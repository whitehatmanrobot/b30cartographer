   DebugEntry(WBP_PersonHandleFirst);

    OM_ObjectH(m_pomClient, m_hWSGroup,
        USER_INFORMATION_WORKSET, 0, ppObjPerson, FIRST);

    DebugExitVOID(WBP_PersonHandleFirst);
}




//
// WBP_PersonHandleNext
//
STDMETHODIMP_(UINT) WbClient::WBP_PersonHandleNext
(
    POM_OBJECT      pObjPerson,
    POM_OBJECT *    ppObjPersonNext
)
{
    UINT            rc;

    DebugEntry(WBP_PersonHandleNext);

    //
    // Get the handle of the next object in the user information workset.
    //
    rc = OM_ObjectH(m_pomClient,
                      m_hWSGroup,
                      USER_INFORMATION_WORKSET,
                      pObjPerson,
                    ppObjPersonNext,
                    AFTER);

    if (rc == OM_RC_NO_SUCH_OBJECT)
    {
        rc = WB_RC_NO_SUCH_PERSON;
    }
    else if (rc != 0)
    {
        ERROR_OUT(("OM_ObjectNextH = %d", rc));
    }


    DebugExitDWORD(WBP_PersonHandleNext, rc);
    return(rc);
}



//
// WBP_PersonHandleLocal
//
STDMETHODIMP_(void) WbClient::WBP_PersonHandleLocal
(
    POM_OBJECT *     ppObjPerson
)
{
    DebugEntry(WBP_PersonHandleLocal);

    *ppObjPerson = m_pObjLocal;

    DebugExitVOID(WBP_PersonHandleLocal);
}



//
// WBP_PersonCountInCall
//
STDMETHODIMP_(UINT) WbClient::WBP_PersonCountInCall(void)
{
    UINT        count;
    POM_OBJECT  pObj;

    DebugEntry(WBP_PersonCountInCall);

    //
    // Get the count:
    //
    pObj = NULL;
    WBP_PersonHandleFirst(&pObj);
    for (count = 1; ; count++)
    {
        if (WBP_PersonHandleNext(pObj, &pObj) == WB_RC_NO_SUCH_PERSON)
        {
            break;
        }
    }

    DebugExitDWORD(WBP_PersonCountInCall, count);
    return(count);
}




//
// WBP_GetPersonData
//
STDMETHODIMP_(UINT) WbClient::WBP_GetPersonData
(
    POM_OBJECT      pObjPerson,
    PWB_PERSON      pPerson
)
{
    UINT            rc;

    DebugEntry(WBP_GetPersonData);

    ASSERT(!IsBadWritePtr(pPerson, sizeof(WB_PERSON)));

    //
    // Get the object.
    //
    rc = wbPersonGet(pObjPerson, pPerson);

    DebugExitDWORD(WBP_GetPersonData, rc);
    return(rc);
}



//
// WBP_SetLocalPersonData
//
STDMETHODIMP_(UINT) WbClient::WBP_SetLocalPersonData(PWB_PERSON  pPerson)
{
    UINT        rc;
    POM_OBJECTDATA  pUserObject;

    DebugEntry(WBP_SetPersonData);

    ASSERT(!IsBadReadPtr(pPerson, sizeof(WB_PERSON)));

    //
    // Allocate a user object
    //
    rc = OM_ObjectAlloc(m_pomClient,
                          m_hWSGroup,
                          USER_INFORMATION_WORKSET,
                          sizeof(WB_PERSON),
                          &pUserObject);
    if (rc != 0)
    {
        ERROR_OUT(("OM_ObjectAlloc = %d", rc));
        DC_QUIT;
    }

    //
    // Set the length of the object
    //
    pUserObject->length = sizeof(WB_PERSON);

    //
    // Copy the user information into the ObMan object
    //
    memcpy(pUserObject->data, pPerson, sizeof(WB_PERSON));

    //
    // Replace the user object
    //
    rc = OM_ObjectReplace(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           m_pObjLocal,
                           &pUserObject);
    if (rc != 0)
    {
        ERROR_OUT(("OM_ObjectReplace"));

        //
        // Discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     &pUserObject);

        DC_QUIT;
    }

DC_EXIT_POINT:
    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_UPDATE_IND event will be generated.
    //
    DebugExitDWORD(WBP_SetPersonData, rc);
    return(rc);
}



//
// WBP_PersonUpdateConfirm
//
STDMETHODIMP_(void) WbClient::WBP_PersonUpdateConfirm
(
    POM_OBJECT   pObjPerson
)
{
    DebugEntry(WBP_PersonUpdateConfirm);

    //
    // Confirm the update to ObMan
    //
    OM_ObjectUpdateConfirm(m_pomClient,
                         m_hWSGroup,
                         USER_INFORMATION_WORKSET,
                         pObjPerson);

    DebugExitVOID(WBP_PersonUpdateConfirm);
}




//
// WBP_PersonReplaceConfirm
//
STDMETHODIMP_(void) WbClient::WBP_PersonReplaceConfirm
(
    POM_OBJECT   pObjPerson
)
{
    DebugEntry(WBP_PersonReplaceConfirm);

    //
    // Confirm the replace to ObMan
    //
    OM_ObjectReplaceConfirm(m_pomClient,
                         m_hWSGroup,
                         USER_INFORMATION_WORKSET,
                         pObjPerson);

    DebugExitVOID(WBP_PersonReplaceConfirm);
}



//
// WBP_PersonLeftConfirm
//
STDMETHODIMP_(void) WbClient::WBP_PersonLeftConfirm
(
    POM_OBJECT      pObjPerson
)
{
    DebugEntry(WBP_PersonLeftConfirm);

    //
    // Confirm the update to ObMan
    //
    OM_ObjectDeleteConfirm(m_pomClient,
                         m_hWSGroup,
                         USER_INFORMATION_WORKSET,
                         pObjPerson);

    DebugExitVOID(WBP_PersonLeftConfirm);
}



//
// WBP_SyncPositionGet
//
STDMETHODIMP_(UINT) WbClient::WBP_SyncPositionGet
(
    PWB_SYNC            pSync
)
{
    UINT                result;
    POM_OBJECTDATA      pSyncObject = NULL;
    PWB_SYNC_CONTROL    pSyncControl = NULL;

    DebugEntry(WBP_SyncPositionGet);


    ASSERT(!IsBadWritePtr(pSync, sizeof(WB_SYNC)));

    //
    // Read the Sync Control object
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         SYNC_CONTROL_WORKSET,
                         m_pObjSyncControl,
                         &pSyncObject);
    if (result != 0)
    {
        ERROR_OUT(("Error reading Sync Control Object = %d", result));
        DC_QUIT;
    }

    pSyncControl = (PWB_SYNC_CONTROL) pSyncObject->data;

    //
    // Copy the Sync Person details to the result field
    // NOTE:
    // LiveLan sends a larger object, we need to ignore the stuff past the
    // end.
    //
    if (pSyncControl->sync.length != sizeof(WB_SYNC))
    {
        WARNING_OUT(("WBP_SyncPositionGet (interop): Remote created WB_SYNC of size %d, we expected size %d",
            pSyncControl->sync.length, sizeof(WB_SYNC)));
    }
    memcpy(pSync, &pSyncControl->sync, min(sizeof(WB_SYNC), pSyncControl->sync.length));

    //
    // Release the Sync Control Object
    //
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   SYNC_CONTROL_WORKSET,
                   m_pObjSyncControl,
                   &pSyncObject);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_SyncPositionGet, result);
    return(result);
}



//
// WBP_SyncPositionUpdate
//
STDMETHODIMP_(UINT) WbClient::WBP_SyncPositionUpdate
(
    PWB_SYNC        pSync
)
{
    UINT            result;
    POM_OBJECTDATA      pSyncObject = NULL;
    PWB_SYNC_CONTROL pSyncControl = NULL;

    DebugEntry(WBP_SyncPositionUpdate);

    ASSERT(!IsBadReadPtr(pSync, sizeof(WB_SYNC)));

    //
    // Write the new sync control object (do not create it)
    //
    result = wbWriteSyncControl(pSync, FALSE);

    DebugExitDWORD(WBP_SyncPositionUpdate, result);
    return(result);
}



//
// WBP_CancelLoad
//
STDMETHODIMP_(UINT) WbClient::WBP_CancelLoad(void)
{
    UINT        result = 0;

    DebugEntry(WBP_CancelLoad);

    //
    // Check a load is in progress
    //
    if (m_loadState == LOAD_STATE_EMPTY)
    {
        TRACE_OUT(("request to cancel load, but there is no load in progress"));
        result = WB_RC_NOT_LOADING;
        DC_QUIT;
    }

    TRACE_OUT(("Cancelling load in progress"));

    //
    // Close the file
    //
    if (m_hLoadFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hLoadFile);
        m_hLoadFile = INVALID_HANDLE_VALUE;
    }

    //
    // reset the load state to show we're no longer loading.
    //
    m_loadState = LOAD_STATE_EMPTY;

DC_EXIT_POINT:
    DebugExitDWORD(WBP_CancelLoad, result);
    return(result);
}



//
//
// Name:    WBP_ValidateFile
//
// Purpose: Validate that a passed filename holds a valid whiteboard file
//
// Returns: 0 if successful
//          !0 if an error
//
//
STDMETHODIMP_(UINT) WbClient::WBP_ValidateFile
(
    LPCSTR          pFileName,
    HANDLE *        phFile
)
{
    UINT            result = 0;
    HANDLE          hFile;
    WB_FILE_HEADER  fileHeader;
    UINT            length;
    ULONG           cbSizeRead;
    BOOL            fileOpen = FALSE;

    DebugEntry(WBP_ValidateFile);

    //
    // Open the file
    //
    hFile = CreateFile(pFileName, GENERIC_READ, 0, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        WARNING_OUT(("Error opening file, win32 err=%d", GetLastError()));
        result = WB_RC_CREATE_FAILED;
        DC_QUIT;
    }

    //
    // Show that we have opened the file successfully
    //
    fileOpen = TRUE;

    //
    // Read the file header length
    //
    if (! ReadFile(hFile, (void *) &length, sizeof(length), &cbSizeRead, NULL))
    {
        WARNING_OUT(("Error reading file header length, win32 err=%d", GetLastError()));
        result = WB_RC_READ_FAILED;
        DC_QUIT;
    }
    ASSERT(cbSizeRead == sizeof(length));

    if (length != sizeof(fileHeader))
    {
        WARNING_OUT(("Bad file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }

    //
    // Read the file header
    //
    if (! ReadFile(hFile, (void *) &fileHeader, sizeof(fileHeader), &cbSizeRead, NULL))
    {
        WARNING_OUT(("Error reading file header, win32 err=%d", GetLastError()));
        result = WB_RC_READ_FAILED;
        DC_QUIT;
    }

    if (cbSizeRead != sizeof(fileHeader))
    {
        WARNING_OUT(("Could not read file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }

    //
    // Validate the file header
    //
    if (   (fileHeader.type != TYPE_FILE_HEADER)
        || lstrcmp(fileHeader.functionProfile, WB_FP_NAME))
    {
        WARNING_OUT(("Bad function profile in file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }


DC_EXIT_POINT:

    //
    // Return the handle, if the user needs it.
    //
    if ( (result == 0) && (phFile != NULL))
    {
        TRACE_OUT(("return file handle"));
        *phFile = hFile;
    }

    //
    // Close the file if there has been an error or the caller simply
    // doesnt want the file handle.
    //
    if ( (fileOpen) &&
         ((phFile == NULL) || (result != 0)) )
    {
        CloseHandle(hFile);
    }

    DebugExitDWORD(WBP_ValidateFile, result);
    return(result);
}




//
//
// Name:    wbGraphicLocked
//
// Purpose: Test whether a client has a lock on the specified graphic, and
//          if so, return the person handle of the client holding the lock.
//
// Returns: TRUE  if a client has a lock
//          FALSE otherwise
//
//
BOOL WbClient::wbGraphicLocked
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    POM_OBJECT *     ppObjLock
)
{
    BOOL            result = FALSE;
    UINT            rc;
    PWB_GRAPHIC     pGraphic = NULL;

    DebugEntry(wbGraphicLocked);

    //
    // Read the object
    //
    if (WBP_GraphicGet(hPage, hGraphic, &pGraphic) != 0)
    {
        DC_QUIT;
    }

    //
    // Look at its lock details
    //
    if (pGraphic->locked != WB_GRAPHIC_LOCK_NONE)
    {
        //
        // The lock flag in the graphic is set
        //

        //
        // Convert the lock user ID in the graphic to a handle
        //
        rc = OM_ObjectIDToPtr(m_pomClient,
                                 m_hWSGroup,
                                 USER_INFORMATION_WORKSET,
                                 pGraphic->lockPersonID,
                                 ppObjLock);

        if (rc == 0)
        {

            TRACE_OUT(("Graphic is locked"));
            result = TRUE;
            DC_QUIT;
        }

        if (rc != OM_RC_BAD_OBJECT_ID)
        {
            //
            // An error occurred in converting the objectID
            //
            TRACE_OUT(("Error converting object ID to handle"));
            DC_QUIT;
        }
    }

    //
    // The object is not locked (or the lock user has left the call)
    //
    TRACE_OUT(("Graphic is not locked"));


DC_EXIT_POINT:
    //
    // If the graphic is still held by us, release it
    //
    if (pGraphic != NULL)
    {
        WBP_GraphicRelease(hPage, hGraphic, pGraphic);
    }

    DebugExitBOOL(wbGraphicLocked, result);
    return(result);
}




//
//
// Name:    wbAddLocalUserObject
//
// Purpose: Add an object to the user information workset for the local
//          user.
//
// Returns: Error code
//
//
UINT WbClient::wbAddLocalUserObject(void)
{
    UINT            rc;
    POM_OBJECTDATA     pData;
    PWB_PERSON      pUser;
    CM_STATUS       cmStatus;

    DebugEntry(wbAddLocalUserObject);

    TRACE_OUT(("Adding the necessary control objects"));

    //
    // Build a user object for this user and write it to the User Information
    // Workset.
    //
    rc = OM_ObjectAlloc(m_pomClient,
                      m_hWSGroup,
                      USER_INFORMATION_WORKSET,
                      sizeof(WB_PERSON),
                      &pData);
    if (rc != 0)
    {
        ERROR_OUT(("Error allocating object = %d", rc));
        DC_QUIT;
    }

    pData->length = sizeof(WB_PERSON);
    pUser = (PWB_PERSON) (pData->data);

    //
    // Initialize the contents of the user object for this user
    //
    TRACE_OUT(("Initialising user contents"));

    ZeroMemory(pUser, sizeof(WB_PERSON));

    pUser->currentPage        = FIRST_PAGE_WORKSET; // lonchanc: it was 1.
    pUser->synced             = FALSE;
    pUser->pointerActive      = FALSE;
    pUser->pointerPage        = FIRST_PAGE_WORKSET; // lonchanc: it was 1.
    pUser->colorId            = (TSHR_UINT16)wbSelectPersonColor();

    //
    // Fill in the Call Manager personID if we are in a call.
    //
    if (CMS_GetStatus(&cmStatus))
    {
        TRACE_OUT(("CMG personID %u", cmStatus.localHandle));
        pUser->cmgPersonID = cmStatus.localHandle;
    }
    else
    {
        pUser->cmgPersonID = 0;
    }

    //
    // Copy the user name into the object:
    //
    lstrcpy(pUser->personName, cmStatus.localName);

    //
    // Copy the person's color into the client's data
    //
    m_colorId = pUser->colorId;

    //
    // Add the object to the User Information Workset, saving the handle of
    // the user object in the client details.
    //
    rc = OM_ObjectAdd(m_pomClient,
                        m_hWSGroup,
                        USER_INFORMATION_WORKSET,
                        &pData,
                        WB_PERSON_OBJECT_UPDATE_SIZE,
                        &m_pObjLocal,
                        LAST);
    if (rc != 0)
    {
        //
        // The add failed, we must discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     &pData);

        ERROR_OUT(("Error adding user object = %d", rc));
        DC_QUIT;
    }

    //
    // Save the ID of this user in the client details (for later use in the
    // lock information).
    //
    OM_ObjectPtrToID(m_pomClient,
                      m_hWSGroup,
                      USER_INFORMATION_WORKSET,
                      m_pObjLocal,
                      &(m_personID));

DC_EXIT_POINT:
    DebugExitDWORD(wbAddLocalUserObject, rc);
    return(rc);
}



//
//
// Name:    wbGetEmptyPageHandle
//
// Purpose: Return a handle for a page that does not have its workset open.
//
// Returns: Handle of free page (or 0 if none exists)
//
//
WB_PAGE_HANDLE WbClient::wbGetEmptyPageHandle(void)
{
    UINT    index;
    WB_PAGE_HANDLE hPage = WB_PAGE_HANDLE_NULL;
    PWB_PAGE_STATE pPageState = m_pageStates;

    //
    // Search the page list for an empty entry
    //
    for (index = 0; index < WB_MAX_PAGES; index++, pPageState++)
    {
        if (   (pPageState->state == PAGE_NOT_IN_USE)
            && (pPageState->subState == PAGE_STATE_EMPTY))
        {
            hPage = PAGE_INDEX_TO_HANDLE(index);
            break;
        }
    }


    return(hPage);
}



//
//
// Name:    wbGetReadyPageHandle
//
// Purpose: Return a handle for a page that has its workset open but is not
//          currently in use.
//
// Returns: Handle of free page (or 0 if none exists)
//
//
WB_PAGE_HANDLE WbClient::wbGetReadyPageHandle(void)
{
    UINT       index;
    WB_PAGE_HANDLE hPage = WB_PAGE_HANDLE_NULL;
    PWB_PAGE_STATE pPageState = m_pageStates;

    //
    // Search the page list for a ready entry
    //
    for (index = 0; index < WB_MAX_PAGES; index++, pPageState++)
    {
        if (   (pPageState->state == PAGE_NOT_IN_USE)
             && (pPageState->subState == PAGE_STATE_READY))
        {
            hPage = PAGE_INDEX_TO_HANDLE(index);
            break;
        }
    }

    return(hPage);
}



//
//
// Name:    wbPageOrderPageNumber
//
// Purpose: Return the number of the specified page.
//          This function performs no validation on its parameters.
//
// Returns: None
//
//
UINT WbClient::wbPageOrderPageNumber
(
    PWB_PAGE_ORDER pPageOrder,
    WB_PAGE_HANDLE hPage
)
{
    UINT       index;
    POM_WORKSET_ID pPage = pPageOrder->pages;

    DebugEntry(wbPageOrderPageNumber);

    //
    // Search the page order list for the page handle (workset ID)
    //
    for (index = 0; index <= pPageOrder->countPages; index++)
    {
        if (pPage[index] == (OM_WORKSET_ID)hPage)
        {
            DC_QUIT;
        }
    }

    //
    // The page was not found - this is an internal error
    //
    ERROR_OUT(("Page handle not found"));

  //
  // Return the page number starting from 1.
  //
DC_EXIT_POINT:
    DebugExitDWORD(wbPageOrderPageNumber, index + 1);
    return(index + 1);
}



//
//
// Name:    wbPageOrderPageAdd
//
// Purpose: Add a new page to a page order structure. This function expects
//          the parameters to be valid - they must be checked before
//          calling it. It also assumes that there is space in the page
//          list for the new page.
//
// Params:  pPageOrder - pointer to page list
//          hRefPage   - page used as a reference point for the new page
//          hPage      - handle of the page to be added
//          where      - relative position - before or after hRefPage
//
// Returns: None
//
//
void WbClient::wbPageOrderPageAdd
(
    PWB_PAGE_ORDER  pPageOrder,
    WB_PAGE_HANDLE  hRefPage,
    WB_PAGE_HANDLE  hPage,
    UINT            where
)
{
    UINT            index;
    POM_WORKSET_ID  pPage = pPageOrder->pages;

    DebugEntry(wbPageOrderPageAdd);

    //
    // Process according to the add position
    //
    switch(where)
    {
        case PAGE_FIRST:
            index = 0;
            if (pPageOrder->countPages != 0)
            {
                UT_MoveMemory(&pPage[1], &pPage[0], pPageOrder->countPages*sizeof(pPage[0]));
            }
            break;

        case PAGE_LAST:
            index = pPageOrder->countPages;
            break;

        case PAGE_AFTER:
        case PAGE_BEFORE:
            //
            // Make an empty space in the page order list
            //
            index = wbPageOrderPageNumber(pPageOrder, hRefPage);
            if (where == PAGE_BEFORE)
            {
                index--;
            }

            UT_MoveMemory(&pPage[index + 1], &pPage[index],
              (pPageOrder->countPages - index)*sizeof(pPage[0]));
            break;

        default:
            ERROR_OUT(("Bad where parameter"));
    }

    //
    // Save the new page handle in the list
    //
    pPage[index] = hPage;

    //
    // Show that the extra page is now present
    //
    pPageOrder->countPages += 1;

    DebugExitVOID(wbPageOrderPageAdd);
}




//
//
// Name:    wbPageOrderPageDelete
//
// Purpose: Remove the specified page from a page order structure. This
//          function expects its the parameters to be valid - they must be
//          checked before calling it.
//
// Returns: None
//
//
void WbClient::wbPageOrderPageDelete
(
    PWB_PAGE_ORDER  pPageOrder,
    WB_PAGE_HANDLE  hPage
)
{
    UINT            index;
    POM_WORKSET_ID  pPage = pPageOrder->pages;

    DebugEntry(wbPageOrderPageDelete);

    index = wbPageOrderPageNumber(pPageOrder, hPage);
    UT_MoveMemory(&pPage[index - 1],
             &pPage[index],
             (pPageOrder->countPages - index)*sizeof(pPage[0]));

    pPageOrder->countPages -= 1;

    DebugExitVOID(wbPageOrderPageDelete);
}




//
//
// Name:    wbPagesPageAdd
//
// Purpose: Add a new page to the internal page list. This function expects
//          the parameters to be valid - they must be checked before
//          calling it. It also assumes that there is space in the page
//          list for the new page.
//
// Returns: None
//
//
void WbClient::wbPagesPageAdd
(
    WB_PAGE_HANDLE  hRefPage,
    WB_PAGE_HANDLE  hPage,
    UINT            where
)
{
    PWB_PAGE_STATE pPageState;

    DebugEntry(wbPagesPageAdd);

    //
    // Add the page to the page order structure
    //
    wbPageOrderPageAdd(&(m_pageOrder), hRefPage, hPage, where);

    //
    // Update the page state information
    //
    pPageState = GetPageState(hPage);
    pPageState->state    = PAGE_IN_USE;
    pPageState->subState = PAGE_STATE_EMPTY;

    DebugExitVOID(wbPagesPageAdd);
}



//
//
// Name:    wbClientReset
//
// Purpose: Reset the client data to a state where the client is not in a
//          call, but is registered with ObMan and has event and exit
//          handlers registered with utilities.
//
// Returns: None
//
//
void WbClient::wbClientReset(void)
{
    UINT       index;
    PWB_PAGE_ORDER pPageOrder = &(m_pageOrder);
    PWB_PAGE_STATE pPageState = m_pageStates;

    DebugEntry(wbClientReset);

    //
    // Initialize object handles
    //
    m_hWSGroup          = (OM_WSGROUP_HANDLE) NULL;

    m_pObjPageControl   = NULL;
    m_pObjSyncControl   = NULL;
    m_pObjLocal         = NULL;

    m_pObjLock          = NULL;
    m_pObjPersonLock    = NULL;

    //
    // Initialize the status variables
    //
    m_errorState        = ERROR_STATE_EMPTY;
    m_changed           = FALSE;
    m_lockState         = LOCK_STATE_EMPTY;
    m_lockType          = WB_LOCK_TYPE_NONE;
    m_lockRequestType   = WB_LOCK_TYPE_NONE;

    m_loadState         = LOAD_STATE_EMPTY;
    if (m_hLoadFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hLoadFile);
        m_hLoadFile    = INVALID_HANDLE_VALUE;
    }

    m_countReadyPages   = 0;


    //
    // Zero the whole structure
    //
    ZeroMemory(pPageOrder, sizeof(*pPageOrder));

    //
    // Set the object type
    //
    pPageOrder->objectType = TYPE_CONTROL_PAGE_ORDER;

    //
    // Set up the page control elements
    //
    pPageOrder->generationLo   = 1;
    pPageOrder->generationHi   = 0;
    pPageOrder->countPages     = 0;

    //
    // Initialize the page state structures
    //
    for (index = 0; index < WB_MAX_PAGES; index++, pPageState++)
    {
        pPageState->state = PAGE_NOT_IN_USE;
        pPageState->subState = PAGE_STATE_EMPTY;
    }

    DebugExitVOID(wbClientReset);
}




//
//
// Name:    wbOnWsGroupRegisterCon
//
// Purpose: Routine processing OM_WSGROUP_REGISTER_CON events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWsGroupRegisterCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL        processed;

    DebugEntry(wbOnWsGroupRegisterCon);

    //
    // Check that this is the event we are expecting
    //
    if (pEvent32->correlator != m_wsgroupCorrelator)
    {
        //
        // We are not expecting this event, this means that it must be for a
        // workset group which we wanted to deregister from (but had not yet
        // received confirmation). So deregister immediately.
        //

        //
        // Check that the return code for the registration is OK
        //
        if (pEvent32->result == 0)
        {
            OM_WSGroupDeregister(m_pomClient, &(pEvent16->hWSGroup));
        }

        processed = FALSE;
        DC_QUIT;
    }

    //
    // Show that we have processed the event
    //
    processed = TRUE;

    //
    // Test for the correct state
    //
    if (m_subState != STATE_REG_PENDING_WSGROUP_CON)
    {
        //
        // We are not in the correct state for this event - this is an internal
        // error.
        //
        ERROR_OUT(("Not in correct state for WSGroupRegisterCon"));
        DC_QUIT;
    }

    //
    // Check that the return code for the registration is OK
    //
    if (pEvent32->result != 0)
    {
        //
        // Registration with the workset group failed - tidy up
        //
        wbError();

        DC_QUIT;
    }

    //
    // Registration with the workset group succeeded
    //
    m_hWSGroup = pEvent16->hWSGroup;

    //
    // Get the clients network ID, used in graphic objects to determine where
    // they are loaded.
    //
    if (!wbGetNetUserID())
    {
        //
        // Tidy up (and post an error event to the client)
        //
        ERROR_OUT(("Failed to get user ID"));
        wbError();
        DC_QUIT;
    }

    //
    // Start opening the worksets.  We open them one at a time and wait for
    // the response to avoid flooding the message queue.
    // The user information workset is given high priority.  This allows
    // remote pointer movements to travel quickly.
    //
    if (OM_WorksetOpenPReq(m_pomClient,
                          m_hWSGroup,
                          USER_INFORMATION_WORKSET,
                          NET_HIGH_PRIORITY,
                          TRUE,
                          &(m_worksetOpenCorrelator)) != 0)
    {
        ERROR_OUT(("User Information Workset Open Failed"));
        wbError();
        DC_QUIT;
    }

    //
    // Move to the next state
    //
    m_subState = STATE_REG_PENDING_USER_WORKSET;

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWsGroupRegisterCon, processed);
    return(processed);
}



//
//
// Name:    wbOnWorksetOpenCon
//
// Purpose: Routine processing OM_WORKSET_OPEN_CON events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWorksetOpenCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;
    OM_WORKSET_ID eventWorksetID;

    DebugEntry(wbOnWorksetOpenCon);

    //
    // Process according to the workset ID
    //
    eventWorksetID = pEvent16->worksetID;

    //
    // If the event is for a page workset
    //
    if (eventWorksetID >= FIRST_PAGE_WORKSET)
    {
        //
        // We are opening a page workset
        //
        processed = wbOnPageWorksetOpenCon(param1, param2);
        if (!processed)
        {
            DC_QUIT;
        }
    }

    //
    // We are done if this is a page workset other than the 1st page workset
    //
    if (eventWorksetID > FIRST_PAGE_WORKSET)
    {
        DC_QUIT;
    }

    //
    // Now check if it is one of the control worksets (the first page workset
    // is both a control workset and a page workset).
    //
    if (eventWorksetID != FIRST_PAGE_WORKSET)
    {
        //
        // Check the message correlator
        //
        if (pEvent32->correlator != m_worksetOpenCorrelator)
        {
            TRACE_OUT(("Correlators do not match - quitting"));
            DC_QUIT;
        }
    }

    //
    // We are opening a control workset - process the event
    //
    wbOnControlWorksetOpenCon(param1, param2);
    processed = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWorksetOpenCon, processed);
    return(processed);
}




//
//
// Name:    wbOnControlWorksetOpenCon
//
// Purpose: Routine processing OM_WORKSET_OPEN_CON events for control
//          worksets.
//
// Returns: Error code
//
//
void WbClient::wbOnControlWorksetOpenCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    UINT            rc;
    OM_WORKSET_ID   eventId;

    DebugEntry(wbOnControlWorksetOpenCon);

    //
    // Check the return code in the open
    //
    if (pEvent32->result != 0)
    {
        ERROR_OUT(("Error reported on workset open = %d", pEvent32->result));
        wbError();
        DC_QUIT;
    }

    //
    // If we are in registration, we are opening the required worksets -
    // continue the process.
    //
    if (m_state > STATE_REGISTERING)
    {
        ERROR_OUT(("Control workset open con after registration"));
    }

    //
    // Set up for opening the next workset
    //
    eventId = pEvent16->worksetID;
    switch(eventId)
    {
        case USER_INFORMATION_WORKSET:
            //
            // The user information workset is given high priority.  This allows
            // remote pointer movements to travel quickly.
            //
            TRACE_OUT(("Opening Page Control workset"));
            rc = OM_WorksetOpenPReq(m_pomClient,
                              m_hWSGroup,
                              PAGE_CONTROL_WORKSET,
                              NET_HIGH_PRIORITY,
                              FALSE,
                              &(m_worksetOpenCorrelator));

            m_subState = STATE_REG_PENDING_WORKSET_OPEN;
            break;

        case PAGE_CONTROL_WORKSET:
            //
            // The sync control workset is given high priority to allow sync
            // updates to travel quickly.
            //
            TRACE_OUT(("Opening Sync Control workset"));
            rc = OM_WorksetOpenPReq(m_pomClient,
                              m_hWSGroup,
                              SYNC_CONTROL_WORKSET,
                              NET_HIGH_PRIORITY,
                              FALSE,
                              &(m_worksetOpenCorrelator));
            break;

        case SYNC_CONTROL_WORKSET:
            //
            // Open the first of the page worksets - we must do this to allow us
            // to use it as the only page available if we are the first person in
            // the call.
            //
            TRACE_OUT(("Opening first page workset"));
            rc = wbPageWorksetOpen((WB_PAGE_HANDLE)FIRST_PAGE_WORKSET,
                             OPEN_LOCAL);
            break;

        case FIRST_PAGE_WORKSET:
            break;

        default:
            ERROR_OUT(("Bad workset ID"));
            break;
    }

    //
    // Check whether we have just opened another workset
    //
    if (eventId != FIRST_PAGE_WORKSET)
    {
        //
        // Test the return code from the open
        //
        if (rc != 0)
        {
            ERROR_OUT(("Workset open failed = %d", rc));
            wbError();
        }

        DC_QUIT;
    }

    //
    // We have now opened all the control worksets. We now add the required
    // control objects.
    //
    rc = wbAddLocalUserObject();
    if (rc != 0)
    {
        //
        // Stop the join call process, tidy up and send an error message to the
        // client.
        //
        wbError();
        DC_QUIT;
    }

    m_subState = STATE_REG_USER_OBJECT_ADDED;
    TRACE_OUT(("Moved to substate STATE_REG_USER_OBJECT_ADDED"));

    //
    // Check whether the Page Control objects are available yet (they could
    // have been added by another user in the call).
    //
    TRACE_OUT(("%x PAGE WS object, %x SYNC WS object",
                                               m_pObjPageControl,
                                               m_pObjSyncControl));
    if ( (m_pObjPageControl == 0) &&
         (m_pObjSyncControl == 0))
    {
        TRACE_OUT(("No control objects - WE MIGHT BE FIRST IN CALL - get lock"));

        //
        // We may be the first user to register - request the lock on the Page
        // Control Workset.
        //
        rc = wbLock(WB_LOCK_TYPE_PAGE_ORDER);
		if (rc != 0)
        {
            ERROR_OUT(("Error from wbLock = %d", rc));
            wbError();
			DC_QUIT;
        }

        //
        // Set the new registration state
        //
        m_subState = STATE_REG_PENDING_LOCK;
        TRACE_OUT(("Moved to substate STATE_REG_PENDING_LOCK"));
        DC_QUIT;
    }
    else
    {
        if (m_pObjSyncControl == 0)
        {
            TRACE_OUT(("Waiting for sync control"));
            m_subState = STATE_REG_PENDING_SYNC_CONTROL;
            DC_QUIT;
        }

        if (m_pObjPageControl == 0)
        {
            TRACE_OUT(("Waiting for page control"));
            m_subState = STATE_REG_PENDING_PAGE_CONTROL;
            DC_QUIT;
        }
    }

    //
    // Complete registration
    //
    TRACE_OUT(("Page Control and Sync Control objects both there."));
    TRACE_OUT(("Registration can be completed"));

    wbOnControlWorksetsReady();


DC_EXIT_POINT:
    DebugExitVOID(wbOnControlWorksetOpenCon);
}




//
//
// Name:    wbPageWorksetOpen
//
// Purpose: Open a page workset
//
// Returns: Error code
//
//
UINT WbClient::wbPageWorksetOpen
(
    WB_PAGE_HANDLE  hPage,
    UINT            localOrExternal
)
{
    UINT            result;
    PWB_PAGE_STATE  pPageState;

    DebugEntry(wbPageWorksetOpen);

    //
    // Get the page state
    //
    pPageState = GetPageState(hPage);
    ASSERT((pPageState->state == PAGE_NOT_IN_USE));
    ASSERT((pPageState->subState == PAGE_STATE_EMPTY));

    //
    // Open the workset. We allow ObMan to choose the priority, this means
    // that ObMan uses a variable priority scheme allowing small objects to
    // overtake large ones.
    //
    result = OM_WorksetOpenPReq(m_pomClient,
                              m_hWSGroup,
                              (OM_WORKSET_ID)hPage,
                              OM_OBMAN_CHOOSES_PRIORITY,
                              FALSE,
                              &(pPageState->worksetOpenCorrelator));
    if (result != 0)
    {
        ERROR_OUT(("WorksetOpen failed = %d", result));
        DC_QUIT;
    }

    //
    // Update the page state
    //
    if (localOrExternal == OPEN_LOCAL)
    {
        pPageState->subState = PAGE_STATE_LOCAL_OPEN_CONFIRM;
        TRACE_OUT(("Moved page %d state to PAGE_STATE_PENDING_OPEN_CONFIRM",
                                                           (UINT) hPage));
    }
    else
    {
        pPageState->subState = PAGE_STATE_EXTERNAL_OPEN_CONFIRM;
        TRACE_OUT(("Moved page %d state to PAGE_STATE_PENDING_OPEN_CONFIRM",
                                                           (UINT) hPage));
    }

DC_EXIT_POINT:
    DebugExitDWORD(wbPageWorksetOpen, result);
    return(result);
}




//
//
// Name:    wbOnPageWorksetOpenCon
//
// Purpose: Routine processing OM_WORKSET_OPEN_CON events for page worksets
//
// Returns: Error code
//
//
BOOL WbClient::wbOnPageWorksetOpenCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;
    OM_WORKSET_ID    eventId;
    PWB_PAGE_STATE   pPageState;
    WB_PAGE_HANDLE   hPage;
    UINT         oldState;

    DebugEntry(wbOnPageWorksetOpenCon);

    //
    // Get the page state pointer
    //
    eventId = pEvent16->worksetID;
    hPage   = (WB_PAGE_HANDLE)eventId;
    pPageState = GetPageState(hPage);

    //
    // Check the message correlator
    //
    if (pEvent32->correlator != pPageState->worksetOpenCorrelator)
    {
        TRACE_OUT(("Correlators do not match - quitting"));
        DC_QUIT;
    }

    //
    // Show that we have processed this event
    //
    processed = TRUE;

    //
    // Check the return code in the open
    //
    if (pEvent32->result != 0)
    {
        ERROR_OUT(("Error reported on page workset open = %d",
             pEvent32->result));

        pPageState->subState = PAGE_STATE_EMPTY;
        TRACE_OUT(("Moved page %d substate to PAGE_STATE_EMPTY",
             (UINT)hPage));
        DC_QUIT;
    }

    //
    // Update the page state to indicate that the page is now ready for use
    //
    oldState = pPageState->subState;
    pPageState->subState = PAGE_STATE_READY;
    TRACE_OUT(("Moved page %d to substate to PAGE_STATE_READY",
           (UINT)hPage));

    switch (oldState)
    {
        case PAGE_STATE_LOCAL_OPEN_CONFIRM:
            //
            // This workset was opened locally, therefore it is being opened as
            // part of the workset cache. Nothing more to do.
            //
            break;

        case PAGE_STATE_EXTERNAL_OPEN_CONFIRM:
            //
            // This workset was opened as a result of external updates to the
            // Page Control object.  We therefore need to add the page to the
            // page list now that the workset is open.  We no longer know where
            // the page is to be added - so call the main Page Control update
            // routine again to get all the information.
            //
            wbProcessPageControlChanges();
            break;

        default:
            ERROR_OUT(("Bad page state %d", pPageState->subState));
            break;
    }

    //
    // Increment the number of pages in ready state.  This count is never
    // decremented - once a workset is open it stays open.
    //
    m_countReadyPages += 1;

    //
    // If we are in registration and are waiting for the cache of ready
    // pages, we must complete registration now.
    //
    if ( (m_state == STATE_REGISTERING) &&
         (m_subState == STATE_REG_PENDING_READY_PAGES) )
    {
        //
        // If there are enough pages in the cache
        //
        if (wbCheckReadyPages())
        {
            //
            // We have enough ready pages - complete registration
            //
            wbCompleteRegistration();
            DC_QUIT;
        }

        //
        // There are not yet enough pages in the cache.  CheckReadyPages will
        // have made a new workset open request, so we will receive another
        // workset open confirm soon.
        //
        DC_QUIT;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnPageWorksetOpenCon, processed);
    return(processed);
}



//
//
// Name:    wbOnWorksetLockCon
//
// Purpose: Routine processing OM_WORKSET_LOCK_CON events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWorksetLockCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;
    UINT            rc;

    DebugEntry(wbOnWorksetLockCon);

    //
    // Check the message correlator
    //
    if (pEvent32->correlator != m_lockCorrelator)
    {
        DC_QUIT;
    }

    //
    // The message is for us - set the result to "processed"
    //
    processed = TRUE;

    //
    // Check that the event is for the Page Control Workset (this is the
    // only expected workset).
    //
    if (pEvent16->worksetID != PAGE_CONTROL_WORKSET)
    {
        ERROR_OUT(("Unexpected workset in LockCon = %d",
                                                       pEvent16->worksetID));
    }

    //
    // Process according to the current lock state
    //
    switch (m_lockState)
    {
        //
        // We were waiting for lock confirmation
        //
        case LOCK_STATE_PENDING_LOCK:
            //
            // Check the return code in the event
            //
            if (pEvent32->result != 0)
            {
                TRACE_OUT(("Posting WBP_EVENT_LOCK_FAILED, rc %d",
                                                           pEvent32->result));
                WBP_PostEvent(0,                      // No delay
                             WBP_EVENT_LOCK_FAILED,  // Lock request failed
                             0,                      // No parameters
                             0);

                //
                // The lock failed - update the state.  This means that
                // another user has acquired the lock.  We expect to get a
                // lock object add indication soon.
                //
                m_lockState = LOCK_STATE_EMPTY;
                TRACE_OUT(("Lock request failed - lock state is now EMPTY"));
                DC_QUIT;
            }

            //
            // Write the lock details to the Page Control Workset
            //
            rc = wbWriteLock();
            if (rc != 0)
            {
                ERROR_OUT(("Unable to write lock details = %d", rc));

                //
                // Tidy up by unlocking the Page Control Workset
                //
                OM_WorksetUnlock(m_pomClient,
                                 m_hWSGroup,
                                 PAGE_CONTROL_WORKSET);

                //
                // Tell the client of the failure
                //
                TRACE_OUT(("Posting WBP_EVENT_LOCK_FAILED"));
                WBP_PostEvent(0,                      // No delay
                             WBP_EVENT_LOCK_FAILED,  // Lock request failed
                             0,                      // No parameters
                             0);

                //
                // Update the lock state
                //
                m_lockState = LOCK_STATE_EMPTY;
                TRACE_OUT(("Moved lock state to LOCK_STATE_EMPTY"));
                DC_QUIT;
            }

            //
            // Once we get here the write of the lock object above will
            // trigger an object add event that completes the lock
            // processing.
            //
            m_lockState = LOCK_STATE_PENDING_ADD;
            TRACE_OUT(("Moved lock state to LOCK_STATE_PENDING_ADD"));
            break;

        //
        // The application has cancelled the lock request before it has had
        // time to complete - tidy up.
        //
        case LOCK_STATE_CANCEL_LOCK:
            TRACE_OUT(("LOCK_STATE_CANCEL_LOCK"));

            //
            // If the request failed, just reset the state.
            //
            //
            // The lock was cancelled - unlock the workset if necessary,
            // and notify the front-end of the unlock.
            //
            if (pEvent32->result == 0)
            {
                //
                // We have locked the workset successfully, but in the
                // meantime the front-end has cancelled the lock, so unlock
                // the workset now.
                //
                TRACE_OUT((
                      "Lock cancelled before workset locked, so unlock now"));
                OM_WorksetUnlock(m_pomClient,
                                 m_hWSGroup,
                                 PAGE_CONTROL_WORKSET);
            }
            m_lockState = LOCK_STATE_EMPTY;

            //
            // Tell the app that we have cancelled the lock.
            //
            TRACE_OUT(("Posting WBP_EVENT_UNLOCKED"));
            WBP_PostEvent(0,
                         WBP_EVENT_UNLOCKED,
                         0,
                         0);
            break;

        //
        // Another has got in before us
        //
        case LOCK_STATE_LOCKED_OUT:

            //
            // We have received a lock confirmation and should have been
            // expecting the lock.  But we are locked out.  This means that
            // another user has got in just before us, acquired the lock
            // and added the lock object.  We have processed the add and
            // changed the lock state accordingly.  This lock confirmation
            // will therefore normally be a failure. If by some fluke it
            // isn't, then we treat it as a failure for safety.
            //
            if (pEvent32->result == 0)
            {
                ERROR_OUT(("Lock violation"));

                //
                // Tidy up by unlocking the Page Control Workset - leave
                // the state as LOCKED_OUT; we'll clear it on receipt of
                // the unlock (either local, or from the locking user).
                //
                OM_WorksetUnlock(m_pomClient,
                                 m_hWSGroup,
                                 PAGE_CONTROL_WORKSET);
            }
            break;

        default:
            ERROR_OUT(("Bad lock state %d", m_lockState));
            break;
    } // Switch on lock state

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWorksetLockCon, processed);
    return(processed);
}



//
//
// Name:    wbOnWorksetUnlockInd
//
// Purpose: Routine processing OM_WORKSET_UNLOCK_IND events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWorksetUnlockInd
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = TRUE;

    DebugEntry(wbOnWorksetUnlockInd);

    //
    // We are only interested if the workset id is that of the Page Control
    // Workset.
    //
    if (pEvent16->worksetID != PAGE_CONTROL_WORKSET)
    {
        TRACE_OUT(("Unexpected workset in unlock = %d", pEvent16->worksetID));
        DC_QUIT;
    }

    switch (m_lockState)
    {
        //
        // We had the lock and are waiting to unlock or another user had
        // the lock and has now removed it.
        //
        case LOCK_STATE_LOCKED_OUT:
            //
            // We received the unlock of the workset before the removal of
            // the lock object; we just ignore this, since the deletion of
            // the lock object is our indication that the wb lock is removed.
            //
            TRACE_OUT(("Unlock of page control workset while locked out"));
            break;

        //
        // We are unlocking after an error acquiring the lock or after a
        // user has cancelled alock before we had time to complete it.
        //
        case LOCK_STATE_CANCEL_LOCK:

            //
            // An error occurred in getting the lock - the client has
            // already been informed so we just record the state change.
            //
            m_lockState = LOCK_STATE_EMPTY;
            TRACE_OUT(("Moved lock state to LOCK_STATE_EMPTY"));
            break;

        //
        // We are waiting for the lock - but have got an unlock instead.
        // This could be from another user, or from previous aborted
        // attempts by us to get the lock.  We ignore the event and wait
        // for our lock confirmation.
        //
        case LOCK_STATE_PENDING_LOCK:
            TRACE_OUT((
                "Got unlock indication while waiting for lock confirmation"));
            break;

        //
        // We can get an unlock indication without ever having seen the
        // lock object if the lock object was never added (failure at
        // another user) or if ObMan has spoiled the add and delete.
        //
        case LOCK_STATE_EMPTY:
            TRACE_OUT(("Unlock received in LOCK_STATE_EMPTY - ignoring"));
            break;

		//
        // Unlock not expected in this state
        //
        default:
            ERROR_OUT(("Bad lock state %d", m_lockState));
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnWorksetUnlockInd, processed);
    return(processed);
}



//
//
// Name:    wbOnControlWorksetsReady
//
// Purpose: The control worksets have been opened and set up. Continue the
//          registration process by updating the internal page order to
//          ensure that in matches the external order.
//
// Returns: Error code
//
//
void WbClient::wbOnControlWorksetsReady(void)
{
    DebugEntry(wbOnControlWorksetsReady);

    //
    // Read the Page Control object and compare its content to the internal
    // Page Order.
    //
    wbProcessPageControlChanges();

    //
    // Update the state to show that we are waiting for the Page Order
    // Updated event indicating that the internal page order now matches
    // the external order.
    //
    m_subState = STATE_REG_PENDING_PAGE_ORDER;
    TRACE_OUT(("Moved sub state to STATE_REG_PENDING_PAGE_ORDER"));

    DebugExitVOID(wbOnControlWorksetsReady);
}



//
//
// Name:    wbCompleteRegistration
//
// Purpose: Perform the final steps in registering a client.  These are:
//          post a WB_EVENT_REGISTERED event to the client; check if
//          another user has a lock on the contents or page order, if so,
//          post a WB_EVENT_CONTENTS_LOCKED or WB_EVENT_PAGE_ORDER_LOCKED
//          to the client.
//
// Returns: Error code
//
//
void WbClient::wbCompleteRegistration(void)
{
    DebugEntry(wbCompleteRegistration);

    //
    // Inform the client that we are fully registered
    //
    TRACE_OUT(("Posting WBP_EVENT_REGISTER_OK"));
    WBP_PostEvent(0,                               // No delay
                 WBP_EVENT_JOIN_CALL_OK,          // Fully registered
                 0,                               // No parameters
                 0);

    //
    // Notify the client of the lock status
    //
    wbSendLockNotification();

    //
    // Record that we are now fully registered
    //
    m_state = STATE_IDLE;
    m_subState = STATE_EMPTY;
    TRACE_OUT(("Moved to state STATE_IDLE"));

    DebugExitVOID(wbCompleteRegistration);
}



//
//
// Name:    wbLeaveCall
//
// Purpose: Remove a client from a call/workset group
//
// Returns: None
//
//
void WbClient::wbLeaveCall(void)
{
    DebugEntry(wbLeaveCall);

    //
    // If we have not got far enough to have entered a call - leave now
    // (there is nothing to tidy up).
    //
    if (m_state < STATE_REGISTERING)
    {
        DC_QUIT;
    }

    //
    // If we have the lock - delete the lock object (the workset will be
    // unlocked by ObMan when we deregister).
    //
    if (m_lockState == LOCK_STATE_GOT_LOCK)
    {
        TRACE_OUT(("Still got lock - deleting lock object, handle %d",
                                                      m_pObjLock));
		if (OM_ObjectDelete(m_pomClient,
                                m_hWSGroup,
                                PAGE_CONTROL_WORKSET,
                                m_pObjLock) != 0)
		{
	            ERROR_OUT(("Error deleting lock object"));
		}

        //
        // If all is well at this point the unlock process will be
        // completed when the object delete ind is received.
        //
        m_lockState = LOCK_STATE_PENDING_DELETE;
        TRACE_OUT(("Moved to state LOCK_STATE_PENDING_DELETE"));
    }

    //
    // Fix up the sub state to indicate that all registration actions have
    // been completed (to ensure that they are all undone).
    //
    if (m_state > STATE_REGISTERING)
    {
        m_subState = STATE_REG_END;
        TRACE_OUT(("Moved to substate STATE_REG_END"));
    }

    //
    // Delete the user object representing the local user from the User
    // Information Workset (if it is present).  Note that we are about to
    // deregister from ObMan - this acts as automatic confirmation of the
    // delete request so we do not need to wait for the
    // OM_OBJECT_DELETE_IND event.
    //
    if (m_subState >= STATE_REG_USER_OBJECT_ADDED)
    {
        TRACE_OUT(("Deleting user object"));
        if (OM_ObjectDelete(m_pomClient,
                                 m_hWSGroup,
                                 USER_INFORMATION_WORKSET,
                                 m_pObjLocal) != 0)
        {
            //
            // Trace the error but do not quit - we expect everything to be
            // tidied up when we deregister from ObMan.
            //
            ERROR_OUT(("Error deleting local user object"));
        }
    }

    //
    // If we have already registered with the Workset Group, deregister
    // now.  we have not yet received the confirmation, and get it later we
    // will deregister immediately.
    //
    if (m_subState > STATE_REG_PENDING_WSGROUP_CON)
    {
        OM_WSGroupDeregister(m_pomClient, &(m_hWSGroup));
    }
    else
    {
        //
        // We have not yet received the Workset Group Registration
        // confirmation, change the value in the correlator field so that
        // we recognize the fact that we have cancelled registration later.
        //
        m_wsgroupCorrelator--;
    }

    //
    // Reset the handles of objects added during registration
    //
    TRACE_OUT(("Resetting client data"));
    wbClientReset();

    //
    // Set the client state to the appropriate value
    //
    m_state = STATE_STARTED;
    m_subState = STATE_STARTED_START;
    TRACE_OUT(("Moved state to STATE_STARTED"));

DC_EXIT_POINT:
    DebugExitVOID(wbLeaveCall);
}



//
//
// Name:    wbContentsDelete
//
// Purpose: Remove all the current graphics and pages, leaving a single
//          blank page.
//
// Returns: None
//
//
void WbClient::wbContentsDelete
(
    UINT        changedFlagAction
)
{
    PWB_PAGE_ORDER   pPageOrder = &(m_pageOrder);
    PWB_PAGE_STATE   pPageState;
    UINT         index;

    DebugEntry(wbContentsDelete);

    //
    // Just clear the first page in the list
    //
    wbPageClear(pPageOrder->pages[0], changedFlagAction);

    //
    // If there is only one page left in the list - we're done.
    //
    if (pPageOrder->countPages == 1)
    {
        DC_QUIT;
    }

    //
    // There is more than one page
    //

    //
    // Mark all of the active pages (except the first) as "delete pending"
    //
    for (index = 1; index < pPageOrder->countPages; index++)
    {
        pPageState = GetPageState((pPageOrder->pages)[index]);

        if ((pPageState->state == PAGE_IN_USE) &&
            (pPageState->subState == PAGE_STATE_EMPTY))
        {
            pPageState->subState = PAGE_STATE_LOCAL_DELETE;
        }
    }

    //
    // Write the page control information.  The replace event generated by
    // the write will kick off the actual deletion of the pages marked.
    //
    wbWritePageControl(FALSE);

DC_EXIT_POINT:
    DebugExitVOID(wbContentsDelete);
}



//
//
// Name:    wbStartContentsLoad
//
// Purpose: Start the loading of a file (after the contents have been
//          cleared).
//
// Returns: Error code
//
//
void WbClient::wbStartContentsLoad(void)
{
    DebugEntry(wbStartContentsLoad);

    //
    // Specify the first (and only) page handle as the page to load to
    //
    wbPageHandleFromNumber(1, &m_loadPageHandle);

    //
    // Update the load state to show that we are now loading
    //
    m_loadState = LOAD_STATE_LOADING;
    TRACE_OUT(("Moved load state to LOAD_STATE_LOADING"));

    //
    // Load the first page - subsequent pages are chained from this first one
    //
    wbPageLoad();

    DebugExitVOID(wbStartContentsLoad);
}




//
//
// Name:    wbLock
//
// Purpose: Request the lock for the Whiteboard contents or the page order
//          generating one of the following events:
//
//          WB_EVENT_CONTENTS_LOCKED
//          WB_EVENT_CONTENTS_LOCK_FAILED.
//
// Returns: Error code
//
//
UINT WbClient::wbLock(WB_LOCK_TYPE lockType)
{
    UINT            result = 0;
    OM_CORRELATOR   correlator;

    DebugEntry(wbLock);

    //
    // If we already have the lock we can merely change its status
    //
    if (m_lockState == LOCK_STATE_GOT_LOCK)
    {
        TRACE_OUT(("Already got the lock"));

        m_lockRequestType = lockType;
        result = wbWriteLock();
        DC_QUIT;
    }

    //
    // Request the lock for the Page Control Workset
    //
    result = OM_WorksetLockReq(m_pomClient,
                             m_hWSGroup,
                             PAGE_CONTROL_WORKSET,
                             &correlator);
    if (result != 0)
    {
        ERROR_OUT(("OM_WorksetLockReq failed, result = %d", result));
        DC_QUIT;
    }

    TRACE_OUT(("Requested lock for the Page Control Workset"));

    //
    // Save the lock details
    //

	m_lockState       = LOCK_STATE_PENDING_LOCK;
    m_lockCorrelator  = correlator;
    m_lockRequestType = lockType;

    TRACE_OUT(("Moved lock state to LOCK_STATE_PENDING_LOCK"));
    TRACE_OUT(("Lock type requested = %d", lockType));

    //
    // We return now, further processing is done when the OM_WORKSET_LOCK_CON
    // event is received.
    //

DC_EXIT_POINT:
    DebugExitDWORD(wbLock, result);
    return(result);
}




//
//
// Name:    wbUnlock
//
// Purpose: Unlock the Contents or Page Order.
//
// Returns: Error code
//
//
void WbClient::wbUnlock(void)
{
    DebugEntry(wbUnlock);

    //
    // Check that we have the lock
    //
    if (m_lockState != LOCK_STATE_GOT_LOCK)
    {
        ERROR_OUT(("Local person doesn't have lock"));
        DC_QUIT;
    }

    //
    // Delete the lock object
    //
    TRACE_OUT(("Delete Lock handle %x", m_pObjLock));
    if (OM_ObjectDelete(m_pomClient,
                           m_hWSGroup,
                           PAGE_CONTROL_WORKSET,
                           m_pObjLock) != 0)
    {
        ERROR_OUT(("Could not delete lock object"));
        DC_QUIT;
    }

    //
    // If all is well at this point the unlock process will be completed when
    // the object delete ind is received.
    //
    m_lockState = LOCK_STATE_PENDING_DELETE;
    TRACE_OUT(("Moved to state LOCK_STATE_PENDING_DELETE"));


DC_EXIT_POINT:
    DebugExitVOID(wbUnlock);
}



//
//
// Name:    wbObjectSave
//
// Purpose: Save a structure to file
//
// Returns: Error code
//
//
UINT WbClient::wbObjectSave
(
    HANDLE      hFile,
    LPBYTE      pData,
    UINT        length
)
{
    UINT        result = 0;
    ULONG       cbSizeWritten;

    DebugEntry(wbObjectSave);

    //
    // Save the length
    //
    if (! WriteFile(hFile, (void *) &length, sizeof(length), &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
        DC_QUIT;
    }
    ASSERT(cbSizeWritten == sizeof(length));

    //
    // Save the object data
    //
    if (! WriteFile(hFile, pData, length, &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing data to file, win32 err=%d", GetLastError()));
        DC_QUIT;
    }
    ASSERT(cbSizeWritten == length);

DC_EXIT_POINT:
  DebugExitDWORD(wbObjectSave, result);
  return result;
}



//
//
// Name:    wbPageSave
//
// Purpose: Save the contents of a single page to file.
//
// Returns: Error code
//
//
UINT WbClient::wbPageSave
(
    WB_PAGE_HANDLE  hPage,
    HANDLE           hFile
)
{
    UINT            result = 0;
    UINT            rc;
    OM_WORKSET_ID   worksetID = (OM_WORKSET_ID)hPage;
    POM_OBJECT pObj;
    POM_OBJECTDATA     pData;
    WB_END_OF_PAGE  endOfPage;

    DebugEntry(wbPageSave);

    //
    // Get the first object
    //
    result = OM_ObjectH(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           0,
                           &pObj,
                           FIRST);
    if (result == OM_RC_NO_SUCH_OBJECT)
    {
        // This can happen on an empty page, not an error
        TRACE_OUT(("No objects left, quitting with good return"));
        result = 0;
        DC_QUIT;
    }

    if (result != 0)
    {
        ERROR_OUT(("Error getting first object in page"));
        DC_QUIT;
    }

    //
    // Loop through the objects
    //
    for( ; ; )
    {
        //
        // Get a pointer to the object
        //
        result = OM_ObjectRead(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           pObj,
                           &pData);
        if (result != 0)
        {
            ERROR_OUT(("Error reading object = %d", result));
            DC_QUIT;
        }

        //
        // Save the object data
        //
        rc = wbObjectSave(hFile,
                      (LPBYTE) pData->data,
                      pData->length);

        //
        // The return code is tested after we have released the object because
        // we must always do the release.
        //

        //
        // Release the object
        //
        OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     worksetID,
                     pObj,
                     &pData);

        //
        // Now test the write return code
        //
        if (rc != 0)
        {
            result = rc;
            ERROR_OUT(("Error writing object data = %d", result));
            DC_QUIT;
        }

        //
        // Get the next object
        //
        result = OM_ObjectH(m_pomClient,
                            m_hWSGroup,
                            worksetID,
                            pObj,
                            &pObj,
                            AFTER);
        if (result == OM_RC_NO_SUCH_OBJECT)
        {
            TRACE_OUT(("No objects left, quitting with good return"));
            result = 0;
            DC_QUIT;
        }
    }


DC_EXIT_POINT:

    //
    // If we have successfully written the page contents, we write an end-of-
    // page marker to the file.
    //
    if (result == 0)
    {
        //
        // Set the end of page object details
        //
        ZeroMemory(&endOfPage, sizeof(endOfPage));

        endOfPage.length = sizeof(endOfPage);
        endOfPage.type   = TYPE_END_OF_PAGE;

        //
        // Write the end-of-page object
        //
        result = wbObjectSave(hFile,
                          (LPBYTE) &endOfPage,
                          sizeof(endOfPage));
        if (result != 0)
        {
            ERROR_OUT(("Error writing end-of-page = %d", result));
        }
    }

    DebugExitDWORD(wbPageSave, result);
    return(result);
}




//
//
// Name:    wbPageLoad
//
// Purpose: Load the contents of a single page from file.
//
// Returns: Error code
//
//
void WbClient::wbPageLoad(void)
{
    UINT            result = 0;
    UINT            type;
    POM_OBJECT      pObj;
    POM_OBJECTDATA  pData  = NULL;
    PWB_GRAPHIC     pGraphic = NULL;
    WB_PAGE_HANDLE  hPage = m_loadPageHandle;
    WB_PAGE_HANDLE  hNewPage;
    UINT            postDelay = 0;

    DebugEntry(wbPageLoad);
    TRACE_OUT(("Entered wbPageLoad for page %d", (UINT) hPage));

    //
    // Check the load state - if we're not loading, then quit (can happen if
    // the load is cancelled).
    //
    if (m_loadState == LOAD_STATE_EMPTY)
    {
        TRACE_OUT(("Load has been cancelled - abandoning page load"));
        DC_QUIT;
    }

    //
    // Check that we have a full complement of ready pages before starting
    // the load.
    //
    if (!wbCheckReadyPages())
    {
        //
        // There are not enough pages worksets ready to be used.  We exit now
        // to allow the page to be made ready before we continue.  We set up a
        // delay on the message that will be used to restart the process to
        // allow the worksets to be opened before we get back in here.
        //
        postDelay = 200;
        DC_QUIT;
    }

    //
    // If we are waiting to add a new page, get the handle of the page we
    // expect to add next here.  (We have to do this as ObMan requires that
    // we allocate memory for the object in the correct workset, but we do
    // not want to actually add the page here because we may not need it.)
    //
    if (m_loadState == LOAD_STATE_PENDING_NEW_PAGE)
    {
        hNewPage = wbGetReadyPageHandle();

        //
        // If we cannot get a ready page - we must have run out of pages (we
        // have already done a check on the availability of ready pages above).
        // If we cannot get a new page we continue using the old.
        //
        if (hNewPage != WB_PAGE_HANDLE_NULL)
        {
            hPage = hNewPage;
        }
    }

    //
    // Read the next object
    //
    result = wbObjectLoad(m_hLoadFile,
                        (OM_WORKSET_ID)hPage,
                        &pGraphic);
    if (result != 0)
    {
        ERROR_OUT(("Error reading object = %d", result));
        DC_QUIT;
    }

    pData = ObjectDataPtrFromGraphic(pGraphic);
    type = pGraphic->type;

    //
    // Process the object according to type
    //

    //
    // End of file marker
    //
    if (type == TYPE_END_OF_FILE)
    {
        //
        // Let the Front End know that the load has completed
        //
        TRACE_OUT(("Posting WBP_EVENT_LOAD_COMPLETE"));
        WBP_PostEvent(
                 0,                        // No delay
                 WBP_EVENT_LOAD_COMPLETE,  // Load completed
                 0,                        // No parameters
                 0);

        //
        // Leave now - the file will be closed below
        //
        DC_QUIT;
    }

    //
    // It is not an end-of file object.  So it must be either an end-of page
    // or a graphic object.  In either case we may already have flagged the
    // need to add a new page.
    //

    //
    // Add a new page (if necessary)
    //
    if (m_loadState == LOAD_STATE_PENDING_NEW_PAGE)
    {
        //
        // If we could not get a new page handle above leave with an error
        //
        if (hPage == m_loadPageHandle)
        {
            ERROR_OUT(("Run out of pages for load"));
            result = WB_RC_TOO_MANY_PAGES;
            DC_QUIT;
        }

        //
        // Add a new page after the current page.  The new page handle is saved
        // in the client details.
        //
        result = wbPageAdd(m_loadPageHandle,
                       PAGE_AFTER,
                       &(m_loadPageHandle),
                       DONT_RESET_CHANGED_FLAG);
        if (result != 0)
        {
            ERROR_OUT(("Failed to add page"));
            DC_QUIT;
        }

        //
        // Check that we got the page handle we expected
        //
        ASSERT((hPage == m_loadPageHandle));

        //
        // Show that we are no longer waiting for a new page
        //
        m_loadState = LOAD_STATE_LOADING;
    }

    //
    // End of page marker
    //
    if (type == TYPE_END_OF_PAGE)
    {
        TRACE_OUT(("End of page object"));

        //
        // Discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     (OM_WORKSET_ID)hPage,
                     &pData);
        pData = NULL;

        //
        // Set the load state to "pending new page" and leave the routine
        // immediately.  The process continues when we return to this routine.
        //
        m_loadState = LOAD_STATE_PENDING_NEW_PAGE;

        //
        // Exit (we post ourselves a message below to get us back into this
        // routine later).
        //
        postDelay = 100;
        DC_QUIT;
    }

    //
    // The object is a standard graphic
    //
    TRACE_OUT(("Graphic object"));

    //
    // Add the object to the page
    //
    result = OM_ObjectAdd(m_pomClient,
                            m_hWSGroup,
                            (OM_WORKSET_ID)hPage,
                            &pData,
                            sizeof(WB_GRAPHIC),
                            &pObj,
                            LAST);
    if (result != 0)
    {
        DC_QUIT;
    }

    //
    // Show that we have finished with the object
    //
    pGraphic = NULL;
    pData  = NULL;

DC_EXIT_POINT:

    //
    // If we still have the object - discard it
    //
    if (pData != NULL)
    {
        TRACE_OUT(("Discarding object"));
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     (OM_WORKSET_ID)hPage,
                     &pData);
    }

    //
    // If an error occurred or we have reached the end-of-file - close the
    // file.
    //
    if ((result != 0) || (type == TYPE_END_OF_FILE))
    {
        CloseHandle(m_hLoadFile);
        m_hLoadFile = INVALID_HANDLE_VALUE;

        //
        // If the final result is an error - post an error message to ourselves
        //
        if (result != 0)
        {
            TRACE_OUT(("Posting WBP_EVENT_LOAD_FAILED"));
            WBP_PostEvent(
                   0,                      // No delay
                   WBP_EVENT_LOAD_FAILED,  // Load the next object
                   0,                      // No parameters
                   0);
        }

        //
        // Record that we are no longer in the load process
        //
        m_loadState = LOAD_STATE_EMPTY;
        TRACE_OUT(("Moved load state to LOAD_STATE_EMPTY"));
    }

    //
    // send a message to load the next page, unless the load has been
    // cancelled
    //
    if (m_loadState != LOAD_STATE_EMPTY)
    {
        //
        // We have not reached the end-of-file and there has been no error.
        // Post a message to ourselves to continue the load process.
        //
        TRACE_OUT(("Posting WBPI_EVENT_LOAD_NEXT"));
        WBP_PostEvent(postDelay,                // With delay
                 WBPI_EVENT_LOAD_NEXT,     // Load the next object
                 0,                        // No parameters
                 0);
    }

    DebugExitVOID(wbPageLoad);
}



//
//
// Name:    wbObjectLoad
//
// Purpose: Load a single object from file.
//
// Returns: Error code
//
//
UINT WbClient::wbObjectLoad
(
    HANDLE          hFile,
    WB_PAGE_HANDLE  hPage,
    PPWB_GRAPHIC    ppGraphic
)
{
    UINT            result = 0;
    OM_WORKSET_ID   worksetID = (OM_WORKSET_ID)hPage;
    UINT            length;
    ULONG           cbSizeRead;
    POM_OBJECTDATA     pData  = NULL;
    PWB_GRAPHIC     pGraphic = NULL;

    DebugEntry(wbObjectLoad);

    TRACE_OUT(("Entered wbObjectLoad for page %d", (UINT) hPage));

    //
    // Read the next object's length
    //
    if ( (! ReadFile(hFile, (void *) &length, sizeof(length), &cbSizeRead, NULL)) ||
        (cbSizeRead != sizeof(length)) ||
        (length > OM_MAX_OBJECT_SIZE) ||
        (length == 0) )
    {
        //
        // Make sure we return a sensible error.
        //
        ERROR_OUT(("reading object length, win32 err=%d, length=%d", GetLastError(), length));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }

    //
    // Allocate memory for the object
    //
    result = OM_ObjectAlloc(m_pomClient,
                          m_hWSGroup,
                          worksetID,
                          length,
                        &pData);
    if (result != 0)
    {
        ERROR_OUT(("Error allocating object = %d", result));
        DC_QUIT;
    }

    pData->length = length;
    pGraphic = GraphicPtrFromObjectData(pData);

    //
    // Read the object into memory
    //
    if ( (! ReadFile(hFile, (void *) pGraphic, length, &cbSizeRead, NULL)) ||
           (cbSizeRead != length))
    {
        //
        // Make sure we return a sensible error.
        //
        ERROR_OUT((
            "Reading object from file: win32 err=%d, asked for %d got %d bytes",
            GetLastError(),
            length,
            cbSizeRead));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }

    //
    // Validate the object type
    //
    switch (pGraphic->type)
    {
        //
        // Standard type, end-of-page or end-of-file
        //
        case TYPE_END_OF_PAGE:
        case TYPE_END_OF_FILE:
        case TYPE_GRAPHIC_FREEHAND:
        case TYPE_GRAPHIC_LINE:
        case TYPE_GRAPHIC_RECTANGLE:
        case TYPE_GRAPHIC_FILLED_RECTANGLE:
        case TYPE_GRAPHIC_ELLIPSE:
        case TYPE_GRAPHIC_FILLED_ELLIPSE:
        case TYPE_GRAPHIC_TEXT:
        case TYPE_GRAPHIC_DIB:
            break;

        //
        // Unrecognized object type - probably wrong version
        //
        default:
            result = WB_RC_BAD_FILE_FORMAT;
            DC_QUIT;
            break;
    }

    //
    // For graphic objects, set the flag in the object header showing that it
    // was loaded from file.  Add our user ID so we know where it came from.
    //
    if ( (pGraphic->type != TYPE_END_OF_FILE) &&
       (pGraphic->type != TYPE_END_OF_PAGE))
    {
        pGraphic->loadedFromFile = TRUE;
        pGraphic->loadingClientID = m_clientNetID;
    }

    *ppGraphic = pGraphic;

DC_EXIT_POINT:

    //
    // If an error has occurred - discard the object (if we have it)
    //
    if ((result != 0) && (pData != NULL))
    {
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     worksetID,
                     &pData);
    }

    DebugExitDWORD(wbObjectLoad, result);
    return(result);
}



//
//
// Name:    wbPageHandleFromNumber
//
// Purpose: Return the handle of a page specified by page number
//
// Returns: Error code
//
//
UINT WbClient::wbPageHandleFromNumber
(
    UINT            pageNumber,
    PWB_PAGE_HANDLE phPage
)
{
    UINT        result = 0;
    WB_PAGE_HANDLE  hPage;
    PWB_PAGE_ORDER  pPageOrder = &(m_pageOrder);

    DebugEntry(wbPageHandleFromNumber);

    //
    // Validate the requested page number
    //
    if ((pageNumber < 1)|| (pageNumber > WB_MAX_PAGES))
    {
        result = WB_RC_BAD_PAGE_NUMBER;
        DC_QUIT;
    }

    if (pageNumber > pPageOrder->countPages)
    {
        result = WB_RC_NO_SUCH_PAGE;
        DC_QUIT;
    }

    //
    // Get the page handle
    //
    hPage = (pPageOrder->pages)[pageNumber - 1];

    //
    // Check that this page is in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        ERROR_OUT(("Page list is bad"));
    }

    //
    // Return the page handle
    //
    *phPage = hPage;

DC_EXIT_POINT:
    DebugExitDWORD(wbPageHandleFromNumber, result);
    return(result);
}




//
//
// Name:    wbPageClear
//
// Purpose: Clear the specified page of all graphic objects
//
// Returns: Error code
//
//
UINT WbClient::wbPageClear
(
    WB_PAGE_HANDLE  hPage,
    UINT            changedFlagAction
)
{
    UINT            result = 0;

    DebugEntry(wbPageClear);

    //
    // Show that the contents have changed, if required.
    //
    if (changedFlagAction == RESET_CHANGED_FLAG)
    {
        m_changed = TRUE;
        TRACE_OUT(("Changed flag now TRUE"));
    }

    //
    // Request that the page be cleared
    //
    result = OM_WorksetClear(m_pomClient,
                           m_hWSGroup,
                           (OM_WORKSET_ID)hPage);


    DebugExitDWORD(wbPageClear, result);
    return(result);
}




//
//
// Name:    wbPageClearConfirm
//
// Purpose: Complete the clearing of a page
//
// Returns: Error code
//
//
void WbClient::wbPageClearConfirm(WB_PAGE_HANDLE hPage)
{
    DebugEntry(wbPageClearConfirm);

    //
    // Request that the page be cleared
    //
    OM_WorksetClearConfirm(m_pomClient,
                         m_hWSGroup,
                         (OM_WORKSET_ID)hPage);


    //
    // Check the load state to see whether we are waiting to load the
    // contents
    //
    if (m_loadState == LOAD_STATE_PENDING_CLEAR)
    {
        //
        // We are waiting to load.  If there is only one page available (ie the
        // one that has just been cleared) we are ready to load, otherwise we
        // wait for the page deletes to happen.
        //
        if ((m_pageOrder).countPages == 1)
        {
            //
            // Start the load proper
            //
            wbStartContentsLoad();
        }
        else
        {
            //
            // Move the load state to show that we are waiting for all the pages
            // to be deleted.
            //
            m_loadState = LOAD_STATE_PENDING_DELETE;
            TRACE_OUT(("Moved load state to LOAD_STATE_PENDING_DELETE"));
        }
    }

    DebugExitVOID(wbPageClearConfirm);
}




//
//
// Name:    wbCheckReadyPages
//
// Purpose: Check that we have enough worksets open for the local user to
//          use immediately (during page adds).
//
// Returns: None
//
//
BOOL WbClient::wbCheckReadyPages(void)
{
    BOOL         bResult = TRUE;
    WB_PAGE_HANDLE hNewPage;
    UINT       countPages = m_pageOrder.countPages;
    UINT       countReadyPages = m_countReadyPages;

    //
    // If we have opened all the worksets
    //
    if (countReadyPages == WB_MAX_PAGES)
    {
        //
        // Quit there are no more worksets that we can open
        //
        DC_QUIT;
    }

    //
    // If the number of pages in use is getting close to the number of ready
    // pages.
    //
    if (   (countReadyPages >= PREINITIALIZE_PAGES)
        && (countPages <= (countReadyPages - PREINITIALIZE_PAGES)))
    {
        DC_QUIT;
    }

    //
    // If the number of pages ready is less than the required cache size,
    // open another one.
    //
    hNewPage = wbGetEmptyPageHandle();
    if (hNewPage != WB_PAGE_HANDLE_NULL)
    {
        //
        // Open the workset associated with the page
        //
        wbPageWorksetOpen(hNewPage, OPEN_LOCAL);
    }

    bResult = FALSE;

DC_EXIT_POINT:
    return(bResult);
}




//
//
// Name:    wbPageAdd
//
// Purpose: Add a new (blank) page in a specified position
//
// Returns: Error code
//
//
UINT WbClient::wbPageAdd
(
    WB_PAGE_HANDLE  hRefPage,
    UINT            where,
    PWB_PAGE_HANDLE phPage,
    UINT            changedFlagAction
)
{
    UINT            result = 0;
    WB_PAGE_HANDLE  hNewPage;

    DebugEntry(wbPageAdd);

    //
    // Check that there are not too many pages already
    //
    if (m_pageOrder.countPages == WB_MAX_PAGES)
    {
        result = WB_RC_TOO_MANY_PAGES;
        DC_QUIT;
    }

    //
    // Validate the specified reference page
    //
    ASSERT(GetPageState(hRefPage)->state == PAGE_IN_USE);

    //
    // Get a handle for the new page
    //
    hNewPage = wbGetReadyPageHandle();

    //
    // If there are no handles ready we attempt to create one and return a
    // busy indication.
    //
    if (hNewPage == WB_PAGE_HANDLE_NULL)
    {
        result = WB_RC_BUSY;
        DC_QUIT;
    }

    //
    // Make the internal update immediately - this allows the client to
    // reference the new page as soon as this function has returned.
    //
    wbPagesPageAdd(hRefPage, hNewPage, where);

    //
    // Update the Page Control Object
    //
    result = wbWritePageControl(FALSE);
    if (result != 0)
    {
        wbError();
        DC_QUIT;
    }

    //
    // Show that the contents have changed (if required).
    //
    if (changedFlagAction == RESET_CHANGED_FLAG)
    {
        m_changed = TRUE;
        TRACE_OUT(("Changed flag now TRUE"));
    }

    //
    // Return the handle of the new page
    //
    *phPage = hNewPage;

DC_EXIT_POINT:
    //
    // If we successfully added the page, or could not get a spare page
    // handle, attempt to create a spare one for next time.
    //
    if ((result == 0) || (result == WB_RC_BUSY))
    {
        wbCheckReadyPages();
    }

    DebugExitDWORD(wbPageAdd, result);
    return(result);
}




//
//
// Name:    wbPageMove
//
// Purpose: Move a page relative to another page
//
// Returns: Error code
//
//
UINT WbClient::wbPageMove
(
    WB_PAGE_HANDLE  hRefPage,
    WB_PAGE_HANDLE  hPage,
    UINT            where
)
{
    UINT       result = 0;
    PWB_PAGE_ORDER pPageOrder = &(m_pageOrder);

    DebugEntry(wbPageMove);

    //
    // Extract the page to be moved
    //
    wbPageOrderPageDelete(pPageOrder, hPage);

    //
    // Add it back at its new position
    //
    wbPageOrderPageAdd(pPageOrder, hRefPage, hPage, where);

    //
    // Update the page control object
    //
    result = wbWritePageControl(FALSE);
    if (result != 0)
    {
        wbError();
        DC_QUIT;
    }

    //
    // Show that the contents have changed
    //
    m_changed = TRUE;
    TRACE_OUT(("Changed flag now TRUE"));

DC_EXIT_POINT:
    DebugExitDWORD(wbPageMove, result);
    return(result);
}





//
//
// Name:    wbPageHandle
//
// Purpose: Return a page handle.  The page for which the handle is
//          required can be specified relative to another page or as the
//          first/last page.
//
// Returns: Error code
//
//
UINT WbClient::wbPageHandle
(
    WB_PAGE_HANDLE  hRefPage,
    UINT            where,
    PWB_PAGE_HANDLE phPage
)
{
    UINT       result = 0;
    UINT       pageNumber;
    PWB_PAGE_ORDER pPageOrder = &(m_pageOrder);
    POM_WORKSET_ID pPage = pPageOrder->pages;
    WB_PAGE_HANDLE hPage;

    DebugEntry(wbPageHandle);

    //
    // Check the relative position
    //
    switch (where)
    {
        case PAGE_FIRST:
            hPage = pPage[0];
            break;

        case PAGE_LAST:
            hPage = pPage[pPageOrder->countPages - 1];
            break;

        case PAGE_AFTER:
        case PAGE_BEFORE:
            //
            // Validate the specified reference page
            //
            ASSERT(GetPageState(hRefPage)->state == PAGE_IN_USE);

            //
            // Get the page number of the reference page
            //
            pageNumber = wbPageOrderPageNumber(pPageOrder, hRefPage);
            TRACE_OUT(("Reference page number is %d", pageNumber));

            //
            // Get the page number of the required page
            //
            pageNumber = (UINT)(pageNumber + ((where == PAGE_AFTER) ? 1 : -1));
            TRACE_OUT(("New page number is %d", pageNumber));

            //
            // Check that the new page is valid
            //
            TRACE_OUT(("Number of pages is %d", pPageOrder->countPages));
            if (   (pageNumber < 1)
                || (pageNumber > pPageOrder->countPages))
            {
                TRACE_OUT(("Returning WB_RC_NO_SUCH_PAGE"));
                result = WB_RC_NO_SUCH_PAGE;
                DC_QUIT;
            }

            //
            // Get the handle of the page
            //
            hPage = pPage[pageNumber - 1];
            TRACE_OUT(("Returning handle %d", (UINT) hPage));
            break;
    }

    //
    // Return the page handle
    //
    *phPage = hPage;

DC_EXIT_POINT:
    DebugExitDWORD(wbPageHandle, result);
    return(result);
}



//
//
// Name:    wbGraphicSelectPrevious
//
// Purpose: Return the next graphic object in the specified page whose
//          bounding rectangle contains the specified point.  The function
//          starts with the graphic whose handle is given as parameter and
//          will return this graphic if it contains the point.
//
// Returns: Error code
//
//
UINT WbClient::wbGraphicSelectPrevious
(
    WB_PAGE_HANDLE      hPage,
    LPPOINT             pPoint,
    WB_GRAPHIC_HANDLE   hGraphic,
    PWB_GRAPHIC_HANDLE  phGraphic
)
{
    UINT                result = 0;
    OM_WORKSET_ID       worksetID = (OM_WORKSET_ID)hPage;
    PWB_GRAPHIC         pGraphic;
    POM_OBJECTDATA         pData;
    RECT                rect;

    DebugEntry(wbGraphicSelectPrevious);

    *phGraphic = (WB_GRAPHIC_HANDLE) NULL;

    //
    // Loop back through the objects starting at the reference point
    //
    do
    {
        //
        // Get the object from ObMan
        //
        result = OM_ObjectRead(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           hGraphic,
                           &pData);

        //
        // Leave the loop if error on read - we do not need to do the release
        //
        if (result != 0)
        {
            DC_QUIT;
        }

        pGraphic = GraphicPtrFromObjectData(pData);

        //
        // Extract the bounding rectangle of the object
        //
        RECT_FROM_TSHR_RECT16(&rect, pGraphic->rectBounds);

        //
        // Release the object
        //
        OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     worksetID,
                     hGraphic,
                     &pData);

        //
        // Check whether the point lies in bounds
        //
        if (PtInRect(&rect, *pPoint))
        {
            //
            // Set the result handle
            //
            TRACE_OUT(("Returning graphic handle"));
            *phGraphic = hGraphic;
            DC_QUIT;
        }

        //
        // Get the next object to test
        //
        result = OM_ObjectH(m_pomClient,
                            m_hWSGroup,
                            worksetID,
                             hGraphic,
                             &hGraphic,
                            BEFORE);
    }
    while (result == 0);

    //
    // Correct the return code (if necessary)
    //
    if (result == OM_RC_NO_SUCH_OBJECT)
    {
        TRACE_OUT(("Returning WB_RC_NO_SUCH_GRAPHIC"));
        result = WB_RC_NO_SUCH_GRAPHIC;
    }

DC_EXIT_POINT:
    DebugExitDWORD(wbGraphicSelectPrevious, result);
    return(result);
}




//
//
// Name:    wbCoreExitHandler
//
// Purpose: Exit handler for the Whiteboard Core. This handler is
//          registered with the Utilities by the WBP_Start call. It is
//          deregistered by the client deregistration process, so it is
//          only called when an abnormal termination occurs.
//
// Returns: None
//
//
void CALLBACK wbCoreExitHandler(LPVOID clientData)
{
    WbClient*    pwbClient = (WbClient *)clientData;

    pwbClient->wbExitHandler();
}


void WbClient::wbExitHandler(void)
{
    DebugEntry(wbExitHandler);

    //
    // Leave the current call if there is one, removing any locks etc.
    //
    wbLeaveCall();

    //
    // Dereg from call manager
    //
    if (m_pcmClient != NULL)
    {
        CMS_Deregister(&(m_pcmClient));
    }

    //
    // Dereg exit handler
    //
    if (m_subState >= STATE_START_REGISTERED_EXIT)
    {
        UT_DeregisterExit(m_putTask, wbCoreExitHandler, this);
    }

    //
    // Dereg obman
    //
    if (m_subState >= STATE_START_REGISTERED_OM)
    {
        OM_Deregister(&m_pomClient);
    }

    //
    // Dereg event handler
    //
    if (m_subState >= STATE_START_REGISTERED_EVENT)
    {
        UT_DeregisterEvent(m_putTask, wbCoreEventHandler, this);
    }

    //
    // delete ourself!
    //
    delete this;

    DebugExitVOID(wbExitHandler);
}



//
//
// Name:    wbCoreEventHandler
//
// Purpose: Event handler for the Whiteboard Core. This handler is
//          registered with the Utilities by the WBP_Start call.
//
// Params:  clientData  - pointer to the data stored for a client
//          event       - event identifier
//          param1      - word event parameter (content depends on event)
//          param2      - long event parameter (content depends on event)
//
// Returns: Error code
//
//
BOOL CALLBACK wbCoreEventHandler
(
    LPVOID      clientData,
    UINT        event,
    UINT_PTR    param1,
    UINT_PTR    param2
)
{
    WbClient*   pwbClient = (WbClient *)clientData;

    return(pwbClient->wbEventHandler(event, param1, param2));
}


BOOL WbClient::wbEventHandler
(
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16    pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32    pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL                processed = FALSE;

    DebugEntry(wbEventHandler);

    TRACE_OUT(("event %d, param1 %d, param2 %d", event, param1, param2));

    switch (event)
    {
        //
        // Confirmation that we have registered with a workset group
        //
        case OM_WSGROUP_REGISTER_CON:
            TRACE_OUT(("OM_WSGROUP_REGISTER_CON %x %x",param1,param2));
            processed = wbOnWsGroupRegisterCon(param1, param2);
            break;

        //
        // Confirmation that we have moved a workset group
        //
        case OM_WSGROUP_MOVE_CON:
            TRACE_OUT(("OM_WSGROUP_MOVE_CON %x %x",param1,param2));
            processed = wbOnWsGroupMoveCon(param1, param2);
            break;

        //
        // Our workset group has been moved
        //
        case OM_WSGROUP_MOVE_IND:
            TRACE_OUT(("OM_WSGROUP_MOVE_IND %x %x",param1,param2));
            processed = wbOnWsGroupMoveInd(param1, param2);
            break;

        //
        // A workset has been created - we do nothing
        //
        case OM_WORKSET_NEW_IND:
            TRACE_OUT(("OM_WORKSET_NEW_IND %x %x",param1,param2));
            processed = TRUE;
            break;

        //
        // A workset has been opened
        //
        case OM_WORKSET_OPEN_CON:
            TRACE_OUT(("OM_WORKSET_OPEN_CON %x %x",param1,param2));
            processed = wbOnWorksetOpenCon(param1, param2);
            break;

        //
        // A workset has been locked
        //
        case OM_WORKSET_LOCK_CON:
            TRACE_OUT(("OM_WORKSET_LOCK_CON %x %x",param1,param2));
            processed = wbOnWorksetLockCon(param1, param2);
            break;

        //
        // A workset has been unlocked
        //
        case OM_WORKSET_UNLOCK_IND:
            TRACE_OUT(("OM_WORKSET_UNLOCK_IND %x %x",param1,param2));
            processed = wbOnWorksetUnlockInd(param1, param2);
            break;

        //
        // ObMan has run out of resources
        //
        case OM_OUT_OF_RESOURCES_IND:
            TRACE_OUT(("OM_OUT_OF_RESOURCES_IND %x %x",param1,param2));
            wbError();
            processed = TRUE;
            break;

        //
        // A workset has been cleared
        //
        case OM_WORKSET_CLEAR_IND:
            TRACE_OUT(("OM_WORKSET_CLEAR_IND %x %x",param1,param2));
            processed = wbOnWorksetClearInd(param1, param2);
            break;

        //
        // A new object has been added to a workset
        //
        case OM_OBJECT_ADD_IND:
            TRACE_OUT(("OM_OBJECT_ADD_IND %x %x",param1,param2));
            processed = wbOnObjectAddInd(param1, (POM_OBJECT)param2);
            break;

        //
        // An object has been moved
        //
        case OM_OBJECT_MOVE_IND:
            TRACE_OUT(("OM_OBJECT_MOVE_IND %x %x",param1,param2));
            processed = wbOnObjectMoveInd(param1, param2);
            break;

        //
        // An object has been deleted
        //
        case OM_OBJECT_DELETE_IND:
            TRACE_OUT(("OM_OBJECT_DELETE_IND %x %x",param1,param2));
            processed = wbOnObjectDeleteInd(param1, (POM_OBJECT)param2);
            break;

        //
        // An object has been updated
        //
        case OM_OBJECT_UPDATE_IND:
            TRACE_OUT(("OM_OBJECT_UPDATE_IND %x %x",param1,param2));
            processed = wbOnObjectUpdateInd(param1, (POM_OBJECT)param2);
            break;

        //
        // An object has been updated
        //
        case OM_OBJECT_REPLACE_IND:
            TRACE_OUT(("OM_OBJECT_REPLACE_IND %x %x",param1,param2));
            processed = wbOnObjectReplaceInd(param1, (POM_OBJECT)param2);
            break;

        //
        // Load chaining event
        //
        case WBPI_EVENT_LOAD_NEXT:
            TRACE_OUT(("WBPI_EVENT_LOAD_NEXT"));
            wbPageLoad();
            processed = TRUE;
            break;

        //
        // Whiteboard page clear indication
        //
        case WBP_EVENT_PAGE_CLEAR_IND:
            TRACE_OUT(("WBP_EVENT_PAGE_CLEAR_IND"));
            processed = wbOnWBPPageClearInd((WB_PAGE_HANDLE) param1);
            break;

        //
        // Whiteboard lock notification
        //
        case WBP_EVENT_PAGE_ORDER_LOCKED:
        case WBP_EVENT_CONTENTS_LOCKED:
            TRACE_OUT(("WBP_EVENT_xxx_LOCKED (%#hx) %#hx %#lx",
                     event,
                     param1,
                     param2));
            processed = wbOnWBPLock();
            break;

        //
        // Whiteboard lock failure notification
        //
        case WBP_EVENT_LOCK_FAILED:
            TRACE_OUT(("WBP_EVENT_LOCK_FAILED %x %x",param1,param2));
            processed = wbOnWBPLockFailed();
            break;

        //
        // Whiteboard Unlock notification
        //
        case WBP_EVENT_UNLOCKED:
            TRACE_OUT(("WBP_EVENT_UNLOCKED %x %x",param1,param2));
            processed = wbOnWBPUnlocked();
            break;

        //
        // Whiteboard Page Order Updated notification
        //
        case WBP_EVENT_PAGE_ORDER_UPDATED:
            TRACE_OUT(("WBP_EVENT_PAGE_ORDER_UPDATED %x %x",
                     param1,
                     param2));
            processed = wbOnWBPPageOrderUpdated();
            break;

        //
        // We are not interested in this event - do nothing
        //
        default:
            TRACE_OUT(("Event ignored"));
            break;
    } // Switch on event type


    DebugExitBOOL(wbEventHandler, processed);
    return(processed);
}




//
// wbJoinCallError
//
// This function should be called in STATE_REGISTERING only.
//
//
void WbClient::wbJoinCallError(void)
{
    DebugEntry(wbJoinCallError);

    ASSERT((m_state == STATE_REGISTERING));

    //
    // Post a registration failed message to the client
    //
    TRACE_OUT(("Posting WBP_EVENT_REGISTER_FAILED"));
    WBP_PostEvent(
               0,                              // No delay
               WBP_EVENT_JOIN_CALL_FAILED,     // Failure
               0,                              // No parameters
               0);

    //
    // Tidy up after the attempt to join the call
    //
    wbLeaveCall();

    DebugExitVOID(wbJoinCallError);
}




//
// wbError
//
void WbClient::wbError(void)
{
    DebugEntry(wbError);

    //
    // An error has occurred during Core processing.  We act according to the
    // current state.
    //
    switch (m_state)
    {
        //
        // If the error has occurred during registration, post a registration
        // failure message to the client and cancel registration.
        //
        case STATE_REGISTERING:
            wbJoinCallError();
            break;

        //
        // If the error occurred during normal running, we tell the client who
        // must deregister.
        //
        case STATE_IDLE:
            //
            // Only take action if we are not already in fatal error state
            //
            if (m_errorState == ERROR_STATE_EMPTY)
            {
                //
                // Post an error message to the client
                //
                TRACE_OUT(("Posting WBP_EVENT_ERROR"));
                WBP_PostEvent(
                     0,                            // No delay
                     WBP_EVENT_ERROR,              // Error
                     0,                            // No parameters
                     0);

                //
                // Record that an error has occurred
                //
                m_errorState = ERROR_STATE_FATAL;
                TRACE_OUT(("Moved error state to ERROR_STATE_FATAL"));
            }
            break;

        //
        // Client is in an unknown state
        //
        default:
            ERROR_OUT(("Bad main state for call"));
            break;
    }

    DebugExitVOID(wbError);
}



//
//
// Name:    wbOnWSGroupMoveCon
//
// Purpose: Routine processing OM_WSGROUP_MOVE_CON events.
//
//
BOOL WbClient::wbOnWsGroupMoveCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;
    UINT rc;
    BOOL   failedToJoin     = FALSE;

    DebugEntry(wbOnWsGroupMoveCon);

    //
    // Check that this is the event we are expecting
    //
    if (pEvent32->correlator != m_wsgroupCorrelator)
    {
        DC_QUIT;
    }

    //
    // Show that we have processed the event
    //
    processed = TRUE;

    //
    // Test for the correct state
    //
    if (m_subState != STATE_REG_PENDING_WSGROUP_MOVE)
    {
        //
        // We are not in the correct state for this event - this is an internal
        // error.
        //
        ERROR_OUT(("Wrong state for WSGroupMoveCon"));
    }

    //
    // Check that the return code for the move is OK
    //
    if (pEvent32->result != 0)
    {
        //
        // Moving the workset group failed - post a "join call failed" message
        // to the front-end.
        //
        TRACE_OUT(("WSGroup move failed, result = %d", pEvent32->result));
        failedToJoin = TRUE;
        DC_QUIT;
    }

    //
    // The WSGroupMove has completed successfully.  Replace our local user
    // object by deleting the current one (we must have one to get to this
    // point) and adding a new one.
    //
    // The reason we do this is that our existing user object has been moved
    // from the local domain into a call, but since it is in a non-persistent
    // workset, the Obman behaviour for this object when the call ends is
    // undefined.  So we replace the object to get a defined behaviour.
    //
    TRACE_OUT(("Deleting local user object"));
    rc = OM_ObjectDelete(m_pomClient,
                       m_hWSGroup,
                       USER_INFORMATION_WORKSET,
                       m_pObjLocal);
    if (rc != 0)
    {
        ERROR_OUT(("Error deleting local user object = %u", rc));
    }

    TRACE_OUT(("Adding new local user object"));
    rc = wbAddLocalUserObject();
    if (rc != 0)
    {
        TRACE_OUT(("Failed to add local user object"));
        failedToJoin = TRUE;
        DC_QUIT;
    }

    //
    // Get the clients network ID, used in graphic objects to determine where
    // they are loaded.
    //
    if (!wbGetNetUserID())
    {
        //
        // Tidy up (and post an error event to the client)
        //
        ERROR_OUT(("Failed to get user ID, rc %u", rc));
        failedToJoin = TRUE;
        DC_QUIT;
    }

    //
    // We added our user object successfully, so now wait for the
    // OBJECT_ADD_IND to arrive.
    //
    m_subState = STATE_REG_PENDING_NEW_USER_OBJECT;

DC_EXIT_POINT:
    if (failedToJoin)
    {
        //
        // We have failed to join the call, so clean up.
        //
        wbError();
    }

    DebugExitBOOL(wbOnWsGroupMoveCon, processed);
    return(processed);
}




//
//
// Name:    wbOnWSGroupMoveInd
//
// Purpose: Routine processing OM_WSGROUP_MOVE_IND events.
//
//
BOOL WbClient::wbOnWsGroupMoveInd
(
    UINT_PTR param1,
    UINT_PTR callID
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    BOOL        processed = TRUE;

    DebugEntry(wbOnWsGroupMoveInd);

    if (callID != OM_NO_CALL)
    {
        TRACE_OUT(("Moved into new call"));
        DC_QUIT;
    }

    //
    // If we are registering, treat it as a failure to join the call,
    // otherwise let the client know about the network failure.
    //
    if (m_state == STATE_REGISTERING)
    {
        TRACE_OUT(("Call went down while registering"));
        wbError();
        DC_QUIT;
    }

    TRACE_OUT(("Posting WBP_EVENT_NETWORK_LOST"));
    WBP_PostEvent(0,
                 WBP_EVENT_NETWORK_LOST,      // Unlocked
                 0,                           // No parameters
                 0);

    //
    // Tidy up the User Information workset (the local client is now the
    // only user).  Note that since the user information workset it
    // non-persistent, Obman will delete the remote user objects for us.
    //

    //
    // - check we have opened the user workset
    //
    if ( (m_state    > STATE_REGISTERING) ||
         (m_subState > STATE_REG_PENDING_USER_WORKSET))
    {
        //
        // Delete the lock object.
        //
        if (m_pObjLock != NULL)
        {
            TRACE_OUT(("Deleting lock object %d", m_pObjLock));
            if (OM_ObjectDelete(m_pomClient,
                                     m_hWSGroup,
                                     PAGE_CONTROL_WORKSET,
                                     m_pObjLock) != 0)
            {
                ERROR_OUT(("Error deleting lock object"));
            }

            if (m_lockState == LOCK_STATE_GOT_LOCK)
            {
                //
                // If all is well at this point the unlock process will be
                // completed when the object delete ind is received.
                //
                m_lockState = LOCK_STATE_PENDING_DELETE;
                TRACE_OUT(("Moved to state LOCK_STATE_PENDING_DELETE"));
            }
            else
            {
                m_lockState = LOCK_STATE_EMPTY;
                TRACE_OUT(("Moved to state LOCK_STATE_EMPTY"));
            }
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWSGroupMoveInd, processed);
    return(processed);
}




//
//
// Name:    wbOnWorksetClearInd
//
// Purpose: Routine processing OM_WORKSET_CLEAR_IND events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWorksetClearInd
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;

    DebugEntry(wbOnWorksetClearInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            ERROR_OUT(("Unexpected clear for Page Control Workset"));
            break;

        //
        // Lock Workset
        //
        case SYNC_CONTROL_WORKSET:
            ERROR_OUT(("Unexpected clear for Sync Control Workset"));
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            ERROR_OUT(("Unexpected clear for User Information Workset"));
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            //
            // Tell the client that the page has been cleared - the client must then
            // confirm the clear.
            //
            TRACE_OUT(("Posting WBP_EVENT_PAGE_CLEAR_IND"));
            WBP_PostEvent(
               0,
               WBP_EVENT_PAGE_CLEAR_IND,
               pEvent16->worksetID,
               0);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnWorksetClearInd, processed);
    return(processed);
}




//
//
// Name:    wbOnWBPPageClearInd
//
// Purpose: Routine processing WBP_PAGE_CLEAR_IND events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPPageClearInd(WB_PAGE_HANDLE  hPage)
{
    BOOL            processed;

    DebugEntry(wbOnWBPPageClearInd);

    //
    // This routine catches WB_PAGE_CLEAR_IND events posted to the client.
    // Because of the asynchronous nature of page order updates these can
    // sometimes have been sent previously for pages that are now no longer
    // in use. We trap these events here, confirm the clear to ObMan and
    // discard the event.
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Page is not in use - confirming workset clear immediately"));

        //
        // Accept the page clear immediately
        //
        wbPageClearConfirm(hPage);
        processed = TRUE;
    }
    else
    {
        //
        // If we get here the page is in use - so we must pass the event on to
        // the client.  Resetting the result code of this routine to "not
        // processed" will ask the utilities to pass it on to the next event
        // handler.
        //
        processed = FALSE;
    }


    DebugExitBOOL(wbOnWBPPageClearInd, processed);
    return(processed);
}




//
//
// Name:    wbOnObjectAddInd
//
// Purpose: Routine processing OM_OBJECT_ADD_IND events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectAddInd
(
    UINT_PTR param1,
    POM_OBJECT pObj
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    BOOL            processed = FALSE;

    DebugEntry(wbOnObjectAddInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            wbOnPageObjectAddInd(pObj);
            break;

        //
        // Sync Control Workset
        //
        case SYNC_CONTROL_WORKSET:
            wbOnSyncObjectAddInd(pObj);
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            wbOnUserObjectAddInd(pObj);
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectAddInd(pEvent16->worksetID, pObj);
            break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectAddInd, processed);
    return(processed);
}



//
//
// Name:    wbGetPageObjectType
//
// Purpose: Get the type of an object in the Page Control Workset
//
// Returns: Error code
//
//
UINT WbClient::wbGetPageObjectType
(
    POM_OBJECT    pObj,
    UINT *        pObjectType
)
{
    UINT            result;
    POM_OBJECTDATA  pData;

    DebugEntry(wbGetPageObjectType);

    //
    // Read the object to get its type
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         PAGE_CONTROL_WORKSET,
                         pObj,
                         &pData);
    if (result != 0)
    {
        ERROR_OUT(("Error reading object = %d", result));
        wbError();
        DC_QUIT;
    }

    //
    // The first two bytes of the object data give its type
    //
    *pObjectType = *((TSHR_UINT16 *)pData->data);

    //
    // Release the object
    //
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   PAGE_CONTROL_WORKSET,
                   pObj,
                   &pData);


DC_EXIT_POINT:
    DebugExitDWORD(wbGetPageObjectType, result);
    return(result);
}



//
//
// Name:    wbOnPageObjectAddInd
//
// Purpose: Routine processing OM_OBJECT_ADD_IND events occurring on the
//          Page Control Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnPageObjectAddInd(POM_OBJECT pObj)
{
    UINT    objectType;

    DebugEntry(wbOnPageObjectAddInd);

    //
    // Read the object to get its type
    //
    if (wbGetPageObjectType(pObj, &objectType) != 0)
    {
        DC_QUIT;
    }

    //
    // Act according to the type of object added
    //
    switch (objectType)
    {
        case TYPE_CONTROL_LOCK:
            TRACE_OUT(("It is a lock object"));
            wbReadLock();
            break;

        case TYPE_CONTROL_PAGE_ORDER:
            TRACE_OUT(("It is the Page Control object"));
            wbOnPageControlObjectAddInd(pObj);
            break;

        default:
            ERROR_OUT(("Unknown object type added to Page Control Workset"));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(wbOnPageObjectAddInd);
}



//
//
// Name:    wbOnPageControlObjectAddInd
//
// Purpose: Routine processing add of page control object
//
// Returns: Error code
//
//
void WbClient::wbOnPageControlObjectAddInd(POM_OBJECT    pObj)
{
    DebugEntry(wbOnPageControlObjectAddInd);

    //
    // We only ever expect to get one of these objects
    //
    if (m_pObjPageControl != 0)
    {
        //
        // Check that this is the same object - the add has been triggered by
        // the workset open but we have already read the contents.
        //
        ASSERT((m_pObjPageControl == pObj));
    }

    //
    // Save the handle of the object
    //
    m_pObjPageControl = pObj;
    TRACE_OUT(("Got Page Control object"));

    //
    // Continue according to the current state
    //
    switch (m_state)
    {
        case STATE_REGISTERING:
            //
            // We now have a Page Control Object - if we are waiting for the
            // object we can now move to the next stage.
            //
            if (m_subState == STATE_REG_PENDING_PAGE_CONTROL)
            {
                //
                // If we have the lock on the Page Control Workset then we are in
                // control of the registration process.  We must add the sync
                // control object to the Sync Workset.
                //
                if (m_lockState == LOCK_STATE_GOT_LOCK)
                {
                    //
                    // Create the Sync Control Object
                    //
                    if (wbCreateSyncControl() != 0)
                    {
                        ERROR_OUT(("Error adding Sync Control Object"));
                        wbError();
                        DC_QUIT;
                    }
                }

                //
                // If we do not have the sync control object then wait for it -
                // otherwise we can complete initialisation.
                //
                if (m_pObjSyncControl == 0)
                {
                    m_subState = STATE_REG_PENDING_SYNC_CONTROL;
                    TRACE_OUT(("Moved substate to STATE_REG_PENDING_SYNC_CONTROL"));
                    DC_QUIT;
                }
                else
                {
                    //
                    // If it is us who has the Page Control Workset locked - release
                    // the lock.
                    //
                    if (m_lockState == LOCK_STATE_GOT_LOCK)
                    {
                        //
                        // Unlock the workset
                        //
                        wbUnlock();

                        //
                        // Wait for notification of the lock being released
                        //
                        TRACE_OUT(("Sub state change %d to %d",
                            m_subState, STATE_REG_PENDING_UNLOCK));

                        m_subState = STATE_REG_PENDING_UNLOCK;
                    }
                    else
                    {
                        TRACE_OUT(("Page Control and Sync Control objects both there."));
                        TRACE_OUT(("Registration can be completed"));
                        wbOnControlWorksetsReady();
                    }
                }
            }

            //
            // In other registration states we are not ready to process the
            // event.  It will be dealt with later.
            //
            break;

        case STATE_IDLE:
            //
            // We must already have a Page COntrol Object since we are in idle
            // state.  So this is an error.  It may have been caused by another
            // client so we just trace it rather than asserting.
            //
            ERROR_OUT(("Unexpected add of Page Control Object in idle state"));
            break;

        default:
            ERROR_OUT(("Bad main state"));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(wbOnPageControlObjectAddInd);
}




//
//
// Name:    wbOnSyncObjectAddInd
//
// Purpose: Routine processing OM_OBJECT_ADD_IND events occurring on the
//          Sync Control Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnSyncObjectAddInd(POM_OBJECT    pObj)
{
    DebugEntry(wbOnSyncObjectAddInd);

    //
    // We only expect this during registration
    //
    switch(m_state)
    {
        //
        // We are waiting for registration to continue
        //
        case STATE_REGISTERING:
            switch(m_subState)
            {
                //
                // We are waiting for a Sync Control Object
                //
                case STATE_REG_PENDING_SYNC_CONTROL:
                    m_pObjSyncControl = pObj;

                    //
                    // The Sync Control object has been added.  We do not need to do
                    // anything with it yet.
                    //

                    //
                    // If we already have the page control object then we can
                    // complete initilisation, otherwise we have to wait for it.
                    //
                    if (m_pObjPageControl == 0)
                    {
                        TRACE_OUT(("Sub state change %d to %d",
                            m_subState, STATE_REG_PENDING_PAGE_CONTROL));
                        m_subState = STATE_REG_PENDING_PAGE_CONTROL;
                    }
                    else
                    {
                        //
                        // If it is us who has the Page Control Workset locked -
                        // release the lock.
                        //
                        if (m_lockState == LOCK_STATE_GOT_LOCK)
                        {
                            //
                            // Unlock the workset
                            //
                            wbUnlock();

                            //
                            // Wait for notification of the lock being released
                            //
                            TRACE_OUT(("Sub state change %d to %d",
                               m_subState, STATE_REG_PENDING_UNLOCK));
                            m_subState = STATE_REG_PENDING_UNLOCK;
                        }
                        else
                        {
                            TRACE_OUT(("Page Control and Sync Control objects both there."));
                            TRACE_OUT(("Registration can be completed"));
                            wbOnControlWorksetsReady();
                        }
                    }
                    break;

                default:
                    //
                    // Save the handle of the Sync Control Object
                    //
                    m_pObjSyncControl = pObj;
                    break;
            }
            break;

        //
        // We are fully registered and are therefore not expecting an add event
        // on this workset.  However, since we are registered we must be
        // satisfied that we have a Sync Control Object - so ignore the error.
        //
        case STATE_IDLE:
            ERROR_OUT(("Sync object add not expected in idle state"));
            break;

        //
        // The client is in an unknown state
        //
        default:
            ERROR_OUT(("Client in unknown state = %d", m_state));
            break;
    }

    DebugExitVOID(wbOnSyncObjectAddInd);
}



//
//
// Name:    wbOnUserObjectAddInd
//
// Purpose: A user object has been added to the User Information Workset.
//          Inform the client that a new user has joined the call.
//
// Returns: Error code
//
//
void WbClient::wbOnUserObjectAddInd(POM_OBJECT    pObj)
{
    UINT                countUsers;

    DebugEntry(wbOnUserObjectAddInd);

    OM_WorksetCountObjects(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           &countUsers);
    TRACE_OUT(("Number of users is now %d", countUsers));

    //
    // Ignore the add indication for our own user.
    //
    if (m_pObjLocal == pObj)
    {
        TRACE_OUT(("Got add of own user object"));
        //
        // If we have the lock (temporarily, with NULL lock owner handle),
        // then we need to update the lock object with our actual handle.
        //
        if ((m_pObjLock != NULL) &&
            (m_lockState == LOCK_STATE_GOT_LOCK))
        {
            TRACE_OUT(("Got the lock - update lock object"));
            wbWriteLock();
        }

        if ((m_state == STATE_REGISTERING) &&
            (m_subState == STATE_REG_PENDING_NEW_USER_OBJECT))
        {
            //
            // We have successfully joined the call.
            //
            TRACE_OUT(("Posting WBP_EVENT_JOIN_CALL_OK"));
            WBP_PostEvent(
                       0,                             // No delay
                       WBP_EVENT_JOIN_CALL_OK,        // Unlocked
                       0,                             // No parameters
                       0);

            //
            // Update the state to show that we are ready for work again
            //
            m_state = STATE_IDLE;
            m_subState = STATE_EMPTY;
            TRACE_OUT(("Moved state back to STATE_IDLE"));
        }

        DC_QUIT;
    }

    //
    // If we have created our user object we must check to see if the new
    // user has usurped our color.  If so we may need to change color.
    //
    if (m_pObjLocal != NULL)
    {
        TRACE_OUT(("We have added our user object - check colors"));
        wbCheckPersonColor(pObj);
    }

    //
    // Ignore these events unless we are fully registered
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Ignoring user object add - not fully registered"));
        DC_QUIT;
    }

    //
    // Tell the client that a new user has joined
    //
    TRACE_OUT(("Posting WBP_EVENT_USER_JOINED"));
    WBP_PostEvent(
                 0,                               // No delay
                 WBP_EVENT_PERSON_JOINED,         // Event type
                 0,                               // No short parameter
                 (UINT_PTR) pObj);                // User object handle

    //
    // Try to read the lock object - we may not have been able to do this
    // yet.
    //
    wbReadLock();


DC_EXIT_POINT:
    DebugExitVOID(wbOnUserObjectAddInd);
}



//
//
// Name:    wbOnGraphicObjectAddInd
//
// Purpose: A graphic object has been added to a page workset.
//          Inform the client that a new graphic has been added.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectAddInd
(
    OM_WORKSET_ID       worksetID,
    POM_OBJECT    pObj
)
{
    WB_PAGE_HANDLE      hPage = (WB_PAGE_HANDLE)worksetID;
    POM_OBJECTDATA         pData;
    PWB_GRAPHIC         pGraphic;
    UINT                result;

    DebugEntry(wbOnGraphicObjectAddInd);

    //
    // NFC, SFR 6450.  If this object was loaded from file on this machine,
    // then we dont need to set the "changed flag".  Otherwise record that
    // the contents have changed
    //
    //
    // Read the object.
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         worksetID,
                          pObj,
                         &pData);
    if (result != 0)
    {
        WARNING_OUT(("OM_ObjectRead (%u) failed, set changed flag anyway ", result));
        m_changed = TRUE;
        TRACE_OUT(("changed flag now TRUE"));
    }
    else
    {
        //
        // Convert the ObMan pointer to a core pointer
        //
        pGraphic = GraphicPtrFromObjectData(pData);

        if ( ! ((pGraphic->loadedFromFile) &&
              (pGraphic->loadingClientID == m_clientNetID)))
        {
            TRACE_OUT(("Not loaded from file locally - Set changed flag on"));
            m_changed = TRUE;
            TRACE_OUT(("Changed flag now TRUE"));
        }

        //
        // Finished with the object, so release it.
        //
        OM_ObjectRelease(m_pomClient,
                       m_hWSGroup,
                       worksetID,
                        pObj,
                       &pData);
    }

    //
    // These events are ignored unless we are fully registered (the client
    // can do nothing about them if it is not registered correctly).
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Ignoring add of graphic object - not registered"));
        DC_QUIT;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Ignoring add to page not in use"));
        DC_QUIT;
    }

    //
    // Inform the client of the object being added
    //
    TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_ADDED"));
    WBP_PostEvent(
               0,                               // No delay
               WBP_EVENT_GRAPHIC_ADDED,         // Event type
               hPage,                           //
               (UINT_PTR)pObj);                 // User object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnGraphicObjectAddInd);
}


//
//
// Name:    wbOnObjectMoveInd
//
// Purpose: This routine is called whenever OM_OBJECT_MOVE_IND events are
//          received.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectMoveInd
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL        processed = FALSE;

    DebugEntry(wbOnObjectMoveInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset Lock Workset User Information Workset
        //
        case PAGE_CONTROL_WORKSET:
        case SYNC_CONTROL_WORKSET:
        case USER_INFORMATION_WORKSET:
            //
            // Event not expected for these worksets
            //
            ERROR_OUT(("Unexpected for workset %d", (UINT) pEvent16->worksetID));
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectMoveInd(pEvent16->worksetID,
                               (POM_OBJECT) param2);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectMoveInd, processed);
    return(processed);
}




//
//
// Name:    wbOnGraphicObjectMoveInd
//
// Purpose: This routine is called whenever an OM_OBJECT_MOVE_IND is
//          received for a graphic object.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectMoveInd
(
    OM_WORKSET_ID   worksetID,
    POM_OBJECT      pObj
)
{
    WB_PAGE_HANDLE hPage = (WB_PAGE_HANDLE)worksetID;

    DebugEntry(wbOnGraphicObjectMoveInd);

    //
    // Record that the contents have changed
    //
    m_changed = TRUE;

    //
    // These events are ignored unless we are fully registered (the client
    // can do nothing about them).
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Ignoring move of graphic object before registration"));
        DC_QUIT;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Ignoring move in page not in use"));
        DC_QUIT;
    }

    //
    // Inform the client of the object being added
    //
    TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_MOVED"));
    WBP_PostEvent(
               0,                                  // No delay
               WBP_EVENT_GRAPHIC_MOVED,            // Event type
               hPage,                              // Page handle
               (UINT_PTR)pObj);                    // Object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnGraphicObjectMoveInd);
}



//
//
// Name:    wbOnObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectDeleteInd
(
    UINT_PTR param1,
    POM_OBJECT pObj
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    BOOL             processed = FALSE;

    DebugEntry(wbOnObjectDeleteInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            wbOnPageObjectDeleteInd(pObj);
            break;

        //
        // Sync Workset
        //
        case SYNC_CONTROL_WORKSET:
            ERROR_OUT(("Illegal object delete on sync control workset - ignored"));

            //
            // We do not confirm the delete since we do not want to lose the Sync
            // Control Object.
            //
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            wbOnUserObjectDeleteInd(pObj);
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectDeleteInd(pEvent16->worksetID, pObj);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectDeleteInd, processed);
    return(processed);
}



//
//
// Name:    wbOnPageObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received for an object in the Page Control Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnPageObjectDeleteInd(POM_OBJECT    pObj)
{
    UINT                objectType;

    DebugEntry(wbOnPageObjectDeleteInd);

    //
    // Get the type of object that is being deleted
    //
    if (wbGetPageObjectType(pObj, &objectType) != 0)
    {
        DC_QUIT;
    }

    switch(objectType)
    {
        case TYPE_CONTROL_PAGE_ORDER:
            //
            // The object is the Page Control Object - something serious is wrong
            // as this object should never be deleted.
            //
            ERROR_OUT(("Attempt to delete page control object"));
            break;

        case TYPE_CONTROL_LOCK:
            TRACE_OUT(("Lock object being deleted"));
            wbOnLockControlObjectDeleteInd(pObj);
            break;

        default:
            ERROR_OUT(("Bad object type"));
            break;
    }


DC_EXIT_POINT:
    DebugExitVOID(wbOnPageObjectDeleteInd);
}



//
//
// Name:    wbOnLockControlObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received for a lock object in the Page Control Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnLockControlObjectDeleteInd(POM_OBJECT      pObj
)
{
    DebugEntry(wbOnLockControlObjectDeleteInd);

    //
    // Confirm the delete to ObMan
    //
    TRACE_OUT(("Lock handle %x, expecting %x", pObj, m_pObjLock));
    if (pObj != m_pObjLock)
    {
        WARNING_OUT(("Unexpected lock handle %x, expecting %x",
                                       pObj, m_pObjLock));
    }

    OM_ObjectDeleteConfirm(m_pomClient,
                           m_hWSGroup,
                           PAGE_CONTROL_WORKSET,
                           pObj);
    m_pObjLock = NULL;

    //
    // Process according to the current lock state
    //
    switch(m_lockState)
    {
        case LOCK_STATE_PENDING_DELETE:
            //
            // We are deleting our lock object.  We must unlock the
            // workset.
            //
            TRACE_OUT(("Our lock object delete confirmed - unlocking the workset"));
            OM_WorksetUnlock(m_pomClient,
                             m_hWSGroup,
                             PAGE_CONTROL_WORKSET);
            break;

        case LOCK_STATE_LOCKED_OUT:
            //
            // The user with the lock has deleted the lock object. We treat
            // this as a removal of the whiteboard lock - we reset the
            // state at the end of this function.
            //
            TRACE_OUT(("Remote user's lock object deleted"));
            break;

        case LOCK_STATE_EMPTY:
            //
            // We have just deleted the object at the end of a call to tidy
            // up.  Carry on so we reset lockType / pObjPersonLock etc.
            //
            TRACE_OUT(("LOCK_STATE_EMPTY"));
            break;

        case LOCK_STATE_PENDING_LOCK:
            WARNING_OUT(("LOCK_STATE_PENDING_LOCK"));
            //
            // We don't expect to get here. If by some chance we do, then
            // just quit, since we should still get the workset lock con.
            //
            DC_QUIT;
            break;

        default:
            ERROR_OUT(("Bad lock state %d", m_lockState));
            break;
    }

    //
    // The lock object has been deleted, so there is no lock active
    //
    m_lockType             = WB_LOCK_TYPE_NONE;
    m_pObjPersonLock    = NULL;

    //
    // Record that there is now no lock
    //
    m_lockState = LOCK_STATE_EMPTY;
    TRACE_OUT(("Moved lock state to LOCK_STATE_EMPTY"));

    //
    // Notify the client of the lock status change
    //
    wbSendLockNotification();


DC_EXIT_POINT:
    DebugExitVOID(wbOnLockControlObjectDeleteInd);
}




//
//
// Name:    wbOnGraphicObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received for an object in a page workset.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectDeleteInd
(
    OM_WORKSET_ID       worksetID,
    POM_OBJECT    pObj
)
{
    WB_PAGE_HANDLE      hPage = (WB_PAGE_HANDLE)worksetID;
    BOOL                bConfirm = FALSE;

    DebugEntry(wbOnGraphicObjectDeleteInd);

    //
    // Record that the contents have changed
    //
    m_changed = TRUE;
    TRACE_OUT(("Changed flag now TRUE"));

    //
    // These events are handled within the core until the client is ready.
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Delete of graphic object before registration"));
        bConfirm = TRUE;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Delete in page that is not in use"));
        bConfirm = TRUE;
    }

    //
    // Check whether we are to pass the event on to the client
    //
    if (bConfirm)
    {
        //
        // Confirm the delete to ObMan
        //
        TRACE_OUT(("Confirming delete immediately"));
        OM_ObjectDeleteConfirm(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           pObj);
    }
    else
    {
        //
        // Inform the client of the object being added
        //
        TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_DELETE_IND"));
        WBP_PostEvent(
                 0,                                  // No delay
                 WBP_EVENT_GRAPHIC_DELETE_IND,       // Event type
                 hPage,                              // Page handle
                 (UINT_PTR)pObj);                    // Object handle
    }

    DebugExitVOID(wbOnGraphicObjectDeleteInd);
}




//
//
// Name:    wbOnUserObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received for an object in the User Information Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnUserObjectDeleteInd
(
    POM_OBJECT   pObjPerson
)
{
    DebugEntry(wbOnUserObjectDeleteInd);

    //
    // If the user which has been removed had a lock then remove its user
    // handle from the client data.  The lock is still there, and will be
    // removed when we get the WORKSET_UNLOCK_IND for the lock workset.  This
    // arrives after the user-object delete, because the user workset is of
    // higher priority.
    //
    if (m_pObjPersonLock == pObjPerson)
    {
        m_pObjPersonLock = NULL;
    }

    //
    // These events are ignored unless we are fully registered (the client
    // can do nothing about them).
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Delete of user object before registration - confirming"));

        //
        // Confirm the delete
        //
        OM_ObjectDeleteConfirm(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           pObjPerson);

        //
        // Nothing more to be done
        //
        DC_QUIT;
    }

    //
    // Inform the client of the user leaving
    //
    TRACE_OUT(("Posting WBP_EVENT_USER_LEFT_IND"));
    WBP_PostEvent(
               0,                                  // No delay
               WBP_EVENT_PERSON_LEFT,              // Event type
               0,                                  // No short parameter
               (UINT_PTR) pObjPerson);             // User object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnUserObjectDeleteInd);
}



//
//
// Name:    wbOnObjectUpdateInd
//
// Purpose: This routine is called whenever an OM_OBJECT_UPDATE_IND is
//          received for an object in a page workset.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectUpdateInd
(
    UINT_PTR param1,
    POM_OBJECT pObj
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    BOOL            processed = FALSE;

    DebugEntry(wbOnObjectUpdateInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            ERROR_OUT(("Illegal object update on page control workset - ignored"));

            //
            // Updates on the Page Control Object are not allowed - do not
            // confirm it.
            //
            break;

        //
        // Lock Workset
        //
        case SYNC_CONTROL_WORKSET:
            ERROR_OUT(("Illegal object update on sync control workset"));

            //
            // Updates to the Sync Control Object itself are not allowed - do not
            // confirm it.
            //
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            wbOnUserObjectUpdateInd(pObj);
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectUpdateInd(pEvent16->worksetID, pObj);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectUpdateInd, processed);
    return(processed);
}




//
//
// Name:    wbOnUserObjectUpdateInd
//
// Purpose: This routine is called whenever an OM_OBJECT_UPDATE_IND is
//          received for an object in the User Information Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnUserObjectUpdateInd(POM_OBJECT    pObj)
{
    DebugEntry(wbOnUserObjectUpdateInd);

    //
    // if the updated user object is not the local user's, and we have
    // already added the local user's object, then check the color hasn't
    // changed to clash with the local user's color.
    //
    if (   (m_pObjLocal != pObj)
        && (m_pObjLocal != NULL))
    {
        TRACE_OUT(("Check color of updated user object"));
        wbCheckPersonColor(pObj);
    }

    //
    // Don't inform the front end if we aren't fully registered
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("User object updated before registration - confirming"));

        //
        // Confirm the update immediately
        //
        OM_ObjectUpdateConfirm(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           pObj);

        //
        // Nothing more to be done
        //
        DC_QUIT;
    }

    //
    // Tell the client that a user has been updated
    //
    TRACE_OUT(("Posting WBP_EVENT_PERSON_UPDATE_IND"));
    WBP_PostEvent(
               0,                               // No delay
               WBP_EVENT_PERSON_UPDATE,         // Event type
               0,                               // No short parameter
               (UINT_PTR) pObj);                // User object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnUserObjectUpdateInd);
}



//
//
// Name:    wbOnUserObjectReplaceInd
//
// Purpose: This routine is called whenever an OM_OBJECT_REPLACE_IND is
//          received for an object in the User Information Workset.
//
//
// Returns: Error code
//
//
void WbClient::wbOnUserObjectReplaceInd(POM_OBJECT   pObj)
{
    DebugEntry(wbOnUserObjectReplaceInd);

    //
    // if the updated user object is not the local user's, and we have
    // already added the local user's object, then check the color hasn't
    // changed to clash with the local user's color.
    //
    if (   (m_pObjLocal != pObj)
        && (m_pObjLocal != NULL))
    {
        TRACE_OUT(("Check color of updated user object"));
        wbCheckPersonColor(pObj);
    }

    //
    // Don't inform the front end if we aren't fully registered
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("User object replaced before registration - confirming"));

        //
        // Confirm the replace immediately
        //
        OM_ObjectReplaceConfirm(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           pObj);

        //
        // Nothing more to be done
        //
        DC_QUIT;
    }

    //
    // Tell the client that a user has been updated
    //
    TRACE_OUT(("Posting WBP_EVENT_PERSON_UPDATE_IND"));
    WBP_PostEvent(
               0,                               // No delay
               WBP_EVENT_PERSON_REPLACE,        // Event type
               0,                               // No short parameter
               (UINT_PTR) pObj);                // User object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnUserObjectReplaceInd);
}




//
//
// Name:    wbOnGraphicObjectUpdateInd
//
// Purpose: This routine is called whenever an OM_OBJECT_UPDATE_IND is
//          received for an object in a page workset.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectUpdateInd
(
    OM_WORKSET_ID    worksetID,
    POM_OBJECT pObj
)
{
    WB_PAGE_HANDLE hPage = (WB_PAGE_HANDLE)worksetID;
    BOOL         bConfirm = FALSE;

    DebugEntry(wbOnGraphicObjectUpdateInd);

    //
    // Record that the contents have changed
    //
    m_changed = TRUE;
    TRACE_OUT(("Changed flag now TRUE"));

    //
    // These events are handled within the core until the client is ready.
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Update of graphic object before registration"));
        bConfirm = TRUE;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Update for page that is not in use"));
        bConfirm = TRUE;
    }

    //
    // Check whether we are to confirm the update now or ask the client
    //
    if (bConfirm)
    {
        //
        // Confirm the update immediately
        //
        TRACE_OUT(("Confirming update immediately"));
        OM_ObjectUpdateConfirm(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           pObj);
    }
    else
    {
        //
        // Inform the client of the object being added
        //
        TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_UPDATE_IND"));
        WBP_PostEvent(
                 0,                               // No delay
                 WBP_EVENT_GRAPHIC_UPDATE_IND,    // Event type
                 hPage,                           // Page handle
                 (UINT_PTR)pObj);                 // Object handle
    }

    DebugExitVOID(wbOnGraphicObjectUpdateInd);
}



//
//
// Name:    wbOnObjectReplaceInd
//
// Purpose: This routine is called whenever an OM_OBJECT_REPLACE_IND is
//          received.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectReplaceInd
(
    UINT_PTR param1,
    POM_OBJECT pObj
)
{
    POM_EVENT_DATA16 pEvent = (POM_EVENT_DATA16) &param1;
    BOOL        processed = FALSE;

    DebugEntry(wbOnObjectReplaceInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch (pEvent->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            wbOnPageObjectReplaceInd(pObj);
            break;

        //
        // Lock Workset
        //
        case SYNC_CONTROL_WORKSET:
            wbOnSyncObjectReplaceInd(pObj);
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            wbOnUserObjectReplaceInd(pObj);
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectReplaceInd(pEvent->worksetID, pObj);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectReplaceInd, processed);
    return(processed);
}


//
//
// Name:    wbOnPageObjectReplaceInd
//
// Purpose: This routine is called whenever the Page Control object is
//          replaced.
//
// Returns: Error code
//
//
void WbClient::wbOnPageObjectReplaceInd(POM_OBJECT    pObj)
{
    UINT                objectType;

    DebugEntry(wbOnPageObjectReplaceInd);

    //
    // Confirm the change to ObMan (cannot fail)
    //
    OM_ObjectReplaceConfirm(m_pomClient,
                          m_hWSGroup,
                          PAGE_CONTROL_WORKSET,
                          pObj);

    //
    // Read the object to get its type
    //
    if (wbGetPageObjectType(pObj, &objectType) != 0)
    {
        DC_QUIT;
    }

    //
    // Act according to the type of object added
    //
    switch (objectType)
    {
        case TYPE_CONTROL_LOCK:
            wbReadLock();
            break;

        case TYPE_CONTROL_PAGE_ORDER:
            wbOnPageControlObjectReplaceInd();
            break;

        default:
            ERROR_OUT(("Unknown object type added to Page Control Workset"));
            break;
    }


DC_EXIT_POINT:
    DebugExitVOID(wbOnPageObjectReplaceInd);
}



//
//
// Name:    wbOnPageControlObjectReplaceInd
//
// Purpose: This routine is called whenever the Page Control object is
//          replaced.
//
// Returns: Error code
//
//
void WbClient::wbOnPageControlObjectReplaceInd(void)
{
    DebugEntry(wbOnPageControlObjectReplaceInd);

    //
    // Process according to the current state
    //
    switch (m_state)
    {
        case STATE_REGISTERING:
            //
            // During registration we do nothing - the Page Order is updated
            // explicitly as one of the last registration actions.
            //
            break;

        case STATE_IDLE:
            //
            // When we are fully registered we must send events to the front-end
            // indicating what changes have been made to the page list.
            //
            wbProcessPageControlChanges();
            break;

        default:
            ERROR_OUT(("Bad client major state"));
            break;
    }

    DebugExitVOID(wbOnPageControlObjectReplaceInd);
}



//
//
// Name:    wbProcessPageControlChanges
//
// Purpose: This routine is called whenever the Page Control object is
//          replaced in idle state. It reads the new Page Control data
//          and starts the process of informing the client of any changes.
//
// Returns: Error code
//
//
void WbClient::wbProcessPageControlChanges(void)
{
    BYTE          toBeMarked[WB_MAX_PAGES];
    UINT         indexExternal;
    UINT         indexInternal;
    UINT         lLengthExternal;
    BOOL           addOutstanding = TRUE;
    PWB_PAGE_ORDER   pPageOrderExternal;
    PWB_PAGE_ORDER   pPageOrderInternal = &(m_pageOrder);
    PWB_PAGE_STATE   pPageState;
    POM_WORKSET_ID   pPageExternal;
    UINT     countPagesExternal;
    POM_OBJECTDATA      pData = NULL;

    DebugEntry(wbProcessPageControlChanges);

    //
    // Read the new Page Control Object
    //
    if (OM_ObjectRead(m_pomClient,
                     m_hWSGroup,
                     PAGE_CONTROL_WORKSET,
                     m_pObjPageControl,
                     &pData) != 0)
    {
        ERROR_OUT(("Error reading Page Control Object"));
        wbError();
        DC_QUIT;
    }

    //
    // Extract details from the external page order
    //
    lLengthExternal    = pData->length;
    pPageOrderExternal = (PWB_PAGE_ORDER) pData->data;
    pPageExternal      = pPageOrderExternal->pages;
    countPagesExternal = pPageOrderExternal->countPages;

    //
    // Process existing and newly added pages
    //
    for (indexExternal = 0; indexExternal < countPagesExternal; indexExternal++)
    {
        //
        // Convert the index into the Page Control Object to an index into the
        // internal Page List.
        //
        indexInternal = PAGE_WORKSET_ID_TO_INDEX(pPageExternal[indexExternal]);

        //
        // Test and update the internal page state as necessary
        //
        pPageState = &((m_pageStates)[indexInternal]);

        //
        // If the page is in use locally then we do not need to do anything
        // (the external and internal page lists agree already).
        //
        if (pPageState->state != PAGE_IN_USE)
        {
            switch (pPageState->subState)
            {
                case PAGE_STATE_EMPTY:
                    //
                    // The page does not yet have a workset open for it - open one
                    // now.  (But only open one per call to this routine to prevent
                    // swamping the message queue.  The other outstanding opens will
                    // be done when this routine is next called).
                    //
                    wbPageWorksetOpen(PAGE_INDEX_TO_HANDLE(indexInternal),
                            OPEN_EXTERNAL);

                    //
                    // Leave now - this routine will be called again when the open
                    // confirm is received for the workset just opened.
                    //
                    DC_QUIT;
                    break;

                case PAGE_STATE_LOCAL_OPEN_CONFIRM:
                case PAGE_STATE_EXTERNAL_OPEN_CONFIRM:
                case PAGE_STATE_EXTERNAL_ADD:
                    //
                    // Do nothing - the page is already in the add process
                    //
                    TRACE_OUT(("Page %d is already pending local add",
                                        PAGE_INDEX_TO_HANDLE(indexInternal)));
                    break;

                case PAGE_STATE_READY:
                    //
                    // The page workset has been opened previously - we can just mark
                    // the page as being in use immediately.
                    //
                    pPageState->state = PAGE_IN_USE;
                    pPageState->subState = PAGE_STATE_EMPTY;
                    TRACE_OUT(("Moved page %d state to PAGE_IN_USE",
                            (UINT) PAGE_INDEX_TO_HANDLE(indexInternal) ));
                    break;

                default:
                    ERROR_OUT(("Bad page substate %d", pPageState->subState));
                    break;
            }
        }
    }

    //
    // Mark any pages that no longer appear in the Page Control Object as
    // "delete pending" (unless they are already marked).
    //

    FillMemory(toBeMarked, sizeof(toBeMarked), TRUE);

    //
    // Flag which pages should be marked
    //
    for (indexExternal = 0; indexExternal < countPagesExternal; indexExternal++)
    {
        toBeMarked[PAGE_WORKSET_ID_TO_INDEX(pPageExternal[indexExternal])] = 0;
    }

    //
    // Mark them
    //
    for (indexInternal = 0; indexInternal < WB_MAX_PAGES; indexInternal++)
    {
        pPageState = &((m_pageStates)[indexInternal]);

        if (   (toBeMarked[indexInternal] == 1)
            && (pPageState->state == PAGE_IN_USE))
        {
            switch (pPageState->subState)
            {
                case PAGE_STATE_EMPTY:
                    //
                    // Ask the client for confirmation of the delete
                    //
                    TRACE_OUT(("Posting WBP_EVENT_PAGE_DELETE_IND"));
                    WBP_PostEvent(
                       0,                         // No delay
                       WBP_EVENT_PAGE_DELETE_IND, // Page being deleted
                       PAGE_INDEX_TO_HANDLE(indexInternal), // Page handle
                       0);

                    //
                    // Update the page state
                    //
                    pPageState->subState = PAGE_STATE_EXTERNAL_DELETE_CONFIRM;
                    TRACE_OUT(("Moved page %d substate to PAGE_STATE_EXTERNAL_DELETE_CONFIRM",
                            (UINT) PAGE_INDEX_TO_HANDLE(indexInternal) ));

                    //
                    // Leave now - this routine will be called again when the delete
                    // confirm is received for this workset.
                    //
                    DC_QUIT;
                    break;

                case PAGE_STATE_LOCAL_DELETE:
                    //
                    // Ask the client for confirmation of the delete
                    //
                    TRACE_OUT(("Posting WBP_EVENT_PAGE_DELETE_IND"));
                    WBP_PostEvent(
                       0,                         // No delay
                       WBP_EVENT_PAGE_DELETE_IND, // Page being deleted
                       PAGE_INDEX_TO_HANDLE(indexInternal), // Page handle
                       0);

                    //
                    // Update the page state
                    //
                    pPageState->subState = PAGE_STATE_LOCAL_DELETE_CONFIRM;
                    TRACE_OUT(("Moved page %d substate to PAGE_STATE_LOCAL_DELETE_CONFIRM",
                          (UINT) PAGE_INDEX_TO_HANDLE(indexInternal) ));

                    //
                    // Leave now - this routine will be called again when the delete
                    // confirm is received for this workset.
                    //
                    DC_QUIT;
                    break;

                case PAGE_STATE_EXTERNAL_DELETE:
                case PAGE_STATE_EXTERNAL_DELETE_CONFIRM:
                case PAGE_STATE_LOCAL_DELETE_CONFIRM:
                    //
                    // We are already expecting a delete for this page
                    //
                    TRACE_OUT(("Page %d is already pending local delete",
                                        PAGE_INDEX_TO_HANDLE(indexInternal)));
                    DC_QUIT;
                    break;

                default:
                    ERROR_OUT(("Bad page substate %d", pPageState->subState));
                    break;
            }
        }
    }

    //
    // There are no deletes or adds outstanding now
    //

    //
    // Copy the new page order to the internal page list
    //
    memcpy(pPageOrderInternal, pPageOrderExternal, lLengthExternal);

    //
    // Inform the client of the change
    //
    TRACE_OUT(("Posting WBP_EVENT_PAGE_ORDER_UPDATED"));
    WBP_PostEvent(
               0,                                      // No delay
               WBP_EVENT_PAGE_ORDER_UPDATED,           // Event number
               0,                                      // No parameters
               0);

    //
    // Check the number of pages ready in the cache
    //
    wbCheckReadyPages();

DC_EXIT_POINT:
    //
    // Release the Page Control Object
    //
    if (pData != NULL)
    {
        OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     PAGE_CONTROL_WORKSET,
                     m_pObjPageControl,
                     &pData);
    }

    DebugExitVOID(wbProcessPageControlChanges);
}



//
//
// Name:    wbOnSyncObjectReplaceInd
//
// Purpose: This routine is called whenever the Sync Control object is
//          replaced.
//
// Returns: Error code
//
//
void WbClient::wbOnSyncObjectReplaceInd(POM_OBJECT    pObj)
{
    POM_OBJECTDATA         pSyncObject;
    PWB_SYNC_CONTROL    pSyncControl;
    OM_OBJECT_ID        syncPersonID;

    DebugEntry(wbOnSyncControlReplaced);

    //
    // Confirm the replace of the object
    //
    OM_ObjectReplaceConfirm(m_pomClient,
                          m_hWSGroup,
                          SYNC_CONTROL_WORKSET,
                          pObj);

    //
    // Read the object and determine whether it was written by this client or
    // another.
    //
    if (OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         SYNC_CONTROL_WORKSET,
                         m_pObjSyncControl,
                         &pSyncObject) != 0)
    {
        ERROR_OUT(("Error reading Sync Control Object"));
        wbError();
        DC_QUIT;
    }

    pSyncControl = (PWB_SYNC_CONTROL) pSyncObject->data;

    //
    // Get the user ID from the object
    //
    syncPersonID = pSyncControl->personID;

    //
    // Release the Sync Control Object
    //
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   SYNC_CONTROL_WORKSET,
                   m_pObjSyncControl,
                   &pSyncObject);
    pSyncControl = NULL;

    //
    // If the user ID in the object is not the ID of the current client, we
    // must post a message to the front-end.
    //
    if (memcmp(&syncPersonID,
                &(m_personID),
                sizeof(syncPersonID)) != 0)
    {
        //
        // Post a "sync position updated" event to the front-end
        //
        TRACE_OUT(("Posting WBP_EVENT_SYNC_POSITION_UPDATED"));
        WBP_PostEvent(
                 0,
                 WBP_EVENT_SYNC_POSITION_UPDATED,
                 0,
                 0);
    }

DC_EXIT_POINT:
    DebugExitVOID(wbOnSyncControlReplaced);
}



//
//
// Name:    wbOnGraphicObjectReplaceInd
//
// Purpose: This routine is called whenever an OM_OBJECT_REPLACE_IND is
//          received for an object in a page workset.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectReplaceInd
(
    OM_WORKSET_ID   worksetID,
    POM_OBJECT      pObj
)
{
    WB_PAGE_HANDLE hPage = (WB_PAGE_HANDLE)worksetID;
    BOOL         bConfirm = FALSE;

    DebugEntry(wbOnGraphicObjectReplaceInd);

    //
    // Record that the contents have changed
    //
    m_changed = TRUE;
    TRACE_OUT(("Changed flag now TRUE"));

    //
    // These events are handled within the core until the client is ready.
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Replace of graphic object before registration"));
        bConfirm = TRUE;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Replace in page that is not in use"));
        bConfirm = TRUE;
    }

    //
    // Check whether we are to pass the replace on to the client
    //
    if (bConfirm)
    {
        //
        // Confirm the change to ObMan (cannot fail)
        //
        TRACE_OUT(("Confirming replace immediately"));
        OM_ObjectReplaceConfirm(m_pomClient,
                            m_hWSGroup,
                            worksetID,
                            pObj);
    }
    else
    {
        //
        // Inform the client of the object being added
        //
        TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_REPLACE_IND"));
        WBP_PostEvent(
                 0,                               // No delay
                 WBP_EVENT_GRAPHIC_REPLACE_IND,   // Event type
                 hPage,                           // Page handle
                 (UINT_PTR)pObj);                 // Object handle
    }


    DebugExitVOID(wbOnGraphicObjectReplaceInd);
}



//
//
// Name:    wbWritePageControl
//
// Purpose: Write the page control information to the Page Control Workset
//          from the copy held in client data. We write only those pages
//          which are marked as being in use (and are not pending delete).
//
// Returns: Error code
//
//
UINT WbClient::wbWritePageControl(BOOL create)
{
    UINT                result = 0;
    UINT                rc;
    UINT                index;
    UINT                length;
    PWB_PAGE_ORDER    pPageOrderInternal = &(m_pageOrder);
    PWB_PAGE_ORDER    pPageOrderExternal;
    WB_PAGE_HANDLE    hPage;
    PWB_PAGE_STATE    pPageState;
    POM_OBJECT  pObj;
    POM_OBJECTDATA       pData = NULL;
    UINT          generation;

    DebugEntry(wbWritePageControl);

    //
    // Allocate memory for the object.
    //
    length = sizeof(WB_PAGE_ORDER)
         - (  (WB_MAX_PAGES - pPageOrderInternal->countPages)
            * sizeof(OM_WORKSET_ID));

    if (OM_ObjectAlloc(m_pomClient,
                      m_hWSGroup,
                      PAGE_CONTROL_WORKSET,
                      length,
                      &pData) != 0)
    {
        ERROR_OUT(("Error allocating object"));
        DC_QUIT;
    }

    pData->length = length;

    //
    // Get a pointer to the page control object itself
    //
    pPageOrderExternal = (PWB_PAGE_ORDER) pData->data;

    //
    // Set the object type
    //
    pPageOrderExternal->objectType = TYPE_CONTROL_PAGE_ORDER;

    //
    // Increment the page list generation number indicating that we have
    // written a new version of the page list.
    //
    generation = MAKELONG(pPageOrderInternal->generationLo,
                              pPageOrderInternal->generationHi);
    generation++;
    pPageOrderInternal->generationLo = LOWORD(generation);
    pPageOrderInternal->generationHi = HIWORD(generation);

    //
    // Copy the page control data
    //
    pPageOrderExternal->objectType   = TYPE_CONTROL_PAGE_ORDER;
    pPageOrderExternal->generationLo = pPageOrderInternal->generationLo;
    pPageOrderExternal->generationHi = pPageOrderInternal->generationHi;
    pPageOrderExternal->countPages   = 0;

    //
    // Loop through the internal page order finding the pages that are in
    // use.
    //
    for (index = 0; index < pPageOrderInternal->countPages; index++)
    {
        //
        // Get the handle of the next page
        //
        hPage = (pPageOrderInternal->pages)[index];

        //
        // Check the page state
        //
        pPageState = GetPageState(hPage);
        if (   (pPageState->state == PAGE_IN_USE)
           && (pPageState->subState == PAGE_STATE_EMPTY))
        {
            //
            // Add the page to the external list
            //
            (pPageOrderExternal->pages)[pPageOrderExternal->countPages] = hPage;
            pPageOrderExternal->countPages++;
        }
    }

    //
    // We expect always to copy at least one page
    //
    ASSERT((pPageOrderExternal->countPages >= 1));

    //
    // Check whether we are creating or replacing the object
    //
    if (create)
    {
        //
        // Add the object to the workset (we never update these objects, so the
        // update length is set to 0).
        //
        rc = OM_ObjectAdd(m_pomClient,
                          m_hWSGroup,
                          PAGE_CONTROL_WORKSET,
                          &pData,
                          0,
                          &pObj,
                          LAST);
    }
    else
    {
        //
        // Replace the existing object
        //
        TRACE_OUT(("Replacing Page Control Object"));
        rc = OM_ObjectReplace(m_pomClient,
                          m_hWSGroup,
                          PAGE_CONTROL_WORKSET,
                          m_pObjPageControl,
                          &pData);
    }

    if (rc != 0)
    {
        //
        // Discard the object - it was not used to replace the existing one
        //
        TRACE_OUT(("Adding Page Control Object"));
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     PAGE_CONTROL_WORKSET,
                     &pData);

        ERROR_OUT(("Error adding/replacing page control object"));
        DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitDWORD(wbWritePageControl, result);
    return(result);
}



//
//
// Name:    wbCreateSyncControl
//
// Purpose: Create the sync control object
//
// Returns: None
//
//
UINT WbClient::wbCreateSyncControl(void)
{
    UINT    result;
    WB_SYNC sync;

    DebugEntry(wbCreateSyncControl);

    //
    // Set the sync information to no page, empty rectangle
    //
    ZeroMemory(&sync, sizeof(WB_SYNC));
    sync.length             = WB_SYNC_SIZE;
    sync.currentPage        = WB_PAGE_HANDLE_NULL;

    //
    // Write the object
    //
    result = wbWriteSyncControl(&sync, TRUE);

    DebugExitDWORD(wbCreateSyncControl, result);
    return(result);
}



//
//
// Name:    wbWriteSyncControl
//
// Purpose: Write the Sync Control object to the Page Control Workset
//
// Returns: Error code
//
//
UINT WbClient::wbWriteSyncControl
(
    PWB_SYNC    pSync,
    BOOL        create
)
{
    UINT         result = 0;
    UINT         rc;
    POM_OBJECT pObj;
    POM_OBJECTDATA      pData = NULL;
    PWB_SYNC_CONTROL pSyncControl;

    DebugEntry(wbWriteSyncControl);

    //
    // Allocate memory for the object.
    //
    rc = OM_ObjectAlloc(m_pomClient,
                      m_hWSGroup,
                      SYNC_CONTROL_WORKSET,
                      WB_SYNC_CONTROL_SIZE,
                      &pData);
    if (rc != 0)
    {
        ERROR_OUT(("Error allocating object"));
        DC_QUIT;
    }

    pData->length = WB_SYNC_CONTROL_SIZE;

    //
    // Copy the sync control data from the client information
    //
    pSyncControl           = (PWB_SYNC_CONTROL) pData->data;
    pSyncControl->personID = m_personID;
    memcpy(&(pSyncControl->sync), pSync, WB_SYNC_SIZE);

    //
    // Check whether we are creating or replacing the object
    //
    if (create)
    {
        //
        // Add the object to the workset
        //
        rc = OM_ObjectAdd(m_pomClient,
                          m_hWSGroup,
                          SYNC_CONTROL_WORKSET,
                          &pData,
                          WB_SYNC_CONTROL_SIZE,
                          &pObj,
                          LAST);

        //
        // If successful
        //
        if (rc == 0)
        {
            //
            // Save the handle of the sync control object
            //
            m_pObjSyncControl = pObj;

            //
            // Make sure we do not discard the object below
            //
            pData = NULL;
        }
    }
    else
    {
        //
        // Replace the existing object
        //
        rc = OM_ObjectReplace(m_pomClient,
                          m_hWSGroup,
                          SYNC_CONTROL_WORKSET,
                          m_pObjSyncControl,
                          &pData);

        //
        // Make sure we do not discard the object below
        //
        pData = NULL;
    }


DC_EXIT_POINT:
    //
    // If we still have the Sync Control object - discard it
    //
    if (pData != NULL)
    {
        //
        // Discard the object - it was not used to replace the existing one
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     SYNC_CONTROL_WORKSET,
                     &pData);
    }

    //
    // If an error occurred during processing - report it
    //
    if (rc != 0)
    {
        ERROR_OUT(("Error adding/replacing sync control object"));
        wbError();
        DC_QUIT;
    }

    DebugExitDWORD(wbWriteSyncControl, result);
    return(result);
}



//
//
// Name:    wbSelectPersonColor
//
// Purpose: Select a color identifier for the local user
//
// Returns: Selected color
//
//
UINT WbClient::wbSelectPersonColor(void)
{
    UINT    count = 0;
    UINT    result;
    POM_OBJECT   pObjUser;

    DebugEntry(wbSelectPersonColor);

    //
    // Select the color according to the order in the workset.  See comments
    // in wbCheckPersonColor for further details.
    //

    //
    // start at the first object, search for the position of the local user's
    // user object.
    //
    result = OM_ObjectH(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           0,
                           &pObjUser,
                            FIRST);
    while ((result == 0) && (pObjUser != m_pObjLocal))
    {
        count++;
        result = OM_ObjectH(m_pomClient,
                            m_hWSGroup,
                            USER_INFORMATION_WORKSET,
                            pObjUser,
                            &pObjUser,
                            AFTER);

    }

    if ((result != 0) && (result != OM_RC_NO_SUCH_OBJECT))
    {
        ERROR_OUT(("Unexpected return code from ObMan"));
    }

    DebugExitDWORD(wbSelectPersonColor, count);
    return (count);
}



//
//
// Name:    wbCheckPersonColor
//
// Purpose: Check whether a new user has usurped our color. If so we must
//          update our own color.
//
// Returns: None
//
//
void WbClient::wbCheckPersonColor
(
    POM_OBJECT    hCheckObject
)
{
    POM_OBJECTDATA        pCheckObject = NULL;
    PWB_PERSON         pUser;
    WB_PERSON          user;

    DebugEntry(wbCheckPersonColor);

    //
    // Read the new user information
    //
    if (OM_ObjectRead(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     hCheckObject,
                     &pCheckObject) != 0)
    {
        wbError();
        DC_QUIT;
    }

    pUser = (PWB_PERSON) pCheckObject->data;

    //
    // Compare the color identifier in the new user with that of the local
    // user, if they are different there is nothing to do.
    //
    if (pUser->colorId == m_colorId)
    {
        TRACE_OUT(("New user has same color as local user = %d", pUser->colorId));

        //
        // The user color is determined by the order in the workset group of
        // the user objects.  The first user has color 0, the second color 1
        // etc.
        //
        // When a user leaves the workset, however, the colors do not change.
        //
        // When a new user joins, it sets its color to its new position, and
        // the others will then be forced to change accordingly.  Whenever an
        // object add or update is received where the new remote user color
        // clashes with the local one, it is always the local user's job to
        // change color, since the remote user has selected his new color
        // according to his current position in the workset.  The local user
        // can't have the same position (since two users have two distinct user
        // objects, so therefore must have the wrong color.
        //

        //
        // Get the user object for the local user
        //
        if (wbPersonGet(m_pObjLocal, &user) != 0)
        {
            DC_QUIT;
        }

        //
        // Update the color
        //
        TRACE_OUT(("Old color ID for local user is %d", user.colorId));
        user.colorId = (TSHR_UINT16)wbSelectPersonColor();
        TRACE_OUT(("New color ID for local user is %d", user.colorId));

        //
        // Copy the person's color into the client's data
        //
        m_colorId = user.colorId;

        //
        // Write the new user information back
        //
        if (wbPersonUpdate(&user) != 0)
        {
            DC_QUIT;
        }
    }

DC_EXIT_POINT:

    //
    // If an object has been read, release it now
    //
    if (pCheckObject != NULL)
    {
        OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     hCheckObject,
                     &pCheckObject);
    }

    DebugExitVOID(wbCheckPersonColor);
}



//
//
// Name:    wbWriteLock
//
// Purpose: Add a lock object to the Page Control Workset
//
// Returns: Error code
//
//
UINT WbClient::wbWriteLock(void)
{
    UINT         result;
    POM_OBJECTDATA      pData;
    PWB_LOCK         pLock;
    POM_OBJECT pObj;

    DebugEntry(wbWriteLock);

    //
    // Create a lock object
    //
    result = OM_ObjectAlloc(m_pomClient,
                            m_hWSGroup,
                            PAGE_CONTROL_WORKSET,
                            sizeof(WB_LOCK),
                            &pData);
    if (result != 0)
    {
        ERROR_OUT(("Unable to allocate lock object = %d", result));
        wbError();
        DC_QUIT;
    }

    pData->length = sizeof(WB_LOCK);

    //
    // Set the lock object fields
    //
    pLock = (PWB_LOCK) pData->data;
    pLock->objectType = TYPE_CONTROL_LOCK;
    pLock->personID     = m_personID;
    pLock->lockType   = m_lockRequestType;

    //
    // If we already have the lock, then we can just replace the object
    //
    if (m_pObjLock == NULL)
    {
        //
        // Add the lock object to the Workset.  The Add indication received
        // by the remote users signals the presence of the lock to them.
        //
        result = OM_ObjectAdd(m_pomClient,
                                  m_hWSGroup,
                                  PAGE_CONTROL_WORKSET,
                                  &pData,
                                  sizeof(WB_LOCK),
                                  &pObj,
                                  LAST);
    }
    else
    {
        //
        // Replace the existing object
        //
        result = OM_ObjectReplace(m_pomClient,
                                  m_hWSGroup,
                                  PAGE_CONTROL_WORKSET,
                                  m_pObjLock,
                                  &pData);
    }

    if (result != 0)
    {
        //
        // The add or replace failed, we must discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                         m_hWSGroup,
                         PAGE_CONTROL_WORKSET,
                         &pData);

        ERROR_OUT(("Error adding user object"));
        wbError();
        DC_QUIT;
    }

    //
    // Save the handle of the lock object
    //
    TRACE_OUT(("Lock handle was %x, now %x", m_pObjLock, pObj));
    m_pObjLock = pObj;

DC_EXIT_POINT:
    DebugExitDWORD(wbWriteLock, result);
    return(result);
}



//
//
// Name:    wbReadLock
//
// Purpose: Update the lock information stored in the client data after a
//          change in the Lock Object.
//
// Returns: Error code
//
//
void WbClient::wbReadLock(void)
{
    UINT  count = 0;

    DebugEntry(wbReadLock);

    //
    // Before we read the lock information we need to ensure that the
    // PAGE_CONTROL_WORKSET and the USER_INFORMATION_WORKSET both contain
    // the objects we need.  If either of the objects are missing, quit and
    // wait until we are called again - this function will be called
    // whenever new objects are added to these worksets.
    //
    OM_WorksetCountObjects(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           &count);
    TRACE_OUT(("%d objects in USER_INFORMATION_WORKSET", count));
    if (count == 0)
    {
        TRACE_OUT(("Need to wait for USER_INFO object"));
        DC_QUIT;
    }
    OM_WorksetCountObjects(m_pomClient,
                           m_hWSGroup,
                           PAGE_CONTROL_WORKSET,
                           &count);
    TRACE_OUT(("%d objects in PAGE_CONTROL_WORKSET", count));
    if (count == 0)
    {
        TRACE_OUT(("Need to wait for PAGE_CONTROL object"));
        DC_QUIT;
    }

    TRACE_OUT(("Process lock"));
    wbProcessLockNotification();

DC_EXIT_POINT:
    DebugExitVOID(wbReadLock);
}


//
//
// Name:    wbProcessLockNotification
//
// Purpose:
//
// Returns: Error code
//
//
void WbClient::wbProcessLockNotification(void)
{
    UINT            rc = 0;
    POM_OBJECTDATA      pData;
    PWB_LOCK        pLock;
    WB_LOCK_TYPE    lockType;
    POM_OBJECT   pObjPersonLock;
    POM_OBJECT   pObj;
    POM_OBJECT   pObjLock;
    UINT            objectType = 0;

    DebugEntry(wbProcessLockNotification);

    //
    // Get the handle of the lock object.  We use the last object in the
    // workset to protect against lock objects being left lying around.
    //
    rc = OM_ObjectH(m_pomClient,
                        m_hWSGroup,
                        PAGE_CONTROL_WORKSET,
                        0,
                        &pObj,
                        LAST);
    if (rc != 0)
    {
        ERROR_OUT(("Error getting lock object handle = %d", rc));
        wbError();
        DC_QUIT;
    }

    //
    // Check that this is the CONTROL_LOCK object.  Quit if it isnt - we
    // will be called again later when the object arrices.
    //
    rc = wbGetPageObjectType(pObj, &objectType);
    if (rc != 0)
    {
        DC_QUIT;
    }
    if (objectType != TYPE_CONTROL_LOCK)
    {
        TRACE_OUT(("not LOCK control object - quit"));
        DC_QUIT;
    }

    //
    // Save the handle of the lock object
    //
    pObjLock = pObj;

    //
    // Read the object
    //
    rc = OM_ObjectRead(m_pomClient,
                       m_hWSGroup,
                       PAGE_CONTROL_WORKSET,
                       pObj,
                       &pData);
    if (rc != 0)
    {
        ERROR_OUT(("Error reading lock object %d", rc));
        wbError();
        DC_QUIT;
    }
    pLock = (PWB_LOCK) &(pData->data);

    //
    // Save the lock details
    //
    lockType   = (WB_LOCK_TYPE)pLock->lockType;
    TRACE_OUT(("Lock type %d", lockType));

    //
    // Convert the object ID held in the PAGE_CONTROL workset to an object
    // handle.
    //
    rc = OM_ObjectIDToPtr(m_pomClient,
                             m_hWSGroup,
                             USER_INFORMATION_WORKSET,
                             pLock->personID,
                             &pObjPersonLock);

    //
    // The return code is checked after the object release to ensure that
    // the object is not held and read again.
    //

    //
    // Release the lock object
    //
    OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     PAGE_CONTROL_WORKSET,
                     pObj,
                     &pData);

    //
    // Check the return code from the ID to Handle call
    //
    if (rc == OM_RC_BAD_OBJECT_ID)
    {
        WARNING_OUT(("Unknown ID - wait for next add of user object"));
        DC_QUIT;
    }
    else if (rc != 0)
    {
        ERROR_OUT(("Error (%d) converting lock user ID to handle", rc));
        wbError();
        DC_QUIT;
    }

    //
    // Validate the lock state and details
    //
    switch (m_lockState)
    {
        //
        // In this state we do not actually have the lock, but are waiting
        // for confirmation of an earlier workset-lock request. In this
        // case, we let the front end know that the lock request has failed
        // before sending indication of the lock by the other user.
        //
        case LOCK_STATE_PENDING_LOCK:
            ASSERT((pObjPersonLock != m_pObjLocal));

            m_lockState = LOCK_STATE_LOCKED_OUT;
            TRACE_OUT(("Moved lock state to LOCK_STATE_LOCKED_OUT"));

            WBP_PostEvent(
                         0,                      // No delay
                         WBP_EVENT_LOCK_FAILED,  // Lock request failed
                         0,                      // No parameters
                         0);
            break;

        //
        // In these states we do not have a lock - this must be a new lock
        // from remote user or an update to an old lock.
        //
        case LOCK_STATE_EMPTY:
        case LOCK_STATE_LOCKED_OUT:
            ASSERT((pObjPersonLock != m_pObjLocal));

            //
            // Update the lock state to show that we are now locked out
            //
            m_lockState = LOCK_STATE_LOCKED_OUT;
            TRACE_OUT(("Moved lock state to LOCK_STATE_LOCKED_OUT"));
            break;

        //
        // In these states we have the lock (or are expecting to get it)
        //
        case LOCK_STATE_GOT_LOCK:
        case LOCK_STATE_PENDING_ADD:
            ASSERT((pObjPersonLock == m_pObjLocal));

            //
            // Update the lock state to show that we are now locked out
            //
            m_lockState = LOCK_STATE_GOT_LOCK;
            TRACE_OUT(("Moved lock state to LOCK_STATE_GOT_LOCK"));
            break;

        //
        // The lock request has been cancelled - unlock the WS.
        //
        case LOCK_STATE_CANCEL_LOCK:
            break;

        //
        // In any other state we are not expecting any lock
        //
        default:
            ERROR_OUT(("Not expecting lock object add"));
            break;
    }

    //
    // Save the lock details
    //
    TRACE_OUT(("Lock handle was %x, now %x",
             m_pObjLock, pObjLock));
    m_pObjLock          = pObjLock;
    m_lockType          = lockType;
    m_pObjPersonLock    = pObjPersonLock;

    //
    // If the lock has subsequently been cancelled, unlock the WS.
    //
    if (m_lockState == LOCK_STATE_CANCEL_LOCK)
    {
        TRACE_OUT(("Cancel lock"));
        m_lockState = LOCK_STATE_GOT_LOCK;
        wbUnlock();
    }
    else
    {
        //
        // Inform the client of the lock.  The notification will be trapped
        // by the core if the client is not fully registered.
        //
        wbSendLockNotification();
    }

DC_EXIT_POINT:
    DebugExitVOID(wbProcessLockNotification);
}



//
//
// Name:    wbSendLockNotification
//
// Purpose: Post a lock notification to the client.  The lock information
//          held in the client memory must be up to date when this function
//          is called.
//
// Returns: Error code
//
//
void WbClient::wbSendLockNotification(void)
{
    UINT result = 0;
    UINT lockEvent;

    DebugEntry(wbSendLockNotification);

    //
    // Check that we are in a valid state for sending a lock notification
    //
    if (   (m_lockState == LOCK_STATE_GOT_LOCK)
        || (m_lockState == LOCK_STATE_LOCKED_OUT)
        || (m_lockState == LOCK_STATE_EMPTY))
    {
        //
        // Verify the lock type
        //
        switch (m_lockType)
        {
            case WB_LOCK_TYPE_CONTENTS:
                TRACE_OUT(("Posting WBP_EVENT_CONTENTS_LOCKED"));
                lockEvent = WBP_EVENT_CONTENTS_LOCKED;
                break;

            case WB_LOCK_TYPE_PAGE_ORDER:
                TRACE_OUT(("Posting WBP_EVENT_PAGE_ORDER_LOCKED"));
                lockEvent = WBP_EVENT_PAGE_ORDER_LOCKED;
                break;

            case WB_LOCK_TYPE_NONE:
                TRACE_OUT(("Posting WBP_EVENT_UNLOCKED"));
                lockEvent = WBP_EVENT_UNLOCKED;
                break;

            default:
                ERROR_OUT(("Bad lock type %d", (UINT) m_lockType));
                break;
        }

        //
        // Tell the client that the lock has been acquired or released
        //
        WBP_PostEvent(
                 0,
                 lockEvent,
                 0,
                 (UINT_PTR)m_pObjPersonLock);

        TRACE_OUT(("Sent lock notification"));
    }

    DebugExitVOID(wbSendLockNotification);
}



//
//
// Name:    wbOnWBPLock
//
// Purpose: Process a successful lock acquisitoin
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPLock(void)
{
    BOOL    processed = TRUE;

    DebugEntry(wbOnWBPLock);

    //
    // If we are registering and have just acquired the lock - we can now
    // continue the registration process.
    //

    //
    // Test the current state
    //
    switch (m_state)
    {
        //
        // We are waiting for registration to continue
        //
        case STATE_REGISTERING:
            //
            // Act on the registration substate
            //
            if (m_subState == STATE_REG_PENDING_LOCK)
            {
                //
                // Check that it is us who now has the lock
                //
                if (m_lockState != LOCK_STATE_GOT_LOCK)
                {
                    TRACE_OUT(("It is not us who has the lock"));

                    //
                    // Another client has acquired the lock - we must wait for them
                    // to add the Page Control Object.
                    //
                    m_subState = STATE_REG_PENDING_PAGE_CONTROL;
                    TRACE_OUT(("Moved to substate STATE_REG_PENDING_PAGE_CONTROL"));
                    DC_QUIT;
                }

                //
                // We now have the Page Control Workset locked - check for the
                // existence of the Page Control and Sync Control objects.  (We
                // have to do this because another client could have locked the
                // workset, added the objects and unlocked the workset just before
                // we requested the lock.  The Page Control Object may not have
                // reached us before we requested the lock.  Now that we have the
                // lock we are guaranteed to have all objects in the workset so the
                // object add events may have arrived just before the lock
                // confirmation.
                //
                if (   (m_pObjPageControl != 0)
                    && (m_pObjSyncControl != 0))
                {
                    //
                    // Unlock the workset
                    //
                    wbUnlock();

                    //
                    // Wait for the unlock to complete
                    //
                    m_subState = STATE_REG_PENDING_UNLOCK;
                    TRACE_OUT(("Moved to substate STATE_REG_PENDING_UNLOCK"));
                    DC_QUIT;
                }

                //
                // We are the first in the call - we must add the Page Control
                // Object.  (It is possible that another client added the Page
                // Control object and then failed.  To cover this we check
                // separately for the Page Control and Sync objects.)
                //
                if (m_pObjPageControl == 0)
                {
                    //
                    // Add a single page to the page control object using the first
                    // page workset (which we always open).
                    //
                    wbPagesPageAdd(0, FIRST_PAGE_WORKSET,
                         PAGE_FIRST);

                    //
                    // Write the Page Control information
                    //
                    if (wbWritePageControl(TRUE) != 0)
                    {
                        ERROR_OUT(("Error adding Page Control Object"));
                        wbError();
                        DC_QUIT;
                    }

                    //
                    // Update the state to "waiting for Page Control"
                    //
                    m_subState = STATE_REG_PENDING_PAGE_CONTROL;
                    TRACE_OUT(("Moved to substate STATE_REG_PENDING_PAGE_CONTROL"));
                    DC_QUIT;
                }

                //
                // The Page Control object is there, so the Sync Control object
                // must not be (we checked above for both being there and would
                // have exited by now if they were).
                //
                ASSERT((m_pObjSyncControl == 0));

                //
                // Create the Sync Control Object.
                //
                if (wbCreateSyncControl() != 0)
                {
                    ERROR_OUT(("Error adding Sync Control Object"));
                    wbError();
                    DC_QUIT;
                }

                //
                // Wait for the Sync Control object to be added
                //
                m_subState = STATE_REG_PENDING_SYNC_CONTROL;
                TRACE_OUT(("Moved substate to STATE_REG_PENDING_SYNC_CONTROL"));
                DC_QUIT;
            }
            break;

        case STATE_IDLE:
            //
            // We are fully registered.  The event must be passed on to the
            // front-end
            //
            processed = FALSE;
            break;

        //
        // We are in an unknown state
        //
        default:
            ERROR_OUT(("Bad client major state"));
            break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWBPLock, processed);
    return(processed);
}

//
//
// Name:    wbOnWBPLockFailed
//
// Purpose: Process a failed lock acquisition
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPLockFailed(void)
{
    BOOL    processed = TRUE;

    DebugEntry(wbOnWBPLockFailed);

    //
    // Check the current state
    //
    switch (m_state)
    {
        case STATE_REGISTERING:
            //
            // If we are registering and have just failed to acquire the lock -
            // this is because another user has the lock.  If both the page and
            // sync objects have been added, finish registration, otherwise wait
            // for them to be added.
            //
            if ( (m_pObjPageControl != 0) &&
                 (m_pObjSyncControl != 0))
            {
                TRACE_OUT(("Page Control and Sync Control objects both there."));
                TRACE_OUT(("Registration can be completed"));
                wbOnControlWorksetsReady();
                DC_QUIT;
            }

            if (m_pObjPageControl == 0)
            {
                TRACE_OUT(("Waiting for page control"));
                m_subState = STATE_REG_PENDING_PAGE_CONTROL;
                DC_QUIT;
            }

            if (m_pObjSyncControl == 0)
            {
                TRACE_OUT(("Waiting for sync control"));
                m_subState = STATE_REG_PENDING_SYNC_CONTROL;
                DC_QUIT;
            }
            break;

        case STATE_IDLE:
            //
            // We are fully registered.  The event must be passed on to the
            // front-end
            //
            processed = FALSE;
            break;

        default:
            ERROR_OUT(("Bad main state"));
            break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWBPLockFailed, processed);
    return(processed);
}

//
//
// Name:    wbOnWBPUnlocked
//
// Purpose: Process an unlock notification
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPUnlocked(void)
{
    BOOL    processed = TRUE;

    DebugEntry(wbOnWBPUnlocked);

    //
    // If we are registering and waiting to unlock the Page Control Workset
    // we must complete registration here.
    //

    //
    // Check the current state
    //
    switch (m_state)
    {
        case STATE_REGISTERING:
            //
            // Check whether we are expecting his event
            //
            if(m_subState == STATE_REG_PENDING_UNLOCK)
            {
                //
                // Continue the registration process
                //
                wbOnControlWorksetsReady();
                DC_QUIT;
            }

            //
            // We were not expecting the unlock event
            //
            WARNING_OUT(("Unexpected unlock event"));
            break;

        case STATE_IDLE:
            //
            // We are fully registered.  The event must be passed on to the
            // front-end
            //
            processed = FALSE;
            break;

        default:
            ERROR_OUT(("Bad main state"));
            break;
    } // Switch on client state


DC_EXIT_POINT:
    DebugExitBOOL(wbOnWBPUnlocked, processed);
    return(processed);
}




//
//
// Name:    wbOnWBPPageOrderUpdated
//
// Purpose: Process a page order updated notification
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPPageOrderUpdated(void)
{
    BOOL    processed = FALSE;

    DebugEntry(wbOnWBPPageOrderUpdated);

    //
    // If we are registering and waiting for the Page Order to be brought
    // up-to-date we can now continue registration.
    //
    if (m_state == STATE_REGISTERING)
    {
        //
        // Show that we have processed the event (we do not want to pass it on
        // to the client, they are not yet fully registered and will not be
        // expecting it).
        //
        processed = TRUE;

        //
        // If we have enough pages ready in the cache, we have completed
        // registration.  (Otherwise the call to CheckReadyPages will open
        // another page and will complete registration later.)
        //
        if (wbCheckReadyPages())
        {
            wbCompleteRegistration();
            DC_QUIT;
        }

        //
        // We must wait for sufficiently many pages to be ready
        //
        m_subState = STATE_REG_PENDING_READY_PAGES;
        TRACE_OUT(("Moved substate to STATE_REG_PENDING_READY_PAGES"));
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWBPPageOrderUpdated, processed);
    return(processed);
}



//
//
// Name:    wbPersonGet
//
// Purpose: Get user details
//
// Returns: Error code
//
//
UINT WbClient::wbPersonGet
(
    POM_OBJECT      pObjUser,
    PWB_PERSON      pUser
)
{
    UINT    result = 0;
    POM_OBJECTDATA pUserObject;

    DebugEntry(wbPersonGet);

    if (pObjUser == m_pObjLocal)
    {
        TRACE_OUT(("Call is for local user details"));
    }

    //
    // Read the object.
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         USER_INFORMATION_WORKSET,
                         pObjUser,
                         &pUserObject);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectRead = %d", result));
        DC_QUIT;
    }

    //
    // Copy the read user object into the buffer passed
    //
    memcpy(pUser, pUserObject->data, sizeof(WB_PERSON));
    TRACE_OUT(("CMG personID %u", pUser->cmgPersonID));

    //
    // Release the object
    //
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   USER_INFORMATION_WORKSET,
                    pObjUser,
                   &pUserObject);

    //
    // If the call is for the local user, update the color field to ensure it
    // doesn't get overwritten in a race condition with the front-end (i.e.
    // the front end tries to update the user before the color-change event
    // has been received).  The core "knows better" than ObMan what the local
    // user's color is.  This is safe because the color field is only ever
    // changed locally.
    //
    if (pObjUser == m_pObjLocal)
    {
        pUser->colorId = (TSHR_UINT16)m_colorId;
    }


DC_EXIT_POINT:
    DebugExitDWORD(wbPersonGet, result);
    return(result);
}



//
//
// Name:    wbPersonUpdate
//
// Purpose: Update the local user object - this is only used by the CORE -
//          the front-end calls WBP_SetPersonData, which does a _replace_.
//
// Returns: Error code
//
//
UINT WbClient::wbPersonUpdate(PWB_PERSON pUser)
{
    UINT    result = 0;
    POM_OBJECTDATA pUserObject;

    DebugEntry(wbPersonUpdate);

    //
    // Allocate a user object
    //
    result = OM_ObjectAlloc(m_pomClient,
                          m_hWSGroup,
                          USER_INFORMATION_WORKSET,
                          sizeof(WB_PERSON),
                          &pUserObject);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectAlloc = %d", result));
        DC_QUIT;
    }

    //
    // Set the length of the object
    //
    pUserObject->length = WB_PERSON_OBJECT_UPDATE_SIZE,

    //
    // Copy the user information into the ObMan object
    //
    memcpy(pUserObject->data, pUser, sizeof(WB_PERSON));

    //
    // Update the object
    //
    result = OM_ObjectUpdate(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           m_pObjLocal,
                           &pUserObject);

    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectUpdate = %d", result));

        //
        // Discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     &pUserObject);

        DC_QUIT;
    }

    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_UPDATE_IND event will be generated.
    //

DC_EXIT_POINT:
    DebugExitDWORD(wbPersonUpdate, result);
    return(result);
}



//
//
// Name:    wbGetNetUserID().
//
// Purpose: Get the network user ID for this client
//
// Returns:
//
//
BOOL WbClient::wbGetNetUserID(void)
{
    BOOL    result = TRUE;
    UINT  rc = 0;

    DebugEntry(wbGetNetUserID);

    rc = OM_GetNetworkUserID(m_pomClient,
                             m_hWSGroup,
                             &m_clientNetID);
    if (rc != 0)
    {
        if (rc == OM_RC_LOCAL_WSGROUP)
        {
            m_clientNetID = 0;
        }
        else
        {
            result = FALSE;
        }
    }

    DebugExitBOOL(wbGetNetUserID, result);
    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.95\global95.h ===
//
// GLOBAL95.H
// Global variables specific to Win95
//

DC_DATA ( DWORD,     g_hInstAs16 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.nt\cpi32dll.cpp ===
#include "precomp.h"


//
// CPI32DLL.CPP
// CPI32 dll entry point
//
// Copyright(c) Microsoft 1997-
//

#define INIT_DBG_ZONE_DATA
#include "dbgzones.h"


BOOL APIENTRY DllMain (HINSTANCE hInstance, DWORD reason, LPVOID plReserved)
{
    BOOL    rc = TRUE;

    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
                        (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif // _DEBUG

            DBG_INIT_MEMORY_TRACKING(hInstance);

            //
            // Utility stuff
            //
            if (!UT_HandleProcessStart(hInstance))
            {
                rc = FALSE;
                break;
            }

            //
            // Call platform specific init code
            //
            OSI_Load();

            //
            // Do common stuff
            //

            //
            // Init Persistent PKZIP -- this just calculates some values 
            // which are effectively constants, the tables are just too 
            // unwieldy to declare as such.
            //
            GDC_Init();

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // Call platform specific cleanup code
            //
            OSI_Unload();


            //
            // Utility stuff
            //
            UT_HandleProcessEnd();

            DBG_CHECK_MEMORY_TRACKING(hInstance);

#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif // _DEBUG

            break;
        }

        case DLL_THREAD_DETACH:
            UT_HandleThreadEnd();
            break;

        default:
            break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.95\osi.cpp ===
#include "precomp.h"


//
// OSI.C
// OS Isolation Layer, Win95 version
//
// Copyright(c) Microsoft 1997-
//

#include <version.h>
#include <ndcgver.h>

#include <osi.h>

extern "C"
{
    #include <asthk.h>
}

#define MLZ_FILE_ZONE  ZONE_CORE


//
// OSI_Load()
// This handles our process attach code.  It establishes thunks to the
// 16-bit Win95 library.  WE CAN ONLY DO THIS ONCE.  It is imperative
// that a flat-thunk pair come/go together, since the 32-bit piece hangs
// on to a shared memory section that is the thunk table in the 16-bit piece.
//
void OSI_Load(void)
{
    DebugEntry(OSI_Load);

    ASSERT(!g_hInstAs16);

    g_asWin95 = TRUE;

    //
    // Establish the thunks with AS16
    //
    if (FT_thkConnectToFlatThkPeer(TEXT("nmaswin.dll"), TEXT("nmas.dll")))
    {
        OSILoad16(&g_hInstAs16);
        ASSERT(g_hInstAs16);
    }
    else
    {
        ERROR_OUT(("Couldn't load nmaswin.dll"));

        //
        // Note, even on load failure, we will continue.  We just don't let
        // you do app sharing stuff.
        //
    }

    DebugExitVOID(OSI_Load);
}


//
// OSI_Unload()
// This handles our process detach code.  It frees the 16-bit library that
// we are pared with.
//
void OSI_Unload(void)
{

    DebugEntry(OSI_Unload);

    if (g_hInstAs16)
    {
        //
        // See comment for OSI_Term().  On catastropic failure, we may
        // call this BEFORE OSI_Term.  So null out variables it uses.
        //
        g_osiInitialized = FALSE;

        //
        // Free 16-bit library so loads + frees are paired.  Note that 16-bit
        // cleanup occurs when the library is freed.
        //
        FreeLibrary16(g_hInstAs16);
        g_hInstAs16 = 0;


    }

    DebugExitVOID(OSI_Unload);
}



//
// OSI_Init
// This initializes our display driver/hook dll communication code.
//
// We load our 16-bit library and establish thunks to it.
//
void OSI_Init(void)
{
    DebugEntry(OSI_Init);

    if (!g_hInstAs16)
    {
        WARNING_OUT(("No app sharing at all since library not present"));
        DC_QUIT;
    }

    //
    // We are quasi initialized.
    //
    g_osiInitialized = TRUE;

    ASSERT(g_asMainWindow);
    ASSERT(g_asHostProp);

    //
    // Call into 16-bit code to do any initialization necessary
    //

    g_asCanHost = OSIInit16(DCS_MAKE_VERSION(), g_asMainWindow, g_asHostProp,
        (LPDWORD)&g_asSharedMemory, (LPDWORD)g_poaData,
        (LPDWORD)&g_lpimSharedData, (LPDWORD)&g_sbcEnabled, (LPDWORD)g_asbcShuntBuffers,
        g_asbcBitMasks);

    if (g_asCanHost)
    {
        ASSERT(g_asSharedMemory);
        ASSERT(g_poaData[0]);
        ASSERT(g_poaData[1]);
        ASSERT(g_lpimSharedData);

        if (g_sbcEnabled)
        {
            ASSERT(g_asbcShuntBuffers[0]);
        }
    }
    else
    {
        ASSERT(!g_asSharedMemory);
        ASSERT(!g_poaData[0]);
        ASSERT(!g_poaData[1]);
        ASSERT(!g_sbcEnabled);
        ASSERT(!g_asbcShuntBuffers[0]);
    }

DC_EXIT_POINT:
    DebugExitVOID(OSI_Init);
}



//
// OSI_Term()
// This cleans up our resources, closes the driver, etc.
//
void  OSI_Term(void)
{
    UINT    i;

    DebugEntry(OSI_Term);

    ASSERT(GetCurrentThreadId() == g_asMainThreadId);

    if (g_osiInitialized)
    {
        g_osiInitialized = FALSE;

        //
        // In Ctl+Alt+Del, the process detach of mnmcpi32.dll may happen
        // first, followed by the process detach of mnmcrsp_.dll.  The latter
        // will call DCS_Term, which will call OSI_Term().  We don't want to
        // blow up.  So OSI_Unload nulls out these variables also.
        //
        ASSERT(g_hInstAs16);

        OSITerm16(FALSE);
    }

    // Clear our shared memory variables
    for (i = 0; i < 3; i++)
    {
        g_asbcBitMasks[i] = 0;
    }

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        g_asbcShuntBuffers[i] = NULL;
    }
    g_sbcEnabled = FALSE;

    g_asSharedMemory = NULL;
    g_poaData[0] = NULL;
    g_poaData[1] = NULL;
    g_asCanHost = FALSE;
    g_lpimSharedData = NULL;

    DebugExitVOID(OSI_Term);
}



//
// OSI_FunctionRequest()
//
// This is a generic way of communicating with the graphics part of
// hosting.  On NT, it's a real display driver, and this uses ExtEscape.
// On Win95, it's a 16-bit dll, and this uses a thunk.
//
BOOL  OSI_FunctionRequest
(
    DWORD   escapeFn,
    LPOSI_ESCAPE_HEADER  pRequest,
    DWORD   requestLen
)
{
    BOOL    rc;

    DebugEntry(OSI_FunctionRequest);

    ASSERT(g_osiInitialized);
    ASSERT(g_hInstAs16);

    //
    // NOTE:  In Win95, since we use a direct thunk to communicate
    // with our driver, we don't really need to
    //      (1) Fill in an identifier (AS16 knows it's us)
    //      (2) Fill in the escape fn field
    //      (3) Fill in the version stamp (the thunk fixups will fail
    //          if pieces are mismatched)
    //
    // However, we keep the identifer field around.  If/when we support
    // multiple AS clients at the same time, we will want to know
    // who the caller was.
    //

    pRequest->identifier = OSI_ESCAPE_IDENTIFIER;
    pRequest->escapeFn   = escapeFn;
    pRequest->version    = DCS_MAKE_VERSION();

    rc = OSIFunctionRequest16(escapeFn, pRequest, requestLen);

    DebugExitBOOL(OSI_FunctionRequest, rc);
    return(rc);
}



BOOL WINAPI OSI_StartWindowTracking(void)
{
    ASSERT(g_hInstAs16);
    return(OSIStartWindowTracking16());
}



void WINAPI OSI_StopWindowTracking(void)
{
    ASSERT(g_hInstAs16);
    OSIStopWindowTracking16();
}



BOOL WINAPI OSI_IsWindowScreenSaver(HWND hwnd)
{
    ASSERT(g_hInstAs16);
    return(OSIIsWindowScreenSaver16(hwnd));
}


BOOL WINAPI OSI_IsWOWWindow(HWND hwnd)
{
    return(FALSE);
}


BOOL WINAPI OSI_ShareWindow(HWND hwnd, UINT uType, BOOL fRepaint, BOOL fUpdateCount)
{
    ASSERT(g_hInstAs16);
    return(OSIShareWindow16(hwnd, uType, fRepaint, fUpdateCount));
}


BOOL WINAPI OSI_UnshareWindow(HWND hwnd, BOOL fUpdateCount)
{
    ASSERT(g_hInstAs16);
    return(OSIUnshareWindow16(hwnd, fUpdateCount));
}

void OSI_RepaintDesktop(void)
{
}

void OSI_SetGUIEffects(BOOL fOn)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.nt\makefile.inc ===
!include $(ROOT)\as\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.95\i386\asthkls.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Thu Apr 01 11:42:56 1999

;Command Line: d:\projects\cayman\dev\bin\misc\i386\thunk -t thk -o i386\asthkls.asm ..\thk\asthkls.thk 

	TITLE	$i386\asthkls.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_PrologPrime	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef QT_ThunkPrime	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_thkTargetTable	;Flat address of target table in 16-bit module.

public FT_thkChecksum32
FT_thkChecksum32	dd	016bddh


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data
;---------------------------------------------------------------
;Flat address of target table in 16-bit module name.
;Filled in by the initial handshaking routine: FT_thkConnectToFlatThkPeer
;---------------------------------------------------------------
FT_thkTargetTable	dd	0	;Flat address of target table in 16-bit module.


	.code 

FT_thkDynaName	db	'FT_thkThkConnectionData',0

;------------------------------------------------------------
;FT_thkConnectToFlatThkPeer:;
; The 32-bit dll must call this routine once at initialization
; time. It will load the 16-bit library and fetch the pointers
; needed to make the flat thunk run.
;
; Calling sequence:
;
;   FT_thkConnectToFlatThkPeer	proto	near stdcall, dll16:dword, dll32:dword
;
;   Name16     db   'mumble16.dll',0   ;Name of 16-bit library
;   Name32     db   'mumble32.dll',0   ;Name of 32-bit library
;
;              invoke FT_thkConnectToFlatThkPeer offset Name16, offset Name32
;              or   eax,eax
;              jz   failed
;              ;success
;
;------------------------------------------------------------
public FT_thkConnectToFlatThkPeer@8
FT_thkConnectToFlatThkPeer@8:
extern ThunkInitLSF@20:near32
	pop	edx	;Pop return address
	push	offset 016bddh	;Checksum
	push	offset FT_thkDynaName	;Symbol exported from peer.
	push	offset FT_thkTargetTable	;Address of destination.
	push	edx
	jmp	ThunkInitLSF@20
		





pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk	db	0ebh, 30
	db	30 dup(0cch)	;Patch space.
	db	0e8h,0,0,0,0	;CALL NEAR32 $
	db	58h	;POP EAX
	db	2dh,32+5,0,0,0	;SUB EAX, IMM32
	db	0bah	;MOV EDX, IMM32
	dd	offset FT_thkTargetTable - offset QT_Thunk_thk
	db	068h	;PUSH IMM32
	dd	offset QT_ThunkPrime
	db	0c3h	;RETN

FT_Prolog_thk	db	0ebh, 30
	db	30 dup(0cch)	;Patch space.
	db	0e8h,0,0,0,0	;CALL NEAR32 $
	db	5ah	;POP EDX
	db	81h,0eah, 32+5,0,0,0	;SUB EDX, IMM32
	db	52h	;PUSH EDX
	db	068h	;PUSH IMM32
	dd	offset FT_thkTargetTable - offset FT_Prolog_thk
	db	068h	;PUSH IMM32
	dd	offset FT_PrologPrime
	db	0c3h	;RETN


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include asthkls.inc



;************************ START OF THUNK BODIES************************




;
public OSILoad16@4
OSILoad16@4:
	FAPILOG16	270
	mov	cl,11
; OSILoad16(16) = OSILoad16(32) {}
;
; dword ptr [ebp+8]:  phInstance
;
public IIOSILoad16@4
IIOSILoad16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public OSIInit16@36
OSIInit16@36:
	FAPILOG16	256
	mov	cl,10
; OSIInit16(16) = OSIInit16(32) {}
;
; dword ptr [ebp+8]:  version
; dword ptr [ebp+12]:  hwnd
; dword ptr [ebp+16]:  atom
; dword ptr [ebp+20]:  ppShared
; dword ptr [ebp+24]:  ppoaShared
; dword ptr [ebp+28]:  pimShared
; dword ptr [ebp+32]:  psbcEnabled
; dword ptr [ebp+36]:  psbcShunt
; dword ptr [ebp+40]:  pBitmasks
;
public IIOSIInit16@36
IIOSIInit16@36:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;version: dword->dword
	push	word ptr [ebp+12]	;hwnd: dword->word
	push	word ptr [ebp+16]	;atom: dword->word
	call	SMapLS_IP_EBP_20
	push	eax
	call	SMapLS_IP_EBP_24
	push	eax
	call	SMapLS_IP_EBP_28
	push	eax
	call	SMapLS_IP_EBP_32
	push	eax
	call	SMapLS_IP_EBP_36
	push	eax
	call	SMapLS_IP_EBP_40
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_20
	call	SUnMapLS_IP_EBP_24
	call	SUnMapLS_IP_EBP_28
	call	SUnMapLS_IP_EBP_32
	call	SUnMapLS_IP_EBP_36
	call	SUnMapLS_IP_EBP_40
	leave
	retn	36





;
public OSITerm16@4
OSITerm16@4:
	FAPILOG16	242
	mov	cl,9
; OSITerm16(16) = OSITerm16(32) {}
;
; dword ptr [ebp+8]:  fUnloading
;
public IIOSITerm16@4
IIOSITerm16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;fUnloading: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public OSIFunctionRequest16@12
OSIFunctionRequest16@12:
	FAPILOG16	217
	mov	cl,8
; OSIFunctionRequest16(16) = OSIFunctionRequest16(32) {}
;
; dword ptr [ebp+8]:  escape
; dword ptr [ebp+12]:  lpvEsc
; dword ptr [ebp+16]:  cbEsc
;
public IIOSIFunctionRequest16@12
IIOSIFunctionRequest16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;escape: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbEsc: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public OSIStartWindowTracking16@0
OSIStartWindowTracking16@0:
	FAPILOG16	188
	mov	cl,7
; OSIStartWindowTracking16(16) = OSIStartWindowTracking16(32) {}
;
;
public IIOSIStartWindowTracking16@0
IIOSIStartWindowTracking16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn





;
public OSIStopWindowTracking16@0
OSIStopWindowTracking16@0:
	FAPILOG16	160
	mov	cl,6
; OSIStopWindowTracking16(16) = OSIStopWindowTracking16(32) {}
;
;
public IIOSIStopWindowTracking16@0
IIOSIStopWindowTracking16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn





;
public OSIShareWindow16@16
OSIShareWindow16@16:
	FAPILOG16	139
	mov	cl,5
; OSIShareWindow16(16) = OSIShareWindow16(32) {}
;
; dword ptr [ebp+8]:  hwnd
; dword ptr [ebp+12]:  uType
; dword ptr [ebp+16]:  fRedraw
; dword ptr [ebp+20]:  fUpdate
;
public IIOSIShareWindow16@16
IIOSIShareWindow16@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwnd: dword->word
	push	word ptr [ebp+12]	;uType: dword->word
	push	word ptr [ebp+16]	;fRedraw: dword->word
	push	word ptr [ebp+20]	;fUpdate: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	16





;
public OSIIsWindowScreenSaver16@4
OSIIsWindowScreenSaver16@4:
	FAPILOG16	87
	mov	cl,3
; OSIIsWindowScreenSaver16(16) = OSIIsWindowScreenSaver16(32) {}
;
; dword ptr [ebp+8]:  hwnd
;
public IIOSIIsWindowScreenSaver16@4
IIOSIIsWindowScreenSaver16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwnd: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public OSIInstallControlledHooks16@8
OSIInstallControlledHooks16@8:
	FAPILOG16	55
	mov	cl,2
	jmp	IIOSIInstallControlledHooks16@8
public OSIUnshareWindow16@8
OSIUnshareWindow16@8:
	FAPILOG16	116
	mov	cl,4
; OSIInstallControlledHooks16(16) = OSIInstallControlledHooks16(32) {}
;
; dword ptr [ebp+8]:  fInstall
; dword ptr [ebp+12]:  fDesktop
;
public IIOSIInstallControlledHooks16@8
IIOSIInstallControlledHooks16@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;fInstall: dword->word
	push	word ptr [ebp+12]	;fDesktop: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	8





;
public OSIInjectMouseEvent16@20
OSIInjectMouseEvent16@20:
	FAPILOG16	29
	mov	cl,1
; OSIInjectMouseEvent16(16) = OSIInjectMouseEvent16(32) {}
;
; dword ptr [ebp+8]:  param1
; dword ptr [ebp+12]:  param2
; dword ptr [ebp+16]:  param3
; dword ptr [ebp+20]:  param4
; dword ptr [ebp+24]:  param5
;
public IIOSIInjectMouseEvent16@20
IIOSIInjectMouseEvent16@20:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;param1: dword->word
	push	word ptr [ebp+12]	;param2: dword->word
	push	word ptr [ebp+16]	;param3: dword->word
	push	word ptr [ebp+20]	;param4: dword->word
	push	dword ptr [ebp+24]	;param5: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	20





;
public OSIInjectKeyboardEvent16@16
OSIInjectKeyboardEvent16@16:
	FAPILOG16	0
	mov	cl,0
; OSIInjectKeyboardEvent16(16) = OSIInjectKeyboardEvent16(32) {}
;
; dword ptr [ebp+8]:  param1
; dword ptr [ebp+12]:  param2
; dword ptr [ebp+16]:  param3
; dword ptr [ebp+20]:  param4
;
public IIOSIInjectKeyboardEvent16@16
IIOSIInjectKeyboardEvent16@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;param1: dword->word
	push	word ptr [ebp+12]	;param2: dword->word
	push	word ptr [ebp+16]	;param3: dword->word
	push	dword ptr [ebp+20]	;param4: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	16




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] OSIInjectKeyboardEvent16',0
	db	'[F] OSIInjectMouseEvent16',0
	db	'[F] OSIInstallControlledHooks16',0
	db	'[F] OSIIsWindowScreenSaver16',0
	db	'[F] OSIUnshareWindow16',0
	db	'[F] OSIShareWindow16',0
	db	'[F] OSIStopWindowTracking16',0
	db	'[F] OSIStartWindowTracking16',0
	db	'[F] OSIFunctionRequest16',0
	db	'[F] OSITerm16',0
	db	'[F] OSIInit16',0
	db	'[F] OSILoad16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef OSIInjectKeyboardEvent16:far16
externDef OSIInjectMouseEvent16:far16
externDef OSIInstallControlledHooks16:far16
externDef OSIIsWindowScreenSaver16:far16
externDef OSIUnshareWindow16:far16
externDef OSIShareWindow16:far16
externDef OSIStopWindowTracking16:far16
externDef OSIStartWindowTracking16:far16
externDef OSIFunctionRequest16:far16
externDef OSITerm16:far16
externDef OSIInit16:far16
externDef OSILoad16:far16


FT_thkTargetTable label word
	dw	offset OSIInjectKeyboardEvent16
	dw	   seg OSIInjectKeyboardEvent16
	dw	offset OSIInjectMouseEvent16
	dw	   seg OSIInjectMouseEvent16
	dw	offset OSIInstallControlledHooks16
	dw	   seg OSIInstallControlledHooks16
	dw	offset OSIIsWindowScreenSaver16
	dw	   seg OSIIsWindowScreenSaver16
	dw	offset OSIUnshareWindow16
	dw	   seg OSIUnshareWindow16
	dw	offset OSIShareWindow16
	dw	   seg OSIShareWindow16
	dw	offset OSIStopWindowTracking16
	dw	   seg OSIStopWindowTracking16
	dw	offset OSIStartWindowTracking16
	dw	   seg OSIStartWindowTracking16
	dw	offset OSIFunctionRequest16
	dw	   seg OSIFunctionRequest16
	dw	offset OSITerm16
	dw	   seg OSITerm16
	dw	offset OSIInit16
	dw	   seg OSIInit16
	dw	offset OSILoad16
	dw	   seg OSILoad16


; The following symbol must be exported in the .def file.
public	FT_thkThkConnectionData
FT_thkThkConnectionData label dword
	dd	016bddh	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable



ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.nt\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
#include <globalnt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.nt\globalnt.cpp ===
#include "precomp.h"


//
// This file generates the storage for our NT specific global variables
//

#include <datainit.h>
#include <globalnt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.nt\im.cpp ===
#include "precomp.h"

//
// IM.CPP
// Input Manager, NT specific code
//

#define MLZ_FILE_ZONE  ZONE_INPUT

//
// OSI_InstallControlledHooks()
//
// Installs/removes input hooks for control
//
BOOL WINAPI OSI_InstallControlledHooks(BOOL fEnable, BOOL fDesktop)
{
    BOOL    rc = FALSE;

    DebugEntry(OSI_InstallControlledHooks);

    if (fEnable)
    {
        //
        // Create the service thread, it will install the hooks.
        //
        ASSERT(!g_imNTData.imLowLevelInputThread);

        if (!DCS_StartThread(IMLowLevelInputProcessor))
        {
            ERROR_OUT(( "Failed to create LL IM thread"));
            DC_QUIT;
        }
    }
    else
    {
        if (g_imNTData.imLowLevelInputThread != 0)
        {
            PostThreadMessage( g_imNTData.imLowLevelInputThread, WM_QUIT, 0, 0);
            g_imNTData.imLowLevelInputThread = 0;
        }
    }

    if (fDesktop)
    {
        rc = TRUE;
    }
    else
    {
        rc = OSI_InstallHighLevelMouseHook(fEnable);
    }

DC_EXIT_POINT:
    DebugExitBOOL(OSI_InstallControlledHooks, rc);
    return(rc);
}



// Name:      IMLowLevelInputProcessor
//
// Purpose:   Main function for the low-level input handler thread.
//
// Returns:   wParam of the WM_QUIT message.
//
// Params:    syncObject - sync object that allows this thread to signal
//            the creating thread via COM_SignalThreadStarted.
//
// Operation: This function is the start point for the low-level input
//            handler thread.
//
//            We raise the priority of this thread to:
//            (a) ensure that we avoid hitting the low-level callback
//            timeout - which would cause us to miss events.
//            (b) minimize visible mouse movement lag on the screen.
//
//            The thread installs the low-level hooks and enters a
//            GetMessage/DispatchMessage loop which handles the low-level
//            callbacks.
//
//            The Share Core sends the thread a WM_QUIT message to
//            terminate it, which causes it to exit the message loop and
//            removes the low-level hooks before it terminates.
//
DWORD WINAPI IMLowLevelInputProcessor(LPVOID hEventWait)
{
    MSG             msg;
    UINT            rc = 0;

    DebugEntry(IMLowLevelInputProcessor);

    TRACE_OUT(( "Thread started..."));

    //
    // Give ourseleves the highest possible priority (within our process
    // priority class) to ensure that the low-level events are serviced as
    // soon as possible.
    //
    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    g_imNTData.imLowLevelInputThread = GetCurrentThreadId();

    //
    // Install low-level input hooks.
    //
    g_imNTData.imhLowLevelMouseHook = SetWindowsHookEx(
                                     WH_MOUSE_LL,
                                     IMLowLevelMouseProc,
                                     g_asInstance,
                                     0 );

    g_imNTData.imhLowLevelKeyboardHook = SetWindowsHookEx(
                                     WH_KEYBOARD_LL,
                                     IMLowLevelKeyboardProc,
                                     g_asInstance,
                                     0 );

    //
    // We're done with our init code, for better or for worse.  Let the
    // calling thread continue.
    //
    SetEvent((HANDLE)hEventWait);

    if ( (g_imNTData.imhLowLevelMouseHook == NULL) ||
         (g_imNTData.imhLowLevelKeyboardHook == NULL) )
    {
        ERROR_OUT(( "SetWindowsHookEx failed: hMouse(%u) hKeyboard(%u)",
            g_imNTData.imhLowLevelMouseHook, g_imNTData.imhLowLevelKeyboardHook ));
        DC_QUIT;
    }

    //
    // Do our message loop to get events
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    //
    // Remove hooks
    //

    if (g_imNTData.imhLowLevelMouseHook != NULL)
    {
        UnhookWindowsHookEx(g_imNTData.imhLowLevelMouseHook);
        g_imNTData.imhLowLevelMouseHook = NULL;
    }

    if (g_imNTData.imhLowLevelKeyboardHook != NULL)
    {
        UnhookWindowsHookEx(g_imNTData.imhLowLevelKeyboardHook);
        g_imNTData.imhLowLevelKeyboardHook = NULL;
    }

DC_EXIT_POINT:
    DebugExitDWORD(IMLowLevelInputProcessor, rc);
    return(rc);
}


//
// Name:      IMOtherDesktopProc()
//
// This allows us to inject (but not block) input into other desktops
// besides default, where the user's desktop resides.  Specifically, the
// winlogon desktop and/or the screensaver desktop.
//
// This is trickier than it might seem, because the winlogon desktop is
// always around, but the screen saver one is transitory.
//
// The periodic SWL_ code, called when hosting, checks for the current
// desktop and if it's switched posts us a message so we can change our
// desktop and our hooks.
//
DWORD WINAPI IMOtherDesktopProc(LPVOID hEventWait)
{
    MSG             msg;
    UINT            rc = 0;
    HDESK           hDesktop;
    GUIEFFECTS      effects;

    DebugEntry(IMOtherDesktopProc);

    TRACE_OUT(("Other desktop thread started..."));

    g_imNTData.imOtherDesktopThread = GetCurrentThreadId();

    //
    // Start out attached to the WinLogon desktop because it's always
    // around.
    //

    // Set our desktop to the winlogon desktop
    hDesktop = OpenDesktop(NAME_DESKTOP_WINLOGON,
                        0,
                        FALSE,
                        DESKTOP_JOURNALPLAYBACK);

    if ( !hDesktop )
    {
        WARNING_OUT(("OpenDesktop failed: %ld", GetLastError()));
        DC_QUIT;
    }
    else if (!SetThreadDesktop (hDesktop))
    {
        WARNING_OUT(("SetThreadDesktop failed: %ld", GetLastError()));
        DC_QUIT;
    }

    //
    // Attempt to load the driver dynamically on this thread also.
    //
    if (g_asNT5)
    {
        OSI_InitDriver50(TRUE);
    }

    // Let the calling thread continue.
    SetEvent((HANDLE)hEventWait);

    ZeroMemory(&effects, sizeof(effects));

    while (GetMessage(&msg, NULL, 0, 0))
    {
        switch(msg.message)
        {
            case OSI_WM_MOUSEINJECT:
                mouse_event(
                                LOWORD(msg.wParam), // flags
                                HIWORD(msg.lParam), // x
                                LOWORD(msg.lParam), // y
                                HIWORD(msg.wParam), // mouseData
                                0);                 // dwExtraInfo
                break;

            case OSI_WM_KEYBDINJECT:
                keybd_event(
                                (BYTE)(LOWORD(msg.lParam)), // vkCode
                                (BYTE)(HIWORD(msg.lParam)), // scanCode
                                (DWORD)msg.wParam,          // flags
                                0);                         // dwExtraInfo
                break;

            case OSI_WM_DESKTOPREPAINT:
                USR_RepaintWindow(NULL);
                break;

            case OSI_WM_INJECTSAS:
            {
                HWND hwndSAS;

                if ( hwndSAS = FindWindow("SAS window class",NULL))
                {
                    PostMessage(hwndSAS,WM_HOTKEY,0,
                        MAKELONG(0x8000|MOD_ALT|MOD_CONTROL,VK_DELETE));
                }
                else
                {
                    WARNING_OUT(("SAS window not found, on screensaver desktop"));
                }
                break;
            }

            case OSI_WM_DESKTOPSWITCH:
            {
                HDESK   hDesktopNew;

                TRACE_OUT(("OSI_WM_DESKTOPSWITCH:  switching desktop from %d to %d",
                    msg.wParam, msg.lParam));

                if (msg.lParam == DESKTOP_SCREENSAVER)
                {
                    // We're switching TO the screensaver, attach to it.
                    TRACE_OUT(("Switching TO screensaver"));
                    hDesktopNew = OpenDesktop(NAME_DESKTOP_SCREENSAVER,
                        0, FALSE, DESKTOP_JOURNALPLAYBACK);
                }
                else if (msg.wParam == DESKTOP_SCREENSAVER)
                {
                    //
                    // We're switching FROM the screensaver, reattach to
                    // winlogon
                    //
                    TRACE_OUT(("Switching FROM screensaver"));
                    hDesktopNew = OpenDesktop(NAME_DESKTOP_WINLOGON,
                        0, FALSE, DESKTOP_JOURNALPLAYBACK);
                }
                else
                {
                    hDesktopNew = NULL;
                }

                if (hDesktopNew != NULL)
                {
                    if (!SetThreadDesktop(hDesktopNew))
                    {
                        WARNING_OUT(("SetThreadDesktop to 0x%08x, type %d failed",
                            hDesktopNew, msg.lParam));
                    }
                    else
                    {
                        CloseHandle(hDesktop);
                        hDesktop = hDesktopNew;
                    }
                }
                break;
            }

            case OSI_WM_SETGUIEFFECTS:
            {
                HET_SetGUIEffects((msg.wParam != 0), &effects);
                break;
            }
        }
    }

DC_EXIT_POINT:

    if (g_asNT5)
    {
        OSI_InitDriver50(FALSE);
    }

    if (hDesktop)
    {
        CloseHandle(hDesktop);
    }

    g_imNTData.imOtherDesktopThread = 0;

    DebugExitDWORD(IMOtherDesktopProc, rc);
    return(rc);
}


//
// IMLowLevelMouseProc()
// NT callback for low-level mouse events.
//
// It is installed and called on a secondary thread with high priority to
// service the APC call outs.  It follows the windows hook conventions for
// parameters and return values--zero to accept the event, non-zero to
// discard.
//
//
LRESULT CALLBACK IMLowLevelMouseProc
(
    int       nCode,
    WPARAM    wParam,
    LPARAM    lParam
)
{
    LRESULT             rc = 0;
    PMSLLHOOKSTRUCT     pMouseEvent;

    DebugEntry(IMLowLevelMouseProc);

    pMouseEvent = (PMSLLHOOKSTRUCT)lParam;

    //
    // If this isn't for an event that is happening or it's one we
    // injected ourself, pass it through and no need for processing.
    //
    if ((nCode != HC_ACTION) || (pMouseEvent->flags & LLMHF_INJECTED))
    {
        DC_QUIT;
    }

    //
    // This is a local user event.  If controlled, throw it away.  Unless
    // it's a click, in that case post a REVOKECONTROL message.
    //
    if (g_imSharedData.imControlled)
    {
        //
        // If this is a button click, take control back
        //
        if ((wParam == WM_LBUTTONDOWN) ||
            (wParam == WM_RBUTTONDOWN) ||
            (wParam == WM_MBUTTONDOWN))
        {
            //
            // Don't take control back if this is unattended.
            //
            if (!g_imSharedData.imUnattended)
            {
                PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, 0, 0);
            }
        }

        // Swallow event.
        rc = 1;
    }

DC_EXIT_POINT:
    //
    // Don't pass on to the next hook (if there is one) if we are
    // discarding the event.
    //
    if (!rc)
    {
        rc = CallNextHookEx(g_imNTData.imhLowLevelMouseHook, nCode,
            wParam, lParam);
    }

    DebugExitDWORD(IMLowLevelMouseProc, rc);
    return(rc);
}


// Name:      IMLowLevelKeyboardProc
//
// Purpose:   Windows callback function for low-level keyboard events.
//
// Returns:   0 if event is to be passed on to USER.
//            1 if event is to be discarded.
//
// Params:    Low-level callback params (see Windows documentation).
//
// Operation: Determines whether to allow the given event into USER.
//
//            We always pass on injected events.
//            The Control Arbitrator determines whether local events are
//            passed on.
//
LRESULT CALLBACK IMLowLevelKeyboardProc
(
    int       nCode,
    WPARAM    wParam,
    LPARAM    lParam
)
{
    LRESULT             rc = 0;
    PKBDLLHOOKSTRUCT    pKbdEvent;

    DebugEntry(IMLowLevelKeyboardProc);

    pKbdEvent = (PKBDLLHOOKSTRUCT)lParam;

    //
    // If this isn't for an action or it's an event we ourself originated,
    // let it through, and do no processing.
    //
    if ((nCode != HC_ACTION) || (pKbdEvent->flags & LLKHF_INJECTED))
    {
        DC_QUIT;
    }

    if (g_imSharedData.imControlled)
    {
        if (!(pKbdEvent->flags & LLKHF_UP))
        {
            //
            // This is a key down.  Take control back, and kill control
            // allowability if it's the ESC key.
            //
            if ((pKbdEvent->vkCode & 0x00FF) == VK_ESCAPE || g_imSharedData.imUnattended)
            {
                // ESC key always disallows control, even in unattended mode
                PostMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, FALSE, 0);
            }
            else if (!g_imSharedData.imUnattended)
            {
                PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, 0, 0);
            }
        }

        //
        // Don't discard toggle keys.  The enabled/disabled function
        // is already set before we see the keystroke.  If we discard,
        // the lights are incorrect.
        //
        // LAURABU:  How do we fix this in new model?  Post a toggle-key
        // message and undo it (fake press)?
        //
        if (!IM_KEY_IS_TOGGLE(pKbdEvent->vkCode & 0x00FF))
            rc = 1;
    }

DC_EXIT_POINT:
    //
    // Don't pass on to the next hook if we are swallowing the event.
    //
    if (!rc)
    {
        rc = CallNextHookEx(g_imNTData.imhLowLevelKeyboardHook,
            nCode, wParam, lParam);
    }

    DebugExitDWORD(IMLowLevelKeyboardProc, rc);
    return(rc);
}



//
// IMInjectMouseEvent()
// NT-specific version to inject mouse events into the local system
//
void WINAPI OSI_InjectMouseEvent
(
    DWORD   flags,
    LONG    x,
    LONG    y,
    DWORD   mouseData,
    DWORD   dwExtraInfo
)
{
    TRACE_OUT(("Before MOUSE inject:  %08lx, %08lx %08lx",
        flags, mouseData, dwExtraInfo));

    mouse_event(flags, (DWORD)x, (DWORD)y, mouseData, dwExtraInfo);

    if ( g_imNTData.imOtherDesktopThread )
    {
        // Stuff these dword parameters through WORDS
        // need to make sure we don't clip anything
        ASSERT(!(flags & 0xffff0000));
        //ASSERT(!(mouseData & 0xffff0000)); BUGBUG possible loss
        ASSERT(!(x & 0xffff0000));
        ASSERT(!(y & 0xffff0000));

        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_MOUSEINJECT,
            MAKEWPARAM((WORD)flags,(WORD)mouseData),
            MAKELPARAM((WORD)y, (WORD)x ));
    }

    TRACE_OUT(("After MOUSE inject"));
}


//
// OSI_InjectSAS()
// NT-specific version to inject ctrl+alt+del into the local system
//
void WINAPI OSI_InjectCtrlAltDel(void)
{
    if ( g_imNTData.imOtherDesktopThread )
    {
        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_INJECTSAS,
            0,
            0 );
    }
    else
    {
        WARNING_OUT(("Ignoring SAS Injection attempt"));
    }
}


//
// OSI_InjectKeyboardEvent()
// NT-specific version to inject keyboard events into the local system
//
void WINAPI OSI_InjectKeyboardEvent
(
    DWORD   flags,
    WORD    vkCode,
    WORD    scanCode,
    DWORD   dwExtraInfo
)
{
    TRACE_OUT(("Before KEY inject:  %04lx, {%04x, %04x}, %04lx",
        flags, vkCode, scanCode, dwExtraInfo));

    keybd_event((BYTE)vkCode, (BYTE)scanCode, flags, dwExtraInfo);

    if ( g_imNTData.imOtherDesktopThread )
    {
        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_KEYBDINJECT,
            (WPARAM)flags,
            MAKELPARAM(vkCode, scanCode));
    }

    TRACE_OUT(("After KEY inject"));
}


//
// OSI_DesktopSwitch()
// NT-specific, called when we think the current desktop has changed.
//
void WINAPI OSI_DesktopSwitch
(
    UINT    desktopFrom,
    UINT    desktopTo
)
{
    DebugEntry(OSI_DesktopSwitch);

    if (g_imNTData.imOtherDesktopThread)
    {
        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_DESKTOPSWITCH,
            desktopFrom,
            desktopTo);
    }

    DebugExitVOID(OSI_DesktopSwitch);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.nt\osi.cpp ===
#include "precomp.h"

#ifndef DM_POSITION
#define DM_POSITION         0x00000020L
#endif

//
// OSI.CPP
// OS Isolation layer, NT version
//
// Copyright(c) Microsoft 1997-
//

#include <version.h>
#include <ndcgver.h>
#include <osi.h>

#define MLZ_FILE_ZONE  ZONE_CORE


//
// NT 5.0 app sharing stuff.
// NOTE:
//      The name for NetMeeting's display driver, s_szNmDD, comes from
// mnmdd.sys.  We have no define for it nor access to the source.  DO NOT
// CHANGE THIS without talking to Andre Vachon.  Hopefully, he will perform
// the same courtesy for us if he changes mnmdd.sys.  If not, we can't share 
// anymore.  We won't even find our driver to load.
//
typedef BOOL (WINAPI * FN_ENUMDD)(LPVOID, DWORD, LPDISPLAY_DEVICE, DWORD);
static TCHAR s_szNmDD[] = "NetMeeting driver";


//
// OSI_Load()
// This handles our process attach.  We figure out if this is NT5 or not
//
void OSI_Load(void)
{
    OSVERSIONINFO       osVersion;

    ZeroMemory(&osVersion, sizeof(osVersion));
    osVersion.dwOSVersionInfoSize = sizeof(osVersion);
    GetVersionEx(&osVersion);
    ASSERT(osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT);

    if (osVersion.dwMajorVersion >= 5)
        g_asNT5 = TRUE;
}



//
// OSI_Unload()
// This handles our process detach.  We currently do nothing.
//
void OSI_Unload(void)
{
    return;
}



//
// OSI_InitDriver50()
//
// Attemps to dynamically load/unload our display driver for NT 5.0.  This is
// called on the main thread, and if under a service, on the winlogon
// thread also.  It will only succeed on the input focus desktop.
//
void  OSI_InitDriver50(BOOL fInit)
{
    DWORD               iEnum;
    DISPLAY_DEVICE      dd;
    DEVMODE             devmode;
    FN_ENUMDD           pfnEnumDD;

    DebugEntry(OSI_InitDriver50);

    ASSERT(g_asNT5);

    pfnEnumDD = (FN_ENUMDD)GetProcAddress(GetModuleHandle("USER32.DLL"),
        "EnumDisplayDevicesA");
    if (pfnEnumDD != NULL)
    {
        ZeroMemory(&dd, sizeof(dd));
        dd.cb = sizeof(dd);

        iEnum = 0;
        while (pfnEnumDD(NULL, iEnum++, &dd, 0))
        {
            if ((dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) &&
                !lstrcmpi((LPCSTR)dd.DeviceString, s_szNmDD))
            {
                LONG    lResult;

                //
                // There may be multiple monitors, drivers, etc.  
                // We have to actually tell the system what bit depth, 
                // format, etc. our driver wants just like if we were 
                // a real driver.  We therefore always ask to get 24bpp 
                // format info, no myriad 16bpp and 32bpp formats to deal
                // with anymore.
                //
                // Also, no more 4bpp not VGA nonsense either--just 8 or 24.
                //

                ZeroMemory(&devmode, sizeof(devmode));
                devmode.dmSize = sizeof(devmode);
                devmode.dmFields = DM_POSITION | DM_BITSPERPEL | DM_PELSWIDTH |
                    DM_PELSHEIGHT;

                if (fInit)
                {
                    //
                    // Fill in fields to get driver attached.
                    //
                    if (g_usrCaptureBPP <= 8)
                        g_usrCaptureBPP = 8;
                    else
                        g_usrCaptureBPP = 24;
                    devmode.dmBitsPerPel = g_usrCaptureBPP;

                    // devmode.dmPosition is (0, 0), this means "primary"
                    devmode.dmPelsWidth = GetSystemMetrics(SM_CXSCREEN);
                    devmode.dmPelsHeight = GetSystemMetrics(SM_CYSCREEN);
                }


				//
				// Before we change the display settings in a multimonitor machine, we better move the cursor out of the way
				// If we do not do do we get an extra cursor in the middle of the primary monitor
				//
				::SetCursorPos(-1, -1);


                //
                // This simply changes the state in the registry from
                // attached to unattached, without the system actually 
                // reflecting the change.  If/when we have multiple 
                // listings for our shadow driver, move the CDS(NULL, 0)
                // call outside the loop, and get rid of the break.
                //
                lResult = ChangeDisplaySettingsEx((LPCSTR)dd.DeviceName, &devmode,
                        NULL, CDS_UPDATEREGISTRY | CDS_NORESET, NULL);
                if (lResult != DISP_CHANGE_SUCCESSFUL)
                {
                    WARNING_OUT(("ChangeDisplaySettingsEx failed, error %d", lResult));
                }
                else
                {
	
                    //
                    // This causes Windows to actually go reread the registry and 
                    // update the current display to reflect the attached items, 
                    // positions, sizes, and color depths.
                    //
                    ChangeDisplaySettings(NULL, 0);

#ifdef _DEBUG
                    if (fInit)
                    {
                        HDC hdc;
                            
                        //
                        // Create a temp DC based on this driver and make sure
                        // the settings matched what we asked for.
                        //
                        hdc = CreateDC(NULL, (LPCSTR)dd.DeviceName, NULL, NULL);

                        if (!hdc)
                        {
                            WARNING_OUT(("OSI_Init:  dynamic display driver load failed"));
                        }
                        else
                        {
                            ASSERT(GetDeviceCaps(hdc, HORZRES) == (int)devmode.dmPelsWidth);
                            ASSERT(GetDeviceCaps(hdc, VERTRES) == (int)devmode.dmPelsHeight);
                            ASSERT(GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES) ==
                                (int)g_usrCaptureBPP);

                            DeleteDC(hdc);
                        }
                    }
#endif // _DEBUG

                    //
                    // Tell MNMHOOK_ the name of our driver so it can talk
                    // to it via ExtEscape.
                    //
                    OSI_SetDriverName(fInit ? (LPCSTR)dd.DeviceName : NULL);
                }

                break;
            }
        }
    }

    DebugExitVOID(OSI_InitDriver50);
}


//
// OSI_Init - see osi.h
//
void  OSI_Init(void)
{
    UINT                i;
    OSI_INIT_REQUEST    requestBuffer;

    DebugEntry(OSI_Init);

    //
    // First, setup up pointer to shared data.  This data lives here in NT.
    //
#ifdef DEBUG
    g_imSharedData.cbSize = sizeof(g_imSharedData);
#endif

    g_lpimSharedData = &g_imSharedData;

    requestBuffer.result = FALSE;
    requestBuffer.pSharedMemory = NULL;
    requestBuffer.poaData[0] = NULL;
    requestBuffer.poaData[1] = NULL;
    requestBuffer.sbcEnabled = FALSE;

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        ASSERT(!g_asbcShuntBuffers[i]);
        requestBuffer.psbcTileData[i] = NULL;
    }

    //
    // Do this FIRST.  On NT5, only threads on the desktop with input
    // can succeed at calling ChangeDisplaySettings.  So like other things,
    // we must try to dynamically load/unload our driver on both desks.
    //

    //
    // Create the winlogon desktop event injection helper thread
    // only if we're started as a service.  Note that it will try to
    // load display at start too.
    //
    ASSERT(!g_imNTData.imOtherDesktopThread);

    if (g_asOptions & AS_SERVICE)
    {
        WARNING_OUT(("Starting other desktop thread for SERVICE"));
        if (!DCS_StartThread(IMOtherDesktopProc))
        {
            WARNING_OUT(( "Failed to create other desktop IM thread"));
            DC_QUIT;
        }
    }


    //
    // DO THIS ONLY FOR NT5
    // We are going to enumerate all the entries for our shadow driver
    // (currently only one) and attach each to the actual display.
    //
    if (g_asNT5)
    {
        OSI_InitDriver50(TRUE);
    }

DC_EXIT_POINT:
    g_osiInitialized = OSI_FunctionRequest(OSI_ESC_INIT, (LPOSI_ESCAPE_HEADER)&requestBuffer,
            sizeof(requestBuffer));

    if (!g_osiInitialized)
    {
        WARNING_OUT(("OSI_ESC_INIT: display driver not present"));
    }
    else
    {
        if (requestBuffer.result)
        {
            g_asCanHost = TRUE;

            //
            // Got shared memory pointers; keep them around
            //
            g_asSharedMemory   = (LPSHM_SHARED_MEMORY)requestBuffer.pSharedMemory;
            ASSERT(g_asSharedMemory);

            g_poaData[0]        = (LPOA_SHARED_DATA)requestBuffer.poaData[0];
            ASSERT(g_poaData[0]);

            g_poaData[1]        = (LPOA_SHARED_DATA)requestBuffer.poaData[1];
            ASSERT(g_poaData[1]);

            g_sbcEnabled        = requestBuffer.sbcEnabled;
            if (g_sbcEnabled)
            {
                //
                // Get shunt buffers
                //
                for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
                {
                    g_asbcShuntBuffers[i] = (LPSBC_SHUNT_BUFFER)requestBuffer.psbcTileData[i];
                    ASSERT(g_asbcShuntBuffers[i]);

                    TRACE_OUT(("OSI_Init: sbc shunt buffer %d:  entries %08d, bytes 0x%08x",
                        i, g_asbcShuntBuffers[i]->numEntries, g_asbcShuntBuffers[i]->numBytes));
                }

                for (i = 0; i < 3; i++)
                {
                    g_asbcBitMasks[i] = requestBuffer.aBitmasks[i];
                }
            }
        }
    }

    if (g_asCanHost)
    {
        //
        // Tell HOOK dll (used for control as well as sharing) about our hwnd
        // and stuff.  If we are able to host.
        //
        ASSERT(g_asMainWindow);
        ASSERT(g_asHostProp);

        HOOK_Init(g_asMainWindow, g_asHostProp);
    }

    DebugExitVOID(OSI_Init);
}


//
// OSI_Term - see osi.h
//
void  OSI_Term(void)
{
    UINT    i;

    DebugEntry(OSI_Term);

    //
    // This can be called on multiple threads:
    //      * The main DCS thread
    //      * The last thread of the process causing us to get a process
    //              detach.
    // We call it in the latter case also to make sure we cleanup properly.
    //
    ASSERT(GetCurrentThreadId() == g_asMainThreadId);

    //
    // Kill the other desktop thread if it's around.
    //
    if (g_imNTData.imOtherDesktopThread != 0)
    {
        ASSERT(g_asOptions & AS_SERVICE);
        PostThreadMessage(g_imNTData.imOtherDesktopThread, WM_QUIT, 0, 0);
        while (g_imNTData.imOtherDesktopThread)
        {
            WARNING_OUT(("OSI_Term: waiting for other desktop thread to exit"));
            Sleep(1);
        }
    }


    if (g_osiInitialized)
    {
        OSI_TERM_REQUEST    requestBuffer;

        g_osiInitialized = FALSE;

        //
        // We call the term routine only if the driver is actually loaded
        // (as opposed to whether something went wrong when trying to setup
        // for hosting) so that we will cleanup if something went wrong in
        // the middle.
        //
        OSI_FunctionRequest(OSI_ESC_TERM, (LPOSI_ESCAPE_HEADER)&requestBuffer,
            sizeof(requestBuffer));
    }

    //
    // ONLY DO THIS FOR NT5
    // We need to undo all the work we did at init time to attach our 
    // driver(s) to the display, and detach them.  Again, enumerate the
    // registry entries and look for ours.
    //
    //

    if (g_asNT5)
    {
        OSI_InitDriver50(FALSE);
    }

    // Clear our shared memory variables
    for (i = 0; i < 3; i++)
    {
        g_asbcBitMasks[i] = 0;
    }

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        g_asbcShuntBuffers[i] = NULL;
    }
    g_sbcEnabled = FALSE;

    g_asSharedMemory = NULL;
    g_poaData[0] = NULL;
    g_poaData[1] = NULL;

    g_asCanHost = FALSE;

    g_lpimSharedData = NULL;

    DebugExitVOID(OSI_Term);
}




VOID OSI_RepaintDesktop(void)
{
    DebugEntry(OSI_RepaintDesktop);

    // If this does not appear to be a window it may be a window on the
    // winlogon desktop, so we need to get the proxy thread to repaint it
    if ( g_imNTData.imOtherDesktopThread )
    {
        PostThreadMessage(g_imNTData.imOtherDesktopThread,
                        OSI_WM_DESKTOPREPAINT, 0, 0);
    }
    DebugExitVOID(OSI_RepaintDesktop);
}


VOID OSI_SetGUIEffects(BOOL fOff)
{
    DebugEntry(OSI_SetGUIEffects);

    if (g_imNTData.imOtherDesktopThread)
    {
        PostThreadMessage(g_imNTData.imOtherDesktopThread,
                        OSI_WM_SETGUIEFFECTS, fOff, 0);
    }

    DebugExitVOID(OSI_SetGUIEffects);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\ba.c ===
#include "precomp.h"


//
// BA.C
// Bounds Accumulation, disply driver side
//
// Copyright(c) Microsoft 1997-
//


//
//
// BA_DDProcessRequest() - see ba.h
//
//
BOOL BA_DDProcessRequest
(
    DWORD                   fnEscape,
    LPOSI_ESCAPE_HEADER     pRequest,
    DWORD                   cbRequest,
    LPOSI_ESCAPE_HEADER     pResult,
    DWORD                   cbResult
)
{
    BOOL                    rc = TRUE;
    LPBA_BOUNDS_INFO        pBoundsInfo;
    UINT                    i;
    RECT                    rect;

    DebugEntry(BA_DDProcessRequest);

    if ((cbRequest != sizeof(BA_BOUNDS_INFO)) ||
        (cbResult  != sizeof(BA_BOUNDS_INFO)))
    {
        ERROR_OUT(("BA_DDProcessRequest:  Invalid sizes %d, %d for BA_ESC", cbRequest, cbResult));
        rc = FALSE;
        DC_QUIT;
    }

    switch (fnEscape)
    {
        case BA_ESC_GET_BOUNDS:
        {
            //
            // The share core is calling us to get the current bounds
            // (presumably to try to send them).  While the share core is
            // processing the bounds, we reset the bounds, but take a copy
            // first to use for spoiling orders by SDA.  When the share
            // core has completed processing the bounds, it will call us
            // again with a BA_ESC_RETURN_BOUNDS escape (even if it has
            // sent all the bounds).
            //
            // So, we have to:
            //  - return the bounds to the share core
            //  - set up the spoiling rects to be these bounds
            //  - clear our main bounds.
            //

            //
            // This will copy the current bounds to the caller's buffer and
            // clear our current bounds.
            // NOTE:  We keep these in globals because the caller will shortly
            // call us to return any unsent bounds rects.
            //
            BA_CopyBounds(g_baSpoilingRects, &g_baNumSpoilingRects, TRUE);

            //
            // Return the bounds info to the share core
            //
            TRACE_OUT(( "Returning %d rects to share core", g_baNumSpoilingRects));

            pBoundsInfo = (LPBA_BOUNDS_INFO)pResult;
            pBoundsInfo->numRects = g_baNumSpoilingRects;

            for (i = 0; i < g_baNumSpoilingRects; i++)
            {
                RECT_TO_RECTL(&g_baSpoilingRects[i], &pBoundsInfo->rects[i]);
            }
        }
        break;

        case BA_ESC_RETURN_BOUNDS:
        {
            //
            // The share core has completed its processing of the bounds
            // which we passed on the BA_ESC_GET_BOUNDS escape.  We have to
            // reset the spoiling rectangles and add any bounds which the
            // share core failed to process into our current bounds.
            //

            //
            // To reset the spoiling bounds we just have to reset the
            // number of bounds.
            //
            g_baNumSpoilingRects = 0;

            //
            // Now add the share core's bounds into our current bounds
            //
            pBoundsInfo = (LPBA_BOUNDS_INFO)pRequest;
            TRACE_OUT(( "Received %d rects from share core",
                         pBoundsInfo->numRects));

            for (i = 0 ; i < pBoundsInfo->numRects ; i++)
            {
                RECTL_TO_RECT(&pBoundsInfo->rects[i], &rect);

                TRACE_OUT(( "Rect %d, {%d, %d, %d, %d}",
                     i, rect.left, rect.top, rect.right, rect.bottom));

                BA_AddScreenData(&rect);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unrecognised BA escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(BA_DDProcessRequest, rc);
    return(rc);
}



//
// BA_DDInit - see ba.h for description.
//
void BA_DDInit(void)
{
    DebugEntry(BA_DDInit);

    BA_ResetBounds();

    DebugExitVOID(BA_DDInit);
}




//
// This gets a current version of our bound rect list, and clears it 
// afterwards if requested.
//
void BA_CopyBounds
(
    LPRECT  pRects,
    LPUINT  pNumRects,
    BOOL    fReset
)
{
    UINT    i;
#ifdef DEBUG
    UINT    cRects = 0;
#endif

    DebugEntry(BA_CopyBounds);

    if (*pNumRects = g_baRectsUsed)
    {
        //
        // Return the bounds that have been accumulated.
        //
        TRACE_OUT(( "num rects : %d", g_baRectsUsed));

        //
        // We can return the bounds in any order - we don't care how we
        // order the SDA rectangles.
        //
        // Also note that we must compare BA_NUM_RECTS + 1 sets of
        // rectangles because that's the number actually used by the add
        // rectangle code and while it guarantees that it will only use
        // BA_NUM_RECTS rectangles, it does not guarantee that the last
        // element in the array is the merge rectangle.
        //
        for (i = 0; i <= BA_NUM_RECTS; i++)
        {
            if (g_baBounds[i].InUse)
            {
                TRACE_OUT(("Found rect: {%04d,%04d,%04d,%04d}",
                    g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                    g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));

                *pRects = g_baBounds[i].Coord;
                pRects++;
#ifdef DEBUG
                cRects++;
#endif
            }
        }

        //
        // Check for self-consistency
        //
        ASSERT(cRects == *pNumRects);

        if (fReset)
            BA_ResetBounds();
    }

    DebugExitVOID(BACopyBounds);
}



//
//
// BA_AddScreenData(..)
//
// Adds the specified rectangle to the current Screen Data Area.
//
// Called by the GDI interception code for orders that it cannot send as
// orders.
//
// NOTE that the rectangle is INCLUSIVE coords
//
//
void BA_AddScreenData(LPRECT pRect)
{
    RECT  preRects[BA_NUM_RECTS];
    RECT  postRects[BA_NUM_RECTS];
    UINT  numPreRects;
    UINT  numPostRects;
    UINT  i;

    DebugEntry(BA_AddScreenData);

    //
    // Check that the caller has passed a valid rectangle.  If not, do a
    // trace alert, and then return immediately (as an invalid rectangle
    // shouldn't contribute to the accumulated bounds) - but report an OK
    // return code, so we keep running.
    //
    if ((pRect->right < pRect->left) ||
        (pRect->bottom < pRect->top) )
    {
        WARNING_OUT(( "Invalid Add Rect (%d,%d,%d,%d)",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom ));
        DC_QUIT;
    }

    if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
    {
        //
        // We are spoiling existing orders by new SDA, so query the current
        // bounds.
        //
        BA_CopyBounds(preRects, &numPreRects, FALSE);
    }


    //
    // Add the rect to the bounds.
    //
    if (BAAddRect(pRect, 0))
    {
        if ((pRect->right > pRect->left) && (pRect->bottom > pRect->top))
        {
            LPBA_FAST_DATA  lpbaFast;

            lpbaFast = BA_FST_START_WRITING;

            SHM_CheckPointer(lpbaFast);
            lpbaFast->totalSDA += COM_SizeOfRectInclusive(pRect);

            TRACE_OUT(("Added rect to bounds, giving %ld of SD", lpbaFast->totalSDA));

            //
            // This is where the Win95 product would make a call to
            // DCS_TriggerEarlyTimer
            //

            BA_FST_STOP_WRITING;
        }

        if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
        {
            //
            // Adding the new rectangle changed the existing bounds so
            // query the new bounds
            //
            BA_CopyBounds(postRects, &numPostRects, FALSE);

            //
            // Try to spoil existing orders using each of the rectangles
            // which have changed.
            //
            for (i = 0; i < numPostRects; i++)
            {
                if ( (i > numPreRects)                          ||
                     (postRects[i].left   != preRects[i].left)  ||
                     (postRects[i].right  != preRects[i].right) ||
                     (postRects[i].top    != preRects[i].top)   ||
                     (postRects[i].bottom != preRects[i].bottom) )
                {
                    OA_DDSpoilOrdersByRect(&postRects[i]);
                }
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(BA_AddScreenData);
}



//
//
// BA_QuerySpoilingBounds() - see ba.h
//
//
void BA_QuerySpoilingBounds(LPRECT pRects, LPUINT pNumRects)
{
    DebugEntry(BA_QuerySpoilingBounds);

    //
    // Just have to return the number of spoiling rectangles, and the
    // rectangles themselves.  No rectangles is perfectly valid.
    //
    TRACE_OUT(( "Num rects %d", g_baNumSpoilingRects));

    *pNumRects = g_baNumSpoilingRects;
    memcpy(pRects, g_baSpoilingRects, g_baNumSpoilingRects*sizeof(RECT));

    DebugExitVOID(BA_QuerySpoilingBounds);
}



void BA_ResetBounds(void)
{
    UINT i;

    DebugEntry(BA_ResetBounds);

    //
    // Clear the bounds - reset the number we are using, mark all slots as
    // free, and clean the list.
    //
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        g_baBounds[i].InUse = FALSE;
        g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;
    }

    g_baFirstRect = BA_INVALID_RECT_INDEX;
    g_baLastRect  = BA_INVALID_RECT_INDEX;
    g_baRectsUsed = 0;

    DebugExitVOID(BA_ResetBounds);
}





//
// Name:        BAOverlap
//
// Description: Detects overlap between two rectangles.
//
//              - check for no overlap using loose test that lets through
//                adjacent/overlapping merges
//              - check for adjacent/overlapping merges
//              - check for no overlap (using strict test)
//              - use outcodes to check internal edge cases
//              - use outcodes to check external edge cases
//
//              If at each stage the check detects that the two rectangles
//              meet the criteria, the function returns the appropriate
//              return or outcode combination.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
//              This function does not alter either of the rectangles.
//
// Params (IN): pRect1 - first rectangle
//              pRect2 - second rectangle
//
// Returns:     One of the overlap return codes or outcode combinations
//              defined above.
//
//
int BAOverlap(LPRECT pRect1, LPRECT pRect2 )
{
    int ExternalEdges;
    int ExternalCount;
    int InternalEdges;
    int InternalCount;

    //
    // Check for no overlap.
    //
    // Note that this test is looser than strict no overlap, and will let
    // through rectangles that do not overlap, but just abutt by one pel -
    // so that we get a chance to detect adjacent merges.
    //
    // So (for example) for the following:
    //
    // - it detects no overlap when there is at least 1 pel between rects
    //
    //                  10,10        52,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt and are mergable
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt, even where they are
    //   not mergable
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - it allows rectangles through when they overlap in some way
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    //
    if (!((pRect1->left <= pRect2->right + 1) &&
          (pRect1->top <= pRect2->bottom + 1) &&
          (pRect1->right >= pRect2->left - 1) &&
          (pRect1->bottom >= pRect2->top - 1)   ))
    {
        return(OL_NONE);
    }

    //
    // Check for adjoining/overlapping rectangles which can be merged.
    //
    // These tests detect (for example for the XMAX variant), where:
    //
    // - the rectangles abutt and can be merged
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - the rectangles overlap and can be merged
    //
    //                  10,10   40,10
    //                   +-------+--+------+
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |Rect 1 |  |Rect 2|
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   +-------+--+------+
    //                              50,50  90,50
    //
    // - the rectangles abutt and cannot be merged - this case is detected
    //   by the strict overlap case below
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - the rectangles overlap and cannot be merged - this case is
    //   detected by the outcode tests below
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    // - rectangle 2 is enclosed in rectangle 1 and should not be merged -
    //   this case is detected by the outcode tests below.
    //
    //                  10,10   40,10
    //                   +-------+------+-----+
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |Rect 1 |Rect 2|     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   +-------+------+-----+
    //                               60,50   90,50
    //                               Rect2   Rect1
    //
    //
    if ( (pRect1->left <= pRect2->right + 1) &&
         (pRect1->left >  pRect2->left    ) &&
         (pRect1->right >  pRect2->right    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMIN);
    }

    if ( (pRect1->top <= pRect2->bottom + 1) &&
         (pRect1->top >  pRect2->top    ) &&
         (pRect1->bottom >  pRect2->bottom    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMIN);
    }

    if ( (pRect1->right >= pRect2->left - 1) &&
         (pRect1->right <  pRect2->right    ) &&
         (pRect1->left <  pRect2->left    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMAX);
    }

    if ( (pRect1->bottom >= pRect2->top - 1) &&
         (pRect1->bottom <  pRect2->bottom    ) &&
         (pRect1->top <  pRect2->top    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMAX);
    }

    //
    // Check for no overlap.
    // Note that this test is a stricter version than the earlier one, so
    // that we now only continue testing rectangles that do genuinely
    // overlap.
    //
    if (!((pRect1->left <= pRect2->right) &&
          (pRect1->top <= pRect2->bottom) &&
          (pRect1->right >= pRect2->left) &&
          (pRect1->bottom >= pRect2->top)   ))
    {
        return(OL_NONE);
    }

    //
    // Use outcodes for Internal edge cases, as follows:
    //
    // EE_XMIN - rect1 xmin is enclosed within rect2
    // EE_YMIN - rect1 ymin is enclosed within rect2
    // EE_XMAX - rect1 xmax is enclosed within rect2
    // EE_YMAX - rect1 ymax is enclosed within rect2
    //
    // If 3 or more bits are set then rect1 is enclosed either partially or
    // completely within rect2 as follows (see individual switch cases for
    // diagrams).
    //
    // OL_ENCLOSED           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_XMIN = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSED_YMIN = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_PART_ENCLOSED_XMAX =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_YMAX = EE_XMIN |           EE_XMAX | EE_YMAX
    //
    // In practice, if 3 or more bits are set, the negative of the outcode
    // value is retruned to ensure that it is distinct from the external
    // edge outcode returns (see below).
    //
    //
    InternalCount = 0;
    InternalEdges = 0;
    if ( pRect1->left >= pRect2->left && pRect1->left <= pRect2->right)
    {
        InternalEdges |= EE_XMIN;
        InternalCount ++;
    }
    if ( pRect1->top >= pRect2->top && pRect1->top <= pRect2->bottom)
    {
        InternalEdges |= EE_YMIN;
        InternalCount ++;
    }
    if ( pRect1->right >= pRect2->left && pRect1->right <= pRect2->right)
    {
        InternalEdges |= EE_XMAX;
        InternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->top && pRect1->bottom <= pRect2->bottom)
    {
        InternalEdges |= EE_YMAX;
        InternalCount ++;
    }

    if ( InternalCount >= 3)
    {
        return(-InternalEdges);
    }

    //
    // Use outcodes for External edge cases as follows.
    //
    // EE_XMIN - rect1 xmin is left of rect2 xmin
    // EE_YMIN - rect1 ymin is above rect2 ymin
    // EE_XMAX - rect1 xmax is right of rect2 xmax
    // EE_YMAX - rect1 ymax is below rect2 ymax
    //
    // These are the classic "line" outcodes.
    //
    // If 2 or more bits are set then rect1 overlaps rect2 as follows (see
    // individual switch cases for diagrams).
    //
    // OL_ENCLOSES           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMIN =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMAX = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSES_YMIN = EE_XMIN |           EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_YMAX = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_SPLIT_X            =           EE_YMIN |           EE_YMAX
    // OL_SPLIT_Y            = EE_XMIN |           EE_XMAX
    // OL_SPLIT_XMIN_YMIN    =                     EE_XMAX | EE_YMAX
    // OL_SPLIT_XMAX_YMIN    = EE_XMIN |                     EE_YMAX
    // OL_SPLIT_XMIN_YMAX    =           EE_YMIN | EE_XMAX
    // OL_SPLIT_XMAX_YMAX    = EE_XMIN | EE_YMIN
    //
    // The accumulated outcode value is returned.
    //
    //
    ExternalEdges = 0;
    ExternalCount = 0;
    if ( pRect1->left <= pRect2->left )
    {
        ExternalEdges |= EE_XMIN;
        ExternalCount ++;
    }
    if ( pRect1->top <= pRect2->top )
    {
        ExternalEdges |= EE_YMIN;
        ExternalCount ++;
    }
    if ( pRect1->right >= pRect2->right )
    {
        ExternalEdges |= EE_XMAX;
        ExternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->bottom )
    {
        ExternalEdges |= EE_YMAX;
        ExternalCount ++;
    }
    if (ExternalCount >= 2)
    {
        return(ExternalEdges);
    }

    //
    // If get here then we failed to detect a valid case.
    //
    WARNING_OUT(( "Unrecognised Overlap: (%d,%d,%d,%d),(%d,%d,%d,%d)",
            pRect1->left, pRect1->top, pRect1->right, pRect1->bottom,
            pRect2->left, pRect2->top, pRect2->right, pRect2->bottom ));
    return(OL_NONE);
}



//
// Name:        BAAddRectList
//
// Description: Adds a rectangle to the list of accumulated rectangles.
//
//              - find a free slot in the array
//              - add slot record to list
//              - fill slot record with rect and mark as in use.
//
// Params (IN): pRect - rectangle to add
//
// Returns:
//
//
void BAAddRectList(LPRECT pRect)
{
    UINT     i;
    BOOL     fFoundFreeSlot;

    DebugEntry(BAAddRectList);

    //
    // Find a free slot in the array.  Note that the loop searches to
    // BA_NUM_RECTS+1, because:
    //
    // - the array is defined as having one more slot than BA_NUM_RECTS
    //
    // - we may need to add a rect in that slot when BA_NUM_RECTS are
    //   in use prior to a forced merge.
    //
    fFoundFreeSlot = FALSE;
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        if (!g_baBounds[i].InUse)
        {
            fFoundFreeSlot = TRUE;
            break;
        }
    }

    if (!fFoundFreeSlot)
    {
        WARNING_OUT(( "No space in array for rect (%d,%d,%d,%d)",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom));

        for ( i = 0; i <= BA_NUM_RECTS; i++ )
        {
            WARNING_OUT((
                     "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                       g_baBounds[i].iNext,
                       g_baBounds[i].Coord.left,
                       g_baBounds[i].Coord.top,
                       g_baBounds[i].Coord.right,
                       g_baBounds[i].Coord.bottom,
                       i,
                       g_baBounds[i].InUse));
        }

        DC_QUIT;
    }

    //
    // If first rect, then set up list.
    // If not, add to tail of list.
    //
    if (g_baRectsUsed == 0)
    {
        g_baFirstRect = i;
        g_baLastRect = i;
    }
    else
    {
        g_baBounds[g_baLastRect].iNext = i;
        g_baLastRect = i;
    }
    g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;

    //
    // Fill in slot and mark as in use.
    //
    g_baBounds[i].InUse = TRUE;
    g_baBounds[i].Coord = *pRect;

    //
    // Increment number of rectangles.
    //
    TRACE_OUT(( "Add Rect  : ix - %d, (%d,%d,%d,%d)", i,
                    pRect->left,pRect->top,pRect->right,pRect->bottom));
    g_baRectsUsed++;

DC_EXIT_POINT:
    DebugExitVOID(BAAddRectList);
}


//
// Name:        BA_RemoveRectList
//
// Description: Removes a rectangle from the list of accumulated
//              rectangles.
//
//              - find the rectangle in the list
//              - unlink it from the list and mark the slot as free
//
// Params (IN): pRect - rectangle to remove
//
// Returns:
//
//
void BA_RemoveRectList(LPRECT pRect)
{
    UINT      i;
    UINT      j;

    DebugEntry(BA_RemoveRectList);

    //
    // If rectangle to remove is first...
    // Remove it by adjusting first pointer and mark as free.
    // Note that the check for tail adjustment has to be done before we
    // change first.
    //
    if ( g_baBounds[g_baFirstRect].Coord.left == pRect->left &&
         g_baBounds[g_baFirstRect].Coord.top == pRect->top &&
         g_baBounds[g_baFirstRect].Coord.right == pRect->right &&
         g_baBounds[g_baFirstRect].Coord.bottom == pRect->bottom   )
    {
        TRACE_OUT(( "Remove first"));
        if (g_baFirstRect == g_baLastRect)
        {
            g_baLastRect = BA_INVALID_RECT_INDEX;
        }
        g_baBounds[g_baFirstRect].InUse = FALSE;
        g_baFirstRect = g_baBounds[g_baFirstRect].iNext;
    }

    //
    // If rectangle to remove is not first...
    // Find it in list, remove it by adjusting previous pointer and mark it
    // as free.
    // Note that the check for tail adjustment has to be done before we
    // change the previous pointer.
    //
    else
    {
        TRACE_OUT(( "Remove not first"));
        for ( j = g_baFirstRect;
              g_baBounds[j].iNext != BA_INVALID_RECT_INDEX;
              j = g_baBounds[j].iNext )
        {
            if ( (g_baBounds[g_baBounds[j].iNext].Coord.left == pRect->left) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.top == pRect->top) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.right == pRect->right) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.bottom == pRect->bottom) )
            {
                break;
            }
        }

        if (j == BA_INVALID_RECT_INDEX)
        {
            WARNING_OUT(( "Couldn't remove rect (%d,%d,%d,%d)",
                       pRect->left,
                       pRect->top,
                       pRect->right,
                       pRect->bottom ));

            for ( i = 0; i <= BA_NUM_RECTS; i++ )
            {
                WARNING_OUT((
                       "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                           g_baBounds[i].iNext,
                           g_baBounds[i].Coord.left,
                           g_baBounds[i].Coord.top,
                           g_baBounds[i].Coord.right,
                           g_baBounds[i].Coord.bottom,
                           i,
                           g_baBounds[i].InUse));
            }
            return;
        }

        if (g_baBounds[j].iNext == g_baLastRect )
        {
             g_baLastRect = j;
        }
        g_baBounds[g_baBounds[j].iNext].InUse = FALSE;
        g_baBounds[j].iNext = g_baBounds[g_baBounds[j].iNext].iNext;
    }

    //
    // One less rect...
    //
    g_baRectsUsed--;
    DebugExitVOID(BA_RemoveRectList);
}


//
// Name:        BAAddRect
//
// Description: Accumulates rectangles.
//
//              This is a complex routine, with the essential algorithm
//              as follows.
//
//              - Start with the supplied rectangle as the candidate
//                rectangle.
//
//              - Compare the candidate against each of the existing
//                accumulated rectangles.
//
//              - If some form of overlap is detected between the
//                candidate and an existing rectangle, this may result in
//                one of the following (see the cases of the switch for
//                details):
//
//                - adjust the candidate or the existing rectangle or both
//                - merge the candidate into the existing rectangle
//                - discard the candidate as it is enclosed by an existing
//                  rectangle.
//
//              - If the merge or adjustment results in a changed
//                candidate, restart the comparisons from the beginning of
//                the list with the changed candidate.
//
//              - If the adjustment results in a split (giving two
//                candidate rectangles), invoke this routine recursively
//                with one of the two candidates as its candidate.
//
//              - If no overlap is detected against the existing rectangles,
//                add the candidate to the list of accumulated rectangles.
//
//              - If the add results in more than BA_NUM_RECTS
//                accumulated rectangles, do a forced merge of two of the
//                accumulate rectangles (which include the newly added
//                candidate) - choosing the two rectangles where the merged
//                rectangle results in the smallest increase in area over
//                the two non-merged rectangles.
//
//              - After a forced merge, restart the comparisons from the
//                beginning of the list with the newly merged rectangle as
//                the candidate.
//
//              For a particular call, this process will continue until
//              the candidate (whether the supplied rectangle, an adjusted
//              version of that rectangle, or a merged rectangle):
//
//              - does not find an overlap among the rectangles in the list
//                and does not cause a forced merge
//              - is discarded becuase it is enclosed within one of the
//                rectangles in the list.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
// Params (IN): pCand - new candidate rectangle
//              level - recursion level
//
// Returns:  TRUE if rectandle was spoilt due to a complete overlap.
//
//
BOOL BAAddRect
(
    LPRECT  pCand,
    int     level
)
{
    int     bestMergeIncrease;
    int     mergeIncrease;
    UINT    iBestMerge1;
    UINT    iBestMerge2;
    UINT    iExist;
    UINT    iTmp;
    BOOL    fRectToAdd;
    BOOL    fRectMerged;
    BOOL    fResetRects;
    RECT    rectNew;
    UINT    iLastMerge;
    int     OverlapType;
    BOOL    rc = TRUE;

    DebugEntry(BAAddRect);

    //
    // Increase the level count in case we recurse.
    //
    level++;

    //
    // Start off by assuming the candidate rectangle will be added to the
    // accumulated list of rectangles, and that no merges will occur.
    //
    fRectToAdd  = TRUE;
    fRectMerged = FALSE;

    //
    // Loop until no merges occur.
    //
    do
    {
        TRACE_OUT(( "Candidate rect: (%d,%d,%d,%d)",
                    pCand->left,pCand->top,pCand->right,pCand->bottom));

        //
        // Compare the current candidate rectangle against the rectangles
        // in the current accumulated list.
        //
        iExist = g_baFirstRect;

        while (iExist != BA_INVALID_RECT_INDEX)
        {
            //
            // Assume that the comparisons will run through the whole list.
            //
            fResetRects = FALSE;

            //
            // If the candidate and the existing rectangle are the same
            // then ignore.  This occurs when an existing rectangle is
            // replaced by a candidate and the comparisons are restarted
            // from the front of the list - whereupon at some point the
            // candidate will be compared with itself.
            //
            if ( &g_baBounds[iExist].Coord == pCand )
            {
                TRACE_OUT(( "OL_SAME - %d", iExist));
                iExist = g_baBounds[iExist].iNext;
                continue;
            }

            //
            // Switch on the overlap type (see Overlap routine).
            //
            OverlapType = BAOverlap(&(g_baBounds[iExist].Coord), pCand);
            switch (OverlapType)
            {

                case OL_NONE:
                    //
                    // No overlap.
                    //
                    TRACE_OUT(( "OL_NONE - %d", iExist));
                    break;

                case OL_MERGE_XMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the left
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Cand    ||  Exist   |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the left
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Cand  |  |Exist |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_XMIN - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.left = pCand->left;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->right = g_baBounds[iExist].Coord.right;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;


                case OL_MERGE_XMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the right
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Exist   ||  Cand    |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the right
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Exist |  | Cand |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_XMAX - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.right = pCand->right;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->left = g_baBounds[iExist].Coord.left;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the top
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing on the top
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //      Exist 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Cand
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_YMIN - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.top = pCand->top;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->bottom = g_baBounds[iExist].Coord.bottom;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   from below
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing from below
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //       Cand 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Exist
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_YMAX - %d", iExist));
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.bottom = pCand->bottom;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->top = g_baBounds[iExist].Coord.top;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_ENCLOSED:
                    //
                    // The existing is enclosed by the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Cand          |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Exist    |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // If the candidate is the original, replace the
                    // existing by the candidate, and make the new existing
                    // the new candidate.
                    //
                    // If the candidate is an existing rectangle, remove
                    // the other existing rectangle.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_ENCLOSED - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord   = *pCand;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSED_XMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Exist         |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||E |
                    //           |                      ||x |
                    //           |        Cand          ||i |
                    //           |                      ||s |
                    //           |                      ||t |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_XMIN - %d", iExist));
                    g_baBounds[iExist].Coord.left = pCand->right + 1;
                    break;

                case OL_PART_ENCLOSED_XMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |               |      |
                    //     |     |        Exist  |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     | E  ||                      |
                    //     | x  ||                      |
                    //     | i  ||        Cand          |
                    //     | s  ||                      |
                    //     | t  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_XMAX - %d", iExist));
                    g_baBounds[iExist].Coord.right = pCand->left - 1;
                    break;

                case OL_PART_ENCLOSED_YMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |  Exist |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_YMIN - %d", iExist));
                    g_baBounds[iExist].Coord.top = pCand->bottom + 1;
                    break;

                case OL_PART_ENCLOSED_YMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Exist  |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Cand          |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_YMAX - %d", iExist));
                    g_baBounds[iExist].Coord.bottom = pCand->top - 1;
                    break;

                case OL_ENCLOSES:
                    //
                    // The existing encloses the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Exist         |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Cand     |    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // Just discard the candidate by exiting.
                    //
                    //
                    TRACE_OUT(( "OL_ENCLOSES - %d", iExist));

                    //
                    // Return FALSE indicating that the rectangle is
                    // already catered for by the existing bounds
                    //
                    rc= FALSE;
                    DC_QUIT;
                    break;

                case OL_PART_ENCLOSES_XMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |        Cand   |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     |    ||                      |
                    //     | C  ||                      |
                    //     | a  ||                      |
                    //     | n  ||        Exist         |
                    //     | d  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_XMIN - %d", iExist));
                    pCand->right = g_baBounds[iExist].Coord.left - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_XMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Cand          |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||  |
                    //           |                      ||C |
                    //           |        Exist         ||a |
                    //           |                      ||n |
                    //           |                      ||d |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_XMAX - %d", iExist));
                    pCand->left = g_baBounds[iExist].Coord.right + 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Cand   |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Exist         |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_YMIN - %d", iExist));
                    pCand->bottom = g_baBounds[iExist].Coord.top - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |  Cand  |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_YMAX - %d", iExist));
                    pCand->top = g_baBounds[iExist].Coord.bottom + 1;

                    fResetRects = TRUE;
                    break;

                case OL_SPLIT_X:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Exist |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           | Cand|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into left and right halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the right. Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |        |151,130
                    //           +----+|        |+-----+
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           |Cand|| Exist  || New |
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           +----+|        |+-----+
                    //           99,160|        |     180,160
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_X - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.right + 1;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_Y:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Cand  |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           |Exist|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into top and bottom halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the top and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |  Cand  |
                    //        70,130   +--------+150,129
                    //           +---------------------+
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           +---------------------+180,160
                    //          100,161+--------+
                    //                 |  New   |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_Y - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->bottom  = g_baBounds[iExist].Coord.top - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Cand        |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Exist    |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into top and left pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //          100,100     151,100
                    //              +-------+-------+
                    //              |       |       |
                    //              |       |  New  |
                    //              |       |       |
                    //              |       |       |200,149
                    //              |       +-------+-----+
                    //              | Cand  |150,150      |
                    //              |       |             |
                    //              |       |             |
                    //              |       |             |
                    //              |       |    Exist    |
                    //              +-------+             |
                    //               150,200|             |
                    //                      |             |
                    //                      |             |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMIN_YMIN - %d", iExist));

                    if ( g_baRectsUsed < BA_NUM_RECTS )
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |       Cand    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Exist        |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into top and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100     201,100
                    //                     +--------+------+
                    //                     |  New   |      |
                    //                     |        |      |
                    //          100,150    | 200,149|      |
                    //              +------+--------+      |
                    //              |               | Cand |
                    //              |               |      |
                    //              |               |      |
                    //              |               |      |
                    //              |     Exist     |      |
                    //              |               |      |
                    //              |               +------+
                    //              |               |   250,200
                    //              |               |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMAX_YMIN - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |      Exist    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Cand         |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into left and bottom pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |               |
                    //          100,150    |               |
                    //              +------+               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              | Cand |               |
                    //              |      |               |
                    //              |      +--------+------+
                    //              |      |151,200 |   250,200
                    //              |      |        |
                    //              |      |  New   |
                    //              +------+--------+
                    //                  149,250   200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMIN_YMAX - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Exist       |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Cand     |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into bottom and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the bottom.  Call this routine recursively to
                    // handle the new rectangle.
                    //
                    //          100,100
                    //              +---------------+
                    //              |               |
                    //              |               |
                    //              |               |
                    //              |               |201,150
                    //              |    Exist      +-----+
                    //              |               |     |
                    //              |               |     |
                    //              |               |     |
                    //              |               |Cand |
                    //              |        200,200|     |
                    //              +-------+-------+     |
                    //               150,201|       |     |
                    //                      |       |     |
                    //                      |  New  |     |
                    //                      |       |     |
                    //                      +-------+-----+
                    //                         200,250  250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMAX_YMAX - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                default:
                    //
                    // This should not happen.
                    //
                    ERROR_OUT(( "Unrecognised overlap case-%d",OverlapType));
                    break;
            }

            iExist = (fResetRects) ? g_baFirstRect :
                                     g_baBounds[iExist].iNext;
        }


        //
        // Arriving here means that no overlap was found between the
        // candidate and the existing rectangles.
        //
        // - If the candidate is the original rectangle, add it to the
        //   list.
        // - If the candidate is an existing rectangle, it is already in
        //   the list.
        //
        if ( fRectToAdd )
        {
            BAAddRectList(pCand);
        }


        //
        // The compare and add processing above is allowed to add a
        // rectangle to the list when there are already BA_NUM_RECTS
        // (eg. when doing a split or when there is no overlap at all with
        // the existing rectangles) - and there is an extra slot for that
        // purpose.
        //
        // If we now have more than BA_NUM_RECTS rectangles, do a
        // forced merge, so that the next call to this routine has a spare
        // slot.
        //
        //
        fRectMerged = ( g_baRectsUsed > BA_NUM_RECTS );
        if ( fRectMerged )
        {
            //
            // Start looking for merged rectangles.
            //
            // For each rectangle in the list, compare it with the others,
            // and Determine cost of merging.
            //
            // We want to merge the two rectangles with the minimum
            // area difference, ie that will produce a merged
            // rectangle that covers the least superfluous screen
            // area.
            //
            // Note that we calculate the areas of the rectangles here
            // (rather than on the fly as they are created/ manipulated in
            // the loop), as the statistics show that forced merges occur
            // very much less frequently than non-forced manipulations (ie
            // splits, adds etc.
            //
            //
            bestMergeIncrease = 0x7FFFFFFF;

            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                g_baBounds[iExist].Area =
                    COM_SizeOfRectInclusive(&g_baBounds[iExist].Coord);
            }

#ifdef _DEBUG
            iBestMerge1 = BA_INVALID_RECT_INDEX;
            iBestMerge2 = BA_INVALID_RECT_INDEX;
#endif

            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                for ( iTmp = g_baBounds[iExist].iNext;
                      iTmp != BA_INVALID_RECT_INDEX;
                      iTmp = g_baBounds[iTmp].iNext )
                {
                    rectNew.left = min( g_baBounds[iExist].Coord.left,
                                           g_baBounds[iTmp].Coord.left );
                    rectNew.top = min( g_baBounds[iExist].Coord.top,
                                          g_baBounds[iTmp].Coord.top );
                    rectNew.right = max( g_baBounds[iExist].Coord.right,
                                            g_baBounds[iTmp].Coord.right );
                    rectNew.bottom = max( g_baBounds[iExist].Coord.bottom,
                                             g_baBounds[iTmp].Coord.bottom );

                    mergeIncrease = COM_SizeOfRectInclusive(&rectNew) -
                        g_baBounds[iExist].Area - g_baBounds[iTmp].Area;

                    if (bestMergeIncrease > mergeIncrease)
                    {
                        iBestMerge1 = iExist;
                        iBestMerge2 = iTmp;
                        bestMergeIncrease = mergeIncrease;
                    }
                }
            }

            ASSERT(iBestMerge1 != BA_INVALID_RECT_INDEX);
            ASSERT(iBestMerge2 != BA_INVALID_RECT_INDEX);

            //
            // Now do the merge.
            //
            // We recalculate the size of the merged rectangle here -
            // alternatively we could remember the size of the best so far
            // in the loop above.  The trade off is between calculating
            // twice or copying at least once but probably more than once
            // as we find successively better merges.
            //
            TRACE_OUT(("BestMerge1 %d, (%d,%d,%d,%d)", iBestMerge1,
                       g_baBounds[iBestMerge1].Coord.left,
                       g_baBounds[iBestMerge1].Coord.top,
                       g_baBounds[iBestMerge1].Coord.right,
                       g_baBounds[iBestMerge1].Coord.bottom ));

            TRACE_OUT(("BestMerge2 %d, (%d,%d,%d,%d)", iBestMerge2,
                       g_baBounds[iBestMerge2].Coord.left,
                       g_baBounds[iBestMerge2].Coord.top,
                       g_baBounds[iBestMerge2].Coord.right,
                       g_baBounds[iBestMerge2].Coord.bottom ));

            g_baBounds[iBestMerge1].Coord.left =
                            min( g_baBounds[iBestMerge1].Coord.left,
                                    g_baBounds[iBestMerge2].Coord.left );
            g_baBounds[iBestMerge1].Coord.top =
                            min( g_baBounds[iBestMerge1].Coord.top,
                                    g_baBounds[iBestMerge2].Coord.top );
            g_baBounds[iBestMerge1].Coord.right =
                            max( g_baBounds[iBestMerge1].Coord.right,
                                    g_baBounds[iBestMerge2].Coord.right );
            g_baBounds[iBestMerge1].Coord.bottom =
                            max( g_baBounds[iBestMerge1].Coord.bottom,
                                    g_baBounds[iBestMerge2].Coord.bottom );

            //
            // Remove the second best merge.
            //
            BA_RemoveRectList(&(g_baBounds[iBestMerge2].Coord));

            //
            // The best merged rectangle becomes the candidate, and we fall
            // g_back to the head of the comparison loop to start again.
            //
            pCand      = &(g_baBounds[iBestMerge1].Coord);
            iLastMerge = iBestMerge1;
            fRectToAdd = FALSE;
        }

    } while ( fRectMerged );

DC_EXIT_POINT:
    DebugExitBOOL(BAAddRect, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.nt\globalnt.h ===
//
// GLOBALNT.H
// Global variables specific to NT
//

DC_DATA ( IM_SHARED_DATA,   g_imSharedData );
DC_DATA ( IM_NT_DATA,       g_imNTData );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\globals.c ===
//
// GLOBALS.C
// Global variable storage
//
// Copyright(c) Microsoft 1997-
//


#include "precomp.h"


#include <datainit.h>
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\com.c ===
#include "precomp.h"


//
// COM.C
// Common functions, simple
//
// Copyright(c) Microsoft 1997-
//



//
// COM_BasedListInsertBefore(...)
//
// See com.h for description.
//
void COM_BasedListInsertBefore(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertBefore);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item before pExisting:
    //
    pTemp = COM_BasedPrevListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pTemp, pExisting));

    //
    // Set its <next> field to point to the new item
    //
    pTemp->next = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->prev  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <prev> field of pExisting to point to new item:
    //
    pExisting->prev = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->next      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertBefore);
} // COM_BasedListInsertBefore


//
// COM_BasedListInsertAfter(...)
//
// See com.h for description.
//
void COM_BasedListInsertAfter(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertAfter);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item after pExisting:
    //
    pTemp = COM_BasedNextListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pExisting, pTemp));

    //
    // Set its <prev> field to point to the new item
    //
    pTemp->prev = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->next  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <next> field of pExisting to point to new item:
    //
    pExisting->next = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->prev      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertAfter);
} // COM_BasedListInsertAfter


//
// COM_BasedListRemove(...)
//
// See com.h for description.
//
void COM_BasedListRemove(PBASEDLIST pListItem)
{
    PBASEDLIST pNext     = NULL;
    PBASEDLIST pPrev     = NULL;

    DebugEntry(COM_BasedListRemove);

    //
    // Check for bad parameters.
    //
    ASSERT((pListItem != NULL));

    pPrev = COM_BasedPrevListField(pListItem);
    pNext = COM_BasedNextListField(pListItem);

    ASSERT((pPrev != NULL));
    ASSERT((pNext != NULL));

    TRACE_OUT(("Removing item at %#lx from list", pListItem));

    pPrev->next = PTRBASE_TO_OFFSET(pNext, pPrev);
    pNext->prev = PTRBASE_TO_OFFSET(pPrev, pNext);

    DebugExitVOID(COM_BasedListRemove);
} // COM_BasedListRemove


//
//
// List manipulation routines
//  COM_BasedListNext
//  COM_BasedListPrev
//  COM_BasedListFirst
//  COM_BasedListLast
//
//

void FAR * COM_BasedListNext( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedNextListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}

void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedPrevListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}


void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedNextListField(pHead), nOffset));
}

void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedPrevListField(pHead), nOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\cm.c ===
#include "precomp.h"


//
// CM.C
// Cursor Manager, display driver side
//
// Copyright(c) Microsoft 1997-
//


//
//
// CM_DDProcessRequest() - see cm.h
//
//
ULONG CM_DDProcessRequest
(
    SURFOBJ*    pso,
    UINT        cjIn,
    void *      pvIn,
    UINT        cjOut,
    void *      pvOut
)
{
    BOOL                rc;
    LPOSI_ESCAPE_HEADER pHeader;
    LPOSI_PDEV          ppDev = (LPOSI_PDEV)pso->dhpdev;

    DebugEntry(CM_DDProcessRequest);

    if ((cjIn != sizeof(CM_DRV_XFORM_INFO)) ||
        (cjOut != sizeof(CM_DRV_XFORM_INFO)))
    {
        ERROR_OUT(("CM_DDProcessRequest:  Invalid sizes %d, %d for CM_ESC", cjIn, cjOut));
        rc = FALSE;
        DC_QUIT;
    }

    //
    // Get the request number.
    //
    pHeader = pvIn;
    switch (pHeader->escapeFn)
    {
        case CM_ESC_XFORM:
        {
            ASSERT(cjIn == sizeof(CM_DRV_XFORM_INFO));
            ASSERT(cjOut == sizeof(CM_DRV_XFORM_INFO));

            ((LPCM_DRV_XFORM_INFO)pvOut)->result =
                     CMDDSetTransform(ppDev, (LPCM_DRV_XFORM_INFO)pvIn);

            rc = TRUE;
            break;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognised CM_ escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(CM_DDProcessRequest, rc);
    return((ULONG)rc);
}



// Name:      CM_DDInit
//
// Purpose:   Allocate a working surface for colour cursors
//
// Returns:   TRUE/FALSE
//
// Params:    IN      ppDev  - surface information
//
BOOL CM_DDInit(LPOSI_PDEV ppDev)
{
    SIZEL   bitmapSize;
    BOOL    rc = FALSE;

    DebugEntry(CM_DDInit);

    ASSERT(!g_cmWorkBitmap);

    //
    // Allocate the work bitmap, at the local device resolution.  Note that
    // we create it "top down" rather than the default of "bottom up" to
    // simplify copying data from the bitmap (we don't have to work out
    // offsets into the data - we can copy from the beginning).
    //
    bitmapSize.cx = CM_MAX_CURSOR_WIDTH;
    bitmapSize.cy = CM_MAX_CURSOR_HEIGHT;
    g_cmWorkBitmap = EngCreateBitmap(bitmapSize,
            BYTES_IN_BITMAP(bitmapSize.cx, 1, ppDev->cBitsPerPel),
            ppDev->iBitmapFormat, BMF_TOPDOWN, NULL);

    if (!g_cmWorkBitmap)
    {
        ERROR_OUT(( "Failed to create work bitmap"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(CM_DDInit, rc);
    return(rc);
}



//
//
// CM_DDTerm - see cm.h
//
//
void CM_DDTerm(void)
{
    DebugEntry(CM_DDTerm);

    //
    // Destroy the bitmap.  Despite its name, EngDeleteSurface is the
    // correct function to do this.
    //
    if (g_cmWorkBitmap)
    {
        if (!EngDeleteSurface((HSURF)g_cmWorkBitmap))
        {
            ERROR_OUT(( "Failed to delete work bitmap"));
        }
        else
        {
            TRACE_OUT(( "Deleted work bitmap"));
        }

        g_cmWorkBitmap = NULL;
    }

    DebugExitVOID(CM_DDTerm);
}


//
// CM_DDViewing()
//
void CM_DDViewing
(
    SURFOBJ *   pso,
    BOOL        fViewers
)
{
    DebugEntry(CM_DDViewing);

    if (fViewers)
    {
        //
        // Jiggle the cursor so we get the current image.
        //
        EngSetPointerTag(((LPOSI_PDEV)pso->dhpdev)->hdevEng, NULL, NULL, NULL, 0);
    }

    DebugExitVOID(CM_DDViewing);
}


//
//
// DrvSetPointerShape - see winddi.h
//
//
ULONG  DrvSetPointerShape(SURFOBJ  *pso,
                          SURFOBJ  *psoMask,
                          SURFOBJ  *psoColor,
                          XLATEOBJ *pxlo,
                          LONG      xHot,
                          LONG      yHot,
                          LONG      x,
                          LONG      y,
                          RECTL    *prcl,
                          FLONG     fl)
{
    ULONG                 rc         = SPS_ACCEPT_NOEXCLUDE;
    SURFOBJ *         pWorkSurf  = NULL;
    LPOSI_PDEV             ppDev      = (LPOSI_PDEV)pso->dhpdev;
    BOOL                writingSHM = FALSE;
    LPCM_SHAPE_DATA pCursorShapeData;
    RECTL                 destRectl;
    POINTL                sourcePt;
    int                   ii;
    LONG                  lineLen;
    LPBYTE              srcPtr;
    LPBYTE              dstPtr;
    LPCM_FAST_DATA      lpcmShared;

    DebugEntry(DrvSetPointerShape);

    //
    // Returning SPS_ACCEPT_NOEXCLUDE means we can ignore prcl.
    //

    //
    // Only process the change if we are hosting.  (Hosting implies being
    // initialized).
    //
    if (!g_oeViewers)
    {
        DC_QUIT;
    }

    //
    // Get access to the shared memory.
    //
    lpcmShared = CM_SHM_START_WRITING;
    writingSHM = TRUE;

    //
    // First of all, let's trace out some useful information.
    //
    TRACE_OUT(( "pso %#hlx psoMask %#hlx psoColor %#hlx pxlo %#hlx",
                  pso, psoMask, psoColor, pxlo));
    TRACE_OUT(( "hot spot (%d, %d) x, y (%d, %d)", xHot, yHot, x, y));
    TRACE_OUT(( "Flags %#hlx", fl));

    //
    // Set up a local pointer to the cursor shape data.
    //

    pCursorShapeData = &lpcmShared->cmCursorShapeData;

    if (psoMask == NULL)
    {
        //
        // This is a transparent cursor.  Send a NULL cursor.  Note that
        // this is not the same as hiding the cursor using DrvMovePointer -
        // as in this case the cursor cannot be unhidden unless
        // DrvSetPointerShape is called again.
        //
        TRACE_OUT(( "Transparent Cursor"));
        CM_SET_NULL_CURSOR(pCursorShapeData);
        g_asSharedMemory->cmCursorHidden = FALSE;
        lpcmShared->cmCursorStamp = g_cmNextCursorStamp++;
        DC_QUIT;
    }

    //
    // We've been passed a system cursor.  Fill in the header for our local
    // cursor.  We can get the hot spot position and cursor size and width
    // easily.
    //
    pCursorShapeData->hdr.ptHotSpot.x = xHot;
    pCursorShapeData->hdr.ptHotSpot.y = yHot;

    TRACE_OUT(( "Pointer mask is %#hlx by %#hlx pixels (lDelta: %#hlx)",
             psoMask->sizlBitmap.cx,
             psoMask->sizlBitmap.cy,
             psoMask->lDelta));

    pCursorShapeData->hdr.cx = (WORD)psoMask->sizlBitmap.cx;
    pCursorShapeData->hdr.cy = (WORD)psoMask->sizlBitmap.cy / 2;

    //
    // Check cursor size
    //
    if ((pCursorShapeData->hdr.cx > CM_MAX_CURSOR_WIDTH) ||
        (pCursorShapeData->hdr.cy > CM_MAX_CURSOR_HEIGHT))
    {
        ERROR_OUT(( "Cursor too big! %d %d",
                     psoMask->sizlBitmap.cx, psoMask->sizlBitmap.cy));
        DC_QUIT;
    }

    //
    // lDelta may be negative for an inverted cursor (which is what we get
    // from DC-Share).
    //
    lineLen = abs(psoMask->lDelta);

    //
    // At this point we need to know if we are dealing with a color cursor.
    //
    if (NULL == psoColor)
    {
        TRACE_OUT(( "Monochrome pointer"));

        pCursorShapeData->hdr.cPlanes     = 1;
        pCursorShapeData->hdr.cBitsPerPel = 1;

        pCursorShapeData->hdr.cbRowWidth  = (WORD)lineLen;

        //
        // Copy the 1bpp AND mask and cursor shape (XOR mask) across.
        //
        TRACE_OUT(( "Copying AND mask across from %#hlx (size: %#hlx)",
                 psoMask->pvBits,
                 psoMask->cjBits));

        dstPtr = pCursorShapeData->data;
        srcPtr = (LPBYTE) psoMask->pvScan0;
        for (ii = pCursorShapeData->hdr.cy * 2; ii > 0 ; ii--)
        {
            memcpy(dstPtr, srcPtr, lineLen);
            srcPtr += psoMask->lDelta;
            dstPtr += lineLen;
        }

        //
        // Copy black-and-white palette colors
        //
        TRACE_OUT(( "Copy B+W palette"));

        lpcmShared->colorTable[0].peRed   = 0;
        lpcmShared->colorTable[0].peGreen = 0;
        lpcmShared->colorTable[0].peBlue  = 0;
        lpcmShared->colorTable[0].peFlags = 0;

        lpcmShared->colorTable[1].peRed   = 255;
        lpcmShared->colorTable[1].peGreen = 255;
        lpcmShared->colorTable[1].peBlue  = 255;
        lpcmShared->colorTable[1].peFlags = 0;

        //
        // That's all we need to do in this case.
        //
    }
    else
    {
        TRACE_OUT(( "Color pointer - mask of %#hlx by %#hlx (lDelta: %#hlx)",
                 psoColor->sizlBitmap.cx,
                 psoColor->sizlBitmap.cy,
                 psoColor->lDelta));

        //
        // Note: row width used to calculate AND mask size - and is thus
        // for the 1bpp mask.
        //
        pCursorShapeData->hdr.cbRowWidth  = (WORD)lineLen;
        pCursorShapeData->hdr.cPlanes     = 1;

        //
        // Note: data at device bpp.
        //
        TRACE_OUT(( "BPP is %d", pCursorShapeData->hdr.cBitsPerPel));
        pCursorShapeData->hdr.cBitsPerPel = (BYTE)ppDev->cBitsPerPel;

        //
        // Lock the work bitmap to get a surface to pass to EngBitBlt.
        //
        pWorkSurf = EngLockSurface((HSURF)g_cmWorkBitmap);
        if (NULL == pWorkSurf)
        {
            ERROR_OUT(( "Failed to lock work surface"));
            DC_QUIT;
        }
        TRACE_OUT(( "Locked surface"));

        //
        // Perform the Blt to our work bitmap so that we can get the bits
        // at the native bpp.
        //
        destRectl.top    = 0;
        destRectl.left   = 0;
        destRectl.right  = psoColor->sizlBitmap.cx;
        destRectl.bottom = psoColor->sizlBitmap.cy;

        sourcePt.x = 0;
        sourcePt.y = 0;

        if (!EngBitBlt(pWorkSurf,
                       psoColor,
                       NULL,                    // mask surface
                       NULL,                    // clip object
                       pxlo,                    // XLATE object
                       &destRectl,
                       &sourcePt,
                       NULL,                    // mask origin
                       NULL,                    // brush
                       NULL,                    // brush origin
                       0xcccc))                 // SRCCPY
        {
            ERROR_OUT(( "Failed to Blt to work bitmap"));
            DC_QUIT;
        }
        TRACE_OUT(( "Got the bits at native format into the work bitmap"));

        //
        // Now copy the bits we want from this work bitmap into the
        // DCCURSORSHAPE shared memory.
        // First copy the AND bits (but ignore the redundant 1bpp XOR bits)
        //
        TRACE_OUT(( "Copy %d bytes of 1bpp AND mask", psoMask->cjBits/2));

        dstPtr = pCursorShapeData->data;
        srcPtr = (LPBYTE) psoMask->pvScan0;
        for (ii = pCursorShapeData->hdr.cy; ii > 0 ; ii--)
        {
            memcpy(dstPtr, srcPtr, lineLen);
            srcPtr += psoMask->lDelta;
            dstPtr += lineLen;
        }

        TRACE_OUT(( "Copy %d bytes of color", pWorkSurf->cjBits));
        memcpy(&(pCursorShapeData->data[psoMask->cjBits / 2]),
                  pWorkSurf->pvBits,
                  pWorkSurf->cjBits);


        //
        // Now work out the palette and copy into shared memory
        //
        if (pCursorShapeData->hdr.cBitsPerPel > 8)
        {
            //
            // Need the bitmasks.
            //
            TRACE_OUT(( "Copy bitmasks"));
            lpcmShared->bitmasks[0] = ppDev->flRed;
            lpcmShared->bitmasks[1] = ppDev->flGreen;
            lpcmShared->bitmasks[2] = ppDev->flBlue;
        }
        else
        {
            //
            // Need a palette.
            //
            TRACE_OUT(( "Copy %d palette bytes",
                  COLORS_FOR_BPP(ppDev->cBitsPerPel) * sizeof(PALETTEENTRY)));
            memcpy(lpcmShared->colorTable,
                      ppDev->pPal,
                      COLORS_FOR_BPP(ppDev->cBitsPerPel) *
                                                      sizeof(PALETTEENTRY));
        }
    }

    //
    // Set the cursor stamp, and the cursor hidden state.
    //
    lpcmShared->cmCursorStamp = g_cmNextCursorStamp++;
    g_asSharedMemory->cmCursorHidden = FALSE;

DC_EXIT_POINT:

    //
    // Free access to the shared memory if we got it earlier.
    //
    if (writingSHM)
    {
        CM_SHM_STOP_WRITING;
    }

    if (pWorkSurf != NULL)
    {
        //
        // Unlock the work bitmap surface.
        //
        EngUnlockSurface(pWorkSurf);
    }

    DebugExitDWORD(DrvSetPointerShape, rc);
    return(rc);

} // DrvSetPointerShape


//
// DrvMovePointer - see NT DDK documentation.
// We only look at this in order to check for hidden cursors - normal
// pointer moves are ignored.
//
VOID DrvMovePointer(SURFOBJ *pso,
                    LONG     x,
                    LONG     y,
                    RECTL   *prcl)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV) pso->dhpdev;

    DebugEntry(DrvMovePointer);

    //
    // We don't use the exclusion rectangle because we only support
    // hardware Pointers.  If we were doing our own Pointer simulations we
    // would want to update prcl so that the engine would call us to
    // exclude our pointer before drawing to the pixels in prcl.
    //

    //
    // Only process the mouse move if we are hosting.  (Hosting implies
    // being initialized).
    //
    if (!g_oeViewers)
    {
        DC_QUIT;
    }

    if (x == -1)
    {
        if (!g_cmCursorHidden)
        {
            //
            // Pointer is hidden.
            //
            TRACE_OUT(("Hide the cursor"));

            //
            // Set the 'hide cursor' flag.
            //
            CM_SHM_START_WRITING;
            g_asSharedMemory->cmCursorHidden = TRUE;
            CM_SHM_STOP_WRITING;

            //
            // Update our fast-path variable.
            //
            g_cmCursorHidden = TRUE;
        }
    }
    else
    {
        if (g_cmCursorHidden)
        {
            //
            // The pointer is unhidden
            //
            TRACE_OUT(("Show the cursor"));

            CM_SHM_START_WRITING;
            g_asSharedMemory->cmCursorHidden = FALSE;
            CM_SHM_STOP_WRITING;

            //
            // Update our fast-path variable.
            //
            g_cmCursorHidden = FALSE;
        }
    }


DC_EXIT_POINT:
    DebugExitVOID(DrvMovePointer);
}



// Name:      CMDDSetTransform
//
// Purpose:   Set up a cursor transform
//
// Returns:   TRUE/FALSE
//
// Params:    IN      ppDev - device info
//            IN      pXformInfo - data passed in to DrvEscape
//
BOOL CMDDSetTransform(LPOSI_PDEV ppDev, LPCM_DRV_XFORM_INFO pXformInfo)
{
    BOOL        rc = FALSE;
    LPBYTE      pAND   = pXformInfo->pANDMask;
    SIZEL       bitmapSize;
    HBITMAP     andBitmap;
    SURFOBJ  *  pANDSurf;

    DebugEntry(CMDDSetTransform);

    if (pAND == NULL)
    {
        //
        // Reset the transform
        //
        TRACE_OUT(( "Clear transform"));
        EngSetPointerTag(ppDev->hdevEng, NULL, NULL, NULL, 0);
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Transforms are always monochrome
    //

    //
    // Create a 1bpp bitmap, double-height, with the AND bits followed by
    // the XOR bits.  We are given a top-down DIB, so we need to create
    // a top-down bitmap.
    //
    bitmapSize.cx = pXformInfo->width;
    bitmapSize.cy = pXformInfo->height * 2;

    andBitmap = EngCreateBitmap(bitmapSize, BYTES_IN_BITMAP(bitmapSize.cx, 1, 1),
        BMF_1BPP, BMF_TOPDOWN, NULL);

    pANDSurf = EngLockSurface((HSURF)andBitmap);
    if (pANDSurf == NULL)
    {
        ERROR_OUT(( "Failed to lock work surface"));
        DC_QUIT;
    }

    //
    // Copy the bits
    //
    memcpy(pANDSurf->pvBits, pAND, pANDSurf->cjBits);

    TRACE_OUT(( "Set the tag"));
    EngSetPointerTag(ppDev->hdevEng, pANDSurf, NULL, NULL, 0);

    EngUnlockSurface(pANDSurf);
    EngDeleteSurface((HSURF)andBitmap);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(CMDDSetTransform, rc);
    return(rc);

} // CMDDSetTransform
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\globals.h ===
//
// GLOBALS.H
// Global variable decls
//
// Copyright(c) Microsoft 1997-
//

#include <osi.h>
#include <shm.h>
#include <oa.h>
#include <ba.h>
#include <cm.h>
#include <host.h>
#include <fh.h>
#include <ssi.h>
#include <oe.h>
#include <sbc.h>


//
// Debug stuff
//
#if defined(DEBUG) || defined(INIT_TRACE)
DC_DATA_VAL   ( char,           g_szAssertionFailure[], "Assertion failure!" );
DC_DATA_ARRAY ( char,           g_szDbgBuf, CCH_DEBUG_MAX );
DC_DATA_VAL   ( UINT,           g_trcConfig, ZONE_INIT );
#endif // DEBUG or INIT_TRACE



//
// Driver
//




//
// Shared Memory Manager
//
DC_DATA     ( LPSHM_SHARED_MEMORY,      g_asSharedMemory );
DC_DATA_ARRAY ( LPOA_SHARED_DATA,       g_poaData,    2 );

//
// Shared memory.
//
DC_DATA ( UINT,           g_shmSharedMemorySize );
DC_DATA ( LPVOID,         g_shmMappedMemory );      // user mode ptr




//
// Bounds Accumulator
//
DC_DATA ( UINT,           g_baFirstRect );
DC_DATA ( UINT,           g_baLastRect );
DC_DATA ( UINT,           g_baRectsUsed );

DC_DATA_ARRAY ( DD_BOUNDS,  g_baBounds,   BA_NUM_RECTS+1);


//
// A local copy of the bounding rectangles which the share core is
// currently processing.  These are used when accumulating orders which
// rely on the contents of the destination.
//
DC_DATA         ( UINT,    g_baNumSpoilingRects);
DC_DATA_ARRAY   ( RECT,    g_baSpoilingRects,    BA_NUM_RECTS);


//
// Is the spoiling of existing orders when adding screen data allowed at
// the moment, or temporarily disabled ?  To do the spoiling, both
// baSpoilByNewSDA and baSpoilByNewSDAEnabled must be TRUE.
//
DC_DATA_VAL ( BOOL,   g_baSpoilByNewSDAEnabled,     TRUE);




//
// Cursor Manager
//

DC_DATA (HBITMAP,   g_cmWorkBitmap );
DC_DATA (DWORD,     g_cmNextCursorStamp );
DC_DATA (BOOL,      g_cmCursorHidden );



//
// Hosted Entity Tracker
//
DC_DATA ( BASEDLIST,           g_hetWindowList );  // Anchor for hosted wnd list
DC_DATA ( BASEDLIST,           g_hetFreeWndList ); // Anchor for free list
DC_DATA ( BASEDLIST,           g_hetMemoryList );  // Anchor for memory block list

//
// Flag which indicates if the desktop is shared.
//
DC_DATA ( BOOL,             g_hetDDDesktopIsShared );



//
// Order Accumulator
//

// Throughput
DC_DATA ( UINT,         g_oaFlow );

//
// Flag to indicate whether we are allowed to purge the order heap.
//
DC_DATA_VAL ( BOOL,     g_oaPurgeAllowed,            TRUE);


//
// Order Encoder 
//

//
// Are we supporting all ROPS in a conference, or do we disallow ROPS which
// involve the destination bits.
//
DC_DATA ( BOOL,             g_oeSendOrders );

//
// Are text orders allowed?
//
DC_DATA ( BOOL,           g_oeTextEnabled );

//
// Array of supported orders
//
DC_DATA_ARRAY ( BYTE,       g_oeOrderSupported,   ORD_NUM_INTERNAL_ORDERS );



//
// Temporary buffer to store the memblt and mem3blt orders which are
// initially created by the display driver interception code.  This buffer
// is used because the subsequent logic for these orders breaks down the
// original order into smaller tiled orders and then throws the original
// away.  So to keep a coherent order heap, we do not allocate the
// temporary order off the heap.
//
DC_DATA_ARRAY(BYTE,
                   g_oeTmpOrderBuffer,
                   sizeof(INT_ORDER) +
                       max( max( max(sizeof(MEMBLT_ORDER),
                                              sizeof(MEMBLT_R2_ORDER) ),
                                       sizeof(MEM3BLT_ORDER) ),
                               sizeof(MEM3BLT_R2_ORDER) ));

//
// Storage space to create a temporary solid brush for BitBlt orders.
//
DC_DATA ( OE_BRUSH_DATA,    g_oeBrushData );

//
// Local font matching data - this is passed from the share core
//
DC_DATA ( LPLOCALFONT,  g_poeLocalFonts );

//
// Local font index.  This is an array of bookmarks that indicate the first
// entry in the local font table that starts with a particular character.
// For example, g_oeLocalFontIndex[65] gives the first index in g_oeLocalFonts
// that starts with the character 'A'.
//
DC_DATA_ARRAY( WORD,  g_oeLocalFontIndex, FH_LOCAL_INDEX_SIZE );

//
// Number of local fonts
//
DC_DATA ( UINT,             g_oeNumFonts );

//
// Capabilities - from PROTCAPS_ORDERS
//
DC_DATA ( UINT,             g_oeFontCaps );

//
// Do we support baseline text orders for this conference?
//
DC_DATA ( BOOL,           g_oeBaselineTextEnabled );

//
// Local font matching data - this is passed from the share core
//
DC_DATA_ARRAY ( WCHAR,      g_oeTempString, (ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1));

DC_DATA ( BOOL,             g_oeViewers );         // Accumulate graphics



//
// Send Bitmap Cache
//


//
// BPP for bitmap data sent over the wire
//
DC_DATA ( UINT,  g_sbcSendingBPP );

//
// Cache info
//
DC_DATA_ARRAY( SBC_SHM_CACHE_INFO,  g_asbcCacheInfo,  NUM_BMP_CACHES );


//
// Array of structures holding the info required to get the bitmap bits
// from the source surface into the shunt buffer.
//
DC_DATA_ARRAY (SBC_TILE_WORK_INFO, g_asbcWorkInfo, SBC_NUM_TILE_SIZES );

//
// The Id to use for the next tile passed to the share core in a shunt
// buffer.
//
DC_DATA ( WORD,   g_sbcNextTileId );

//
// This is the number of ticks per second which the performance timer
// generates.  We store this rather than making lots of calls to
// EngQueryPerformanceFrequency.
//
DC_DATA ( LONGLONG, g_sbcPerfFrequency );

//
// Array of structures containing info about bitmap cache thrashers
//
DC_DATA_ARRAY (SBC_THRASHERS,   g_sbcThrashers, SBC_NUM_THRASHERS );


//
// Save Screenbits Interceptor
//

//
// Remote status for SSB
//
DC_DATA ( REMOTE_SSB_STATE,  g_ssiRemoteSSBState );

//
// Local status for SSB
//
DC_DATA ( LOCAL_SSB_STATE,  g_ssiLocalSSBState );

//
// Current max for save screen bitmap size
//
DC_DATA ( DWORD,            g_ssiSaveBitmapSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\oa.c ===
#include "precomp.h"


//
// OA.C
// Order Accumulation, both cpi32 and display driver sides
//
// Copyright(c) Microsoft 1997-
//



//
// OA_DDProcessRequest - see oa.h
//
BOOL OA_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc;

    DebugEntry(OA_DDProcessRequest);

    //
    // Get the request number.
    //
    switch (fnEscape)
    {
        case OA_ESC_FLOW_CONTROL:
        {
            if (cbRequest != sizeof(OA_FLOW_CONTROL))
            {
                ERROR_OUT(("OA_DDProcessRequest:  Invalid size %d for OA_ESC_FLOW_CONTROL",
                    cbRequest));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // Save new order accum throughput value
            //
            g_oaFlow = ((LPOA_FLOW_CONTROL)pRequest)->oaFlow;
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OA escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(OA_DDProcessRequest, rc);
    return(rc);
}



//
//
// OA_DDAddOrder(..)
//
// Adds an order to the queue for transmission.
//
// If the new order is completetly covered by the current SDA then
// it is spoilt.
//
// If the order is opaque and overlaps earlier orders it may clip
// or spoil them.
//
// Called by the GDI interception code.
//
//
void  OA_DDAddOrder(LPINT_ORDER pNewOrder, void FAR * pExtraInfo)
{
    RECT      SDARects[BA_NUM_RECTS*2];
    UINT      cBounds;
    UINT      spoilingBounds;
    UINT      totalBounds;
    UINT      i;
    RECT      SrcRect;
    RECT      tmpRect;
    BOOL      gotBounds = FALSE;
    int       dx;
    int       dy;
    RECT      IntersectedSrcRect;
    RECT      InvalidDstRect;
    LPINT_ORDER  pTmpOrder;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    LPOA_SHARED_DATA    lpoaShared;
    LPOA_FAST_DATA      lpoaFast;

    DebugEntry(OA_DDAddOrder);

    lpoaShared  = OA_SHM_START_WRITING;
    lpoaFast    = OA_FST_START_WRITING;

    //
    // Accumulate order accumulation rate.  We are interested in how
    // quickly orders are being added to the buffer, so that we can tell
    // DCS scheduling whether frequent sends are advisable
    //
    SHM_CheckPointer(&lpoaFast->ordersAccumulated);
    lpoaFast->ordersAccumulated++;

    //
    // If the order is a private one, then we just add it to the Order
    // List and return immediately.
    //
    // Private Orders are used to send bitmap cache information (bitmap
    // bits and color tables).
    //
    // Private Orders never spoil any others and must never be spoilt.
    //
    if (pNewOrder->OrderHeader.Common.fOrderFlags & OF_PRIVATE)
    {
        TRACE_OUT(("Add private order (%lx)", pNewOrder));
        OADDAppendToOrderList(lpoaShared, pNewOrder);
        DC_QUIT;
    }

    //
    // If this order is spoilable and its is completely enclosed by the
    // current screen data area, we can spoil it.  Unless...
    //
    // PM - Performance
    //
    // We have observed in usability testing that clipping orders always
    // degrades the end-user's perceived performance.  This is because the
    // orders flow much faster than the screendata and tend to relate to
    // text, which is what the user really wants to see.  For example, text
    // overwriting a bitmap will be delayed because we want to send the
    // bitmap as screendata.
    //
    // Also, word documents tend to contain sections of screendata due to
    // mismatched fonts, intelliquotes, spelling annotation, current line
    // memblit.  Nothing we can do about this, but if we page down two or
    // three times, or down and up again we get an accumulation of the
    // screendata on all the pages spoiling the orders and the end result
    // is that we have to wait longer than we would if we had not spoiled
    // the orders.
    //
    // So, what we can do instead is leave the text orders in and overwrite
    // them with screendata when it gets through.  However, to make this
    // really effective what we also do is convert any transparent text
    // (as WEB browsers tend to use) into opaque text on a default
    // background.
    //
    //
    if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILABLE) != 0)
    {
        //
        // Get the driver's current bounds.
        //
        BA_CopyBounds(SDARects, &cBounds, FALSE);
        gotBounds = TRUE;

        for (i = 0; i < cBounds ; i++)
        {
            if ( OADDCompleteOverlapRect(&pNewOrder->OrderHeader.Common.rcsDst,
                                      &(SDARects[i])) )
            {
                //
                // The destination of the order is completely covered by
                // the SDA.  Check for a text order.
                //
                pExtTextOut = (LPEXTTEXTOUT_ORDER)pNewOrder->abOrderData;
                if (pExtTextOut->type == ORD_EXTTEXTOUT_TYPE)
                {
                    //
                    // The order is going to be completely overwritten so
                    // we can play around with it all we like.
                    // Just make it opaque so the user can read it while
                    // waiting for the screendata to follow on.
                    //
                    pExtTextOut->fuOptions |= ETO_OPAQUE;

                    //
                    // pExtTextOut->rectangle is a TSHR_RECT32
                    //
                    pExtTextOut->rectangle.left = pNewOrder->OrderHeader.Common.rcsDst.left;
                    pExtTextOut->rectangle.top = pNewOrder->OrderHeader.Common.rcsDst.top;
                    pExtTextOut->rectangle.right = pNewOrder->OrderHeader.Common.rcsDst.right;
                    pExtTextOut->rectangle.bottom = pNewOrder->OrderHeader.Common.rcsDst.bottom;

                    TRACE_OUT(("Converted text order to opaque"));
                    break;
                }
                else
                {
                    TRACE_OUT(("Spoiling order by SDA"));
                    OA_DDFreeOrderMem(pNewOrder);
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Pass the order onto the Bitmap Cache Controller to try to cache the
    // src bitmap.
    //
    if (ORDER_IS_MEMBLT(pNewOrder) || ORDER_IS_MEM3BLT(pNewOrder))
    {
        if (!SBC_DDCacheMemScreenBlt(pNewOrder, pExtraInfo))
        {
            //
            // The memory to screen blt cannot be handled as an order (the
            // source bitmap could not cached).  Add the destination of the
            // blt into the SDA and discard the order.
            //
            TRACE_OUT(("Failed to cache mem->screen blt"));
            TRACE_OUT(("Add rect to SDA (%d,%d)(%d,%d)",
                           pNewOrder->OrderHeader.Common.rcsDst.left,
                           pNewOrder->OrderHeader.Common.rcsDst.top,
                           pNewOrder->OrderHeader.Common.rcsDst.right,
                           pNewOrder->OrderHeader.Common.rcsDst.bottom ));

            RECT_FROM_TSHR_RECT16(&tmpRect,
                                    pNewOrder->OrderHeader.Common.rcsDst);
            OA_DDFreeOrderMem(pNewOrder);
            BA_AddScreenData(&tmpRect);
            DC_QUIT;
        }
        else
        {
            TRACE_OUT(("Cached MEMBLT targetted at (%d,%d)(%d,%d)",
                           pNewOrder->OrderHeader.Common.rcsDst.left,
                           pNewOrder->OrderHeader.Common.rcsDst.top,
                           pNewOrder->OrderHeader.Common.rcsDst.right,
                           pNewOrder->OrderHeader.Common.rcsDst.bottom ));
        }
    }

    if (ORDER_IS_SCRBLT(pNewOrder))
    {
        //
        //
        // Handle Screen to Screen (SS) bitblts.
        //
        // The basic plan
        // --------------
        //
        // If the source of a screen to screen blt intersects with the
        // current SDA then we have to do some additional work because all
        // orders are always executed before the SDA is copied.  This means
        // that the data within the SDA will not be available at the time
        // we want to do the SS blt.
        //
        // In this situation we adjust the SS blt to remove all overlap
        // from the src rectangle.  The destination rectangle is adjusted
        // accordingly.  The area removed from the destination rectangle is
        // added into the SDA.
        //
        //
        TRACE_OUT(("Handle SS blt(%lx)", pNewOrder));

        //
        // Make the order non-spoilable because we don't want the adding
        // of screen data to delete the order.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags &= ~OF_SPOILABLE;

        //
        // Calculate the src rect.
        //
        SrcRect.left = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
        SrcRect.right = SrcRect.left +
                        ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nWidth - 1;
        SrcRect.top = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;
        SrcRect.bottom = SrcRect.top +
                       ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nHeight - 1;

        //
        //
        // ORIGINAL SCRBLT SCHEME
        // ----------------------
        //
        // If the source rectangle intersects the current Screen Data Area
        // (SDA) then the src rectangle is modified so that no there is no
        // intersection with the SDA, and the dst rectangle adjusted
        // accordingly (this is the theory - in practice the operation
        // remains the same and we just adjust the dst clip rectangle).
        // The destination area that is removed is added into the SDA.
        //
        // The code works, but can result in more screen data being sent
        // than is required.
        //
        // e.g.
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The bottom edge of the blt is trimmed off, and the corresponding
        // destination area added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //                  xxxxxx
        //
        //
        //
        // NEW SCRBLT SCHEME
        // ------------------
        //
        // The new scheme does not modify the blt rectangles, and just
        // maps the SDA overlap to the destination rect and adds that
        // area back into the SDA.
        //
        // e.g. (as above)
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The blt operation remains the same, but the overlap area is
        // mapped to the destination rectangle and added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DxDDDD
        //
        //
        // This scheme results in a smaller SDA area. However, this scheme
        // does blt potentially invalid data to the destination - which
        // may briefly be visible at the remote machine (because orders
        // are replayed before Screen Data). This has not (yet) proved to
        // be a problem.
        //
        // The main benefit of the new scheme is when scrolling an area
        // that includes a small SDA.
        //
        //                                         new         old
        //                                        scheme      scheme
        //
        //     AAAAAAAA                          AAAAAAAA    AAAAAAAA
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAAAAAA  scroll up 3 times ->    AAAxAAAA    xxxxxxxx
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAxAAAA                          AAAxAAAA    xxxxxxxx
        //
        //
        //
        if (!gotBounds)
        {
            //
            // Get the driver's current bounds.
            //
            BA_CopyBounds(SDARects, &cBounds, FALSE);
        }

        //
        // Now get any bounds which the share core is currently processing.
        // We have to include these bounds when we are doing the above
        // processing to avoid a situation where the core grabs the screen
        // data from the source of a ScrBlt after the source has been
        // updated by another order.
        //
        // e.g.  If there is no driver SDA, but the core is processing the
        // area marked 'c'...
        //
        // If we ignore the core SDA, we queue a ScrBlt order which does
        // the following.
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DDDDDD
        //      SccccS      DDDDDD
        //      SSSSSS      DDDDDD
        //
        // However, if another order (marked 'N') is accumulated before
        // the core grabs the SDA, we end up with the shadow doing the
        // following
        //
        //      SSSSSS      DDDDDD
        //      ScNNcS  ->  DDNNDD
        //      ScNNcS      DDNNDD
        //      SSSSSS      DDDDDD
        //
        // i.e. the new order gets copied to the destination of the ScrBlt.
        // So, the ScrBlt order must be processed as
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DxxxxD
        //      SccccS      DxxxxD
        //      SSSSSS      DDDDDD
        //
        //
        BA_QuerySpoilingBounds(&SDARects[cBounds], &spoilingBounds);
        totalBounds = cBounds + spoilingBounds;

        //
        //
        // This is the new SCRBLT handler.
        //
        //
        for (i = 0; i < totalBounds ; i++)
        {
            if ( (SrcRect.left >= SDARects[i].left) &&
                 (SrcRect.right <= SDARects[i].right) &&
                 (SrcRect.top >= SDARects[i].top) &&
                 (SrcRect.bottom <= SDARects[i].bottom) )
            {
                //
                // The src of the SS blt is completely within the SDA.  We
                // must add in the whole destination rectangle into the SDA
                // and spoil the SS blt.
                //
                TRACE_OUT(("SS blt src within SDA - spoil it"));

                RECT_FROM_TSHR_RECT16(&tmpRect,
                                        pNewOrder->OrderHeader.Common.rcsDst);
                OA_DDFreeOrderMem(pNewOrder);
                BA_AddScreenData(&tmpRect);
                DC_QUIT;
            }

            //
            // Intersect the src rect with the SDA rect.
            //
            IntersectedSrcRect.left = max( SrcRect.left,
                                              SDARects[i].left );
            IntersectedSrcRect.right = min( SrcRect.right,
                                               SDARects[i].right );
            IntersectedSrcRect.top = max( SrcRect.top,
                                             SDARects[i].top );
            IntersectedSrcRect.bottom = min( SrcRect.bottom,
                                                SDARects[i].bottom );


            dx = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nLeftRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
            dy = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nTopRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;

            InvalidDstRect.left   = IntersectedSrcRect.left + dx;
            InvalidDstRect.right  = IntersectedSrcRect.right + dx;
            InvalidDstRect.top    = IntersectedSrcRect.top + dy;
            InvalidDstRect.bottom = IntersectedSrcRect.bottom + dy;

            //
            // Intersect the invalid destination rectangle with the
            // destination clip rectangle.
            //
            InvalidDstRect.left = max(
                                InvalidDstRect.left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                InvalidDstRect.right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                InvalidDstRect.top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                InvalidDstRect.bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                BA_AddScreenData(&InvalidDstRect);
            }

        } // for (i = 0; i < totalBounds ; i++)

        //
        // Make the order spoilable again (this assumes that all SS blts
        // are spoilable.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILABLE;

    } // if (ORDER_IS_SCRBLT(pNewOrder))

    else if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_DESTROP) != 0)
    {
        //
        // This is the case where the output of the order depends on the
        // existing contents of the target area (e.g.  an invert).
        //
        // What we have to do here is to add any parts of the destination
        // of this order which intersect the SDA which the share core is
        // processing to the driver SDA.  The reason for this is the same
        // as the SCRBLT case - the share core may grab the data from the
        // screen after we have applied this order (e.g.  after we have
        // inverted an area of the screen), then send the order as well
        // (re-inverting the area of the screen).
        //
        // Note that we only have to worry about the SDA which the share
        // core is processing - we can ignore the driver's SDA.
        //
        TRACE_OUT(("Handle dest ROP (%#.8lx)", pNewOrder));

        BA_QuerySpoilingBounds(SDARects, &spoilingBounds);
        for (i = 0; i < spoilingBounds ; i++)
        {
            //
            // Intersect the dest rect with the share core SDA rect.
            //
            InvalidDstRect.left = max(
                                SDARects[i].left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                SDARects[i].right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                SDARects[i].top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                SDARects[i].bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                TRACE_OUT(("Adding to SDA (%d,%d) (%d,%d)",
                             InvalidDstRect.left,
                             InvalidDstRect.top,
                             InvalidDstRect.right,
                             InvalidDstRect.bottom));
                BA_AddScreenData(&InvalidDstRect);
            }
        }
    }

    //
    // Add the new order to the end of the Order List.
    //
    OADDAppendToOrderList(lpoaShared, pNewOrder);
    TRACE_OUT(("Append order(%lx) to list", pNewOrder));

    //
    // Now see if this order spoils any existing orders
    //
    if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILER) != 0)
    {
        //
        // Its a spoiler, so try to spoil with it.
        //
        // We have to pass in the bounding rectangle of the order, and the
        // first order to try to spoil to OADDSpoilFromOrder.  The first
        // order to try to spoil is the one before the new order.
        //
        RECT_FROM_TSHR_RECT16(&tmpRect,
                                pNewOrder->OrderHeader.Common.rcsDst);

        pTmpOrder = COM_BasedListPrev(&lpoaShared->orderListHead, pNewOrder,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        OADDSpoilFromOrder(lpoaShared, pTmpOrder, &tmpRect);
    }

    //
    // This is where the Win95 product would call DCS_TriggerEarlyTimer.
    //

DC_EXIT_POINT:
    OA_FST_STOP_WRITING;
    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDAddOrder);
}

//
//
// FUNCTION: OA_DDAllocOrderMem
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our own private
// Order Heap.
//
// Allocates any Additional Order Memory from global memory.  A pointer to
// the Additional Order Memory is stored within the allocated order's
// header (pOrder->OrderHeader.pAdditionalOrderData).
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated from Global Memory.  If this parameter is zero no
// additional order memory is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OA_DDAllocOrderMem(UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength)
{
    LPINT_ORDER  pOrder = NULL;
    LPINT_ORDER  pFirstOrder;
    LPINT_ORDER  pTailOrder;
    RECT      tferRect;
    int     targetSize;
    UINT    moveOffset;
    UINT    moveBytes;
    LPINT_ORDER  pColorTableOrder = NULL;
    LPBYTE     pNextOrderPos;
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDAllocOrderMem);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // PM Performance
    //
    // Although turning order accumulation off does clear the pipe, ready
    // for us to get the screendata over the wire as soon as we can, it
    // actually hinders end-user responsiveness because they see a longer
    // interval when nothing is happening, rather than getting feedback
    // that we are busy and the whole thing taking longer!
    //
    // So, what we do when we fill up the order buffer is we discard half
    // the orders in the buffer, adding them to the screendata.  In this
    // way we will always keep between 50 and 100% of the orders for the
    // final updates to the window, which hopefully will be what the user
    // really wants to see.
    //
    // If the orders keep coming then we will keep on accumulating some,
    // sending them, discarding others until things quiet down, at which
    // point we will flush out our order buffer.
    //
    // When we come to flush the order buffer we also spoil the early ones
    // against screendata, so that we only have the final set of orders to
    // replay.  We control the size of this final non-spoiled set depending
    // on whether we are running over a high or low speed connection.
    // Also, if we did not encounter any back pressure during the session
    // then we do not purge any orders at all, preferring to send
    // everything we possibly can as orders.
    //
    // Note that this approach assumes that we do not spoil all orders
    // against screendata on the fly because that leads to us generally
    // sending out-of-data orders followed by up-to-date screendata, which
    // is exactly what we do not want to see.
    //
    //

    //
    // First check that we have not already exceeded our high water mark
    // recommended by flow control.  If we have then purge half the queue
    // so we have space to accumulate the later, more valuable, orders
    //
    // Note that this does not guarantee that we will have less orders
    // accumulated than the limit set by flow control.  However, if enough
    // orders are generated, we will come through this branch on each order
    // and finally reduce to below the imposed limit.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    if (g_oaPurgeAllowed && (lpoaShared->totalOrderBytes >
        (DWORD)(g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)))
    {
        RECT        aRects[BA_NUM_RECTS];
        UINT        numRects;
        UINT        i;

        WARNING_OUT(("Purging orders; total 0x%08x is greater than heap 0x%08x",
            lpoaShared->totalOrderBytes,
            (g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)));

        //
        //
        // If we need to make room for the new order then purge half the
        // current queue.  We do this so we end up with the most recent
        // orders on the queue, rather than the oldest.
        //
        SHM_CheckPointer(&lpoaShared->totalOrderBytes);
        targetSize = lpoaShared->totalOrderBytes / 2;
        TRACE_OUT(("Target size %ld", targetSize));

        //
        // Iterate through the list until we have found the first order
        // beyond the limit to be destroyed.  Once we have got this order,
        // we can shuffle the list over the useless orders.
        //
        SHM_CheckPointer(&lpoaShared->orderListHead);
        pOrder = COM_BasedListFirst(&lpoaShared->orderListHead,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        pTailOrder = (LPINT_ORDER)COM_BasedPrevListField(&lpoaShared->orderListHead);

        //
        // If we hit this condition, we have to have at least one order
        // pending, so these both must be non NULL.
        //
        SHM_CheckPointer(pOrder);
        SHM_CheckPointer(pTailOrder);

        TRACE_OUT(("Order 0x%08lx, tail 0x%08lx", pOrder, pTailOrder));

        //
        // Disable spoiling of existing orders by screen data while we do
        // the purge otherwise we may try to spoil an order which we are
        // purging !
        //
        g_baSpoilByNewSDAEnabled = FALSE;

        while ((pOrder != NULL) && (targetSize > 0))
        {
            //
            // Can't check at end; COM_BasedListNext may return NULL and
            // SHM_CheckPointer doesn't like that.
            //
            SHM_CheckPointer(pOrder);

            //
            // Check to see if this is an internal color table order.  If
            // it is, the OF_INTERNAL flag will be set.
            //
            // MemBlt orders rely on being preceeded by a color table order
            // to set up the colors correctly.  If we purge all the color
            // table orders, the following Mem(3)Blts will get the wrong
            // colors.  So, we have to keep track of the last color table
            // order to be purged and then add it back into the order heap
            // later.
            //
            if ((pOrder->OrderHeader.Common.fOrderFlags & OF_INTERNAL) != 0)
            {
                TRACE_OUT(("Found color table order at %#.8lx", pOrder));
                pColorTableOrder = pOrder;
            }
            else
            {
                //
                // Add the order to the Screen Data Area
                //
                TRACE_OUT(("Purging orders. Add rect to SDA (%d,%d)(%d,%d)",
                             pOrder->OrderHeader.Common.rcsDst.left,
                             pOrder->OrderHeader.Common.rcsDst.top,
                             pOrder->OrderHeader.Common.rcsDst.right,
                             pOrder->OrderHeader.Common.rcsDst.bottom));

                RECT_FROM_TSHR_RECT16(&tferRect,
                                        pOrder->OrderHeader.Common.rcsDst);
                BA_AddScreenData(&tferRect);
            }

            //
            // Keep track of how much data still needs removing.
            //
            targetSize                 -= INT_ORDER_SIZE(pOrder);
            lpoaShared->totalHeapOrderBytes -= INT_ORDER_SIZE(pOrder);
            lpoaShared->totalOrderBytes     -= MAX_ORDER_SIZE(pOrder);

            //
            // If the order is a Mem(3)Blt, we have to tell SBC that we are
            // getting rid of it.
            //
            if (ORDER_IS_MEMBLT(pOrder) || ORDER_IS_MEM3BLT(pOrder))
            {
                SBC_DDOrderSpoiltNotification(pOrder);
            }

            //
            // Get the next order to be removed.
            //
            pOrder = COM_BasedListNext(&lpoaShared->orderListHead,
                pOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }

        TRACE_OUT(("Stopped at order %#.8lx", pOrder));

        //
        // Orders have been transferred to SDA, so now we have to
        //   - move the last purged color table order (if there is one) to
        //     the start of the order heap
        //   - shuffle up the heap
        //   - reset the pointers.
        //
        // pOrder points to the first non-purged order.
        //
        if (pOrder != NULL)
        {
            SHM_CheckPointer(&lpoaShared->orderHeap);
            SHM_CheckPointer(&lpoaShared->orderListHead);

            pNextOrderPos = lpoaShared->orderHeap;

            //
            // If we purged (at least) one color table order, move the last
            // color table order to the start of the order heap.
            //
            if (pColorTableOrder != NULL)
            {
                TRACE_OUT(("Moving color table from %#.8lx to start",
                             pColorTableOrder));

                RtlMoveMemory(pNextOrderPos, pColorTableOrder,
                              INT_ORDER_SIZE(pColorTableOrder));

                pColorTableOrder        = (LPINT_ORDER)pNextOrderPos;
                lpoaShared->totalHeapOrderBytes
                                       += INT_ORDER_SIZE(pColorTableOrder);
                lpoaShared->totalOrderBytes += MAX_ORDER_SIZE(pColorTableOrder);
                pNextOrderPos          += INT_ORDER_SIZE(pColorTableOrder);

                //
                // Chain the order into the start of the order list.  Just
                // do the pointers to and from the list head for now, we
                // will do the rest later.
                //
                lpoaShared->orderListHead.next =
                   PTRBASE_TO_OFFSET(pColorTableOrder, &lpoaShared->orderListHead);

                pColorTableOrder->OrderHeader.list.prev =
                   PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pColorTableOrder);
            }

            //
            // Move the heap up to the top of the buffer.  The following
            // diagram illustrates how the order heap is split up at the
            // moment.
            //
            //              OA_SHM_NEXTORDER
            // |<>|
            //
            //         moveOffset          moveBytes
            //     |<>|<>|
            //
            // ͻ
            //                                                       
            //        purged           remaining          unused     
            //        orders           orders                        
            //                                                      
            // ͼ
            // ^  ^                 ^
            //                    
            //                    
            //                     pOrder
            //   
            //    pNextOrderPos
            //  
            //   color table order
            // 
            //  lpoaShared->orderHeap (pColorTableOrder)
            //
            // If there is no color table order, pNextOrderPos is equal to
            // lpoaShared->orderHeap.
            //
            // moveOffset is the number of bytes to move the remaining
            // orders by.
            //
            // moveBytes is the number of bytes to be moved.
            //
            //
            moveOffset = (UINT)((UINT_PTR)pOrder - (UINT_PTR)pNextOrderPos);
            moveBytes  = (UINT)(lpoaShared->nextOrder
                       - moveOffset
                       - (pNextOrderPos - lpoaShared->orderHeap));

            TRACE_OUT(("Moving %d bytes", moveBytes));

            RtlMoveMemory(pNextOrderPos, pOrder, moveBytes);

            //
            // Update the head and tail pointers to reflect their new
            // positions.
            //
            pFirstOrder = (LPINT_ORDER)pNextOrderPos;
            pTailOrder  = (LPINT_ORDER)((LPBYTE)pTailOrder - moveOffset);
            SHM_CheckPointer(pFirstOrder);
            SHM_CheckPointer(pTailOrder);

            TRACE_OUT(("New first unpurged %#.8lx, tail %#.8lx",
                         pFirstOrder,
                         pTailOrder));

            //
            // Since the offsets are relative to the order pointer, we only
            // need to modify the start and end offsets.
            //
            // Unfortunately, the possibility of a color table order at the
            // start of the heap complicates the chaining of pFirstOrder.
            // If there is a color table order, we chain pFirstOrder to the
            // color table order, otherwise we chain it to the start of the
            // order list.
            //
            lpoaShared->orderListHead.prev =
                         PTRBASE_TO_OFFSET(pTailOrder, &lpoaShared->orderListHead);
            pTailOrder->OrderHeader.list.next =
                         PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pTailOrder);

            if (pColorTableOrder != NULL)
            {
                pColorTableOrder->OrderHeader.list.next =
                             PTRBASE_TO_OFFSET(pFirstOrder, pColorTableOrder);
                pFirstOrder->OrderHeader.list.prev =
                             PTRBASE_TO_OFFSET(pColorTableOrder, pFirstOrder);
            }
            else
            {
                lpoaShared->orderListHead.next =
                        PTRBASE_TO_OFFSET(pFirstOrder, &lpoaShared->orderListHead);
                pFirstOrder->OrderHeader.list.prev =
                        PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pFirstOrder);
            }

            //
            // Sort out where the next order to be allocated will go
            //
            lpoaShared->nextOrder -= moveOffset;
        }
        else
        {
            //
            // No orders left - this happens if we've had lots of spoiling.
            // We have now cleared out all the valid orders so let's
            // re-initialise the heap for next time.
            //
            OA_DDResetOrderList();
        }

        //
        // Now re-enable the spoiling of orders by SDA.
        //
        g_baSpoilByNewSDAEnabled = TRUE;

        WARNING_OUT(("Purged orders, total is now 0x%08x", lpoaShared->totalOrderBytes));

        //
        // Lastly, spoil the remaining orders by the screen data.
        // If we've gotten this far, there's a lot of data being sent
        // and/or we're slow.  So nuke 'em.
        //
        BA_CopyBounds(aRects, &numRects, FALSE);

        for (i = 0; i < numRects; i++)
        {
            OA_DDSpoilOrdersByRect(aRects+i);
        }

        WARNING_OUT(("Spoiled remaining orders by SDA, total is now 0x%08x", lpoaShared->totalOrderBytes));

        TRACE_OUT(("Next 0x%08lx", lpoaShared->nextOrder));
        TRACE_OUT(("Head 0x%08lx", lpoaShared->orderListHead.next));
        TRACE_OUT(("Tail 0x%08lx", lpoaShared->orderListHead.prev));
        TRACE_OUT(("Total heap bytes 0x%08lx", lpoaShared->totalHeapOrderBytes));
        TRACE_OUT(("Total order bytes 0x%08lx", lpoaShared->totalOrderBytes));
    }

    pOrder = OADDAllocOrderMemInt(lpoaShared, cbOrderDataLength,
                                cbAdditionalOrderDataLength);
    if ( pOrder != NULL )
    {
        //
        // Update the count of total order data.
        //
        SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
        lpoaShared->totalHeapOrderBytes       += sizeof(INT_ORDER_HEADER)
                                         +  cbOrderDataLength;

        SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
        lpoaShared->totalAdditionalOrderBytes += cbAdditionalOrderDataLength;

    }
    TRACE_OUT(("Alloc order, addr %lx, size %u", pOrder,
                                                   cbOrderDataLength));

    OA_SHM_STOP_WRITING;
    DebugExitPVOID(OA_DDAllocOrderMem, pOrder);
    return(pOrder);
}

//
//
// FUNCTION: OA_DDFreeOrderMem
//
//
// DESCRIPTION:
//
// Frees order memory from our own private heap.
// Frees any Additional Order Memory associated with this order.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDFreeOrderMem(LPINT_ORDER pOrder)
{
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDFreeOrderMem);

    ASSERT(pOrder);

    lpoaShared = OA_SHM_START_WRITING;

    TRACE_OUT(("Free order %lx", pOrder));

    //
    // Update the data totals.
    //
    SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
    lpoaShared->totalHeapOrderBytes -= (sizeof(INT_ORDER_HEADER)
                              + pOrder->OrderHeader.Common.cbOrderDataLength);

    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    lpoaShared->totalAdditionalOrderBytes -=
                              pOrder->OrderHeader.cbAdditionalOrderDataLength;

    //
    // Do the work.
    //
    OADDFreeOrderMemInt(lpoaShared, pOrder);

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDFreeOrderMem);
}


//
//
// FUNCTION: OA_DDResetOrderList
//
//
// DESCRIPTION:
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
//
//
// PARAMETERS:
//
// None.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDResetOrderList(void)
{
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDResetOrderList);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // First free all the orders on the list.
    //
    OADDFreeAllOrders(lpoaShared);

    //
    // Ensure that the list pointers are NULL.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    if ((lpoaShared->orderListHead.next != 0) || (lpoaShared->orderListHead.prev != 0))
    {
        ERROR_OUT(("Non-NULL list pointers (%lx)(%lx)",
                       lpoaShared->orderListHead.next,
                       lpoaShared->orderListHead.prev));

        SHM_CheckPointer(&lpoaShared->orderListHead);
        COM_BasedListInit(&lpoaShared->orderListHead);
    }

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDResetOrderList);
}



//
// OA_DDSyncUpdatesNow
//
// Called when a sync operation is required.
//
// Discards all outstanding orders.
//
void  OA_DDSyncUpdatesNow(void)
{
    DebugEntry(OA_SyncUpdatesNow);

    OADDFreeAllOrders(g_poaData[g_asSharedMemory->displayToCore.currentBuffer]);

    DebugExitVOID(OA_DDSyncUpdatesNow);
}


//
//
// OA_DDRemoveListOrder(..)
//
// Removes the specified order from the Order List by marking it as spoilt.
//
// Returns:
//   Pointer to the order following the removed order.
//
//
LPINT_ORDER  OA_DDRemoveListOrder(LPINT_ORDER pCondemnedOrder)
{
    LPINT_ORDER pSaveOrder;
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDRemoveListOrder);

    TRACE_OUT(("Remove list order (%lx)", pCondemnedOrder));

    lpoaShared = OA_SHM_START_WRITING;

    SHM_CheckPointer(pCondemnedOrder);

    //
    // Check for a valid order.
    //
    if (pCondemnedOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT)
    {
        TRACE_OUT(("Invalid order"));
        DC_QUIT;
    }

    //
    // Get the offset value of this order.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);

    //
    // Mark the order as spoilt.
    //
    pCondemnedOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILT;

    //
    // Update the count of bytes currently in the Order List.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes -= (UINT)MAX_ORDER_SIZE(pCondemnedOrder);

    //
    // SAve the order so we can remove it from the linked list after having
    // got the next element in the chain.
    //
    pSaveOrder = pCondemnedOrder;

    //
    // Return the next order in the list.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);

    pCondemnedOrder = COM_BasedListNext(&lpoaShared->orderListHead,
        pCondemnedOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    if (pSaveOrder == pCondemnedOrder)
    {
        ERROR_OUT(("Order list has gone circular !"));
    }

    //
    // Delete the unwanted order from the linked list.
    //
    COM_BasedListRemove(&pSaveOrder->OrderHeader.list);

    //
    // Check that the list is still consistent with the total number of
    // order bytes.
    //
    if ( (lpoaShared->orderListHead.next != 0) &&
         (lpoaShared->orderListHead.prev != 0) &&
         (lpoaShared->totalOrderBytes    == 0) )
    {
        ERROR_OUT(("List head wrong: %ld %ld", lpoaShared->orderListHead.next,
                                                 lpoaShared->orderListHead.prev));
        COM_BasedListInit(&lpoaShared->orderListHead);
        pCondemnedOrder = NULL;
    }

DC_EXIT_POINT:
    OA_SHM_STOP_WRITING;

    DebugExitPVOID(OA_DDRemoveListOrder, pCondemnedOrder);
    return(pCondemnedOrder);
}



//
// OA_DDSpoilOrdersByRect - see oa.h
//
void  OA_DDSpoilOrdersByRect(LPRECT pRect)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER  pOrder;

    DebugEntry(OA_DDSpoilOrdersByRect);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // We want to start spoiling from the newest order i.e.  the one at the
    // end of the order list.
    //
    pOrder = COM_BasedListLast(&lpoaShared->orderListHead,
        FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    if (pOrder != NULL)
    {
        OADDSpoilFromOrder(lpoaShared, pOrder, pRect);
    }

    OA_SHM_STOP_WRITING;

    DebugExitVOID(OA_DDSpoilOrdersByRect);
}





//
//
// OADDAppendToOrderList(..)
//
// Commits an allocated order to the end of the Order List.  The order must
// NOT be freed once it has been added.  The whole list must be invalidated
// to free the committed orders.
//
//
void  OADDAppendToOrderList(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pNewOrder)
{
    DebugEntry(OADDAppendToOrderList);

    //
    // Chain entry is already set up so all we do is keep track of
    // committed orders.
    //

    //
    // Store the total number of order bytes used.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes += (UINT)MAX_ORDER_SIZE(pNewOrder);

    DebugExitVOID(OADDAppendToOrderList);
}


//
//
// FUNCTION: OADDAllocOrderMemInt
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our order heap.
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated.  If this parameter is zero no additional order memory
// is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OADDAllocOrderMemInt
(
    LPOA_SHARED_DATA    lpoaShared,
    UINT                cbOrderDataLength,
    UINT                cbAdditionalOrderDataLength
)
{
    LPINT_ORDER   pOrder = NULL;
    UINT       cbOrderSize;

    DebugEntry(OADDAllocOrderMemInt);

    //
    // If the additional data will take us over our Additional Data Limit
    // then fail the memory allocation.
    //
    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    if ((lpoaShared->totalAdditionalOrderBytes + cbAdditionalOrderDataLength) >
                                                    MAX_ADDITIONAL_DATA_BYTES)
    {
        TRACE_OUT(("Hit Additional Data Limit, current %lu addint %u",
                     lpoaShared->totalAdditionalOrderBytes,
                     cbAdditionalOrderDataLength));
        DC_QUIT;
    }

    //
    // Calculate the number of bytes we need to allocate (including the
    // order header).  Round up to the nearest 4 bytes to keep the 4 byte
    // alignment for the next order.
    //
    cbOrderSize = sizeof(INT_ORDER_HEADER) + cbOrderDataLength;
    cbOrderSize = (cbOrderSize + 3) & 0xFFFFFFFC;

    //
    // Make sure we don't overrun our heap limit
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    if (lpoaShared->nextOrder + cbOrderSize > OA_HEAP_MAX)
    {
        TRACE_OUT(("Heap limit hit"));
        DC_QUIT;
    }

    //
    // Construct a far pointer to the allocated memory, and fill in the
    // length field in the Order Header.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);
    pOrder = (LPINT_ORDER)(lpoaShared->orderHeap + lpoaShared->nextOrder);
    pOrder->OrderHeader.Common.cbOrderDataLength = (TSHR_UINT16)cbOrderDataLength;

    //
    // Update the order header to point to the next section of free heap.
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    lpoaShared->nextOrder += cbOrderSize;

    //
    // Allocate any Additional Order Memory from Global Memory.
    //
    if (cbAdditionalOrderDataLength > 0)
    {
        //
        // Make sure we don't overrun our heap limit
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        if (lpoaShared->nextOrder + cbAdditionalOrderDataLength > OA_HEAP_MAX)
        {
            TRACE_OUT(("Heap limit hit for additional data"));

            //
            // Clear the allocated order and quit.
            //
            SHM_CheckPointer(&lpoaShared->nextOrder);
            lpoaShared->nextOrder -= cbOrderSize;
            pOrder            = NULL;
            DC_QUIT;
        }

        //
        // Store the space for the additional data.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        pOrder->OrderHeader.additionalOrderData         = lpoaShared->nextOrder;
        pOrder->OrderHeader.cbAdditionalOrderDataLength =
                                                  (WORD)cbAdditionalOrderDataLength;

        //
        // Update the next order pointer to point to the next 4-byte
        // boundary.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder += cbAdditionalOrderDataLength + 3;
        lpoaShared->nextOrder &= 0xFFFFFFFC;
    }
    else
    {
        pOrder->OrderHeader.additionalOrderData         = 0;
        pOrder->OrderHeader.cbAdditionalOrderDataLength = 0;
    }

    //
    // Create the chain entry.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    COM_BasedListInsertBefore(&lpoaShared->orderListHead, &pOrder->OrderHeader.list);

DC_EXIT_POINT:
    DebugExitPVOID(OADDAllocOrderMemInit, pOrder);
    return(pOrder);
}


//
//
// FUNCTION: OADDFreeOrderMemInt
//
//
// DESCRIPTION:
//
// Frees order memory from our orders heap.  Frees any Additional Order
// Memory associated with this order.  This must NOT be used on an order
// that has been committed to the order list.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OADDFreeOrderMemInt(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder)
{
    LPINT_ORDER pOrderTail;

    DebugEntry(OADDFreeOrderMemInt);

    //
    // The order heap is real a misnomer.  We know that the memory is only
    // allocated in a purely sequential manner and deallocated as one large
    // lump of memory.
    //
    // So we do not need to implement a full memory heap allocation
    // mechanism.  Instead, we just need to keep track of where the
    // previous high water mark was before this order was freed.
    //

    //
    // Find the tail of the current chain.
    //
    pOrderTail = COM_BasedListLast(&lpoaShared->orderListHead, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    SHM_CheckPointer(pOrderTail);

    //
    // We wont necessarily be freeing the last item in the order heap.
    //
    if (pOrder == pOrderTail)
    {
        //
        // This is the last item in the heap, so we can set the pointer to
        // the next order to be used back to the start of the order being
        // freed.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder = (LONG)((LPBYTE)pOrder -
                                      (LPBYTE)(lpoaShared->orderHeap));
    }
    else
    {
        //
        // This is not the last item in the heap - we must not reset the
        // pointer to the next item to be used.
        //
        TRACE_OUT(("Not resetting next order (not last item in heap)"));
    }

    //
    // Delete the item from the chain.
    //
    COM_BasedListRemove(&pOrder->OrderHeader.list);

    DebugExitVOID(OADDFreeOrderMemInt);
}


//
// OADDFreeAllOrders
//
// Free the all the individual orders on the orders list, without
// discarding the list itself.
//
void  OADDFreeAllOrders(LPOA_SHARED_DATA lpoaShared)
{
    DebugEntry(OADDFreeAllOrders);

    //
    // Simply clear the list head.
    //
    COM_BasedListInit(&lpoaShared->orderListHead);
    SHM_CheckPointer(&lpoaShared->orderListHead);

    lpoaShared->totalHeapOrderBytes       = 0;
    lpoaShared->totalOrderBytes           = 0;
    lpoaShared->totalAdditionalOrderBytes = 0;
    lpoaShared->nextOrder                 = 0;

    DebugExitVOID(OADDFreeAllOrders);
}


//
//
// OADDOrderIsValid(..)
//
// Determines if a pointer points to a valid order.
//
// Returns:
//   TRUE if valid order, FALSE if invalid.
//
//
BOOL  OADDOrderIsValid(LPINT_ORDER pOrder)
{
    BOOL rc;

    DebugEntry(OADDOrderIsValid);

    //
    // Check the order is not already spoilt
    //
    rc = ((pOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT) == 0);

    DebugExitBOOL(OADDOrderIsValid, rc);
    return(rc);
}


BOOL  OADDCompleteOverlapRect(LPTSHR_RECT16 prcsSrc, LPRECT   prcsOverlap)
{
    //
    // Return TRUE if the source is completely enclosed by the overlap
    // rectangle.
    //
    return( (prcsSrc->left >= prcsOverlap->left) &&
            (prcsSrc->right <= prcsOverlap->right) &&
            (prcsSrc->top >= prcsOverlap->top) &&
            (prcsSrc->bottom <= prcsOverlap->bottom) );
}


//
// Name:      OADDSpoilFromOrder
//
// Purpose:   Remove any orders from the order heap which should be spoiled
//            by a given rectangle..
//
// Returns:   Nothing
//
// Params:    IN  pTargetOrder - Pointer to the first order to try to
//                               spoil.
//            IN  pRect        - Pointer to the spoiling rectangle.
//
// Operation: pTargetOrder may be spoiled by this function, so be careful
//            on return.
//
void  OADDSpoilFromOrder
(
    LPOA_SHARED_DATA    lpoaShared,
    LPINT_ORDER         pTargetOrder,
    LPRECT              pSpoilRect
)
{
    UINT      nonProductiveScanDepth = 0;
    UINT      scanExitDepth;
    BOOL      reachedBlocker = FALSE;

    DebugEntry(OADDSpoilFromOrder);

    TRACE_OUT(("Spoiling rect is {%d, %d, %d, %d}",
                 pSpoilRect->left,
                 pSpoilRect->top,
                 pSpoilRect->right,
                 pSpoilRect->bottom));

    //
    // Work out how deep we will scan if the spoiling is non-productive.
    // We go further for bigger orders over PSTN.  (ie Irrespective of the
    // bandwidth we do not want to do much work when the app is blasting
    // out a lot of single pel orders!)
    //
    if (((pSpoilRect->right - pSpoilRect->left) < FULL_SPOIL_WIDTH) &&
        ((pSpoilRect->bottom - pSpoilRect->top) < FULL_SPOIL_HEIGHT))
    {
        TRACE_OUT(("Small order so reducing spoil depth"));
        scanExitDepth = OA_FAST_SCAN_DEPTH;
    }
    else
    {
        //
        // Use the current default scan depth (this is based on the
        // current network throughput).
        //
        scanExitDepth = (g_oaFlow == OAFLOW_FAST) ?
            OA_FAST_SCAN_DEPTH : OA_SLOW_SCAN_DEPTH;
    }

    //
    // Loop backwards from the base order until we have one of the
    // following occurs.
    //   - We spoil all the preceeding orders.
    //   - We reach a blocker which we can't spoil.
    //   - We find scanExitDepth orders which we can't spoil.
    //
    while ((pTargetOrder != NULL)
             && !reachedBlocker
             && (nonProductiveScanDepth < scanExitDepth))
    {
        //
        // We do not exit immediately when we reach a blocker because it is
        // possible that we will spoil it.  If we do spoil it, then we can
        // quite happily try spoiling the orders which preceed it.
        //
        // So, just set a flag here which we will reset if we spoil the
        // order.
        //
        reachedBlocker =
           ((pTargetOrder->OrderHeader.Common.fOrderFlags & OF_BLOCKER) != 0);

        //
        // Only try to spoil spoilable orders.
        //
        if ((pTargetOrder->OrderHeader.Common.fOrderFlags &
                                                 OF_SPOILABLE) != 0)
        {
            if (OADDCompleteOverlapRect(
                        &pTargetOrder->OrderHeader.Common.rcsDst, pSpoilRect))
            {
                //
                // The order can be spoilt.  If the order is a MemBlt or a
                // Mem3Blt, we have to notify SBC to allow it to free up
                // associated data.
                //
                if (ORDER_IS_MEMBLT(pTargetOrder) ||
                    ORDER_IS_MEM3BLT(pTargetOrder))
                {
                    SBC_DDOrderSpoiltNotification(pTargetOrder);
                }

                TRACE_OUT(("Spoil by order (%hd, %hd) (%hd, %hd)",
                             pTargetOrder->OrderHeader.Common.rcsDst.left,
                             pTargetOrder->OrderHeader.Common.rcsDst.top,
                             pTargetOrder->OrderHeader.Common.rcsDst.right,
                             pTargetOrder->OrderHeader.Common.rcsDst.bottom));

                pTargetOrder = OA_DDRemoveListOrder(pTargetOrder);

                //
                // Reset the blocker flag - we spoiled the order, so if it
                // was a blocker we can now try to spoil earlier orders.
                //
                reachedBlocker = FALSE;
            }
            else
            {
                nonProductiveScanDepth++;
            }
        }
        else
        {
            nonProductiveScanDepth++;
        }

        //
        // Get the previous order in the list.  We have to be careful
        // because we may have just removed the last item in the list, in
        // which case pTargetOrder will be NULL.
        //
        if (pTargetOrder == NULL)
        {
            pTargetOrder = COM_BasedListLast(&lpoaShared->orderListHead,
                FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
        else
        {
            pTargetOrder = COM_BasedListPrev(&lpoaShared->orderListHead,
                pTargetOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
    }

    DebugExitVOID(OADDSpoilFromOrder);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\het.c ===
#include "precomp.h"


//
// HET.C
// Hosted Entity Tracker, NT Display Driver version
//
// Copyright(c)Microsoft 1997-
//

#include <limits.h>

//
// HET_DDTerm()
//
void HET_DDTerm(void)
{
    LPHET_WINDOW_MEMORY pMem;

    DebugEntry(HET_DDTerm);

    //
    // Clean up any window/graphics tracking stuff
    //
    g_hetDDDesktopIsShared = FALSE;
    HETDDViewing(NULL, FALSE);
    HETDDUnshareAll();


    //
    // Loop through the memory list blocks, freeing each.  Then clear
    // the Window and Free lists.
    //                           
    while (pMem = COM_BasedListFirst(&g_hetMemoryList, FIELD_OFFSET(HET_WINDOW_MEMORY, chain)))
    {
        TRACE_OUT(("HET_DDTerm:  Freeing memory block %lx", pMem));

        COM_BasedListRemove(&(pMem->chain));
        EngFreeMem(pMem);
    }

    //
    // Clear the window linked lists since they contain elements in
    // the now free memory block.
    //
    COM_BasedListInit(&g_hetFreeWndList);
    COM_BasedListInit(&g_hetWindowList);

    DebugExitVOID(HET_DDTerm);
}


//
// HET_DDProcessRequest - see host.h
//
ULONG HET_DDProcessRequest(SURFOBJ  *pso,
                               UINT  cjIn,
                               void *   pvIn,
                               UINT  cjOut,
                               void *   pvOut)
{
    ULONG rc = TRUE;
    LPOSI_ESCAPE_HEADER  pHeader;

    DebugEntry(HET_DDProcessRequest);

    pHeader = pvIn;
    TRACE_OUT(( "Request %#x", pHeader->escapeFn));
    switch (pHeader->escapeFn)
    {
        case HET_ESC_SHARE_WINDOW:
        {
            if ((cjIn != sizeof(HET_SHARE_WINDOW)) ||
                (cjOut != sizeof(HET_SHARE_WINDOW)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_SHARE_WINDOW",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            ((LPHET_SHARE_WINDOW)pvOut)->result =
                HETDDShareWindow(pso, (LPHET_SHARE_WINDOW)pvIn);
        }
        break;

        case HET_ESC_UNSHARE_WINDOW:
        {
            if ((cjIn != sizeof(HET_UNSHARE_WINDOW)) ||
                (cjOut != sizeof(HET_UNSHARE_WINDOW)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_UNSHARE_WINDOW",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            HETDDUnshareWindow((LPHET_UNSHARE_WINDOW)pvIn);
        }
        break;

        case HET_ESC_UNSHARE_ALL:
        {
            if ((cjIn != sizeof(HET_UNSHARE_ALL)) ||
                (cjOut != sizeof(HET_UNSHARE_ALL)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_UNSHARE_ALL",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            HETDDUnshareAll();
        }
        break;

        case HET_ESC_SHARE_DESKTOP:
        {
            if ((cjIn != sizeof(HET_SHARE_DESKTOP)) ||
                (cjOut != sizeof(HET_SHARE_DESKTOP)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_SHARE_DESKTOP",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            g_hetDDDesktopIsShared = TRUE;
        }
        break;

        case HET_ESC_UNSHARE_DESKTOP:
        {
            if ((cjIn != sizeof(HET_UNSHARE_DESKTOP)) ||
                (cjOut != sizeof(HET_UNSHARE_DESKTOP)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_UNSHARE_DESKTOP",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            g_hetDDDesktopIsShared = FALSE;
            HETDDViewing(NULL, FALSE);
        }
        break;

        case HET_ESC_VIEWER:
        {
            //
            // We may turn OFF viewing but keep stuff shared and the windows
            // tracked -- hosting a meeting and sharing something, for 
            // example. 
            //
            if ((cjIn != sizeof(HET_VIEWER)) ||
                (cjOut != sizeof(HET_VIEWER)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_VIEWER",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            HETDDViewing(pso, (((LPHET_VIEWER)pvIn)->viewersPresent != 0));
            break;
        }

        default:
        {
            ERROR_OUT(( "Unknown request type %#x", pHeader->escapeFn));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(HET_DDProcessRequest, rc);
    return(rc);
}


//
// HET_DDOutputIsHosted - see host.h
//
BOOL HET_DDOutputIsHosted(POINT pt)
{
    BOOL              rc = FALSE;
    UINT              j;
    LPHET_WINDOW_STRUCT  pWnd;

    DebugEntry(HET_DDOutputIsHosted);

    //
    // Now check to see if the desktop is shared - if it is then simply
    // return TRUE.
    //
    if (g_hetDDDesktopIsShared)
    {
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Search through the window list
    //
    pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    while (pWnd != NULL)
    {
        //
        // Search each enumerated rectangle
        //
        TRACE_OUT(( "Window %#x has %u rectangle(s)",
                pWnd, pWnd->rects.c));
        for (j = 0; j < pWnd->rects.c; j++)
        {
            //
            // See whether the point passed in is within this rectangle.
            // Note that at this point we are dealing with exclusive
            // co-ordinates.
            //
            if ((pt.x >= pWnd->rects.arcl[j].left) &&
                (pt.x <  pWnd->rects.arcl[j].right) &&
                (pt.y >= pWnd->rects.arcl[j].top) &&
                (pt.y <  pWnd->rects.arcl[j].bottom))
            {
                TRACE_OUT((
                    "Pt {%d, %d}, in win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pt.x, pt.y, pWnd->hwnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

                //
                // Found it!  Re-order the list, most recently used first
                //
                COM_BasedListRemove(&(pWnd->chain));
                COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

                //
                // Stop looking
                //
                rc = TRUE;
                DC_QUIT;
            }

            TRACE_OUT(( "Pt not in win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pWnd->hwnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

        } // for all rectangles

        //
        // Move on to next window
        //
        pWnd = COM_BasedListNext(&g_hetWindowList, pWnd, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    }

DC_EXIT_POINT:
    DebugExitBOOL(HET_DDOutputIsHosted, rc);
    return(rc);
}


//
// HET_DDOutputRectIsHosted - see host.h
//
BOOL HET_DDOutputRectIsHosted(LPRECT pRect)
{
    BOOL              rc = FALSE;
    UINT              j;
    LPHET_WINDOW_STRUCT  pWnd;
    RECT              rectIntersect;

    DebugEntry(HET_DDOutputRectIsHosted);

    //
    // Now check to see if the desktop is shared - if it is then simply
    // return TRUE.
    //
    if (g_hetDDDesktopIsShared)
    {
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Search through the window list
    //
    pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    while (pWnd != NULL)
    {
        //
        // Search each enumerated rectangle
        //
        TRACE_OUT(( "Window %#x has %u rectangle(s)",
                pWnd, pWnd->rects.c));
        for (j = 0; j < pWnd->rects.c; j++)
        {
            //
            // See whether the rect passed in intersects this rectangle.
            // Note that at this point we are dealing with exclusive
            // co-ordinates.
            //
            rectIntersect.left = max( pRect->left,
                                         pWnd->rects.arcl[j].left );
            rectIntersect.top = max( pRect->top,
                                        pWnd->rects.arcl[j].top );
            rectIntersect.right = min( pRect->right,
                                          pWnd->rects.arcl[j].right );
            rectIntersect.bottom = min( pRect->bottom,
                                           pWnd->rects.arcl[j].bottom );

            //
            // If the intersection rectangle is well-ordered and non-NULL
            // then we have an intersection.
            //
            // The rects that we are dealing with are exclusive.
            //
            if ((rectIntersect.left < rectIntersect.right) &&
                (rectIntersect.top < rectIntersect.bottom))
            {
                TRACE_OUT((
             "Rect  {%d, %d, %d, %d} intersects win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pRect->left, pRect->top, pRect->right, pRect->bottom,
                    pWnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

                //
                // Found it!  Re-order the list, most recently used first
                //
                COM_BasedListRemove(&(pWnd->chain));
                COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

                //
                // Stop looking
                //
                rc = TRUE;
                DC_QUIT;
            }

            TRACE_OUT(( "Rect not in win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pWnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

        } // for all rectangles

        //
        // Move on to next window
        //
        pWnd = COM_BasedListNext(&g_hetWindowList, pWnd, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    }

DC_EXIT_POINT:
    DebugExitBOOL(HET_DDOutputRectIsHosted, rc);
    return(rc);
}


//
//
// Name:        HETDDVisRgnCallback
//
// Description: WNDOBJ Callback
//
// Params:      pWo - pointer to the WNDOBJ which has changed
//              fl  - flags (se NT DDK documentation)
//
// Returns:     none
//
// Operation:
//
//
VOID CALLBACK HETDDVisRgnCallback(PWNDOBJ pWo, FLONG fl)
{
    ULONG               count;
    int               size;
    LPHET_WINDOW_STRUCT  pWnd;
    RECTL             rectl;
    UINT              i;

    DebugEntry(HETDDVisRgnCallback);

    //
    // Some calls pass a NULL pWo - exit now in this case
    //
    if (pWo == NULL)
    {
        DC_QUIT;
    }

    //
    // Find the window structure for this window
    //
    pWnd = pWo->pvConsumer;
    if (pWnd == NULL)
    {
        ERROR_OUT(( "Wndobj %x (fl %x) has no window structure", pWo, fl));
        DC_QUIT;
    }

    //
    // Check for window deletion
    //
    if (fl & WOC_DELETE)
    {
        TRACE_OUT(( "Wndobj %x (structure %x) deleted", pWo, pWo->pvConsumer));

        // ASSERT the window is valid
        ASSERT(pWnd->hwnd != NULL);

        //
        // Move the window from the active to the free list
        //
        COM_BasedListRemove(&(pWnd->chain));
        COM_BasedListInsertAfter(&g_hetFreeWndList, &(pWnd->chain));

#ifdef DEBUG
        // Check if this has reentrancy problems
        pWnd->hwnd = NULL;
#endif

        //
        // Do any processing if this is the last window to be unshared.
        //
        // If we are not keeping track of any windows, the first pointer in
        // the list will point to itself, ie list head->next == 0
        //
        if (g_hetWindowList.next == 0)
        {
            HETDDViewing(NULL, FALSE);
        }

        //
        // Exit now
        //
        DC_QUIT;
    }

    //
    // If we get here, this callback must be for a new visible region on a
    // tracked window.
    //

    //
    // Start the enumeration.  This function is supposed to count the
    // rectangles, but it always returns 0.
    //
    WNDOBJ_cEnumStart(pWo, CT_RECTANGLES, CD_ANY, 200);

    //
    // BOGUS BUGBUG LAURABU (perf opt for NT):
    //
    // NT will enum up to HET_WINDOW_RECTS at a time.  Note that the enum
    // function returns FALSE if, after obtaining the current batch, none
    // are left to grab the next time.
    //
    // If the visrgn is composed of more than that, we will wipe out the 
    // previous set of rects, then ensure that the bounding box of the 
    // preceding rects is the last rect in the list.
    //
    // This is bad in several cases.  For example if there are n visrgn piece
    // rects, and n == c*HET_WINDOW_RECTS + 1, we will end up with 2 entries:
    //      * The last piece rect
    //      * The bounding box of the previous n-1 piece rects 
    // A lot of output may be accumulated in deadspace as a result.
    //
    // A better algorithm may be to fill the first HET_WINDOW_RECTS-1 slots,
    // then union the rest into the last rectangle.  That way we make use of
    // all the slots.  But this could be awkward, since we need a scratch
    // ENUM_RECT struct rather than using the HET_WINDOW_STRUCT directly.
    //

    //
    // First time through, enumerate HET_WINDOW_RECTS rectangles.
    // Subsequent times, enumerate HET_WINDOW_RECTS-1 (see bottom of loop).
    // This guarantees that there will be room to store a combined
    // rectangle when we finally finish enumerating them.
    //
    pWnd->rects.c = HET_WINDOW_RECTS;
    rectl.left   = LONG_MAX;
    rectl.top    = LONG_MAX;
    rectl.right  = 0;
    rectl.bottom = 0;

    //
    // Enumerate the rectangles
    // NOTE that WNDOBJ_bEnum returns FALSE when there is nothing left
    // to enumerate AFTER grabbing this set.
    //

    while (WNDOBJ_bEnum(pWo, sizeof(pWnd->rects), (ULONG *)&pWnd->rects))
    {
#ifdef _DEBUG
        {
            char    trcStr[200];
            UINT    j;

            sprintf(trcStr, "WNDOBJ %p %d: ", pWo, pWnd->rects.c);

            for (j = 0; j < pWnd->rects.c; j++)
            {
                sprintf(trcStr, "%s {%ld, %ld, %ld, %ld} ", trcStr,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].top,
                    pWnd->rects.arcl[j].right, pWnd->rects.arcl[j].bottom);
                if ((j & 3) == 3)       // output every 4th rect
                {
                    TRACE_OUT(( "%s", trcStr));
                    strcpy(trcStr, "                ");
                }
            }
            if ((j & 3) != 0)           // if any rects left
            {
                TRACE_OUT(( "%s", trcStr));
            }
        }
#endif

        //
        // Combine the preceding rectangles into one bounding rectangle
        //
        for (i = 0; i < pWnd->rects.c; i++)
        {
            if (pWnd->rects.arcl[i].left < rectl.left)
            {
                rectl.left = pWnd->rects.arcl[i].left;
            }
            if (pWnd->rects.arcl[i].top < rectl.top)
            {
                rectl.top = pWnd->rects.arcl[i].top;
            }
            if (pWnd->rects.arcl[i].right > rectl.right)
            {
                rectl.right = pWnd->rects.arcl[i].right;
            }
            if (pWnd->rects.arcl[i].bottom > rectl.bottom)
            {
                rectl.bottom = pWnd->rects.arcl[i].bottom;
            }
        }
        TRACE_OUT(( "Combined into {%ld, %ld, %ld, %ld}",
                rectl.left, rectl.top, rectl.right, rectl.bottom));

        //
        // Second & subsequent times, enumerate HET_WINDOW_RECTS-1
        //
        pWnd->rects.c = HET_WINDOW_RECTS - 1;
    }

    //
    // If any combining was done, save the combined rectangle now.
    //
    if (rectl.right != 0)
    {
        pWnd->rects.arcl[pWnd->rects.c] = rectl;
        pWnd->rects.c++;
        TRACE_OUT(( "Add combined rectangle to list"));
    }

    //
    // On the assumption that this WNDOBJ is the most likely to be the
    // target of the next output command, move it to the top of the list.
    //
    COM_BasedListRemove(&(pWnd->chain));
    COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

    //
    // Return to caller
    //
DC_EXIT_POINT:
    DebugExitVOID(HETDDVisRgnCallback);
}


//
//
// Name:        HETDDShareWindow
//
// Description: Share a window (DD processing)
//
// Params:      pso      - SURFOBJ
//              pReq     - request received from DrvEscape
//
//
BOOL HETDDShareWindow(SURFOBJ *pso, LPHET_SHARE_WINDOW  pReq)
{
    PWNDOBJ            pWo;
    FLONG              fl = WO_RGN_CLIENT | WO_RGN_UPDATE_ALL | WO_RGN_WINDOW;
    LPHET_WINDOW_STRUCT pWnd;
    BOOL                rc = FALSE;

    DebugEntry(HETDDShareWindow);

    ASSERT(!g_hetDDDesktopIsShared);

    //
    // Try to track the window
    //
    pWo = EngCreateWnd(pso, (HWND)pReq->winID, HETDDVisRgnCallback, fl, 0);

    //
    // Failed to track window - exit now
    //
    if (pWo == 0)
    {
        ERROR_OUT(( "Failed to track window %#x", pReq->winID));
        DC_QUIT;
    }

    //
    // Window is already tracked.  This happens when an invisible window is
    // shown in a process the USER shared, and we caught its create.
    //
    if (pWo == (PWNDOBJ)-1)
    {
        //
        // No more to do here
        //
        TRACE_OUT(( "Window %#x already tracked", pReq->winID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Add window into our list.
    //

    //
    // Find free window structure
    //
    pWnd = COM_BasedListFirst(&g_hetFreeWndList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));

    //
    // If no free structures, grow the list
    //
    if (pWnd == NULL)
    {
        if (!HETDDAllocWndMem())
        {
            ERROR_OUT(( "Unable to allocate new window structures"));
            DC_QUIT;
        }

        pWnd = COM_BasedListFirst(&g_hetFreeWndList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    }

    //
    // Fill in the structure
    //
    TRACE_OUT(( "Fill in details for new window"));
    pWnd->hwnd     = (HWND)pReq->winID;
    pWnd->wndobj   = pWo;

    //
    // Set this to zero.  There's a brief period between the time we put
    // this in our tracked list and the time we get called back to recalc
    // the visrgn (because the ring 3 code invalidates the window completely).
    // We might get graphical output and we don't want to parse garbage
    // from this window's record.
    //
    pWnd->rects.c  = 0;

    //
    // Move the window structure from free to active list
    //
    COM_BasedListRemove(&(pWnd->chain));
    COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

    //
    // Save backwards pointer in the WNDOBJ
    // THIS MUST BE LAST since our callback can happen anytime afterwards.
    //
    // NOTE that the window's visrgn rects get into our list because the
    // ring3 code completely invalidates the window, causing the callback
    // to get called.
    //
    TRACE_OUT(( "Save pointer %#lx in Wndobj %#x", pWnd, pWo));
    WNDOBJ_vSetConsumer(pWo, pWnd);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HETDDShareWindow, rc);
    return(rc);
}


//
//
// Name:        HETDDUnshareWindow
//
// Description: Unshare a window (DD processing)
//
//
//
void HETDDUnshareWindow(LPHET_UNSHARE_WINDOW  pReq)
{
    LPHET_WINDOW_STRUCT  pWnd, pNextWnd;

    DebugEntry(HETDDUnshareWindow);

    TRACE_OUT(( "Unshare %x", pReq->winID));
    //
    // Scan window list for this window and its descendants
    //
    pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    while (pWnd != NULL)
    {
        //
        // If this window is being unshared, free it
        //
        pNextWnd = COM_BasedListNext(&g_hetWindowList, pWnd, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));

        if (pWnd->hwnd == (HWND)pReq->winID)
        {
            TRACE_OUT(( "Unsharing %x", pReq->winID));

            //
            // Stop tracking the window
            //
            HETDDDeleteAndFreeWnd(pWnd);
        }

        //
        // Go on to (previously saved) next window
        //
        pWnd = pNextWnd;
    }

    //
    // Return to caller
    //
    DebugExitVOID(HETDDUnshareWindow);
}


//
//
// Name:        HETDDUnshareAll
//
// Description: Unshare all windows (DD processing) (what did you expect)
//
//
void HETDDUnshareAll(void)
{
    LPHET_WINDOW_STRUCT pWnd;

    DebugEntry(HETDDUnshareAll);

    //
    // Clear all window structures
    //
    while (pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain)))
    {
        TRACE_OUT(( "Unshare Window structure %x", pWnd));

        //
        // Stop tracking the window
        //
        HETDDDeleteAndFreeWnd(pWnd);
    }

    //
    // Return to caller
    //
    DebugExitVOID(HETDDUnshareAll);
}


//
//
// Name:        HETDDAllocWndMem
//
// Description: Allocate memory for a (new) window list
//
// Parameters:  None
//
//
BOOL HETDDAllocWndMem(void)
{
    BOOL             rc = FALSE;
    int              i;
    LPHET_WINDOW_MEMORY pNew;

    DebugEntry(HETDDAllocWndMem);

    //
    // Allocate a new strucure
    //
    pNew = EngAllocMem(FL_ZERO_MEMORY, sizeof(HET_WINDOW_MEMORY), OSI_ALLOC_TAG);
    if (pNew == NULL)
    {
        ERROR_OUT(("HETDDAllocWndMem: unable to allocate memory"));
        DC_QUIT;
    }

    //
    // Add this memory block to the list of memory blocks
    //
    COM_BasedListInsertAfter(&g_hetMemoryList, &(pNew->chain));

    //
    // Add all new entries to free list
    //
    TRACE_OUT(("HETDDAllocWndMem: adding new entries to free list"));
    for (i = 0; i < HET_WINDOW_COUNT; i++)
    {
        COM_BasedListInsertAfter(&g_hetFreeWndList, &(pNew->wnd[i].chain));
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HETDDAllocWndMem, rc);
    return(rc);
}

//
//
// Name:        HETDDDeleteAndFreeWnd
//
// Description: Delete and window and free its window structure
//
// Parameters:  pWnd - pointer to window structure to delete & free
//
// Returns:     none
//
// Operation:   Ths function stops tracking a window and frees its memory
//
//
void HETDDDeleteAndFreeWnd(LPHET_WINDOW_STRUCT pWnd)
{
    DebugEntry(HETDDDeleteAndFreeWnd);

    //
    // Stop tracking the window
    //
    EngDeleteWnd(pWnd->wndobj);

    //
    // NOTE LAURABU!  EngDeleteWnd() will call the VisRgnCallback with
    // WO_DELETE, which will cause us to exectute a duplicate of exactly 
    // the code below.  So why do it twice (which is scary anyway), especially
    // the stop hosting code?
    //
    ASSERT(pWnd->hwnd == NULL);

    //
    // Return to caller
    //
    DebugExitVOID(HETDDDeleteAndFreeWnd);
}


//
// HETDDViewers()
//
// Called when viewing of our shared apps starts/stops.  Naturally, no longer
// sharing anything stops viewing also.
//
void HETDDViewing
(
    SURFOBJ *   pso,
    BOOL        fViewers
)
{
    DebugEntry(HETDDViewers);

    if (g_oeViewers != fViewers)
    {
        g_oeViewers = fViewers;
        CM_DDViewing(pso, fViewers);

        if (g_oeViewers)
        {
            //
            // Force palette grab.
            //
            g_asSharedMemory->pmPaletteChanged = TRUE;
        }
    }

    DebugExitVOID(HETDDViewing);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\oe.c ===
#include "precomp.h"


//
// OE.C
// Order Encoder, display driver side
//
// Copyright(c) Microsoft 1997-
//

//
// Number of entries in the font alias table.
//
#define NUM_ALIAS_FONTS 3

//
// Define entries in the Font Alias table.  This table is used to convert
// non-existant fonts (used by certain widely used applications) into
// something we can use as a local font.
//
// The font names that we alias are:
//
// "Helv"
// This is used by Excel. It is mapped directly onto "MS Sans Serif".
//
// "MS Dialog"
// This is used by Word. It is the same as an 8pt bold MS Sans Serif.
// We actually map it to a "MS Sans Serif" font that is one pel narrower
// than the metrics specify (because all matching is done on non-bold
// fonts) - hence the 1 value in the charWidthAdjustment field.
//
// "MS Dialog Light"
// Added as part of the Win95 performance enhancements...Presumably for
// MS-Word...
//
//
FONT_ALIAS_TABLE fontAliasTable[NUM_ALIAS_FONTS] =
{
    { "Helv",            "MS Sans Serif", 0 },
    { "MS Dialog",       "MS Sans Serif", 1 },
    { "MS Dialog Light", "MS Sans Serif", 0 }
};




//
// FUNCTION: OE_SendAsOrder see oe.h
//
BOOL  OE_SendAsOrder(DWORD order)
{
    BOOL  rc = FALSE;

    DebugEntry(OE_SendAsOrder);

    //
    // Only check the order if we are allowed to send orders in the first
    // place!
    //
    if (g_oeSendOrders)
    {
        TRACE_OUT(("Orders enabled"));

        //
        // We are sending some orders, so check individual flags.
        //
        rc = (BOOL)g_oeOrderSupported[HIWORD(order)];
        TRACE_OUT(("Send order %lx HIWORD %hu", order, HIWORD(order)));
    }

    DebugExitDWORD(OE_SendAsOrder, rc);
    return(rc);
}


//
// OE_RectIntersectsSDA - see oe.h
//
BOOL  OE_RectIntersectsSDA(LPRECT pRect)
{
    RECT  rectVD;
    BOOL  fIntersection = FALSE;
    UINT  i;

    DebugEntry(OE_RectIntersectsSDA);

    //
    // Copy the supplied rectangle, converting to inclusive Virtual
    // Desktop coords.
    //
    rectVD.left   = pRect->left;
    rectVD.top    = pRect->top;
    rectVD.right  = pRect->right - 1;
    rectVD.bottom = pRect->bottom - 1;

    //
    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    //
    for (i = 0; i <= BA_NUM_RECTS; i++)
    {
        if ( (g_baBounds[i].InUse) &&
             (g_baBounds[i].Coord.left <= rectVD.right) &&
             (g_baBounds[i].Coord.top <= rectVD.bottom) &&
             (g_baBounds[i].Coord.right >= rectVD.left) &&
             (g_baBounds[i].Coord.bottom >= rectVD.top) )
        {
            TRACE_OUT(("Rect(%d,%d)(%d,%d) intersects SDA(%d,%d)(%d,%d)",
                          rectVD.left, rectVD.top,
                          rectVD.right, rectVD.bottom,
                          g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                          g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DebugExitDWORD(OE_RectIntersectsSDA, fIntersection);
    return(fIntersection);
}


//
// DrvBitBlt - see NT DDK documentation.
//
BOOL DrvBitBlt( SURFOBJ  *psoDst,
                      SURFOBJ  *psoSrc,
                      SURFOBJ  *psoMask,
                      CLIPOBJ  *pco,
                      XLATEOBJ *pxlo,
                      RECTL    *prclDst,
                      POINTL   *pptlSrc,
                      POINTL   *pptlMask,
                      BRUSHOBJ *pbo,
                      POINTL   *pptlBrush,
                      ROP4      rop4 )
{
    LPOSI_PDEV               ppdev = (LPOSI_PDEV)psoDst->dhpdev;
    BOOL                    rc = TRUE;
    UINT                orderType = 0;
    BYTE                 rop3;
    LPINT_ORDER              pOrder = NULL;
    LPDSTBLT_ORDER          pDstBlt;
    LPSCRBLT_ORDER          pScrBlt;
    LPMEMBLT_ORDER          pMemBlt;
    LPMEM3BLT_ORDER         pMem3Blt;
    BOOL                  fSendOrder  = FALSE;
    BOOL                  fAccumulate = FALSE;
    UINT                fOrderFlags = OF_SPOILABLE;
    RECT                  bounds;
    RECT                  intersectRect;
    POINT                 origin;
    POE_BRUSH_DATA          pCurrentBrush;
    MEMBLT_ORDER_EXTRA_INFO memBltExtraInfo;

    DebugEntry(DrvBitBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCKS
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;

    //
    // Get the bounding rectangle for the operation.
    //
    RECT_FROM_RECTL(bounds, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &bounds);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert the data to virtual coordinates.
    //
    OELRtoVirtual(&bounds, 1);

    //
    // Check if this 4-way ROP simplifies to a 3-way ROP.  A 4-way ROP
    // contains two 3-way ROPS, one for each setting of a mask bit - the
    // high ROP3 corresponds to a value of zero in the mask bit.
    //
    // If the two 3-way ROPs are the same, we know the 4-way ROP is a 3-way
    // ROP.
    //
    if (ROP3_LOW_FROM_ROP4(rop4) == ROP3_HIGH_FROM_ROP4(rop4))
    {
        //
        // Take the high byte as the 3-way ROP.
        //
        rop3 = ROP3_HIGH_FROM_ROP4(rop4);
        TRACE_OUT(( "4-way ROP %04x is really 3-way %02x", rop4, rop3));
    }
    else
    {
        TRACE_OUT(( "4-way ROP %08x", rop4));
        DC_QUIT;
    }

    //
    // Determine the command type.  It can be one of the following.
    //
    // DSTBLT  - A destination only BLT (no source, or pattern)
    // PATBLT  - a pattern BLT (no source)
    // SCRBLT  - a screen to screen BLT
    // MEMBLT  - a memory to screen BLT (no pattern)
    // MEM3BLT - a memory to screen 3-way BLT
    //

    //
    // Check for destination only BLTs (ie. independent of source bits).
    //
    if ((psoSrc == NULL) || ROP3_NO_SOURCE(rop3))
    {
        //
        // Check for a pattern or true destination BLT.
        //
        if (ROP3_NO_PATTERN(rop3))
        {
            TRACE_OUT(( "DSTBLT"));
            orderType = ORD_DSTBLT;
        }
        else
        {
            TRACE_OUT(( "PATBLT"));
            orderType = ORD_PATBLT;
        }
    }
    else
    {
        //
        // We have a source BLT, check whether we have screen or memory
        // BLTs.
        //
        if (psoSrc->hsurf != ppdev->hsurfScreen)
        {
            if (psoDst->hsurf != ppdev->hsurfScreen)
            {
                ERROR_OUT(( "MEM to MEM blt!"));
            }
            else
            {
                //
                // We have a memory to screen BLT, check which type.
                //
                if ((ppdev->cBitsPerPel == 4) && (rop3 != 0xcc))
                {
                    //
                    // No order -- the result depends on the palette
                    // which is dicy in VGA
                    //
                    TRACE_OUT(("No order on VGA for rop 0x%02x", rop3));
                    DC_QUIT;
                }

                if (ROP3_NO_PATTERN(rop3))
                {
                    TRACE_OUT(( "MEMBLT"));
                    orderType = ORD_MEMBLT;
                }
                else
                {
                    TRACE_OUT(( "MEM3BLT"));
                    orderType = ORD_MEM3BLT;
                }
            }
        }
        else
        {
            if (psoDst->hsurf != ppdev->hsurfScreen)
            {
                TRACE_OUT(( "SCR to MEM blt!"));
            }
            else
            {
                //
                // We only support destination only screen BLTs (ie.  no
                // patterns allowed).
                //
                if (ROP3_NO_PATTERN(rop3))
                {
                    TRACE_OUT(( "SCRBLT"));
                    orderType = ORD_SCRBLT;
                }
                else
                {
                    TRACE_OUT(( "Unsupported screen ROP %x", rop3));
                }
            }
        }
    }

    //
    // Check if we have a supported order.
    //
    if (orderType == 0)
    {
        TRACE_OUT(( "Unsupported BLT"));
        fAccumulate = FALSE;
        DC_QUIT;
    }

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(orderType))
    {
        TRACE_OUT(( "Order %d not allowed", orderType));
        DC_QUIT;
    }

    //
    // Check if we are allowed to send the ROP.
    //
    if (!OESendRop3AsOrder(rop3))
    {
        TRACE_OUT(( "Cannot send ROP %d", rop3));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // If this is a Memblt, do an initial check on whether it is cachable
    //
    if ((orderType == ORD_MEMBLT) || (orderType == ORD_MEM3BLT))
    {
        //
        // We have to fill in a structure containing extra into
        // specifically for a MEM(3)BLT order.
        //
        memBltExtraInfo.pSource   = psoSrc;
        memBltExtraInfo.pDest     = psoDst;
        memBltExtraInfo.pXlateObj = pxlo;

        if (!SBC_DDIsMemScreenBltCachable(&memBltExtraInfo))
        {
            TRACE_OUT(( "MemBlt is not cachable"));
            DC_QUIT;
        }

        //
        // It is cachable.  Before we get SBC to do the caching, we have to
        // allow it to queue a color table (if required).
        //
        if (!SBC_DDMaybeQueueColorTable(ppdev))
        {
            TRACE_OUT(( "Unable to queue color table for MemBlt"));
            DC_QUIT;
        }
    }

    //
    // We have a recognised order - do the specific checks for each order.
    //
    switch (orderType)
    {
        case ORD_DSTBLT:
            //
            // Allocate the memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(DSTBLT_ORDER),0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pDstBlt = (LPDSTBLT_ORDER)pOrder->abOrderData;

            //
            // Set the spoiler flag if the rop is opaque.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
                fOrderFlags |= OF_SPOILER;
            }

            //
            // Store the order type.
            //
            pDstBlt->type = LOWORD(orderType);

            //
            // Virtual desktop co-ordinates.
            //
            pDstBlt->nLeftRect  = bounds.left;
            pDstBlt->nTopRect   = bounds.top;
            pDstBlt->nWidth     = bounds.right  - bounds.left + 1;
            pDstBlt->nHeight    = bounds.bottom - bounds.top  + 1;
            pDstBlt->bRop       = rop3;

            TRACE_OUT(( "DstBlt X %d Y %d w %d h %d rop %02X",
                    pDstBlt->nLeftRect,
                    pDstBlt->nTopRect,
                    pDstBlt->nWidth,
                    pDstBlt->nHeight,
                    pDstBlt->bRop));
            break;

        case ORD_PATBLT:
            if ( !OEEncodePatBlt(ppdev,
                                 pbo,
                                 pptlBrush,
                                 rop3,
                                 &bounds,
                                 &pOrder) )
            {
                //
                // Something went wrong with the encoding, so skip to the
                // end to add this operation to the SDA.
                //
                DC_QUIT;
            }

            fOrderFlags = pOrder->OrderHeader.Common.fOrderFlags;
            break;

        case ORD_SCRBLT:
            //
            // Check for a SCRBLT as a result of a Desktop Scroll.  We must
            // ignore these as they will stuff the remote desktop.
            //
            // The check is simple - if the virtual position of the source
            // is the same as the virual position of the target for a
            // SRCCOPY type SCRBLT, we have a hit...
            //
            POINT_FROM_POINTL(origin, (*pptlSrc));

            //
            // Allocate the memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SCRBLT_ORDER),0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pScrBlt = (LPSCRBLT_ORDER)pOrder->abOrderData;

            //
            // Store the order type.
            //
            pScrBlt->type = LOWORD(orderType);

            //
            // All data which is sent over the wire must be in virtual
            // desktop co-ordinates.  OELRtoVirtual has already converted
            // bounds to an inclusive rectangle in virtual co-ordinates.
            //
            pScrBlt->nLeftRect  = bounds.left;
            pScrBlt->nTopRect   = bounds.top;
            pScrBlt->nWidth     = bounds.right  - bounds.left + 1;
            pScrBlt->nHeight    = bounds.bottom - bounds.top  + 1;
            pScrBlt->bRop       = rop3;

            //
            // Source point on the screen.
            //
            OELPtoVirtual(&origin, 1);
            pScrBlt->nXSrc = origin.x;
            pScrBlt->nYSrc = origin.y;

            //
            // Screen to screen blts are Blocking orders (i.e.  they
            // prevent any previous orders from being spoilt).
            //
            // We do not mark Screen to Screen blts as SPOILER orders.  If
            // the ROP is opaque we could spoil the destination rect, but
            // only the area that does not overlap with the src rectangle.
            // The most common use of Screen to Screen blts is scrolling,
            // where the src and dst rects almost completely overlap,
            // giving only a small "spoiler" region.  The spoiler region
            // could also be complex (more that 1 rect).
            //
            // Consequently, the potential gains of trying to spoil using
            // these orders are small compared to the complexity of the
            // code required.
            //
            //
            fOrderFlags |= OF_BLOCKER;

            //
            // If the blt is screen to screen and the source overlaps the
            // destination and the clipping is not simple (> 1 rect) then
            // we do not want to send this as an order.
            //
            // (This is because we would need some complex code to
            // calculate the order in which to blt through each of the clip
            // rects.  As this case is pretty rare, it seems reasonable to
            // just send it as Screen Data).
            //
            if (!OEClippingIsSimple(pco))
            {
                //
                // Calculate the overlapping rectangle.
                //
                intersectRect.left  = max(pScrBlt->nLeftRect, pScrBlt->nXSrc);

                intersectRect.right = min(
                          pScrBlt->nLeftRect + pScrBlt->nWidth-1,
                          pScrBlt->nXSrc     + pScrBlt->nWidth-1 );

                intersectRect.top   = max(pScrBlt->nTopRect, pScrBlt->nYSrc);

                intersectRect.bottom = min(
                               pScrBlt->nTopRect + pScrBlt->nHeight-1,
                               pScrBlt->nYSrc    + pScrBlt->nHeight-1 );

                //
                // Check for a src / dst overlap.  If they overlap, the
                // intersection is a well-ordered non-trivial rectangle.
                //
                if ( (intersectRect.left <= intersectRect.right ) &&
                     (intersectRect.top  <= intersectRect.bottom) )
                {
                    //
                    // The src & dest overlap.  Free up the order memory
                    // and skip out now.  The destination rectangle will be
                    // added to the Screen Data Area.
                    //
                    OA_DDFreeOrderMem(pOrder);
                    DC_QUIT;
                }
            }

            TRACE_OUT(( "ScrBlt x %d y %d w %d h %d sx %d sy %d rop %02X",
                   pScrBlt->nLeftRect,
                   pScrBlt->nTopRect,
                   pScrBlt->nWidth,
                   pScrBlt->nHeight,
                   pScrBlt->nXSrc,
                   pScrBlt->nYSrc,
                   pScrBlt->bRop));
            break;

        case ORD_MEMBLT:
            //
            // Allocate the memory for the order - don't use OA as we are
            // only going to tile this order immediately.  Instead, we have
            // a static buffer to receive the template order data.
            //
            pOrder  = (LPINT_ORDER)g_oeTmpOrderBuffer;
            pMemBlt = (LPMEMBLT_ORDER)pOrder->abOrderData;
            pOrder->OrderHeader.Common.cbOrderDataLength
                                                    = sizeof(MEMBLT_R2_ORDER);

            //
            // Store the order type.
            //
            pMemBlt->type = LOWORD(orderType);

            //
            // Any data which is sent over the wire must be in virtual
            // desktop co-ordinates.  The bounding rectangle has already
            // been converted by OELRtoScreen.
            //
            pMemBlt->nLeftRect  = bounds.left;
            pMemBlt->nTopRect   = bounds.top;
            pMemBlt->nWidth     = bounds.right  - bounds.left + 1;
            pMemBlt->nHeight    = bounds.bottom - bounds.top  + 1;
            pMemBlt->bRop       = rop3;

            //
            // We need to store the source bitmap origin.  This is a memory
            // object, so screen/virtual conversions are unnecessary.
            //
            pMemBlt->nXSrc = pptlSrc->x;
            pMemBlt->nYSrc = pptlSrc->y;

            //
            // Mark the order as opaque if necessary.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
                fOrderFlags |= OF_SPOILER;
            }

            //
            // Store the src bitmap handle in the order.
            //
            pMemBlt->cacheId = 0;

            TRACE_OUT(( "MemBlt dx %d dy %d w %d h %d sx %d sy %d rop %04X",
                   pMemBlt->nLeftRect,
                   pMemBlt->nTopRect,
                   pMemBlt->nWidth,
                   pMemBlt->nHeight,
                   pMemBlt->nXSrc,
                   pMemBlt->nYSrc,
                   pMemBlt->bRop));
            break;

        case ORD_MEM3BLT:
            //
            // Check that the brush pattern is simple.
            //
            if (!OECheckBrushIsSimple(ppdev, pbo, &pCurrentBrush))
            {
                TRACE_OUT(( "Brush is not simple"));
                orderType = 0;
                DC_QUIT;
            }

            //
            // Allocate the memory for the order - don't use OA as we are
            // only going to tile this order immediately.  Instead, we have
            // a static buffer to receive the template order data.
            //
            pOrder   = (LPINT_ORDER)g_oeTmpOrderBuffer;
            pMem3Blt = (LPMEM3BLT_ORDER)pOrder->abOrderData;
            pOrder->OrderHeader.Common.cbOrderDataLength
                                                   = sizeof(MEM3BLT_R2_ORDER);

            //
            // Store the order type.
            //
            pMem3Blt->type = LOWORD(orderType);

            //
            // All data which is sent over the wire must be in virtual
            // desktop co-ordinates.  OELRtoVirtual has already done this
            // conversion for us.
            //
            pMem3Blt->nLeftRect  = bounds.left;
            pMem3Blt->nTopRect   = bounds.top;
            pMem3Blt->nWidth     = bounds.right  - bounds.left + 1;
            pMem3Blt->nHeight    = bounds.bottom - bounds.top  + 1;
            pMem3Blt->bRop       = rop3;

            //
            // We need to store the source bitmap origin.  This is a memory
            // object, so screen/virtual conversions are unnecessary.
            //
            pMem3Blt->nXSrc = pptlSrc->x;
            pMem3Blt->nYSrc = pptlSrc->y;

            //
            // Mark the order as opaque if necessary.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
                fOrderFlags |= OF_SPOILER;
            }

            //
            // Store the src bitmap handle in the order.
            //
            pMem3Blt->cacheId = 0;

            //
            // Set up the information required for the pattern.
            //
            pMem3Blt->BackColor = pCurrentBrush->back;
            pMem3Blt->ForeColor = pCurrentBrush->fore;

            //
            // The protocol brush origin is the point on the screen where
            // we want the brush to start being drawn from (tiling where
            // necessary).  This must be in virtual coordinates.
            //
            pMem3Blt->BrushOrgX  = pptlBrush->x;
            pMem3Blt->BrushOrgY  = pptlBrush->y;
            OELPtoVirtual((LPPOINT)&pMem3Blt->BrushOrgX, 1);

            //
            // Extra brush data from the data when we realised the brush.
            //
            pMem3Blt->BrushStyle = pCurrentBrush->style;
            pMem3Blt->BrushHatch = pCurrentBrush->style;

            RtlCopyMemory(pMem3Blt->BrushExtra,
                          pCurrentBrush->brushData,
                          sizeof(pMem3Blt->BrushExtra));

            TRACE_OUT(( "Mem3Blt brush %02X %02X dx %d dy %d w %d h %d "
                         "sx %d sy %d rop %04X",
                    pMem3Blt->BrushStyle,
                    pMem3Blt->BrushHatch,
                    pMem3Blt->nLeftRect,
                    pMem3Blt->nTopRect,
                    pMem3Blt->nWidth,
                    pMem3Blt->nHeight,
                    pMem3Blt->nXSrc,
                    pMem3Blt->nYSrc,
                    pMem3Blt->bRop));
            break;

        default:
            ERROR_OUT(( "New unsupported order %08lx", orderType));
            orderType = 0;
            break;
    }

    //
    // We have generated an order so make sure we send it.
    //
    if (orderType != 0)
    {
        fSendOrder = TRUE;
    }

DC_EXIT_POINT:
    //
    // If we did not send an order, we must accumulate the output in the
    // Screen Data Area.
    //
    if (fSendOrder)
    {
        //
        // Check if the ROP has a dependency on the destination.
        //
        if (!ROP3_NO_TARGET(rop3))
        {
            TRACE_OUT(( "ROP has a target dependency"));
            fOrderFlags |= OF_DESTROP;
        }

        //
        // Store the general order data.  The bounding rectagle
        // co-ordinates must be virtual desktop.  OELRtoVirtual has already
        // converted rect for us.
        //
        pOrder->OrderHeader.Common.fOrderFlags   = (TSHR_UINT16)fOrderFlags;

        TSHR_RECT16_FROM_RECT(&pOrder->OrderHeader.Common.rcsDst, bounds);

        //
        // Add the order to the cache.  Note that we have the new tiled
        // processing for MEMBLT and MEM3BLT orders.
        //
        if ((orderType == ORD_MEMBLT) || (orderType == ORD_MEM3BLT))
        {
            OETileBitBltOrder(pOrder, &memBltExtraInfo, pco);
        }
        else
        {
            OEClipAndAddOrder(pOrder, NULL, pco);
        }
    }
    else
    {
        if (fAccumulate)
        {
            OEClipAndAddScreenData(&bounds, pco);
        }

    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvBitBlt, rc);
    return(rc);
}


//
// DrvStretchBlt - see NT DDK documentation.
//
BOOL DrvStretchBlt(SURFOBJ         *psoDst,
                         SURFOBJ         *psoSrc,
                         SURFOBJ         *psoMask,
                         CLIPOBJ         *pco,
                         XLATEOBJ        *pxlo,
                         COLORADJUSTMENT *pca,
                         POINTL          *pptlHTOrg,
                         RECTL           *prclDst,
                         RECTL           *prclSrc,
                         POINTL          *pptlMask,
                         ULONG            iMode)
{
    BOOL    rc = TRUE;
    RECT  rectSrc;
    RECT  rectDst;
    BOOL  fAccumulate = FALSE;
    POINTL  ptlSrc;
    BOOL    usedBitBlt  = FALSE;

    DebugEntry(DrvStretchBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;


    //
    // Get the source and destination rectangles
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Check that we have a valid ROP code.  The NT DDK states that the ROP
    // code for the StretchBlt is implicit in the mask specification.  If a
    // mask is specified, we have an implicit ROP4 of 0xCCAA, otherwise the
    // code is 0xCCCC.
    //
    // Our BitBlt code only encodes orders for ROP3s, so we must throw any
    // StretchBlts with a mask.
    //
    if (psoMask != NULL)
    {
        TRACE_OUT(( "Mask specified"));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // Rectangles are now well-ordered, check if we have a degenerate (ie.
    // no stretch) case.
    //
    if ( (rectSrc.right  - rectSrc.left == rectDst.right  - rectDst.left) &&
         (rectSrc.bottom - rectSrc.top  == rectDst.bottom - rectDst.top ) )
    {
        //
        // This can be passed on to the BitBlt code.
        //
        usedBitBlt = TRUE;

        ptlSrc.x = prclSrc->left;
        ptlSrc.y = prclSrc->top;

        rc = DrvBitBlt(psoDst,
                       psoSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclDst,
                       &ptlSrc,
                       pptlMask,
                       NULL,
                       NULL,
                       0xCCCC);

        //
        // We have stored this object in the BitBlt, so don't store the
        // data again.
        //
        fAccumulate = FALSE;
    }

DC_EXIT_POINT:
    if (fAccumulate)
    {
        //
        // Convert the data to virtual coordinates.
        //
        OELRtoVirtual(&rectDst, 1);

        //
        // Update the screen data area
        //
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvStretchBlt, rc);
    return(rc);
}


//
// DrvCopyBits - see NT DDK documentation.
//
BOOL DrvCopyBits(SURFOBJ  *psoDst,
                       SURFOBJ  *psoSrc,
                       CLIPOBJ  *pco,
                       XLATEOBJ *pxlo,
                       RECTL    *prclDst,
                       POINTL   *pptlSrc)
{
    //
    // CopyBits is a fast path for the NT display drivers.  In our case it
    // can always be processed as a BITBLT.
    //
    return(DrvBitBlt( psoDst,
                    psoSrc,
                    NULL,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    NULL,
                    NULL,
                    NULL,
                    0xCCCC));
}


//
// DrvTextOut - see NT DDK documentation.
//
BOOL DrvTextOut(SURFOBJ  *pso,
                      STROBJ   *pstro,
                      FONTOBJ  *pfo,
                      CLIPOBJ  *pco,
                      RECTL    *prclExtra,
                      RECTL    *prclOpaque,
                      BRUSHOBJ *pboFore,
                      BRUSHOBJ *pboOpaque,
                      POINTL   *pptlOrg,
                      MIX       mix)
{
    LPOSI_PDEV           ppdev = (LPOSI_PDEV)pso->dhpdev;
    BOOL                rc = TRUE;
    RECT              rectDst;
    RECT              rectText;
    LPINT_ORDER          pOrder;
    LPINT_ORDER          pOpaqueOrder;
    LPTEXTOUT_ORDER     pTextOut;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    BOOL              fSendOrder  = FALSE;
    BOOL              fAccumulate = FALSE;
    char              ansiString[ORD_MAX_STRING_LEN_WITHOUT_DELTAS+2];
    ULONG               ansiLen;
    ULONG               tempLen;
    UINT            orderType = 0;
    ULONG               maxLength;
    LPSTR             lpVariable;
    BOOL                fMoreData;
    ULONG               count;
    ULONG               i;
    GLYPHPOS*           pGlyphData;
    int                 currentDelta;
    LPVARIABLE_DELTAX   lpDeltaPos;
    UINT                fontFlags;
    UINT                fontAscender;
    UINT                fontHeight;
    UINT                fontWidth;
    UINT                fontWeight;
    UINT                fontIndex;
    POINTL              lastPtl;
    LPCOMMON_TEXTORDER   pCommon;
    POINT               startPoint;
    BOOL              sendDeltaX = FALSE;

    DebugEntry(DrvTextOut);

    //
    // DO THIS _BEFORE_ TAKING LOCKS
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    if (prclOpaque != NULL)
    {
        RECT_FROM_RECTL(rectDst, (*prclOpaque));
    }
    else
    {
        RECT_FROM_RECTL(rectDst, pstro->rclBkGround);
        TRACE_OUT(( "Using STROBJ bgd for size"));
    }

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Determine which order we will generate
    //
    if ( ((pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT) != 0) &&
         (prclOpaque == NULL) )
    {
        orderType = ORD_TEXTOUT;
        maxLength = ORD_MAX_STRING_LEN_WITHOUT_DELTAS;
    }
    else
    {
        orderType = ORD_EXTTEXTOUT;
        maxLength = ORD_MAX_STRING_LEN_WITH_DELTAS;
    }

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(orderType))
    {
        TRACE_OUT(( "Text order %x not allowed", orderType));
        DC_QUIT;
    }

    //
    // Check for a valid brush for the test operation.
    //
    if (pboFore->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for text fg"));
        DC_QUIT;
    }
    if (pboOpaque->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for text bg"));
        DC_QUIT;
    }

    //
    // Check that we don't have any modifiers rects on the font
    //
    if (prclExtra != NULL)
    {
        TRACE_OUT(( "Unsupported extra rects"));
        DC_QUIT;
    }

    //
    // Check that text orientation is OK.
    //
    if (pstro->flAccel & OE_BAD_TEXT_MASK)
    {
        TRACE_OUT(("DrvTextOut - unsupported flAccel 0x%08x", pstro->flAccel));
        DC_QUIT;
    }

    //
    // Check we have a valid string.
    //
    if (pstro->pwszOrg == NULL)
    {
        TRACE_OUT(( "No string - opaque %x", prclOpaque));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // Convert the string to an ANSI representation.
    //
    RtlFillMemory(ansiString, sizeof(ansiString), 0);
    EngUnicodeToMultiByteN(ansiString,
                           maxLength,
                           &ansiLen,
                           pstro->pwszOrg,
                           pstro->cGlyphs * sizeof(WCHAR));


    //
    // The conversion claims it never fails, but we have seen results that
    // are completely different on the remote box.  So we convert the ANSI
    // string back to UNICODE and check that we still have what we started
    // with.
    //
    EngMultiByteToUnicodeN(g_oeTempString,
                           sizeof(g_oeTempString),
                           &tempLen,
                           ansiString,
                           ansiLen);

    //
    // Check we don't have too much data, or that the translation failed to
    // give the correct data.  This happens when we try to translate
    // UNICODE text.
    //
    if ( (tempLen != pstro->cGlyphs * sizeof(WCHAR))           ||
         (memcmp(pstro->pwszOrg, g_oeTempString, tempLen) != 0) )
    {
        TRACE_OUT(( "String not translated"));
        DC_QUIT;
    }

    //
    // Check that the font is valid.
    //
    if (!OECheckFontIsSupported(pfo, ansiString, ansiLen,
                                &fontHeight,
                                &fontAscender,
                                &fontWidth,
                                &fontWeight,
                                &fontFlags,
                                &fontIndex,
                                &sendDeltaX))
    {
        TRACE_OUT(( "Unsupported font for '%s'", ansiString));
        //
        // Check if there is an opaque rectangle. If so it is worth
        // splitting this out. Word can output an entire line comprising a
        // single character followed by background, eg bullets, where the
        // line is blanked by drawing the bullet character at the start of
        // the line followed by a large - >1000 pixel - opaque rect.
        // Splitting the opaque rect from the text means we can send a
        // small area of SD for the unmatched font char while encoding the
        // large opaque rectangle.
        //
        if ( (prclOpaque != NULL) &&
             (pstro->cGlyphs == 1) &&
             (pstro->flAccel & SO_HORIZONTAL) &&
             OE_SendAsOrder(ORD_PATBLT))
        {
            //
            // There is an opaque rectangle and a single char.
            // Encode the opaque rectangle. First get a copy of the target
            // rect so we can use it later (and flip it into screen
            // coordinates).
            //
            TRACE_OUT(( "Have 1 char + opaque rect"));
            rectText.left = rectDst.left;
            rectText.top = rectDst.top;
            rectText.right = rectDst.right + 1;
            rectText.bottom = rectDst.bottom + 1;

            //
            // Call into the PATBLT encoding function.
            //
            if ( !OEEncodePatBlt(ppdev,
                                 pboOpaque,
                                 pptlOrg,
                                 OE_COPYPEN_ROP,
                                 &rectDst,
                                 &pOpaqueOrder) )
            {
                //
                // Something went wrong with the encoding, so skip to the
                // end to add this operation to the SDA.
                //
                TRACE_OUT(( "Failed to encode opaque rect"));
                DC_QUIT;
            }

            //
            // Store the general order data.  The bounding rectagle
            // co-ordinates must be virtual desktop.  OELRtoVirtual has
            // already converted rect for us.
            //
            TSHR_RECT16_FROM_RECT(&pOpaqueOrder->OrderHeader.Common.rcsDst, rectDst);

            //
            // Add the order to the cache.
            //
            OEClipAndAddOrder(pOpaqueOrder, NULL, pco);

            //
            // Calculate the bounds of the text. Get the glyph positions
            // for the left and right, and assume the top and bottom equate
            // approximately to the opaque rectangle.
            //
            if ( pstro->pgp == NULL)
            {
                //
                // The string object doesn't contain the GLYPHPOS info, so
                // enumerate the glyphs.
                //
                TRACE_OUT(( "Enumerate glyphs"));
                STROBJ_vEnumStart(pstro);
                STROBJ_bEnum(pstro, &count, &pGlyphData);
            }
            else
            {
                //
                // The string object already contains the GLYPHPOS info, so
                // just grab the pointer to it.
                //
                pGlyphData = pstro->pgp;
            }

            rectDst = rectText;
            rectDst.left = max(rectDst.left, pGlyphData[0].ptl.x);
            if ( pstro->ulCharInc == 0 )
            {
                //
                // No character increment for this string object. Just use
                // the maximum glyph width to calculate the right bounding
                // edge.
                //
                TRACE_OUT(( "no charinc glyph %d trg %d left %d maxX %d",
                                                   pGlyphData[0].ptl.x,
                                                   rectDst.right,
                                                   rectDst.left,
                                                   pfo->cxMax));
                rectDst.right = min(rectDst.right, (int)(pGlyphData[0].ptl.x +
                                                              pfo->cxMax - 1));
            }
            else
            {
                //
                // The string object has a character increment, so use it
                // to determine the right bounding edge.
                //
                TRACE_OUT(( "charinc %x glyph %d trg %d left %d",
                                                    pstro->ulCharInc,
                                                    pGlyphData[0].ptl.x,
                                                    rectDst.right,
                                                    rectDst.left));
                rectDst.right = min(rectDst.right, (int)(pGlyphData[0].ptl.x +
                                                        pstro->ulCharInc - 1));
            }

            //
            // Flip the target rectangle back to virtual coordinates.
            //
            rectDst.right -= 1;
            rectDst.bottom -= 1;
        }

        //
        // Skip to the end to add to the SDA.
        //
        DC_QUIT;
    }

    //
    // It is possible that the font matching blows our previous decision to
    // generate a TextOut order and we need to generate an ExtTextOut order
    // instead.  We need to reverify our parameters if this is the case.
    //
    if ((sendDeltaX) && (orderType != ORD_EXTTEXTOUT))
    {
        TRACE_OUT(( "Text order must be EXTTEXTOUT"));

        //
        // Set up for ExtTexOut orders.
        //
        orderType = ORD_EXTTEXTOUT;
        maxLength = ORD_MAX_STRING_LEN_WITH_DELTAS;

        //
        // Check if we are allowed to send this order (determined by the
        // negotiated capabilities of all the machines in the conference).
        //
        if (!OE_SendAsOrder(orderType))
        {
            TRACE_OUT(( "Text order %x not allowed", orderType));
            DC_QUIT;
        }

        //
        // Make sure we haven't blown the order size.
        //
        if (pstro->cGlyphs > maxLength)
        {
            TRACE_OUT(( "Text limit blown", pstro->cGlyphs));
            DC_QUIT;
        }
    }

    //
    // Get the proper start position for the text.
    //
    if ( pstro->pgp == NULL)
    {
        STROBJ_vEnumStart(pstro);
        STROBJ_bEnum(pstro, &count, &pGlyphData);
        if (count == 0)
        {
            WARNING_OUT(( "No glyphs"));
            DC_QUIT;
        }
    }
    else
    {
        pGlyphData = pstro->pgp;
    }

    startPoint.x = pGlyphData[0].ptl.x;

    //
    // Check if we should be using baseline alignment for the y
    // coordinate.  If we should be, the value in the glyph data is
    // correct.  If not, we the y coordinate is for the top of the
    // text, and we have to calculate it.
    //
    if (g_oeBaselineTextEnabled)
    {
        startPoint.y = pGlyphData[0].ptl.y;
        fontFlags   |= NF_BASELINE;
    }
    else
    {
        startPoint.y = pGlyphData[0].ptl.y - fontAscender;
    }

    //
    // Allocate memory for the order
    //
    switch (orderType)
    {
        case ORD_TEXTOUT:
        {
            //
            // Allocate the memory
            //
            pOrder = OA_DDAllocOrderMem((UINT)( sizeof(TEXTOUT_ORDER)
                                          - ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                                          + ansiLen ),
                                      0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pTextOut = (LPTEXTOUT_ORDER)pOrder->abOrderData;

            //
            // Set up the order type.
            //
            pTextOut->type    = ORD_TEXTOUT_TYPE;

            //
            // Get a pointer to the fields which are common to both TextOut
            // and ExtTextOut
            //
            pCommon           = &pTextOut->common;
        }
        break;


        case ORD_EXTTEXTOUT:
        {
            //
            // BOGUS LAURABU
            // This allocates space for a deltax array whether or not one is needed
            //
            //
            // Allocate the memory
            //
            pOrder = OA_DDAllocOrderMem((UINT)( sizeof(EXTTEXTOUT_ORDER)
                                      -  ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                                      - (ORD_MAX_STRING_LEN_WITH_DELTAS
                                                            * sizeof(TSHR_INT32))
                                      + ansiLen * (sizeof(TSHR_INT32) + 1)
                                      + 4),   // Allow for internal padding
                                      0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pExtTextOut = (LPEXTTEXTOUT_ORDER)pOrder->abOrderData;

            //
            // Set up the order type.
            //
            pExtTextOut->type = ORD_EXTTEXTOUT_TYPE;

            //
            // Get a pointer to the fields which are common to both TextOut
            // and ExtTextOut
            //
            pCommon           = &pExtTextOut->common;
        }
        break;

        default:
        {
            ERROR_OUT(( "Unknown order %x", orderType));
            DC_QUIT;
        }
        break;
    }

    //
    // Fill in the fields which are common to both TextOut and ExtTextOut
    //
    // Convert to virtual coordinates
    //
    OELPtoVirtual(&startPoint, 1);

    //
    // The x and y values are available in virtual coords from the bounds
    // rectangle.
    //
    pCommon->nXStart = startPoint.x;
    pCommon->nYStart = startPoint.y;

    //
    // Get the text colours.
    //
    OEConvertColor(ppdev,
                   &pCommon->BackColor,
                   pboOpaque->iSolidColor,
                   NULL);
    OEConvertColor(ppdev,
                   &pCommon->ForeColor,
                   pboFore->iSolidColor,
                   NULL);

    //
    // The transparency of the operation is determined by whether we have
    // an opaque rectangle or not.
    //
    pCommon->BackMode    = (prclOpaque == NULL) ? TRANSPARENT : OPAQUE;

    //
    // NT has a character extra spacing, not a generic for every character
    // spacing.  So, we always set this value to 0.
    //
    pCommon->CharExtra   = 0;

    //
    // NT does not provide a break of any sorts.
    //
    pCommon->BreakExtra  = 0;
    pCommon->BreakCount  = 0;

    //
    // Copy the font details
    //
    pCommon->FontHeight  = fontHeight;
    pCommon->FontWidth   = fontWidth;
    pCommon->FontWeight  = fontWeight;
    pCommon->FontFlags   = fontFlags;
    pCommon->FontIndex   = fontIndex;

    //
    // Now fill in the order specific data
    //
    switch (orderType)
    {
        case ORD_TEXTOUT:

            //
            // Copy across the text string.
            //
            pTextOut->variableString.len = (BYTE)ansiLen;
            RtlCopyMemory(pTextOut->variableString.string,
                          ansiString,
                          ansiLen);

            //
            // Make sure we send the order
            //
            fSendOrder = TRUE;

            TRACE_OUT(( "TEXTOUT: X %u Y %u bm %u FC %02X%02X%02X "
                         "BC %02X%02X%02X",
                         pTextOut->common.nXStart,
                         pTextOut->common.nYStart,
                         pTextOut->common.BackMode,
                         pTextOut->common.ForeColor.red,
                         pTextOut->common.ForeColor.green,
                         pTextOut->common.ForeColor.blue,
                         pTextOut->common.BackColor.red,
                         pTextOut->common.BackColor.green,
                         pTextOut->common.BackColor.blue));

            TRACE_OUT(( "Font: fx %u fy %u fw %u ff %04x fh %u len %u",
                         pTextOut->common.FontWidth,
                         pTextOut->common.FontHeight,
                         pTextOut->common.FontWeight,
                         pTextOut->common.FontFlags,
                         pTextOut->common.FontIndex,
                         ansiLen));

            TRACE_OUT(( "String '%s'", ansiString));
            break;

        case ORD_EXTTEXTOUT:
            //
            // Since our text is only ever fully contained within the
            // opaque rectangle, we only set the opaque flag (and ignore
            // the clipping).
            //
            pExtTextOut->fuOptions = (prclOpaque == NULL) ? 0 : ETO_OPAQUE;

            //
            // Set up the bounding rectangle for the operation.
            // EXT_TEXT_OUT orders use TSHR_RECT32s, hence we can't directly
            // assign rectDst to it.
            //
            pExtTextOut->rectangle.left     = rectDst.left;
            pExtTextOut->rectangle.top      = rectDst.top;
            pExtTextOut->rectangle.right    = rectDst.right;
            pExtTextOut->rectangle.bottom   = rectDst.bottom;

            //
            // Copy across the text string.
            //
            pExtTextOut->variableString.len = ansiLen;
            RtlCopyMemory(pExtTextOut->variableString.string,
                          ansiString,
                          ansiLen);

            //
            // WHOOP WHOOP WHOOP - Prepare to shut your eyes...
            //
            // Although we have a defined fixed length structure for
            // storing ExtTextOut orders, we must not send the full
            // structure over the network as the text will only be, say, 10
            // characters while the structure contains room for 127.
            //
            // Hence we pack the structure now to remove all the blank data
            // BUT we must maintain the natural alignment of the variables.
            //
            // So we know the length of the string which we can use to
            // start the new delta structure at the next 4-byte boundary.
            //
            lpVariable = ((LPBYTE)(&pExtTextOut->variableString))
                       + ansiLen
                       + sizeof(pExtTextOut->variableString.len);

            lpVariable = (LPSTR)
                         DC_ROUND_UP_4((UINT_PTR)lpVariable);

            lpDeltaPos = (LPVARIABLE_DELTAX)lpVariable;

            //
            // Do we need a delta array, or are the chars at their default
            // positions.
            //
            if ( sendDeltaX ||
                 ((pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT) == 0) )
            {
                //
                // Store the length of the position deltas.
                //
                lpDeltaPos->len = ansiLen * sizeof(TSHR_INT32);

                //
                // Set up the position deltas.
                //
                STROBJ_vEnumStart(pstro);
                fMoreData    = TRUE;
                currentDelta = 0;
                while (fMoreData)
                {
                    //
                    // Get the next set of glyph data
                    //
                    fMoreData = STROBJ_bEnum(pstro, &count, &pGlyphData);
                    for (i = 0; i < count; i++)
                    {
                        //
                        // The first time through we must set up the first
                        // glyph position.
                        //
                        if ((currentDelta == 0) && (i == 0))
                        {
                            lastPtl.x = pGlyphData[0].ptl.x;
                            lastPtl.y = pGlyphData[0].ptl.y;

                            TRACE_OUT(( "First Pos %d", lastPtl.x));
                        }
                        else
                        {
                            //
                            // For subsequent entries, we need to add the
                            // delta on the X position to the array.
                            //
                            if (pstro->ulCharInc == 0)
                            {
                                 lpDeltaPos->deltaX[currentDelta]
                                                         = pGlyphData[i].ptl.x
                                                         - lastPtl.x;

                                //
                                // Check for delta Y's - which we can't
                                // encode
                                //
                                if (pGlyphData[i].ptl.y - lastPtl.y)
                                {
                                    WARNING_OUT(( "New Y %d",
                                                 pGlyphData[i].ptl.y));
                                    OA_DDFreeOrderMem(pOrder);
                                    DC_QUIT;
                                }

                                //
                                // Store the last position for the next
                                // time round.
                                //
                                lastPtl.x = pGlyphData[i].ptl.x;
                                lastPtl.y = pGlyphData[i].ptl.y;

                                TRACE_OUT(( "Next Pos %d %d", i, lastPtl.x));
                            }
                            else
                            {
                                lpDeltaPos->deltaX[currentDelta]
                                                           = pstro->ulCharInc;
                            }

                            currentDelta++;
                        }
                    }
                }

                //
                // For the last entry, we need to set up the data by hand
                // (there are only n-1 deltas for n chars)
                //
                // This is done for compatibility with Windows 95 which
                // requires the last delta to be the delta to the place
                // where the next char would be if there were n+1 chars in
                // the string.
                //
                if (pstro->ulCharInc == 0)
                {
                    //
                    // No characters left - fudge a value of the width of
                    // the last character.
                    //
                    lpDeltaPos->deltaX[currentDelta] =
                                 pGlyphData[count-1].pgdf->pgb->sizlBitmap.cx;
                }
                else
                {
                    //
                    // All chars are evenly spaced, so just stick the value
                    // in.
                    //
                    lpDeltaPos->deltaX[currentDelta] = pstro->ulCharInc;
                }

                //
                // WHOOP WHOOP WHOOP - You can open your eyes now...
                //

                //
                // We must indicate the presence of this field to the
                // receiver.
                //
                pExtTextOut->fuOptions |= ETO_LPDX;
            }
            else
            {
                //
                // Mark the delta array as empty.
                //
                lpDeltaPos->len = 0;
            }

            //
            // WHOOP WHOOP WHOOP - You can open your eyes now...
            //


            //
            // Make sure we send the order
            //
            fSendOrder = TRUE;

            TRACE_OUT(( "EXTTEXTOUT: X %u Y %u bm %u FC %02X%02X%02X "
                         "BC %02X%02X%02X",
                         pExtTextOut->common.nXStart,
                         pExtTextOut->common.nYStart,
                         pExtTextOut->common.BackMode,
                         pExtTextOut->common.ForeColor.red,
                         pExtTextOut->common.ForeColor.green,
                         pExtTextOut->common.ForeColor.blue,
                         pExtTextOut->common.BackColor.red,
                         pExtTextOut->common.BackColor.green,
                         pExtTextOut->common.BackColor.blue));

            TRACE_OUT(( "Extra: Opt %x X1 %d Y1 %d X2 %d Y2 %d",
                         pExtTextOut->fuOptions,
                         pExtTextOut->rectangle.left,
                         pExtTextOut->rectangle.top,
                         pExtTextOut->rectangle.right,
                         pExtTextOut->rectangle.bottom));

            TRACE_OUT(( "Font: fx %u fy %u fw %u ff %04x fh %u len %u",
                         pExtTextOut->common.FontWidth,
                         pExtTextOut->common.FontHeight,
                         pExtTextOut->common.FontWeight,
                         pExtTextOut->common.FontFlags,
                         pExtTextOut->common.FontIndex,
                         ansiLen));

            TRACE_OUT(( "String '%s'", ansiString));
            break;

        default:
            ERROR_OUT(( "Unknown order %x", orderType));
            break;
    }

DC_EXIT_POINT:
    //
    // If we did not send an order, we must accumulate the output in the
    // Screen Data Area.
    //
    if (fSendOrder)
    {
        //
        // Store the general order data.  The bounding rectangle position
        // must be in virtual desktop co-ordinates.  OELRtoVirtual has
        // already done this.
        //
        pOrder->OrderHeader.Common.fOrderFlags   = OF_SPOILABLE;
        TSHR_RECT16_FROM_RECT(&pOrder->OrderHeader.Common.rcsDst, rectDst);

        //
        // Add the order to the cache.
        //
        OEClipAndAddOrder(pOrder, NULL, pco);
    }
    else
    {
        if (fAccumulate)
        {
            OEClipAndAddScreenData(&rectDst, pco);
        }
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvTextOut, rc);
    return(rc);
}


//
// DrvLineTo - see NT DDK documentation.
//
BOOL DrvLineTo(SURFOBJ   *pso,
                     CLIPOBJ   *pco,
                     BRUSHOBJ  *pbo,
                     LONG       x1,
                     LONG       y1,
                     LONG       x2,
                     LONG       y2,
                     RECTL     *prclBounds,
                     MIX        mix)
{
    LPOSI_PDEV      ppdev = (LPOSI_PDEV)pso->dhpdev;
    BOOL           rc = TRUE;
    RECT         rectDst;
    POINT           startPoint;
    POINT           endPoint;
    BOOL          fAccumulate = FALSE;

    DebugEntry(DrvLineTo);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, (*prclBounds));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert the data to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(ORD_LINETO))
    {
        TRACE_OUT(( "LineTo order not allowed"));
        DC_QUIT;
    }

    //
    // Check for a valid brush for the test operation.
    //
    if (pbo->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for line"));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // Set up data for order
    //
    startPoint.x = x1;
    startPoint.y = y1;
    endPoint.x   = x2;
    endPoint.y   = y2;

    //
    // Store that order.
    //
    if (!OEAddLine(ppdev,
              &startPoint,
              &endPoint,
              &rectDst,
              mix & 0x1F,
              1,
              pbo->iSolidColor,
              pco))
    {
        TRACE_OUT(( "Failed to add order - use SDA"));
        DC_QUIT;
    }

    //
    // We have stored this object, so don't store the data in the SDA
    // again.
    //
    fAccumulate = FALSE;

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvLineTo, rc);
    return(rc);
}


//
// DrvStrokePath - see NT DDK documentation.
//
BOOL DrvStrokePath(SURFOBJ   *pso,
                         PATHOBJ   *ppo,
                         CLIPOBJ   *pco,
                         XFORMOBJ  *pxo,
                         BRUSHOBJ  *pbo,
                         POINTL    *pptlBrushOrg,
                         LINEATTRS *plineattrs,
                         MIX        mix)
{
    LPOSI_PDEV      ppdev = (LPOSI_PDEV)pso->dhpdev;
    BOOL           rc = TRUE;
    RECTFX         rectfxTrg;
    RECT         rectDst;
    BOOL           fMore = TRUE;
    PATHDATA       pathData;
    POINT        startPoint;
    POINT        nextPoint;
    POINT        endPoint;
    BOOL         fAccumulate = FALSE;
    UINT         i;

    DebugEntry(DrvStrokePath);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    PATHOBJ_vGetBounds(ppo, &rectfxTrg);
    RECT_FROM_RECTFX(rectDst, rectfxTrg);

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(ORD_LINETO))
    {
        TRACE_OUT(( "LineTo order not allowed"));
        DC_QUIT;
    }

    //
    // Check for a valid brush for the test operation.
    //
    if (pbo->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for line"));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // See if we can optimize the path...
    //
    // We cannot send:
    //
    // - curvy lines (i.e. beziers)
    // - lines with funny end patterns (i.e. geometric lines)
    // - non Windows standard patterns
    //
    if ( ((ppo->fl        & PO_BEZIERS)   == 0) &&
         ((plineattrs->fl & LA_GEOMETRIC) == 0) &&
         (plineattrs->pstyle              == NULL) )
    {
        //
        // This is a set of solid cosmetic (i.e.  no fancy end styles)
        // lines.  Let's send those orders.
        //
        // NT stores all paths as a set of independent sub-paths.  Each
        // sub-path can start at a new point that is NOT linked to the
        // previous sub-path.
        //
        // Paths used for this function (as opposed to DrvFillPath or
        // DrvStrokeAndFillPath) do not need to be closed.
        //
        PATHOBJ_vEnumStart(ppo);

        while (fMore)
        {
            //
            // Get the next set of lines
            //
            fMore = PATHOBJ_bEnum(ppo, &pathData);

            TRACE_OUT(( "PTS: %lu FLAG: %08lx",
                         pathData.count,
                         pathData.flags));

            //
            // If this is the start of a path, remember the point in case
            // we need to close the path at the end.
            //
            if (pathData.flags & PD_BEGINSUBPATH)
            {
                POINT_FROM_POINTFIX(startPoint, pathData.pptfx[0]);
                POINT_FROM_POINTFIX(nextPoint,  pathData.pptfx[0]);
            }

            //
            // Generate orders for each line in the path.
            //
            for (i = 0; i < pathData.count; i++)
            {
                POINT_FROM_POINTFIX(endPoint, pathData.pptfx[i]);

                if ( (nextPoint.x != endPoint.x) ||
                     (nextPoint.y != endPoint.y) )
                {
                    if (!OEAddLine(ppdev,
                                   &nextPoint,
                                   &endPoint,
                                   &rectDst,
                                   mix & 0x1f,
                                   plineattrs->elWidth.l,
                                   pbo->iSolidColor,
                                   pco))
                    {
                        DC_QUIT;
                    }
                }

                nextPoint.x = endPoint.x;
                nextPoint.y = endPoint.y;
            }

            //
            // Close the path if necessary.
            //
            if ((pathData.flags & PD_CLOSEFIGURE) != 0)
            {
                if (!OEAddLine(ppdev,
                               &endPoint,
                               &startPoint,
                               &rectDst,
                               mix & 0x1f,
                               plineattrs->elWidth.l,
                               pbo->iSolidColor,
                               pco))
                {
                    DC_QUIT;
                }
            }
        }

        //
        // We have processed the entire thing as orders - don't send screen
        // data.
        //
        fAccumulate = FALSE;
    }

DC_EXIT_POINT:
    if (fAccumulate)
    {
        //
        // Convert the bounds to virtual coordinates.
        //
        OELRtoVirtual(&rectDst, 1);
        TRACE_OUT(( "SDA: (%d,%d)(%d,%d)",
                     rectDst.left,
                     rectDst.top,
                     rectDst.right,
                     rectDst.bottom));

        //
        // Update the Screen Data Area
        //
        OEClipAndAddScreenData(&rectDst, pco);

    }
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvStrokePath, rc);
    return(rc);
}


//
// DrvFillPath - see NT DDK documentation.
//
BOOL DrvFillPath(SURFOBJ  *pso,
                       PATHOBJ  *ppo,
                       CLIPOBJ  *pco,
                       BRUSHOBJ *pbo,
                       POINTL   *pptlBrushOrg,
                       MIX       mix,
                       FLONG     flOptions)
{
    BOOL    rc = TRUE;
    RECTFX  rectfxTrg;
    RECT  rectDst;

    DebugEntry(DrvFillPath);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    PATHOBJ_vGetBounds(ppo, &rectfxTrg);
    RECT_FROM_RECTFX(rectDst, rectfxTrg);

    //
    // Check if we are accumulating data for this function
    //
    if (!OEAccumulateOutput(pso, pco, &rectDst))
    {
        DC_QUIT;
    }

    //
    // Convert the bounds to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);
    TRACE_OUT(( "SDA: (%d,%d)(%d,%d)",
                 rectDst.left,
                 rectDst.top,
                 rectDst.right,
                 rectDst.bottom));

    //
    // Update the Screen Data Area
    //
    OEClipAndAddScreenData(&rectDst, pco);

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvFillPath, rc);
    return(rc);
}


//
// DrvStrokeAndFillPath - see NT DDK documentation.
//
BOOL DrvStrokeAndFillPath(SURFOBJ   *pso,
                                PATHOBJ   *ppo,
                                CLIPOBJ   *pco,
                                XFORMOBJ  *pxo,
                                BRUSHOBJ  *pboStroke,
                                LINEATTRS *plineattrs,
                                BRUSHOBJ  *pboFill,
                                POINTL    *pptlBrushOrg,
                                MIX        mixFill,
                                FLONG      flOptions)
{
    BOOL    rc = TRUE;
    RECTFX  rectfxTrg;
    RECT  rectDst;

    DebugEntry(DrvStrokeAndFillPath);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    PATHOBJ_vGetBounds(ppo, &rectfxTrg);
    RECT_FROM_RECTFX(rectDst, rectfxTrg);

    //
    // Check if we are accumulating data for this function
    //
    if (!OEAccumulateOutput(pso, pco, &rectDst))
    {
        DC_QUIT;
    }

    //
    // Convert the bounds to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Update the Screen Data Area
    //
    OEClipAndAddScreenData(&rectDst, pco);

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvStrokeAndFillPath, rc);
    return(rc);
}


//
// DrvPaint - see NT DDK documentation.
//
BOOL DrvPaint(SURFOBJ  *pso,
                    CLIPOBJ  *pco,
                    BRUSHOBJ *pbo,
                    POINTL   *pptlBrushOrg,
                    MIX       mix)
{
    BOOL    rc = TRUE;
    RECT  rectDst;
    BOOL  fAccumulate = FALSE;
    ROP4    rop4;

    DebugEntry(DrvPaint);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, pco->rclBounds);

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // The low byte of the mix represents a ROP2.  We need a ROP4 for
    // BitBlt, so convert the mix as follows.
    //
    // Remember the definitions of 2, 3 & 4 way ROP codes.
    //
    //  Msk Pat Src Dst
    //
    //  1   1   1   1    ͸ͻ         ROP2 uses P & D only
    //  1   1   1   0                  
    //  1   1   0   1    Ŀ                     ROP3 uses P, S & D
    //  1   1   0   0     ROP2-1ROP3  ROP4
    //  1   0   1   1     (see                 ROP4 uses M, P, S & D
    //  1   0   1   0     note)      
    //  1   0   0   1                  
    //  1   0   0   0    ;      
    //  0   1   1   1                   
    //  0   1   1   0                            NOTE: Windows defines its
    //  0   1   0   1                            ROP2 codes as the bitwise
    //  0   1   0   0                            value calculated here
    //  0   0   1   1                            plus one.  All other ROP
    //  0   0   1   0                            codes are the straight
    //  0   0   0   1                            bitwise value.
    //  0   0   0   0    ͼ
    //
    // Or, algorithmically...
    //
    // ROP3 = (ROP2 & 0x3) | ((ROP2 & 0xC) << 4) | (ROP2 << 2)
    //
    // ROP4 = (ROP3 << 8) | ROP3
    //
    mix  = (mix & 0x1F) - 1;
    rop4 = (mix & 0x3) | ((mix & 0xC) << 4) | (mix << 2);
    rop4 = (rop4 << 8) | rop4;

    //
    // This can be passed on to the BitBlt code.
    //
    rc = DrvBitBlt( pso,
                    NULL,
                    NULL,
                    pco,
                    NULL,
                    &pco->rclBounds,
                    NULL,
                    NULL,
                    pbo,
                    pptlBrushOrg,
                    rop4 );

    //
    // We have stored this object in the BitBlt, so don't store the data
    // again.
    //
    fAccumulate = FALSE;

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvPaint, rc);
    return(rc);
}


//
// OE_DDProcessRequest - see oe.h
//
ULONG OE_DDProcessRequest
(
    SURFOBJ* pso,
    UINT    cjIn,
    void *  pvIn,
    UINT    cjOut,
    void *  pvOut
)
{
    BOOL                    rc = TRUE;
    LPOSI_ESCAPE_HEADER      pHeader;

    DebugEntry(OE_DDProcessRequest);

    //
    // Get the request number.
    //
    pHeader = pvIn;
    switch (pHeader->escapeFn)
    {
        case OE_ESC_NEW_FONTS:
        {
            if ((cjIn != sizeof(OE_NEW_FONTS)) ||
                (cjOut != sizeof(OE_NEW_FONTS)))
            {
                ERROR_OUT(("OE_DDProcessRequest:  Invalid sizes %d, %d for OE_ESC_NEW_FONTS",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // Get new local font data
            //
            OEDDSetNewFonts(pvIn);
        }
        break;

        case OE_ESC_NEW_CAPABILITIES:
        {
            if ((cjIn != sizeof(OE_NEW_CAPABILITIES)) ||
                (cjOut != sizeof(OE_NEW_CAPABILITIES)))
            {
                ERROR_OUT(("OE_DDProcessRequest:  Invalid sizes %d, %d for OE_ESC_NEW_CAPABILITIES",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // The capabilities have changed - take the new copy.
            //
            OEDDSetNewCapabilities(pvIn);
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognised OE escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(OE_DDProcessRequest, rc);
    return((ULONG)rc);
}


//
// OE_DDTerm()
// This cleans up objects used
//
void OE_DDTerm(void)
{
    DebugEntry(OE_DDTerm);

    //
    // Free font list
    //
    if (g_poeLocalFonts)
    {
        TRACE_OUT(("OE_DDLocalHosting: freeing font block since we're done sharing"));
        EngFreeMem(g_poeLocalFonts);

        g_poeLocalFonts = NULL;
        g_oeNumFonts = 0;
    }

    DebugExitVOID(OE_DDTerm);
}


//
// DrvRealizeBrush - see NT DDK documentation.
//
BOOL DrvRealizeBrush(BRUSHOBJ *pbo,
                           SURFOBJ  *psoTarget,
                           SURFOBJ  *psoPattern,
                           SURFOBJ  *psoMask,
                           XLATEOBJ *pxlo,
                           ULONG    iHatch)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)psoTarget->dhpdev;
    BOOL      rc    = TRUE;
    LPBYTE  pData;
    BYTE   brushBits[8];
    UINT  color1;
    UINT  color2;
    int     i;
    int     j;
    BOOL    monochromeBrush = TRUE;

    DebugEntry(DrvRealizeBrush);

    //
    // This function only sets up local data, so shared memory protection
    // is not required.
    //

    //
    // Since this function is called only when we call BRUSHOBJ_pvGetRBrush
    // and we don't do any processing until we are in a share we don't need
    // an explicit check for hosting here ('coz that happened before the
    // call to realise the brush).
    //

    //
    // A valid brush satisfies either of the following criteria.
    //
    //  1) It is a standard hatch brush (as passed by DrvEnablePDEV)
    //  2) It is an 8x8 monochrome bitmap
    //

    //
    // Check for a Windows standard hatch
    //
    if (iHatch < HS_DDI_MAX)
    {
        TRACE_OUT(( "Standard hatch %lu", iHatch));
        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_HATCHED,
                          NULL,
                          pxlo,
                          (BYTE)iHatch,
                          0,
                          1);
        DC_QUIT;
    }

    //
    // If the driver has been passed a dither color brush we can support
    // this by sending a solid color brush definition
    //
    if ((iHatch & RB_DITHERCOLOR) != 0)
    {
        TRACE_OUT(( "Standard hatch %lu", iHatch));
        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_SOLID,
                          NULL,
                          NULL,
                          (BYTE)iHatch,
                          iHatch & 0xFFFFFF,
                          0);
        DC_QUIT;
    }


    //
    // Check for a simple 8x8 brush
    //
    if ( (psoPattern->sizlBitmap.cx == 8) &&
         (psoPattern->sizlBitmap.cy == 8) )
    {
        //
        // Check for 2 colours only in the bitmap.
        //
        // NOTE: There's a flag (BMF_TOPDOWN) in psoPattern->fjBitmap
        // that's supposed to indicate whether the bitmap is top-down or
        // bottom-up, but it is not always set up correctly.  In fact, the
        // bitmaps are always the wrong way up for our protocol, so we have
        // to flip them regardless of the flag.  Hence the row numbers are
        // reversed ('i' loops) in all the conversions below.
        //
        pData = psoPattern->pvScan0;
        switch (psoPattern->iBitmapFormat)
        {
            case BMF_1BPP:
            {
                //
                // 1 bpp MUST be 2 colours maximum.
                //
                color1 = 1;
                color2 = 0;
                for (i = 7; i >= 0; i--)
                {
                    brushBits[i] = *pData;
                    pData       += psoPattern->lDelta;
                }
            }
            break;

            case BMF_4BPP:
            {
                //
                // See if it is really a 2 colour brush.  Start off with
                // both colours the same.
                //
                color1 = pData[0] & 15;
                color2 = color1;

                //
                // Iterate through each row of the bitmap.
                //
                for (i = 7; (i >= 0) && (monochromeBrush); i--)
                {
                    brushBits[i] = 0;

                    //
                    // Check each pixel in the row: 4bpp->2 pixels per byte
                    //
                    for (j = 0; (j < 4) && (monochromeBrush); j++)
                    {
                        //
                        // Check the 1st pixel color
                        //
                        if ( (color1 != (UINT)(pData[j] & 0x0F)) &&
                             (color2 != (UINT)(pData[j] & 0x0F)) )
                        {
                            if (color1 == color2)
                            {
                                color2 = (pData[j] & 0x0F);
                            }
                            else
                            {
                                monochromeBrush = FALSE;
                            }
                        }

                        //
                        // Check the 2nd pixel color
                        //
                        if ( (color1 != (UINT)((pData[j] & 0xF0) >> 4)) &&
                             (color2 != (UINT)((pData[j] & 0xF0) >> 4)) )
                        {
                            if (color1 == color2)
                            {
                                color2 = (pData[j] & 0xF0) >> 4;
                            }
                            else
                            {
                                monochromeBrush = FALSE;
                            }
                        }

                        //
                        // Set up the brush data.  High bit is leftmost.
                        //
                        if ((UINT)(pData[j] & 0x0F) == color1)
                        {
                            brushBits[i] |= 0x40 >> (j * 2);
                        }
                        if ((UINT)(pData[j] & 0xF0) >> 4  == color1)
                        {
                            brushBits[i] |= 0x80 >> (j * 2);
                        }
                    }

                    //
                    // Get start of next row.
                    //
                    pData += psoPattern->lDelta;
                }
            }
            break;

            case BMF_8BPP:
            {
                //
                // See if it is really a 2 colour brush.  Start off with
                // both colours the same.
                //
                color1 = pData[0];
                color2 = color1;

                //
                // Iterate through each row of the bitmap.
                //
                for (i = 7; (i >= 0) && (monochromeBrush); i--)
                {
                    brushBits[i] = 0;

                    //
                    // Check each pixel in the row: 8bpp->1 pixel per byte
                    //
                    for (j = 0; (j < 8) && (monochromeBrush); j++)
                    {
                        //
                        // Check each pixel.
                        //
                        if ( (color1 != pData[j]) &&
                             (color2 != pData[j]) )
                        {
                            if (color1 == color2)
                            {
                                color2 = pData[j];
                            }
                            else
                            {
                                monochromeBrush = FALSE;
                            }
                        }

                        //
                        // Update the brush data.  High bit is leftmost.
                        //
                        if (pData[j] == color1)
                        {
                           brushBits[i] |= 0x80 >> j;
                        }
                    }

                    //
                    // Get start of next row.
                    //
                    pData += psoPattern->lDelta;
                }
            }
            break;

            default:
            {
                //
                // Unsupported colour depth.
                //
                monochromeBrush = FALSE;
            }
            break;
        }
    }
    else
    {
        //
        // The brush is the wrong size or requires dithering and so cannot
        // be sent over the wire.
        //
        monochromeBrush = FALSE;
    }

    //
    // Store that brush.
    //
    if (monochromeBrush)
    {
        //
        // Store the brush - note that we have a monochrome brush where the
        // color bit is set up so that 0 = color2 and 1 = color1.  This
        // actually corresponds to 0 = fg and 1 = bg for the protocol
        // colors.
        //
        TRACE_OUT(( "Storing brush: type %d bg %x fg %x",
                     psoPattern->iBitmapFormat,
                     color1,
                     color2));

        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_PATTERN,
                          brushBits,
                          pxlo,
                          0,
                          color2,
                          color1);
    }
    else
    {
        TRACE_OUT(( "Rejected brush h %08lx s (%ld, %ld) fmt %lu",
                     iHatch,
                     psoPattern != NULL ? psoPattern->sizlBitmap.cx : 0,
                     psoPattern != NULL ? psoPattern->sizlBitmap.cy : 0,
                     psoPattern != NULL ? psoPattern->iBitmapFormat : 0));
        rc = OEStoreBrush(ppdev, pbo, BS_NULL, NULL, pxlo, 0, 0, 0);
    }

DC_EXIT_POINT:

    DebugExitDWORD(DrvRealizeBrush, rc);
    return(rc);
}


//
// DrvSaveScreenBits - see NT DDK documentation.
//
ULONG_PTR DrvSaveScreenBits(SURFOBJ *pso,
                              ULONG    iMode,
                              ULONG_PTR    ident,
                              RECTL   *prcl)
{
    BOOL    rc;
    UINT  ourMode;
    RECT  rectDst;

    DebugEntry(DrvSaveScreenBits);

    TRACE_OUT(("DrvSaveScreenBits:  %s",
        ((iMode == SS_SAVE) ? "SAVE" :
            ((iMode == SS_RESTORE) ? "RESTORE" : "DISCARD"))));
    TRACE_OUT(("      rect        {%04ld, %04ld, %04ld, %04ld}",
        prcl->left, prcl->top, prcl->right, prcl->bottom));
    //
    // Default is TRUE, let SaveBits happen if we don't care.  Which we don't
    // if we have no shared memory (NetMeeting isn't running), no window list
    // (no shared apps), or the operation isn't intersecting a window we
    // care about.
    //
    // Note that if we return TRUE on a save, and FALSE on a restore later
    // (because we are now sharing that area for example), USER+GRE handle
    // that.  So it's ok.
    //
    rc = TRUE;

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    //
    // If we have no shared memory (NetMeeting isn't running), this will bail
    // out immediately.
    //

    OE_SHM_START_WRITING;


    //
    // Get the bounding rectangle for the operation.  NOTE that this is
    // meaningless for SS_FREE.
    //
    RECT_FROM_RECTL(rectDst, (*prcl));
    if (iMode != SS_FREE)
    {
        //
        // Check if we are accumulating data for this area, ONLY FOR
        // SAVEs.  We may get notified after a window is gone to
        // restore or discard bits we had saved.
        //
        if (!OEAccumulateOutputRect(pso, &rectDst))
        {
            TRACE_OUT(("DrvSaveScreenBits:  save/restore in area we don't care about"));
            DC_QUIT;
        }
    }

    //
    // Convert the NT orders to our generic save/restore types.
    //
    switch (iMode)
    {
        case SS_SAVE:
        {
            ourMode = ONBOARD_SAVE;
        }
        break;

        case SS_RESTORE:
        {
            ourMode = ONBOARD_RESTORE;
        }
        break;

        case SS_FREE:
        {
            ourMode = ONBOARD_DISCARD;
        }
        break;

        default:
        {
            ERROR_OUT(( "Unknown type %lu", iMode));
            DC_QUIT;
        }
    }

    //
    // Call through to the SSI handler.
    //
    rc = SSI_SaveScreenBitmap(&rectDst, ourMode);

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    TRACE_OUT(("DrvSaveScreenBits returning %d", rc));
    DebugExitDWORD(DrvSaveScreenBits, rc);
    return(rc);
}



//
// Function:    OEUnicodeStrlen
//
// Description: Get the length of a unicode string in bytes.
//
// Parameters:  pString - Unicode string to be read
//
// Returns:     Length of the Unicode string in bytes
//
int  OEUnicodeStrlen(PWSTR pString)
{
    int i;

    for (i = 0; pString[i] != 0; i++)
        ;

    return((i + 1) * sizeof(WCHAR));
}



//
// Function:    OEExpandColor
//
// Description: Converts a generic bitwise representation of an RGB color
//              index into an 8-bit color index as used by the line
//              protocol.
//
//
void  OEExpandColor
(
    LPBYTE  lpField,
    ULONG   srcColor,
    ULONG   mask
)
{
    ULONG   colorTmp;

    DebugEntry(OEExpandColor);

    //
    // Different example bit masks:
    //
    // Normal 24-bit:
    //      0x000000FF  (red)
    //      0x0000FF00  (green)
    //      0x00FF0000  (blue)
    //
    // True color 32-bits:
    //      0xFF000000  (red)
    //      0x00FF0000  (green)
    //      0x0000FF00  (blue)
    //
    // 5-5-5 16-bits
    //      0x0000001F  (red)
    //      0x000003E0  (green)
    //      0x00007C00  (blue)
    //
    // 5-6-5 16-bits
    //      0x0000001F  (red)
    //      0x000007E0  (green)
    //      0x0000F800  (blue)
    //
    //
    // Convert the color using the following algorithm.
    //
    // <new color> = <old color> * <new bpp mask> / <old bpp mask>
    //
    // where:
    //
    // new bpp mask = mask for all bits at new setting (0xFF for 8bpp)
    //
    // This way maximal (eg.  0x1F) and minimal (eg.  0x00) settings are
    // converted into the correct 8-bit maximum and minimum.
    //
    // Rearranging the above equation we get:
    //
    // <new color> = (<old color> & <old bpp mask>) * 0xFF / <old bpp mask>
    //
    // where:
    //
    // <old bpp mask> = mask for the color
    //

    //
    // LAURABU BOGUS:
    // We need to avoid overflow caused by the multiply.  NOTE:  in theory
    // we should use a double, but that's painfully slow.  So for now hack
    // it.  If the HIBYTE is set, just right shift 24 bits.
    //
    colorTmp = srcColor & mask;
    if (colorTmp & 0xFF000000)
        colorTmp >>= 24;
    else
        colorTmp = (colorTmp * 0xFF) / mask;
    *lpField = (BYTE)colorTmp;

    TRACE_OUT(( "0x%lX -> 0x%X", srcColor, *lpField));

    DebugExitVOID(OEExpandColor);
}


//
// Function:    OEConvertColor
//
// Description: Convert a color from the NT Display Driver into a TSHR_COLOR
//
// Parameters:  pDCColor  - (returned) color in protocol format
//              osColor   - color from the NT display driver
//              pxlo      - XLATEOBJ for the color to be converted
//                          (NULL if no translation is required)
//
// Returns:     (none)
//
void  OEConvertColor(LPOSI_PDEV ppdev, LPTSHR_COLOR pTshrColor,
                                         ULONG     osColor,
                                         XLATEOBJ* pxlo)
{
    ULONG    realIndex;

    DebugEntry(OEConvertColor);

    //
    // Make sure we have a default setting.
    //
    RtlFillMemory(pTshrColor, sizeof(TSHR_COLOR), 0);

    //
    // Check if color translation is required.
    //
    if ((pxlo != NULL) && (pxlo->flXlate != XO_TRIVIAL))
    {
        //
        // Convert from BMP to device color.
        //
        realIndex = XLATEOBJ_iXlate(pxlo, osColor);
        if (realIndex == -1)
        {
            ERROR_OUT(( "Failed to convert color 0x%lx", osColor));
            DC_QUIT;
        }
    }
    else
    {
        //
        // Use the OS color without translation
        //
        realIndex = osColor;
    }

    TRACE_OUT(( "Device color 0x%lX", realIndex));

    //
    // We now have the device specific version of the color.  Time to
    // convert it into a 24-bit RGB color as used by the line protocol.
    //
    switch (ppdev->iBitmapFormat)
    {
        case BMF_1BPP:
        case BMF_4BPP:
        case BMF_4RLE:
        case BMF_8BPP:
        case BMF_8RLE:
            //
            // Palette type device - use the device color as an index into
            // our palette array.
            //
            pTshrColor->red  = (BYTE)ppdev->pPal[realIndex].peRed;
            pTshrColor->green= (BYTE)ppdev->pPal[realIndex].peGreen;
            pTshrColor->blue = (BYTE)ppdev->pPal[realIndex].peBlue;
            break;

        case BMF_16BPP:
        case BMF_24BPP:
        case BMF_32BPP:
            //
            // Generic colour masks (could be eg.  5-6-5 for 16 or 8-8-8
            // for 24 bits per pel).  We must mask off the other bits and
            // shift down to bit 0.
            //
            OEExpandColor(&(pTshrColor->red),
                          realIndex,
                          ppdev->flRed);

            OEExpandColor(&(pTshrColor->green),
                          realIndex,
                          ppdev->flGreen);

            OEExpandColor(&(pTshrColor->blue),
                          realIndex,
                          ppdev->flBlue);
            break;

        default:
            ERROR_OUT(( "Unrecognised BMP color depth %lu",
                                                       ppdev->iBitmapFormat));
            break;
    }

    TRACE_OUT(( "Red %x green %x blue %x", pTshrColor->red,
                                            pTshrColor->green,
                                            pTshrColor->blue));

DC_EXIT_POINT:
    DebugExitVOID(OEConvertColor);
}


//
// Function:    OEStoreBrush
//
// Description: Store the brush data required for pattern realted orders.
//              This function is called by DrvRealiseBrush when it has data
//              to be stored about a brush.
//
// Parameters:  pbo        - BRUSHOBJ of the brush to be stored
//              style      - Style of the brush (as defined in the DC-Share
//                           protocol)
//              pBits      - Pointer to the bits which are used to define
//                           a BS_PATTERN brush.
//              pxlo       - XLATEOBJ for the brush.
//              hatch      - Standard Windows hatch pattern index for a
//                           BS_HATCHED brush.
//              color1     - index into XLATEOBJ for bit set color
//                           OR exact 24bpp color to use (pxlo == NULL)
//              color2     - index into XLATEOBJ for bit clear color
//                           OR exact 24bpp color to use (pxlo == NULL)
//
// Returns:     (none)
//
BOOL  OEStoreBrush(LPOSI_PDEV ppdev,
                                       BRUSHOBJ* pbo,
                                       BYTE   style,
                                       LPBYTE  pBits,
                                       XLATEOBJ* pxlo,
                                       BYTE   hatch,
                                       UINT  color1,
                                       UINT  color2)
{
    BOOL         rc = FALSE;
    int          i;
    LPBYTE       pData;
    ULONG*         pColorTable;
    POE_BRUSH_DATA pBrush;

    DebugEntry(OEStoreBrush);

    //
    // Allocate the space for the brush data.
    //
    pBrush = (POE_BRUSH_DATA)BRUSHOBJ_pvAllocRbrush(pbo,
                                                    sizeof(OE_BRUSH_DATA));
    if (pBrush == NULL)
    {
        ERROR_OUT(( "No memory"));
        DC_QUIT;
    }

    //
    // Reset the brush definition
    //
    RtlFillMemory(pBrush, sizeof(OE_BRUSH_DATA), 0);

    //
    // Set the new brush data.
    //
    pBrush->style = style;
    pBrush->hatch = hatch;

    TRACE_OUT(( " Style: %d Hatch: %d", style, hatch));

    //
    // For pattern brushes, copy the brush specific data.
    //
    if (style == BS_PATTERN)
    {
        //
        // Copy the brush bits.  Since this is an 8x8 mono bitmap, we can
        // copy the first byte of the brush data for each scan line.
        //
        // NOTE however that the brush structures sent over the wire
        // re-use the hatching variable as the first byte of the brush data.
        //
        pData         = pBits;
        pBrush->hatch = *pData;
        TRACE_OUT(( " Hatch: %d", *pData));

        pData++;

        for (i = 0; i < 7; i++)
        {
            pBrush->brushData[i] = pData[i];
            TRACE_OUT(( " Data[%d]: %d", i, pData[i]));
        }

        //
        // Get pointer to the bitmap color table.
        //
        pColorTable = pxlo->pulXlate;
        if (pColorTable == NULL)
        {
            pColorTable = XLATEOBJ_piVector(pxlo);
        }
    }

    //
    // Store the foreground and background colours for the brush.
    //
    if (pxlo != NULL)
    {
        //
        // Conversion required.
        //
        OEConvertColor(ppdev,
                       &pBrush->fore,
                       color1,
                       pxlo);

        OEConvertColor(ppdev,
                       &pBrush->back,
                       color2,
                       pxlo);
    }
    else
    {
        //
        // We have been passed an exact 24bpp color - this only happens for
        // solid brushes so we don't need to convert color2.
        //
        pBrush->fore.red   = (BYTE) (color1 & 0x0000FF);
        pBrush->fore.green = (BYTE)((color1 & 0x00FF00) >> 8);
        pBrush->fore.blue  = (BYTE)((color1 & 0xFF0000) >> 16);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OEStoreBrush, rc);
    return(rc);
}


//
// Function:    OECheckBrushIsSimple
//
// Description: Check that the brush is a 'simple' object we can transfer
//              over the DC-Share protocol.
//
// Parameters:  pbo - BRUSHOBJ of the brush to be checked.
//
// Returns:     TRUE  - brush can be sent as DC-Share order
//              FALSE - brush is too complicated.
//
BOOL  OECheckBrushIsSimple(LPOSI_PDEV       ppdev,
                                               BRUSHOBJ*       pbo,
                                               POE_BRUSH_DATA* ppBrush)
{
    BOOL         rc     = FALSE;
    POE_BRUSH_DATA pBrush = NULL;

    DebugEntry(OECheckBrushIsSimple);

    //
    // A 'simple' brush satisfies any of the following.
    //
    //  1) It is a solid color.
    //  2) It is a valid brush as stored by DrvRealizeBrush.
    //

    //
    // Check for a simple solid colour.
    //
    if (pbo->iSolidColor != -1)
    {
        //
        // Use the reserved brush definition to set up the solid colour.
        //
        TRACE_OUT(( "Simple solid colour %08lx", pbo->iSolidColor));
        pBrush = &g_oeBrushData;

        //
        // Set up the specific data for this brush.
        //
        OEConvertColor(ppdev, &pBrush->fore, pbo->iSolidColor, NULL);

        pBrush->back.red   = 0;
        pBrush->back.green = 0;
        pBrush->back.blue  = 0;

        pBrush->style      = BS_SOLID;
        pBrush->hatch      = 0;

        RtlFillMemory(pBrush->brushData, 7, 0);

        //
        // We have a valid brush - return true.
        //
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Check brush definition (which was stored when we realized the
    // brush).
    //
    pBrush = (POE_BRUSH_DATA)pbo->pvRbrush;
    if (pBrush == NULL)
    {
        pBrush = (POE_BRUSH_DATA)BRUSHOBJ_pvGetRbrush(pbo);
        if (pBrush == NULL)
        {
            //
            // We can get NULL returned from BRUSHOBJ_pvGetRbrush when the
            // brush is NULL or in low-memory situations (when the brush
            // realization may fail).
            //
            TRACE_OUT(( "NULL returned from BRUSHOBJ_pvGetRbrush"));
            DC_QUIT;
        }
    }

    //
    // Check it is an encodable brush.
    //
    if (pBrush->style == BS_NULL)
    {
        TRACE_OUT(( "Complex brush"));
        DC_QUIT;
    }

    //
    // Evrything passed - let's use this brush.
    //
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Return the brush definition
    //
    *ppBrush = pBrush;

    TRACE_OUT(( "Returning %d - 0x%08lx", rc, pBrush));

    DebugExitDWORD(OECheckBrushIsSimple, rc);
    return(rc);
}


//
// Function:    OEClippingIsSimple
//
// Description: Check to see if the clipping on the graphics object is
//              trivial
//
// Parameters:  pco - CLIPOBJ of the graphics object to be checked.
//
// Returns:     TRUE  - Clipping is trivial
//              FALSE - Clipping is complex
//
BOOL  OEClippingIsSimple(CLIPOBJ* pco)
{
    BOOL rc = TRUE;

    DebugEntry(OEClippingIsSimple);

    //
    // Check for a valid clip object
    //
    if (pco == NULL)
    {
        TRACE_OUT(( "No clipobj"));
        DC_QUIT;
    }

    //
    // Check for complexity of clipping
    //
    switch (pco->iDComplexity)
    {
        case DC_TRIVIAL:
        case DC_RECT:
            //
            // Trivial (ignore clipping) or simple (one square) clipping -
            // no worries.
            //
            TRACE_OUT(( "Simple clipping"));
            DC_QUIT;

        default:
            TRACE_OUT(( "Clipping is complex"));
            break;
    }

    //
    // Failed all tests - must be too complicated.
    //
    rc = FALSE;

DC_EXIT_POINT:
    DebugExitDWORD(OEClippingIsSimple, rc);
    return(rc);
}


//
// Function:    OEClippingIsComplex
//
// Description: Check to see if the clipping on the graphics object is too
//              complicated to be sent as an order or multiple orders.
//
// Parameters:  pco - CLIPOBJ of the graphics object to be checked.
//
// Returns:     TRUE  - Clipping is too complicated
//              FALSE - Clipping is sufficiently simple to send as orders
//
BOOL  OEClippingIsComplex(CLIPOBJ* pco)
{
    BOOL       rc         = FALSE;
    BOOL       fMoreRects;
    OE_ENUMRECTS clip;
    UINT       numRects = 0;

    DebugEntry(OEClippingIsComplex);

    //
    // If the any of the following are true, the clipping is not too
    // complicated.
    //
    //  1) The clip object does not exist.
    //  2) The clipping is trivial (the object exists, but there are no
    //     clipping rectangles).
    //  3) The clipping is a single rectangle.
    //  4) The object enumerates to less than 'n' rectangles.
    //

    //
    // Check for a valid clip object
    //
    if (pco == NULL)
    {
        TRACE_OUT(( "No clipobj"));
        DC_QUIT;
    }

    //
    // Check for complexity of clipping
    //
    switch (pco->iDComplexity)
    {
        case DC_TRIVIAL:
        case DC_RECT:
            //
            // Trivial or simple clipping - no worries.
            //
            TRACE_OUT(( "Simple clipping"));
            DC_QUIT;

        case DC_COMPLEX:
            //
            // Lots of rectangles - make sure that it is less than the
            // acceptable limit.
            // The documentation for this function incorrectly states that
            // the returned value is the total number of rectangles
            // comprising the clip region. In fact, -1 is always returned,
            // even when the final parameter is non-zero. This means we
            // have to enumerate to get the number of rects.
            //
            CLIPOBJ_cEnumStart(pco,
                               FALSE,
                               CT_RECTANGLES,
                               CD_ANY,
                               0);

            //
            // MSDN: It is possible for CLIPOBJ_bEnum to return TRUE with
            // the number of clipping rectangles equal to zero. In such
            // cases, the driver should call CLIPOBJ_bEnum again without
            // taking any action. Get as many rectangles as we permit for
            // order encoding - this loop should execute once only.
            // If the number of rects equals COMPLEX_CLIP_RECT_COUNT the
            // 1st invocation of CLIPOBJ_bEnum returns that there are more
            // rects and a second call returns there are no more without
            // returning any in addition to those returned on the first
            // call. Our buffer has space for COMPLEX_CLIP_RECT_COUNT+1
            // rects so we should never have to execute the loop more than
            // once.
            //
            do
            {
                fMoreRects = CLIPOBJ_bEnum(pco,
                                           sizeof(clip),
                                           (ULONG *)&clip.rects);
                numRects += clip.rects.c;
            } while ( fMoreRects && (numRects <= COMPLEX_CLIP_RECT_COUNT) );

            //
            // If there are no more rectangles in the clip region then the
            // clipping complexity is within our limits for order encoding.
            //
            if ( numRects <= COMPLEX_CLIP_RECT_COUNT )
            {
                TRACE_OUT(( "Acceptable clipping %u", numRects));
                DC_QUIT;
            }
            break;

        default:
            ERROR_OUT(( "Unknown clipping"));
            break;
    }

    //
    // Failed all tests - must be too complicated.
    //
    TRACE_OUT(( "Complex clipping"));
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OEClippingIsComplex, rc);
    return(rc);
}


//
// Function:    OEAccumulateOutput
//
// Description: Check to see if we should accumulate this output for
//              sending to the remote machine.
//
// Parameters:  pso   - Pointer to the target surface
//              pco   - Pointer to the clip object (may be NULL)
//              pRect - Pointer to the bounding rectangle of the operation
//
// Returns:     TRUE  - We should accumulate the output
//              FALSE - ignore the output
//
BOOL   OEAccumulateOutput(SURFOBJ* pso, CLIPOBJ *pco, LPRECT pRect)
{
    BOOL    rc = FALSE;
    POINT   pt = {0,0};
    ENUMRECTS clipRect;
    LPOSI_PDEV ppdev = ((LPOSI_PDEV)pso->dhpdev);

    DebugEntry(OEAccumulateOutput);

    //
    // Validate we have valid parameters to access the surface.
    //
    if (ppdev == NULL)
    {
        TRACE_OUT(( "NULL PDEV"));
        DC_QUIT;
    }

    //
    // Check for the screen surface, which will be a bitmap in the hosting
    // only code.
    //
    if (ppdev->hsurfScreen != pso->hsurf)
    {
        TRACE_OUT(( "Dest is not our surface"));
        DC_QUIT;
    }

    if (pso->dhsurf == NULL)
    {
        ERROR_OUT(( "NULL hSurf"));
        DC_QUIT;
    }

    //
    // Extract a single point from the clip object
    //
    if (pco == NULL)
    {
        //
        // No clip object - use a point from the bounding rectangle
        //
        pt.x = pRect->left;
        pt.y = pRect->top;
        TRACE_OUT(( "No clip object, point is %d, %d", pt.x, pt.y));
    }
    else if (pco->iDComplexity == DC_TRIVIAL)
    {
        //
        // Trivial clip object - use a point from the bounding rectangle
        //
        pt.x = pRect->left;
        pt.y = pRect->top;
        TRACE_OUT(( "Trivial clip object, point is %d, %d", pt.x, pt.y));
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        //
        // Single clip rectangle - use a point from it
        //
        // It appears that the clip rectangle is frequantly the entire
        // display.  This is about as much use as a chocolate teapot.  If
        // this is the case, use a point from the bounding rectangle
        // instead.
        //
        if ((pco->rclBounds.left == 0) && (pco->rclBounds.top == 0))
        {
            pt.x = pRect->left;
            pt.y = pRect->top;
            TRACE_OUT(( "Meaningless clip rect, point is %d, %d",
                    pt.x, pt.y));
        }
        else
        {
            pt.x = pco->rclBounds.left;
            pt.y = pco->rclBounds.top;
            TRACE_OUT(( "Single clip rect, point is %d, %d", pt.x, pt.y));
        }
    }
    else
    {
        //
        // Complex clip object - enumerate its first rectangle and use a
        // point from that.
        //
        TRACE_OUT(( "Complex clip rect - call cEnumStart"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        clipRect.c = 1;
        memset(clipRect.arcl, 0, sizeof(RECTL));
        TRACE_OUT(( "Complex clip rect - call bEnum"));
        CLIPOBJ_bEnum(pco, sizeof(clipRect), (ULONG *)(&clipRect));

        pt.x = clipRect.arcl[0].left;
        pt.y = clipRect.arcl[0].top;
        TRACE_OUT(( "Complex clip rect, point is %d, %d", pt.x, pt.y));
    }

    //
    // Check if we are accumulating this window.
    //
    rc = HET_DDOutputIsHosted(pt);

DC_EXIT_POINT:
    TRACE_OUT(("OEAccumulateOutput:  point {%d, %d} is %sshared",
        pt.x, pt.y, (rc ? "" : "NOT ")));
    DebugExitBOOL(OEAccumulateOutput, rc);
    return(rc);
}


//
// Function:    OEAccumulateOutputRect
//
// Description: Check to see if we should accumulate the given output rect
//              for sending to the remote machine.
//
//              Most drawing functions will use OEAccumulateOutput, which
//              just checks for a single point within the hosted area.
//              This function checks for any part of the given rectangle
//              intersecting with the hosted area.  It is currently only
//              used by DrvSaveScreenBitmap - operations which may not
//              lie completetely within the hosted area.
//
// Parameters:  pso   - Pointer to the target surface
//              pRect - Pointer to the bounding rectangle of the operation
//
// Returns:     TRUE  - We should accumulate the output
//              FALSE - ignore the output
//
BOOL   OEAccumulateOutputRect( SURFOBJ* pso, LPRECT pRect)
{
    BOOL    rc = FALSE;
    LPOSI_PDEV ppdev = ((LPOSI_PDEV)pso->dhpdev);

    DebugEntry(OEAccumulateOutputRect);

    //
    // Validate we have valid parameters to access the surface.
    //
    if (ppdev == NULL)
    {
        TRACE_OUT(( "NULL PDEV"));
        DC_QUIT;
    }

    //
    // Check for the screen surface, which will be a bitmap in the hosting
    // only code.
    //
    if (ppdev->hsurfScreen != pso->hsurf)
    {
        TRACE_OUT(( "Dest is not our surface"));
        DC_QUIT;
    }

    if (pso->dhsurf == NULL)
    {
        ERROR_OUT(( "NULL hSurf"));
        DC_QUIT;
    }

    //
    // Check if we are accumulating this window.
    //
    rc = HET_DDOutputRectIsHosted(pRect);

DC_EXIT_POINT:
    TRACE_OUT(("OEAccumulateOutputRect:  rect {%d, %d, %d, %d} is %sshared",
        pRect->left, pRect->top, pRect->right, pRect->bottom,
        (rc ? "" : "NOT ")));
    DebugExitBOOL(OEAccumulateOutputRect, rc);
    return(rc);
}


//
// Function:    OESendRop3AsOrder
//
// Description: Check if we are allowed to send this 3-way ROP.  A ROP may
//              be disallowed if it relies on the destination data.
//
// Parameters:  rop3 - the 3-way ROP to be checked.
//
// Returns:     TRUE  - We are allowed to send this ROP
//              FALSE - We can't send this ROP
//
BOOL  OESendRop3AsOrder(BYTE rop3)
{
    BOOL   rc = TRUE;

    DebugEntry(OESendRop3AsOrder);

    //
    // Rop 0x5F is used by MSDN to highlight search keywords.  This XORs
    // a pattern with the destination, producing markedly different (and
    // sometimes unreadable) shadow output.  We special-case no-encoding for
    // it.
    //
    if (rop3 == 0x5F)
    {
        TRACE_OUT(("Rop3 0x5F never encoded"));
        rc = FALSE;
    }

    DebugExitBOOL(OESendRop3AsOrder, rc);
    return(rc);
}




//
// Function:    OECheckFontIsSupported
//
// Description: Check if we are allowed to send this font.  Fonts are
//              disallowed while they are being negotiated on a new entry
//              to the share.
//
// Parameters:  pfo           - (IN)  the font to be checked
//              pFontText     - (IN)  text message to be sent
//              textLen       - (IN)  length of text message
//              pFontHeight   - (OUT) font height in points
//              pFontAscender - (OUT) font ascender in points
//              pFontWidth    - (OUT) ave font width in points
//              pFontWeight   - (OUT) font weight
//              pFontFlags    - (OUT) font style flags
//              pFontIndex    - (OUT) font table index
//              pSendDeltaX   - (OUT) Do we need to send delta X coords?
//
// Returns:     TRUE  - We are allowed to send this font
//              FALSE - We can't send this font
//
BOOL   OECheckFontIsSupported
(
    FONTOBJ*    pfo,
    LPSTR       pFontText,
    UINT        textLen,
    LPUINT      pFontHeight,
    LPUINT      pFontAscender,
    LPUINT      pFontWidth,
    LPUINT      pFontWeight,
    LPUINT      pFontFlags,
    LPUINT      pFontIndex,
    LPBOOL      pSendDeltaX
)
{
    BOOL            rc = FALSE;
    PIFIMETRICS     pFontMetrics;
    UINT            codePage;
    UINT            i;
    UINT            iLocal;
    UINT            matchQuality;
    UINT            charWidthAdjustment = 0;
    char            fontName[FH_FACESIZE];
    ULONG           fontNameLen;
    PWSTR           pUnicodeString;
    XFORMOBJ*       pxform;
    POINTL          xformSize[3];
    int             compareResult;
    FLOATOBJ_XFORM  xformFloatData;

    DebugEntry(OECheckFontIsSupported);

    //
    // Set up default return values
    //
    *pSendDeltaX = FALSE;

    //
    // Check that we have a valid list of font data from the remotes.
    //
    if (!g_oeTextEnabled)
    {
        TRACE_OUT(( "Fonts unavailable"));
        DC_QUIT;
    }

    //
    // Check for valid font attributes
    //
    pFontMetrics = FONTOBJ_pifi(pfo);
    if (pFontMetrics->fsSelection & FM_SEL_OUTLINED)
    {
        TRACE_OUT(( "Unsupported font style"));
        DC_QUIT;
    }

    //
    // The current protocol cannot apply a general 2-D transform to text
    // orders, so we must reject any weird ones such as:
    //
    // - rotations
    // - X or Y shears
    // - X or Y reflections
    // - scaling with a negative value.
    //
    // Or put another way, we only allow:
    //
    // - the identity transformation
    // - scaling with a positive value.
    //
    pxform = FONTOBJ_pxoGetXform(pfo);
    if (pxform != NULL)
    {
        //
        // Get the details of the transformation.  Note we can ignore the
        // translation vector as it does not affect the font sizing /
        // orientation, so we are only interested in the matrix values...
        //

        //
        // NOTE:  Do NOT use floating point explicitly!
        // Can't do float ops in ring 0 with normal lib for x86.
        // Use FLOATOBJs instead and corresponding Eng services.
        // On alpha, these are macros and are way fast in any case.
        //

        if (XFORMOBJ_iGetFloatObjXform(pxform, &xformFloatData) != DDI_ERROR)
        {
            //
            // Rotations and shears will have cross dependencies on the x
            // and y components.
            //
            if ( (!FLOATOBJ_EqualLong(&xformFloatData.eM12, 0)) ||
                 (!FLOATOBJ_EqualLong(&xformFloatData.eM21, 0)) )
            {
                TRACE_OUT(( "Rejected rotn/shear"));
                DC_QUIT;
            }

            //
            // Reflections and scaling operations with negative scale
            // factors will have negative values on the leading diagonal of
            // the matrix.
            //
            if ( (FLOATOBJ_LessThanLong(&xformFloatData.eM11, 0)) ||
                 (FLOATOBJ_LessThanLong(&xformFloatData.eM22, 0)) )
            {
                TRACE_OUT(( "Rejected refln/-ive"));
                DC_QUIT;
            }
        }
    }

    //
    // Get the current font code page for font matching.
    //
    switch (pFontMetrics->jWinCharSet)
    {
        case ANSI_CHARSET:
            TRACE_OUT(( "ANSI font"));
            codePage = NF_CP_WIN_ANSI;
            break;

        case OEM_CHARSET:
            TRACE_OUT(( "OEM font"));
            codePage = NF_CP_WIN_OEM;
            break;

        case SYMBOL_CHARSET:
            TRACE_OUT(("Symbol font"));
            codePage = NF_CP_WIN_SYMBOL;
            break;

        default:
            TRACE_OUT(( "Unknown CP %d", pFontMetrics->jWinCharSet));
            codePage = NF_CP_UNKNOWN;
            break;
    }

    //
    // Get the name of the font.
    //
    pUnicodeString = (PWSTR)( (LPBYTE)pFontMetrics +
                                        pFontMetrics->dpwszFamilyName );
    EngUnicodeToMultiByteN(fontName,
                           sizeof(fontName),
                           &fontNameLen,
                           pUnicodeString,
                           OEUnicodeStrlen(pUnicodeString));

    //
    // Search our Font Alias Table for the current family name.  If we find
    // it, replace it with the alias name from the table.
    //
    for (i = 0; i < NUM_ALIAS_FONTS; i++)
    {
        if (!strcmp((LPSTR)fontName,
                        (LPSTR)(fontAliasTable[i].pszOriginalFontName)))
        {
            TRACE_OUT(( "Alias name: %s -> %s",
                              (LPSTR)fontName,
                              (LPSTR)(fontAliasTable[i].pszAliasFontName)));
            strcpy((LPSTR)fontName,
                   (LPSTR)(fontAliasTable[i].pszAliasFontName));
            charWidthAdjustment = fontAliasTable[i].charWidthAdjustment;
            break;
        }
    }

    TRACE_OUT(( "Font name: '%s'", fontName));

    //
    // We have a font name to match with those we know to be available
    // remotely.  Try to jump straight to the first entry in the local font
    // table starting with the same character as this font.  If this index
    // slot is empty (i.e.  has a value of USHRT_MAX) then the loop will
    // immediately exit
    //
    TRACE_OUT(( "Looking for matching fonts"));

    for (iLocal = g_oeLocalFontIndex[(BYTE)fontName[0]];
         iLocal < g_oeNumFonts;
         iLocal++)
    {
        TRACE_OUT(( "Trying font number %hd", iLocal));

        //
        // If this font is not supported remotely then skip it.
        //
        ASSERT(g_poeLocalFonts);
        matchQuality = g_poeLocalFonts[iLocal].SupportCode;
        if (matchQuality == FH_SC_NO_MATCH)
        {
            continue;
        }

        //
        // See if we've got a facename match
        //
        compareResult =
                 strcmp(g_poeLocalFonts[iLocal].Details.nfFaceName, fontName);

        if (compareResult < 0)
        {
            //
            // We haven't found a match yet, but we haven't gone far enough
            // into this list.
            //
            continue;
        }
        else if (compareResult > 0)
        {
            //
            // We're past the part of the local font array that's applicable.
            // We didn't find a match, it must not exist.
            //
            break;
        }

        //
        // The font names match.  Now see if the other attributes do...
        //

        //
        // This is looking promising - a font with the right name is
        // supported on the remote system.
        //
        // Start building up the details in the global variables while
        // making further checks...
        //
        *pFontFlags  = 0;
        *pFontIndex = iLocal;
        *pFontWeight = pFontMetrics->usWinWeight;

        //
        // Check for a fixed pitch font.
        //
        if ((pFontMetrics->jWinPitchAndFamily & FIXED_PITCH) != 0)
        {
            *pFontFlags |= NF_FIXED_PITCH;
        }

        //
        // Is it a TrueType font?
        //
        if ((pfo->flFontType & TRUETYPE_FONTTYPE) != 0)
        {
            *pFontFlags |= NF_TRUE_TYPE;
        }

        //
        // Get the basic width and height.
        //
        xformSize[0].y = 0;
        xformSize[0].x = 0;
        xformSize[1].y = pFontMetrics->fwdUnitsPerEm;
        xformSize[1].x = pFontMetrics->fwdAveCharWidth;
        xformSize[2].y = pFontMetrics->fwdWinAscender;
        xformSize[2].x = 0;

        //
        // We now need to convert these sizes if the GDI has provided a
        // transform object.
        //
        if (pxform != NULL)
        {
            if (!XFORMOBJ_bApplyXform(pxform,
                                      XF_LTOL,
                                      3,
                                      &xformSize,
                                      &xformSize))
            {
                ERROR_OUT(( "Xform failed"));
                continue;
            }
        }

        //
        // Calculate the font width and height.
        //
        *pFontHeight = (UINT)(xformSize[1].y - xformSize[0].y);
        *pFontWidth  = (UINT)(xformSize[1].x - xformSize[0].x
                                                 - charWidthAdjustment);

        TRACE_OUT(( "Device font size %hdx%hd", *pFontWidth, *pFontHeight));

        //
        // Get the offset to the start of the text cell.
        //
        *pFontAscender = (UINT)(xformSize[2].y - xformSize[0].y);

        //
        // Check that we have a matching pair - where we require that the
        // fonts (ie the one being used by the application and the one
        // we've matched with the remote system) are the same pitch (ie
        // variable or fixed) and use the same technology (ie TrueType or
        // not).
        //
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_PITCH) !=
                ((TSHR_UINT16)(*pFontFlags) & NF_FIXED_PITCH))
        {
            TRACE_OUT(( "Fixed pitch mismatch"));
            continue;
        }
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_TRUE_TYPE) !=
                ((TSHR_UINT16)*pFontFlags & NF_TRUE_TYPE))
        {
            TRACE_OUT(( "True type mismatch"));
            continue;
        }

        //
        // We have a pair of fonts with the same attributes - either both
        // fixed pitch or both variable pitch - and using the same font
        // technology.
        //
        // If the font is fixed pitch then we must also check that this
        // particular size matches.
        //
        // If the font is not fixed pitch (scalable) then we assume that it
        // is matchable.
        //
        if (g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_SIZE)
        {
            //
            // The font is fixed size, so we must check that this
            // particular size is matchable.
            //
            if ( (*pFontHeight != g_poeLocalFonts[iLocal].Details.nfAveHeight) ||
                 (*pFontWidth  != g_poeLocalFonts[iLocal].Details.nfAveWidth)  )
            {
                //
                // The sizes differ, so we must fail this match.
                //
                TRACE_OUT(( "Size mismatch"));
                continue;
            }
        }

        //
        // Hey! We've got a matched pair!
        //
        rc = TRUE;
        TRACE_OUT(( "Found match at local font %hd", iLocal));
        break;
    }

    if (rc != TRUE)
    {
        TRACE_OUT(( "Couldn't find matching font in table"));
        DC_QUIT;
    }

    //
    // Build up the rest of the font flags.  We have already put the pitch
    // flag in place.
    //
    if ( ((pFontMetrics->fsSelection & FM_SEL_ITALIC) != 0) ||
         ((pfo->flFontType           & FO_SIM_ITALIC) != 0) )
    {
        TRACE_OUT(( "Italic"));
        *pFontFlags |= NF_ITALIC;
    }
    if ((pFontMetrics->fsSelection & FM_SEL_UNDERSCORE) != 0)
    {
        TRACE_OUT(( "Underline"));
        *pFontFlags |= NF_UNDERLINE;
    }
    if ((pFontMetrics->fsSelection & FM_SEL_STRIKEOUT) != 0)
    {
        TRACE_OUT(( "Strikeout"));
        *pFontFlags |= NF_STRIKEOUT;
    }

    //
    // It is possible to have a font made bold by Windows, i.e.  the
    // standard font definition is not bold, but windows manipulates the
    // font data to create a bold effect.  This is marked by the
    // FO_SIM_BOLD flag.
    //
    // In this case we need to ensure that the font flags are marked as
    // bold according to the weight.
    //
    if ( ((pfo->flFontType & FO_SIM_BOLD) != 0)       &&
         ( pFontMetrics->usWinWeight      <  FW_BOLD) )
    {
        TRACE_OUT(( "Upgrading weight for a bold font"));
        *pFontWeight = FW_BOLD;
    }

    //
    // If the font is an exact match, or if it is an approximate match for
    // its entire range (0x00 to 0xFF) then send it happily.  If not...only
    // send chars within the range 0x20->0x7F ("true ASCII").
    //
    ASSERT(g_poeLocalFonts);
    if (codePage != g_poeLocalFonts[iLocal].Details.nfCodePage)
    {
        TRACE_OUT(( "Using different CP: downgrade to APPROX_ASC"));
        matchQuality = FH_SC_APPROX_ASCII_MATCH;
    }

    //
    // If we don't have an exact match, check the individual characters.
    //
    if ( (matchQuality != FH_SC_EXACT_MATCH ) &&
         (matchQuality != FH_SC_APPROX_MATCH) )
    {
        //
        // The approximate match is only valid if we use a font that
        // supports the ANSI character set.
        //
        if ((pFontMetrics->jWinCharSet & ANSI_CHARSET) != 0)
        {
            TRACE_OUT(( "Cannot do match without ANSI support"));
            DC_QUIT;
        }

        //
        // This font is not a good match across its entire range.  Check
        // that all chars are within the desired range.
        //
        for (i = 0; i < textLen; i++)
        {
            if ( (pFontText[i] == 0) ||
                 ( (pFontText[i] >= NF_ASCII_FIRST) &&
                   (pFontText[i] <= NF_ASCII_LAST)  )  )
            {
                continue;
            }

            //
            // Can only get here by finding a char outside our acceptable
            // range.
            //
            TRACE_OUT(( "found non ASCII char %x", pFontText[i]));
            DC_QUIT;
        }

    }

    //
    // We have a valid font. Now sort out delta X issues.
    //

    //
    // If we do not need to send delta X arrays then exit now.
    //
    if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
    {
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_SOMETIMES))
        {
            //
            // CAPS_FONT_NEED_X_SOMETIMES and CAPS_FONT_NEED_X_ALWAYS are
            // both not set so we can exit now.  (We do not need a delta X
            // array).
            //
            TRACE_OUT(( "Capabilities eliminated delta X"));
            DC_QUIT;
        }

        //
        // CAPS_FONT_NEED_X_SOMETIMES is set and CAPS_FONT_NEED_X_ALWAYS is
        // not set.  In this case whether we need a delta X is determined
        // by whether the font is an exact match or an approximate match
        // (because of either approximation of name, signature, or aspect
        // ratio).  We can only find this out after we have extracted the
        // font handle from the existing order.
        //
    }

    //
    // If the string is a single character (or less) then we can just
    // return.
    //
    if (textLen <= 1)
    {
        TRACE_OUT(( "String only %lu long", textLen));
        DC_QUIT;
    }

    //
    // Capabilities allow us to ignore delta X position if we have an exact
    // match.
    //
    if ((matchQuality & FH_SC_EXACT) != 0)
    {
        //
        // Exit immediately, providing that there is no override to always
        // send increments.
        //
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
        {
            TRACE_OUT(( "Font has exact match"));
            DC_QUIT;
        }
    }

    //
    // We have passed all the checks - we must send a delta X array.
    //
    TRACE_OUT(( "Must send delta X"));
    *pSendDeltaX = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OECheckFontIsSupported, rc);
    return(rc);
}


//
// Function:    OELPtoVirtual
//
// Description: Adjusts window coordinates to virtual desktop coordinates.
//              Clips the result to [+32766, -32768].
//
// Parameters:  pPoints - Array of points to be converted
//              cPoints - Number of points to be converted
//
// Returns:     (none)
//
void  OELPtoVirtual
(
    LPPOINT aPts,
    UINT    cPts
)
{
    int         l;
    TSHR_INT16  s;

    DebugEntry(OELPtoVirtual);

    //
    // Convert to screen coordinates
    //
    while (cPts > 0)
    {
        //
        // Look for int16 overflow in the X coordinate
        //
        l = aPts->x;
        s = (TSHR_INT16)l;

        if (l == (int)s)
        {
            aPts->x = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->x = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted X from %ld to %d", l, aPts->x));
        }

        //
        // Look for int16 overflow in the Y coordinate
        //
        l = aPts->y;
        s = (TSHR_INT16)l;

        if (l == (int)s)
        {
            aPts->y = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->y = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted Y from %ld to %d", l, aPts->y));
        }

        //
        // Move on to the next point
        //
        --cPts;
        ++aPts;
    }

    DebugExitVOID(OELPtoVirtual);
}


//
// Function:    OELRtoVirtual
//
// Description: Adjusts RECT in window coordinates to virtual coordinates.
//              Clips the result to [+32766, -32768].
//
// Parameters:  pRects  - Array of rects to be converted
//              numRects  - Number of rects to be converted
//
// Returns:     (none)
//
// NB.  This function takes a Windows rectangle (exclusive coords) and
//      returns a DC-Share rectangle (inclusive coords).
//
void OELRtoVirtual
(
    LPRECT  aRects,
    UINT    cRects
)
{
    DebugEntry(OELRtoVirtual);

    //
    // Convert the points to screen coords, clipping to INT16s
    //
    OELPtoVirtual((LPPOINT)aRects, 2 * cRects);

    //
    // Make each rectangle inclusive
    //
    while (cRects > 0)
    {
        aRects->right--;
        aRects->bottom--;

        //
        // Move on to the next rect
        //
        cRects--;
        aRects++;
    }

    DebugExitVOID(OELRtoVirtual);
}


//
// Function:    OEClipAndAddOrder
//
// Description: Adds the order to the order buffer, splitting it up into
//              multiple orders if the clipping is complicated.  If we fail
//              to send the full order, we accumulate it in the SDA instead
//
// Parameters:  pOrder     - Order to be stored.
//              pExtraInfo - Pointer to extra data associated with the
//                           order.  This data depends on the order type,
//                           and may be NULL.
//              pco        - Clipping object for the area
//
// Returns:     (none)
//
void   OEClipAndAddOrder(LPINT_ORDER pOrder,
                                             void *    pExtraInfo,
                                             CLIPOBJ*   pco)
{
    BOOL             fOrderClipped;
    BOOL             fMoreRects;
    RECT             clippedRect;
    RECT             orderRect;
    LPINT_ORDER         pNewOrder;
    LPINT_ORDER         pLastOrder = NULL;
    OE_ENUMRECTS       clip;
    UINT             i;
    UINT             numRects = 0;

    DebugEntry(OEClipAndAddOrder);

    //
    // Convert the order rectangle passed in (in virtual co-ordinates) back
    // to screen co-ordinates.  It is going to be clipped against clip
    // rectangles returned to us in screen co-ordinates.
    //
    // Note that we also convert to exclusive coords here to make
    // comparison with the exclusive Windows coords easier.
    //
    orderRect.left   = pOrder->OrderHeader.Common.rcsDst.left;
    orderRect.top    = pOrder->OrderHeader.Common.rcsDst.top;
    orderRect.right  = pOrder->OrderHeader.Common.rcsDst.right + 1;
    orderRect.bottom = pOrder->OrderHeader.Common.rcsDst.bottom + 1;
    fOrderClipped    = FALSE;

    TRACE_OUT(( "orderRect: (%d,%d)(%d,%d)",
                 orderRect.left,
                 orderRect.top,
                 orderRect.right,
                 orderRect.bottom));

    //
    // Check if we have a clipping object at all.
    //
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        //
        // No clipping object - just use the bounds
        //
        clippedRect   = orderRect;
        fOrderClipped = TRUE;
        pLastOrder    = pOrder;
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        //
        // One clipping rectangle - use it directly.
        //
        RECT_FROM_RECTL(clippedRect, pco->rclBounds);
        clippedRect.left   = max(clippedRect.left,   orderRect.left);
        clippedRect.bottom = min(clippedRect.bottom, orderRect.bottom);
        clippedRect.right  = min(clippedRect.right,  orderRect.right);
        clippedRect.top    = max(clippedRect.top,    orderRect.top);
        fOrderClipped = TRUE;
        pLastOrder     = pOrder;
    }
    else
    {
        //
        // OA can only cope as long as the orders are added in the same
        // order that they were allocated, so we need to do a little
        // shuffling here.
        //
        // We always keep one order outstanding (pLastOrder) and a flag to
        // indicate if it is valid (fOrderClipped).  The first time we find
        // a valid clipping rectangle, we set up pLastOrder and
        // fOrderClipped.  If we find we need to allocate a new order, we
        // request the memory for the new order (pNewOrder), add pLastOrder
        // and store pNewOrder in pLastOrder.
        //
        // Once we have finished enumerating the clipping rectangles, if
        // pLastOrder is valid, we add it in.
        //
        // Also, while we are adding all these orders, OA must not purge
        // the order heap otherwise we'll be left holding an invalid
        // pointer.
        //
        pNewOrder = pOrder;
        g_oaPurgeAllowed = FALSE;

        //
        // Multiple clipping rectangles - Enumerate all the rectangles
        // involved in this drawing operation.
        // The documentation for this function incorrectly states that
        // the returned value is the total number of rectangles
        // comprising the clip region. In fact, -1 is always returned,
        // even when the final parameter is non-zero.
        //
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        //
        // Get the clip rectangles. We fetch these into the clip buffer
        // which is big enough to get all the clip rectangles we expect + 1.
        // If the order runs across this number of clip rects or more then
        // we will already have decided to send it as screen data.
        // The clip rectangle fetching is contained within a loop because,
        // while we expect to call CLIPOBJ_bEnum once only, it is possible
        // for this functio to return zero rects and report that there are
        // more to fetch (according to MSDN).
        //
        do
        {
            fMoreRects = CLIPOBJ_bEnum(pco,
                                       sizeof(clip),
                                       (ULONG *)&clip.rects);

            //
            // The clipping object can decide that there are no more
            // rectangles and that this query has returned no rectangles,
            // so we must check for any valid data in the returned
            // rectangle list.
            //
            if (clip.rects.c == 0)
            {
                //
                // We didn't get any rects this time so go round again - if
                // we're finished, the loop termination condition will take
                // us out. CLIPOBJ_bEnum can return a count of zero when
                // there are still more rects.
                //
                TRACE_OUT(( "No rects this time, more %u", fMoreRects));
                continue;
            }

            //
            // To get to here we expect to have fetched all the rects and
            // no more. Do a quick check.
            //
            numRects += clip.rects.c;
            ASSERT( (numRects <= COMPLEX_CLIP_RECT_COUNT) );

            //
            // Process each clip rectangle by clipping the drawing order to
            // it.
            //
            for ( i = 0; i < clip.rects.c; i++ )
            {
                TRACE_OUT(( "  (%d,%d)(%d,%d)",
                             clip.rects.arcl[i].left,
                             clip.rects.arcl[i].top,
                             clip.rects.arcl[i].right,
                             clip.rects.arcl[i].bottom));

                //
                // Check for an intersection
                //
                if ( (clip.rects.arcl[i].left >= orderRect.right)  ||
                     (clip.rects.arcl[i].bottom <= orderRect.top)    ||
                     (clip.rects.arcl[i].right <= orderRect.left)   ||
                     (clip.rects.arcl[i].top >= orderRect.bottom) )
                {
                    //
                    // No intersection, move on to next clip rect.
                    //
                    continue;
                }

                //
                // There is an intersection, so we may need to add a new
                // order to the buffer to cater for this rectangle.
                //
                if (fOrderClipped)
                {
                    //
                    // The order has already been clipped once, so it
                    // actually intersects more than one clip rect, ie
                    // fOrderClipped is always FALSE for at least the first
                    // clip rectangle in the clip.rects buffer.  We cope
                    // with this by duplicating the order and clipping it
                    // again.
                    //
                    pNewOrder = OA_DDAllocOrderMem(
                         pLastOrder->OrderHeader.Common.cbOrderDataLength, 0);

                    if (pNewOrder == NULL)
                    {
                        WARNING_OUT(( "Order memory allocation failed" ));
                        goto CLIP_ORDER_FAILED;
                    }

                    //
                    // Copy the header & data from the original order to
                    // the new order (making sure that we don't overwrite
                    // the list information at the start of the header).
                    //
                    memcpy((LPBYTE)pNewOrder
                                    + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                              (LPBYTE)pLastOrder
                                    + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                              pLastOrder->OrderHeader.Common.cbOrderDataLength
                                    + sizeof(INT_ORDER_HEADER)
                                    - FIELD_SIZE(INT_ORDER, OrderHeader.list));

                    //
                    // Set the destination (clip) rectangle (in virtual
                    // desktop coordinates).
                    //
                    TSHR_RECT16_FROM_RECT(
                                       &pLastOrder->OrderHeader.Common.rcsDst,
                                       clippedRect);

                    pLastOrder->OrderHeader.Common.rcsDst.right -= 1;
                    pLastOrder->OrderHeader.Common.rcsDst.bottom -= 1;

                    TRACE_OUT(( "Adding duplicate order  (%d,%d) (%d,%d)",
                               pLastOrder->OrderHeader.Common.rcsDst.left,
                               pLastOrder->OrderHeader.Common.rcsDst.top,
                               pLastOrder->OrderHeader.Common.rcsDst.right,
                               pLastOrder->OrderHeader.Common.rcsDst.bottom));

                    //
                    // Add the order to the Order List.
                    //
                    OA_DDAddOrder(pLastOrder, pExtraInfo);
                }

                //
                // Update the clipping rectangle for the order to be sent.
                //
                clippedRect.left  = max(clip.rects.arcl[i].left,
                                           orderRect.left);
                clippedRect.bottom= min(clip.rects.arcl[i].bottom,
                                           orderRect.bottom);
                clippedRect.right = min(clip.rects.arcl[i].right,
                                           orderRect.right);
                clippedRect.top   = max(clip.rects.arcl[i].top,
                                           orderRect.top);
                fOrderClipped     = TRUE;
                pLastOrder        = pNewOrder;
            }
        } while (fMoreRects);
    }

    //
    // Check whether the clipping has removed the order entirely.
    //
    if (fOrderClipped)
    {
        TSHR_RECT16_FROM_RECT(&pLastOrder->OrderHeader.Common.rcsDst,
                                clippedRect);

        pLastOrder->OrderHeader.Common.rcsDst.right -= 1;
        pLastOrder->OrderHeader.Common.rcsDst.bottom -= 1;

        TRACE_OUT(( "Adding order  (%d,%d) (%d,%d)",
                    pLastOrder->OrderHeader.Common.rcsDst.left,
                    pLastOrder->OrderHeader.Common.rcsDst.top,
                    pLastOrder->OrderHeader.Common.rcsDst.right,
                    pLastOrder->OrderHeader.Common.rcsDst.bottom));

        //
        // Add the order to the Order List.
        //
        OA_DDAddOrder(pLastOrder, pExtraInfo);
    }
    else
    {

        TRACE_OUT(( "Order clipped completely"));
        OA_DDFreeOrderMem(pOrder);
    }

    DC_QUIT;


CLIP_ORDER_FAILED:
    //
    // Allocation of memory for a duplicate order failed.  Just add the
    // original order's destination rect into the SDA and free the order.
    //
    // The order rectangle is already in inclusive virtual coordinates.
    //
    TRACE_OUT(( "Order add failed, add to SDA"));
    RECT_FROM_TSHR_RECT16(&orderRect,pLastOrder->OrderHeader.Common.rcsDst);
    OA_DDFreeOrderMem(pLastOrder);
    BA_AddScreenData(&orderRect);

DC_EXIT_POINT:
    //
    // Make sure that we always re-enable heap purging.
    //
    g_oaPurgeAllowed = TRUE;

    DebugExitVOID(OEClipAndAddOrder);
}


//
// Function:    OEClipAndAddScreenData
//
// Description: Determines if we need to accumulate any screen data for the
//              specified area.  If so, it is added to the SDA.
//
// Parameters:  pRect - Bounding rectangle of area to be accumulated
//              pco   - Clipping object for the area
//
// Returns:     (none)
//
void   OEClipAndAddScreenData(LPRECT pRect, CLIPOBJ* pco)
{
    RECT    SDACandidate;
    BOOL    fMoreRects;
    RECT    clippedRect;
    OE_ENUMRECTS clip;
    UINT    i;

    DebugEntry(OEClipAndAddScreenData);

    //
    // Convert the order rectangle passed in (in virtual co-ordinates) back
    // to screen co-ordinates.  It is going to be clipped against clip
    // rectangles returned to us in screen co-ordinates.
    //
    // Note that we also convert to exclusive coords here to make
    // comparison with the exclusive Windows coords easier.
    //
    SDACandidate.left   = pRect->left;
    SDACandidate.top    = pRect->top;
    SDACandidate.right  = pRect->right + 1;
    SDACandidate.bottom = pRect->bottom + 1;

    TRACE_OUT(( "SDACandidate: (%d,%d)(%d,%d)",
                 SDACandidate.left,
                 SDACandidate.top,
                 SDACandidate.right,
                 SDACandidate.bottom));

    //
    // Check if we have a clipping object at all.
    //
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        //
        // Convert the clipped rect into Virtual Desktop coords.
        //
        clippedRect         = SDACandidate;
        clippedRect.right  -= 1;
        clippedRect.bottom -= 1;

        //
        // Add the clipped rect into the SDA.
        //
        TRACE_OUT(( "Adding SDA (%d,%d)(%d,%d)", clippedRect.left,
                                                  clippedRect.top,
                                                  clippedRect.right,
                                                  clippedRect.bottom));

        BA_AddScreenData(&clippedRect);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        //
        // One clipping rectangle - use it directly, converting into
        // Virtual Desktop coords. Make sure the rectangle is valid before
        // adding to the SDA.
        //
        RECT_FROM_RECTL(clippedRect, pco->rclBounds);
        clippedRect.left = max(clippedRect.left, SDACandidate.left);
        clippedRect.right = min(clippedRect.right, SDACandidate.right) + -1;

        if ( clippedRect.left <= clippedRect.right )
        {
            clippedRect.bottom = min(clippedRect.bottom,
                                        SDACandidate.bottom) + -1;
            clippedRect.top = max(clippedRect.top, SDACandidate.top);

            if ( clippedRect.bottom >= clippedRect.top )
            {
                //
                // Add the clipped rect into the SDA.
                //
                TRACE_OUT(( "Adding SDA RECT (%d,%d)(%d,%d)",
                                                         clippedRect.left,
                                                         clippedRect.top,
                                                         clippedRect.right,
                                                         clippedRect.bottom));
                BA_AddScreenData(&clippedRect);
            }
        }
    }
    else
    {
        //
        // Enumerate all the rectangles involved in this drawing operation.
        // The documentation for this function incorrectly states that
        // the returned value is the total number of rectangles
        // comprising the clip region. In fact, -1 is always returned,
        // even when the final parameter is non-zero.
        //
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do
        {
            //
            // Get the next batch of clipping rectangles
            //
            fMoreRects = CLIPOBJ_bEnum(pco,
                                       sizeof(clip),
                                       (ULONG *)&clip.rects);

            for ( i = 0; i < clip.rects.c; i++ )
            {
                TRACE_OUT(( "  (%d,%d)(%d,%d)",
                             clip.rects.arcl[i].left,
                             clip.rects.arcl[i].top,
                             clip.rects.arcl[i].right,
                             clip.rects.arcl[i].bottom));

                //
                // Intersect the SDA rect with the clip rect, checking for
                // no intersection.
                //
                clippedRect.left  = max( clip.rects.arcl[i].left,
                                            SDACandidate.left );
                clippedRect.right = min( clip.rects.arcl[i].right,
                                            SDACandidate.right );

                if (clippedRect.left >= clippedRect.right)
                {
                    //
                    // No horizontal intersection.
                    //
                    continue;
                }

                clippedRect.bottom = min( clip.rects.arcl[i].bottom,
                                             SDACandidate.bottom );
                clippedRect.top    = max( clip.rects.arcl[i].top,
                                             SDACandidate.top );

                if (clippedRect.top >= clippedRect.bottom)
                {
                    //
                    // No vertical intersection.
                    //
                    continue;
                }

                //
                // Convert the clipped rect into Virtual Desktop coords.
                //
                clippedRect.right  -= 1;
                clippedRect.bottom -= 1;

                //
                // Add the clipped rect into the SDA.
                //
                TRACE_OUT(( "Adding SDA (%d,%d)(%d,%d)",
                             clippedRect.left,
                             clippedRect.top,
                             clippedRect.right,
                             clippedRect.bottom));

                BA_AddScreenData(&clippedRect);
            }
        } while (fMoreRects);
    }

    DebugExitVOID(OEClipAndAddScreenData);
}





//
// FUNCTION:    OEDDSetNewFonts
//
// DESCRIPTION:
//
// Set the new font handling information to be used by the display driver.
//
// RETURNS:
//
// NONE
//
//
void  OEDDSetNewFonts(LPOE_NEW_FONTS pRequest)
{
    UINT    cbNewSize;

    DebugEntry(OEDDSetNewFonts);

    TRACE_OUT(( "New fonts %d", pRequest->countFonts));

    //
    // Initialize new number of fonts to zero in case an error happens.
    // We don't want to use stale font info if so.
    //
    g_oeNumFonts = 0;

    g_oeFontCaps = pRequest->fontCaps;

    //
    // Free our previous font block if we had one.
    //
    if (g_poeLocalFonts)
    {
        EngFreeMem(g_poeLocalFonts);
        g_poeLocalFonts = NULL;
    }

    //
    // Alloc a new one, the size of the new font block.
    //
    cbNewSize = pRequest->countFonts * sizeof(LOCALFONT);
    g_poeLocalFonts = EngAllocMem(0, cbNewSize, OSI_ALLOC_TAG);
    if (! g_poeLocalFonts)
    {
        ERROR_OUT(("OEDDSetNewFonts: can't allocate space for font info"));
        DC_QUIT;
    }

    //
    // OK, if we're here, this is going to succeed.  Copy the info over.
    //
    g_oeNumFonts = pRequest->countFonts;

    memcpy(g_poeLocalFonts, pRequest->fontData, cbNewSize);

    memcpy(g_oeLocalFontIndex, pRequest->fontIndex,
              sizeof(g_oeLocalFontIndex[0]) * FH_LOCAL_INDEX_SIZE);

DC_EXIT_POINT:
    DebugExitVOID(OEDDSetNewFonts);
}


//
// FUNCTION:    OEDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new OE related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void  OEDDSetNewCapabilities(LPOE_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(OEDDSetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_oeBaselineTextEnabled = pCapabilities->baselineTextEnabled;

    g_oeSendOrders          = pCapabilities->sendOrders;

    g_oeTextEnabled         = pCapabilities->textEnabled;

    //
    // The share core has passed down a pointer to it's copy of the order
    // support array.  We take a copy for the kernel here.
    //
    memcpy(g_oeOrderSupported,
              pCapabilities->orderSupported,
              sizeof(g_oeOrderSupported));

    TRACE_OUT(( "OE caps: BLT %c Orders %c Text %c",
                 g_oeBaselineTextEnabled ? 'Y': 'N',
                 g_oeSendOrders ? 'Y': 'N',
                 g_oeTextEnabled ? 'Y': 'N'));

    DebugExitVOID(OEDDSetNewCapabilities);
}


//
// Function:    OETileBitBltOrder
//
// Description: Divides a single large BitBlt order into a series of small,
//              "tiled" BitBlt orders, each of which is added to the order
//              queue.
//
// Parameters:  pOrder     - Template order to be tiled
//              pExtraInfo - Structure containing pointers to the source
//                           and destination surface objects, and a pointer
//                           to the color translation object for the Blt
//              pco        - Clipping object for the operation
//
// Returns:     TRUE - Stored in orders (and possibly some SDA)
//              FALSE- Stored in SDA (or contained bad data)
//
//
void   OETileBitBltOrder
(
    LPINT_ORDER                 pOrder,
    LPMEMBLT_ORDER_EXTRA_INFO   pExtraInfo,
    CLIPOBJ*                    pco
)
{
    UINT        tileWidth;
    UINT        tileHeight;
    int         srcLeft;
    int         srcTop;
    int         srcRight;
    int         srcBottom;
    int         xFirstTile;
    int         yFirstTile;
    int         xTile;
    int         yTile;
    UINT        type;
    int         bmpWidth, bmpHeight;
    RECT        destRect;

    DebugEntry(OETileBitBltOrder);

    //
    // Extract the src bitmap handle from the Order - if the order is not a
    // memory to screen blit, we get out now.
    //
    type = ((LPMEMBLT_ORDER)pOrder->abOrderData)->type;
    switch (type)
    {
        case ORD_MEMBLT_TYPE:
        {
            srcLeft   = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nXSrc;
            srcTop    = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nYSrc;
            srcRight  = srcLeft +
                       ((LPMEMBLT_ORDER)pOrder->abOrderData)->nWidth;
            srcBottom = srcTop +
                       ((LPMEMBLT_ORDER)pOrder->abOrderData)->nHeight;
            destRect.left  = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nLeftRect;
            destRect.top   = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nTopRect;
            destRect.right = destRect.left +
                ((LPMEMBLT_ORDER)pOrder->abOrderData)->nWidth;
            destRect.bottom= destRect.top +
                ((LPMEMBLT_ORDER)pOrder->abOrderData)->nHeight;
        }
        break;

        case ORD_MEM3BLT_TYPE:
        {
            srcLeft   = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nXSrc;
            srcTop    = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nYSrc;
            srcRight  = srcLeft +
                       ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nWidth;
            srcBottom = srcTop +
                       ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nHeight;

            destRect.left = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nLeftRect;
            destRect.top  = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nTopRect;
            destRect.right= destRect.left +
                            ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nWidth;
            destRect.bottom = destRect.top +
                            ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nHeight;
        }
        break;

        default:
        {
            ERROR_OUT(( "Invalid order type %u", type));
        }
        break;
    }

    //
    // Fetch the bitmap details.
    //
    bmpWidth  = (int)pExtraInfo->pSource->sizlBitmap.cx;
    bmpHeight = (int)pExtraInfo->pSource->sizlBitmap.cy;

    if (!SBC_DDQueryBitmapTileSize(bmpWidth, bmpHeight, &tileWidth, &tileHeight))
    {
        //
        // This could happen if some 2.x user joins the share.
        //
        TRACE_OUT(("Bitmap is not tileable"));
        OEClipAndAddScreenData(&destRect, pco);
    }
    else
    {
        //
        // Tile the order.  If an individual tile fails to get queued as an
        // order, OEAddTiledBitBltOrder() will add it as screen data.  Hence
        // no return value to be checked.
        //
        xFirstTile = srcLeft - (srcLeft % tileWidth);
        yFirstTile = srcTop - (srcTop % tileHeight);

        for (yTile = yFirstTile; yTile < srcBottom; yTile += tileHeight)
        {
            for (xTile = xFirstTile; xTile < srcRight; xTile += tileWidth)
            {
                OEAddTiledBitBltOrder(pOrder, pExtraInfo, pco, xTile, yTile,
                    tileWidth,  tileHeight);
            }
        }
    }

    DebugExitVOID(OETileBitBltOrder);
}



//
// Function:    OEAddTiledBitBltOrder
//
// Description: Takes an unmodified "large" BitBlt and a tile rectangle,
//              makes a copy of the order and modifies the copied order's
//              src/dest so it applies to the source tile only. The order
//              is added to the order queue.  If the allocation of the
//              "tiled" order fails, the destination rect is added to SDA
//
// Parameters:  pOrder     - Template order to be added
//              pExtraInfo - Pointer to the extra BitBlt info
//              pco        - Clipping object for the BitBlt
//              xTile      - X position of the tile
//              yTile      - Y position of the tile
//              tileWidth  - tile width
//              tileHeight - tile height
//
// Returns:     none
//
//
void   OEAddTiledBitBltOrder(
                                         LPINT_ORDER               pOrder,
                                         LPMEMBLT_ORDER_EXTRA_INFO pExtraInfo,
                                         CLIPOBJ*                 pco,
                                         int                  xTile,
                                         int                  yTile,
                                         UINT                 tileWidth,
                                         UINT                 tileHeight)
{
    LPINT_ORDER pTileOrder;
    LPINT  pXSrc   = NULL;
    LPINT  pYSrc   = NULL;
    LPINT  pLeft   = NULL;
    LPINT  pTop    = NULL;
    LPINT  pWidth  = NULL;
    LPINT  pHeight = NULL;
    RECT    srcRect;
    RECT    destRect;
    UINT  type;

    DebugEntry(OETileAndAddBitBltOrder);

    //
    // This is a trusted interface - assume the type is correct
    //
    type = ((LPMEMBLT_ORDER)pOrder->abOrderData)->type;
    ASSERT(((type == ORD_MEMBLT_TYPE) || (type == ORD_MEM3BLT_TYPE)));

    //
    // Do processing which depends on the type of bit blt being tiled:
    // - save existing src and dest rects
    // - make a copy of the order (which will be the tile order)
    // - save pointers to the fields in the tile order which we're likely
    //   to change.
    //
    if (type == ORD_MEMBLT_TYPE)
    {
        srcRect.left  = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nXSrc;
        srcRect.top   = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nYSrc;
        srcRect.right = srcRect.left +
                        ((LPMEMBLT_ORDER)pOrder->abOrderData)->nWidth;
        srcRect.bottom = srcRect.top +
                        ((LPMEMBLT_ORDER)pOrder->abOrderData)->nHeight;
        destRect.left = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nLeftRect;
        destRect.top  = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nTopRect;

        //
        // We must allocate enough space for the maximum size order that
        // SBC may use (i.e.  an R2 order).  We default to filling in the
        // data as an R1 order.
        //
        pTileOrder = OA_DDAllocOrderMem(sizeof(MEMBLT_R2_ORDER),0);
        if (pTileOrder == NULL)
        {
            TRACE_OUT(( "No space for tile order"));
            DC_QUIT;
        }

        //
        // We must not mess up the linked list data in the orders.
        //
        RtlCopyMemory(((LPBYTE)pTileOrder) +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      ((LPBYTE)pOrder)     +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      sizeof(INT_ORDER_HEADER)
                                    + sizeof(MEMBLT_R2_ORDER)
                                    - FIELD_SIZE(INT_ORDER, OrderHeader.list));

        pXSrc   = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nXSrc;
        pYSrc   = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nYSrc;
        pWidth  = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nWidth;
        pHeight = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nHeight;
        pLeft   = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nLeftRect;
        pTop    = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nTopRect;
    }
    else
    {
        srcRect.left  = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nXSrc;
        srcRect.top   = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nYSrc;
        srcRect.right = srcRect.left +
                        ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nWidth;
        srcRect.bottom = srcRect.top +
                        ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nHeight;
        destRect.left = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nLeftRect;
        destRect.top  = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nTopRect;

        //
        // We must allocate enough space for the maximum size order that
        // SBC may use (i.e.  an R2 order).  We default to filling in the
        // data as an R1 order.
        //
        pTileOrder = OA_DDAllocOrderMem(sizeof(MEM3BLT_R2_ORDER),0);
        if (pTileOrder == NULL)
        {
            TRACE_OUT(( "No space for tile order"));
            DC_QUIT;
        }

        //
        // We must not mess up the linked list data in the orders.
        //
        RtlCopyMemory(((LPBYTE)pTileOrder) +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      ((LPBYTE)pOrder)     +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      sizeof(INT_ORDER_HEADER)
                                    + sizeof(MEM3BLT_R2_ORDER)
                                    - FIELD_SIZE(INT_ORDER, OrderHeader.list));

        pXSrc   = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nXSrc;
        pYSrc   = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nYSrc;
        pWidth  = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nWidth;
        pHeight = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nHeight;
        pLeft   = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nLeftRect;
        pTop    = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nTopRect;
    }

    TRACE_OUT(( "Tiling order, orig srcLeft=%hd, srcTop=%hd, srcRight=%hd, "
           "srcBottom=%hd, destX=%hd, destY=%hd; "
           "xTile=%hd, yTile=%hd, tileW=%hd, tileH=%hd",
           srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
           destRect.left, destRect.top,
           xTile, yTile, tileWidth, tileHeight));

DC_EXIT_POINT:
    //
    // NOTE: ALL THE POINTERS MAY BE NULL AT THIS POINT - DO NOT USE THEM
    // UNTIL YOU VERIFY PTILEORDER IS NON-NULL.
    //
    // Intersect source and tile rects, and set up destination rect
    // accordingly - we need to do this even if we failed to copy the
    // order, because the tiled source rect will have to be added to the
    // screen data area.
    //
    if (xTile > srcRect.left)
    {
        destRect.left += (xTile - srcRect.left);
        srcRect.left = xTile;
    }

    if (yTile > srcRect.top)
    {
        destRect.top += (yTile - srcRect.top);
        srcRect.top = yTile;
    }

    srcRect.right  = min((UINT)srcRect.right, xTile + tileWidth);
    srcRect.bottom = min((UINT)srcRect.bottom, yTile + tileHeight);

    destRect.right  = destRect.left + (srcRect.right - srcRect.left);
    destRect.bottom = destRect.top + (srcRect.bottom - srcRect.top);

    //
    // If the order was successfully copied above, then modify the order
    // to contain the tiled coordinates, and add it to the order list.
    // Otherwise, send the dest rect as screen data.
    //
    if (pTileOrder != NULL)
    {
        TRACE_OUT(( "Tile order originally: srcX=%hd, srcY=%hd, destX=%hd, "
               "destY=%hd, w=%hd, h=%hd",
               *pXSrc, *pYSrc, *pLeft, *pTop, *pWidth, *pHeight));

        *pXSrc = srcRect.left;
        *pYSrc = srcRect.top;
        *pLeft = destRect.left;
        *pTop  = destRect.top;
        *pWidth = srcRect.right - srcRect.left;
        *pHeight = srcRect.bottom - srcRect.top;

        pTileOrder->OrderHeader.Common.rcsDst.left = (TSHR_INT16)destRect.left;
        pTileOrder->OrderHeader.Common.rcsDst.right = (TSHR_INT16)destRect.right;
        pTileOrder->OrderHeader.Common.rcsDst.top = (TSHR_INT16)destRect.top;
        pTileOrder->OrderHeader.Common.rcsDst.bottom =
                                                     (TSHR_INT16)destRect.bottom;

        TRACE_OUT(( "Adding order srcX=%hd, srcY=%hd, destX=%hd, destY=%hd,"
               " w=%hd, h=%hd",
               *pXSrc, *pYSrc, *pLeft, *pTop, *pWidth, *pHeight));
        OEClipAndAddOrder(pTileOrder, pExtraInfo, pco);
    }
    else
    {
        TRACE_OUT(( "Failed to allocate order - sending as screen data"));
        OEClipAndAddScreenData(&destRect, pco);
    }

    DebugExitVOID(OETileAndAddBitBltOrder);
}



// NAME:      OEAddLine
//
// PURPOSE:
//
// Add a LineTo order to the order heap.
//
// RETURNS:
//
// TRUE  - Attempted to add to heap
// FALSE - No room left to allocate an order
//
// PARAMS:
//
// ppdev      - display driver PDEV
// startPoint - start point of line
// endPoint   - end point of line
// rectDst    - bounding rectangle
// rop2       - ROP2 to use with line
// width      - width of line to add
// color      - color of line to add
// pco        - clipping object for drawing operation
//
BOOL  OEAddLine(LPOSI_PDEV ppdev,
                    LPPOINT  startPoint,
                    LPPOINT  endPoint,
                                    LPRECT   rectDst,
                                    UINT  rop2,
                                    UINT  width,
                                    UINT  color,
                                    CLIPOBJ*  pco)
{
    BOOL         rc = FALSE;
    LPLINETO_ORDER pLineTo;
    LPINT_ORDER     pOrder;

    DebugEntry(OEAddLine);

    //
    // Allocate the memory for the order.
    //
    pOrder = OA_DDAllocOrderMem(sizeof(LINETO_ORDER),0);
    if (pOrder == NULL)
    {
        TRACE_OUT(( "Failed to alloc order"));
        DC_QUIT;
    }
    pLineTo = (LPLINETO_ORDER)pOrder->abOrderData;

    //
    // Mark this order type.
    //
    pLineTo->type = ORD_LINETO_TYPE;

    //
    // Store the line end coordinates.
    //
    pLineTo->nXStart   = startPoint->x;
    pLineTo->nYStart   = startPoint->y;
    pLineTo->nXEnd     = endPoint->x;
    pLineTo->nYEnd     = endPoint->y;

    //
    // We must convert these values to virtual coords.
    //
    OELPtoVirtual((LPPOINT)&pLineTo->nXStart, 2);

    //
    // Always do solid lines, so it does not matter what we specify as the
    // back color.
    //
    RtlFillMemory(&pLineTo->BackColor,
                  sizeof(pLineTo->BackColor),
                  0);

    //
    // We only draw solid lines with no option as to what we do to the
    // background, so this is always transparent.
    //
    pLineTo->BackMode  = TRANSPARENT;

    //
    // Get the ROP value.
    //
    pLineTo->ROP2      = rop2;

    //
    // The NT Display Driver is only called to accelerate simple solid
    // lines.  So we only support pen styles of PS_SOLID.
    //
    pLineTo->PenStyle  = PS_SOLID;

    //
    // Get the pen width.
    //
    pLineTo->PenWidth = width;

    //
    // Set up the color.
    //
    OEConvertColor(ppdev,
                   &pLineTo->PenColor,
                   color,
                   NULL);

    TRACE_OUT(( "LineTo BC %02x%02x%02x BM %04X rop2 %02X "
                 "pen %04X %04X %02x%02x%02x x1 %d y1 %d x2 %d y2 %d",
            pLineTo->BackColor.red,
            pLineTo->BackColor.green,
            pLineTo->BackColor.blue,
            pLineTo->BackMode,
            pLineTo->ROP2,
            pLineTo->PenStyle,
            pLineTo->PenWidth,
            pLineTo->PenColor.red,
            pLineTo->PenColor.green,
            pLineTo->PenColor.blue,
            pLineTo->nXStart,
            pLineTo->nYStart,
            pLineTo->nXEnd,
            pLineTo->nYEnd));

    //
    // Store the general order data.  The bounding rectangle must be in to
    // virtual desktop co-ordinates.  OELRtoVirtual has already done this.
    //
    pOrder->OrderHeader.Common.fOrderFlags   = OF_SPOILABLE;
    pOrder->OrderHeader.Common.rcsDst.left   = (TSHR_INT16)rectDst->left;
    pOrder->OrderHeader.Common.rcsDst.right  = (TSHR_INT16)rectDst->right;
    pOrder->OrderHeader.Common.rcsDst.top    = (TSHR_INT16)rectDst->top;
    pOrder->OrderHeader.Common.rcsDst.bottom = (TSHR_INT16)rectDst->bottom;

    //
    // Store that order!
    //
    OEClipAndAddOrder(pOrder, NULL, pco);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OEAddLine, rc);
    return(rc);
}


// NAME:      OEEncodePatBlt
//
// PURPOSE:
//
// Attempts to encode a PatBlt order. This function allocates the memory
// for the encoded order (pointer returned in ppOrder). If the function
// completes successfully, it is the caller's responsibility to free this
// memory.
//
// RETURNS:
//
// TRUE  - Order encoded
// FALSE - Order not encoded (so add to SDA)
//
// PARAMS:
//
// ppdev       - display driver PDEV
// pbo         - brush object for the blt
// pptlBrush   - brush origin
// rop3        - 3-way rop to use
// pBounds     - bounding rectangle
// ppOrder     - the encoded order
//
BOOL  OEEncodePatBlt(LPOSI_PDEV   ppdev,
                                         BRUSHOBJ   *pbo,
                                         POINTL     *pptlBrush,
                                         BYTE     rop3,
                                         LPRECT     pBounds,
                                         LPINT_ORDER *ppOrder)
{
    BOOL rc = FALSE;
    POE_BRUSH_DATA pCurrentBrush;
    LPPATBLT_ORDER pPatBlt;
    UINT orderFlags = OF_SPOILABLE;

    DebugEntry(OEEncodePatBlt);

    //
    // Check for a simple brush pattern.
    //
    if ( OECheckBrushIsSimple(ppdev, pbo, &pCurrentBrush) )
    {
        //
        // Allocate the memory for the order.
        //
        *ppOrder = OA_DDAllocOrderMem(sizeof(PATBLT_ORDER),0);
        if (*ppOrder != NULL)
        {
            pPatBlt = (LPPATBLT_ORDER)((*ppOrder)->abOrderData);

            //
            // Set the opaque flag if the rop is opaque.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
               orderFlags |= OF_SPOILER;
            }

            //
            // Set up order type.
            //
            pPatBlt->type = LOWORD(ORD_PATBLT);

            //
            // Virtual desktop co-ordinates.
            //
            pPatBlt->nLeftRect  = pBounds->left;
            pPatBlt->nTopRect   = pBounds->top;
            pPatBlt->nWidth     = pBounds->right  - pBounds->left + 1;
            pPatBlt->nHeight    = pBounds->bottom - pBounds->top  + 1;
            pPatBlt->bRop       = rop3;

            //
            // Pattern colours.
            //
            pPatBlt->BackColor  = pCurrentBrush->back;
            pPatBlt->ForeColor  = pCurrentBrush->fore;

            //
            // The protocol brush origin is the point on the screen where
            // we want the brush to start being drawn from (tiling where
            // necessary).  This must be in virtual coordinates.
            //
            pPatBlt->BrushOrgX  = pptlBrush->x;
            pPatBlt->BrushOrgY  = pptlBrush->y;
            OELPtoVirtual((LPPOINT)&pPatBlt->BrushOrgX, 1);

            //
            // Extra brush data from the data when we realised the brush.
            //
            pPatBlt->BrushStyle = pCurrentBrush->style;
            pPatBlt->BrushHatch = pCurrentBrush->hatch;

            RtlCopyMemory(pPatBlt->BrushExtra,
                          pCurrentBrush->brushData,
                          sizeof(pPatBlt->BrushExtra));

            TRACE_OUT(( "PatBlt BC %02x%02x%02x FC %02x%02x%02x "
                         "Brush %02X %02X X %d Y %d w %d h %d rop %02X",
                    pPatBlt->BackColor.red,
                    pPatBlt->BackColor.green,
                    pPatBlt->BackColor.blue,
                    pPatBlt->ForeColor.red,
                    pPatBlt->ForeColor.green,
                    pPatBlt->ForeColor.blue,
                    pPatBlt->BrushStyle,
                    pPatBlt->BrushHatch,
                    pPatBlt->nLeftRect,
                    pPatBlt->nTopRect,
                    pPatBlt->nWidth,
                    pPatBlt->nHeight,
                    pPatBlt->bRop));

            //
            // Copy any order flags into the encoded order structure.
            //
            (*ppOrder)->OrderHeader.Common.fOrderFlags = (TSHR_UINT16)orderFlags;

            rc = TRUE;
        }
        else
        {
            TRACE_OUT(( "Failed to alloc order"));
        }
    }
    else
    {
        TRACE_OUT(( "Brush is not simple"));
    }

    DebugExitDWORD(OEEncodePatBlt, rc);
    return(rc);
}




//
// DrvTransparentBlt()
// NEW FOR NT5
//
BOOL DrvTransparentBlt
(
    SURFOBJ *   psoDst,
    SURFOBJ *   psoSrc,
    CLIPOBJ *   pco,
    XLATEOBJ *  pxlo,
    RECTL *     prclDst,
    RECTL *     prclSrc,
    ULONG       iTransColor,
    ULONG       ulReserved
)
{
    BOOL        rc = TRUE;
    RECT        rectSrc;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvTransparentBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));


    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvTransparentBlt, rc);
    return(rc);
}



//
// DrvAlphaBlend()
// NEW FOR NT5
//
BOOL DrvAlphaBlend
(
    SURFOBJ *   psoDst,
    SURFOBJ *   psoSrc,
    CLIPOBJ *   pco,
    XLATEOBJ *  pxlo,
    RECTL *     prclDst,
    RECTL *     prclSrc,
    BLENDOBJ *  pBlendObj
)
{
    BOOL        rc = TRUE;
    RECT        rectSrc;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvAlphaBlend);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));


    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvAlphaBlend, rc);
    return(rc);
}



//
// DrvPlgBlt()
// NEW FOR NT5
//
BOOL DrvPlgBlt
(
    SURFOBJ *           psoDst,
    SURFOBJ *           psoSrc,
    SURFOBJ *           psoMsk,
    CLIPOBJ *           pco,
    XLATEOBJ *          pxlo,
    COLORADJUSTMENT *   pca,
    POINTL *            pptlBrushOrg,
    POINTFIX *          pptfx,
    RECTL *             prclDst,
    POINTL *            pptlSrc,
    ULONG               iMode
)
{
    BOOL        rc = TRUE;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvPlgBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvPlgBlt, rc);
    return(rc);
}



//
// DrvStretchBltROP()
// NEW FOR NT5
//
BOOL DrvStretchBltROP
(
    SURFOBJ *           psoDst,
    SURFOBJ *           psoSrc,
    SURFOBJ *           psoMask,
    CLIPOBJ *           pco,
    XLATEOBJ *          pxlo,
    COLORADJUSTMENT *   pca,
    POINTL *            pptlHTOrg,
    RECTL *             prclDst,
    RECTL *             prclSrc,
    POINTL *            pptlMask,
    ULONG               iMode,
    BRUSHOBJ *          pbo,
    DWORD               rop4
)
{
    BOOL        rc = TRUE;
    RECT        rectSrc;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvStretchBltROP);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvStretchBltROP, rc);
    return(rc);
}



//
// DrvGradientFill()
// NEW FOR NT5
//
BOOL DrvGradientFill
(
    SURFOBJ *       psoDst,
    CLIPOBJ *       pco,
    XLATEOBJ *      pxlo,
    TRIVERTEX *     pVertex,
    ULONG           nVertex,
    PVOID           pMesh,
    ULONG           nMesh,
    RECTL *         prclExtents,
    POINTL *        pptlDitherOrg,
    ULONG           ulMode
)
{
    BOOL        rc = TRUE;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvGradientFill);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, pco->rclBounds);

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvGradientFill, rc);
    return(rc);
}








=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\shm.c ===
#include "precomp.h"


//
// SHM.C
// Shared Memory Access, cpi32 and display driver sides both
//
// Copyright(c) Microsoft 1997-
//


//
// SHM_StartAccess
//
LPVOID  SHM_StartAccess(int block)
{
    LPBUFFER_CONTROL    pControl;
    LPVOID              pMemBlock;

    DebugEntry(SHM_StartAccess);

    //
    // Test for shared memory present
    //
    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Mark the double-buffer as busy.
    //
    pControl->busyFlag = 1;

    //
    // Set up the current buffer pointer if this is the first access to the
    // shared memory.
    //
    pControl->indexCount++;
    if (pControl->indexCount == 1)
    {
        //
        // Set up the 'in use' buffer pointer
        //
        pControl->currentBuffer = pControl->newBuffer;

        //
        // Mark the buffer as busy so that the Share Core knows where we
        // are.
        //
        pControl->bufferBusy[pControl->currentBuffer] = 1;
    }

    //
    // Get the pointer to the block to return
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pMemBlock = g_poaData[pControl->currentBuffer];
            break;

        case SHM_OA_FAST:
            pMemBlock = &(g_asSharedMemory->oaFast[pControl->currentBuffer]);
            break;

        case SHM_BA_FAST:
            pMemBlock = &(g_asSharedMemory->baFast[pControl->currentBuffer]);
            break;

        case SHM_CM_FAST:
            pMemBlock = &(g_asSharedMemory->cmFast[pControl->currentBuffer]);
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    DebugExitPVOID(SHM_StartAccess, pMemBlock);
    return(pMemBlock);
}


//
// SHM_StopAccess
//
void  SHM_StopAccess(int block)
{
    LPBUFFER_CONTROL pControl;

    DebugEntry(SHM_StopAccess);

    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Decrement usage count - if we have finally finished with the memory,
    // clear the busy flags so that the Share Core knows it won't tread on
    // the display driver's toes.
    //
    pControl->indexCount--;
    if (pControl->indexCount == 0)
    {
        pControl->bufferBusy[pControl->currentBuffer] = 0;

        pControl->busyFlag = 0;
    }

    DebugExitVOID(SHM_StopAccess);
}


#ifdef _DEBUG
//
// SHM_CheckPointer - see shm.h
//
void  SHM_CheckPointer(LPVOID ptr)
{
    DebugEntry(SHMCheckPointer);

    if (ptr == NULL)
    {
        ERROR_OUT(("Null pointer"));
        DC_QUIT;
    }

    ASSERT(g_asSharedMemory);

    if (((LPBYTE)ptr - (LPBYTE)g_asSharedMemory < 0) ||
        ((LPBYTE)ptr - (LPBYTE)g_asSharedMemory >= SHM_SIZE_USED))
    {
        ERROR_OUT(("Bad pointer"));
    }

DC_EXIT_POINT:
    DebugExitVOID(SHM_CheckPointer);
}
#endif // _DEBUG






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\sbc.c ===
#include "precomp.h"


//
// SBC.C
// Send Bitmap Cache, display driver side
//
// Copyright(c) Microsoft 1997-
//


//
//
// SBC_DDProcessRequest() - see sbc.h
//
//
BOOL SBC_DDProcessRequest
(
    SURFOBJ*  pso,
    DWORD     fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD     cbResult
)
{
    BOOL            rc;
    LPOSI_PDEV      ppDev = (LPOSI_PDEV)pso->dhpdev;

    DebugEntry(SBC_DDProcessRequest);

    //
    // Get the request number.
    //
    switch (fnEscape)
    {
        case SBC_ESC_NEW_CAPABILITIES:
        {
            if (cbResult != sizeof(SBC_NEW_CAPABILITIES))
            {
                ERROR_OUT(("SBC_DDProcessRequest:  Invalid size %d for SBC_ESC_NEW_CAPABILITIES",
                    cbResult));
                rc = FALSE;
                DC_QUIT;
            }
            TRACE_OUT(("SBC_ESC_NEW_CAPABILITIES"));

            SBCDDSetNewCapabilities((LPSBC_NEW_CAPABILITIES)pRequest);

            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SBC_ escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDProcessRequest, rc);
    return(rc);
}


//
//
// SBC_DDInit() - see sbc.h
//
//
BOOL SBC_DDInit
(
    LPOSI_PDEV  ppDev,
    LPBYTE      pRestOfMemory,
    DWORD       cbRestOfMemory,
    LPOSI_INIT_REQUEST   pResult
)
{
    UINT    i;
    SIZEL   bitmapSize;
    BOOL    rc = FALSE;

    DebugEntry(SBC_DDInit);

    //
    // We have to create work DIBs to Blt into when SBC_CacheMemScreenBlt
    // is called.
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
    {
        ASSERT(!g_asbcWorkInfo[i].pShuntBuffer);
        ASSERT(!g_asbcWorkInfo[i].mruIndex);
        ASSERT(!g_asbcWorkInfo[i].workBitmap);

        if (i == SBC_MEDIUM_TILE_INDEX)
        {
            g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth = MP_MEDIUM_TILE_WIDTH;
            g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight = MP_MEDIUM_TILE_HEIGHT;
        }
        else
        {
            ASSERT(i == SBC_LARGE_TILE_INDEX);

            g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth = MP_LARGE_TILE_WIDTH;
            g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight = MP_LARGE_TILE_HEIGHT;
        }

        //
        // Create the bitmap.  Note that we create it "top down" rather
        // than the default of "bottom up" to simplify copying data from
        // the bitmap (we don't have to work out offsets into the data - we
        // can copy from the beginning).
        //
        // We set the last parameter to NULL, to allow GDI to allocate
        // memory for the bits.  We can get a pointer to the bits later
        // when we have a SURFOBJ for the bitmap.
        //
        bitmapSize.cx = g_asbcWorkInfo[i].tileWidth;
        bitmapSize.cy = g_asbcWorkInfo[i].tileHeight;

        g_asbcWorkInfo[i].workBitmap = EngCreateBitmap(bitmapSize,
            BYTES_IN_BITMAP(g_asbcWorkInfo[i].tileWidth, 1, ppDev->cBitsPerPel),
            ppDev->iBitmapFormat, BMF_TOPDOWN, NULL);

        if (! g_asbcWorkInfo[i].workBitmap)
        {
            ERROR_OUT(( "Failed to create work bitmap %d", i));
            DC_QUIT;
        }
    }

    //
    // Initialize the shunt buffers
    //
    if (! SBCDDCreateShuntBuffers(ppDev, pRestOfMemory, cbRestOfMemory))
    {
        ERROR_OUT(( "Failed to create shunt buffers"));
        DC_QUIT;
    }

    //
    // Set up the remaining global variables
    //
    EngQueryPerformanceFrequency(&g_sbcPerfFrequency);

    //
    // OK, so we can create our SBC cache.  Fill in the details.
    //

    for (i = 0 ; i < SBC_NUM_TILE_SIZES; i++)
    {
        //
        // This is filling in the APP address to the shunt buffers.
        //
        pResult->psbcTileData[i] = (LPBYTE)pResult->pSharedMemory +
            PTRBASE_TO_OFFSET(g_asbcWorkInfo[i].pShuntBuffer, g_asSharedMemory);
    }

    pResult->aBitmasks[0] = ppDev->flRed;
    pResult->aBitmasks[1] = ppDev->flGreen;
    pResult->aBitmasks[2] = ppDev->flBlue;

    //
    // If we are a palette device (i.e.  we are running at 8 bpp or less),
    // set the paletteChanged flag so that we will send a color table to
    // the share core before our first Mem(3)Blt.
    //
    ppDev->paletteChanged = (ppDev->cBitsPerPel <= 8);

    rc = TRUE;
DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDInit, rc);
    return(rc);
}


//
//
// SBC_DDTerm() - see sbc.h
//
//
void SBC_DDTerm(void)
{
    UINT    i;

    DebugEntry(SBC_DDTerm);

    //
    // We just have to set the pointers to the shunt buffers to NULL
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
    {
        // Kill the bitmap if there
        if (g_asbcWorkInfo[i].workBitmap)
        {
            EngDeleteSurface((HSURF)g_asbcWorkInfo[i].workBitmap);
            g_asbcWorkInfo[i].workBitmap = 0;
        }

        g_asbcWorkInfo[i].pShuntBuffer = NULL;
        g_asbcWorkInfo[i].mruIndex        = 0;
    }

    DebugExitVOID(SBC_DDTerm);
}


//
//
// SBC_DDIsMemScreenBltCachable() - see sbc.h
//
//
BOOL SBC_DDIsMemScreenBltCachable(LPMEMBLT_ORDER_EXTRA_INFO pMemBltInfo)
{
    BOOL            rc = FALSE;
    UINT            tileWidth;
    UINT            tileHeight;
    SURFOBJ *       pSourceSurf;

    DebugEntry(SBC_DDIsMemScreenBltCachable);

    //
    // Is this an RLE bitmap - these bitmaps can have effective transparent
    // sections which we cannot mimic with SBC.
    //
    pSourceSurf = pMemBltInfo->pSource;
    if ( (pSourceSurf->iBitmapFormat == BMF_4RLE) ||
         (pSourceSurf->iBitmapFormat == BMF_8RLE) )
    {
        TRACE_OUT(( "RLE Bitmap %d", pSourceSurf->iBitmapFormat));
        DC_QUIT;
    }

    //
    // If this is a thrasher then don't cache it
    //
    if (SBCDDIsBitmapThrasher(pSourceSurf))
    {
        TRACE_OUT(( "Its a thrasher"));
        DC_QUIT;
    }

    //
    // Make sure that this bitmap can be tiled OK
    //
    if (!SBC_DDQueryBitmapTileSize(pSourceSurf->sizlBitmap.cx,
                                   pSourceSurf->sizlBitmap.cy,
                                   &tileWidth,
                                   &tileHeight))
    {
        TRACE_OUT(("Cache does not support tiling"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(SBC_DDIsMemScreenBltCachable, rc);
    return(rc);
}


//
//
// SBC_DDCacheMemScreenBlt() - see sbc.h
//
//
BOOL SBC_DDCacheMemScreenBlt
(
    LPINT_ORDER         pOrder,
    LPMEMBLT_ORDER_EXTRA_INFO   pMemBltInfo
)
{
    BOOL                rc = FALSE;
    LPMEMBLT_ORDER      pMemBltOrder = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    UINT                bmpWidth;
    UINT                bmpHeight;
    UINT                tileWidth;
    UINT                tileHeight;
    POINTL              tileOrg;
    UINT                cxSubBitmapWidth;
    UINT                cySubBitmapHeight;
    UINT                type;
    SURFOBJ *           pDestSurf;
    SURFOBJ *           pSourceSurf;
    LPOSI_PDEV          pDestDev;
    SURFOBJ *           pWorkSurf = NULL;
    LPBYTE              pWorkBits;
    RECTL               destRectl;
    POINTL              sourcePt;
    int                 tileSize;
    LPSBC_TILE_DATA     pTileData = NULL;

    DebugEntry(SBC_DDCacheMemScreenBlt);

    //
    // Do a first pass on the cacheability of the Blt
    //
    if (!SBC_DDIsMemScreenBltCachable(pMemBltInfo))
    {
        TRACE_OUT(( "This MemBlt Order is not cachable"));
        DC_QUIT;
    }

    //
    // Get the width and height of the source bitmap
    //
    pSourceSurf = pMemBltInfo->pSource;
    bmpWidth    = pSourceSurf->sizlBitmap.cx;
    bmpHeight   = pSourceSurf->sizlBitmap.cy;

    //
    // Calculate the tile size for this blit
    //

    if (!SBC_DDQueryBitmapTileSize(bmpWidth, bmpHeight, &tileWidth, &tileHeight))
    {
        TRACE_OUT(("Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // Set up pointers to the source coordinates in the order.
    //
    type = pMemBltOrder->type;
    if (type == ORD_MEMBLT_TYPE)
    {
        sourcePt.x = pMemBltOrder->nXSrc;
        sourcePt.y = pMemBltOrder->nYSrc;
        TRACE_OUT((
              "Request to cache MemBlt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMemBltOrder->nWidth,
                 pMemBltOrder->nHeight,
                 pMemBltOrder->nLeftRect,
                 pMemBltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }
    else
    {
        sourcePt.x = pMem3BltOrder->nXSrc;
        sourcePt.y = pMem3BltOrder->nYSrc;
        TRACE_OUT((
             "Request to cache Mem3Blt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMem3BltOrder->nWidth,
                 pMem3BltOrder->nHeight,
                 pMem3BltOrder->nLeftRect,
                 pMem3BltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }

    //
    // Calculate the tile origin and size of remaining bitmap.  Origin is
    // rounded down to the nearest tile.  Actual size of bitmap to cache
    // may be smaller than tile size if the tile runs off the right/bottom
    // of the bitmap
    //
    tileOrg.x = sourcePt.x - (sourcePt.x % tileWidth);
    tileOrg.y = sourcePt.y - (sourcePt.y % tileHeight);

    //
    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrg.x) is the
    // remaining width of the bitmap after the start of this tile.
    //
    cxSubBitmapWidth  = min(tileWidth, bmpWidth - tileOrg.x);
    cySubBitmapHeight = min(tileHeight, bmpHeight - tileOrg.y);

    //
    // We know how large a tile we have - we now have to Blt it into one of
    // our work bitmaps and pass it up to the share core.  First, work out
    // which of our work bitmaps we should use and set up some variables
    // based on this.
    //
    for (tileSize = 0; tileSize < SBC_NUM_TILE_SIZES ; tileSize++)
    {
        if ((cxSubBitmapWidth <= g_asbcWorkInfo[tileSize].tileWidth) &&
            (cySubBitmapHeight <= g_asbcWorkInfo[tileSize].tileHeight))
        {
            break;
        }
    }

    if (tileSize == SBC_NUM_TILE_SIZES)
    {
        ERROR_OUT(( "%d x %d tile doesn't fit into work bmp",
                     cxSubBitmapWidth,
                     cySubBitmapHeight));
        DC_QUIT;
    }

    //
    // Before doing any more work, get the next free entry in the shunt
    // buffer.  Note that this fills in the tileId element of the returned
    // structure.
    //
    // It is perfectly valid for this call to fail.  The shunt buffer may
    // just be full if we are sending lots of bitmap data up to the share
    // core.
    //
    if (!SBCDDGetNextFreeTile(tileSize, &pTileData))
    {
        TRACE_OUT(( "Unable to get a free tile in shunt buffer"));
        DC_QUIT;
    }

    //
    // Lock the work bitmap to get a surface to pass to EngBitBlt
    //
    pWorkSurf = EngLockSurface((HSURF)g_asbcWorkInfo[tileSize].workBitmap);
    if (pWorkSurf == NULL)
    {
        ERROR_OUT(( "Failed to lock work surface"));
        DC_QUIT;
    }
    TRACE_OUT(( "Locked surface"));

    //
    // Do the Blt to our work bitmap to get the bits at native bpp, and
    // using the color table which we sent to the share core.
    //
    destRectl.top    = 0;
    destRectl.left   = 0;
    destRectl.right  = cxSubBitmapWidth;
    destRectl.bottom = cySubBitmapHeight;

    sourcePt = tileOrg;

    if (!EngBitBlt(pWorkSurf,
                   pSourceSurf,
                   NULL,                    // mask surface
                   NULL,                    // clip object
                   pMemBltInfo->pXlateObj,
                   &destRectl,
                   &sourcePt,
                   NULL,                    // mask origin
                   NULL,                    // brush
                   NULL,                    // brush origin
                   0xcccc))                 // SRCCPY
    {
        ERROR_OUT(( "Failed to Blt to work bitmap"));
        DC_QUIT;
    }
    TRACE_OUT(( "Completed BitBlt"));

    //
    // The Blt succeeded, so pass the bits to the share core by copying
    // them into the correct shunt buffer.
    //
    // bytesUsed is set to the number of bytes required for
    // cySubBitmapHeight number of full scanlines in the shunt buffer tile
    // (NOT the number of bytes available in the tile, or the number of
    // bytes of data which was actually Blted)
    //
    // major/minorCacheInfo are set to details from the source surface.
    // hdev does not change on consecutive Blts from the same surface, but
    // iUniq may.
    //
    pDestSurf            = pMemBltInfo->pDest;
    pDestDev             = (LPOSI_PDEV)pDestSurf->dhpdev;
    pTileData->bytesUsed = BYTES_IN_BITMAP(g_asbcWorkInfo[tileSize].tileWidth,
                                           cySubBitmapHeight,
                                           pDestDev->cBitsPerPel);
    pTileData->srcX           = (TSHR_UINT16)sourcePt.x;
    pTileData->srcY           = (TSHR_UINT16)sourcePt.y;
    pTileData->width          = (WORD)cxSubBitmapWidth;
    pTileData->height         = (WORD)cySubBitmapHeight;
    pTileData->tilingWidth    = (WORD)tileWidth;
    pTileData->tilingHeight   = (WORD)tileHeight;
    pTileData->majorCacheInfo = (UINT_PTR)pSourceSurf->hsurf;
    pTileData->minorCacheInfo = (UINT)pSourceSurf->iUniq;
    pTileData->majorPalette   = (UINT_PTR)pMemBltInfo->pXlateObj;
    pTileData->minorPalette   = (UINT)(pMemBltInfo->pXlateObj != NULL ?
                                           pMemBltInfo->pXlateObj->iUniq : 0);

    //
    // If the source surface has the BMF_DONTCACHE flag set then it is a
    // DIB Section.  This means that an app can change the bits in the
    // surface without calling GDI, and hence without the iUniq value being
    // updated.
    //
    // We rely on iUniq changing for the fast path to work, so we must
    // exclude these bitmaps from the fast path.  Do this by resetting the
    // majorCacheInfo field (we use this rather than minorCacheInfo because
    // we can't tell what an invalid iUniq value is).
    //
    if ( (pSourceSurf->iType == STYPE_BITMAP) &&
         ((pSourceSurf->fjBitmap & BMF_DONTCACHE) != 0) )
    {
        TRACE_OUT(( "Source hsurf %#.8lx has BMF_DONTCACHE set",
                     pTileData->majorCacheInfo));
        pTileData->majorCacheInfo = SBC_DONT_FASTPATH;
    }

    //
    // Note that this only works correctly because we create our work
    // bitmaps to be "top down" rather than the default of "bottom up".
    // i.e.  the data for the top scanline is first in memory, so we can
    // start copying from the start of the bit data.  Bottom up would mean
    // working out an offset into the work bitmap to start copying from.
    //
    memcpy(pTileData->bitData, pWorkSurf->pvBits, pTileData->bytesUsed);

    //
    // We've done the copy.  Reset the work bitmap bits for next time we
    // use this work bitmap - this helps with compression later on.
    //
    memset(pWorkSurf->pvBits, 0, pWorkSurf->cjBits);

    //
    // Fill in the required info in the Mem(3)Blt order.
    //
    if (type == ORD_MEMBLT_TYPE)
    {
        pMemBltOrder->cacheId = pTileData->tileId;
    }
    else
    {
        pMem3BltOrder->cacheId = pTileData->tileId;
    }

    //
    // We've filled in all the data in the shunt buffer entry, so mark it
    // as in use so that the share core can access it.
    //
    pTileData->inUse = TRUE;

    //
    // Must have completed successfully to get to here
    //
    TRACE_OUT(( "Queued tile (%d, %d), %d x %d, tile %d x %d, Id %hx",
                 sourcePt.x,
                 sourcePt.y,
                 cxSubBitmapWidth,
                 cySubBitmapHeight,
                 g_asbcWorkInfo[tileSize].tileWidth,
                 g_asbcWorkInfo[tileSize].tileHeight,
                 pTileData->tileId));
    rc = TRUE;

DC_EXIT_POINT:

    //
    // Unlock the work surface (if required)
    //
    if (pWorkSurf != NULL)
    {
        EngUnlockSurface(pWorkSurf);
        TRACE_OUT(( "Unlocked surface"));
    }

    DebugExitDWORD(SBC_DDCacheMemScreenBlt, rc);
    return(rc);
}



//
// SBC_DDQueryBitmapTileSize()
//
// Once 2.X COMPAT is gone, we don't need this anymore.  We won't set our
// random cell sizes based off of what REMOTES say.
//
BOOL SBC_DDQueryBitmapTileSize
(
    UINT    bmpWidth,
    UINT    bmpHeight,
    UINT *  pTileWidth,
    UINT *  pTileHeight
)
{
    BOOL    rc = FALSE;

    DebugEntry(SBC_DDQueryBitmapTileSize);

    //
    // The tile cell sizes are currently changed when back level nodes
    // join in a 3.0 call, in which case we must take the MINIMUM of the
    // cell sizes/entries for everybody in the share.
    //
    if (g_asbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize <
            BYTES_IN_BITMAP(g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth,
                            g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight,
                            g_sbcSendingBPP))
    {
        //
        // This should be a short-term thing.  When an old dude joins the
        // share, we'll also adjust g_sbcSendingBPP.
        //
        TRACE_OUT(("SBC_DDQueryBitmapTileSize:  No space for any cells"));
        DC_QUIT;
    }

    rc = TRUE;

    //
    // If the large size is adequate, use that cell size
    //
    if (g_asbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize >=
        BYTES_IN_BITMAP(g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth,
                        g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight,
                        g_sbcSendingBPP))
    {
        if ((bmpWidth > g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth) ||
            (bmpHeight > g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight))
        {
            *pTileWidth = g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth;
            *pTileHeight = g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight;
            DC_QUIT;
        }
    }

    //
    // Sigh, medium cells it is.
    //
    *pTileWidth = g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth;
    *pTileHeight = g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDQueryBitmapTileSize, rc);
    return(rc);
}




//
//
// SBC_DDSyncUpdatesNow() - see sbc.h
//
//
void SBC_DDSyncUpdatesNow(LPOSI_PDEV ppDev)
{
    LPSBC_TILE_DATA  pTileData;
    UINT          i;
    UINT          j;

    DebugEntry(SBC_DDSyncUpdatesNow);

    TRACE_OUT(( "Marking all shunt buffer entries as not in use"));

    //
    // We have to mark all entries in the shunt buffers as being free.
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
    	if(g_asbcWorkInfo[i].pShuntBuffer)
    	{
		for (j = 0; j < g_asbcWorkInfo[i].pShuntBuffer->numEntries ; j++)
       		{
        		pTileData = SBCTilePtrFromIndex(g_asbcWorkInfo[i].pShuntBuffer, j);
	            	pTileData->inUse = FALSE;
		}
    	}
        //
        // Reset the MRU counter for this shunt buffer
        //
        g_asbcWorkInfo[i].mruIndex = 0;
    }

    //
    // If we are a palette device (i.e.  we are running at 8 bpp or less),
    // set the paletteChanged flag so we will send up a color table before
    // our next Mem(3)Blt.  We do this because the color table order for
    // the current device palette may have been discarded during the OA
    // sync.
    //
    ppDev->paletteChanged = (ppDev->cBitsPerPel <= 8);

    DebugExitVOID(SBC_DDSyncUpdatesNow);
}


//
//
// SBC_DDOrderSpoiltNotification() - see sbc.h
//
//
void SBC_DDOrderSpoiltNotification(LPINT_ORDER pOrder)
{
    LPMEMBLT_ORDER      pMemBltOrder  = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    UINT                tileId;
    LPSBC_TILE_DATA     pTileData;
    UINT                tileType;
    UINT                i;

    DebugEntry(SBC_DDOrderSpoiltNotification);

    //
    // pOrder has been removed from the order heap before being processed.
    // We have to free up the entry which it references in one of the shunt
    // buffers.  First get the tile Id.
    //
    if (pMemBltOrder->type == ORD_MEMBLT_TYPE)
    {
        tileId = pMemBltOrder->cacheId;
    }
    else
    {
        tileId = pMem3BltOrder->cacheId;
    }
    TRACE_OUT(( "Order referencing tile %hx has been spoiled", tileId));

    //
    // Find out which of the shunt buffers the entry should be in based on
    // the tileId
    //
    tileType = SBC_TILE_TYPE(tileId);

    //
    // We implement the shunt buffers as circular FIFO queues, so we will
    // start looking from the last order which we marked as being in use,
    // and work BACKWARDS.  This is because, in general, the entries after
    // the last one we accessed will not be in use (unless the whole shunt
    // buffer is in use).
    //
    // So, get the index of the last tile we accessed.
    //
    i = g_asbcWorkInfo[tileType].mruIndex;

    //
    // Loop through the circular buffer until we get a match, or have
    // circled back to the beginning.
    //
    // Note that this has been coded as a "do while" loop, rather than just
    // a "while" loop so that we don't miss mruIndex.  mruIndex is set up
    // to point to the NEXT entry to be used, rather than the last entry to
    // be used, so decrementing i before doing any work first time round
    // the loop is actually what we want to do.
    //
    do
    {
        //
        // On to the next tile
        //
        i = (i == 0)
          ? g_asbcWorkInfo[tileType].pShuntBuffer->numEntries - 1
          : i - 1;

        pTileData = SBCTilePtrFromIndex(g_asbcWorkInfo[tileType].pShuntBuffer, i);

        if (pTileData->inUse && (pTileData->tileId == tileId))
        {
            //
            // We've got a match, so mark the tile as being free.
            //
            // We don't want to update the shunt buffer mruIndex - this
            // should remain indicating the next tile to be used when
            // adding an entry to the shunt buffer.
            //
            TRACE_OUT(( "Marked tile Id %hx at index %d as free",
                         tileId,
                         i));
            pTileData->inUse = FALSE;
            break;
        }
    }
    while (i != g_asbcWorkInfo[tileType].mruIndex);

    DebugExitVOID(SBC_DDOrderSpoiltNotification);
}


//
//
// SBC_DDMaybeQueueColorTable() - see sbc.h
//
//
BOOL SBC_DDMaybeQueueColorTable(LPOSI_PDEV ppDev)
{
    BOOL                      queuedOK = FALSE;
    int                       orderSize;
    LPINT_ORDER                  pOrder;
    LPINT_COLORTABLE_ORDER_1BPP  pColorTableOrder;
    UINT                      numColors;
    UINT                      i;

    DebugEntry(SBC_DDMaybeQueueColorTable);

    //
    // If we're running at > 8 bpp, then we don't have a palette, so just
    // quit out.
    //
    if (ppDev->cBitsPerPel > 8)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // Check the boolean in our PDEV to see if the palette has changed
    // since the last time we sent a color table order.  Note that if we
    // have a non palette device, the boolean will never be set.
    //
    if (!ppDev->paletteChanged)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // The palette has changed, so allocate order memory to queue a color
    // table order.  The order size depends on the bpp of our device.  Note
    // that the allocation can fail if the order buffer is full.
    //
    switch (ppDev->cBitsPerPel)
    {
        case 1:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_1BPP);
        }
        break;

        case 4:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_4BPP);
        }
        break;

        case 8:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_8BPP);
        }
        break;

        default:
        {
            ERROR_OUT(("Invalid bpp (%d) for palette device", ppDev->cBitsPerPel));
            DC_QUIT;
        }
        break;
    }

    pOrder = OA_DDAllocOrderMem(orderSize, 0);
    if (pOrder == NULL)
    {
        TRACE_OUT(( "Failed to allocate %d bytes for order", orderSize));
        DC_QUIT;
    }
    TRACE_OUT(( "Allocate %d bytes for color table order", orderSize));

    //
    // We've successfully allocated the order, so fill in the details.  We
    // mark the order as internal so that the Update Packager will spot it
    // up in the share core and prevent it being sent over the wire.
    //
    pOrder->OrderHeader.Common.fOrderFlags = OF_INTERNAL;

    pColorTableOrder = (LPINT_COLORTABLE_ORDER_1BPP)&(pOrder->abOrderData);
    pColorTableOrder->header.type = INTORD_COLORTABLE_TYPE;
    pColorTableOrder->header.bpp  = (TSHR_UINT16)ppDev->cBitsPerPel;

    //
    // Unfortunately we can't just copy the palette from the PDEV into the
    // color table order because the PDEV has an array of PALETTEENTRY
    // structures which are RGBs whereas the order has an array of
    // TSHR_RGBQUADs which are BGRs...
    //
    numColors = COLORS_FOR_BPP(ppDev->cBitsPerPel);
    ASSERT(numColors);

    for (i = 0; i < numColors; i++)
    {
        pColorTableOrder->colorData[i].rgbRed   = ppDev->pPal[i].peRed;
        pColorTableOrder->colorData[i].rgbGreen = ppDev->pPal[i].peGreen;
        pColorTableOrder->colorData[i].rgbBlue  = ppDev->pPal[i].peBlue;
    }

    //
    // Add the order
    //
    OA_DDAddOrder(pOrder, NULL);
    TRACE_OUT(( "Added internal color table order, size %d", orderSize));

    //
    // Reset the flag which indicates that the palette needs to be sent
    //
    ppDev->paletteChanged = FALSE;

    //
    // Must be OK to get to here
    //
    queuedOK = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDMaybeQueueColorTable, queuedOK);
    return(queuedOK);
}





//
// SBCDDCreateShuntBuffers()
//
// Here's where we calc how many cache entries (tiles) we can support.  This
// depends on:
//      * The amount of shared memory we have
//      * The color depth of the driver
//
// There is an upper bound on the amount of memory we'll use, since this
// maps to how much memory on remotes will be needed to store our sent
// cache entries.
//
// The tiles are created in a fixed proportion (MP_RATIO_MTOL).
//
// We return TRUE for success if we can set up the caches and create the
// objects necessary for a sent bitmap cache.
//
BOOL SBCDDCreateShuntBuffers
(
    LPOSI_PDEV  ppDev,
    LPBYTE      psbcSharedMemory,
    DWORD       sbcSharedMemorySize
)
{
    int     i;
    UINT    memPerBuffer[SBC_NUM_TILE_SIZES];
    UINT    memPerTile[SBC_NUM_TILE_SIZES];
    UINT    numTiles[SBC_NUM_TILE_SIZES];
    UINT    memRequired;
    LPBYTE  pBuffer        = psbcSharedMemory;
    BOOL    rc             = FALSE;

    DebugEntry(SBCDDCreateShuntBuffers);

    //
    // We should already have a pointer to the shared memory we can use for
    // our shunt buffers, and the number of bytes available.  What we have
    // to do is to partition this shared memory into SBC_NUM_TILE_SIZE
    // shunt buffers.  i.e. one shunt buffer per tile size.
    //
    //
    // <--- buffer 0 ---><------------------ buffer 1 -------------------->
    //
    //Ŀ
    //    :  :  :  :             :        :         :         :        
    //    :  :  :  :       tile  :  tile  :  tile   :  tile   :  tile  
    //    :  :  :  :             :        :         :         :        
    //
    //^ ^                  ^
    //                   
    //  header[0]      header[1]
    //
    // psbcSharedMemory
    //
    //
    // We try to use the number of entries given in the pEntries array, but
    // if we do not have enough shared memory for this, we reduce the
    // number of entries in each shunt buffer, preserving the ratio between
    // the number of entries in each of the shunt buffers.
    //

    //
    // First make sure that we have some shared memory
    //
    if (sbcSharedMemorySize == 0)
    {
        ERROR_OUT(( "No SBC shared memory !"));
        DC_QUIT;
    }

    // Max out at MP_MEMORY_MAX bytes
    sbcSharedMemorySize = min(sbcSharedMemorySize, MP_MEMORY_MAX);

    //
    // Do we have enough shared memory to satisfy the requested number of
    // entries in each shunt buffer ?
    //
    memRequired = 0;

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        memPerTile[i] = SBC_BYTES_PER_TILE(g_asbcWorkInfo[i].tileWidth,
                                           g_asbcWorkInfo[i].tileHeight,
                                           ppDev->cBitsPerPel);

        // We use the same amount of memory for each tile size.
        numTiles[i] = ((sbcSharedMemorySize / SBC_NUM_TILE_SIZES) -
                         (sizeof(SBC_SHUNT_BUFFER) - sizeof(SBC_TILE_DATA))) /
                        memPerTile[i];
        TRACE_OUT(("Can fit %d tiles of memory size %d in tile cache %d",
            numTiles[i], memPerTile[i], i));

        memPerBuffer[i] = (numTiles[i] * memPerTile[i]) +
                          (sizeof(SBC_SHUNT_BUFFER) - sizeof(SBC_TILE_DATA));
        memRequired    += memPerBuffer[i];
    }

    TRACE_OUT(( "%d bytes required for request, %d bytes available",
                 memRequired,
                 sbcSharedMemorySize));

    ASSERT(memRequired <= sbcSharedMemorySize);

    // Zero out rest of amount we're going to use
    RtlFillMemory(psbcSharedMemory, memRequired, 0);


    //
    // OK, we've got the
    //   - the bytes per tile in memPerTile[i]
    //   - number of entries per shunt buffer in numTiles[i]
    //   - the total size of each shunt buffer in memPerBuffer[i].
    //
    // Do the partitioning.
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        g_asbcWorkInfo[i].pShuntBuffer = (LPSBC_SHUNT_BUFFER)pBuffer;

        g_asbcWorkInfo[i].pShuntBuffer->numEntries    = numTiles[i];
        g_asbcWorkInfo[i].pShuntBuffer->numBytes      = memPerTile[i]
                                                   - sizeof(SBC_TILE_DATA);
        g_asbcWorkInfo[i].pShuntBuffer->structureSize = memPerTile[i];

        //
        // Move the buffer pointer past the memory we are using for this
        // shunt buffer.
        //
        pBuffer += memPerBuffer[i];

        TRACE_OUT(( "Shunt buffer %d at %#.8lx: tile bytes %u, "
                     "structure size %u, num entries %u",
                     i,
                     g_asbcWorkInfo[i].pShuntBuffer,
                     g_asbcWorkInfo[i].pShuntBuffer->numBytes,
                     g_asbcWorkInfo[i].pShuntBuffer->structureSize,
                     g_asbcWorkInfo[i].pShuntBuffer->numEntries));

        //
        // Fill in the mruIndex for this shunt buffer
        //
        g_asbcWorkInfo[i].mruIndex = 0;
    }

    //
    // Initialize the global variables associated with the shunt buffers
    //
    g_sbcNextTileId = 0;

    //
    // Must be OK to get to here
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDCreateShuntBuffers, rc);
    return(rc);
}




//
// Name:      SBCGetNextFreeTile
//
// Purpose:   Return the next free tile of the correct size from one of the
//            shunt buffers.
//
// Returns:   TRUE if a tile is returned, FALSE otherwise
//
// Params:    IN  workTileSize - The tile size.  One of
//                     SBC_MEDIUM_TILE
//                     SBC_LARGE_TILE
//            OUT ppTileData   - A pointer to the tile.
//
// Operation: The tileId field of the tile is filled in on return from
//            this function.
//
//
BOOL SBCDDGetNextFreeTile(int tileSize, LPSBC_TILE_DATA FAR * ppTileData)
{
    BOOL              foundFreeTile = FALSE;
    LPSBC_TILE_DATA      pTileData;

    DebugEntry(SBCDDGetNextFreeTile);

    //
    // Make sure that we have a valid tile size
    //
    if (tileSize >= SBC_NUM_TILE_SIZES)
    {
        ERROR_OUT(( "Invalid tile size %d", tileSize));
        DC_QUIT;
    }

    //
    // Get a pointer to the next entry to be used in the shunt buffer
    // containing tiles of the given size.
    //
    pTileData = SBCTilePtrFromIndex(g_asbcWorkInfo[tileSize].pShuntBuffer,
                                        g_asbcWorkInfo[tileSize].mruIndex);

    //
    // If the entry is still in use (the share core has not yet processed
    // the order which references this tile) we have to quit - the shunt
    // buffer is full.
    //
    if (pTileData->inUse)
    {
        TRACE_OUT(( "Target entry (%d, %d) is still in use",
                     tileSize,
                     g_asbcWorkInfo[tileSize].mruIndex));
        DC_QUIT;
    }

    //
    // The entry is not in use - we can re-use it.  Fill in the Id field,
    // and the pointer to the entry which we return to the caller.
    //
    // We always set the top bit of the tile Id for large tiles, and clear
    // it for small tiles.
    //
    *ppTileData       = pTileData;
    pTileData->tileId = g_sbcNextTileId;
    if (tileSize == SBC_MEDIUM_TILE_INDEX)
    {
        pTileData->tileId &= ~0x8000;
    }
    else
    {
        pTileData->tileId |= 0x8000;
    }
    TRACE_OUT(( "Returning entry (%d, %d), Id %hx",
                 tileSize,
                 g_asbcWorkInfo[tileSize].mruIndex,
                 pTileData->tileId));

    //
    // Update the index of the next free entry in this shunt buffer, and
    // also the Id which we should assign next time.  Remember to wrap the
    // shunt buffer index to the number of entries in the shunt buffer.
    //
    g_asbcWorkInfo[tileSize].mruIndex = (g_asbcWorkInfo[tileSize].mruIndex + 1) %
                               g_asbcWorkInfo[tileSize].pShuntBuffer->numEntries;


    g_sbcNextTileId++;
    g_sbcNextTileId &= ~0x8000;

    //
    // Completed successfully !
    //
    foundFreeTile = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDGetNextFreeTile, foundFreeTile);
    return(foundFreeTile);
}


//
//
// Name:      SBCDDIsBitmapThrasher
//
// Purpose:   Check to see if the given bitmap (surface object) is one
//            which would cause cache thrashing.
//
// Returns:   TRUE if the bitmap is a thrasher, FALSE otherwise.
//
// Params:    IN  pSurfObj - Pointer to the bitmap
//
//
BOOL SBCDDIsBitmapThrasher(SURFOBJ * pSurfObj)
{
    UINT      i;
    BOOL      rc = FALSE;
    BOOL      bitmapInList = FALSE;
    BOOL      updateEntry  = FALSE;
    UINT      updateIndex;
    UINT    nextTickCount;
    UINT      evictIndex;
    UINT    evictTickCount;

    DebugEntry(SBCDDIsBitmapThrasher);

    //
    // Here's an overview of how our bitmap cache thrash detection works...
    //
    // We hold an array of information about the last SBC_NUM_THRASHERS
    // bitmaps which we have tried to cache.  This information is
    //  - A value to identify the bitmap.  This is the hsurf field from the
    //    bitmap surface object, and is different for every bitmap.
    //  - A value to identify the "version" of the bitmap.  This is the
    //    iUniq field from the bitmap surface object, and is updated by GDI
    //    each time the bitmap is drawn to.
    //  - A timestamp for the last time which we saw iUniq change for this
    //    bitmap (or when we added the bitmap to the array).
    //
    // Each time this function is called, we scan this array looking for an
    // entry for the bitmap.
    //
    // If we find an entry, we check whether the bitmap has changed (has
    // the iUniq field changed).  If it has not changed, the bitmap is not
    // a thrasher.  If the bitmap has changed, we check the interval from
    // the timestamp value to the current time.  If the interval is less
    // than the SBC_THRASH_INTERVAL, the bitmap has changed too quickly, so
    // it is a thrasher.  If the interval is OK, the bitmap is not a
    // thrasher.  In either case, we update the stored iUniq field and the
    // timestamp to record the time / version at which we spotted that the
    // bitmap changed.
    //
    // If we do not find an entry for the bitmap, we add an entry for it.
    // If the array is fully populated, we evict the entry with the oldest
    // timestamp, and replace it with the new entry.
    //

    //
    // Scan the thrasher list looking for a match
    //
    for (i=0 ; i<SBC_NUM_THRASHERS ; i++)
    {
        //
        // If we find a match then we are only worried if it has been
        // modified since the last time we read it.
        //
        if (g_sbcThrashers[i].hsurf == pSurfObj->hsurf)
        {
            bitmapInList = TRUE;

            if (g_sbcThrashers[i].iUniq != pSurfObj->iUniq)
            {
                TRACE_OUT(( "Matching surface %x, index %u,"
                             "tick count %u has been modified",
                             pSurfObj->hsurf,
                             i,
                             g_sbcThrashers[i].tickCount));
                updateEntry = TRUE;
                updateIndex = i;

                //
                // Now we need to determine if this is a thrasher.  It is a
                // thrasher if the time we last read it is less than our
                // thrash interval.  (We only update the time when we read
                // a modified bitmap)
                //
                nextTickCount = SBCDDGetTickCount();
                if ((nextTickCount - g_sbcThrashers[i].tickCount) <
                                                          SBC_THRASH_INTERVAL)
                {
                    TRACE_OUT((
                             "Rejected cache attempt of thrashy bitmap %x",
                             pSurfObj->hsurf));
                    rc = TRUE;
                }
                g_sbcThrashers[i].tickCount = nextTickCount;
                g_sbcThrashers[i].iUniq     = pSurfObj->iUniq;
            }

            //
            // We've found a match - we can break out of the loop
            //
            break;
        }
    }

    if (!bitmapInList)
    {
        //
        // The bitmap isn't already in the thrasher list, so add it now.
        // Find the entry with the smallest (earliest) tick count - we will
        // evict this entry from the array to make room for the new entry.
        //
        evictIndex     = 0;
        evictTickCount = 0xffffffff;

        for (i=0 ; i<SBC_NUM_THRASHERS ; i++)
        {
            if (evictTickCount > g_sbcThrashers[i].tickCount)
            {
                evictTickCount = g_sbcThrashers[i].tickCount;
                evictIndex     = i;
            }
        }
        TRACE_OUT(( "Evicting entry %d, surface %x",
                     evictIndex,
                     g_sbcThrashers[i].hsurf));

        nextTickCount = SBCDDGetTickCount();

        TRACE_OUT(( "Adding surface %x to thrash list, tick %d",
                     pSurfObj->hsurf,
                     nextTickCount));
        updateEntry = TRUE;
        updateIndex = evictIndex;
    }

    if (updateEntry)
    {
        //
        // We have to update the entry at index updateIndex.  We optimise
        // things slightly by always putting the most recent bitmap in
        // position 0 of the array, so copy entry 0 to the eviction index,
        // and put the new entry in position 0.
        //
        g_sbcThrashers[updateIndex] = g_sbcThrashers[0];

        g_sbcThrashers[0].hsurf     = pSurfObj->hsurf;
        g_sbcThrashers[0].iUniq     = pSurfObj->iUniq;
        g_sbcThrashers[0].tickCount = nextTickCount;
    }

    DebugExitBOOL(SBCDDIsBitmapThrasher, rc);
    return(rc);
}


//
//
// Name:      SBCDDGetTickCount
//
// Purpose:   Get a system tick count
//
// Returns:   The number of centi-seconds since the system was started.
//            This number will wrap after approximately 497 days!
//
// Params:    None
//
//
DWORD SBCDDGetTickCount(void)
{
    DWORD       tickCount;
    LONGLONG    perfTickCount;

    DebugEntry(SBCDDGetTickCount);

    //
    // Get the number of system ticks since the system was started.
    //
    EngQueryPerformanceCounter(&perfTickCount);

    //
    // Now convert this into a number of centi-seconds.  g_sbcPerfFrequency
    // contains the number of system ticks per second.
    //
    tickCount = (DWORD)((100 * perfTickCount) / g_sbcPerfFrequency);

    DebugExitDWORD(SBCDDGetTickCount, tickCount);
    return(tickCount);
}


//
// FUNCTION:    SBCDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SBC related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SBCDDSetNewCapabilities(LPSBC_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SBCSetNewCapabilities);

    g_sbcSendingBPP     = pCapabilities->sendingBpp;
    memcpy(&g_asbcCacheInfo, pCapabilities->cacheInfo, sizeof(g_asbcCacheInfo));

    DebugExitVOID(SBCSetNewCapabilities);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\osi.c ===
#include "precomp.h"


//
// OSI.C
// OS Isolation layer, display driver side
//
// Copyright(c) Microsoft 1997-
//


#include <version.h>
#include <ndcgver.h>


//
// These are the default 20 Windows colors, lifted from the base S3 driver.
//
// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.
const PALETTEENTRY s_aWinColors[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};



//
// Functions supported by our Display Driver.  Each entry is of the form:
//
//  index    - NT DDK defined index for the DDI function
//
//  function - pointer to our intercept function
//
//
const DRVFN s_osiDriverFns[] =
{
    //
    // NT4 FUNCTIONS
    //
    { INDEX_DrvEnablePDEV,        (PFN)DrvEnablePDEV        },
    { INDEX_DrvCompletePDEV,      (PFN)DrvCompletePDEV      },
    { INDEX_DrvDisablePDEV,       (PFN)DrvDisablePDEV       },
    { INDEX_DrvEnableSurface,     (PFN)DrvEnableSurface     },
    { INDEX_DrvDisableSurface,    (PFN)DrvDisableSurface    },

    { INDEX_DrvAssertMode,        (PFN)DrvAssertMode        },
    { INDEX_DrvResetPDEV,         (PFN)DrvResetPDEV         },
        // INDEX_DrvCreateDeviceBitmap  not used
        // INDEX_DrvDeleteDeviceBitmap  not used
    { INDEX_DrvRealizeBrush,      (PFN)DrvRealizeBrush      },
        // INDEX_DrvDitherColor         not used
    { INDEX_DrvStrokePath,        (PFN)DrvStrokePath        },
    { INDEX_DrvFillPath,          (PFN)DrvFillPath          },

    { INDEX_DrvStrokeAndFillPath, (PFN)DrvStrokeAndFillPath },
    { INDEX_DrvPaint,             (PFN)DrvPaint             },
    { INDEX_DrvBitBlt,            (PFN)DrvBitBlt            },
    { INDEX_DrvCopyBits,          (PFN)DrvCopyBits          },
    { INDEX_DrvStretchBlt,        (PFN)DrvStretchBlt        },

    { INDEX_DrvSetPalette,        (PFN)DrvSetPalette        },
    { INDEX_DrvTextOut,           (PFN)DrvTextOut           },
    { INDEX_DrvEscape,            (PFN)DrvEscape            },
        // INDEX_DrvDrawEscape          not used
        // INDEX_DrvQueryFont           not used
        // INDEX_DrvQueryFontTree       not used
        // INDEX_DrvQueryFontData       not used
    { INDEX_DrvSetPointerShape,   (PFN)DrvSetPointerShape   },
    { INDEX_DrvMovePointer,       (PFN)DrvMovePointer       },

    { INDEX_DrvLineTo,            (PFN)DrvLineTo            },
        // INDEX_DrvSendPage            not used
        // INDEX_DrvStartPage           not used
        // INDEX_DrvEndDoc              not used
        // INDEX_DrvStartDoc            not used
        // INDEX_DrvGetGlyphMode        not used
        // INDEX_DrvSynchronize         not used
    { INDEX_DrvSaveScreenBits,    (PFN)DrvSaveScreenBits    },
    { INDEX_DrvGetModes,          (PFN)DrvGetModes          },
        // INDEX_DrvFree                not used
        // INDEX_DrvDestroyFont         not used
        // INDEX_DrvQueryFontCaps       not used
        // INDEX_DrvLoadFontFile        not used
        // INDEX_DrvUnloadFontFile      not used
        // INDEX_DrvFontManagement      not used
        // INDEX_DrvQueryTrueTypeTable  not used
        // INDEX_DrvQueryTrueTypeOutline    not used
        // INDEX_DrvGetTrueTypeFile     not used
        // INDEX_DrvQueryFontFile       not used
        // INDEX_DrvQueryAdvanceWidths  not used
        // INDEX_DrvSetPixelFormat      not used
        // INDEX_DrvDescribePixelFormat not used
        // INDEX_DrvSwapBuffers         not used
        // INDEX_DrvStartBanding        not used
        // INDEX_DrvNextBand            not used
        // INDEX_DrvGetDirectDrawInfo   not used
        // INDEX_DrvEnableDirectDraw    not used
        // INDEX_DrvDisableDirectDraw   not used
        // INDEX_DrvQuerySpoolType      not used

    //
    // NT5 FUNCTIONS - 5 of them currently.  If you add to this list,
    // update CFN_NT5 below.
    //
        // INDEX_DrvIcmCreateColorTransform not used
        // INDEX_DrvIcmDeleteColorTransform not used
        // INDEX_DrvIcmCheckBitmapBits  not used
        // INDEX_DrvIcmSetDeviceGammaRamp   not used
    { INDEX_DrvGradientFill,      (PFN)DrvGradientFill      },
    { INDEX_DrvStretchBltROP,     (PFN)DrvStretchBltROP     },

    { INDEX_DrvPlgBlt,            (PFN)DrvPlgBlt            },
    { INDEX_DrvAlphaBlend,        (PFN)DrvAlphaBlend        },
        // INDEX_DrvSynthesizeFont      not used
        // INDEX_DrvGetSynthesizedFontFiles not used
    { INDEX_DrvTransparentBlt,    (PFN)DrvTransparentBlt    },
        // INDEX_DrvQueryPerBandInfo    not used
        // INDEX_DrvQueryDeviceSupport  not used
        // INDEX_DrvConnect             not used
        // INDEX_DrvDisconnect          not used
        // INDEX_DrvReconnect           not used
        // INDEX_DrvShadowConnect       not used
        // INDEX_DrvShadowDisconnect    not used
        // INDEX_DrvInvalidateRect      not used
        // INDEX_DrvSetPointerPos       not used
        // INDEX_DrvDisplayIOCtl        not used
        // INDEX_DrvDeriveSurface       not used
        // INDEX_DrvQueryGlyphAttrs     not used
};


#define CFN_NT5         5



//
// s_osiDefaultGdi
//
// This contains the default GDIINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//       It is expected that DDML ignores a lot of these parameters and
//       uses the values from the primary driver instead
//

const GDIINFO s_osiDefaultGdi =
{
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    400,                    // ulHorzSize (display width: mm)
    300,                    // ulVertSize (display height: mm)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    1,                      // cPlanes
    (ULONG)-1,              // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)
    96,                     // ulLogPixelsX (filled in later)
    96,                     // ulLogPixelsY (filled in later)
    TC_RA_ABLE,             // flTextCaps - If we had wanted console windows
                        // to scroll by repainting the entire window,
                        // instead of doing a screen-to-screen blt, we
                        // would have set TC_SCROLLBLT (yes, the flag
                        // is backwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)
    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)
    1,                      // xStyleStep
    1,                      // yStyleStep
    3,                      // denStyleStep -- Styles have a one-to-one
                            // aspect ratio, and every dot is 3 pixels long
    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize
    0,                      // ulNumPalReg

    {
        { 6700, 3300, 0 },   //      Red
        { 2100, 7100, 0 },   //      Green
        { 1400,  800, 0 },   //      Blue
        { 1750, 3950, 0 },   //      Cyan
        { 4050, 2050, 0 },   //      Magenta
        { 4400, 5200, 0 },   //      Yellow
        { 3127, 3290, 0 },   //      AlignmentWhite
        20000,               //      RedGamma
        20000,               //      GreenGamma
        20000,               //      BlueGamma
        0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
};


//
// s_osiDefaultDevInfo
//
// This contains the default DEVINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//
const DEVINFO s_osiDefaultDevInfo =
{
    {
        GCAPS_OPAQUERECT       |
        GCAPS_DITHERONREALIZE  |
        GCAPS_PALMANAGED       |
        GCAPS_MONO_DITHER      |
        GCAPS_COLOR_DITHER     |
        GCAPS_LAYERED
    },                          // NOTE: Only enable ASYNCMOVE if your code
                            //   and hardware can handle DrvMovePointer
                            //   calls at any time, even while another
                            //   thread is in the middle of a drawing
                            //   call such as DrvBitBlt.

                            // flGraphicsFlags
    {   16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,
        VARIABLE_PITCH | FF_DONTCARE, L"System"
    },
                            // lfDefaultFont

    {
        12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
        CLIP_STROKE_PRECIS,PROOF_QUALITY,
        VARIABLE_PITCH | FF_DONTCARE, L"MS Sans Serif"
    },
                            // lfAnsiVarFont

    {
        12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
        CLIP_STROKE_PRECIS,PROOF_QUALITY,
        FIXED_PITCH | FF_DONTCARE, L"Courier"
    },
                            // lfAnsiFixFont

    0,                          // cFonts
    BMF_8BPP,                   // iDitherFormat
    8,                          // cxDither
    8,                          // cyDither
    0                           // hpalDefault (filled in later)
};



//
// DrvEnableDriver - see NT DDK documentation.
//
// This is the only directly exported entry point to the display driver.
// All other entry points are exported through the data returned from this
// function.
//
BOOL DrvEnableDriver
(
    ULONG          iEngineVersion,
    ULONG          cj,
    DRVENABLEDATA* pded
)
{
    DebugEntry(DrvEnableDriver);

    INIT_OUT(("DrvEnableDriver(iEngineVersion = 0x%08x)", iEngineVersion));

    //
    // Check that the engine version is correct - we refuse to load on
    // other versions because we will almost certainly not work.
    //
    if (iEngineVersion < DDI_DRIVER_VERSION_SP3)
    {
        INIT_OUT(("DrvEnableDriver: Not NT 4.0 SP-3 or NT 5.0; failing enable"));
        return(FALSE);
    }

    //
    // Fill in as much as we can.  Start with the entry points.
    //
    if ( cj >= FIELD_OFFSET(DRVENABLEDATA, pdrvfn) +
               FIELD_SIZE  (DRVENABLEDATA, pdrvfn) )
    {
        pded->pdrvfn = (DRVFN *)s_osiDriverFns;
    }

    //
    // Size of our entry point array.
    //
    if ( cj >= FIELD_OFFSET(DRVENABLEDATA, c) +
               FIELD_SIZE  (DRVENABLEDATA, c) )
    {
        //
        // If this is NT4, return back a subset -- it doesn't like tables
        // with unknown indeces
        //
        pded->c = sizeof(s_osiDriverFns) / sizeof(s_osiDriverFns[0]);
        if (iEngineVersion < DDI_DRIVER_VERSION_NT5)
        {
            pded->c -= CFN_NT5;
        }
        INIT_OUT(("DrvEnableDriver: Returning driver function count %u", pded->c));
    }

    //
    // DDI version this driver was targeted for is passed back to engine.
    // Future graphics engines may break calls down to old driver format.
    //
    if ( cj >= FIELD_OFFSET(DRVENABLEDATA, iDriverVersion) +
               FIELD_SIZE  (DRVENABLEDATA, iDriverVersion) )
    {
        //
        // Return back NT5 when we're on NT5.  Hopefully this will work
        // OK...
        //
        pded->iDriverVersion = iEngineVersion;
        INIT_OUT(("DrvEnableDriver: Returning driver version 0x%08x", pded->iDriverVersion));
    }

    DebugExitVOID(DrvEnableDriver);
    return(TRUE);
}


//
// DrvDisableDriver - see NT DDK documentation.
//
VOID DrvDisableDriver(VOID)
{
    DebugEntry(DrvDisableDriver);

    DebugExitVOID(DrvDisableDriver);
}


//
// DrvEnablePDEV - see NT DDK documentation.
//
// Initializes a bunch of fields for GDI, based on the mode we've been
// asked to do.  This is the first thing called after DrvEnableDriver, when
// GDI wants to get some information about us.
//
// (This function mostly returns back information; DrvEnableSurface is used
// for initializing the hardware and driver components.)
//
//
DHPDEV DrvEnablePDEV(DEVMODEW*   pdm,
                     PWSTR       pwszLogAddr,
                     ULONG       cPat,
                     HSURF*      phsurfPatterns,
                     ULONG       cjCaps,
                     ULONG*      pdevcaps,
                     ULONG       cjDevInfo,
                     DEVINFO*    pdi,
                     HDEV        hdev,
                     PWSTR       pwszDeviceName,
                     HANDLE      hDriver)
{
    DHPDEV    rc = NULL;
    LPOSI_PDEV ppdev = NULL;
    GDIINFO   gdiInfoNew;

    DebugEntry(DrvEnablePDEV);

    INIT_OUT(("DrvEnablePDEV: Parameters:"));
    INIT_OUT(("     PWSTR       pdm->dmDeviceName %ws", pdm->dmDeviceName));
    INIT_OUT(("     HDEV        hdev            0x%08x", hdev));
    INIT_OUT(("     PWSTR       pwszDeviceName  %ws", pwszDeviceName));
    INIT_OUT(("     HANDLE      hDriver         0x%08x", hDriver));

    //
    // This function only sets up local data, so shared memory protection
    // is not required.
    //

    //
    // Make sure that we have large enough data to reference.
    //
    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        ERROR_OUT(( "Buffer size too small %lu %lu", cjCaps, cjDevInfo));
        DC_QUIT;
    }

    //
    // Allocate a physical device structure.
    //
    ppdev = EngAllocMem(FL_ZERO_MEMORY, sizeof(OSI_PDEV), OSI_ALLOC_TAG);
    if (ppdev == NULL)
    {
        ERROR_OUT(( "DrvEnablePDEV - Failed EngAllocMem"));
        DC_QUIT;
    }

    ppdev->hDriver = hDriver;

    //
    // Set up the current screen mode information based upon the supplied
    // mode settings.
    //
    if (!OSIInitializeMode((GDIINFO *)pdevcaps,
                                 pdm,
                                 ppdev,
                                 &gdiInfoNew,
                                 pdi))
    {
        ERROR_OUT(( "Failed to initialize mode"));
        DC_QUIT;
    }

    memcpy(pdevcaps, &gdiInfoNew, min(sizeof(GDIINFO), cjCaps));

    INIT_OUT(("DrvEnablePDEV: Returning DEVINFO:"));
    INIT_OUT(("     FLONG       flGraphicsCaps  0x%08x", pdi->flGraphicsCaps));
    INIT_OUT(("     ULONG       iDitherFormat   %d",     pdi->iDitherFormat));
    INIT_OUT(("     HPALETTE    hpalDefault     0x%08x", pdi->hpalDefault));

    INIT_OUT(("DrvEnablePDEV: Returning GDIINFO (pdevcaps):"));
    INIT_OUT(("     ULONG       ulVersion       0x%08x",    gdiInfoNew.ulVersion));
    INIT_OUT(("     ULONG       ulHorzSize      %d",    gdiInfoNew.ulHorzSize));
    INIT_OUT(("     ULONG       ulVertSize      %d",    gdiInfoNew.ulVertSize));
    INIT_OUT(("     ULONG       ulHorzRes       %d",    gdiInfoNew.ulHorzRes));
    INIT_OUT(("     ULONG       ulVertRes       %d",    gdiInfoNew.ulVertRes));
    INIT_OUT(("     ULONG       cBitsPixel      %d",    gdiInfoNew.cBitsPixel));
    INIT_OUT(("     ULONG       cPlanes         %d",    gdiInfoNew.cPlanes));
    INIT_OUT(("     ULONG       ulNumColors     %d",    gdiInfoNew.ulNumColors));
    INIT_OUT(("     ULONG       ulDACRed        0x%08x",    gdiInfoNew.ulDACRed));
    INIT_OUT(("     ULONG       ulDACGreen      0x%08x",    gdiInfoNew.ulDACGreen));
    INIT_OUT(("     ULONG       ulDACBlue       0x%08x",    gdiInfoNew.ulDACBlue));
    INIT_OUT(("     ULONG       ulHTOutputFormat %d",   gdiInfoNew.ulHTOutputFormat));

    //
    // We have successfully initialized - return the new PDEV.
    //
    rc = (DHPDEV)ppdev;

DC_EXIT_POINT:
    //
    // Release any resources if we failed to initialize.
    //
    if (rc == NULL)
    {
        ERROR_OUT(("DrvEnablePDEV failed; cleaning up by disabling"));
        DrvDisablePDEV(NULL);
    }

    DebugExitPVOID(DrvEnablePDEV, rc);
    return(rc);
}


//
// DrvDisablePDEV - see NT DDK documentation
//
// Release the resources allocated in DrvEnablePDEV.  If a surface has been
// enabled DrvDisableSurface will have already been called.
//
// Note that this function will be called when previewing modes in the
// Display Applet, but not at system shutdown.
//
// Note: In an error, we may call this before DrvEnablePDEV is done.
//
//
VOID DrvDisablePDEV(DHPDEV  dhpdev)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvDisablePDEV);

    INIT_OUT(("DrvDisablePDEV(dhpdev = 0x%08x)", dhpdev));

    //
    // Free the resources we allocated for the display.
    //
    if (ppdev != NULL)
    {
        if (ppdev->hpalCreated != NULL)
        {
            EngDeletePalette(ppdev->hpalCreated);
            ppdev->hpalCreated = NULL;
        }

        if (ppdev->pPal != NULL)
        {
            EngFreeMem(ppdev->pPal);
            ppdev->pPal = NULL;
        }

        EngFreeMem(ppdev);
    }

    DebugExitVOID(DrvDisablePDEV);
}


//
// DrvCompletePDEV - see NT DDK documentation
//
// Stores the HPDEV, the engine's handle for this PDEV, in the DHPDEV.
//
VOID DrvCompletePDEV( DHPDEV dhpdev,
                      HDEV   hdev )
{
    DebugEntry(DrvCompletePDEV);

    //
    // Store the device handle for our display handle.
    //
    INIT_OUT(("DrvCompletePDEV(dhpdev = 0x%08x, hdev = 0x%08x)", dhpdev, hdev));

    ((LPOSI_PDEV)dhpdev)->hdevEng = hdev;

    DebugExitVOID(DrvCompletePDEV);
}


//
// DrvResetPDEV - see NT DDK documentation
//
// Allows us to reject dynamic screen changes if necessary ON NT4 ONLY
// This is NOT CALLED on NT5.
//
BOOL DrvResetPDEV
(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
)
{
    BOOL rc = TRUE;

    DebugEntry(DrvResetPDEV);

    INIT_OUT(("DrvResetPDEV(dhpdevOld = 0x%08x, dhpdevNew = 0x%08x)", dhpdevOld,
        dhpdevNew));

    //
    // We can only allow the display driver to change modes while DC-Share
    // is not running.
    //
    if (g_shmMappedMemory != NULL)
    {
        //
        // Deny the request.
        //
        rc = FALSE;
    }

    DebugExitDWORD(DrvResetPDEV, rc);
    return(rc);
}


//
// DrvEnableSurface - see NT DDK documentation
//
// Creates the drawing surface and initializes driver components.  This
// function is called after DrvEnablePDEV, and performs the final device
// initialization.
//
//
HSURF DrvEnableSurface(DHPDEV dhpdev)
{
    LPOSI_PDEV  ppdev = (LPOSI_PDEV)dhpdev;
    HSURF      hsurf;
    SIZEL      sizl;
    LPOSI_DSURF pdsurf;
    HSURF      rc = 0;

    DWORD returnedDataLength;
    DWORD MaxWidth, MaxHeight;
    VIDEO_MEMORY videoMemory;
    VIDEO_MEMORY_INFORMATION videoMemoryInformation;

    DebugEntry(DrvEnableSurface);

    INIT_OUT(("DrvEnableSurface: Parameters:"));
    INIT_OUT(("     LPOSI_PDEV  ppdev           0x%08x", ppdev));
    INIT_OUT(("     HDRIVER     ->hDriver       0x%08x", ppdev->hDriver));
    INIT_OUT(("     INT         ->cxScreen      %d", ppdev->cxScreen));
    INIT_OUT(("     INT         ->cyScreen      %d", ppdev->cyScreen));

    //
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // DSURF structure allocated below.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.
    //
    pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(OSI_DSURF), OSI_ALLOC_TAG);
    if (pdsurf == NULL)
    {
        ERROR_OUT(( "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        DC_QUIT;
    }

    //
    // Store the screen surface details.
    //
    ppdev->pdsurfScreen = pdsurf;
    pdsurf->sizl.cx     = ppdev->cxScreen;
    pdsurf->sizl.cy     = ppdev->cyScreen;
    pdsurf->ppdev       = ppdev;

    INIT_OUT(("DrvEnableSurface: Returning surface pointer 0x%08x", pdsurf));

    //
    // Only map the shared memory the first time we are called.
    //
    if (g_asSharedMemory == NULL)
    {
        //
        // Map the pointer to the shared section in the miniport driver
        //
        videoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                               &videoMemory,
                               sizeof(VIDEO_MEMORY),
                               &videoMemoryInformation,
                               sizeof(VIDEO_MEMORY_INFORMATION),
                               &returnedDataLength))
        {
            ERROR_OUT(( "Could not MAP miniport section"));
            DC_QUIT;
        }

        INIT_OUT(("DrvEnableSurface: Got video memory info from EngDeviceIoControl:"));
        INIT_OUT(("    FrameBufferBase          0x%08x", videoMemoryInformation.FrameBufferBase));
        INIT_OUT(("    FrameBufferLength        0x%08x", videoMemoryInformation.FrameBufferLength));

        g_shmSharedMemorySize = videoMemoryInformation.FrameBufferLength;

        // First block is shared memory header
        g_asSharedMemory = (LPSHM_SHARED_MEMORY)
                           videoMemoryInformation.FrameBufferBase;

        // Next are the two large OA_FAST_DATA blocks
        g_poaData[0]    = (LPOA_SHARED_DATA)(g_asSharedMemory + 1);
        g_poaData[1]    = (LPOA_SHARED_DATA)(g_poaData[0] + 1);
    }

    //
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we
    // ensure that GDI will only ever access the bitmaps bits via the Drv
    // calls that we've HOOKed.
    //
    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    //
    // Otherwise the primary display driver has its own bitmap used by the
    // physical hardware, so we do not need to do any drawing ourself.
    //
    INIT_OUT(("DrvEnableSurface: Calling EngCreateDeviceSurface with:"));
    INIT_OUT(("     Sizl.cx         %d", sizl.cx));
    INIT_OUT(("     Sizl.cy         %d", sizl.cy));
    INIT_OUT(("     BitmapFormat    %d", ppdev->iBitmapFormat));

    hsurf = EngCreateDeviceSurface( (DHSURF)pdsurf,
                                    sizl,
                                    ppdev->iBitmapFormat );

    if (hsurf == 0)
    {
        ERROR_OUT(( "Could not allocate surface"));
        DC_QUIT;
    }

    //
    // Store the screen surface handle.
    //
    ppdev->hsurfScreen = hsurf;

    //
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //
    if (!EngAssociateSurface(hsurf, ppdev->hdevEng,
                HOOK_BITBLT             |
                HOOK_STRETCHBLT         |
                HOOK_PLGBLT             |
                HOOK_TEXTOUT            |
                HOOK_PAINT              |       // OBSOLETE
                HOOK_STROKEPATH         |
                HOOK_FILLPATH           |
                HOOK_STROKEANDFILLPATH  |
                HOOK_LINETO             |
                HOOK_COPYBITS           |
                HOOK_STRETCHBLTROP      |
                HOOK_TRANSPARENTBLT     |
                HOOK_ALPHABLEND         |
                HOOK_GRADIENTFILL       |
                HOOK_SYNCHRONIZEACCESS))        // OBSOLETE
    {
        ERROR_OUT(( "DrvEnableSurface - Failed EngAssociateSurface"));
        DC_QUIT;
    }

    //
    // We have successfully associated the surface so return it to the GDI.
    //
    rc = hsurf;

DC_EXIT_POINT:
    //
    // Tidy up any resources if we failed.
    //
    if (rc == 0)
    {
        DrvDisableSurface((DHPDEV) ppdev);
    }

    DebugExitPVOID(DrvEnableSurface, rc);
    return(rc);
}


//
// DrvDisableSurface - see NT DDK documentation
//
// Free resources allocated by DrvEnableSurface.  Release the surface.
//
// Note that this function will be called when previewing modes in the
// Display Applet, but not at system shutdown.  If you need to reset the
// hardware at shutdown, you can do it in the miniport by providing a
// 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
//
// Note: In an error case, we may call this before DrvEnableSurface is
//       completely done.
//
VOID DrvDisableSurface(DHPDEV dhpdev)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvDisableSurface);

    INIT_OUT(("DrvDisableSurface(dhpdev = 0x%08x)", dhpdev));

    if (ppdev->hsurfScreen != 0)
    {
        EngDeleteSurface(ppdev->hsurfScreen);
    }

    if (ppdev->pdsurfScreen != NULL)
    {
        EngFreeMem(ppdev->pdsurfScreen);
    }

    DebugExitVOID(DrvDisableSurface);
}


//
// DrvEscape - see NT DDK documentation.
//
ULONG DrvEscape(SURFOBJ *pso,
                ULONG    iEsc,
                ULONG    cjIn,
                PVOID    pvIn,
                ULONG    cjOut,
                PVOID    pvOut)
{
    ULONG                   rc = FALSE;
    LPOSI_ESCAPE_HEADER     pHeader;

    DebugEntry(DrvEscape);

    TRACE_OUT(("DrvEscape called with escape %d", iEsc));

    //
    // All functions we support use an identifier in the input data to make
    // sure that we don't try to use another driver's escape functions.  If
    // the identifier is not present, we must not process the request.
    //
    // NOTE: This function is NOT protected for shared memory access
    // because it is responsible for allocating / deallocating the shared
    // memory.
    //

    //
    // Check the data is long enough to store our standard escape header.
    // If it is not big enough this must be an escape request for another
    // driver.
    //
    if (cjIn < sizeof(OSI_ESCAPE_HEADER))
    {
        INIT_OUT(("DrvEscape ignoring; input size %04d too small", cjIn));
        WARNING_OUT(("DrvEscape ignoring; input size %04d too small", cjIn));
        DC_QUIT;
    }
    if (cjOut < sizeof(OSI_ESCAPE_HEADER))
    {
        INIT_OUT(("DrvEscape ignoring; output size %04d too small", cjOut));
        WARNING_OUT(("DrvEscape ignoring; output size %04d too small", cjOut));
        DC_QUIT;
    }

    //
    // Check for our escape ID.  If it is not our escape ID this must be an
    // escape request for another driver.
    //
    pHeader = pvIn;
    if (pHeader->identifier != OSI_ESCAPE_IDENTIFIER)
    {
        INIT_OUT(("DrvEscape ignoring; identifier 0x%08x is not for NetMtg", pHeader->identifier));
        WARNING_OUT(("DrvEscape ignoring; identifier 0x%08x is not for NetMtg", pHeader->identifier));
        DC_QUIT;
    }
    else if (pHeader->version != DCS_MAKE_VERSION())
    {
        INIT_OUT(("DrvEscape failing; version 0x%08x of NetMtg is not that of driver",
            pHeader->version));
        WARNING_OUT(("DrvEscape failing; version 0x%08x of NetMtg is not that of driver",
            pHeader->version));
        DC_QUIT;
    }

    //
    // If we haven't initialized yet, fail all other escapes.
    //
    if (g_shmMappedMemory == NULL)
    {
        if ((iEsc != OSI_ESC_CODE) || (pHeader->escapeFn != OSI_ESC_INIT))
        {
            WARNING_OUT(("DrvEscape failing; driver not initialized"));
            DC_QUIT;
        }
    }

    //
    // Everything is tickety boo - process the request.
    //
    switch (iEsc)
    {
        case OSI_ESC_CODE:
        {
            //
            // This is a request from the share core.  Pass it on to the
            // correct component.
            //
            TRACE_OUT(( "Function %ld", pHeader->escapeFn));

            if( // (pHeader->escapeFn >= OSI_ESC_FIRST) && Always True
                (pHeader->escapeFn <= OSI_ESC_LAST ) )
            {
                //
                // OSI requests.
                //
                rc = OSI_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_OE_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_OE_ESC_LAST ) )
            {
                //
                // Order Encoder requests.
                //
                rc = OE_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_HET_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_HET_ESC_LAST) )
            {
                //
                // Non-locking (wnd tracking) HET requests
                //
                rc = HET_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_SBC_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_SBC_ESC_LAST ) )
            {
                //
                // Send Bitmap Cache requests
                //
                rc = SBC_DDProcessRequest(pso, pHeader->escapeFn, pvIn, pvOut, cjOut);
            }
            else if( (pHeader->escapeFn >= OSI_SSI_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_SSI_ESC_LAST ) )
            {
                //
                // Save Screen Bits requests.
                //
                rc = SSI_DDProcessRequest(pHeader->escapeFn, pHeader, cjIn);
            }
            else if( (pHeader->escapeFn >= OSI_CM_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_CM_ESC_LAST ) )
            {
                //
                // Cursor Manager requests
                //
                rc = CM_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_OA_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_OA_ESC_LAST ) )
            {
                //
                // Order Accumulator requests.
                //
                rc = OA_DDProcessRequest(pHeader->escapeFn, pHeader, cjIn);
            }
            else if( (pHeader->escapeFn >= OSI_BA_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_BA_ESC_LAST ) )
            {
                //
                // Bounds Accumulator requests.
                //
                rc = BA_DDProcessRequest(pHeader->escapeFn, pHeader, cjIn,
                    pvOut, cjOut);
            }
            else
            {
                WARNING_OUT(( "Unknown function", pHeader->escapeFn));
            }
        }
        break;

        case WNDOBJ_SETUP:
        {
            if ((pHeader->escapeFn >= OSI_HET_WO_ESC_FIRST) &&
                (pHeader->escapeFn <= OSI_HET_WO_ESC_LAST))
            {
                TRACE_OUT(("WNDOBJ_SETUP Escape code - pass to HET"));
                rc = HET_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else
            {
                INIT_OUT(("WNDOBJ_SETUP Escape is unrecognized, ignore"));
                WARNING_OUT(("WNDOBJ_SETUP Escape is unrecognized, ignore"));
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unrecognised request %lu", iEsc));
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(DrvEscape, rc);
    return(rc);
}


//
// DrvSetPalette - see NT DDK documentation.
//
BOOL DrvSetPalette(DHPDEV  dhpdev,
                   PALOBJ* ppalo,
                   FLONG   fl,
                   ULONG   iStart,
                   ULONG   cColors)
{
    BOOL rc = FALSE;
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvSetPalette);

    //
    // Check that this doesn't hose our palette.  Note that NT passes a
    // zero indexed array element and a count, hence to fill a palette, the
    // values are 'start at 0 with 256 colours'.  Thus a total of 256 is
    // the maximum for our 8-bit palette.
    //
    if (iStart + cColors > OSI_MAX_PALETTE)
    {
        ERROR_OUT(("Overflow: start %lu count %lu", iStart, cColors));
        DC_QUIT;
    }

    //
    // Fill in the palette
    //
    if (cColors != PALOBJ_cGetColors(ppalo,
                                     iStart,
                                     cColors,
                                     (ULONG*)&ppdev->pPal[iStart]))
    {
        //
        // Don't bother tracing the return code - it's always 0.
        //
        ERROR_OUT(("Failed to read palette"));
        DC_QUIT;
    }

    //
    // BOGUS LAURABU!
    // For NT 5.0, do we need to turn around and reset the contents of
    // our created palette object with these new color values?  Real
    // display drivers don't (S3 e.g.)
    //

    //
    // Set the flag in the PDEV to indicate that the palette has changed
    //
    ppdev->paletteChanged = TRUE;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(DrvSetPalette, rc);
    return(rc);
}


//
// DrvGetModes - see NT DDK documentation
//
// Returns the list of available modes for the device.
// As a mirroring driver, we return 0.  That will cause NT GRE to use
// whatever ChangeDisplaySettingsEx passed along.
//
ULONG DrvGetModes
(
    HANDLE      hDriver,
    ULONG       cjSize,
    DEVMODEW*   pdm
)
{
    return(0);
}


//
// DrvAssertMode - see NT DDK documentation.
//
BOOL DrvAssertMode
(
    DHPDEV  dhpdev,
    BOOL    bEnable
)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvAssertMode);

    INIT_OUT(("DrvAssertMode(dhpdev = 0x%08x, bEnable = %d)", dhpdev, bEnable));

    //
    // Check for fullscreen switching.
    //
    if ((g_asSharedMemory != NULL) && (ppdev != NULL))
    {
        g_asSharedMemory->fullScreen = (BOOL)(!bEnable);
        TRACE_OUT(("Fullscreen is now  %d", g_asSharedMemory->fullScreen));
    }

    DebugExitVOID(DrvAssertMode);
    return(TRUE);
}



//
// Name:      OSIInitializeMode
//
// Purpose:
//
// Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
// devinfo based on the requested mode.
//
// Returns:
//
// TRUE  - Successfully initialized the data
// FALSE - Failed to set up mode data
//
// Params:
//
// pgdiRequested    - GDI info from the primary display driver (empty in NT 5.0)
// pdmRequested     - DEVMODE info with GDI's requested settings for our driver
// ppdev            - Our driver's private copy of settings, values
// pgdiReturn       - GDI info to return for our driver
// pdiReturn        - DEVINFO to return for our driver
//
BOOL  OSIInitializeMode
(
    const GDIINFO*      pgdiRequested,
    const DEVMODEW*     pdmRequested,
    LPOSI_PDEV          ppdev,
    GDIINFO*            pgdiReturn,
    DEVINFO*            pdiReturn
)
{
    BOOL                rc = FALSE;
    HPALETTE            hpal;
    ULONG               cColors;
    ULONG               iMode;

    DebugEntry(OSIInitializeMode);

    INIT_OUT(("DrvEnablePDEV: DEVMODEW requested contains:"));
    INIT_OUT(("     Screen width    -- %li", pdmRequested->dmPelsWidth));
    INIT_OUT(("     Screen height   -- %li", pdmRequested->dmPelsHeight));
    INIT_OUT(("     Bits per pel    -- %li", pdmRequested->dmBitsPerPel));
    INIT_OUT(("DrvEnablePDEV: DEVINFO parameter contains:"));
    INIT_OUT(("     flGraphicsCaps  -- 0x%08x", pdiReturn->flGraphicsCaps));
    INIT_OUT(("     iDitherFormat   -- 0x%08x", pdiReturn->iDitherFormat));
    INIT_OUT(("     hpalDefault     -- 0x%08x", pdiReturn->hpalDefault));
    INIT_OUT(("DrvEnablePDEV: GDIINFO (devcaps) parameter contains:"));
    INIT_OUT(("    ULONG       ulVersion       0x%08x",    pgdiRequested->ulVersion));
    INIT_OUT(("    ULONG       ulHorzSize      %d",    pgdiRequested->ulHorzSize));
    INIT_OUT(("    ULONG       ulVertSize      %d",    pgdiRequested->ulVertSize));
    INIT_OUT(("    ULONG       ulHorzRes       %d",    pgdiRequested->ulHorzRes));
    INIT_OUT(("    ULONG       ulVertRes       %d",    pgdiRequested->ulVertRes));
    INIT_OUT(("    ULONG       cBitsPixel      %d",    pgdiRequested->cBitsPixel));
    INIT_OUT(("    ULONG       cPlanes         %d",    pgdiRequested->cPlanes));
    INIT_OUT(("    ULONG       ulNumColors     %d",    pgdiRequested->ulNumColors));
    INIT_OUT(("    ULONG       ulDACRed        0x%08x",    pgdiRequested->ulDACRed));
    INIT_OUT(("    ULONG       ulDACGreen      0x%08x",    pgdiRequested->ulDACGreen));
    INIT_OUT(("    ULONG       ulDACBlue       0x%08x",    pgdiRequested->ulDACBlue));
    INIT_OUT(("    ULONG       ulHTOutputFormat %d",   pgdiRequested->ulHTOutputFormat));


    //
    // Fill in the GDIINFO we're returning with the info for our driver.
    // First, copy the default settings.
    //
    *pgdiReturn = s_osiDefaultGdi;

    //
    // Second, update the values that vary depending on the requested
    // mode and color depth.
    //

    pgdiReturn->ulHorzRes         = pdmRequested->dmPelsWidth;
    pgdiReturn->ulVertRes         = pdmRequested->dmPelsHeight;
    pgdiReturn->ulVRefresh        = pdmRequested->dmDisplayFrequency;
    pgdiReturn->ulLogPixelsX      = pdmRequested->dmLogPixels;
    pgdiReturn->ulLogPixelsY      = pdmRequested->dmLogPixels;

    //
    // If this is NT 4.0 SP-3, we get passed in the original GDIINFO of
    // the real display.  If not, we need to fake up one.
    //
    if (pgdiRequested->cPlanes != 0)
    {
        //
        // Now overwrite the defaults with the relevant information returned
        // from the kernel driver:
        //
        pgdiReturn->cBitsPixel        = pgdiRequested->cBitsPixel;
        pgdiReturn->cPlanes           = pgdiRequested->cPlanes;

        pgdiReturn->ulDACRed          = pgdiRequested->ulDACRed;
        pgdiReturn->ulDACGreen        = pgdiRequested->ulDACGreen;
        pgdiReturn->ulDACBlue         = pgdiRequested->ulDACBlue;
    }
    else
    {
        pgdiReturn->cBitsPixel        = pdmRequested->dmBitsPerPel;
        pgdiReturn->cPlanes           = 1;

        switch (pgdiReturn->cBitsPixel)
        {
            case 8:
                pgdiReturn->ulDACRed = pgdiReturn->ulDACGreen = pgdiReturn->ulDACBlue = 8;
                break;

            case 24:
                pgdiReturn->ulDACRed    = 0x00FF0000;
                pgdiReturn->ulDACGreen  = 0x0000FF00;
                pgdiReturn->ulDACBlue   = 0x000000FF;
                break;

            default:
                ERROR_OUT(("Invalid color depth in NT 5.0 mirror driver"));
                DC_QUIT;
                break;
        }
    }

    //
    // Now save private copies of info we're returning to GDI
    //
    ppdev->cxScreen         = pgdiReturn->ulHorzRes;
    ppdev->cyScreen         = pgdiReturn->ulVertRes;
    ppdev->cBitsPerPel      = pgdiReturn->cBitsPixel * pgdiReturn->cPlanes;
    if (ppdev->cBitsPerPel == 15)
        ppdev->cBitsPerPel = 16;
    ppdev->flRed            = pgdiReturn->ulDACRed;
    ppdev->flGreen          = pgdiReturn->ulDACGreen;
    ppdev->flBlue           = pgdiReturn->ulDACBlue;

    //
    // Fill in the devinfo structure with the default 8bpp values, taking
    // care not to trash the supplied hpalDefault (which allows us to
    // query information about the real display driver's color format).
    //
    // On NT 5.0, we don't get passed on the screen palette at all, we need
    // to create our own.
    //
    hpal = pdiReturn->hpalDefault;
    *pdiReturn = s_osiDefaultDevInfo;

    switch (pgdiReturn->cBitsPixel * pgdiReturn->cPlanes)
    {
        case 4:
        {
            //
            // NT 4.0 SP-3 ONLY
            //

            pgdiReturn->ulNumColors     = 16;
            pgdiReturn->ulNumPalReg     = 0;
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_4BPP;

            pdiReturn->flGraphicsCaps   &= ~GCAPS_PALMANAGED;
            pdiReturn->iDitherFormat    = BMF_4BPP;

            ppdev->iBitmapFormat        = BMF_4BPP;

            cColors = 16;
            goto AllocPalEntries;
        }
        break;

        case 8:
        {
            pgdiReturn->ulNumColors     = 20;
            pgdiReturn->ulNumPalReg     = 256;

            pdiReturn->iDitherFormat    = BMF_8BPP;

            ppdev->iBitmapFormat        = BMF_8BPP;

            cColors = 256;
AllocPalEntries:
            //
            // Alloc memory for the palette entries.
            //
            ppdev->pPal = EngAllocMem( FL_ZERO_MEMORY,
                            sizeof(PALETTEENTRY) * cColors,
                            OSI_ALLOC_TAG );
            if (ppdev->pPal == NULL)
            {
                ERROR_OUT(("Failed to allocate palette memory"));
                DC_QUIT;
            }
        }
        break;

        case 15:
        case 16:
        {
            //
            // NT 4.0 SP-3 ONLY
            //
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_16BPP;

            pdiReturn->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pdiReturn->iDitherFormat    = BMF_16BPP;

            ppdev->iBitmapFormat        = BMF_16BPP;
        }
        break;

        case 24:
        {
            //
            // DIB conversions will only work if we have a standard RGB
            // surface for 24bpp.
            //
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_24BPP;

            pdiReturn->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pdiReturn->iDitherFormat    = BMF_24BPP;

            ppdev->iBitmapFormat        = BMF_24BPP;
        }
        break;

        case 32:
        {
            //
            // NT 4.0 SP-3 ONLY
            //
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_32BPP;

            pdiReturn->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pdiReturn->iDitherFormat    = BMF_32BPP;

            ppdev->iBitmapFormat        = BMF_32BPP;
        }
        break;

        default:
        {
            //
            // Unsupported bpp - pretend we are 8 bpp.
            //
            ERROR_OUT(("Unsupported bpp value: %d",
                pgdiReturn->cBitsPixel * pgdiReturn->cPlanes));
            DC_QUIT;
        }
        break;
    }


    if (!hpal)
    {
        //
        // This is NT 5.0.  We need to create a palette, either an 8bpp
        // indexed one, or a 24bpp bitfield one.
        //
        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            ULONG   ulLoop;

            //
            // We have to initialize the fixed part (top 10 and bottom 10)
            // of the palette entries.
            //
            for (ulLoop = 0; ulLoop < 10; ulLoop++)
            {
                // First 10
                ppdev->pPal[ulLoop]     = s_aWinColors[ulLoop];

                // Last 10
                ppdev->pPal[256 - 10 + ulLoop] = s_aWinColors[ulLoop + 10];
            }

            // Create the palette from the entries.
            hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*)ppdev->pPal,
                0, 0, 0);

            //
            // Set the flag in the PDEV to indicate that the palette has
            // changed.
            //
            ppdev->paletteChanged = TRUE;
        }
        else
        {
            ASSERT(ppdev->iBitmapFormat == BMF_24BPP);

            hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
        }

        ppdev->hpalCreated = hpal;
        if (!hpal)
        {
            ERROR_OUT(("DrvEnablePDEV: could not create DEVINFO palette"));
            DC_QUIT;
        }
    }
    else
    {
        //
        // This is NT 4.0 SP-3.  Get the real bitmasks for > 8 bpp and
        // the current palette colors for <= 8 bpp.
        //
        if (pgdiReturn->cBitsPixel <= 8)
        {
            if (ppdev->iBitmapFormat == BMF_4BPP)
            {
                ASSERT(cColors == 16);
            }
            else
            {
                ASSERT(cColors == 256);
            }

            if (cColors != EngQueryPalette(hpal, &iMode, cColors,
                    (ULONG *)ppdev->pPal))
            {
                ERROR_OUT(("Failed to query current display palette"));
            }

            //
            // Set the flag in the PDEV to indicate that the palette has
            // changed.
            //
            ppdev->paletteChanged = TRUE;
        }
        else
        {
            ULONG       aulBitmasks[3];

            //
            // Query the true color bitmasks.
            //
            cColors = EngQueryPalette(hpal,
                               &iMode,
                               sizeof(aulBitmasks) / sizeof(aulBitmasks[0]),
                               &aulBitmasks[0] );

            if (cColors == 0)
            {
                ERROR_OUT(("Failed to query real bitmasks"));
            }

            if (iMode == PAL_INDEXED)
            {
                ERROR_OUT(("Bitmask palette is indexed"));
            }

            //
            // Get the real bitmasks for NT 4.0 SP-3 displays since we
            // get the same info the real global display does, and we need
            // to parse the bits in BitBlts, color tanslations, etc.
            //
            ppdev->flRed   = aulBitmasks[0];
            ppdev->flGreen = aulBitmasks[1];
            ppdev->flBlue  = aulBitmasks[2];
        }
    }

    pdiReturn->hpalDefault = hpal;

    rc = TRUE;

    INIT_OUT(("DrvEnablePDEV: Returning bitmasks of:"));
    INIT_OUT(("     red     %08x", ppdev->flRed));
    INIT_OUT(("     green   %08x", ppdev->flGreen));
    INIT_OUT(("     blue    %08x", ppdev->flBlue));

DC_EXIT_POINT:
    DebugExitBOOL(OSIInitializeMode, rc);
    return(rc);
}








//
// FUNCTION:      OSI_DDProcessRequest
//
// DESCRIPTION:
//
// Called by the display driver to process an OSI specific request
//
// PARAMETERS:    pso   - pointer to surface object
//                cjIn  - (IN)  size of request block
//                pvIn  - (IN)  pointer to request block
//                cjOut - (IN)  size of response block
//                pvOut - (OUT) pointer to response block
//
// RETURNS:       None
//
//
ULONG OSI_DDProcessRequest(SURFOBJ* pso,
                                     UINT cjIn,
                                     void *  pvIn,
                                     UINT cjOut,
                                     void *  pvOut)
{
    ULONG               rc;
    LPOSI_ESCAPE_HEADER pHeader;
    LPOSI_PDEV          ppdev = (LPOSI_PDEV)pso->dhpdev;

    DebugEntry(OSI_DDProcessRequest);

    //
    // Get the request number.
    //
    pHeader = pvIn;
    switch (pHeader->escapeFn)
    {
        case OSI_ESC_INIT:
        {
            TRACE_OUT(("DrvEscape:  OSI_ESC_INIT"));
            ASSERT(cjOut == sizeof(OSI_INIT_REQUEST));

            //
            // Get shared memory block
            //
            OSI_DDInit(ppdev, (LPOSI_INIT_REQUEST)pvOut);
            rc = TRUE;
        }
        break;

        case OSI_ESC_TERM:
        {
            TRACE_OUT(("DrvEscape:  OSI_ESC_TERM"));
            ASSERT(cjIn == sizeof(OSI_TERM_REQUEST));

            //
            // Cleanup, NM is going away
            //
            OSI_DDTerm(ppdev);
            rc = TRUE;
        }
        break;

        case OSI_ESC_SYNC_NOW:
        {
            TRACE_OUT(("DrvEscape:  OSI_ESC_SYNC_NOW"));
            ASSERT(cjIn == sizeof(OSI_ESCAPE_HEADER));

            //
            // Resync with the 32-bit ring 3 core.  This happens when
            // somebody joins or leaves a share.
            //
            BA_ResetBounds();
            OA_DDSyncUpdatesNow();
            SBC_DDSyncUpdatesNow(ppdev);
            rc = TRUE;
        }
        break;


        default:
        {
            ERROR_OUT(("Unrecognised request %lu", pHeader->escapeFn));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OSI_DDProcessRequest, rc);
    return(rc);
}




//
// Function:    OSI_DDInit
//
// Description: Map the shared memory into Kernel and User space
//
// Parameters:  count - size of the buffer to return to user space
//              pData - pointer to the buffer to be returned to user space
//
// Returns:     (none)
//
void OSI_DDInit(LPOSI_PDEV ppdev, LPOSI_INIT_REQUEST pResult)
{
    DWORD               memRemaining;
    LPBYTE              pBuffer;
    LPVOID              shmMappedMemory;

    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    DebugEntry(OSI_DDInit);

    // Init to FALSE
    pResult->result = FALSE;

    // Initialize these to NULL
    pResult->pSharedMemory  = NULL;
    pResult->poaData[0]     = NULL;
    pResult->poaData[1]     = NULL;
    pResult->sbcEnabled   = FALSE;

    //
    // Check that the memory is available to the driver and that we are not
    // in a race condition.
    //
    if (g_asSharedMemory == NULL)
    {
        ERROR_OUT(("No memory available"));
        DC_QUIT;
    }

    if (g_shmMappedMemory != NULL)
    {
        //
        // We will never come in here with two copies of NetMeeting running.
        // The UI code prevents the second instance from starting long
        // before app sharing is in the picture.  Therefore, these are the
        // only possibilities:
        //
        //  (1) Previous version is almost shutdown but hasn't called OSI_DDTerm
        // yet and new version is starting up and calls OSI_DDInit
        //
        //  (2) Previous version terminated abnormally and never called
        // OSI_DDTerm().  This code handles the second case.  The first one
        // is handled by the same code in the UI that prevents two copies
        // from starting around the same time.
        //
        WARNING_OUT(("OSI_DDInit:  NetMeeting did not shutdown cleanly last time"));
        OSI_DDTerm(ppdev);
    }

    //
    // Map the shared section into the caller's process.
    //
    INIT_OUT(("OSI_DDInit: Mapping 0x%08x bytes of kernel memory at 0x%08x into caller process",
        g_shmSharedMemorySize, g_asSharedMemory));
    ShareMemory.ProcessHandle           = LongToHandle(-1);
    ShareMemory.ViewOffset              = 0;
    ShareMemory.ViewSize                = g_shmSharedMemorySize;
    ShareMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
            &ShareMemory,
            sizeof(VIDEO_SHARE_MEMORY),
            &ShareMemoryInformation,
            sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
            &ReturnedDataLength) != 0)
    {
        ERROR_OUT(("Failed to map shared memory into calling process"));
        DC_QUIT;
    }

    //
    // USER MODE pointer (not valid in kernel mode)
    //
    INIT_OUT(("OSI_DDInit: Mapped 0x%08x bytes of kernel memory to user memory 0x%08x",
        g_shmSharedMemorySize, ShareMemoryInformation.VirtualAddress));

    shmMappedMemory        = ShareMemoryInformation.VirtualAddress;
    pResult->pSharedMemory = shmMappedMemory;
    pResult->poaData[0]    = ((LPSHM_SHARED_MEMORY)pResult->pSharedMemory) + 1;
    pResult->poaData[1]    = ((LPOA_SHARED_DATA)pResult->poaData[0]) + 1;

    TRACE_OUT(("Shared memory %08lx %08lx %08lx",
            pResult->pSharedMemory, pResult->poaData[0], pResult->poaData[1]));

    //
    // Clear out the shared memory, so it's ready for immediate use.
    // NOTE THAT THIS SETS ALL VALUES TO FALSE.
    // NOTE ALSO THAT THIS CLEARS the two OA_SHARED_DATAs also
    //
    RtlFillMemory(g_asSharedMemory, SHM_SIZE_USED, 0);
    g_asSharedMemory->displayToCore.indexCount    = 0;

    //
    // Set up our pointer to the variable part of the shared memory i.e.
    // the part which is not used for the SHM_SHARED_MEMORY structure
    // We must skip past g_asSharedMemory, two CM_FAST_DATA structs, and
    // two OA_SHARED_DATA structs.
    //
    pBuffer      = (LPBYTE)g_asSharedMemory;
    pBuffer     += SHM_SIZE_USED;
    memRemaining = g_shmSharedMemorySize - SHM_SIZE_USED;

    //
    // Initialise the other components required for DC-Share
    //

    //
    // Bounds accumulation
    //
    BA_DDInit();

    //
    // Cursor
    //
    if (!CM_DDInit(ppdev))
    {
        ERROR_OUT(("CM failed to init"));
        DC_QUIT;
    }

    //
    // Send Bitmap Cache
    // NOTE that if it initializes OK but no caching allowed, we will continue.
    //
    // This will fill in the tile buffers & info.  If no SBC caching allowed,
    // the sbcEnabled field will be FALSE.
    //
    if (SBC_DDInit(ppdev, pBuffer, memRemaining, pResult))
    {
        pResult->sbcEnabled = TRUE;
    }

    //
    // Mark memory as ready to use.
    //
    g_shmMappedMemory = shmMappedMemory;
    pResult->result = TRUE;

DC_EXIT_POINT:
    DebugExitVOID(OSI_DDInit);
}


//
// Function:    OSI_DDTerm
//
// Description: Cleanup when NM shuts down
//
// Returns:     (none)
//
void OSI_DDTerm(LPOSI_PDEV ppdev)
{
    DebugEntry(OSI_DDTerm);

    //
    // Check for a valid address - must be non-NULL.
    //
    if (!g_asSharedMemory)
    {
        ERROR_OUT(("Invalid memory"));
        DC_QUIT;
    }


    //
    // Terminate the dependent components.
    //

    //
    // Hosted Entity Tracker
    //
    HET_DDTerm();

    //
    // Order Encoding
    //
    OE_DDTerm();

    //
    // Send Bitmap Cache
    //
    SBC_DDTerm();

    //
    // Cursor manager.
    //
    CM_DDTerm();

    //
    // The shared memory will be unmapped automatically in this process
    // by OS cleanup, in both NT4 and NT5
    //
    g_shmMappedMemory = NULL;

DC_EXIT_POINT:
    DebugExitVOID(OSI_DDTerm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\al.h ===
//
// Application Loader
//

#ifndef _H_AL
#define _H_AL

//
//
// Includes
//
//
#include <om.h>


//
// THERE IS ONLY ONE CLIENT OF THE APP-LOADER:  OLD WHITEBOARD
//

#define AL_RETRY_DELAY                      100

#define AL_NEW_CALL_RETRY_COUNT             5



//
// Result codes passed in ALS_LOAD_RESULT events
//
typedef enum
{
    AL_LOAD_SUCCESS = 0,
    AL_LOAD_FAIL_NO_FP,
    AL_LOAD_FAIL_NO_EXE,
    AL_LOAD_FAIL_BAD_EXE,
    AL_LOAD_FAIL_LOW_MEM
}
AL_LOAD_RESULT;




//
//
// Application Loader OBMAN object used to communicate result of attempted
// loads
//
// szFunctionProfile : Function Profile being loaded
// personName      : Name of site that attempted the load
// result          : Result of attempted load
//
// NET PROTOCOL.  All network raw data structures, which CAN NOT CHANGE,
// are prefixed with TSHR_.
//
typedef struct tagTSHR_AL_LOAD_RESULT
{
    char        szFunctionProfile[OM_MAX_FP_NAME_LEN];
    char        personName[TSHR_MAX_PERSON_NAME_LEN];
    TSHR_UINT16 result;
    TSHR_UINT16 pad;
}
TSHR_AL_LOAD_RESULT;
typedef TSHR_AL_LOAD_RESULT * PTSHR_AL_LOAD_RESULT;





typedef struct tagAL_PRIMARY
{
    STRUCTURE_STAMP
    PUT_CLIENT          putTask;
    POM_CLIENT          pomClient;
    PCM_CLIENT          pcmClient;

    BOOL                eventProcRegistered:1;
    BOOL                exitProcRegistered:1;
    BOOL                inCall:1;
    BOOL                alWorksetOpen:1;
    BOOL                alWBRegPend:1;
    BOOL                alWBRegSuccess:1;

    // Call Info
    UINT                callID;

    OM_CORRELATOR       omWSGCorrelator;
    OM_CORRELATOR       omWSCorrelator;
    NET_UID             omUID;
    OM_WSGROUP_HANDLE   omWSGroupHandle;
    OM_WSGROUP_HANDLE   alWSGroupHandle;

    // Whiteboard Client
    PUT_CLIENT          putWB;
}
AL_PRIMARY;
typedef struct tagAL_PRIMARY * PAL_PRIMARY;


__inline void ValidateALP(PAL_PRIMARY palPrimary)
{
    ASSERT(!IsBadWritePtr(palPrimary, sizeof(AL_PRIMARY)));
}



//
//
// Application Loader Events
//
// Note: these events are defined relative to AL_BASE_EVENT and use the
//       range AL_BASE_EVENT to AL_BASE_EVENT + 0x7F.  The application
//       loader internally uses events in the range AL_BASE_EVENT+0x80 to
//       AL_BASE_EVENT+0xFF, so events in this range must not be defined
//       as part of the API.
//
//


enum
{
    ALS_LOCAL_LOAD = AL_BASE_EVENT,
    ALS_REMOTE_LOAD_RESULT,
    AL_INT_RETRY_NEW_CALL,
    AL_INT_STARTSTOP_WB
};



//
// ALS_LOAD_RESULT
//
// Overview:
//
//   This event informs a task of the result of an attempted load on a
//   remote machine.
//
// Parameters:
//
//   param_1 :      AL_LOAD_RESULT  reasonCode;
//   param_2 :      UINT            alPersonHandle;
//
//   reasonCode           : Result of attempt to load application
//
//   alPersonHandle       : Handle for the site that attempted the load
//                          (pass to ALS_GetPersonData() to get site name)
//
// Issued to:
//
//   Applications that have registered a function profile that has been
//   used by the Application Loader on a remote site.
//
// Circumstances when issued:
//
//   When the Application Loader on a remote site attempts to load an
//   application due to a new Function Profile object being added to a
//   call.
//
// Receivers response:
//
//   None
//
//



//
// AL_RETRY_NEW_CALL
//
// If AL fails to register with ObManControl on receipt of a CMS_NEW_CALL,
// it will in certain circumstances retry the registration after a short
// delay.  This is implemented by posting an AL_RETRY_NEW_CALL event back
// to itself.
//


//
// AL_INT_STARTSTOP_WB
//
// This starts/stops the old Whiteboard, which is now an MFC dll in CONF's
// process that creates/terminates a thread.  By having CONF itself start
// old WB through us, autolaunch and normal launch are synchronized.
//
// TEMP HACK:
// param1 == TRUE or FALSE (TRUE for new WB TEMP HACK!, FALSE for normal old WB)
// param2 == memory block (receiver must free) of file name to open
//



//
// PRIMARY functions
//


//
// ALP_Init()
// ALP_Term()
//
BOOL ALP_Init(BOOL * pfCleanup);
void ALP_Term(void);


BOOL CALLBACK ALPEventProc(LPVOID palPrimary, UINT event, UINT_PTR param1, UINT_PTR param2);
void CALLBACK ALPExitProc(LPVOID palPrimary);


void ALEndCall(PAL_PRIMARY palPrimary, UINT callID);

void ALNewCall(PAL_PRIMARY palPrimary, UINT retryCount, UINT callID);

BOOL ALWorksetNewInd(PAL_PRIMARY palPrimary, OM_WSGROUP_HANDLE hWSGroup, OM_WORKSET_ID worksetID);

BOOL ALNewWorksetGroup(PAL_PRIMARY palPrimary, OM_WSGROUP_HANDLE hWSGroup, POM_OBJECT pObj);

void ALWorksetRegisterCon(PAL_PRIMARY palPrimary, UINT correlator,
            UINT result, OM_WSGROUP_HANDLE hWSGroup);

BOOL ALRemoteLoadResult(PAL_PRIMARY palPrimary, OM_WSGROUP_HANDLE hWSGroup,
                                        POM_OBJECT  alObjHandle);

void ALLocalLoadResult(PAL_PRIMARY palPrimary, BOOL success);


//
// SECONDARY functions
//

void CALLBACK ALSExitProc(LPVOID palClient);

//
// Launching/activation of WB
// TEMP HACK FOR NEW WB!
//

BOOL ALStartStopWB(PAL_PRIMARY palPrimary, LPCTSTR szFile);
DWORD WINAPI OldWBThreadProc(LPVOID lpv);

//
// Start, Run, Cleanup routines
//
typedef BOOL (WINAPI * PFNINITWB)(void);
typedef void (WINAPI * PFNRUNWB)(void);
typedef void (WINAPI * PFNTERMWB)(void);


#endif // _H_AL

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\ssi.c ===
#include "precomp.h"


//
// SSI.C
// Save Screenbits Interceptor, display driver side
//
// Copyright(c) Microsoft 1997-
//


//
// SSI_DDProcessRequest - see ssi.h
//
BOOL SSI_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc;

    DebugEntry(SSI_DDProcessRequest);

    switch (fnEscape)
    {
        case SSI_ESC_RESET_LEVEL:
        {
            if (cbRequest != sizeof(SSI_RESET_LEVEL))
            {
                ERROR_OUT(("SSI_DDProcessRequest:  Invalid size %d for SSI_ESC_RESET_LEVEL",
                    cbRequest));
                rc = FALSE;
                DC_QUIT;
            }

            SSIResetSaveScreenBitmap();
            rc = TRUE;
        }
        break;

        case SSI_ESC_NEW_CAPABILITIES:
        {
            if (cbRequest != sizeof(SSI_NEW_CAPABILITIES))
            {
                ERROR_OUT(("SSI_DDProcessRequest:  Invalid size %d for SSI_ESC_NEW_CAPABILITIES",
                    cbRequest));
                rc = FALSE;
                DC_QUIT;
            }

            SSISetNewCapabilities((LPSSI_NEW_CAPABILITIES)pRequest);
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SSI_ escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(SSI_DDProcessRequest, rc);
    return(rc);
}



//
// SSI_SaveScreenBitmap()
//
// see ssi.h for description.
//
BOOL SSI_SaveScreenBitmap(LPRECT lpRect, UINT wCommand)
{
    BOOL rc;

    DebugEntry(SSI_SaveScreenBitmap);

    //
    // Decide whether we can transmit this particular SaveBitmap command as
    // an order.
    //
    switch (wCommand)
    {
        case ONBOARD_SAVE:
        {
            //
            // Save the bits.
            //
            rc = SSISaveBits(lpRect);
        }
        break;

        case ONBOARD_RESTORE:
        {
            //
            // Restore the bits.
            //
            rc = SSIRestoreBits(lpRect);
        }
        break;

        case ONBOARD_DISCARD:
        {
            //
            // Discard the saved bits.
            //
            rc = SSIDiscardBits(lpRect);
        }
        break;

        default:
        {
            ERROR_OUT(( "Unexpected wCommand(%d)", wCommand));
            rc = FALSE;
        }
    }

    if (g_ssiLocalSSBState.saveLevel == 0)
    {
        ASSERT(g_ssiRemoteSSBState.pelsSaved == 0);
    }

    DebugExitBOOL(SSI_SaveScreenBitmap, rc);
    return(rc);
}



//
// FUNCTION: SSIResetSaveScreenBitmap.
//
// DESCRIPTION:
//
// Resets the SaveScreenBitmap state.
//
// PARAMETERS: None.
//
// RETURNS: Nothing.
//
//
void SSIResetSaveScreenBitmap(void)
{
    DebugEntry(SSIResetSaveScreenBitmap);

    //
    // Discard all currently saved bits.
    //
    g_ssiLocalSSBState.saveLevel = 0;

    //
    // Reset the number of remote pels saved.
    //
    g_ssiRemoteSSBState.pelsSaved = 0;


    DebugExitVOID(SSIResetSaveScreenBitmap);
}



//
// FUNCTION: SSISendSaveBitmapOrder
//
// DESCRIPTION:
//
// Attempts to send a SaveBitmap order matching the supplied parameters.
//
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords)
//
// RETURNS:
//
// TRUE if order successfully sent FALSE if order not sent
//
//
BOOL SSISendSaveBitmapOrder
(
    LPRECT      lpRect,
    UINT        wCommand
)
{
    DWORD               cRemotePelsRequired;
    LPSAVEBITMAP_ORDER  pSaveBitmapOrder;
    LPINT_ORDER         pOrder;
    BOOL                rc = FALSE;

    DebugEntry(SSISendSaveBitmapOrder);

    //
    // If the SaveBitmap order is not supported then return FALSE
    // immediately.
    //
    if (!OE_SendAsOrder(ORD_SAVEBITMAP))
    {
        WARNING_OUT(("SSISendSaveBitmapOrder failing; save bits orders not supported"));
        DC_QUIT;
    }

    switch (wCommand)
    {
        case ONBOARD_DISCARD:
            //
            // We don't transmit DISCARD orders, there's no need since
            // saves/restores are paired.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                CURRENT_LOCAL_SSB_STATE.remotePelsRequired;
            rc = TRUE;
            DC_QUIT;

        case ONBOARD_SAVE:
            //
            // Calculate the number of pels required in the remote Save
            // Bitmap to handle this rectangle.
            //
            cRemotePelsRequired = SSIRemotePelsRequired(lpRect);

            //
            // If there aren't enough pels in the remote Save Bitmap to
            // handle this rectangle then return immediately.
            //
            if ((g_ssiRemoteSSBState.pelsSaved + cRemotePelsRequired) >
                                                            g_ssiSaveBitmapSize)
            {
                TRACE_OUT(("SSISendSaveBitmapOrder:  ONBOARD_SAVE is failing; not enough space for %08d pels",
                    cRemotePelsRequired));
                DC_QUIT;
            }

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_SAVEBITS;

            //
            // SAVEBITS is a BLOCKER order i.e. it prevents any earlier
            // orders from being spoilt by subsequent orders or Screen
            // Data.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_BLOCKER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition =  g_ssiRemoteSSBState.pelsSaved;

            //
            // Store the relevant details in the current entry of the
            // local SSB structure.
            //
            CURRENT_LOCAL_SSB_STATE.remoteSavedPosition =
                                        pSaveBitmapOrder->SavedBitmapPosition;

            CURRENT_LOCAL_SSB_STATE.remotePelsRequired = cRemotePelsRequired;

            //
            // Update the count of remote pels saved.
            //
            g_ssiRemoteSSBState.pelsSaved += cRemotePelsRequired;

            //
            // The operation rectangle is NULL.
            //
            pOrder->OrderHeader.Common.rcsDst.left   = 1;
            pOrder->OrderHeader.Common.rcsDst.right  = 0;
            pOrder->OrderHeader.Common.rcsDst.top    = 1;
            pOrder->OrderHeader.Common.rcsDst.bottom = 0;


            break;

        case ONBOARD_RESTORE:
            //
            // Update the remote pel count first. Even if we fail to send
            // the order we want to free up the remote pels.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                                   CURRENT_LOCAL_SSB_STATE.remotePelsRequired;

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_RESTOREBITS;

            //
            // The order can spoil others (it is opaque).
            // It is not SPOILABLE because we want to keep the remote
            // save level in a consistent state.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition =
                                  CURRENT_LOCAL_SSB_STATE.remoteSavedPosition;


            //
            // The operation rectangle is also the bounding rectangle of
            // the order.
            //
            pOrder->OrderHeader.Common.rcsDst.left =
                                       (TSHR_INT16)pSaveBitmapOrder->nLeftRect;
            pOrder->OrderHeader.Common.rcsDst.right =
                                       (TSHR_INT16)pSaveBitmapOrder->nRightRect;
            pOrder->OrderHeader.Common.rcsDst.top =
                                       (TSHR_INT16)pSaveBitmapOrder->nTopRect;
            pOrder->OrderHeader.Common.rcsDst.bottom =
                                       (TSHR_INT16)pSaveBitmapOrder->nBottomRect;
            break;


        default:
            ERROR_OUT(( "Unexpected wCommand(%d)", wCommand));
            DC_QUIT;
    }

    TRACE_OUT(( "SaveBitmap op %d pos %ld rect %d %d %d %d",
        pSaveBitmapOrder->Operation, pSaveBitmapOrder->SavedBitmapPosition,
        pSaveBitmapOrder->nLeftRect, pSaveBitmapOrder->nTopRect,
        pSaveBitmapOrder->nRightRect, pSaveBitmapOrder->nBottomRect ));

    //
    // Add the order to the order list.
    // We deliberately do not call OA_DDClipAndAddOrder() because the
    // SaveBitmap order is never clipped.
    //
    OA_DDAddOrder(pOrder, NULL);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SSISendSaveBitmapOrder, rc);
    return(rc);
}



//
// SSISaveBits()
//
// This attemps to save the SPB into our stack.  If we can't save it, no
// big deal--we'll fail the restore and that info will go as screen data.
//
// NOTE THAT THIS ROUTINE IS IN OPPOSITE FROM WIN95.  In Win95, we always
// return FALSE from save so that USER always uses bitmaps for save bits and
// we can track them.  In NT we always return TRUE from save because we
// can't track USER bitmaps.
//
// ALWAYS RETURN TRUE FROM THIS FUNCTION
//
// If FALSE is returned on a Display Driver SaveBits operation then Windows
// (USER) simulates the SaveBits call using BitBlts and DOES NOT make a
// corresponding RestoreBits call.  This makes it impossible for us to
// correctly track the drawing operations (the restore operation is a
// bitblt on a task that may not have been tracked) - and we can end up
// with unrestored areas on the remote.
//
// Therefore this routine should always return TRUE (apart from when
// something very very unexpected happens).  In the cases where we haven't
// saved the data we simply note the fact by storing ST_FAILED_TO_SAVE in
// our local SSB state structure.  Because we return TRUE, we get a
// RestoreBits call and, seeing that the Save failed (by looking in the
// local SSB state structure), we _then_ return FALSE to indicate that the
// Restore failed which causes Windows to invalidate and repaint the
// affected area.
//
//
BOOL SSISaveBits(LPRECT lpRect)
{
    DebugEntry(SSISaveBits);

    //
    // We should never have unbalanced save/restore operations
    //
    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Are we out of space?
    //
    if (g_ssiLocalSSBState.saveLevel >= SSB_MAX_SAVE_LEVEL)
    {
        TRACE_OUT(( "saveLevel(%d) exceeds maximum", g_ssiLocalSSBState.saveLevel));
        DC_QUIT;
    }

    //
    // If the rectangle to be saved intersects the current SDA then we will
    // have to force a repaint on the restore.  This is because orders are
    // always sent before Screen Data, so if we sent a SAVEBITS order at
    // this point, we would not save the intersecting Screen Data.
    //
    // Otherwise mark the bits as saved (we don't have to do anything since
    // we are a chained display driver).
    //
    if (OE_RectIntersectsSDA(lpRect))
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_FAILED_TO_SAVE;
    }
    else
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_SAVED_BY_DISPLAY_DRIVER;
    }

    //
    // Store the rectangle saved
    //
    CURRENT_LOCAL_SSB_STATE.hbmpSave = NULL;
    CURRENT_LOCAL_SSB_STATE.rect     = *lpRect;

    //
    // If the bits were successfully saved then we can try to send the
    // SaveBits command as an order.
    //
    if (CURRENT_LOCAL_SSB_STATE.saveType != ST_FAILED_TO_SAVE)
    {
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely =
            SSISendSaveBitmapOrder(lpRect, ONBOARD_SAVE);
    }
    else
    {
        //
        // We didn't manage to save it.  No point in trying to save the
        // bitmap remotely.
        //
        TRACE_OUT(( "Keep track of failed save for restore later"));
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely = FALSE;
    }

    //
    // Update the save level
    // NOTE this now points to the NEXT free slot
    //
    g_ssiLocalSSBState.saveLevel++;
    
    TRACE_OUT(("SSISaveBits:"));
    TRACE_OUT(("      saveLevel   is      %d", g_ssiLocalSSBState.saveLevel));
    TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));

DC_EXIT_POINT:
    DebugExitBOOL(SSISaveBits, TRUE);
    return(TRUE);
}



//
// FUNCTION: SSIFindSlotAndDiscardAbove
//
// DESCRIPTION:
//
// Finds the top slot in the SSB stack which matches lpRect and updates
// g_ssiLocalSSBState.saveLevel to index it.
//
// PARAMETERS:
//
// lpRect - the SSB rectangle
//
// RETURNS: TRUE if a match was found, FALSE otherwise
//
//
BOOL SSIFindSlotAndDiscardAbove(LPRECT lpRect)
{
    int   i;
    int   iNewSaveLevel;
    BOOL  rc = FALSE;

    DebugEntry(SSIFindSlotAndDiscardAbove);

    //
    // Look for this SPB.  If we find it, then discard the entries after
    // it in our stack.
    //
    iNewSaveLevel = g_ssiLocalSSBState.saveLevel;

    //
    // Find the bits we are trying to restore
    //
    for (i = 0; i < g_ssiLocalSSBState.saveLevel; i++)
    {
        if (rc)
        {
            //
            // We found this SPB, so we are discarding all entries after
            // it in the stack.  Subtract the saved pixels count for this
            // dude.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                g_ssiLocalSSBState.saveState[i].remotePelsRequired;
        }
        else if ((g_ssiLocalSSBState.saveState[i].rect.left   == lpRect->left)  &&
            (g_ssiLocalSSBState.saveState[i].rect.right  == lpRect->right) &&
            (g_ssiLocalSSBState.saveState[i].rect.top    == lpRect->top)   &&
            (g_ssiLocalSSBState.saveState[i].rect.bottom == lpRect->bottom) )
        {
            //
            // Found the one we were looking for
            //
            TRACE_OUT(("Found SPB at slot %d", i));

            iNewSaveLevel = i;
            rc = TRUE;
        }
    }

    g_ssiLocalSSBState.saveLevel = iNewSaveLevel;

    TRACE_OUT(("SSIFindSlotAndDiscardAbove:"));
    TRACE_OUT(("      saveLevel   is      %d", iNewSaveLevel));
    TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));

    DebugExitBOOL(SSIFindSlotAndDiscardAbove, rc);
    return(rc);
}





//
// FUNCTION: SSIRestoreBits
//
// DESCRIPTION:
//
// Attempts to restore the specified screen rectangle bits (using the same
// scheme as we previously used to save the bits: either the Display Driver
// our SaveBitmap simulation).
//
// If the bits were saved remotely then a RestoreBits order is sent to
// restore the remote bits.
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords).
//
// RETURNS:
//
// TRUE or FALSE - this will be returned to Windows as the return code of
// the SaveScreenBitmap call.
//
// Note: if FALSE is returned on a RestoreBits operation then Windows will
// restore the screen by invalidating the area to be restored.
//
//
BOOL SSIRestoreBits(LPRECT lpRect)
{
    BOOL      rc = FALSE;

    DebugEntry(SSIRestoreBits);

    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Can we find the SPB?
    //
    if (SSIFindSlotAndDiscardAbove(lpRect))
    {
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // The bits were saved remotely, so send and order.
            //
            rc = SSISendSaveBitmapOrder(lpRect, ONBOARD_RESTORE);
        }
        else
        {
            //
            // We failed to save the bitmap remotely originally, so now
            // we need to return FALSE so that BitBlt() will accumulate
            // screen data in the area.
            //
            TRACE_OUT(( "No remote save, force repaint"));
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }

        TRACE_OUT(("SSIRestoreBits:"));
        TRACE_OUT(("      saveLevel   is      %d", g_ssiLocalSSBState.saveLevel));
        TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));
    }

    DebugExitBOOL(SSIRestoreBits, rc);
    return(rc);
}


//
// FUNCTION: SSIDiscardBits
//
// DESCRIPTION:
//
// Attempts to discard the specified screen rectangle bits (using the same
// scheme as we previously used to save the bits: either the Display Driver
// our SaveBitmap simulation).
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords).
//
// RETURNS:
//
// TRUE or FALSE - this will be returned to Windows as the return code of
// the SaveScreenBitmap call.
//
//
BOOL SSIDiscardBits(LPRECT lpRect)
{
    BOOL rc = TRUE;

    DebugEntry(SSIDiscardBits);

    //
    // SS_FREE (discard) isn't called with a rectangle.  It is used to
    // discard the most recent save.
    //
    if (g_ssiLocalSSBState.saveLevel > 0)
    {
        --g_ssiLocalSSBState.saveLevel;

        //
        // The save level is now the index to this entry.  Since we are
        // about to free it, this will be the place the next SAVE goes
        // into.
        //

        //
        // If the bits were saved remotely then send a DISCARDBITS order.
        //
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // NOTE that SSISendSaveBitmapOrder() for DISCARD doesn't have
            // a side effect, we can just pass in the address of the rect
            // of the SPB we stored.
            // 
            SSISendSaveBitmapOrder(lpRect, ONBOARD_DISCARD);
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }

        TRACE_OUT(("SSIDiscardBits:"));
        TRACE_OUT(("      saveLevel   is      %d", g_ssiLocalSSBState.saveLevel));
        TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));
    }

    DebugExitBOOL(SSIDiscardBits, rc);
    return(rc);
}


//
// FUNCTION: SSIRemotePelsRequired
//
// DESCRIPTION:
//
// Returns the number of remote pels required to store the supplied
// rectangle, taking account of the Save Bitmap granularity.
//
// PARAMETERS:
//
// lpRect - pointer to rectangle position in EXCLUSIVE screen coordinates.
//
// RETURNS: Number of remote pels required.
//
//
DWORD SSIRemotePelsRequired(LPRECT lpRect)
{
    UINT    rectWidth    = 0;
    UINT    rectHeight   = 0;
    UINT    xGranularity = 1;
    UINT    yGranularity = 1;
    DWORD   rc;

    DebugEntry(SSIRemotePelsRequired);

    ASSERT(lpRect != NULL);

    //
    // Calculate the supplied rectangle size (it is in EXCLUSIVE coords).
    //
    rectWidth  = lpRect->right  - lpRect->left;
    rectHeight = lpRect->bottom - lpRect->top;

    xGranularity = g_ssiLocalSSBState.xGranularity;
    yGranularity = g_ssiLocalSSBState.yGranularity;

    rc =
      ((DWORD)(rectWidth + (xGranularity-1))/xGranularity * xGranularity) *
      ((DWORD)(rectHeight + (yGranularity-1))/yGranularity * yGranularity);

    //
    // Return the pels required in the remote SaveBits bitmap to handle
    // this rectangle, taking account of its granularity.
    //
    DebugExitDWORD(SSIRemotePelsRequired, rc);
    return(rc);
}


//
// FUNCTION:    SSISetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SSI related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SSISetNewCapabilities(LPSSI_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SSISetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_ssiSaveBitmapSize             = pCapabilities->sendSaveBitmapSize;

    g_ssiLocalSSBState.xGranularity = pCapabilities->xGranularity;

    g_ssiLocalSSBState.yGranularity = pCapabilities->yGranularity;

    TRACE_OUT(( "SSI caps: Size %ld X gran %hd Y gran %hd",
                 g_ssiSaveBitmapSize,
                 g_ssiLocalSSBState.xGranularity,
                 g_ssiLocalSSBState.yGranularity));

    DebugExitVOID(SSISetNewCapabilities);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\acpi.h ===
//
// ACPI.H
// This file is included by ObMan applets (namely, the old Whiteboard)
//
// Copyright (c) Microsoft, 1998-
//

#ifndef _H_ACPI
#define _H_ACPI


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Header that sets up OS flags. Include before everything else
//
#include <dcg.h>
#include <ut.h>
#include <dcs.h>


//
// Application Loader Programming Interface
//
#include <al.h>

//
// T.120 Data Conferencing Stuff
//
#include <ast120.h>

#ifdef __cplusplus
}
#endif // __cplusplus

//
// Whiteboard Programming Interface
// C++
//
#include <wb.hpp>


#endif // _H_ACPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\awc.h ===
//
// AWC.H
// Active Window Coordinator
//
// Copyright(c) Microsoft 1997-
//

#ifndef _H_AWC
#define _H_AWC

//
//
// CONSTANTS
//
//

#define AWC_INVALID_HWND            ((HWND)1)
#define AWC_SYNC_MSG_TOKEN          0xffff


//
//
// MACROS
//
//

#define AWC_IS_INDICATION(msg) \
    ((msg == AWC_MSG_ACTIVE_CHANGE_LOCAL) ||      \
     (msg == AWC_MSG_ACTIVE_CHANGE_INVISIBLE) ||  \
     (msg == AWC_MSG_ACTIVE_CHANGE_CAPTURED) ||   \
     (msg == AWC_MSG_ACTIVE_CHANGE_SHARED))

#define AWC_IS_REQUEST(msg) \
    ((msg == AWC_MSG_ACTIVATE_WINDOW) ||        \
     (msg == AWC_MSG_RESTORE_WINDOW))


#endif // _H_AWC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\dd\trc.c ===
#include "precomp.h"


//
// TRC.C
// Debug Tracing
// This emulates the code found in NMUTIL for ring0
//
// Copyright(c) Microsoft 1997-
//


#if defined(DEBUG) || defined(INIT_TRACE)


char        s_ASDbgArea[] = "NetMtg ";

#ifdef _M_ALPHA

va_list     g_trcDummyVa                =   {NULL, 0};
#define DUMMY_VA_LIST       g_trcDummyVa

#else

#define DUMMY_VA_LIST       NULL

#endif // _M_ALPHA



//
// Debug only
//

#ifdef DEBUG

//
// DbgZPrintFn()
// DbgZPrintFnExitDWORD()
// DbgZPrintFnExitPVOID()
//
// This prints out strings for function tracing
//

void DbgZPrintFn(LPSTR szFn)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        sprintf(g_szDbgBuf, "%s\n", szFn);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, DUMMY_VA_LIST);
    }
}



void DbgZPrintFnExitDWORD(LPSTR szFn, DWORD dwResult)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        sprintf(g_szDbgBuf, "%s, RETURN %d\n", szFn, dwResult);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, DUMMY_VA_LIST);
    }
}

void DbgZPrintFnExitPVOID(LPSTR szFn, PVOID ptr)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        sprintf(g_szDbgBuf, "%s, RETURN 0x%p\n", szFn, ptr);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, DUMMY_VA_LIST);
    }
}


//
// DbgZPrintTrace()
//
// This prints out a trace string
//
void DbgZPrintTrace(LPSTR szFormat, ...)
{
    if (g_trcConfig & ZONE_TRACE)
    {
        va_list varArgs;

        va_start(varArgs, szFormat);

        sprintf(g_szDbgBuf, "TRACE: %s\n", szFormat);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

        va_end(varArgs);
    }
}



//
// DbgZPrintWarning()
//
// This prints out a warning string
//
void DbgZPrintWarning(PSTR szFormat, ...)
{
    va_list varArgs;

    va_start(varArgs, szFormat);

    sprintf(g_szDbgBuf, "WARNING: %s\n", szFormat);
    EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

    va_end(varArgs);
}


#endif // DEBUG




//
// DbgZPrintInit()
//
// This is special case tracing only for the init code, which can be
// built even in retail
//

void DbgZPrintInit(LPSTR szFormat, ...)
{
    if (g_trcConfig & ZONE_INIT)
    {
        va_list varArgs;

        va_start(varArgs, szFormat);

        sprintf(g_szDbgBuf, "%s\n", szFormat);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

        va_end(varArgs);
    }
}



//
// DbgZPrintError()
//
// This prints out an error string then breaks into the kernel debugger.
//
void DbgZPrintError(LPSTR szFormat, ...)
{
    va_list varArgs;

    va_start(varArgs, szFormat);

    sprintf(g_szDbgBuf, "ERROR: %s\n", szFormat);
    EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

    va_end(varArgs);

    EngDebugBreak();
}




#endif // DEBUG or INIT_TRACE

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\asmaster.h ===
#ifndef _ASMASTER_H_
#define _ASMASTER_H_




class ASMaster : public IAppSharing
{
    friend BOOL CALLBACK eventProc(LPVOID, UINT, UINT_PTR, UINT_PTR);

public:

	ASMaster(UINT flags, IAppSharingNotify * pNotify);
    ~ASMaster();

	//
	// IUnknown methods:
	//

    STDMETHOD(QueryInterface)(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	//
	// IAppSharing methods:
	//

    //
    // Status
    //
    STDMETHODIMP_(BOOL) IsSharingAvailable();
    STDMETHODIMP_(BOOL) CanShareNow();
    STDMETHODIMP_(BOOL) IsInShare();
    STDMETHODIMP_(BOOL) IsSharing();
    STDMETHODIMP_(BOOL) IsWindowShareable(HWND hwnd);
    STDMETHODIMP_(BOOL) IsWindowShared(HWND hwnd);
    STDMETHODIMP_(BOOL) CanAllowControl();
    STDMETHODIMP_(BOOL) IsControllable();
    STDMETHODIMP GetPersonStatus(IAS_GCC_ID Person, IAS_PERSON_STATUS * pStatus);

    // Share/Unshare this window
    STDMETHODIMP LaunchHostUI(void);
	STDMETHODIMP GetShareableApps(IAS_HWND_ARRAY **ppHwnds);
    STDMETHODIMP FreeShareableApps(IAS_HWND_ARRAY *pHwnds);
	STDMETHODIMP Share(HWND hwnd, IAS_SHARE_TYPE how);
	STDMETHODIMP Unshare(HWND hwnd);

    //
    // Control
    //

    // Viewer side
    STDMETHODIMP TakeControl(IAS_GCC_ID PersonOf);
    STDMETHODIMP CancelTakeControl(IAS_GCC_ID PersonOf);
    STDMETHODIMP ReleaseControl(IAS_GCC_ID PersonOf);
    STDMETHODIMP PassControl(IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo);

    // Host side
    STDMETHODIMP AllowControl(BOOL fAllowed);
    STDMETHODIMP GiveControl(IAS_GCC_ID PersonTo);
    STDMETHODIMP CancelGiveControl(IAS_GCC_ID PersonTo);
    STDMETHODIMP RevokeControl(IAS_GCC_ID PersonTo);

    STDMETHODIMP PauseControl(IAS_GCC_ID PersonInControl);
    STDMETHODIMP UnpauseControl(IAS_GCC_ID PersonInControl);

    //
    // Event notifications
    //
    BOOL        OnEvent(UINT event, UINT_PTR param1, UINT_PTR param2);

public:
    IAppSharingNotify * m_pNotify;

protected:
    LONG                m_cRefs;
};


// callbacks

BOOL CALLBACK eventProc(LPVOID, UINT, UINT, UINT);

DWORD WINAPI WorkThreadEntryPoint(LPVOID hEventWait);
HWND         IsForDialog(HWND hwnd);


#endif // ! _ASMASTER_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\ast120.h ===
//
// AppSharing T.120 Layer
//      * GCC (conference management)
//      * MCS (data)
//      * FLOW (data queuing, flow control)
//
// This is also used by ObMan for old Whiteboard, but old Whiteboard will
// disappear in the next version of NM.
//
// Copyright (c) Microsoft 1998-
//

#ifndef _H_AST120
#define _H_AST120

#include <confreg.h>

// REAL T.120 headers
#include <t120.h>
#include <igccapp.h>
#include <imcsapp.h>
#include <iappldr.h>
#include <mtgset.h>

//
// GCC PART
//

//
// Call Manager Secondaries
//
#define CMTASK_FIRST    0
typedef enum
{
    CMTASK_OM = CMTASK_FIRST,
    CMTASK_AL,
    CMTASK_DCS,
    CMTASK_WB,
    CMTASK_MAX
}
CMTASK;



//
// The GCC Application Registry Key.  This is used for enrolling Groupware
// with GCC and for assigning tokens: for all tokens the registration key
// is the Groupware application key followed by the specific tokenKey for
// this secondary.
//
// The MFGCODE portion of this key has been assigned by the ITU.
//
//     USACode1    0xb5
//     USACode2    0x00
//     MFGCode1    0x53
//     MFGCode2    0x4c
//     "Groupware" 0x02
//
// The length of the key in bytes including the NULLTERM.
//
//
#define GROUPWARE_GCC_APPLICATION_KEY     "\xb5\x00\x53\x4c\x02"





//
// Call Manager Events
//
enum
{
    CMS_NEW_CALL = CM_BASE_EVENT,
    CMS_END_CALL,
    CMS_PERSON_JOINED,
    CMS_PERSON_LEFT,
    CMS_CHANNEL_REGISTER_CONFIRM,
    CMS_TOKEN_ASSIGN_CONFIRM
};



//
// CM_STATUS
//
typedef struct tagCM_STATUS
{
    UINT_PTR            callID;
    UINT            peopleCount;
    BOOL            fTopProvider;
    UINT            topProviderID;
    NM30_MTG_PERMISSIONS attendeePermissions;

    TSHR_PERSONID   localHandle;
    char            localName[TSHR_MAX_PERSON_NAME_LEN];
}
CM_STATUS;
typedef CM_STATUS * PCM_STATUS;




//
// Secondary instance data
//
typedef struct tagCM_CLIENT
{
    STRUCTURE_STAMP
    PUT_CLIENT      putTask;
    CMTASK          taskType;
    UINT            useCount;

    // Registering Channel
    UINT            channelKey;

    // Assigning Token
    UINT            tokenKey;

    BOOL            exitProcRegistered:1;
}
CM_CLIENT;
typedef CM_CLIENT * PCM_CLIENT;



//
// Person element in linked list of people currently in conference
//
typedef struct tagCM_PERSON
{
    BASEDLIST           chain;
    TSHR_PERSONID       netID;
}
CM_PERSON;
typedef CM_PERSON * PCM_PERSON;



//
// Primary data
//
typedef struct tagCM_PRIMARY
{
    STRUCTURE_STAMP
    PUT_CLIENT          putTask;

    BOOL                exitProcRegistered;

    //
    // Secondary tasks
    //
    PCM_CLIENT          tasks[CMTASK_MAX];

    //
    // T.120/call state stuff
    //
    UINT_PTR            callID;
    BOOL                currentCall;
    BOOL                fTopProvider;

    BOOL                bGCCEnrolled;

    IGCCAppSap        * pIAppSap;
    UserID              gccUserID;
    UserID              gccTopProviderID;

    //
    // People conference stuff
    //
    char                localName[TSHR_MAX_PERSON_NAME_LEN];

    UINT                peopleCount;
    BASEDLIST           people;
}
CM_PRIMARY;
typedef CM_PRIMARY * PCM_PRIMARY;



__inline void ValidateCMP(PCM_PRIMARY pcmPrimary)
{
    ASSERT(!IsBadWritePtr(pcmPrimary, sizeof(CM_PRIMARY)));
    ASSERT(pcmPrimary->putTask);
}



__inline void ValidateCMS(PCM_CLIENT pcm)
{
    extern PCM_PRIMARY  g_pcmPrimary;

    ValidateCMP(g_pcmPrimary);

    ASSERT(!IsBadWritePtr(pcm, sizeof(CM_CLIENT)));
    ASSERT(pcm->putTask);

    ASSERT(pcm->taskType >= CMTASK_FIRST);
    ASSERT(pcm->taskType < CMTASK_MAX);
    ASSERT(g_pcmPrimary->tasks[pcm->taskType] == pcm);
}

//
// CM Primary Functions
//

BOOL CMP_Init(BOOL * pfCleanup);
void CMP_Term(void);

void CMPCallEnded(PCM_PRIMARY pcmPrimary);
void CMPBroadcast(PCM_PRIMARY pcmPrimary, UINT event, UINT param1, UINT_PTR param2);

void CALLBACK CMPExitProc(LPVOID pcmPrimary);


BOOL CMPGCCEnroll(PCM_PRIMARY pcmPrimary,
                  GCCConferenceID  conferenceID,
                  BOOL          fEnroll);

void CMPProcessPermitToEnroll(PCM_PRIMARY pcmPrimary,
                              GCCAppPermissionToEnrollInd FAR * pMsg);

void CMPProcessEnrollConfirm(PCM_PRIMARY pcmPrimary,
                             GCCAppEnrollConfirm FAR * pMsg);

void CMPProcessRegistryConfirm(PCM_PRIMARY pcmPrimary,
                               GCCMessageType         messageType,
                               GCCRegistryConfirm FAR * pMsg);

void CMPProcessAppRoster(PCM_PRIMARY pcmPrimary,
                         GCCConferenceID confID,
                         GCCApplicationRoster FAR * pAppRoster);

//
// Process GCC callbacks
//
void CALLBACK CMPGCCCallback(GCCAppSapMsg FAR * pMsg);

void CMPBuildGCCRegistryKey(UINT dcgKeyNum, GCCRegistryKey FAR * pGCCKey, LPSTR dcgKeyStr);



//
// CM Secondary
//

BOOL CMS_Register(PUT_CLIENT putTask, CMTASK taskType, PCM_CLIENT * pCmHandle);
void CMS_Deregister(PCM_CLIENT * pCmHandle);

#ifdef __cplusplus
extern "C"
{
#endif
BOOL WINAPI CMS_GetStatus(PCM_STATUS pCmStats);
#ifdef __cplusplus
}
#endif

BOOL CMS_ChannelRegister(PCM_CLIENT pcmClient, UINT channelKey, UINT channelID);
BOOL CMS_AssignTokenId(PCM_CLIENT pcmClient, UINT tokenKey);

void CALLBACK CMSExitProc(LPVOID pcmClient);



//
// MCS PART
//


//
// Errors
//
enum
{
    // Generic errors
    NET_RC_NO_MEMORY                = NET_BASE_RC,
    NET_RC_INVALID_STATE,

    // S20 errors
    NET_RC_S20_FAIL,

    // MGC errors
    NET_RC_MGC_ALREADY_INITIALIZED,
    NET_RC_MGC_INVALID_USER_HANDLE,
    NET_RC_MGC_INVALID_LENGTH,
    NET_RC_MGC_INVALID_DOMAIN,
    NET_RC_MGC_TOO_MUCH_IN_USE,
    NET_RC_MGC_NOT_YOUR_BUFFER,
    NET_RC_MGC_LIST_FAIL,
    NET_RC_MGC_NOT_CONNECTED,
    NET_RC_MGC_NOT_SUPPORTED,
    NET_RC_MGC_NOT_INITIALIZED,
    NET_RC_MGC_INIT_FAIL,
    NET_RC_MGC_DOMAIN_IN_USE,
    NET_RC_MGC_NOT_ATTACHED,
    NET_RC_MGC_INVALID_CONN_HANDLE,
    NET_RC_MGC_INVALID_UP_DOWN_PARM,
    NET_RC_MGC_INVALID_REMOTE_ADDRESS,
    NET_RC_MGC_CALL_FAILED
};


//
// Results
//
typedef TSHR_UINT16     NET_RESULT;

enum
{
    NET_RESULT_OK   = 0,
    NET_RESULT_NOK,
    NET_RESULT_CHANNEL_UNAVAILABLE,
    NET_RESULT_DOMAIN_UNAVAILABLE,
    NET_RESULT_REJECTED,
    NET_RESULT_TOKEN_ALREADY_GRABBED,
    NET_RESULT_TOKEN_NOT_OWNED,
    NET_RESULT_NOT_SPECIFIED,
    NET_RESULT_UNKNOWN,
    NET_RESULT_USER_REJECTED
};


//
// Reaons
//
typedef enum
{
    NET_REASON_DOMAIN_DISCONNECTED = 1,
    NET_REASON_DOMAIN_UNAVAILABLE,
    NET_REASON_TOKEN_NONEXISTENT,
    NET_REASON_USER_REQUESTED,
    NET_REASON_CHANNEL_UNAVAILABLE,
    NET_REASON_UNKNOWN
}
NET_REASON;



//
// Events
//
enum
{
    NET_EVENT_USER_ATTACH = NET_BASE_EVENT,
    NET_EVENT_USER_DETACH,
    NET_EVENT_CHANNEL_JOIN,
    NET_EVENT_CHANNEL_LEAVE,
    NET_EVENT_TOKEN_GRAB,
    NET_EVENT_TOKEN_INHIBIT,
    NET_EVENT_DATA_RECEIVED,
    NET_FEEDBACK,
    NET_FLOW,
    NET_MG_SCHEDULE,
    NET_MG_WATCHDOG
};




//
// FOR MCS USERS (ALL APPS, INCLUDING CALL MANAGER)
//
//          state->|   0  |  1     |  2     |    3     |   4     |   5
//                 |CTRLR |CTRLR   |CTLR    |CTLR      |CTLR     |CTLR
//                 |state |state 2,|state2, |state2,   |state 3, |state 3
//                 | 0/1  |user not|user    |user      |user     |user
// verb/event      |      |attached|pending |attached  |attached |pending
//       |         |......|........|........|..........|.........|.........
//       V         |      |        |        |          |         |
// _get_buffer     |   X  |  X     |   X    |    -     |  **     |  X
// _free_buffer    |   X  |  X     |   X    |    -     |  -      |  -
// _realloc_bfr    |   X  |  X     |   X    |    -     |  -      |  -
// _attach_user    |   X  |  ->2   |   X    |    X     |  X      |  X
// _detach_user    |   X  |  X     |   X    |    ->1   |  ->0    |  X
// _channel_join   |   X  |  X     |   X    |    -     |  X      |  X
// _channel_leave  |   X  |  X     |   X    |    -     |  -      |  X
// _send_data      |   X  |  X     |   X    |    -     |  X      |  X
//                 |      |        |        |          |         |
// _STOP_CONTRLR*  |      |  ->0   |  ->5   |    ->4   |         |
//                 |      |        |        |          |         |
// _ATTACH_CNF OK  |      |        |  ->3   |          |         |  ->4
// _ATTACH_CNF FAIL|      |        |  ->1   |          |         |  ->0
// _DETACH_IND-SELF|      |        |  ->1   |   ->1    |  ->0    |
// _DETACH_IND-othr|      |        |        |    -     |  -      |
// _JOIN_CONFIRM   |      |        |        |    -     |  -      |
// _LEAVE_INDICAT  |      |        |        |    -     |  -      |
// _SEND_INDICAT   |      |        |        |    -     |  -      |
// =======================================================================
//
// NOTES ** when the controller is STOPPING the NET_GetBuffer
//          verb is valid but always returns a NULL buffer (no memory)
//
//       *  the STOP_CONTROLLER event is internally generated, and is
//          not seen across the API.  It is generated when the controller
//          issues the NET_StopController verb and causes the state change
//          (to state 0, 4 or 5) such that the NET_AttachUser,
//          ChannelJoin and NET_SendData verbs are rejected.
//
//
//



//
// Priorities
//
#define NET_INVALID_PRIORITY        ((NET_PRIORITY)-1)

enum
{
    NET_TOP_PRIORITY = 0,
    NET_HIGH_PRIORITY,
    NET_MEDIUM_PRIORITY,
    NET_LOW_PRIORITY,
    NET_NUM_PRIORITIES
};


//
// SFR6025: This flag is or-ed with the priority bit to indicate to the MCS
//          glue that it should send data on all channels.
//

//
// FOR OBMAN ONLY -- REMOVE IN NM 4.0
//
#define NET_SEND_ALL_PRIORITIES          0x8000






#define NET_ALL_REMOTES             ((NET_UID)1)
#define NET_INVALID_DOMAIN_ID       (0xFFFFFFFF)
#define NET_UNUSED_IDMCS            1





typedef TSHR_UINT16         NET_UID;            // MCS user IDs
typedef TSHR_UINT16         NET_CHANNEL_ID;     // MCS channel IDs
typedef TSHR_UINT16         NET_TOKEN_ID;       // MCS token IDs
typedef TSHR_UINT16         NET_PRIORITY;       // MCS priorities



//
// Forward decls of MGC structures
//
typedef struct tagMG_BUFFER *   PMG_BUFFER;
typedef struct tagMG_CLIENT *   PMG_CLIENT;


//
// Flow control structure - This contains the target latency (in mS) and
// stream size (in bytes) for each User Attachment
// lonchanc: used by S20, MG, and OM.
//
typedef struct tag_NET_FLOW_CONTROL
{
    UINT        latency[NET_NUM_PRIORITIES];
    UINT        streamSize[NET_NUM_PRIORITIES];
}
NET_FLOW_CONTROL, * PNET_FLOW_CONTROL;



//
// NET_EV_JOIN_CONFIRM and NET_EV_JOIN_CONFIRM_BY_KEY
// join_channel confirm:
// lonchanc: used by S20, MG, and OM.
//
typedef struct tagNET_JOIN_CNF_EVENT
{
    UINT_PTR                callID;

    NET_RESULT              result;      // NET_RESULT_USER_ACCEPTED/REJECTED
    TSHR_UINT16             pad1;

    NET_CHANNEL_ID          correlator;
    NET_CHANNEL_ID          channel;
}
NET_JOIN_CNF_EVENT;
typedef NET_JOIN_CNF_EVENT * PNET_JOIN_CNF_EVENT;


//
// NET_EV_SEND_INDICATION
// send data indication: see MG_SendData()
// Despite its name, this event indicates that data has been RECEIVED!
// lonchanc: used by MG and S20
//
typedef struct tag_NET_SEND_IND_EVENT
{
    UINT_PTR                callID;

    NET_PRIORITY            priority;
    NET_CHANNEL_ID          channel;

    UINT                    lengthOfData;
    LPBYTE                  data_ptr;      // Pointer to the real data.
}
NET_SEND_IND_EVENT;
typedef NET_SEND_IND_EVENT * PNET_SEND_IND_EVENT;



//
// MGC, FLOW CONTROL
//

//
// MG tasks
//
#define MGTASK_FIRST    0
typedef enum
{
    MGTASK_OM = MGTASK_FIRST,
    MGTASK_DCS,
    MGTASK_MAX
}
MGTASK;


//
// Buffer types
//
enum
{
    MG_TX_BUFFER = 1,
    MG_RX_BUFFER,
    MG_EV_BUFFER,
    MG_TX_PING,
    MG_TX_PONG,
    MG_TX_PANG,
    MG_RQ_CHANNEL_JOIN,
    MG_RQ_CHANNEL_JOIN_BY_KEY,
    MG_RQ_CHANNEL_LEAVE,
    MG_RQ_TOKEN_GRAB,
    MG_RQ_TOKEN_INHIBIT,
    MG_RQ_TOKEN_RELEASE
};


//
// Period of watchdog timer to detect lost connections
//
#define MG_TIMER_PERIOD                 1000


//
// MG priorities:
//
#define MG_HIGH_PRIORITY        NET_HIGH_PRIORITY
#define MG_MEDIUM_PRIORITY      NET_MEDIUM_PRIORITY
#define MG_LOW_PRIORITY         NET_LOW_PRIORITY

#define MG_PRIORITY_HIGHEST     MG_HIGH_PRIORITY
#define MG_PRIORITY_LOWEST      MG_LOW_PRIORITY
#define MG_NUM_PRIORITIES       (MG_PRIORITY_LOWEST - MG_PRIORITY_HIGHEST + 1)


//
// MCS priority validation.
// Priorities are contiguous numbers in the range NET_PRIORITY_HIGHEST..
// NETPRIORITY_LOWEST.  Priorities supplied to MG may also have the
// NET_SEND_ALL_PRIORITIES flag set.  So, to validate a priority:
//  - knock off the NET_SEND_ALL_PRIORITIES flag to give the raw priority
//  - set the valid raw prioririty to
//      NET_PRIORITY_HIGHEST if the raw priority is less than ...ITY_HIGHEST
//      NET_PRIORITY_LOWEST if the raw priority is more than ...ITY_LOWEST
//      the raw priority if it is in the valid range
//  - add the original ...ALL_PRIORITIES flag to the valid raw priority
//
#define MG_VALID_PRIORITY(p)                                                 \
    ((((p)&~NET_SEND_ALL_PRIORITIES)<MG_HIGH_PRIORITY)?                      \
      (MG_HIGH_PRIORITY|((p)&NET_SEND_ALL_PRIORITIES)):                      \
      (((p)&~NET_SEND_ALL_PRIORITIES)>MG_LOW_PRIORITY)?                      \
        (MG_LOW_PRIORITY|((p)&NET_SEND_ALL_PRIORITIES)):                     \
        (p))


//
//
// The initial stream size setting may appear high, but it is set so that
// in a LAN scenario we do not require the app to place a lot of forward
// pressure on the pipe before it opens up.  In a non-LAN scenario we may
// not do enough spoiling to start with, but in actual fact DCS tends
// to send less data than this limit anyway, so we should reduce it
// quite quickly without flooding the buffers.
//
#define FLO_INIT_STREAMSIZE     8000
#define FLO_MIN_STREAMSIZE       500
#define FLO_MAX_STREAMSIZE    256000
#define FLO_MIN_PINGTIME         100
#define FLO_INIT_PINGTIME       1000

//
// This is the max number of bytes that can be allocated per stream if a
// pong has not been received (i.e. FC is not operational).
//
#define FLO_MAX_PRE_FC_ALLOC   16000

//
// This is the max number of pkts outstanding before we apply back
// pressure:
//
#define FLO_MAX_RCV_PACKETS       5

//
// This is the max number of pkts outstanding before we get worried about
// creep:
//
#define FLO_MAX_RCV_PKTS_CREEP    250

//
// The maximum number of flow controlled streams.
//
#define FLO_MAX_STREAMS       128
#define FLO_NOT_CONTROLLED    FLO_MAX_STREAMS




//
// STRUCTURE : FLO_STREAM_DATA
//
// DESCRIPTION:
//
// This structure holds all the static data for a flow control stream
//
// FIELDS:
//
// channel
// priority
// pingValue         - Next ping value to be sent on the pipe
// eventNeeded       - We need to wake up the app because we have rejected
//                     a buffer allocation request
// backlog           - the allowable backlog in mS bejond which we apply
//                     back pressure
// pingNeeded        - Send a ping at the next opportunity
// pingTime          - Minimum time, in mS, between each ping
// gotPong           - Indicates we have received a pong from some remote
//                     party and so flow control can commence
// lastPingTime      - Time for last ping, in timer ticks
// nextPingTime      - Time for next ping, in timer ticks
// lastDenialTime    - Previous time (in ticks) that we started denying
//                     buffer requests
// curDenialTime     - Time in ticks that we most recently started denying
//                     buffer requests
// DC_ABSMaxBytesInPipe
//                   - Absolute maximum buffer allocation for this stream
// maxBytesInPipe    - Current buffer allocation limit
// bytesInPipe       - Current amount of data outstanding on this stream.
//                     This includes data currently waiting to be sent.
// users             - Base for queue of User correlators
// bytesAllocated    - The current amount of data in the glue for this
//                     stream which has not been sent. This is different
//                     to bytesInPipe which is the amount of unacknowledged
//                     data in this stream.
//
//
typedef struct tagFLO_STREAM_DATA
{
    STRUCTURE_STAMP

    NET_CHANNEL_ID      channel;
    WORD                gotPong:1;
    WORD                eventNeeded:1;
    WORD                pingNeeded:1;

    UINT                priority;
    UINT                pingValue;
    UINT                backlog;
    UINT                pingTime;
    UINT                lastPingTime;
    UINT                nextPingTime;
    UINT                lastDenialTime;
    UINT                curDenialTime;
    UINT                DC_ABSMaxBytesInPipe;
    UINT                maxBytesInPipe;
    UINT                bytesInPipe;
    UINT                bytesAllocated;

    BASEDLIST              users;
}
FLO_STREAM_DATA;
typedef FLO_STREAM_DATA * PFLO_STREAM_DATA;


void __inline ValidateFLOStr(PFLO_STREAM_DATA pStr)
{
    if (pStr != NULL)
    {
        ASSERT(!IsBadWritePtr(pStr, sizeof(FLO_STREAM_DATA)));
    }
}



//
// The FLO callback function
//
// A wakeup type callback indicates that a back pressure situation has
// been relieved.
//
// A buffermod callback indicates this as well, but also indicates that
// the buffer size for controlling flow on the designated channel/priority
// has changed.
//
#define FLO_WAKEUP     1
#define FLO_BUFFERMOD  2
typedef void (* PFLOCALLBACK)(PMG_CLIENT    pmgClient,
                                     UINT       callbackType,
                                     UINT       priority,
                                     UINT       newBufferSize);


//
// STRUCTURE : FLO_STATIC_DATA
//
// DESCRIPTION:
//
// This structure holds all the instance specific static data for the
// Flow Control DLL
//
// FIELDS:
//
// numStreams     - ID of the highest allocated stream
// rsvd           - reserved
// callback       - pointer to a callback function
// pStrData       - an array of FLO_STREAM_DATA pointers.
//
//
typedef struct FLO_STATIC_DATA
{
    UINT                numStreams;
    PFLOCALLBACK        callBack;
    PFLO_STREAM_DATA    pStrData[FLO_MAX_STREAMS];
}
FLO_STATIC_DATA;
typedef FLO_STATIC_DATA * PFLO_STATIC_DATA;



typedef struct FLO_USER
{
    BASEDLIST          list;

    STRUCTURE_STAMP

    WORD            userID;
    WORD            lastPongRcvd;
    WORD            pongNeeded;
    BYTE            sendPongID;
    BYTE            pad1;

    UINT            sentPongTime;    // Time we actually sent the pong
    WORD            rxPackets;       // Count of packets outstanding
    WORD            gotPong;         // Indicates this user has ponged
                                        // and they are permitted to apply
                                        // back pressure to our sends
    UINT            numPongs;        // total number of pongs from user
    UINT            pongDelay;       // total latency across pongs
}
FLO_USER;
typedef FLO_USER * PFLO_USER;


void __inline ValidateFLOUser(PFLO_USER pFloUser)
{
    ASSERT(!IsBadWritePtr(pFloUser, sizeof(FLO_USER)));
}


//
// Maximum wait time before assuming a user is offline
// We need to keep this high until the apps become "well behaved" and
// respond to the flow control buffer size recommendations.
//
#define FLO_MAX_WAIT_TIME     20000



//
//
// Client Control Block
//
//

typedef struct tagMG_CLIENT
{
    PUT_CLIENT      putTask;
    PCM_CLIENT      pcmClient;

    BASEDLIST       buffers;       // list of children buffers
    BASEDLIST       pendChain;     // Chain of pending request from client
    BASEDLIST       joinChain;     // Chain of pending join-by-key requests

    //
    // MCS user attachment info
    //
    PIMCSSap      	m_piMCSSap;       // user interface ptr returned by MCS
    UserID          userIDMCS;        // user ID returned by MCS
    FLO_STATIC_DATA flo;              // flow control structure


    WORD            eventProcReg:1;
    WORD            lowEventProcReg:1;
    WORD            exitProcReg:1;
    WORD            joinPending:1;   // Is there a channel join outstanding ?
    WORD            userAttached:1;

    WORD            joinNextCorr;

    NET_FLOW_CONTROL flowControl;  // flow control latency/backlog params
}
MG_CLIENT;


void __inline ValidateMGClient(PMG_CLIENT pmgc)
{
    ASSERT(!IsBadWritePtr(pmgc, sizeof(MG_CLIENT)));
    ValidateUTClient(pmgc->putTask);
}



typedef struct tagMG_INT_PKT_HEADER
{
    TSHR_UINT16         useCount;   // The use count of this packet.  This
                                    //   is required for sending the same
                                    //   data on multiple channels.

    TSHR_NET_PKT_HEADER header;
}
MG_INT_PKT_HEADER;
typedef MG_INT_PKT_HEADER * PMG_INT_PKT_HEADER;




//
//
// Buffer Control Block
//
//
typedef struct tagMG_BUFFER
{
    STRUCTURE_STAMP

    UINT                type;

    BASEDLIST           pendChain;      // Used when the buffer is added to the
    BASEDLIST           clientChain;

    PMG_INT_PKT_HEADER  pPktHeader;     // Pointer to MCS control info
    void *              pDataBuffer;    // Pointer passed to apps
    UINT                length;         // length of the associated packet

    ChannelID           channelId;      // Send destination, or token grab req
    ChannelID           channelKey;

    UserID              senderId;
    NET_PRIORITY        priority;

    BOOL                eventPosted;
    UINT                work;           // work field for misc use

    PFLO_STREAM_DATA    pStr;           // Pointer to the FC stream
}
MG_BUFFER;


void __inline ValidateMGBuffer(PMG_BUFFER pmgb)
{
    ASSERT(!IsBadWritePtr(pmgb, sizeof(MG_BUFFER)));
}


//
//
//
// MACROS
//
//
//

//
// MCS priority validation.
// Priorities are contiguous numbers in the range NET_PRIORITY_HIGHEST..
// NET_PRIORITY_LOWEST. Priorities supplied to MG may also have the
// NET_SEND_ALL_PRIORITIES flag set. So, to validate a priority:
// -  knock off the NET_SEND_ALL_PRIORITIES flag to give the raw priority
// -  set the valid raw priority to
//   -  NET_PRIORITY_HIGHEST if the raw priority is less than ...ITY_HIGHEST
//   -  NET_PRIORITY_LOWEST if the raw priority is more than ...ITY_LOWEST
//   -  the raw priority if it is in the valid range
// -  add the original ...ALL_PRIORITIES flag to the valid raw priority.
//


//
//
//
// FUNCTION PROTOTYPES
//
//
//

//
//
//  MGLongStopHandler(...)
//
// This function is registered as a low priority event handler for each
// client.  It catches any unprocessed network events and frees any
// associated memory.
//
//
BOOL CALLBACK MGLongStopHandler(LPVOID pmgClient, UINT event, UINT_PTR param1, UINT_PTR param2);

//
//
//  MGEventHandler(...)
//
// This function is registered as a high priority event handler for the
// processing of MG_ChannelJoinByKey, MCS request handling and scheduling.
// It catches NET channel join confirm and CMS register channel confirm
// events, and massages them into the correct return events for the app.
// It queues requests coming from the app context into the glue context
// and schedules queued requests.
//
//
BOOL CALLBACK MGEventHandler(LPVOID pmgClient, UINT event, UINT_PTR param1, UINT_PTR param2);


//
UINT MGHandleSendInd(PMG_CLIENT pmgClient, PSendData pSendInfo);



//
//
//  MGNewBuffer(...)
//  NewTxBuffer(...)
//  NewRxBuffer(...)
//  FreeBuffer(...)
//
// The New function allocates and initialises a buffer , allocates buffer
// memory of the specified size and type and adds the  to the client's
// list of buffer s.
//
// The Tx version performs flow control on the buffer allocation request
// The Rx version just allocates a receive buffer
//
// The Free function discards a buffer , discards the associated buffer
// memory, decrements the client's count of memory in use and removes the
//  from the client's list of buffer s.
//
//

void MGNewCorrelator(PMG_CLIENT ppmgClient, WORD * pCorrelator);

UINT MGNewBuffer(PMG_CLIENT pmgClient, UINT typeOfBuffer,
                                PMG_BUFFER     * ppBuffer);

UINT MGNewDataBuffer(PMG_CLIENT           pmgClient,
                                  UINT                typeOfBuffer,
                                  UINT                sizeOfBuffer,
                                  PMG_BUFFER     * ppBuffer);

UINT MGNewTxBuffer(PMG_CLIENT         pmgClient,
                                NET_PRIORITY          priority,
                                NET_CHANNEL_ID        channel,
                                UINT              sizeOfBuffer,
                                PMG_BUFFER   * ppBuffer);

UINT MGNewRxBuffer(PMG_CLIENT         pmgClient,
                                NET_PRIORITY          priority,
                                NET_CHANNEL_ID        channel,
                                NET_CHANNEL_ID        senderID,
                                PMG_BUFFER   		* ppBuffer);

void MGFreeBuffer(PMG_CLIENT pmgClient, PMG_BUFFER  * ppBuffer);


//
//
//  MGProcessDomainWatchdog(...)
//
// Handle domain watchdog timer ticks.
//
//
void MGProcessDomainWatchdog(PMG_CLIENT pmgClient);

void MGProcessEndFlow(PMG_CLIENT pmgClient, ChannelID channel);

UINT MGPostJoinConfirm(PMG_CLIENT pmgClient,
                                    NET_RESULT      result,
                                    NET_CHANNEL_ID  channel,
                                    NET_CHANNEL_ID  correlator);



NET_RESULT TranslateResult(WORD Result);


//
//
//  MGFLOCallBack(...)
//
// Callback poked by flow control to trigger the app to retry buffer
// requests thet were previously rejected
//
//
void        MGFLOCallBack(PMG_CLIENT    pmgClient,
                                  UINT      callbackType,
                                  UINT      priority,
                                  UINT      newBufferSize);




//
//
//  MGProcessPendingQueue(...)
//
// Called whenever MG wants to try and execute pending requests.  Requests
// are queued because they may fail for a transient reason, such as MCS
// buffer shortage.
//
//
UINT MGProcessPendingQueue(PMG_CLIENT pmgClient);




BOOL    MG_Register(MGTASK task, PMG_CLIENT * pmgClient, PUT_CLIENT putTask);
void    MG_Deregister(PMG_CLIENT * ppmgClient);

void CALLBACK MGExitProc(LPVOID uData);






UINT  MG_Attach(PMG_CLIENT pmgClient,  UINT_PTR callID, PNET_FLOW_CONTROL pFlowControl);
void  MG_Detach(PMG_CLIENT pmgClient);
void  MGDetach(PMG_CLIENT pmgClient);



UINT MG_ChannelJoin(PMG_CLIENT pmgClient, NET_CHANNEL_ID * pCorrelator,
                                        NET_CHANNEL_ID  channel);

UINT MG_ChannelJoinByKey(PMG_CLIENT pmgClient,
                                             NET_CHANNEL_ID * pCorrelator,
                                             WORD          channelKey);

void MG_ChannelLeave(PMG_CLIENT pmgClient, NET_CHANNEL_ID channel);


UINT MG_GetBuffer(PMG_CLIENT pmgClient, UINT length,
                                      NET_PRIORITY   priority,
                                      NET_CHANNEL_ID channel,
                                      void **       buffer);

void MG_FreeBuffer(PMG_CLIENT pmgClient,
                                       void **      buffer);

UINT MG_SendData(PMG_CLIENT pmgClient,
                                     NET_PRIORITY   priority,
                                     NET_CHANNEL_ID channel,
                                     UINT       length,
                                     void **       data);

UINT  MG_TokenGrab(PMG_CLIENT pmgClient, NET_TOKEN_ID token);

UINT  MG_TokenInhibit(PMG_CLIENT pmgClient, NET_TOKEN_ID token);

void MG_FlowControlStart(PMG_CLIENT  pmgClient,
                                          NET_CHANNEL_ID channel,
                                          NET_PRIORITY   priority,
                                          UINT       backlog,
                                          UINT       maxBytesOutstanding);

//
// API FUNCTION: FLO_UserTerm
//
// DESCRIPTION:
//
// Called by an application to end flow control on all the channels
// associated with a particular user.
//
// PARAMETERS:
//
// pUser  - MCS Glue User attachment
//
// RETURNS: Nothing.
//
//
void FLO_UserTerm(PMG_CLIENT pmgClient);



//
// API FUNCTION: FLO_StartControl
//
// DESCRIPTION:
//
// The application calls this function whenever it wants a data stream to
// be flow controlled
//
// PARAMETERS:
//
// pUser  - MCS Glue User attachment
// channel - channel id of channel to be flow controlled
// priority - priority of the stream to be controlled
// backlog - the maximum backlog (in mS) allowed for this stream
// maxBytesOutstanding - the maximum number of bytes allowed in the stream
//                       irrespective of the backlog.  0 = use default of
//                       64 KBytes
//
// RETURNS:
// None
//
//
void FLO_StartControl(PMG_CLIENT    pmgClient,
                              NET_CHANNEL_ID channel,
                              UINT       priority,
                              UINT       backlog,
                              UINT       maxBytesOutstanding);


void FLO_EndControl
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    UINT            priority
);

//
// API FUNCTION: FLO_AllocSend
//
// DESCRIPTION:
//
// The application is requesting a buffer in order to send a packet.  This
// may trigger a flow control packet in advance of the application packet.
// Flow control may choose to reject the packet with NET_OUT_OF_RESOURCE in
// which case the application must reschedule the allocation at a ater
// date.  To assist the rescheduling, if ever a send is rejected then flow
// control will call the application callback to trigger the reschedule.
//
// PARAMETERS:
//
//     pUser  - MCS Glue User attachment
//     priority - The priority for this buffer
//     channel  - The channnel on which to send the packet
//     size     - The size of the packet
//     ppStr    - Pointer to the pointer to the FC stream. This is a
//                return value.
//
//
UINT FLO_AllocSend(PMG_CLIENT   pmgClient,
                             UINT               priority,
                             NET_CHANNEL_ID         channel,
                             UINT               size,
                             PFLO_STREAM_DATA * ppStr);

//
// API FUNCTION: FLO_ReallocSend
//
// DESCRIPTION:
//
// The application has requested that the glue send a packet, but the
// packet contains less data than originally requested.
// Flow control heuristics get thrown out unless we logically free the
// unused portion of the packet for reuse for other allocations.
// If we didn't do this then we might see a 8K packet, for example,
// complete in 1 second because the app only put 1K of data in it.
//
// PARAMETERS:
//
//     pUser  - MCS Glue User attachment
//     pStr     - The flow control stream to be corrected
//     size     - The size of the packet that has been unused
//
// RETURNS:
//
// None
//
//
void FLO_ReallocSend(PMG_CLIENT pmgClient,
                             PFLO_STREAM_DATA       pStr,
                             UINT               size);

//
// API FUNCTION: FLO_DecrementAlloc
//
// DESCRIPTION:
//
// This function decrements the bytesAllocated count for a given stream.
// It is called whenever a packet is sent or removed from the send chain.
//
// PARAMETERS:
//
//     pStr     - The flow control stream to be decremented
//     size     - The size to decrement
//
// RETURNS:
//
// None
//
//
void FLO_DecrementAlloc(      PFLO_STREAM_DATA       pStr,
                                UINT               size);

//
// API FUNCTION: FLO_ReceivedPacket
//
// DESCRIPTION:
//
// Upon receipt of a flow control packet the MCS glue calls this function
// and then ignores the packet.
//
// PARAMETERS:
//
// pUser  - MCS Glue User attachment
// pPkt     - pointer to the packet, for FLO to process
//
// RETURNS:
//
// None
//
//
void FLO_ReceivedPacket(PMG_CLIENT pmgClient, PTSHR_FLO_CONTROL pPkt);


//
// API FUNCTION: FLO_AllocReceive
//
// DESCRIPTION:
//
// Called to indicate that a receive buffer is now in use by the application
//
// PARAMETERS:
//
// pmg         - pointer to the glue user attacgment cb
// priority
// channel
// size        - size of the buffer just been allocated
//
// RETURNS:
//
// None
//
//
void FLO_AllocReceive(PMG_CLIENT         pmgClient,
                              UINT       priority,
                              NET_CHANNEL_ID channel,
                              UINT       senderID);

//
// API FUNCTION: FLO_FreeReceive
//
// DESCRIPTION:
//
// Called to indicate that a receive buffer has ben handed back by the
// application.
//
// PARAMETERS:
//
// pmg         - pointer to the glue user attachment cb
// priority
// channel
// size        - size of the buffer just been freed
//
// RETURNS:
//
// None
//
//
void FLO_FreeReceive(PMG_CLIENT    pmgClient,
                              NET_PRIORITY priority,
                              NET_CHANNEL_ID channel,
                              UINT       senderID);

//
// API FUNCTION: FLO_CheckUsers
//
// DESCRIPTION:
//
// Called periodically by each client to allow flow control to determine if
// remote users have left the channel
//
// PARAMETERS:
//
// pmg - pointer to the user
//
// RETURNS:
//
// None
//
//
void FLO_CheckUsers(PMG_CLIENT pmgClient);

//
// FLOGetStream()
//
UINT FLOGetStream(PMG_CLIENT pmgClient, NET_CHANNEL_ID channel, UINT priority,
        PFLO_STREAM_DATA * ppStr);


void FLOStreamEndControl(PMG_CLIENT pmgClient, UINT stream);

void FLOPing(PMG_CLIENT pmgClient, UINT stream, UINT curtime);
void FLOPang(PMG_CLIENT pmgClient, UINT stream, UINT userID);
void FLOPong(PMG_CLIENT pmgClient, UINT stream, UINT userID, UINT pongID);


//
// API FUNCTION: FLOAddUser
//
// DESCRIPTION:
//
// Add a user to a flow controlled stream
//
// PARAMETERS:
//
// userID - ID of the new user (single member channel ID)
// pStr - pointer to the stream to receive the new user
//
// RETURNS:
//
// None
//
//
PFLO_USER FLOAddUser(UINT         userID,
                                PFLO_STREAM_DATA pStr);

//
// API FUNCTION: FLO_RemoveUser
//
// DESCRIPTION:
//
// Remove a user from a flow controlled stream
//
// PARAMETERS:
//
// pmg - pointer to the MCS glue user
// userID - ID of the bad user (single member channel ID)
//
// RETURNS:
//
// None
//
//
void FLO_RemoveUser(PMG_CLIENT pmgClient, UINT userID);



//
// FUNCTION: MGCallback
//
// DESCRIPTION:
//
// This function is the callback passed to MCS.  The glue layer receives
// all communication from MCS via this function.  It converts MCS messages
// into DC-Groupware events and posts them to the relevant client(s).
//
//
void CALLBACK MGCallback( unsigned int       mcsMessageType,
                          UINT_PTR      eventData,
                          UINT_PTR      pUser );


#endif // _H_AST120

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\as.h ===
//
// App Sharing Header
//
// <DCS.H> is included BEFORE the other component headers, it has common
//      constants and typedefs.
// <AS.H> is included AFTER the other component headers, it has structure
//      definitions that depend on the structures in the component headers.
//

#ifndef _H_AS
#define _H_AS

class ASHost;
class ASPerson;
class ASView;
class ASShare;



//
// This is the data we keep for when we HOST application.  When not
// hosting, we don't have this data at all.  It's a fair amount of variables,
// hence it's worth allocating/freeing.  And when we support multiple
// simultaneous conferences, won't we be glad we don't have globals to
// remove?
//

class ASHost
{
public:
    STRUCTURE_STAMP

    //
    // Pointer back to share
    //
    ASShare *               m_pShare;

    //
    // Bounds rects
    //
    UINT                    m_baNumRects;
    RECT                    m_abaRects[BA_NUM_RECTS];

    //
    // Active Window Coordinator
    //
    HWND                    m_awcLastActiveWindow;
    UINT                    m_awcLastActiveMsg;

    //
    // Control
    //
    BOOL                    m_caRetrySendState;
    BOOL                    m_caAutoAcceptRequests:1;
    BOOL                    m_caTempRejectRequests:1;

    //
    // Cursor Manager
    //
    BOOL                    m_cmfUseColorCursorProtocol:1;
    BOOL                    m_cmfCursorHidden:1;
    BOOL                    m_cmfSyncPos:1;
    BOOL                    m_cmfCursorTransformApplied:1;
    POINT                   m_cmLastCursorPos;
    CURSORDESCRIPTION       m_cmLastCursorShape;
    UINT                    m_cmNumTxCacheEntries;    // CAN GO AWAY IN 4.0
    PCHCACHE                m_cmTxCacheHandle;

    //
    // Host Tracker
    //
    GUIEFFECTS              m_hetEffects;

    //
    // Order Accumulator
    //
    UINT                    m_oaFlow;

    //
    // OE2 OUTGOING encoding
    //
    PARTYORDERDATA          m_oe2Tx;

    //
    // PM OUTGOING cache, current colors
    //
    BOOL                    m_pmMustSendPalette:1;
    BOOL                    m_pmBuggedDriver:1;
    PALETTEENTRY            m_apmCurrentSystemPaletteEntries[PM_NUM_8BPP_PAL_ENTRIES];
    TSHR_RGBQUAD            m_apmTxPaletteColors[PM_NUM_8BPP_PAL_ENTRIES];
    HPALETTE                m_pmTxPalette;
    UINT                    m_pmNumTxCacheEntries;    // CAN GO AWAY IN 4.0
    PCHCACHE                m_pmTxCacheHandle;
    PCOLORTABLECACHE        m_pmNextTxCacheEntry;
    COLORTABLECACHE         m_apmTxCache[TSHR_PM_CACHE_ENTRIES];
    TSHR_RGBQUAD            m_apmDDGreyRGB[PM_GREY_COUNT];

    //
    // Send bitmap cache
    //
    SBC_ORDER_INFO          m_sbcOrderInfo;
    SBC_TILE_WORK_INFO      m_asbcWorkInfo[SBC_NUM_TILE_SIZES];
    BMC_DIB_CACHE           m_asbcBmpCaches[NUM_BMP_CACHES];
    SBC_SHM_CACHE_INFO      m_asbcCacheInfo[NUM_BMP_CACHES];
    LPSBC_FASTPATH          m_sbcFastPath;


    //
    // Screen data
    //
    RECT                    m_sdgPendingRect;
    BOOL                    m_sdgRectIsPending:1;
    UINT                    m_sdgcLossy;
    RECT                    m_asdgLossyRect[BA_NUM_RECTS];

    //
    // Save bits
    //
    DWORD                   m_ssiSaveBitmapSize;  // Can go away in 4.0

    //
    // Shared window list
    //
    BOOL                    m_swlfForceSend:1;
    BOOL                    m_swlfSyncing:1;
    BOOL                    m_swlfRegionalChanges:1;
    ATOM                    m_swlPropAtom;
    UINT                    m_swlCurrentDesktop;
    char                    m_aswlOurDesktopName[SWL_DESKTOPNAME_MAX];
    UINT                    m_swlCurIndex;
    SWLWINATTRIBUTES        m_aswlFullWinStructs[2*SWL_MAX_WINDOWS];
    SWLWINATTRIBUTES        m_aswlCompactWinStructs[2*SWL_MAX_WINDOWS];
    LPSTR                   m_aswlWinNames[2];
    UINT                    m_aswlWinNamesSize[2];
    UINT                    m_aswlNumFullWins[2];
    UINT                    m_aswlNumCompactWins[2];
    UINT                    m_aswlNRSize[2];
    LPTSHR_UINT16           m_aswlNRInfo[2];

    //
    // Updates
    //
    BOOL                    m_upBackPressure;
    BOOL                    m_upfUseSmallPackets:1;
    BOOL                    m_upfSyncTokenRequired:1;
    DWORD                   m_upLastSDTime;
    DWORD                   m_upLastOrdersTime;
    DWORD                   m_upLastTrialTime;
    DWORD                   m_upDeltaSD;
    DWORD                   m_upSDAccum;
    DWORD                   m_upDeltaOrders;
    DWORD                   m_upOrdersAccum;

    UINT                    m_usrSendingBPP;
    HDC                     m_usrWorkDC;

public:

    //
    // Local host starting
    //
    BOOL                    HET_HostStarting(ASShare *);

    BOOL                    CM_HostStarting(void);
    BOOL                    OE2_HostStarting(void);
    BOOL                    PM_HostStarting(void);
    BOOL                    SBC_HostStarting(void);
    BOOL                    SSI_HostStarting(void);
    BOOL                    SWL_HostStarting(void);
    BOOL                    VIEW_HostStarting(void);
    BOOL                    USR_HostStarting(void);

    //
    // Local host ended
    //
    void                    HET_HostEnded(void);

    void                    CA_HostEnded(void);
    void                    CM_HostEnded(void);
    void                    OE2_HostEnded(void);
    void                    PM_HostEnded(void);
    void                    SBC_HostEnded(void);
    void                    SWL_HostEnded(void);
    void                    USR_HostEnded(void);

    //
    // Syncing, when already hosting and somebody else joins
    //
    void                    HET_SyncCommon(void);

    void                    HET_SyncAlreadyHosting(void);
    void                    CA_SyncAlreadyHosting(void);

    void                    AWC_SyncOutgoing(void);
    void                    BA_SyncOutgoing(void);
    void                    CM_SyncOutgoing(void);
    void                    OA_SyncOutgoing(void);
    void                    OE2_SyncOutgoing(void);
    void                    PM_SyncOutgoing(void);
    void                    SBC_SyncOutgoing(void);
    void                    SSI_SyncOutgoing(void);
    void                    SWL_SyncOutgoing(void);

    //
    // Periodic
    //
    void                    AWC_Periodic(void);
    void                    CA_Periodic(void);
    void                    CM_Periodic(void);
    UINT                    SWL_Periodic(void);
    void                    UP_Periodic(UINT currentTime);


    //
    // Component routines - public
    //

    void                    AWC_ActivateWindow(HWND hwnd);

    void                    BA_AddRect(LPRECT pRect);
    void                    BA_CopyBounds(LPRECT pRects, LPUINT pNumRects, BOOL fReset);
    void                    BA_FetchBounds(void);
    UINT                    BA_QueryAccumulation(void);
    void                    BA_ReturnBounds(void);

    UINT                    CH_CacheData(PCHCACHE  pCache, LPBYTE pData,
                                UINT cbSize, UINT evictionCategory);
    void                    CH_ClearCache(PCHCACHE pCache );
    BOOL                    CH_CreateCache(PCHCACHE * ppCache, UINT cEntries,
                                UINT cEvictionCategories, UINT cbNotHashed,
                                PFNCACHEDEL pfnCacheDel);
    void                    CH_DestroyCache(PCHCACHE hCache);
    void                    CH_RemoveCacheEntry(PCHCACHE pCache, UINT iCacheEntry);
    BOOL                    CH_SearchAndCacheData(PCHCACHE pCache, LPBYTE pData,
                                UINT cbData, UINT evictionCategory, UINT* piEntry);
    BOOL                    CH_SearchCache(PCHCACHE pCache, LPBYTE pData,
                                UINT cbData, UINT evictionCategory, UINT* piEntry);
    void                    CH_TouchCacheEntry(PCHCACHE pCache, UINT iCacheEntry);

    void                    CM_ApplicationMovedCursor(void);
    void                    CM_Controlled(ASPerson * pasControlledBy);
    void                    CM_MaybeSendCursorMovedPacket(void);

    void                    HET_RepaintAll(void);

    void                    OA_FlowControl(UINT newBufferSize);
    LPINT_ORDER             OA_GetFirstListOrder(void);
    UINT                    OA_GetTotalOrderListBytes(void);
    void                    OA_LocalHostReset(void);
    UINT                    OA_QueryOrderAccum(void);
    LPINT_ORDER             OA_RemoveListOrder(LPINT_ORDER pCondemnedOrder);
    void                    OA_ResetOrderList(void);

    BOOL                    OE_RectIntersectsSDA(LPRECT lpRect);

    TSHR_UINT16             OE2_EncodeOrder(LPINT_ORDER pIntOrder,
                                LPVOID pBuffer, TSHR_UINT16 cbBufferSize);
    BOOL                    OE2_UseFont(LPSTR pName, TSHR_UINT16 facelength,
                                TSHR_UINT16 CodePage, TSHR_UINT16 MaxHeight,
                                TSHR_UINT16 Height, TSHR_UINT16 Width,
                                TSHR_UINT16 Weight, TSHR_UINT16 flags);

    void                    PM_AdjustColorsForBuggedDisplayDrivers(LPTSHR_RGBQUAD pColors,
                                UINT cColors);
    BOOL                    PM_CacheTxColorTable(LPUINT pIndex, LPBOOL pNewEntry,
                                UINT cColors, LPTSHR_RGBQUAD pColors);
    HPALETTE                PM_GetLocalPalette(void);
    void                    PM_GetSystemPaletteEntries(LPTSHR_RGBQUAD pColors);
    BOOL                    PM_MaybeSendPalettePacket(void);

    void                    SBC_CacheCleared(void);
    void                    SBC_CacheEntryRemoved(UINT cache, UINT cacheIndex);
    UINT                    SBC_CopyPrivateOrderData(LPBYTE pDst,
                                LPCOM_ORDER pOrder, UINT cbFree);
    void                    SBC_OrderSentNotification(LPINT_ORDER pOrder);
    void                    SBC_PMCacheEntryRemoved(UINT cacheIndex);
    void                    SBC_ProcessInternalOrder(LPINT_ORDER pOrder);
    BOOL                    SBC_ProcessMemBltOrder(LPINT_ORDER pOrder,
                                LPINT_ORDER * ppNextOrder);
    void                    SBC_RecreateSendCache(UINT cache, UINT newEntries,
                                UINT newCellSize);

    void                    SDG_SendScreenDataArea(LPBOOL pBackPressure, UINT * pcPackets);

    HWND                    SWL_GetSharedIDFromLocalID(HWND hwnd);
    UINT_PTR                SWL_GetWindowProperty(HWND hwnd);
    void                    SWL_InitFullWindowListEntry(HWND hwnd, UINT prop,
                                LPSTR * ppNames, PSWLWINATTRIBUTES pFullWinEntry);
    BOOL                    SWL_IsOurDesktopActive(void);
    void                    SWL_UpdateCurrentDesktop(void);

    void                    UP_FlowControl(UINT newSize);
    BOOL                    UP_MaybeSendSyncToken(void);

protected:
    void                    CHAvlBalanceTree(PCHCACHE, PCHENTRY);
    void                    CHAvlDelete(PCHCACHE, PCHENTRY, UINT);
    PCHENTRY                CHAvlFind(PCHCACHE, UINT, UINT);
    PCHENTRY                CHAvlFindEqual(PCHCACHE, PCHENTRY);
    void                    CHAvlInsert(PCHCACHE, PCHENTRY);
    LPBYTE                  CHAvlNext(PCHENTRY);
    LPBYTE                  CHAvlPrev(PCHENTRY);
    void                    CHAvlRebalance(PCHENTRY *);
    void                    CHAvlRotateLeft(PCHENTRY *);
    void                    CHAvlRotateRight(PCHENTRY *);
    void                    CHAvlSwapLeftmost(PCHCACHE, PCHENTRY, PCHENTRY);
    void                    CHAvlSwapRightmost(PCHCACHE, PCHENTRY, PCHENTRY);
    UINT                    CHCheckSum(LPBYTE pData, UINT cbDataSize);
    int                     CHCompare(UINT key, UINT cbSize, PCHENTRY pEntry);
    UINT                    CHEvictCacheEntry(PCHCACHE pCache, UINT iEntry, UINT evictionCategory);
    UINT                    CHEvictLRUCacheEntry(PCHCACHE pCache, UINT evictionCategory, UINT evictionCount);
    BOOL                    CHFindFreeCacheEntry(PCHCACHE pCache, UINT* piEntry, UINT* pEvictionCount);
    void                    CHInitEntry(PCHENTRY);
    void                    CHRemoveEntry(PCHCACHE pCache, UINT iCacheEntry);
    UINT                    CHTreeSearch(PCHCACHE pCache, UINT checksum, UINT cbDataSize, LPBYTE pData);
    void                    CHUpdateMRUList(PCHCACHE pCache, UINT iEntry, UINT evictionCategory);

    BOOL                    CMGetColorCursorDetails( LPCM_SHAPE pCursor,
                                LPTSHR_UINT16 pcxWidth, LPTSHR_UINT16 pcyHeight,
                                LPTSHR_UINT16 pxHotSpot, LPTSHR_UINT16 pyHotSpot,
                                LPBYTE pANDMask, LPTSHR_UINT16 pcbANDMask,
                                LPBYTE pXORBitmap, LPTSHR_UINT16 pcbXORBitmap );
    BOOL                    CMGetCursorTagInfo(LPCSTR szTagName);
    void                    CMRemoveCursorTransform(void);
    BOOL                    CMSetCursorTransform(LPBYTE pANDMask, LPBITMAPINFO pXORDIB);
    BOOL                    CMSendBitmapCursor(void);
    BOOL                    CMSendCachedCursor(UINT iCacheEntry);
    BOOL                    CMSendColorBitmapCursor(LPCM_SHAPE pCursor,
                                UINT iCacheEntry);
    BOOL                    CMSendCursorShape(LPCM_SHAPE lpCursorShape,
                                UINT cbCursorDataSize);
    BOOL                    CMSendMonoBitmapCursor(LPCM_SHAPE pCursor);
    BOOL                    CMSendSystemCursor(UINT cursorIDC);

    void                    OAFreeAllOrders(LPOA_SHARED_DATA);

    void                    OE2EncodeBounds(LPBYTE * ppNextFreeSpace,
                                LPTSHR_RECT16 pRect);

    void                    PMGetGrays(void);
    BOOL                    PMSendPalettePacket(LPTSHR_RGBQUAD  pColorTable,
                                UINT numColors);
    BOOL                    PMUpdateSystemPaletteColors(void);
    BOOL                    PMUpdateTxPaletteColors(void);

    void                    SBCAddToFastPath(UINT_PTR majorInfo, UINT minorInfo,
                                UINT_PTR majorPalette, UINT minorPalette, int srcX,
                                int srcY, UINT width, UINT height, UINT cache,
                                UINT cacheIndex, UINT colorCacheIndex);
    BOOL                    SBCCacheBits(LPINT_ORDER pOrder, UINT cbDst,
                                LPBYTE pDIBits, UINT bitmapWidth,
                                UINT fixedBitmapWidth, UINT bitmapHeight,
                                UINT numBytes, UINT * pCache, UINT * pCacheIndex,
                                LPBOOL pIsNewEntry);
    BOOL                    SBCCacheColorTable(LPINT_ORDER pColorTableOrder,
                                LPTSHR_RGBQUAD pColorTable, UINT numColors,
                                UINT * pCacheIndex, LPBOOL pIsNewEntry);
    BOOL                    SBCFindInFastPath(UINT_PTR majorInfo, UINT minorInfo,
                                UINT_PTR majorPalette, UINT minorPalette, int srcX,
                                int srcY, UINT width, UINT height, UINT * pCache,
                                UINT * pCacheIndex, UINT * pColorCacheIndex);
    void                    SBCFreeInternalOrders(void);
    BOOL                    SBCGetTileData(UINT tileId, LPSBC_TILE_DATA * ppTileData,
                                UINT * pTileType);
    void                    SBCInitCacheStructures(void);
    BOOL                    SBCInitFastPath(void);
    BOOL                    SBCInitInternalOrders(void);
    BOOL                    SBCSelectCache(UINT bitsSize, UINT * pCacheIndex);

    BOOL                    SDGSmallBltToNetwork(LPRECT pRect);
    BOOL                    SDGSplitBltToNetwork(LPRECT pRect, UINT * pcPacket);

    void                    SWLAddHostWindowTitle(HWND, UINT, HWND, LPSTR *);
    void                    SWLAdjustZOrderForTransparency(PSWLWINATTRIBUTES pTrans,
                                PSWLWINATTRIBUTES pLast, UINT pos, LPSTR pWinNames,
                                UINT sizeWinNames);
    UINT                    SWLCompactWindowList(UINT, PSWLWINATTRIBUTES, PSWLWINATTRIBUTES);
    void                    SWLInitHostFullWinListEntry(HWND hwnd, UINT prop,
                                HWND hwndOwner, PSWLWINATTRIBUTES pFullWinEntry);
    BOOL                    SWLSendPacket(PSWLWINATTRIBUTES pWindows,
                                UINT numWindows, LPSTR pTitles, UINT lenTitles,
                               UINT NRInfoSize, LPTSHR_UINT16 pNRInfo);
    BOOL                    SWLWindowIsOnTaskBar(HWND hwnd);
    BOOL                    SWLWindowIsTaggable(HWND hwnd);

    UINT                    UPFetchOrdersIntoBuffer(LPBYTE pBuffer,
                                LPTSHR_UINT16 pcOrders, LPUINT pcbBufferSize);
    BOOL                    UPSendOrders(UINT *);
    UINT                    UPSendUpdates(void);

};


void PMCacheCallback(ASHost* pHost, PCHCACHE pCache, UINT iEntry, LPBYTE pData);
void SBCCacheCallback(ASHost* pHost, PCHCACHE pCache, UINT iEntry, LPBYTE pData);




//
// This is the per-person data we keep to VIEW a host.  When this person
// starts to host, we allocate this structure, and then subblocks as
// necessary like caches.  When this person stops hosting, we free it
// after freeing the objects contained within.
//
// NOTE that for some whacky 2.x compatibility, some things that should
// be in the ASView structure are actually kept in ASPerson because
// the information contained within has to stay around when that person
// isn't hosting.  With 3.0 hosts that's not the case.  So when 2.x
// compatibility goes away, move OD2 PM RBC fields here also.
//

class ASView
{
public:
    STRUCTURE_STAMP

    // DS vars
    // For NM 2.x machines only, the offset if their desktop is scrolled over
    POINT                   m_dsScreenOrigin;

    // OD vars, for playback of orders from this remote host
    HRGN                    m_odInvalRgnOrder;
    HRGN                    m_odInvalRgnTotal;
    UINT                    m_odInvalTotal;

    COLORREF                m_odLastBkColor;
    COLORREF                m_odLastTextColor;
    int                     m_odLastBkMode;
    int                     m_odLastROP2;
    UINT                    m_odLastFillMode;
    UINT                    m_odLastArcDirection;
    UINT                    m_odLastPenStyle;
    UINT                    m_odLastPenWidth;
    COLORREF                m_odLastPenColor;
    COLORREF                m_odLastForeColor;
    int                     m_odLastBrushOrgX;
    int                     m_odLastBrushOrgY;
    COLORREF                m_odLastBrushBkColor;
    COLORREF                m_odLastBrushTextColor;
    HBITMAP                 m_odLastBrushPattern;
    UINT                    m_odLastLogBrushStyle;
    UINT                    m_odLastLogBrushHatch;
    TSHR_COLOR              m_odLastLogBrushColor;
    BYTE                    m_odLastLogBrushExtra[7];
    int                     m_odLastCharExtra;
    int                     m_odLastJustExtra;
    int                     m_odLastJustCount;
    HFONT                   m_odLastFontID;
    UINT                    m_odLastFontCodePage;
    UINT                    m_odLastFontWidth;
    UINT                    m_odLastFontHeight;
    UINT                    m_odLastFontWeight;
    UINT                    m_odLastFontFlags;
    UINT                    m_odLastFontFaceLen;
    BYTE                    m_odLastFaceName[FH_FACESIZE];
    UINT                    m_odLastBaselineOffset;
    COLORREF                m_odLastVGAColor[OD_NUM_COLORS];
    TSHR_COLOR              m_odLastVGAResult[OD_NUM_COLORS];
    BOOL                    m_odRectReset;
    int                     m_odLastLeft;
    int                     m_odLastTop;
    int                     m_odLastRight;
    int                     m_odLastBottom;

    // SSI vars
    HDC                     m_ssiDC;
    HBITMAP                 m_ssiBitmap;              // Bitmap handle
    HBITMAP                 m_ssiOldBitmap;
    int                     m_ssiBitmapHeight;

    // SWL vars
    int                     m_swlCount;
    SWLWINATTRIBUTES        m_aswlLast[SWL_MAX_WINDOWS];

    // USR vars
    HDC                     m_usrDC;
    HDC                     m_usrWorkDC;
    HBITMAP                 m_usrBitmap;
    HBITMAP                 m_usrOldBitmap;

    // VIEW vars
    HWND                    m_viewFrame;                // Frame
    HWND                    m_viewClient;               // Host view
    HWND                    m_viewStatusBar;            // Status bar
    UINT                    m_viewStatus;               // Current status
    HMENU                   m_viewMenuBar;              // Menu bar
    RECT                    m_viewSavedWindowRect;      // When full screen, old pos
    HWND                    m_viewInformDlg;            // Notification message up
    UINT                    m_viewInformMsg;            // Informational message

    BOOL                    m_viewFocus:1;              // Key strokes are going to this
    BOOL                    m_viewInMenuMode:1;         // In menu mode
    BOOL                    m_viewFullScreen:1;         // Full screen UI
    BOOL                    m_viewWindowBarOn:1;
    BOOL                    m_viewStatusBarOn:1;
    BOOL                    m_viewSavedWindowBarOn:1;
    BOOL                    m_viewSavedStatusBarOn:1;
    BOOL                    m_viewFullScreenExitTrack:1;
    BOOL                    m_viewFullScreenExitMove:1;

    POINT                   m_viewSavedPos;
    POINT                   m_viewFullScreenExitStart;

    HWND                    m_viewWindowBar;            // App window bar
    BASEDLIST               m_viewWindowBarItems;       // Items in window bar
    PWNDBAR_ITEM            m_viewWindowBarActiveItem;  // Current item
    int                     m_viewWindowBarItemFirst;   // Index of 1st visible item
    int                     m_viewWindowBarItemFitCount;    // # of items that fit
    int                     m_viewWindowBarItemCount;   // # of items total

    UINT                    m_viewMouseFlags;           // For capture
    POINT                   m_viewMouse;                // Mouse pos
    BOOL                    m_viewMouseOutside;         // Mouse is down, outside client
    int                     m_viewMouseWheelDelta;      // Intellimouse wheel insanity

    //
    // These are kept always in the view's client coords.  When the view
    // scrolls over, the shared and obscured regions are adjusted too.
    // When a new SWL packet for the host comes in, these regions are
    // saved accounting for scrolling too.
    //
    HRGN                    m_viewSharedRgn;           // Shared area, not obscured
    HRGN                    m_viewObscuredRgn;         // Shared area, obscured
    HRGN                    m_viewExtentRgn;
    HRGN                    m_viewScreenRgn;
    HRGN                    m_viewPaintRgn;
    HRGN                    m_viewScratchRgn;

    POINT                   m_viewPos;                 // View scroll pos
    POINT                   m_viewPage;                // View page size
    POINT                   m_viewPgSize;              // Page scroll inc
    POINT                   m_viewLnSize;              // Line scroll inc
};




//
// This is the per-person data we keep for each person in a conference.
// We dynamically allocate everybody but ourself (the local dude).
//


class ASPerson
{
public:
    STRUCTURE_STAMP

    ASPerson *              pasNext;

    // VIEW vars (allocated when this person is hosting that we use to VIEW them)
    ASView *                m_pView;

    // SC vars
    UINT_PTR                    mcsID;                      // MCS user_id
    char                    scName[TSHR_MAX_PERSON_NAME_LEN];  // Name
    BYTE                    scSyncSendStatus[SC_STREAM_COUNT];
    BYTE                    scSyncRecStatus[SC_STREAM_COUNT];

    //
    // AWC vars
    // When 2.x compat goes away, move these to AS_VIEW
    //
    UINT_PTR             awcActiveWinID;

    // CA vars
    BOOL                    m_caAllowControl;
    BOOL                    m_caControlPaused;      // ONLY HOST CONTROLLED BY US or US PAUSED
    UINT                    m_caControlID;          // ONLY NODE WE ARE CONTROLLING/CONTROLLED BY
    ASPerson *              m_caControlledBy;
    ASPerson *              m_caInControlOf;
    BOOL                    m_ca2xCooperating;

    //
    // CM vars
    // When 2.x compat goes away, move most of these to AS_VIEW
    //
    POINT                   cmPos;              // Position of the remote cursor, in his screen coords
    POINT                   cmHotSpot;          // The remote cursor hotspot
    BOOL                    cmShadowOff;
    HCURSOR                 cmhRemoteCursor;
    UINT                    ccmRxCache;         // # of entries in cache
    PCACHEDCURSOR           acmRxCache;         // Cached cursor array

    // CPC vars
    CPCALLCAPS              cpcCaps;

    // DCS vars
    PGDC_DICTIONARY         adcsDict;                   // POINTER

    // HET vars
    int                     hetCount;

    // OE vars
    UINT                    oecFonts;
    POEREMOTEFONT           poeFontInfo;

    //
    // NOTE:
    // These are here and not in the HOST data for 2.x compat.  2.x systems
    // don't reset outgoing info if they stay in a share while stopping/
    // restarting hosting.  3.0 systems do (look in HET_HostStarting()).
    // So we must keep the old gunky cache/decode data around for backlevel
    // systems.  Therefore we allocate it dynamically still.
    //

    // OD2 vars
    PPARTYORDERDATA         od2Party;

    // PM vars
    HPALETTE                pmPalette;
    UINT                    pmcColorTable;
    PCOLORTABLECACHE        apmColorTable;

    // RBC vars
    PRBC_HOST_INFO          prbcHost;

    // VIEW vars
    // NOTE: because of bugs in 2.x VD calcs, this is kept around while
    // the person is in the share, whether they are hosting or not.
    POINT                   viewExtent;              // View extent (may be > usrScreenSize for 2.x dudes)
};



//
// Allocated when in a share
//

class ASShare
{
public:
    STRUCTURE_STAMP

    ASHost *                m_pHost;
    ASPerson *              m_pasLocal;    // People list, starting with local person

    //
    // Bitmap Compressor/Decompressor
    //
    MATCH *                 m_amatch;
    LPBYTE                  m_abNormal;
    LPBYTE                  m_abXor;

    //
    // Control Arbitrator
    //
    char                    m_caToggle;
    char                    m_caPad1;
    short                   m_caPad2;
    BASEDLIST               m_caQueuedMsgs;
    ASPerson *              m_caWaitingForReplyFrom;
    UINT                    m_caWaitingForReplyMsg;

    HWND                    m_caQueryDlg;
    CA30PENDING             m_caQuery;

    ASPerson *              m_ca2xControlTokenOwner;    // Person owning control token
    UINT_PTR                m_ca2xControlGeneration;

    //
    // Cursor
    //
    UINT                    m_cmCursorWidth;
    UINT                    m_cmCursorHeight;
    HCURSOR                 m_cmArrowCursor;
    POINT                   m_cmArrowCursorHotSpot;
    HBRUSH                  m_cmHatchBrush;
    HFONT                   m_cmCursorTagFont;

    DWORD                   m_dcsLastScheduleTime;
    DWORD                   m_dcsLastFastMiscTime;
    DWORD                   m_dcsLastIMTime;
    UINT                    m_dcsCompressionLevel;
    UINT                    m_dcsCompressionSupport;
    BOOL                    m_dcsLargePacketCompressionOnly;

    //
    // PKZIP
    //
    BYTE                    m_agdcWorkBuf[GDC_WORKBUF_SIZE];

    //
    // Fonts
    //
    BOOL                    m_fhLocalInfoSent;

    //
    // Hosting
    //
    UINT                    m_hetHostCount;
    BOOL                    m_hetRetrySendState;
    BOOL                    m_hetViewers;

    //
    // Input Manager
    //

    // GLOBAL (or costly to calc/load and undo repeatedly)
    WORD                    m_imScanVKLShift;
    WORD                    m_imScanVKRShift;
    HINSTANCE               m_imImmLib;
    IMMGVK                  m_imImmGVK;

    // IN CONTROL
    BOOL                    m_imfInControlEventIsPending:1;
    BOOL                    m_imfInControlCtrlDown:1;
    BOOL                    m_imfInControlShiftDown:1;
    BOOL                    m_imfInControlMenuDown:1;
    BOOL                    m_imfInControlCapsLock:1;
    BOOL                    m_imfInControlNumLock:1;
    BOOL                    m_imfInControlScrollLock:1;
    BOOL                    m_imfInControlConsumeMenuUp:1;
    BOOL                    m_imfInControlConsumeEscapeUp:1;
    BOOL                    m_imfInControlNewEvent:1;

    IMEVENT                 m_imInControlPendingEvent;
    IMEVENTQ                m_imInControlEventQ;
    BYTE                    m_aimInControlKeyStates[256];
    int                     m_imInControlMouseDownCount;
    DWORD                   m_imInControlMouseDownTime;
    UINT                    m_imInControlMouseWithhold;
    DWORD                   m_imInControlMouseSpoilRate;
    UINT                    m_imInControlNumEventsPending;
    UINT                    m_imInControlNumEventsReturned;
    UINT                    m_aimInControlEventsToReturn[15];
    UINT                    m_imInControlNextHotKeyEntry;
    BYTE                    m_aimInControlHotKeyArray[4];
    UINT                    m_imInControlNumDeadKeysDown;
    UINT                    m_imInControlNumDeadKeys;
    BYTE                    m_aimInControlDeadKeys[IM_MAX_DEAD_KEYS];

    // CONTROLLED (only when hosting!)
    BOOL                    m_imfControlledMouseButtonsReversed:1;
    BOOL                    m_imfControlledMouseClipped:1;
    BOOL                    m_imfControlledPaceInjection:1;
    BOOL                    m_imfControlledNewEvent:1;
    UINT                    m_imControlledNumEventsPending;
    UINT                    m_imControlledNumEventsReturned;
    UINT                    m_aimControlledEventsToReturn[15];
    UINT                    m_imControlledVKToReplay;
    IMEVENTQ                m_imControlledEventQ;
    IMOSQ                   m_imControlledOSQ;
    BYTE                    m_aimControlledControllerKeyStates[256];
    BYTE                    m_aimControlledKeyStates[256];
    BYTE                    m_aimControlledSavedKeyStates[256];
    DWORD                   m_imControlledLastLowLevelMouseEventTime;
    DWORD                   m_imControlledLastMouseRemoteTime;
    DWORD                   m_imControlledLastMouseLocalTime;
    DWORD                   m_imControlledLastIncompleteConversion;
    DWORD                   m_imControlledMouseBacklog;
    POINT                   m_imControlledLastMousePos;

    //
    // Order Encoder
    //
    BOOL                    m_oefSendOrders:1;
    BOOL                    m_oefTextEnabled:1;
    BOOL                    m_oefOE2EncodingOn:1;
    BOOL                    m_oefOE2Negotiable:1;
    BOOL                    m_oefBaseOE:1;
    BOOL                    m_oefAlignedOE:1;
    BYTE                    m_aoeOrderSupported[ORD_NUM_INTERNAL_ORDERS];
    PROTCAPS_ORDERS         m_oeCombinedOrderCaps;
    UINT                    m_oeOE2Flag;

    //
    // Share Controller
    //
    BOOL                    m_scfViewSelf:1;
#ifdef _DEBUG
    BOOL                    m_scfInSync:1;
#endif // _DEBUG
    UINT                    m_scShareVersion;
    int                     m_ascSynced[SC_STREAM_COUNT];
    LPBYTE                  m_ascTmpBuffer;

    TSHR_UINT16             m_swlLastTokenSeen;
    WORD                    m_swlPad;

    POINT                   m_viewVDSize;
    int                     m_viewEdgeCX;
    int                     m_viewEdgeCY;
    HBRUSH                  m_viewObscuredBrush;
    HICON                   m_viewFullScreenExitIcon;
    int                     m_viewFullScreenCX;
    int                     m_viewFullScreenCY;
    int                     m_viewItemCX;
    int                     m_viewItemCY;
    int                     m_viewItemScrollCX;
    int                     m_viewItemScrollCY;
    int                     m_viewStatusBarCY;
    int                     m_viewWindowBarCY;
    HCURSOR                 m_viewNotInControl;
    UINT                    m_viewMouseWheelScrollLines;

    HBITMAP                 m_usrBmp16;
    HBITMAP                 m_usrBmp32;
    HBITMAP                 m_usrBmp48;
    HBITMAP                 m_usrBmp64;
    HBITMAP                 m_usrBmp80;
    HBITMAP                 m_usrBmp96;
    HBITMAP                 m_usrBmp112;
    HBITMAP                 m_usrBmp128;
    HBITMAP                 m_usrBmp256;
    HBITMAP                 m_usrBmp1024;
    LPBYTE                  m_usrPBitmapBuffer;
    BOOL                    m_usrHatchBitmaps;
    BOOL                    m_usrHatchScreenData;
    int                     m_usrHatchColor;

public:
#ifdef _DEBUG
    void                ValidatePerson(ASPerson * pasPerson);
    void                ValidateView(ASPerson * pasPerson);
#else
    __inline void       ValidatePerson(ASPerson * pasPerson) {}
    __inline void       ValidateView(ASPerson * pasPerson) {}
#endif // _DEBUG


    //
    // Share init
    //
    BOOL                SC_ShareStarting(void);

    BOOL                BCD_ShareStarting(void);
    BOOL                CM_ShareStarting(void);
    BOOL                IM_ShareStarting(void);
    BOOL                VIEW_ShareStarting(void);
    BOOL                USR_ShareStarting(void);

    //
    // Share term
    //
    void                SC_ShareEnded(void);

    void                BCD_ShareEnded(void);
    void                CM_ShareEnded(void);
    void                IM_ShareEnded(void);
    void                VIEW_ShareEnded(void);
    void                USR_ShareEnded(void);

    //
    // Member joining share
    //
    BOOL                SC_PartyAdded(UINT mcsID, LPSTR szName, UINT cbCaps, LPVOID pCaps);
    ASPerson *          SC_PartyJoiningShare(UINT mcsID, LPSTR szName, UINT cbCaps, LPVOID pCaps);
    BOOL                CM_PartyJoiningShare(ASPerson * pasPerson);
    BOOL                CPC_PartyJoiningShare(ASPerson * pasPerson, UINT cbCaps, void* pCapsData);
    BOOL                DCS_PartyJoiningShare(ASPerson * pasPerson);
    BOOL                HET_PartyJoiningShare(ASPerson * pasPerson);

    //
    // Member leaving share
    //
    void                SC_PartyDeleted(UINT_PTR mcsID);
    void                SC_PartyLeftShare(UINT_PTR mcsID);
    void                CA_PartyLeftShare(ASPerson * pasPerson);
    void                CM_PartyLeftShare(ASPerson * pasPerson);
    void                DCS_PartyLeftShare(ASPerson * pasPerson);
    void                HET_PartyLeftShare(ASPerson * pasPerson);
    void                OD2_PartyLeftShare(ASPerson * pasPerson);
    void                OE_PartyLeftShare(ASPerson * pasPerson);
    void                PM_PartyLeftShare(ASPerson * pasPerson);
    void                RBC_PartyLeftShare(ASPerson * pasPerson);
    void                SWL_PartyLeftShare(ASPerson * pasPerson);
    void                VIEW_PartyLeftShare(ASPerson * pasPerson);


    //
    // Recalc caps after somebody joined or left
    //
    void                SC_RecalcCaps(BOOL fJoiner);

    void                CM_RecalcCaps(BOOL fJoiner);
    void                DCS_RecalcCaps(BOOL fJoiner);
    void                OE_RecalcCaps(BOOL fJoiner);
    void                PM_RecalcCaps(BOOL fJoiner);
    void                SBC_RecalcCaps(BOOL fJoiner);
    void                SSI_RecalcCaps(BOOL fJoiner);
    void                USR_RecalcCaps(BOOL fJoiner);


    //
    // Syncing due to new member joined or reset
    //
    void                DCS_SyncOutgoing(void);
    void                IM_SyncOutgoing(void);
    void                OD2_SyncIncoming(ASPerson * pasPerson);
    void                OE_SyncOutgoing(void);


    //
    // Starting host view
    //
    BOOL                HET_ViewStarting(ASPerson * pasPerson);

    BOOL                CA_ViewStarting(ASPerson * pasPerson);
    BOOL                CM_ViewStarting(ASPerson * pasPerson);
    BOOL                OD_ViewStarting(ASPerson * pasPerson);
    BOOL                OD2_ViewStarting(ASPerson * pasPerson);
    BOOL                PM_ViewStarting(ASPerson * pasPErson);
    BOOL                RBC_ViewStarting(ASPerson * pasPerson);
    BOOL                SSI_ViewStarting(ASPerson * pasPerson);
    BOOL                VIEW_ViewStarting(ASPerson * pasPerson);
    BOOL                USR_ViewStarting(ASPerson * pasPerson);


    //
    // Stopped host view
    //
    void                HET_ViewEnded(ASPerson * pasPerson);

    void                CA_ViewEnded(ASPerson * pasPerson);
    void                CM_ViewEnded(ASPerson * pasPerson);
    void                OD_ViewEnded(ASPerson * pasPerson);
    void                OD2_ViewEnded(ASPerson * pasPerson);
    void                PM_ViewEnded(ASPerson * pasPerson);
    void                RBC_ViewEnded(ASPerson * pasPerson);
    void                SSI_ViewEnded(ASPerson * pasPerson);
    void                VIEW_ViewEnded(ASPerson * pasPerson);
    void                USR_ViewEnded(ASPerson * pasPerson);

    //
    // Periodic processing when in share, mostly for when hosting
    //
    void                SC_Periodic(void);

    void                CA_Periodic(void);
    void                HET_Periodic(void);
    void                IM_Periodic(void);
    void                OE_Periodic(void);

    //
    // Incoming packet handling
    //
    void                SC_ReceivedPacket(PS20DATAPACKET pPacket);
    void                AWC_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CA_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CA30_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CM_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CPC_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                FH_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                HET_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                PM_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                OD_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                SDP_ReceivedPacket(ASPerson * pasPerson, PS20DATAPACKET pPacket);
    void                SWL_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                UP_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);

    //
    // Random component routines
    //
    BOOL                AWC_SendMsg(UINT_PTR userTo, UINT msg, UINT_PTR data1, UINT_PTR data2);

    BOOL                BC_CompressBitmap( LPBYTE  pSrcBitmap,
                                LPBYTE  pDstBuffer,
                                LPUINT   pDstBufferSize,
                                UINT    bitmapWidth,
                                UINT    bitmapHeight,
                                UINT    bitmapBitsPerPel,
                                LPBOOL   pLossy);
    BOOL                BD_DecompressBitmap( LPBYTE  pCompressedData,
                                  LPBYTE  pDstBitmap,
                                  UINT    srcDataSize,
                                  UINT    bitmapWidth,
                                  UINT    bitmapHeight,
                                  UINT    bitmapBitsPerPel );

    void                CA_TakeControl(ASPerson * pasHost);
    void                CA_CancelTakeControl(ASPerson * pasHost, BOOL fPacket);
    void                CA_ReleaseControl(ASPerson * pasFrom, BOOL fPacket);
    void                CA_PassControl(ASPerson * pasHost, ASPerson * pasViewer);

    void                CA_AllowControl(BOOL fAllow);
    void                CA_GiveControl(ASPerson * pasInvite);
    void                CA_CancelGiveControl(ASPerson * pasViewer, BOOL fPacket);
    void                CA_RevokeControl(ASPerson * pasController, BOOL fPacket);
    void                CA_PauseControl(ASPerson * pasController,  BOOL fPause, BOOL fPacket);

    void                CA_ClearLocalState(UINT clearFlags, ASPerson * pasRemote, BOOL fPacket);
    BOOL                CA_QueryDlgProc(HWND, UINT, WPARAM, LPARAM);

    void                CM_DrawShadowCursor(ASPerson * pasPerson, HDC hdc );
    void                CM_UpdateShadowCursor(ASPerson * pasPerson, BOOL fOff,
                                int xPosNew, int yPosNew, int xHotNew, int yHotNew);

    void                CPC_UpdatedCaps(PPROTCAPS pCaps);

#ifdef _DEBUG
    UINT                DCS_CompressAndSendPacket(UINT streamID, UINT_PTR nodeID, PS20DATAPACKET pPacket, UINT packetLength);
#else
    void                DCS_CompressAndSendPacket(UINT streamID, UINT_PTR nodeID, PS20DATAPACKET pPacket, UINT packetLength);
#endif // _DEBUG
    void                DCS_FlowControl(UINT newBufferSize);

    void                DCS_TakeControl(UINT gccOf);
    void                DCS_CancelTakeControl(UINT gccOf);
    void                DCS_ReleaseControl(UINT gccOf);
    void                DCS_PassControl(UINT gccOf, UINT gccTo);
    void                DCS_GiveControl(UINT gccTo);
    void                DCS_CancelGiveControl(UINT gccTo);
    void                DCS_RevokeControl(UINT gccTo);
    void                DCS_PauseControl(UINT gccTo, BOOL fPause);

    void                FH_ConvertAnyFontIDToLocal(LPCOM_ORDER pOrder, ASPerson * pasPerson);
    void                FH_DetermineFontSupport(void);
    void                FH_SendLocalFontInfo(void);

    void                HET_CalcViewers(ASPerson * pasLeaving);
    void                HET_HandleNewTopLevel(BOOL fShowing);
    void                HET_HandleRecountTopLevel(UINT newCount);
    void                HET_ShareApp(WPARAM, LPARAM);
    void                HET_ShareDesktop(void);
    void                HET_UnshareAll(void);
    void                HET_UnshareApp(WPARAM, LPARAM);
    BOOL                HET_WindowIsHosted(HWND winid);

    BOOL                IM_Controlled(ASPerson * pasControlledBy);
    void                IM_InControl(ASPerson * pasInControlOf);
    void                IM_OutgoingKeyboardInput(ASPerson * pasHost,
                            UINT vkCode, UINT keyData);
    void                IM_OutgoingMouseInput(ASPerson * pasHost,
                            LPPOINT pMousePos, UINT message, UINT extra);
    void                IM_ReceivedPacket(ASPerson * pasPerson, PS20DATAPACKET pPacket);
    void                IM_SyncOutgoingKeyboard(void);

    void                OD_ReplayOrder(ASPerson * pasFrom, LPCOM_ORDER pOrder, BOOL fPalRGB);
    void                OD_ResetRectRegion(ASPerson * pasPerson);
    void                OD_UpdateView(ASPerson * pasHost);

    void                OD2_CalculateBounds(LPCOM_ORDER pOrder, LPRECT pRect,
                                BOOL fDecoding, ASPerson * pasPerson);
    void                OD2_CalculateTextOutBounds(LPTEXTOUT_ORDER pTextOut,
                                LPRECT pRect, BOOL fDecoding, ASPerson * pasPerson);
    LPCOM_ORDER         OD2_DecodeOrder(void * pEOrder, LPUINT LengthDecoded,
                            ASPerson * pasPerson);

    void                OE_EnableText(BOOL enable);
    BOOL                OE_SendAsOrder(DWORD order);

    BOOL                PM_CacheRxColorTable(ASPerson *  pasPerson,
                                UINT index, UINT cColors, LPTSHR_RGBQUAD pColors);
    BOOL                PM_CreatePalette(UINT cEntries, LPTSHR_COLOR pNewEntries,
                            HPALETTE* phPal );
    void                PM_DeletePalette(HPALETTE palette);
    void                PM_GetColorTable(ASPerson * pasPerson, UINT index,
                                UINT * pcColors, LPTSHR_RGBQUAD pColors);

    HBITMAP             RBC_MapCacheIDToBitmapHandle(ASPerson * pasPerson,
                                UINT cacheIndex, UINT entry, UINT colorTable);
    void                RBC_ProcessCacheOrder(ASPerson * pasPerson, LPCOM_ORDER_UA pOrder);

    PS20DATAPACKET      SC_AllocPkt(UINT streamID, UINT_PTR nodeID, UINT_PTR len);
    ASPerson *          SC_PersonAllocate(UINT mcsID, LPSTR szName);
    ASPerson *          SC_PersonFromNetID(UINT_PTR mcsID);
    ASPerson *          SC_PersonFromGccID(UINT gccID);
    void                SC_PersonFree(ASPerson * pasFree);
    BOOL                SC_ValidateNetID(UINT_PTR mcsID, ASPerson** pLocal);

    void                SDP_DrawHatchedRect( HDC surface, int x, int y, int width, int height, UINT color);

    void                SSI_SaveBitmap(ASPerson * pasPerson, LPSAVEBITMAP_ORDER pSaveBitmap);

    TSHR_UINT16         SWL_CalculateNextToken(TSHR_UINT16 curToken);

    BOOL                VIEW_DlgProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT             VIEW_FrameWindowProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT             VIEW_FullScreenExitProc(HWND, UINT, WPARAM, LPARAM);
    void                VIEW_HostStateChange(ASPerson * pasHost);
    void                VIEW_InControl(ASPerson * pasRemote, BOOL fStart);
    void                VIEW_InvalidateRect(ASPerson * pasHost, LPRECT lprc);
    void                VIEW_InvalidateRgn(ASPerson * pasHost, HRGN rgnUpdated);
    BOOL                VIEW_IsPointShared(ASPerson * pasHost, POINT pt);
    void                VIEW_Message(ASPerson * pasHost, UINT ids);
    void                VIEW_PausedInControl(ASPerson * pasRemote, BOOL fPaused);
    void                VIEW_RecalcExtent(ASPerson * pasHost);
    void                VIEW_RecalcVD(void);
    void                VIEW_ScreenChanged(ASPerson * pasPerson);
    void                VIEW_SetHostRegions(ASPerson * pasHost, HRGN rgnShared, HRGN rgnObscured);
    void                VIEW_SyncCursorPos(ASPerson * pasHost, int x, int y);
    void                VIEW_UpdateStatus(ASPerson * pasHost, UINT idsStatus);
    LRESULT             VIEW_ViewWindowProc(HWND, UINT, WPARAM, LPARAM);


    void                VIEW_WindowBarChangedActiveWindow(ASPerson * pasHost);
    void                VIEW_WindowBarEndUpdateItems(ASPerson * pasHost, BOOL fAnyChanges);
    LRESULT             VIEW_WindowBarItemsProc(HWND, UINT, WPARAM, LPARAM);
    BOOL                VIEW_WindowBarUpdateItem(ASPerson * pasHost, PSWLWINATTRIBUTES pWinNew, LPSTR pText);
    LRESULT             VIEW_WindowBarProc(HWND, UINT, WPARAM, LPARAM);

    void                USR_InitDIBitmapHeader(BITMAPINFOHEADER * pbh, UINT bpp);
    void                USR_ScreenChanged(ASPerson * pasPerson);
    void                USR_ScrollDesktop(ASPerson * pasPerson, int xNew, int yNew);
    BOOL                USR_UseFont(HDC hdc, HFONT* pHFONT,
                            LPTEXTMETRIC pMetrics, LPSTR pName, UINT charSet,
                            UINT maxHeight, UINT height, UINT width,
                            UINT weight, UINT flags);


protected:
    void                CAClearRemoteState(ASPerson * pasClear);
    BOOL                CAClearHostState(ASPerson * pasHost, ASPerson * pasController);
    void                CAStartWaiting(ASPerson * pasWait, UINT msgWait);

    BOOL                CAStartQuery(ASPerson * pasFrom, UINT msg, PCA30P pReq);
    void                CAFinishQuery(UINT result);
    void                CACancelQuery(ASPerson * pasFrom, BOOL fPacket);

    void                CAHandleRequestTakeControl(ASPerson * pasViewer, PCA_RTC_PACKET pPacket);
    void                CACompleteRequestTakeControl(ASPerson * pasFrom, PCA_RTC_PACKET pPacket, UINT result);
    void                CAHandleReplyRequestTakeControl(ASPerson * pasHost, PCA_REPLY_RTC_PACKET pPacket);

    void                CAHandleRequestGiveControl(ASPerson * pasHost, PCA_RGC_PACKET pPacket);
    void                CACompleteRequestGiveControl(ASPerson * pasFrom, PCA_RGC_PACKET pPacket, UINT result);
    void                CAHandleReplyRequestGiveControl(ASPerson * pasViewer, PCA_REPLY_RGC_PACKET pPacket);

    void                CAHandlePreferPassControl(ASPerson * pasController, PCA_PPC_PACKET pPacket);
    void                CACompletePreferPassControl(ASPerson * pasViewer, UINT_PTR mcsOrg, PCA_PPC_PACKET pPacket, UINT result);

    void                CAHandleInformReleasedControl(ASPerson * pasController, PCA_INFORM_PACKET pPacket);
    void                CAHandleInformRevokedControl(ASPerson * pasHost, PCA_INFORM_PACKET pPacket);
    void                CAHandleInformPausedControl(ASPerson * pasHost, PCA_INFORM_PACKET pPacket);
    void                CAHandleInformUnpausedControl(ASPerson * pasHost, PCA_INFORM_PACKET pPacket);

    void                CAHandleNewState(ASPerson * pasHost, PCANOTPACKET pPacket);
    void                CAStartControlled(ASPerson * pasInControl, UINT controlID);
    void                CAStopControlled(void);
    void                CAStartInControl(ASPerson * pasControlled, UINT controlID);
    void                CAStopInControl(void);

    // 2.x stuff
    void                CA2xCooperateChange(ASPerson * pasFrom, BOOL fCooperating);
    void                CA2xGrantedControl(ASPerson * pasFrom, PCAPACKET pPacket);
    BOOL                CA2xQueueSendMsg(UINT_PTR destID, UINT msg, UINT_PTR data1,
                            UINT_PTR data2);
    void                CA2xRequestControl(ASPerson * pasFrom, PCAPACKET pPacket);
    BOOL                CA2xSendMsg(UINT_PTR destID, UINT msg, UINT_PTR data1, UINT_PTR data2);
    void                CA2xTakeControl(ASPerson * pas2xHost);

    BOOL                CAFlushOutgoingPackets();
    void                CALangToggle(BOOL);
    UINT                CANewRequestID(void);
    BOOL                CAQueueSendPacket(UINT_PTR destID, UINT msg, PCA30P pPacket);
    BOOL                CASendPacket(UINT_PTR destID, UINT msg, PCA30P pPacket);

    BOOL                CMCreateAbbreviatedName(LPCSTR szTagName, LPSTR szBuf, UINT cbBuf);
    HCURSOR             CMCreateColorCursor(UINT xHotSpot, UINT yHotSpot,
                                UINT cxWidth, UINT cyHeight, LPBYTE pANDMask,
                                LPBYTE pXORBitmap, UINT cbANDMask, UINT cbXORBitmap);
    BOOL                CMCreateIncoming(ASPerson * pasPerson);
    HCURSOR             CMCreateMonoCursor(UINT xHotSpot, UINT yHotSpot,
                                UINT cxWidth, UINT cyHeight, LPBYTE pANDMask,
                                LPBYTE pXORBitmap);
    void                CMDrawCursorTag(ASPerson * pasPerson, HDC hdc);
    void                CMFreeIncoming(ASPerson * pasPerson);
    UINT                CMProcessColorCursorPacket( PCMPACKETCOLORBITMAP pCMPacket,
                                HCURSOR * phNewCursor, LPPOINT pNewHotSpot );
    void                CMProcessCursorIDPacket(PCMPACKETID pCMPacket,
                                HCURSOR * phNewCursor, LPPOINT pNewHotSpot);
    UINT                CMProcessMonoCursorPacket(PCMPACKETMONOBITMAP pCMPacket,
                                HCURSOR * phNewCursor, LPPOINT pNewHotSpot );
    void                CMReceivedCursorMovedPacket(ASPerson * pasPerson, PCMPACKETHEADER pCMPacket );
    void                CMReceivedCursorShapePacket(ASPerson * pasPerson, PCMPACKETHEADER pCMPacket );

    BOOL                CPCCapabilitiesChange(ASPerson * pasPerson, PPROTCAPS pCaps);

    ASPerson *          DCSGetPerson(UINT gccID, BOOL fNull);

    UINT                FHConsiderRemoteFonts(UINT cCommonFonts, ASPerson * pasPerson);
    UINT                FHGetLocalFontHandle(UINT remoteFont, ASPerson * pasPerson);
    void                FHMaybeEnableText(void);

    void                HETCheckSharing(BOOL fStartHost);
    BOOL                HETStartHosting(BOOL fDesktop);
    void                HETStopHosting(BOOL fDesktop);
    void                HETSendLocalCount(void);
    void                HETUpdateLocalCount(UINT newCount);
    void                HETUpdateRemoteCount(ASPerson * pasPerson, UINT newCount);

    BOOL                IMConvertAndSendEvent(ASPerson * pasFor, LPIMEVENT pIMEvent);
    UINT                IMConvertIMEventToOSEvent(LPIMEVENT pEvent, LPIMOSEVENT pOSEvent);
    void                IMDiscardUnreplayableOSEvents(void);
    void                IMGenerateFakeKeyPress(TSHR_UINT16 type,
                            TSHR_UINT16 key, TSHR_UINT16 flags);
    BYTE                IMGetHighLevelKeyState(UINT vk);
    void                IMSendKeyboardState(void);
    BOOL                IMTranslateIncoming(LPIMEVENT pIMIn, LPIMEVENT pIMOut);
    BOOL                IMTranslateOutgoing(LPIMEVENT pIMIn, LPIMEVENT pIMOut);
    void                IMAppendNetEvent(LPIMEVENT pIMEvent);

    void                IMFlushOutgoingEvents(void);
    void                IMInject(BOOL fStart);
    BOOL                IMInjectEvent(LPIMOSEVENT pEvent);
    BOOL                IMInjectingEvents(void);
    UINT                IMInsertModifierKeystrokes(BYTE curKBState, BYTE targetKBState,
                            LPUINT pEventQueue);
    void                IMMaybeAddDeadKey(BYTE vk);
    void                IMMaybeInjectEvents(void);
    void                IMSpoilEvents(void);
    void                IMUpdateAsyncArray(LPBYTE pimKeyStates, LPIMOSEVENT pEvent);

    void                ODAdjustColor(ASPerson * pasPerson, const TSHR_COLOR * pColorIn, LPTSHR_COLOR pColorOut, int type);
    void                ODDrawTextOrder(ASPerson * pasPerson, BOOL fExtText, BOOL fPalRGB,
                            LPCOMMON_TEXTORDER pCommon, LPSTR pText, UINT cchText,
                            LPRECT pExtRect, UINT extOptions, LPINT pExtDx);
    void                ODReplayARC(ASPerson * pasFrom, LPARC_ORDER pArc, BOOL fPalRGB);
    void                ODReplayCHORD(ASPerson * pasFrom, LPCHORD_ORDER pChord, BOOL fPalRGB);
    void                ODReplayDSTBLT(ASPerson * pasFrom, LPDSTBLT_ORDER pDstBlt, BOOL fPalRGB);
    void                ODReplayELLIPSE(ASPerson * pasFrom, LPELLIPSE_ORDER pEllipse, BOOL fPalRGB);
    void                ODReplayEXTTEXTOUT(ASPerson * pasFrom, LPEXTTEXTOUT_ORDER pExtTextOut, BOOL fPalRGB);
    void                ODReplayLINETO(ASPerson * pasFrom, LPLINETO_ORDER pLineTo, BOOL fPalRGB);
    void                ODReplayMEM3BLT(ASPerson * pasFrom, LPMEM3BLT_ORDER pMem3Blt, BOOL fPalRGB);
    void                ODReplayMEMBLT(ASPerson * pasFrom, LPMEMBLT_ORDER pMemBlt, BOOL fPalRGB);
    void                ODReplayOPAQUERECT(ASPerson * pasFrom, LPOPAQUERECT_ORDER pOpaqeRect, BOOL fPalRGB);
    void                ODReplayPATBLT(ASPerson * pasFrom, LPPATBLT_ORDER pPatBlt, BOOL fPalRGB);
    void                ODReplayPIE(ASPerson * pasFrom, LPPIE_ORDER pPie, BOOL fPalRGB);
    void                ODReplayPOLYBEZIER(ASPerson * pasFrom, LPPOLYBEZIER_ORDER pPolyBezier, BOOL fPalRGB);
    void                ODReplayPOLYGON(ASPerson * pasFrom, LPPOLYGON_ORDER pPolygon, BOOL fPalRGB);
    void                ODReplayRECTANGLE(ASPerson * pasFrom, LPRECTANGLE_ORDER pRectangle, BOOL fPalRGB);
    void                ODReplayROUNDRECT(ASPerson * pasFrom, LPROUNDRECT_ORDER pRoundRect, BOOL fPalRGB);
    void                ODReplaySCRBLT(ASPerson * pasFrom, LPSCRBLT_ORDER pScrBlt, BOOL fPalRGB);
    void                ODReplayTEXTOUT(ASPerson * pasFrom, LPTEXTOUT_ORDER pTextOut, BOOL fPalRGB);
    void                ODUseArcDirection(ASPerson * pasPerson, UINT dir);
    void                ODUseBkColor(ASPerson * pasPerson, BOOL fPalRGB, TSHR_COLOR color);
    void                ODUseBkMode(ASPerson * pasPerson, int mode);
    void                ODUseBrush(ASPerson * pasPerson, BOOL fPalRGB,
                            int x, int y, UINT Style, UINT Hatch,
                            TSHR_COLOR Color, BYTE  Extra[7]);
    void                ODUseFillMode(ASPerson * pasPerson, UINT mode);
    void                ODUseFont(ASPerson * pasPerson, LPSTR pName, UINT cchName,
                            UINT codePage, UINT maxHeight, UINT Height,
                            UINT Width, UINT Weight, UINT flags);
    void                ODUsePen(ASPerson * pasPerson, BOOL fPalRGB,
                            UINT style, UINT width, TSHR_COLOR color);
    void                ODUseRectRegion(ASPerson * pasPerson, int left,
                            int top, int right, int bottom);
    void                ODUseROP2(ASPerson * pasPerson, int rop);
    void                ODUseTextBkColor(ASPerson * pasPerson, BOOL fPalRGB, TSHR_COLOR color);
    void                ODUseTextCharacterExtra(ASPerson * pasPerson, int extra);
    void                ODUseTextColor(ASPerson * pasPerson, BOOL fPalRGB, TSHR_COLOR color);
    void                ODUseTextJustification(ASPerson * pasPerson, int extra, int count);

    void                OD2CopyFromDeltaCoords(LPTSHR_INT8* ppSrc, LPVOID pDst,
                                UINT cbDstField, BOOL fSigned, UINT numElements);
    void                OD2DecodeBounds(LPBYTE *ppNextDataToCopy,
                                LPTSHR_RECT16 pRect, ASPerson * pasPerson);
    void                OD2DecodeField(LPBYTE*  ppSrc, LPVOID pDest,
                                UINT cbSrcField, UINT cbDstField, BOOL fSigned,
                                UINT numElements);
    void                OD2FreeIncoming(ASPerson * pasPerson);
    BOOL                OD2UseFont(ASPerson * pasPerson, LPSTR pName,
                                UINT facelength, UINT codePage, UINT MaxHeight,
                                UINT Height, UINT Width, UINT Weight, UINT flags);

    void                OECapabilitiesChanged(void);

    void                PMFreeIncoming(ASPerson * pasPerson);

    void                RBCFreeIncoming(ASPerson * pasPerson);
    void                RBCStoreBitsInCacheBitmap(ASPerson *  pasPerson,
                            UINT cacheID, UINT iCacheEntry, UINT cxSubWidth,
                            UINT cxFixedWidth, UINT cySubHeight, UINT bpp,
                            LPBYTE pBitmapBits, UINT cbBitmapBits, BOOL fCompressed);

    BOOL                SCSyncStream(UINT streamID);

    void                SDPDrawHatchedRegion(HDC hdc, HRGN region, UINT hatchColor);
    void                SDPPlayScreenDataToRDB(ASPerson * pasPerson,
                            PSDPACKET pUpdates, LPBYTE pBits, LPRECT pPosition);

    void                VIEWClientAutoScroll(ASPerson *);
    void                VIEWClientCaptureStolen(ASPerson *);
    void                VIEWClientExtentChange(ASPerson * pasHost, BOOL fRedraw);
    void                VIEWClientGetSize(ASPerson * pasHost, LPRECT lprc);
    void                VIEWClientMouseDown(ASPerson *, UINT, WPARAM, LPARAM);
    void                VIEWClientMouseMove(ASPerson *, UINT, WPARAM, LPARAM);
    void                VIEWClientMouseMsg(ASPerson *, UINT, WPARAM, LPARAM);
    void                VIEWClientMouseUp(ASPerson *, UINT, WPARAM, LPARAM, BOOL);
    void                VIEWClientMouseWheel(ASPerson *, WPARAM, LPARAM);
    void                VIEWClientPaint(ASPerson * pasHost);
    BOOL                VIEWClientScroll(ASPerson * pasHost, int xNew, int yNew);

    void                VIEWFrameAbout(ASPerson * pasHost);
    void                VIEWFrameCommand(ASPerson * pasHost, WPARAM wParam, LPARAM lParam);
    BOOL                VIEWFrameCreate(ASPerson * pasHost);
    void                VIEWFrameFullScreen(ASPerson * pasHost, BOOL fFull);
    void                VIEWFrameGetSize(ASPerson * pasHost, LPRECT lprc);
    void                VIEWFrameHelp(ASPerson * pasHost);
    void                VIEWFrameInitMenuBar(ASPerson * pasHost);
    void                VIEWFrameOnMenuSelect(ASPerson * pasHost, WPARAM wParam, LPARAM lParam);
    void                VIEWFrameResize(ASPerson * pasHost);
    void                VIEWFrameResizeChanged(ASPerson * pasHost);
    void                VIEWFrameSetStatus(ASPerson * pasHost, UINT idsStatus);

    void                VIEWFullScreenExitPaint(ASPerson * pasHost, HWND hwnd);

    void                VIEWStartControlled(BOOL fControlled);

    void                VIEWWindowBarDoActivate(ASPerson * pasHost, PWNDBAR_ITEM pItem);
    void                VIEWWindowBarChangeActiveItem(ASPerson * pasHost, PWNDBAR_ITEM pItem);
    BOOL                VIEWWindowBarCreate(ASPerson * pasHost, HWND hwndBar);
    PWNDBAR_ITEM        VIEWWindowBarFirstVisibleItem(ASPerson * pasHost);
    void                VIEWWindowBarItemsClick(ASPerson * pasHost, HWND hwndItems, int x, int y);
    void                VIEWWindowBarItemsInvalidate(ASPerson * pasHost, PWNDBAR_ITEM pItem);
    void                VIEWWindowBarItemsPaint(ASPerson * pasHost, HWND hwndItems);
    void                VIEWWindowBarItemsScroll(ASPerson * pasHost, WPARAM wParam, LPARAM lParam);
    void                VIEWWindowBarResize(ASPerson * pasHost, HWND hwndBar);


    BOOL                USRCreateRemoteDesktop(ASPerson * pasPerson);
    void                USRDeleteRemoteDesktop(ASPerson * pasPerson);

};




typedef struct tagASSession
{
    // pasNext someday!
    UINT                    scState;

    UINT_PTR                    callID;     // ID of call
    MCSID                   gccID;      // GCC node_id
    BOOL                    fShareCreator;
    NM30_MTG_PERMISSIONS    attendeePermissions;

    UINT                    cchLocalName;
    char                    achLocalName[TSHR_MAX_PERSON_NAME_LEN];
    ASShare *               pShare;
#ifdef _DEBUG
    DWORD                   scShareTime;
#endif

    HWND                    hwndHostUI;
    BOOL                    fHostUI:1;
    BOOL                    fHostUIFrozen:1;
}
ASSession;


#endif // _H_AS

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\ch.h ===
//
// CH.H
// Cache Handler
// 
// Copyright (c) Microsoft 1997-
//

#ifndef _H_CH
#define _H_CH


//
//
// DEFINES
//
//
#define CH_NUM_EVICTION_CATEGORIES  3

// 
// NOTES:
// 64K limit on cache
// CHCACHE includes one entry, so only subtract out header part
//
#define CH_MAX_CACHE_ENTRIES \
    ( (65535 - (sizeof(CHCACHE) - sizeof(CHENTRY))) / sizeof(CHENTRY) )


//
//
// TYPEDEFS
//
//


typedef struct tagCHCHAIN
{
    WORD    next;
    WORD    prev;
} CHCHAIN;
typedef CHCHAIN * PCHCHAIN;



//
// There are going to be thousands of cache entries so we need to keep
// the header as compact as possible.  We could drop the eviction
// category, but it is useful info and does round the entry to 16 bytes
// which makes indexing efficient.
//
// Note that the 16 bit code is restricted to 4096 entries unless we take
// steps to allow huge addressing of the entry array.
//


//
// CHENTRY
// Cache entry in a Cache tree
//
typedef struct tagCHENTRY
{
    struct tagCHENTRY * pParent;
    struct tagCHENTRY * pLeft;
    struct tagCHENTRY * pRight;
    WORD                lHeight;
    WORD                rHeight;
    UINT                cbData;
    LPBYTE              pData;
    UINT                checkSum;
    CHCHAIN             chain;
    WORD                evictionCategory;
    WORD                free;
} CHENTRY;
typedef CHENTRY * PCHENTRY;



//
// A CACHE
//

// FORWARD DECLARATION
typedef struct tagCHCACHE * PCHCACHE;

#ifdef __cplusplus

typedef void (* PFNCACHEDEL)(class ASHost * pHost, PCHCACHE pCache, UINT iEntry, LPBYTE pData);

//
// Each cache may have several eviction categories.  These allow the caller
// to define classes of data so that it can control what is evicted from
// the cache.  To be a candidate for eviction the eviction class of a LRU
// entry must match, unless the number of entries in that category is
// less than the eviction threshold, in which case any cache entry is
// up for grabs.
//
// The EvictionThreshold() function can be used to tune eviction thresholds
// which default to cEntries/cNumEvictionCategories
//

typedef struct tagCHCACHE
{
    STRUCTURE_STAMP

    PFNCACHEDEL     pfnCacheDel;
    UINT            cEntries;
    UINT            cNumEvictionCategories;
    UINT            cbNotHashed;

    //
    // NOTE:  CH_NUM_EVICTION_CATEGORIES is 3, so 3 words + 3 words +
    // 3 words == 9 words, not DWORD aligned.  Hence we stick the WORD
    // field free after iMRUTail.  If CH_NUM_EVICTION_CATEGORIES ever
    // changes to an even value, reshuffle this structure.
    // 
    WORD            cEvictThreshold[CH_NUM_EVICTION_CATEGORIES];
    WORD            iMRUHead[CH_NUM_EVICTION_CATEGORIES];
    WORD            iMRUTail[CH_NUM_EVICTION_CATEGORIES];
    WORD            free;

    PCHENTRY        pRoot;
    PCHENTRY        pFirst;
    PCHENTRY        pLast;

    CHENTRY         Entry[1];
}
CHCACHE;
typedef CHCACHE * PCHCACHE;

#endif // __cplusplus


//
//
// MACROS
//
//

//
// BOGUS LAURABU
// In future, have debug signatures at front of objects to catch heap corruption
//

#define IsValidCache(pCache) \
    (!IsBadWritePtr((pCache), sizeof(CHCACHE)))

#define IsValidCacheEntry(pEntry) \
    (!IsBadWritePtr((pEntry), sizeof(CHENTRY)))

#define IsValidCacheIndex(pCache, iEntry) \
    ((iEntry >= 0) && (iEntry < (pCache)->cEntries))

#define IsCacheEntryInTree(pEntry) \
    (((pEntry)->lHeight != 0xFFFF) && ((pEntry)->rHeight != 0xFFFF))




#endif // _H_CH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\bmc.h ===
//
// BMC.H
// Bitmap Cache
//
// Copyright (c) Microsoft 1997-
//

#ifndef _H_BMC
#define _H_BMC


//
// Bitmap caching order header
//
typedef struct tagBMC_ORDER_HDR
{
    TSHR_UINT8        bmcPacketType;
}
BMC_ORDER_HDR;
typedef BMC_ORDER_HDR FAR * PBMC_ORDER_HDR;


//
// Structure of data stored in DIB cache.
// The first few fields are variable and therefore not included in the
// cache hash.
//
#define BMC_DIB_NOT_HASHED   (FIELD_OFFSET(BMC_DIB_ENTRY, cx))
typedef struct tagBMC_DIB_ENTRY
{
    BYTE            inUse;
    BYTE            bCompressed;
    TSHR_UINT16     iCacheIndex;
    TSHR_UINT16     cx;
    TSHR_UINT16     cxFixed;
    TSHR_UINT16     cy;
    TSHR_UINT16     bpp;
    UINT            cCompressed;
    UINT            cBits;
    BYTE            bits[1];
}
BMC_DIB_ENTRY;
typedef BMC_DIB_ENTRY FAR * PBMC_DIB_ENTRY;


//
// DIB cache header
//
typedef struct tagBMC_DIB_CACHE
{
    PCHCACHE        handle;
    PBMC_DIB_ENTRY  freeEntry;
    LPBYTE          data;
    UINT            cEntries;
    UINT            cCellSize;
    UINT            cSize;
}
BMC_DIB_CACHE;
typedef BMC_DIB_CACHE * PBMC_DIB_CACHE;



//
// WE HAVE NO SMALL TILES ANYMORE
// Medium sized tiles must fit into a medium cell for the sending depth.
// Large sized tiles must fit into a large cell for the sending depth.
//
// Since true color sending can change dynamically, the easiest thing to do
// to cut down on memory usage is to check the capture depth.  If it's
// <= 8, then we can never send true color, so allocate for 8bpp.  Else
// allocate for 24bpp.
//

#define BYTES_IN_SCANLINE(width, bpp)   ((((width)*(bpp))+31)/32)*4

#define BYTES_IN_BITMAP(width, height, bpp)  (BYTES_IN_SCANLINE(width, bpp)*height)


__inline UINT  MaxBitmapHeight(UINT width, UINT bpp)
{
    UINT    bytesPerRow;

    //
    // If bpp is 4, there are width/2 bytes per Row
    // If bpp is 8, there are width bytes per Row
    // If bpp is 24, there are 3*width bytes per Row
    //
    bytesPerRow = BYTES_IN_SCANLINE(width, bpp);
    return((TSHR_MAX_SEND_PKT - sizeof(S20DATAPACKET) + sizeof(DATAPACKETHEADER)) / bytesPerRow);
}


//
// Define the cache identifiers which are transmitted in the hBitmap field
// of Memory->Screen blt orders.
//
// These are replaced by the receiver with their local (real) bitmap
// handle of the specified cache.
//
// Note that they are assumed to be contiguous with the smallest as 0
//
//
#define ID_SMALL_BMP_CACHE              0
#define ID_MEDIUM_BMP_CACHE             1
#define ID_LARGE_BMP_CACHE              2
#define NUM_BMP_CACHES                  3


//
// WHEN 2.X COMPAT IS GONE, WE CAN PLAY WITH THESE SIZES AT WILL.  But
// since the cell size (width * height * bpp) is negotiated when a 2.x
// node is in the share, we can not. Back level nodes assume a certain
// cell size.  So do new level nodes for now!
//

#define MP_SMALL_TILE_WIDTH             16
#define MP_SMALL_TILE_WIDTH             16
#define MP_MEDIUM_TILE_WIDTH            32
#define MP_MEDIUM_TILE_HEIGHT           32
#define MP_LARGE_TILE_WIDTH             64
#define MP_LARGE_TILE_HEIGHT            63


#define MP_CACHE_CELLSIZE(width, height, bpp)   \
    (BYTES_IN_BITMAP(width, height, bpp) + sizeof(BMC_DIB_ENTRY) - 1)


//
// Upper bound on the total cache memory we'll use (2 MB)
//
#define MP_MEMORY_MAX                   0x200000

#define COLORCACHEINDEX_NONE            0xFF

#define MEMBLT_CACHETABLE(pMemBlt) ((TSHR_UINT16)LOBYTE(pMemBlt->cacheId))
#define MEMBLT_COLORINDEX(pMemBlt) ((TSHR_UINT16)HIBYTE(pMemBlt->cacheId))
#define MEMBLT_COMBINEHANDLES(colort, bitmap)   ((TSHR_UINT16)MAKEWORD(bitmap, colort))


BOOL BMCAllocateCacheData(UINT numEntries, UINT cellSize, UINT cacheID,
        PBMC_DIB_CACHE pCache);
void BMCFreeCacheData(PBMC_DIB_CACHE pCache);


#endif // H_BMC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\dbgzones.h ===
#ifndef _DEBUG_ZONES_H_
#define _DEBUG_ZONES_H_

#include <mlzdbg.h>

#if defined(_DEBUG) && defined(MULTI_LEVEL_ZONES)

enum
{
    ZONE_CORE = BASE_ZONE_INDEX,
    ZONE_NET,
    ZONE_ORDER,
    ZONE_OM,
    ZONE_INPUT,
    ZONE_WB,
    ZONE_UT
};

#endif // _DEBUG && MULTI_LEVEL_ZONES


#endif // _DEBUG_ZONES_H_


// lonchanc: this must be outside the _DEBUG_ZONE_H_ protection
// because cpi32dll.c and crspdll.c need to include this header
// again in order to initialize the debug zone data.
#if defined(_DEBUG) && defined(INIT_DBG_ZONE_DATA) && defined(MULTI_LEVEL_ZONES)

static const PSTR c_apszDbgZones[] =
{
    "AppShr",      // debug zone module name
    DEFAULT_ZONES
    "Core",
    "Network",
    "Order",
    "ObMan",
    "Input",
    "Whiteboard",
    "UT",
};

#endif // _DEBUG && INIT_DBG_ZONE_DATA && MULTI_LEVEL_ZONES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\ba.h ===
//
// Bounds Accumulation
//

#ifndef _H_BA
#define _H_BA


//
// Number of rectangles used by the SDA.
// NOTE:  You can play around with this setting, building the core & the 
// display driver.  Bumping it up means finer update areas, bumping it down
// means more rect blobs of data.
//
#define BA_NUM_RECTS      10
#define BA_INVALID_RECT_INDEX ((UINT)-1)


//
// Values for OSI escape codes
//
#define BA_ESC(code)            (OSI_BA_ESC_FIRST + code)

#define BA_ESC_GET_BOUNDS       BA_ESC(0)
#define BA_ESC_RETURN_BOUNDS    BA_ESC(1)


//
//
// MACROS
//
//

//
// Macros to access the fast swapping shared memory.
//
#ifdef DLL_DISP

#define BA_FST_START_WRITING    SHM_StartAccess(SHM_BA_FAST)
#define BA_FST_STOP_WRITING     SHM_StopAccess(SHM_BA_FAST)


#else


#define BA_FST_START_READING    &g_asSharedMemory->baFast[\
            1 - g_asSharedMemory->fastPath.newBuffer]
#define BA_FST_STOP_READING

#define BA_FST_START_WRITING    &g_asSharedMemory->baFast[\
            1 - g_asSharedMemory->fastPath.newBuffer]
#define BA_FST_STOP_WRITING


#endif // DLL_DISP



//
//
// TYPES
//
//




//
// Structure: BA_BOUNDS_INFO
//
// Description: Structure used to pass bounds information between the
//              share core and the driver.
//
//
typedef struct tagBA_BOUNDS_INFO
{
    OSI_ESCAPE_HEADER   header;             // Common header               
    DWORD       numRects;                   // Num of bounds rects
    RECTL       rects[BA_NUM_RECTS];        // Rects
}
BA_BOUNDS_INFO;
typedef BA_BOUNDS_INFO FAR * LPBA_BOUNDS_INFO;


//
// Structure: BA_FAST_DATA
//
// Used to pass data from the screen output task to the Share Core on each
// periodic processing.
//
typedef struct tagBA_FAST_DATA
{
    DWORD    totalSDA;
} BA_FAST_DATA;
typedef BA_FAST_DATA FAR * LPBA_FAST_DATA;



//
//
// OVERVIEW
//
// The bounds code used to be common to the share core and the display
// driver, with the data stored in the double buffered shared memory.  This
// is no longer the case.
//
// The display driver now "owns" the bounds - they are no longer stored in
// shared memory - and does all the complex manipulations such as merging
// rectangles.  When the share core needs to process bounds, it gets a copy
// from the driver by calling BA_FetchBounds(), sends as much of the data
// as possible, then returns the remaining bounds to the driver by calling
// BA_ReturnBounds().
//
// The nett result of these changes is that all the code which was common
// to the share core and the display driver (in abaapi.c and abaint.c) is
// now only in the driver (in nbaapi.c and nbaint.c).  There are vastly
// simplified versions of the functions in the share core.
//
//



//
// BA_ResetBounds
//
#ifdef DLL_DISP
void BA_DDInit(void);

void BA_ResetBounds(void);
#endif // DLL_DISP



//
// Name:      BA_ReturnBounds
//
// Purpose:   Pass the share core's copy of the bounds to the driver.
//
// Returns:   Nothing
//
// Params:    None
//
// Operation: This resets the share core's bounds to NULL.
//

void BA_ReturnBounds(void);




//
// Name:        BA_CopyBounds
//
// Description: Copies the bounding rectangle list.
//
// Params (IN): pRects - pointer to array of RECTs to fill in.
//        (OUT):pNumrects - filled in with number of RECTs copied.
//        (IN): reset current rects or just get current state w/o changing
//              state.
//
// Returns:     TRUE or FALSE
//
// DESCRIPTION
//
// Returns the accumulated bounds for all applications in the bounds
// code's current list of applications.  The bounds returned will
// include all updates originating from these applications but they may
// also include updates outside these applications windows and updates
// originating from other applications.  Therefore the caller must clip
// the returned bounds to the windows of the applications being
// shadowed.
//
// PARAMETERS
//
// pRects:
//
// A pointer to an array of rectangles in which the bounds will be
// returned.  The contents of this array are only valid if *pRegion is NULL
// on return from BA_GetBounds.  There must
// be room for maxRects rectangles (as specified in the bndInitialise
// call).  pRects may be a NULL pointer if maxRects was set to 0 in the
// bndInitialise call.
//
// pNumRects:
//
// A pointer to a variable where the number of rectangles returned at
// pRects is returned.  The contents of this variable are only valid if
// *pRegion is NULL on return from BA_GetBounds.
//
// fReset:
// Whether to reset the core's bounds variables after getting the current
// state or not.
//
//
void BA_CopyBounds(LPRECT pRects, LPUINT pNumRects, BOOL fReset);


#ifdef DLL_DISP


typedef struct tagDD_BOUNDS
{
    UINT    iNext;
    BOOL    InUse;
    RECT    Coord;
    DWORD   Area;
} DD_BOUNDS;
typedef DD_BOUNDS FAR* LPDD_BOUNDS;



//
// Name:      BA_DDProcessRequest
//
// Purpose:   Process a request from the share core
//
// Returns:   TRUE if the request is processed successfully,
//            FALSE otherwise.
//
// Params:    IN     pso   - Pointer to surface object for our driver
//            IN     cjIn  - Size of the input data
//            IN     pvIn  - Pointer to the input data
//            IN     cjOut - Size of the output data
//            IN/OUT pvOut - Pointer to the output data
//

#ifdef IS_16
BOOL    BA_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);
#else
BOOL    BA_DDProcessRequest(DWORD fnEscape, LPOSI_ESCAPE_HEADER pRequest,
                DWORD cbRequest, LPOSI_ESCAPE_HEADER pResult, DWORD cbResult);
#endif // !IS_16


//
// Name:      BA_QuerySpoilingBounds
//
// Purpose:   Return the current spoiling bounds.  That is, the bounds
//            which the share core is currently processing.
//
// Returns:   Nothing
//
// Params:    IN/OUT pRects    - Pointer to an array of rectangles to
//                               return the bounds in.  There must be at
//                               least BA_NUM_RECTS entries in this
//                               array.  The first *pNumRects entries are
//                               valid on return.
//            IN/OUT pNumRects - Returns the number of rectangles forming
//                               the spoiling bounds (can be zero).
//

void BA_QuerySpoilingBounds(LPRECT pRects, LPUINT pNumRects);



//
// Name:        BAOverlap
//
// Description: Detects overlap between two rectangles.
//
//              - check for no overlap using loose test that lets through
//                adjacent/overlapping merges
//              - check for adjacent/overlapping merges
//              - check for no overlap (using strict test)
//              - use outcodes to check internal edge cases
//              - use outcodes to check external edge cases
//
//              If at each stage the check detects that the two rectangles
//              meet the criteria, the function returns the appropriate
//              return or outcode combination.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
//              This function does not alter either of the rectangles.
//
// Params (IN): pRect1 - first rectangle
//              pRect2 - second rectangle
//
// Returns:     One of the overlap return codes or outcode combinations
//              defined above.
//
//

//
// Note that bndRectsArray and bndRectsSizeArray must contain space for
// BA_NUM_RECTS+1 rectangles for the merge algorithm.
//

//
// The function will recurse to a maximum level when trying to split
// rectangles up.  When this limit is reached it will start merging
// rather than splitting
//
#define ADDR_RECURSE_LIMIT 20

//
// The following constants are used to determine overlaps.
//
// - OL_NONE through OL_MERGE_YMAX are return codes - which need to be
//   distinct from all possible outcode combinations - allowing for the
//   minus outcodes for enclosed cases.
//
// - EE_XMIN through EE_YMAX are outcodes - which need to be uniquely
//   ORable binary constants within a single nibble.
//
// - OL_ENCLOSED through OL_SPLIT_XMAX_YMAX are outcode combinations for
//   internal and external edge overlap cases.
//
// See Overlap() for further description.
//
#define OL_NONE               -1
#define OL_MERGE_XMIN         -2
#define OL_MERGE_YMIN         -3
#define OL_MERGE_XMAX         -4
#define OL_MERGE_YMAX         -5

#define EE_XMIN 0x0001
#define EE_YMIN 0x0002
#define EE_XMAX 0x0004
#define EE_YMAX 0x0008

#define OL_ENCLOSED           -(EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX)
#define OL_PART_ENCLOSED_XMIN -(EE_XMIN | EE_YMIN | EE_YMAX)
#define OL_PART_ENCLOSED_YMIN -(EE_XMIN | EE_YMIN | EE_XMAX)
#define OL_PART_ENCLOSED_XMAX -(EE_YMIN | EE_XMAX | EE_YMAX)
#define OL_PART_ENCLOSED_YMAX -(EE_XMIN | EE_XMAX | EE_YMAX)

#define OL_ENCLOSES           EE_XMIN | EE_XMAX | EE_YMIN | EE_YMAX
#define OL_PART_ENCLOSES_XMIN EE_XMAX | EE_YMIN | EE_YMAX
#define OL_PART_ENCLOSES_XMAX EE_XMIN | EE_YMIN | EE_YMAX
#define OL_PART_ENCLOSES_YMIN EE_XMIN | EE_XMAX | EE_YMAX
#define OL_PART_ENCLOSES_YMAX EE_XMIN | EE_XMAX | EE_YMIN
#define OL_SPLIT_X            EE_YMIN | EE_YMAX
#define OL_SPLIT_Y            EE_XMIN | EE_XMAX
#define OL_SPLIT_XMIN_YMIN    EE_XMAX | EE_YMAX
#define OL_SPLIT_XMAX_YMIN    EE_XMIN | EE_YMAX
#define OL_SPLIT_XMIN_YMAX    EE_XMAX | EE_YMIN
#define OL_SPLIT_XMAX_YMAX    EE_XMIN | EE_YMIN

int BAOverlap(LPRECT pRect1, LPRECT pRect2 );

//
// Name:        BAAddRectList
//
// Description: Adds a rectangle to the list of accumulated rectangles.
//
//              - find a free slot in the array
//              - add slot record to list
//              - fill slot record with rect and mark as in use.
//
// Params (IN): pRect - rectangle to add
//
// Returns:
//
//
void BAAddRectList(LPRECT pRect);

//
// Name:        BA_RemoveRectList
//
// Description: Removes a rectangle from the list of accumulated
//              rectangles.
//
//              - find the rectangle in the list
//              - unlink it from the list and mark the slot as free
//
// Params (IN): pRect - rectangle to remove
//
// Returns:
//
//
void BA_RemoveRectList(LPRECT pRect);


void BA_AddScreenData(LPRECT pRect);


//
// Name:        BAAddRect
//
// Description: Accumulates rectangles.
//
//              This is a complex routine, with the essential algorithm
//              as follows.
//
//              - Start with the supplied rectangle as the candidate
//                rectangle.
//
//              - Compare the candidate against each of the existing
//                accumulated rectangles.
//
//              - If some form of overlap is detected between the
//                candidate and an existing rectangle, this may result in
//                one of the following (see the cases of the switch for
//                details):
//
//                - adjust the candidate or the existing rectangle or both
//                - merge the candidate into the existing rectangle
//                - discard the candidate as it is enclosed by an existing
//                  rectangle.
//
//              - If the merge or adjustment results in a changed
//                candidate, restart the comparisons from the beginning of
//                the list with the changed candidate.
//
//              - If the adjustment results in a split (giving two
//                candidate rectangles), invoke this routine recursively
//                with one of the two candidates as its candidate.
//
//              - If no overlap is detected against the existing rectangles,
//                add the candidate to the list of accumulated rectangles.
//
//              - If the add results in more than BA_NUM_RECTS
//                accumulated rectangles, do a forced merge of two of the
//                accumulate rectangles (which include the newly added
//                candidate) - choosing the two rectangles where the merged
//                rectangle results in the smallest increase in area over
//                the two non-merged rectangles.
//
//              - After a forced merge, restart the comparisons from the
//                beginning of the list with the newly merged rectangle as
//                the candidate.
//
//              For a particular call, this process will continue until
//              the candidate (whether the supplied rectangle, an adjusted
//              version of that rectangle, or a merged rectangle):
//
//              - does not find an overlap among the rectangles in the list
//                and does not cause a forced merge
//              - is discarded becuase it is enclosed within one of the
//                rectangles in the list.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
// Params (IN): pCand - new candidate rectangle
//              level - recursion level
//
// Returns:  TRUE if rectandle was spoilt due to a complete overlap.
//
//
BOOL BAAddRect( LPRECT pCand,  int level );


#endif // DLL_DISP



#endif // _H_BA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\control.h ===
//
// CONTROL.H
// Control by us, control of us
//
// Copyright (c) Microsoft 1997-
//

#ifndef _H_CA
#define _H_CA


//
//
// CONSTANTS
//
//

#define CA_SEND_EVENT           0x0001
#define CA_ALLOW_EVENT          0x0002


//
// Cleanup flags
//
#define CACLEAR_HOST            0x0001
#define CACLEAR_VIEW            0x0002
#define CACLEAR_ALL             0x0003


//
// Queued responses to control requests.  We try to send them right away,
// but that can fail.  
// Here's the logic:
//      
// (1) For TAKING/RELEASING control (viewer)
//     There's only one at most pending.  That's because a pending RELEASE
//          cancels out a pending TAKE.  
//
// (2) For RESPONDING/REVOKING control (host)
//     These never cancel out.  Each one will have a successive sequence ID.
//          There should NEVER be a pending BOUNCE in the queue with a 
//          pending RESPOND for the same controller/request ID.  Of course not,
//          since we don't change our state until the packet goes out,
//          and if the RESPOND CONFIRM packet hasn't gone out, we wouldn't
//          be bouncing anybody.
//      
// Outgoing requests take precedence over incoming ones.  In other words,
// if the UI/user/SDK code asks us to take control of a remote, we will
// turn any pending RESPOND CONFIRM packets into RESPOND DENIED ones.  If
// we are in control of another already, take will fail, it's the intermediate
// phase that's undoable only.
//
// Here's the basic logic flow to TAKE CONTROL:
//      Viewer makes new sequence ID
//      Viewer sends private packet to host, requesting control
//      Viewer changes state to "asked for control"
//      Host receives private packet
//      Host sends private response packet to viewer, confirming or denying control
//      If confirming, host broadcasts notification to everybody sometime
//          later.
//      When viewer gets response, viewer moves to incontrol state, or
//          backs off
//
// Here's the basic logic flow to RELEASE CONTROL:
//      Viewer initiated:
//          Send INFORM RELEASED private packet to host
//          Change state to not in control
//          Host receives private packet
//          Host ignores if out of date (bounced already or whatever)
//          Host changes state to not controlled otherwise
//      Host initiated:
//          Send INFORM BOUNCED private packet to viewer
//          Change state to not controlled
//          Viewer receives private packet
//          Viewer ignores if out of date (released already or whatever)
//          Viewer changes state to not in control otherwise
//
// While pending take control, waiting to here confirmation, or in control
//      pending requests to control us are denied.
//


enum
{
    REQUEST_2X  = 0,
    REQUEST_30
};

typedef struct tagCA2XREQ
{
    UINT_PTR            data1;
    UINT_PTR            data2;
}
CA2XREQ;


typedef union
{
    CA_RTC_PACKET       rtc;
    CA_REPLY_RTC_PACKET rrtc;
    CA_RGC_PACKET       rgc;
    CA_REPLY_RGC_PACKET rrgc;
    CA_PPC_PACKET       ppc;
    CA_INFORM_PACKET    inform;
}
CA30P;
typedef CA30P * PCA30P;

class ASPerson;

typedef struct tagCA30PENDING
{
    ASPerson *      pasReplyTo;
    UINT_PTR        mcsOrg;
    UINT            msg;
    CA30P           request;
}
CA30PENDING;
typedef CA30PENDING * PCA30PENDING;


typedef struct tagCA30XREQ
{
    CA30P           packet;
}
CA30REQ;


//
// Private send/responses get queued up and our state can NOT change until
// they go out.
//
typedef struct tagCAREQUEST
{
    STRUCTURE_STAMP

    BASEDLIST       chain;

    UINT            type;
    UINT_PTR        destID;
    UINT            msg;

    union
    {
        CA2XREQ     req2x;
        CA30REQ     req30;
    }
    req;
}
CAREQUEST;
typedef CAREQUEST * PCAREQUEST;


//
// The location of the keyboard language toggle hotkey setting in the
// registry.
//
#define LANGUAGE_TOGGLE_KEY     "keyboard layout\\toggle"
#define LANGUAGE_TOGGLE_KEY_VAL "Hotkey"

//
// A value we use to indicate that the registry entry is not present - it
// could be any value except for '1', '2', or '3'
//
#define LANGUAGE_TOGGLE_NOT_PRESENT   0


//
// Query dialog
//

#define IDT_CAQUERY         50
#define PERIOD_CAQUERY      30000   // 30 seconds

INT_PTR CALLBACK CAQueryDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // _H_CA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\datainit.h ===
//
// Macros that create storage for vars
//

//
// Clear any previous definitions of the macros.
//
#undef DC_DATA
#undef DC_DATA_VAL
#undef DC_CONST_DATA
#undef DC_DATA_ARRAY
#undef DC_CONST_DATA_ARRAY
#undef DC_DATA_2D_ARRAY
#undef DC_CONST_DATA_2D_ARRAY


// This is for structs that can't use the DC_DATA macros; they can switch on it
#define DC_DEFINE_DATA

//
// Allocate Storage
//

#define DC_DATA(TYPE, Name) \
            TYPE Name

#define DC_DATA_VAL(TYPE, Name, Value) \
            TYPE Name = Value

#define DC_CONST_DATA(TYPE, Name, Value) \
            const TYPE Name = Value


#define DC_DATA_ARRAY(TYPE, Name, Size) \
            TYPE Name[Size]

#define DC_CONST_DATA_ARRAY(TYPE, Name, Size, Value) \
            const TYPE Name[Size] = Value


#define DC_DATA_2D_ARRAY(TYPE, Name, Size1, Size2) \
            TYPE Name[Size1][Size2]

#define DC_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, Value) \
            const TYPE Name[Size1][Size2] = Value
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\bcd.h ===
//
// BCD.H
// Bitmap Compression & Decompression
//
// Copyright (c) Microsoft 1997-
//

#ifndef _H_BCD
#define _H_BCD



#define BCD_MATCHCOUNT      8192
#define BCD_NORMALSIZE      65000
#define BCD_XORSIZE         65000


//
// VERSION 2 RLE codes
//
//
// The following codes fill a full single byte address space.  The approach
// is to use the high order bits to identify the code type and the low
// order bits to encode the length of the associated run.  There are two
// forms of order
// - regular orders which have a 5 bit length field (31 bytes of data)
// - "lite" orders with a 4 bit length
//
// A value of 0 in the length field indicates an extended length, where
// the following byte contains the length of the data.  There is also a
// "mega mega" form which has a two byte length field. (See end of
// codespace of the codes that define the megamega form).
//
// A set of codes at the high end of the address space is used to encode
// commonly occuring short sequences, in particular
// - certain single byte FGBG codings
// - single bytes of BLACK and WHITE
//
//
// SUMMARY
// *******
//                      7 6 5 4 3 2 1 0  76543210  76543210  76543210
//
// MEGA_BG_RUN          0 0 0 0 0 0 0 0  <length>
//
// BG_RUN               0 0 0 <length->
//
// MEGA_FG_RUN          0 0 1 0 0 0 0 0  <length>
//
// FG_RUN               0 0 1 <length->
//
// MEGA_FG_BG_IMAGE     0 1 0 0 0 0 0 0  <length>  <-data->  ...
//
// FG_BG_IMAGE          0 1 0 <length->  <-data->  ...
//
// MEGA_COLOR_RUN       0 1 1 0 0 0 0 0  <length>  <-color>
//
// COLOR_RUN            0 1 1 <length->  <color->
//
// MEGA_COLOR_IMAGE     1 0 0 0 0 0 0 0  <length>  <-data->  ...
//
// COLOR_IMAGE          1 0 0 <length->  <-data->  ...
//
// MEGA_PACKED_CLR_IMG  1 0 1 0 0 0 0 0  <length>  <-data->  ...
//
// PACKED COLOR IMAGE   1 0 1 <length->  <-data->  ...
//
// SET_FG_MEGA_FG_RUN   1 1 0 0 0 0 0 0  <length>  <-color>
//
// SET_FG_FG_RUN        1 1 0 0 <-len->  <color->
//
// SET_FG_MEGA_FG_BG    1 1 0 1 0 0 0 0  <length>  <-color>  <-data->  ...
//
// SET_FG_FG_BG         1 1 0 1 <-len->  <color->  <-data->  ...
//
// MEGA_DITHERED_RUN    1 1 1 0 0 0 0 0  <length>  <-data->  <-data->
//
// DITHERED_RUN         1 1 1 0 <-len->  <-data->  <-data->
//
// MEGA_MEGA_BG_RUN     1 1 1 1 0 0 0 0
//
// MEGA_MEGA_FG_RUN     1 1 1 1 0 0 0 1
//
// MEGA_MEGA_FGBG       1 1 1 1 0 0 1 0
//
// MEGA_MEGA_COLOR_RUN  1 1 1 1 0 0 1 1
//
// MEGA_MEGA_CLR_IMG    1 1 1 1 0 1 0 0
//
// MEGA_MEGA_PACKED_CLR 1 1 1 1 0 1 0 1
//
// MEGA_MEGA_SET_FG_RUN 1 1 1 1 0 1 1 0
//
// MEGA_MEGA_SET_FGBG   1 1 1 1 0 1 1 1
//
// MEGA_MEGA_DITHER     1 1 1 1 1 0 0 0
//
// Special FGBG code 1  1 1 1 1 1 0 0 1  FGBG code 0x03 = 11000000
// (Note that 0x01 will generally handled by the single pel insertion code)
//
// Special FBBG code 2  1 1 1 1 1 0 1 0  FGBG code 0x05 = 10100000
//
// Special FBBG code 3  1 1 1 1 1 0 1 1  FGBG code 0x07 = 11100000
//
// Special FBBG code 4  1 1 1 1 1 1 0 0  FGBG code 0x0F = 11110000
//
// BLACK                1 1 1 1 1 1 0 1
//
// WHITE                1 1 1 1 1 1 1 0
//
// START_LOSSY          1 1 1 1 1 1 1 1
//
//
//
// GENERAL NOTES
//
//
// - For MEGA runs the length encoded is the length of the run minus the
//   maximum length of the non-mega form.
//   In  the mega-mega form we encode the plain 16 bit length, to keep
//   encoding/deconding simple.
//
// - The sequence BG_RUN,BG_RUN is not exactly what it appears.  We
//   use the fact that this is not generated in normal encoding to
//   encode <n background><1 foreground><n background>.  The same pel
//   insertion convention applies to any combination of MEGA_BG run and
//   BG_RUN
//
// - A packed image is encoded when we find that all the color fields in a
//   run have 0 in the high order nibble. We do not currently use this code
//   for 8 bit compression, but it is supported by the V2 decoder.
//
// - The set fg color code (Used to exist in V1) has been retired in favor
//   of separate commands for those codes that may embed a color.  Generally
//   This saves one byte for every foreground color transition for 8bpp.
//
// - The color run code is new for V2.  It indicates a color run where the
//   XOR is not performed.  This applies to, for example, the line of bits
//   immediately below a text line.  (There is no special case for runs of
//   the bg color - these are treated as any other color run.)
//
// - Observation shows a high occurrence of BG runs split by single FGBG
//   codes.  In decreasing probability these are 3,5,7,9,f,11,1f,3f (1 is
//   handled by the implicit BG run break). Save 1 byte by encoding as
//   single codes
//
// - There is a relatively high occurrence of single pel color codes ff and
//   00.  Save 1 byte by encoding as special characters
//
// - The length in a FGBG run is slightly strange.  Because they generally
//   occur in multiples of 8 bytes we get a big saving if we encode the
//   length of a short run as length/8.  However, for those special
//   cases where the length is not a multiple of 8 we encode a long run.
//   Therefore the long form can only cover the range 1-256 bytes.
//   beyond that we use the mega-mega form.
//
//
// DETAILS OF COMPRESSION CODES
//
//
// BG_RUN
//
// Represents a background run (black:0) of the specified length.
//
//
//
// FG_BG_IMAGE/SET_FG_FG_BG_IMAGE
//
// Represents a binary image containing only the current foreground(1) and
// background(0) colors.
//
//
//
// FG_RUN/SET_FG_FG_RUN
//
// Represents a continuous foreground run of the specified length.
// The foreground color is white by default, and is changed by the
// SET_FG_FG_RUN version of this code.
//
//
//
// DITHERED_RUN
//
// Represents a run of alternating colors of the specified length.
//
//
//
// COLOR_IMAGE
//
// Represents a color image of the specified length.  No XOR is performed.
// This data is uncompressed, so we hope that we won't see
// many of these codes!
//
//
//
// COLOR_RUN
//
// Represents a color run of the specified length.  No XOR is performed.
// Since the color is not XORed, it is unlikely to match the running
// foreground color information.  Therefore this code always carries a
// color byte and there is no SET_FG_COLOR_RUN form of the code.
//
//
//
// PACKED_COLOR_IMAGE
//
// Represents a color image of the specified length, with pairs of colors
// packed into a single byte.  (This can only be done when the color info
// is zero in the high order nibble.)
//
//
//
// START_LOSSY
//
// Informs the decoder that lossy mode has been established and any of the
// following color runs will need pixel doubling performing.
// RLE decoding will remain in this mode until the end of this block
//
//

#define CODE_MASK                   0xE0
#define CODE_MASK_LITE              0xF0

#define CODE_BG_RUN                 0x00   // 20
#define CODE_FG_RUN                 0x20   // 20
#define CODE_FG_BG_IMAGE            0x40   // 20
#define CODE_COLOR_RUN              0x60   // 20
#define CODE_COLOR_IMAGE            0x80   // 20
#define CODE_PACKED_COLOR_IMAGE     0xA0   // 20
#define CODE_SET_FG_FG_RUN          0xC0   // 10
#define CODE_SET_FG_FG_BG           0xD0   // 10
#define CODE_DITHERED_RUN           0xE0   // 10
#define CODE_MEGA_MEGA_BG_RUN       0xF0
#define CODE_MEGA_MEGA_FG_RUN       0xF1
#define CODE_MEGA_MEGA_FGBG         0xF2
#define CODE_MEGA_MEGA_COLOR_RUN    0xF3
#define CODE_MEGA_MEGA_CLR_IMG      0xF4
#define CODE_MEGA_MEGA_PACKED_CLR   0xF5
#define CODE_MEGA_MEGA_SET_FG_RUN   0xF6
#define CODE_MEGA_MEGA_SET_FGBG     0xF7
#define CODE_MEGA_MEGA_DITHER       0xF8
#define CODE_SPECIAL_FGBG_1         0xF9
#define CODE_SPECIAL_FGBG_2         0xFA
#define CODE_SPECIAL_FGBG_3         0xFB
#define CODE_SPECIAL_FGBG_4         0xFC
#define CODE_WHITE                  0xFD
#define CODE_BLACK                  0xFE
#define CODE_START_LOSSY            0xFF

#define MAX_LENGTH_ORDER            31
#define MAX_LENGTH_LONG_ORDER       287

#define MAX_LENGTH_ORDER_LITE       15
#define MAX_LENGTH_LONG_ORDER_LITE  271

#define MAX_LENGTH_FGBG_ORDER       (31*8)
#define MAX_LENGTH_FGBG_ORDER_LITE  (15*8)
#define MAX_LENGTH_LONG_FGBG_ORDER  255

//
// The special FGBG codes that correspond to codes F0-F7
//
#define SPECIAL_FGBG_CODE_1         0x03
#define SPECIAL_FGBG_CODE_2         0x05
#define SPECIAL_FGBG_CODE_3         0x07
#define SPECIAL_FGBG_CODE_4         0x0F

//
// Run types as stored in the run index array
//
#define RUN_BG                      1
#define RUN_BG_PEL                  2
#define RUN_FG                      3
#define RUN_COLOR                   4
#define RUN_DITHER                  5
#define IMAGE_FGBG                  6
#define IMAGE_COLOR                 7
#define IMAGE_LOSSY_ODD             8


//
// The following structure contains the results of our intermediate scan of
// the buffer.  The offset field contains the expected offset into the
// target buffer following decompression of the associated order and is
// used for self-diagnosis.
//
typedef struct
{
    WORD    length;
    BYTE    type;
    BYTE    fgChar;
}
MATCH;



//
// Function Prototypes
//
// Note that the function compresses the whole bitmap in one call.  However
// it performs two cycles internally, once for the first line and once for
// all subsequent lines.  pelsPerLine (the number of pels on a row) MUST be
// supplied.
//
// The paremeters should be obvious, save
//
// pLossy = pointer to flag indicating we maydiscard part of incompressible
//          data
//
// When lossy compression is enabled any color run carries only half the
// pels and they must be doubled up.  (Also the encoder replaces color on
// alternate lines with BG_RUN thus giving a fourfold reduction in the
// data, but the decoder does not need any special code to handle this).
//
// The encoder may decide not to honor the lossy request because the data
// is highly compressible anyway.  If it determines this then the lossy
// flag is reset so that the caller may determine whether a subsequent
// non-lossy transmission is required or not.
//
//


//
// Unpack4bpp
//
// Convert a 4bpp bitmap into an 8bpp one
//
void Unpack4bpp(LPBYTE destbuf,
                             LPBYTE srcbuf,
                             UINT   srclen);

//
// Pack4bpp
//
// Convert an 8bpp bitmap back to 4bpp
//
void Pack4bpp(LPBYTE destbuf,
                           LPBYTE srcbuf,
                           UINT   srclen);

//
// XORBuffer
//
// Create an XOR image of the input bitmap
//
void XORBuffer(LPBYTE destbuf, LPBYTE srcbuf, UINT srclen, int rowDelta);

//
// CompressV2Int
//
// Internal compresssion function
//
// The work buffer addresses are moved onto the stack, thus eliminating any
// need to use DS to address the default data segment.  This allows the
// compiler to perform more general optimizations.
//
UINT    CompressV2Int(LPBYTE pSrc,
                                  LPBYTE pDst,
                                  UINT   numPels,
                                  UINT   bpp,
                                  UINT   rowDelta,
                                  UINT   dstBufferSize,
                                  LPBOOL pLossy,
                                  LPBYTE nrmbuf,
                                  LPBYTE xorbuf,
                                  MATCH  FAR  *match);

UINT    DecompressV2Int(LPBYTE pSrc,
                                  LPBYTE pDst,
                                  UINT   bytes,
                                  UINT   bpp,
                                  UINT   rowDelta,
                                  LPBYTE nrmbuf);



//
// The Compressed Data header structure.
//
// Rather than add a field to indicate V1 vs V2 compression we use the
// fact that V2 compression treats all the bitmap as main body and sets
// the first row size to zero to distinguish them.  I hesitate to do this
// but any bandwidth saving is important.
//
typedef struct _CD_HEADER
{
    TSHR_UINT16     cbCompFirstRowSize;
    TSHR_UINT16     cbCompMainBodySize;
    TSHR_UINT16     cbScanWidth;
    TSHR_UINT16     cbUncompressedSize;
} CD_HEADER;
typedef CD_HEADER *PCD_HEADER;

#define IsV2CompressedDataHeader(p)  ((p)->cbCompFirstRowSize == 0)
#define SetV2CompressedDataHeader(p) ((p)->cbCompFirstRowSize = 0)


//
// Types of bitmap compression.
//
#ifdef _DEBUG // for assertion
#define RLE_V1     1
#endif
#define RLE_V2     2



//
//
// PROTOTYPES
//
//


#endif // _H_BCD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\cm.h ===
//
// Cursor Manager
//

#ifndef _H_CM
#define _H_CM


//
//
// CONSTANTS
//
//

//
// Maximum cursor sizes.
//
#define CM_MAX_CURSOR_WIDTH            32
#define CM_MAX_CURSOR_HEIGHT           32

//
// This is the maximum size of the cursor data for the combined 1bpp AND
// mask and n bpp XOR mask.  We currently allow for a 32x32 cursor at
// 32bpp.  In this case the AND mask consumes 32*32/8 bytes (128) and the
// XOR mask consumes 32*32*4 bytes (4096).  Total is 32*4 + 32*32*4, which
// is (32*4)*(1 + 32), which is (32*4)*33
//
#define CM_MAX_CURSOR_DATA_SIZE        \
    ((CM_MAX_CURSOR_WIDTH/8) * CM_MAX_CURSOR_HEIGHT * 33)


//
// Thresholds for color intensity to distinguish between 24bpp colors which
// map to black, white, or a hatch pattern
//
#define CM_WHITE_THRESHOLD  (TSHR_UINT32)120000
#define CM_BLACK_THRESHOLD  (TSHR_UINT32)40000


//
// Shadow cursor tag constant declarations.
//
#define	NTRUNCLETTERS	    5 // For CreateAbbreviatedName - "A. B."
#define MAX_CURSOR_TAG_FONT_NAME_LENGTH 64
#define CURSOR_TAG_FONT_HEIGHT  -11

//
// This defines the size of the tag.. careful if you change these
// values... they must define a tag that fits in a hardcoded 32x32 bitmap.
//
#define	TAGXOFF	8
#define	TAGYOFF	20
#define	TAGXSIZ 24
#define	TAGYSIZ	12


typedef struct tag_curtaginfo
{
	WORD cHeight;
	WORD cWidth;
	BYTE aAndBits[ 32 * 32 / 8 ];
	BITMAPINFO bmInfo; // includes foreground color
	RGBQUAD rgbBackground[1]; // describes background color
	BYTE aXorBits[ 32 * 32 / 8 ]; // packed bits follow BITMAPINFO, color table
}
CURTAGINFO, * PCURTAGINFO;



typedef struct tagCACHEDCURSOR
{
    HCURSOR  hCursor;
    POINT     hotSpot;
}
CACHEDCURSOR;
typedef CACHEDCURSOR * PCACHEDCURSOR;


//
// Information about a remote party's cursor.
//
//
//
//
// Calculates the number of bytes wide a cursor is given the width of the
// cursor in pels. Cursors are 1bpp and word padded.
//
#define CM_BYTES_FROM_WIDTH(width) ((((width)+15)/16)*2)


//
//
// TYPES
//
//

//
// A POINTL has 32-bit coords in both 16-bit and 32-bit code
//
typedef struct tagCM_SHAPE_HEADER
{
    POINTL  ptHotSpot;
    WORD    cx;
    WORD    cy;
    WORD    cbRowWidth;
    BYTE    cPlanes;
    BYTE    cBitsPerPel;
} CM_SHAPE_HEADER;
typedef CM_SHAPE_HEADER FAR * LPCM_SHAPE_HEADER;

typedef struct tagCM_SHAPE
{
    CM_SHAPE_HEADER     hdr;
    BYTE                Masks[1]; // 1bpp AND mask, followed by n bpp XOR mask
} CM_SHAPE;
typedef CM_SHAPE FAR * LPCM_SHAPE;


typedef struct tagCM_SHAPE_DATA
{
    CM_SHAPE_HEADER     hdr;
    BYTE                data[CM_MAX_CURSOR_DATA_SIZE];
}
CM_SHAPE_DATA;
typedef CM_SHAPE_DATA FAR * LPCM_SHAPE_DATA;



// Structure: CM_FAST_DATA
//
// Description: Shared memory data - cursor description and usage flag
//
//   cmCursorStamp     - Cursor identifier: an integer written by the
//                       display driver
//   bitmasks          - RGB bitmasks for >8bpp cursors
//   colorTable        - Color table for <= 8bpp cursors
//   cmCursorShapeData - Cursor definition (AND, XOR masks, etc)
//
//
//
//  Note that a PALETTEENTRY is a DWORD, same in 16-bit and 32-bit code
//
typedef struct tagCM_FAST_DATA
{
    DWORD                   cmCursorStamp;
    DWORD                   bitmasks[3];
    PALETTEENTRY            colorTable[256];
    CM_SHAPE_DATA           cmCursorShapeData;
}
CM_FAST_DATA;
typedef CM_FAST_DATA FAR * LPCM_FAST_DATA;



//
//
// MACROS
//
//
#define CURSOR_AND_MASK_SIZE(pCursorShape) \
    ((pCursorShape)->hdr.cbRowWidth * (pCursorShape)->hdr.cy)

#define ROW_WORD_PAD(cbUnpaddedRow) \
    (((cbUnpaddedRow) + 1) & ~1)

#define CURSOR_XOR_BITMAP_SIZE(pCursorShape)                                 \
                     (ROW_WORD_PAD(((pCursorShape)->hdr.cx *                 \
                                    (pCursorShape)->hdr.cBitsPerPel) / 8) *  \
                     (pCursorShape)->hdr.cy)

#define CURSOR_DIB_BITS_SIZE(cx, cy, bpp)   \
                                       (ROW_WORD_PAD(((cx) * (bpp))/8) * (cy))

#define CURSORSHAPE_SIZE(pCursorShape) \
    sizeof(CM_SHAPE_HEADER) +               \
    CURSOR_AND_MASK_SIZE(pCursorShape) +     \
    CURSOR_XOR_BITMAP_SIZE(pCursorShape)

//
// Null cursor indications
//
#define CM_CURSOR_IS_NULL(pCursor) ((((pCursor)->hdr.cPlanes==(BYTE)0xFF) && \
                                    (pCursor)->hdr.cBitsPerPel == (BYTE)0xFF))

#define CM_SET_NULL_CURSOR(pCursor) (pCursor)->hdr.cPlanes = 0xFF;          \
                                    (pCursor)->hdr.cBitsPerPel = 0xFF;

//
// Expands a particular bit into a byte.  The bits are zero-indexed and
// numbered from the left.  The allowable range for pos is 0 to 7
// inclusive.
//
#define BIT_TO_BYTE(cbyte, pos) \
             ( (BYTE) ((((cbyte) >> (7 - (pos))) & 0x01) ? 0xFF : 0x00))

//
// Get two bits from a byte.  The bits are zero-indexed and numbered from
// the left.  The allowable range for pos is 0 to 3 inclusive.
//
#define GET_TWO_BITS(cbyte, pos)                                \
  ( (BYTE) (((cbyte) >> (2 * (3 - (pos)))) & 0x03) )

//
// Return the maximum size of palette (in bytes) required for a DIB at a
// given bpp.  This is 2 ^ bpp for bpp < 8, or 0 for > 8 bpp
//
#define PALETTE_SIZE(BPP)   (((BPP) > 8) ? 0 : ((1<<(BPP)) * sizeof(RGBQUAD)))


//
// Return a pointer to the actual bitmap bits within a DIB.
//
#define POINTER_TO_DIB_BITS(pDIB)                     \
        ((void *) ((LPBYTE)(pDIB) + DIB_BITS_OFFSET(pDIB)) )

//
// Calculate the offset of the data bits in a DIB.
//
#define DIB_BITS_OFFSET(pDIB)                         \
        (PALETTE_SIZE((pDIB)->bmiHeader.biBitCount) +   \
        sizeof(BITMAPINFOHEADER))

//
// Trace out info about a DIB.  PH is a pointer to a BITMAPINFOHEADER
//
#define CAP_TRACE_DIB_DBG(PH, NAME)                                          \
    TRACE_OUT(( "%s: %#.8lx, %ld x %ld, %hd bpp, %s encoded",               \
        (NAME), (DWORD)(PH), (PH)->biWidth, (PH)->biHeight, (PH)->biBitCount,\
        ((PH)->biCompression == BI_RLE8) ? "RLE8"                            \
            : (((PH)->biCompression == BI_RLE4) ? "RLE4" : "not")))

//
// Is the parameter a pointer to a Device Dependant Bitmap?
//
#define IS_DIB(PARAM) (*((LPWORD)(PARAM)) == 0x28)

//
// Driver supports color_cursors and async SetCursor.  This value is taken
// from the Win95 DDK.
//
#define C1_COLORCURSOR  0x0800


//
//
// PROTOTYPES
//
//





//
// Specific values for OSI escape codes
//
#define CM_ESC(code)        (OSI_CM_ESC_FIRST + code)

#define CM_ESC_XFORM        CM_ESC(0)



//
//
// STRUCTURES
//
//


// Structure: CM_DRV_XFORM_INFO
//
// Description: Structure passed from the share core to the display driver
// to pass cursor transform data
//
typedef struct tagCM_DRV_XFORM_INFO
{
    OSI_ESCAPE_HEADER header;

    //
    // Share core -> display driver.
    // Pointers to AND mask.  Note that this user-space pointer is also
    // valid in the display driver realm (ring0 if NT, 16-bit if W95)
    //
    LPBYTE          pANDMask;
    DWORD           width;
    DWORD           height;

    //
    // Driver -> share core.
    //
    DWORD           result;

} CM_DRV_XFORM_INFO;
typedef CM_DRV_XFORM_INFO FAR * LPCM_DRV_XFORM_INFO;


//
//
// PROTOTYPES
//
//

#ifdef DLL_DISP

//
// Name:      CM_DDProcessRequest
//
// Purpose:   Process CM requests from the Share Core which have been
//            to the display driver through the DrvEscape mechanism.
//
// Returns:   TRUE if the request is processed successfully,
//            FALSE otherwise.
//
// Params:    IN     pso   - Pointer to surface object for our driver
//            IN     cjIn  - Size of the input data
//            IN     pvIn  - Pointer to the input data
//            IN     cjOut - Size of the output data
//            IN/OUT pvOut - Pointer to the output data
//

#ifdef IS_16
BOOL    CM_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
            DWORD cbResult);
#else
ULONG   CM_DDProcessRequest(SURFOBJ*  pso,
                                UINT  cjIn,
                                void *   pvIn,
                                UINT  cjOut,
                                void *   pvOut);
#endif


#ifdef IS_16
BOOL    CM_DDInit(HDC);
#else
BOOL    CM_DDInit(LPOSI_PDEV ppDev);
#endif  // IS_16


#ifdef IS_16
void    CM_DDViewing(BOOL fViewers);
#else
void    CM_DDViewing(SURFOBJ * pso, BOOL fViewers);
#endif // IS_16

//
// Name:      CM_DDTerm
//
// Purpose:   Terminates the display driver component of the cursor
//            manager.
//
// Params:    None.
//
void CM_DDTerm(void);


#endif // DLL_DISP


typedef void ( *PFNCMCOPYTOMONO) ( LPBYTE pSrc,
                                                    LPBYTE pDst,
                                                    UINT   cx,
                                                    UINT   cy );


//
// Cursor type (as required by CMMaybeSendCursor).  The values are:
//
//  DEFAULTCURSOR   - standard pointer
//  DISPLAYEDCURSOR - displayed (eg.  bitmap) cursor
//
#define CM_CT_DEFAULTCURSOR   1
#define CM_CT_DISPLAYEDCURSOR 2

//
// Types of displayed cursor:
//
//  UNKNOWN      - ONLY to be used by resyncing code
//  SYSTEMCURSOR - Standard windows cursor
//  BITMAPCURSOR - Displayed cursor
//
#define CM_CD_UNKNOWN         0
#define CM_CD_SYSTEMCURSOR    1
#define CM_CD_BITMAPCURSOR    2

typedef struct tagCURSORDESCRIPTION
{
    DWORD       type;
    DWORD       id;
} CURSORDESCRIPTION;
typedef CURSORDESCRIPTION FAR * LPCURSORDESCRIPTION;

typedef struct tagCURSORIMAGE
{
    WORD                xHotSpot;
    WORD                yHotSpot;
    BITMAPINFOHEADER    crHeader;
    BYTE                crMasks[1];
} CURSORIMAGE;
typedef CURSORIMAGE FAR *LPCURSORIMAGE;



#ifndef DLL_DISP



BOOL CMCreateAbbreviatedName(LPCSTR szTagName, LPSTR szBuf, UINT cbBuf);




//
// BOGUS LAURABU:
// We should use normal GDI StretchBlts to get the bitmap bits, not
// our own whacky pack/unpack code.
//
void CMCopy1bppTo1bpp( LPBYTE pSrc,
                                    LPBYTE pDst,
                                    UINT   cx,
                                    UINT   cy );

void CMCopy4bppTo1bpp( LPBYTE pSrc,
                                    LPBYTE pDst,
                                    UINT   cx,
                                    UINT   cy );

void CMCopy8bppTo1bpp( LPBYTE pSrc,
                                    LPBYTE pDst,
                                    UINT   cx,
                                    UINT   cy );

void CMCopy16bppTo1bpp( LPBYTE pSrc,
                                     LPBYTE pDst,
                                     UINT   cx,
                                     UINT   cy );

void CMCopy24bppTo1bpp( LPBYTE pSrc,
                                     LPBYTE pDst,
                                     UINT   cx,
                                     UINT   cy );

BOOL CMGetMonoCursor( LPTSHR_UINT16 pcxWidth,
                                   LPTSHR_UINT16 pcyHeight,
                                   LPTSHR_UINT16 pxHotSpot,
                                   LPTSHR_UINT16 pyHotSpot,
                                   LPBYTE  pANDBitmap,
                                   LPBYTE  pXORBitmap );



void  CMGetCurrentCursor(LPCURSORDESCRIPTION pCursor);

void CMCalculateColorCursorSize( LPCM_SHAPE pCursor,
                                              LPUINT      pcbANDMaskSize,
                                              LPUINT      pcbXORBitmapSize );

BOOL CMGetMonoCursorDetails( LPCM_SHAPE pCursor,
                                          LPTSHR_UINT16      pcxWidth,
                                          LPTSHR_UINT16      pcyHeight,
                                          LPTSHR_UINT16      pxHotSpot,
                                          LPTSHR_UINT16      pyHotSpot,
                                          LPBYTE       pANDBitmap,
                                          LPTSHR_UINT16      pcbANDBitmap,
                                          LPBYTE       pXORBitmap,
                                          LPTSHR_UINT16      pcbXORBitmap );


void CMRefreshWindowCursor(HWND window);


BOOL CMGetCursorShape( LPCM_SHAPE * ppCursorShape,
                                    LPUINT              pcbCursorDataSize );

HWND CMGetControllingWindow(void);


#define CM_SHM_START_READING  &g_asSharedMemory->cmFast[\
                   1 - g_asSharedMemory->fastPath.newBuffer]
#define CM_SHM_STOP_READING


#else


#ifdef IS_16
BOOL    CMDDSetTransform(LPCM_DRV_XFORM_INFO pResult);
void    CMDDJiggleCursor(void);
#else
BOOL    CMDDSetTransform(LPOSI_PDEV ppDev, LPCM_DRV_XFORM_INFO pXformInfo);
#endif


#define CM_SHM_START_WRITING  SHM_StartAccess(SHM_CM_FAST)
#define CM_SHM_STOP_WRITING   SHM_StopAccess(SHM_CM_FAST)



#endif // !DLL_DISP



#endif // _H_CM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\dcg.h ===
//
// DC Groupware Common stuff
//

#ifndef _H_DCG
#define _H_DCG



#include <stddef.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <memory.h>

#ifdef DLL_DISP

#ifdef IS_16
//
// Win16 Display Driver
//
#define STRICT
#define UNALIGNED
#include <windows.h>
#include <windowsx.h>


#define abs(A)  (((A) < 0)? -(A) : (A))

#define FIELD_OFFSET(type, field)       FIELDOFFSET(type, field)

#else

//
// Windows NT DDK include files (used to replace standard windows.h)       
//                                                                         
// The display driver runs in the Kernel space and so MUST NOT access any  
// Win32 functions or data.  Instead we can only use the Win32k functions  
// as described in the DDK.                                                
//
#include <ntddk.h>
#include <windef.h>
#include <wingdi.h>
#include <ntddvdeo.h>

#endif // IS_16

// DDI
#include <winddi.h>

// Debugging Macros
#include <drvdbg.h>


#else

#ifndef STRICT
#define STRICT
#endif

#define OEMRESOURCE
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <winable.h>


#include <mlzdbg.h> // multi-level zone debug header file
#include <oprahcom.h>

#endif // DLL_DISP


//
// DC_DATA macros to generate extern declarations.
// NOTE:  Keep this section in ssync with datainit.h, the header included
// by a file to actually generate storage for variables declared using the
// DC_DATA macros
//


#define DC_DATA(TYPE, Name) \
            extern TYPE Name

#define DC_DATA_VAL(TYPE, Name, Value) \
            extern TYPE Name

#define DC_CONST_DATA(TYPE, Name, Value) \
            extern const TYPE Name


#define DC_DATA_ARRAY(TYPE, Name, Size) \
            extern TYPE Name[Size]

#define DC_CONST_DATA_ARRAY(TYPE, Name, Size, Value) \
            extern const TYPE Name[Size]


#define DC_DATA_2D_ARRAY(TYPE, Name, Size1, Size2) \
            extern TYPE Name[Size1][Size2]

#define DC_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, Value) \
            extern const TYPE Name[Size1][Size2]



typedef UINT FAR*       LPUINT;


typedef UINT                        MCSID;
#define MCSID_NULL                  ((MCSID)0)


//
// T.128 PROTOCOL STRUCTURES
// These are defined in a way that keeps the offsets and total sizes the 
// same, regardless of whether this header is included in 32-bit code, 
// 16-bit code, big-endian code, etc.
//
// We make special types to avoid inadvertenly altering something else and
// breaking the structure.  The TSHR_ prefix helps make this clear.
//


#include <t_share.h>



//
// Defines the maximum number of BYTES allowed in a translated "shared by "
// string.                                                                 
//
#define DC_MAX_SHARED_BY_BUFFER     64
#define DC_MAX_SHAREDDESKTOP_BUFFER 64


//
// Registry prefix.                                                        
//
#define DC_REG_PREFIX             TEXT("SOFTWARE\\Microsoft\\Conferencing\\AppSharing\\")

//
// Limits                                                                  
//
#define MAX_TSHR_UINT16                 65535


//
// Return codes
//
#define UT_BASE_RC                     0x0000

#define OM_BASE_RC                     0x0200
#define OM_LAST_RC                     0x02FF

#define WB_BASE_RC                     0x0300
#define WB_LAST_RC                     0x03FF

#define NET_BASE_RC                    0x0700
#define NET_LAST_RC                    0x07FF

#define CM_BASE_RC                     0x0800
#define CM_LAST_RC                     0x08FF

#define AL_BASE_RC                     0x0a00
#define AL_LAST_RC                     0x0aFF


//
// Events                                                                  
// ======                                                                  
// This section lists the ranges available for each component when defining
// its events.  A component must not define events outside its permitted   
// range.                                                                  
//
#define UT_BASE_EVENT        (0x0600)   // Utility service events
#define UT_LAST_EVENT        (0x06FF)   // are in this range     

#define OM_BASE_EVENT        (0x0700)   // Object Manager events 
#define OM_LAST_EVENT        (0x07FF)   // are in this range     

#define NET_BASE_EVENT       (0x0800)   // Network layer events  
#define NET_LAST_EVENT       (0x08FF)   // are in this range     

#define CM_BASE_EVENT        (0x0900)   // Call Manager events   
#define CM_LAST_EVENT        (0x09FF)   // are in this range     

#define AL_BASE_EVENT        (0x0A00)   // Application Loader evts
#define AL_LAST_EVENT        (0x0AFF)   // are in this range     

#define SPI_BASE_EVENT       (0x0B00)   // SPI event numbers     
#define SPI_LAST_EVENT       (0x0BFF)

#define S20_BASE_EVENT       (0x0C00)   // S20 event numbers     
#define S20_LAST_EVENT       (0x0CFF)

//
// NOTE:  Keep this above WM_USER; WB reposts the events using the event
// as the message.  So it CANNOT conflict with an existing Win message.
//
#define WB_BASE_EVENT        (0x0D00)   // Whiteboard events     
#define WB_LAST_EVENT        (0x0DFF)   // are in this range     

#define SC_BASE_EVENT        (0x0E00)   // SC event numbers      
#define SC_LAST_EVENT        (0x0EFF)


#define DBG_INI_SECTION_NAME            "Debug"


//
// The GCC channel keys used with MG_ChannelJoinByKey.  They must be      
// unique.                                                                 
//                                                                         
// SFR6043: Modified these values from 41-43 to 421-423.  These values now 
// represent the default static channel numbers used.                      
//                                                                         
// FT (potentially) uses all key numbers in the range 600-1100.  If you add
// a new channel key, do not use a number in that range.                   
//
#define GCC_OBMAN_CHANNEL_KEY       421
#define GCC_AS_CHANNEL_KEY          422

//
// GCC Token keys                                                          
//
#define GCC_OBMAN_TOKEN_KEY         500



//
//                                                                         
// MACROS                                                                  
//                                                                         
//

#define DC_QUIT                        goto DC_EXIT_POINT


//
// DEBUG structure type stamps, to help us track memory leaks
//
#ifdef _DEBUG

typedef struct tagDBGSTAMP
{
    char    idStamp[8];
}
DBGSTAMP;

#define STRUCTURE_STAMP                 DBGSTAMP    stamp;
#define SET_STAMP(lpv, st)              lstrcpyn((lpv)->stamp.idStamp, "AS"#st, sizeof(DBGSTAMP))

#else

#define STRUCTURE_STAMP
#define SET_STAMP(lpv, st)

#endif // _DEBUG

//
// Cousin of the the FIELD macros supplied by 16-bit windows.h.       
//
#define FIELD_SIZE(type, field)   (sizeof(((type FAR *)0L)->field))


//
// Macro to round up a number to the nearest multiple of four.             
//
#define DC_ROUND_UP_4(x)  (((x) + 3L) & ~(3L))


//
// Unaligned pointer access macros -- first macros to extract an integer   
// from an UNALIGNED pointer.  Note that these macros assume that the      
// integer is in local byte order                                          
//
#ifndef DC_NO_UNALIGNED

#define EXTRACT_TSHR_UINT16_UA(pA)      (*(LPTSHR_UINT16_UA)(pA))
#define EXTRACT_TSHR_INT16_UA(pA)       (*(LPTSHR_INT16_UA)(pA))
#define EXTRACT_TSHR_UINT32_UA(pA)      (*(LPTSHR_UINT32_UA)(pA))
#define EXTRACT_TSHR_INT32_UA(pA)       (*(LPTSHR_INT32_UA)(pA))

#define INSERT_TSHR_UINT16_UA(pA,V)     (*(LPTSHR_UINT16_UA)(pA)) = (V)
#define INSERT_TSHR_INT16_UA(pA,V)      (*(LPTSHR_INT16_UA)(pA)) = (V)
#define INSERT_TSHR_UINT32_UA(pA,V)     (*(LPTSHR_UINT32_UA)(pA)) = (V)
#define INSERT_TSHR_INT32_UA(pA,V)      (*(LPTSHR_INT32_UA)(pA)) = (V)

#else

#define EXTRACT_TSHR_UINT16_UA(pA) ((TSHR_UINT16)  (((LPBYTE)(pA))[0]) |        \
                                    (TSHR_UINT16) ((((LPBYTE)(pA))[1]) << 8) )

#define EXTRACT_TSHR_INT16_UA(pA)  ((TSHR_INT16)   (((LPBYTE)(pA))[0]) |        \
                                    (TSHR_INT16)  ((((LPBYTE)(pA))[1]) << 8) )

#define EXTRACT_TSHR_UINT32_UA(pA) ((TSHR_UINT32)  (((LPBYTE)(pA))[0])        | \
                                    (TSHR_UINT32) ((((LPBYTE)(pA))[1]) << 8)  | \
                                    (TSHR_UINT32) ((((LPBYTE)(pA))[2]) << 16) | \
                                    (TSHR_UINT32) ((((LPBYTE)(pA))[3]) << 24) )

#define EXTRACT_TSHR_INT32_UA(pA)  ((TSHR_INT32)  (((LPBYTE)(pA))[0])        | \
                                    (TSHR_INT32) ((((LPBYTE)(pA))[1]) << 8)  | \
                                    (TSHR_INT32) ((((LPBYTE)(pA))[2]) << 16) | \
                                    (TSHR_INT32) ((((LPBYTE)(pA))[3]) << 24) )


#define INSERT_TSHR_UINT16_UA(pA,V)                                     \
             {                                                          \
                 (((LPBYTE)(pA))[0]) = (BYTE)( (V)     & 0x00FF);  \
                 (((LPBYTE)(pA))[1]) = (BYTE)(((V)>>8) & 0x00FF);  \
             }
#define INSERT_TSHR_INT16_UA(pA,V)  INSERT_TSHR_UINT16_UA(pA,V)

#define INSERT_TSHR_UINT32_UA(pA,V)                                           \
             {                                                              \
                 (((LPBYTE)(pA))[0]) = (BYTE)( (V)      & 0x000000FF); \
                 (((LPBYTE)(pA))[1]) = (BYTE)(((V)>>8)  & 0x000000FF); \
                 (((LPBYTE)(pA))[2]) = (BYTE)(((V)>>16) & 0x000000FF); \
                 (((LPBYTE)(pA))[3]) = (BYTE)(((V)>>24) & 0x000000FF); \
             }
#define INSERT_TSHR_INT32_UA(pA,V)  INSERT_TSHR_UINT32_UA(pA,V)


#endif




//
// Stamp type and macro: each module should use these when stamping its    
// data structures.                                                        
//
typedef TSHR_UINT32                       DC_ID_STAMP;

#define DC_MAKE_ID_STAMP(X1, X2, X3, X4)                                    \
   ((DC_ID_STAMP) (((DC_ID_STAMP) X4) << 24) |                                 \
                  (((DC_ID_STAMP) X3) << 16) |                                 \
                  (((DC_ID_STAMP) X2) <<  8) |                                 \
                  (((DC_ID_STAMP) X1) <<  0) )


//
// BOGUS LAURABU!
// COM_SIZEOF_RECT() was the old name of COM_SIZEOF_RECT_EXCLUSIVE(). But
// it was being used in the display driver on INCLUSIVE rects.  I fixed this,
// I changed it to use COM_SIZEOF_RECT_INCLUSIVE.  But this may uncover 
// other bugs.  The reason I found this--my 16-bit display driver generates
// no orders yet, all the DDI calls just add screen data.  So each little
// patblted strip, one pixel wide/high, gets sent via draw bounds as screen
// data.
//

__inline DWORD COM_SizeOfRectInclusive(LPRECT prc)
{
    return((DWORD)(prc->right+1-prc->left) * (DWORD)(prc->bottom+1-prc->top));
}

__inline DWORD COM_SizeOfRectExclusive(LPRECT prc)
{
    return((DWORD)(prc->right-prc->left) * (DWORD)(prc->bottom-prc->top));
}


//
// NORMAL rect<->rectl conversions
//
__inline void RECTL_TO_RECT(const RECTL FAR* lprclSrc, LPRECT lprcDst)
{
    lprcDst->left = lprclSrc->left;
    lprcDst->top = lprclSrc->top;
    lprcDst->right = lprclSrc->right;
    lprcDst->bottom = lprclSrc->bottom;
}


__inline void RECT_TO_RECTL(const RECT FAR* lprcSrc, LPRECTL lprclDst)
{
    lprclDst->left = lprcSrc->left;
    lprclDst->top = lprcSrc->top;
    lprclDst->right = lprcSrc->right;
    lprclDst->bottom = lprcSrc->bottom;
}


//
// This macro works on 32 bit unsigned ticks and returns TRUE if TIME is   
// between BEGIN and END (both inclusive) allowing for the wraparound.     
//
#define IN_TIME_RANGE(BEGIN, END, TIME)                                     \
    (((BEGIN) < (END)) ?                                                    \
    (((TIME) >= (BEGIN)) && ((TIME) <= (END))) :                            \
    (((TIME) >= (BEGIN)) || ((TIME) <= (END))))


//
// Convert BPP to number of colors.                                        
//
#define COLORS_FOR_BPP(BPP) (((BPP) > 8) ? 0 : (1 << (BPP)))


#define MAX_ITOA_LENGTH     18


#endif // _H_DCG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\drvdbg.h ===
//
// DRVDBG.H
// Display Driver (NT-only right now) Debug Macros
//
// Copyright(c) Microsoft 1997-
//

#ifndef _H_DRVDBG
#define _H_DRVDBG


#ifdef  ASSERT
#undef  ASSERT
#endif // ASSERT


#define CCH_DEBUG_MAX           256

// Standard Zones
#define ZONE_INIT               0x0001
#define ZONE_TRACE              0x0002
#define ZONE_FUNCTION           0x0004
#define ZONE_MASK               0x0007
#define ZONE_OAHEAPCHECK        0x0008



#ifndef DEBUG

#define DebugEntry(x)
#define DebugExitVOID(x)
#define DebugExitDWORD(x, dw)
#define DebugExitBOOL(x, f)
#define DebugExitPVOID(x, ptr)

#define TRACE_OUT(x)
#define WARNING_OUT(x)
#define ASSERT(x)

#else



void DbgZPrintFn(LPSTR szFn);
void DbgZPrintFnExitDWORD(LPSTR szFn, DWORD dwResult);
void DbgZPrintFnExitPVOID(LPSTR szFn, PVOID ptr);

#define DebugEntry(szFn)                DbgZPrintFn("ENTER "#szFn)
#define DebugExitVOID(szFn)             DbgZPrintFn("LEAVE "#szFn)
#define DebugExitDWORD(szFn, dwResult)  DbgZPrintFnExitDWORD("LEAVE "#szFn, dwResult)
#define DebugExitBOOL(szFn, fResult)    DbgZPrintFnExitDWORD("LEAVE "#szFn, fResult)
#define DebugExitPVOID(szFn, dwResult)  DbgZPrintFnExitPVOID("LEAVE "#szFn, dwResult)


void _cdecl DbgZPrintTrace(LPSTR pszFormat, ...);
void _cdecl DbgZPrintWarning(LPSTR pszFormat, ...);

#define TRACE_OUT(szMsg)                DbgZPrintTrace  szMsg
#define WARNING_OUT(szMsg)              DbgZPrintWarning  szMsg
#define ERROR_OUT(szMsg)                DbgZPrintError  szMsg


extern char g_szAssertionFailure[];

#define ASSERT(exp)                     if (!(exp)) ERROR_OUT((g_szAssertionFailure))



#endif // !DEBUG


//
// For driver start up tracing in retail as well
//
#if defined(DEBUG) || defined(INIT_TRACE)

void _cdecl DbgZPrintInit(LPSTR pszFormat, ...);
void _cdecl DbgZPrintError(LPSTR pszFormat, ...);

#define INIT_OUT(szMsg)                 DbgZPrintInit  szMsg
#define ERROR_OUT(szMsg)                DbgZPrintError  szMsg

#else

#define INIT_OUT(x)
#define ERROR_OUT(x)

#endif // DEBUG or INIT_TRACE



#endif // _H_DRVDBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\fh.h ===
//
// Font Handler
//

#ifndef _H_FH
#define _H_FH


//
// This is needed to define LPCOM_ORDER
//
#include <oa.h>


//
// Constants.
//

//
// The sent ID field is set up when we copy fonts to send; if we don't send
// the font we set it to this value:
//
#define FONT_NOT_SENT  (-1)

//
// Because a font can match to font ID zero, actually having an explicit
// 'no match' constant acts as an extra 'firewall'.  The remote match array
// is of UINTs, so we have to make this constant positive...
//
#define NO_FONT_MATCH  (0xffff)

//
// This dummy font id is used instead of a remote ID of 0 when we need to
// distinguish between a remote ID of 0, and a remote ID that on conversion
// to local gives zero.
//
#define DUMMY_FONT_ID   0xFFFF



//
// Font Width Table type.
//
typedef struct tagFHWIDTHTABLE
{
    BYTE     charWidths[256];
} FHWIDTHTABLE, FAR * PFHWIDTHTABLE;

//
// The local font structure contains the extra info we need for font
// matching; we can't change the NETWORKFONT structure because we have to
// maintain back compatibility
//
// This comment is slight tosh.  We can and do change NETWORKFONT (though
// only in a carefully managed way!).  The point is that the data outside
// of the Details field is only needed locally - it is not transmitted
// across the wire.
//
// Note that in FH_Init, we do a qsort, which assumes
// that the first thing in the LOCALFONT structure is the facename.  So
// bear this in mind if you change it.  We assume that the NETWORKFONT
// structure will always start with the facename.
//
typedef struct _LOCALFONT
{
    NETWORKFONT Details;                  // old structure - sent over wire
    TSHR_UINT16 lMaxBaselineExt;          // max height of this font
    char        RealName[FH_FACESIZE];    // Real font name
    TSHR_UINT32 SupportCode;              // font is supported - see below
}
LOCALFONT;
typedef LOCALFONT FAR * LPLOCALFONT;

//
// The following values are set in the SupportCode field of the LOCALFONT
// structure to indicate whether a font is supported in the current
// share. The values are designed to make it easy to calculate the lowest
// common denominator of two support codes (l.c.d.  = code1 & code2).
//
// A SupportCode contains the bit flag
//    FH_SC_MATCH if it describes any sort of match at all
//    FH_SC_ALL_CHARS if the match applies to all characters in the font,
//        as opposed to just the ASCII alphanumeric characters
//    FH_SC_EXACT if the match is considered exact,
//        as opposed to an approximate match
//
//
#define FH_SC_MATCH            1
#define FH_SC_ALL_CHARS        2
#define FH_SC_EXACT            4

//
// Forget it: no viable match.
//
#define FH_SC_NO_MATCH 0

//
// Every char is a good but not exact match.
//
#define FH_SC_APPROX_MATCH (FH_SC_MATCH | FH_SC_ALL_CHARS)

//
// Every char is likely to be an accurate match.
//
#define FH_SC_EXACT_MATCH (FH_SC_MATCH | FH_SC_ALL_CHARS | FH_SC_EXACT)

//
// Chars 20->7F are likely to be an accurate match.
//
#define FH_SC_EXACT_ASCII_MATCH (FH_SC_MATCH | FH_SC_EXACT)

//
// Chars 20->7F are likely to be good but not exact matches.
//
#define FH_SC_APPROX_ASCII_MATCH (FH_SC_MATCH)



//
// Structures and typedefs.
//
// The FONTNAME structure is used for each entry in the array of font
// names.
//
typedef struct tagFONTNAME
{
    char        szFontName[FH_FACESIZE];
}
FONTNAME;
typedef FONTNAME FAR * LPFONTNAME;


//
// Maximum number of fonts that we can handle at all.
//
#define FH_MAX_FONTS \
    (((TSHR_MAX_SEND_PKT - sizeof(FHPACKET)) / sizeof(NETWORKFONT)) + 1 )

//
// Size of index into local font table
//
#define FH_LOCAL_INDEX_SIZE  256


typedef struct tagFHFAMILIES
{
    STRUCTURE_STAMP

    UINT        fhcFamilies;
    FONTNAME    afhFamilies[FH_MAX_FONTS];
}
FHFAMILIES;
typedef FHFAMILIES FAR * LPFHFAMILIES;



//
// Local font list
//
// NOTE: The font index is an array of bookmarks that indicate the first
// entry in the local font table that starts with a particular character.
// For example, afhFontIndex[65] gives the first index in afhFonts
// that starts with the character 'A'.
//
//
typedef struct tagFHLOCALFONTS
{
    STRUCTURE_STAMP

    UINT        fhNumFonts;
    TSHR_UINT16 afhFontIndex[FH_LOCAL_INDEX_SIZE];
    LOCALFONT   afhFonts[FH_MAX_FONTS];
}
FHLOCALFONTS;
typedef FHLOCALFONTS FAR * LPFHLOCALFONTS;




//
// FUNCTION: FH_GetFaceNameFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the face name of the font.
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// pFaceNameLength - pointer to variable to receive the length of the face
// name returned.
//
// RETURNS: pointer to face name.
//
//
LPSTR  FH_GetFaceNameFromLocalHandle(UINT  fontHandle,
                                                  LPUINT faceNameLength);

UINT FH_GetMaxHeightFromLocalHandle(UINT  fontHandle);

//
// FUNCTION: FH_GetFontFlagsFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the FontFlags value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: font flags
//
//
UINT FH_GetFontFlagsFromLocalHandle(UINT  fontHandle);

//
// FUNCTION: FH_GetCodePageFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the CharSet value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: CodePage
//
//
UINT FH_GetCodePageFromLocalHandle(UINT  fontHandle);

//
// FUNCTION: FH_Init
//
// DESCRIPTION:
//
// This routine finds all the fonts in the local system.  It is called from
// USR.
//
// PARAMETERS: VOID
//
// RETURNS: Number of fonts found
//
//
UINT FH_Init(void);
void FH_Term(void);


//
// API FUNCTION: FH_CreateAndSelectFont
//
// DESCRIPTION:
//
// Creates a logical font for the HPS/HDC supplied.
//
// PARAMETERS:
//
// surface - surface to create logical font for.
//
// pHNewFont - pointer to new font handle to use. This is returned.
//
// pHOldFont - pointer to old font handle (which was previously selected
// into the HPS or HDC).
//
// fontName - the facename of the font.
//
// codepage - codepage (though in most case just holds charset)
//
// fontMaxHeight - the max baseline extent of the font. (Do not confuse
// with fontHeight which is the cell height of the font).
//
// fontWidth,fontWeight,fontFlags - take the same values as the equivalent
// fields in a TEXTOUT or EXTTEXTOUT order.
//
// RETURNS: TRUE - success, FALSE - failure.
//
BOOL FH_CreateAndSelectFont(HDC    hdc,
                                         HFONT *        pHNewFont,
                                         HFONT *        pHOldFont,
                                         LPSTR        fontName,
                                         UINT         codepage,
                                         UINT         fontMaxHeight,
                                         UINT         fontHeight,
                                         UINT         fontWidth,
                                         UINT         fontWeight,
                                         UINT         fontFlags);


//
// API FUNCTION: FH_DeleteFont
//
// DESCRIPTION:
//
// Deletes/frees the supplied system font handle.
//
// PARAMETERS:
//
//  sysFontHandle - system font handle to delete/free
//
// RETURNS:
//
//  None
//
void FH_DeleteFont(HFONT hFont);

//
// API FUNCTION: FH_SelectFont
//
// DESCRIPTION:
//
// Selects a font identified by its system font handle into a surface.
//
// PARAMETERS:
//
//  surface - the surface to select the font into
//  sysFontHandle - system font handle
//
// RETURNS:
//
//  None
//
void FH_SelectFont(HDC hdc, HFONT hFont);


void FHAddFontToLocalTable( LPSTR  faceName,
                                         TSHR_UINT16 fontFlags,
                                         TSHR_UINT16 codePage,
                                         TSHR_UINT16 maxHeight,
                                         TSHR_UINT16 aveHeight,
                                         TSHR_UINT16 aveWidth,
                                         TSHR_UINT16 aspectX,
                                         TSHR_UINT16 aspectY,
                                         TSHR_UINT16 maxAscent);



void FHConsiderAllLocalFonts(void);

void FHSortAndIndexLocalFonts(void);

int  FHComp(LPVOID p1, LPVOID p2);
void FH_qsort(LPVOID base, UINT num, UINT size);

// prototypes UT_qsort routines
void shortsort(char *lo, char *hi, unsigned  width);
void swap(char *p, char *q, unsigned int width);

// this parameter defines the cutoff between using quick sort and
// insertion sort for arrays; arrays with lengths shorter or equal to the
// below value use insertion sort

#define CUTOFF 8


BOOL FHGenerateFontWidthTable(PFHWIDTHTABLE pTable,
                                           LPLOCALFONT    pFontInfo,
                                           UINT        fontHeight,
                                           UINT        fontWidth,
                                           UINT        fontWeight,
                                           UINT        fontFlags,
                                           LPTSHR_UINT16     pMaxAscent);

BOOL FHGetStringSpacing(UINT fontHandle,
                                     UINT fontHeight,
                                     UINT fontWidth,
                                     UINT fontWeight,
                                     UINT fontFlags,
                                     UINT stringLength,
                                     LPSTR string,
                                     LPTSHR_INT16 deltaXArray);

//
// FHCalculateSignatures - see fh.c.
//
void FHCalculateSignatures(PFHWIDTHTABLE  pTable,
                                        LPTSHR_INT16       pSigFats,
                                        LPTSHR_INT16       pSigThins,
                                        LPTSHR_INT16       pSigSymbol);

//
// Although wingdi.h defines the first two parameters for an ENUMFONTPROC
// as LOGFONT and TEXTMETRIC (thereby disagreeing with MSDN), tests show
// that the structures are actually as defined in MSDN (i.e.  we get valid
// information when accessing the extended fields)
//
int CALLBACK FHEachFontFamily(
                            const ENUMLOGFONT   FAR * enumlogFont,
                            const NEWTEXTMETRIC FAR * TextMetric,
                            int                       FontType,
                            LPARAM                    lParam);

int CALLBACK FHEachFont(const ENUMLOGFONT   FAR * enumlogFont,
                              const NEWTEXTMETRIC FAR * TextMetric,
                              int                       FontType,
                              LPARAM                    lParam);


#endif // _H_FH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\dcs.h ===
//
// DC-Share Stuff
//

#ifndef _H_DCS
#define _H_DCS



//
// RESOURCES
//

#include <resource.h>



//
// We piggyback some extra flags into the ExtTextOut options.  We must
// ensure that we dont clash with the Windows defined ones.
//
#define     ETO_WINDOWS         (0x0001 | ETO_OPAQUE | ETO_CLIPPED)
#define     ETO_LPDX            0x8000U


//
// Debugging Options (also in retail)
//
// NOTE:  THESE MUST STAY IN SYNC WITH WHAT'S in \ui\conf\dbgmenu.*
//

// View one's own shared stuff in a frame to see what others are getting
#define VIEW_INI_VIEWSELF                    "ViewOwnSharedStuff"

// Hatch the areas sent as screen data from the host when viewing them
#define USR_INI_HATCHSCREENDATA             "HatchScreenData"

// Hatch the areas sent as bitmap orders from the host when viewing them
#define USR_INI_HATCHBMPORDERS               "HatchBitmapOrders"

// Turn off flow control
#define S20_INI_NOFLOWCONTROL               "NoFlowControl"

// Turn off OM compression
#define OM_INI_NOCOMPRESSION                "NoOMCompression"

//
// Change compression type (bunch of bit flags)
//      0x0000 (CT_NONE) is no compression
//      0x0001 (CT_PKZIP) is non-persistent dictionary PKZIP
//      0x0002 (CT_PERSIST_PKZIP) is persistent dictionary PKZIP
//
// Default value is 0x0003 (pkzip + persist pkzip)
//      
#define GDC_INI_COMPRESSION                 "GDCCompression"

//
// Change 2nd level order encoding (bunch of bitflags)
//      0x0001 (CAPS_ENCODING_BASE_OE)
//      0x0002 (CAPS_ENCODING_OE2_NEGOTIABLE)
//      0x0004 (CAPS_ENCODING_OE2_DISABLED)
//      0x0008 (CAPS_ENCODING_ALIGNED_OE)
//
// Default value is 0x0002
// To turn off 2nd level encoding, use 0x0006 (negotiable + disabled)
//
#define OE2_INI_2NDORDERENCODING            "2ndLevelOrderEncoding"


//
// Speedy link constant
//
#define DCS_FAST_THRESHOLD                      50000

//
// We will not compress packets smaller than this, whatever the link speed
//
#define DCS_MIN_COMPRESSABLE_PACKET             256

//
// We will not compress packets smaller than this on a fast link
// NOTE that is is the largest single T.120 preallocated packet size.
//
#define DCS_MIN_FAST_COMPRESSABLE_PACKET        8192

//
// We will not try to persistently compress packets larger than this
//
#define DCS_MAX_PDC_COMPRESSABLE_PACKET         4096





//
// Frequency (ms) with which the core performs timer tasks
//
// VOLUME_SAMPLE is the time beyond which we will take another sample of
// the bounds accumulation data.  If the screendata accumulated in this
// time is less than BOUNDS_ACCUM then we will try and send it immediately
// otherwise we wait until the orders have slowed down.
//
// UPDATE_PERIOD is the absolute maximum time between attempts to send data
//
// ANIMATION_SLOWDOWN id how many times we attempt to send mem-scrn blits
// over a PSTN connection.
//
// ANIMATION_DETECTION the interval, in mS, below which we determine the
// app is performing animation.  Must be low otherwise we slowdown during
// rapid typing.  The algorithm simply looks for repeated memblts to the
// same area
//
// DCS_ORDERS_TURNOFF_FREQUENCY
// The frequency of orders above which we start time slicing order
// transmission in order to give the host system a chance to draw the
// orders without having to send them in individual network packets.
//
// DCS_BOUNDS_TURNOFF_RATE
// Very important for performance of typing in Word that this value is not
// too low, since Word can generate 50K per keystroke.  On the other hand,
// it is important not to allow the capture of screendata until after an
// app that does a lot of blitting to the screen has finished.
//
// DCS_BOUNDS_IMMEDIATE_RATE
// To avoid sending excessive amounts of screendata we only send at the
// most ten times per second.  However, if the volumes are small then we
// override this to reduce latency
//
//
// The other rates control individual timer functions - see adcsapi.c for
// further details
// Note that the IM period is less than the likely rate of this function
// being scheduled.  This is set low so that we will, in general, call IM
// periodic every time to keep mouse moves flowing, but it will not be
// called repeatedly if there are several wakeups pending within a single
// scheduling cycle.
//
//
#define DCS_VOLUME_SAMPLE                       500
#define DCS_BOUNDS_TURNOFF_RATE              400000
#define DCS_BOUNDS_IMMEDIATE_RATE            100000
#define DCS_ORDERS_TURNOFF_FREQUENCY            100
#define DCS_SD_UPDATE_SHORT_PERIOD              100
#define DCS_SD_UPDATE_LONG_PERIOD              5000
#define DCS_ORDER_UPDATE_PERIOD                 100
#define DCS_FAST_MISC_PERIOD                    200
#define DCS_IM_PERIOD                            80



//
// Special Messages to synchronize APIs etc.
//
#if defined(DLL_CORE) || defined(DLL_HOOK)

#define DCS_FIRST_MSG               WM_APP

enum
{
    DCS_FINISH_INIT_MSG             = DCS_FIRST_MSG,
    DCS_PERIODIC_SCHEDULE_MSG,
    DCS_KILLSHARE_MSG,
    DCS_SHARE_MSG,
    DCS_UNSHARE_MSG,
    DCS_NEWTOPLEVEL_MSG,
    DCS_RECOUNTTOPLEVEL_MSG,
    DCS_TAKECONTROL_MSG,
    DCS_CANCELTAKECONTROL_MSG,
    DCS_RELEASECONTROL_MSG,
    DCS_PASSCONTROL_MSG,
    DCS_ALLOWCONTROL_MSG,
    DCS_GIVECONTROL_MSG,
    DCS_CANCELGIVECONTROL_MSG,
    DCS_REVOKECONTROL_MSG,
    DCS_PAUSECONTROL_MSG
};

#endif // DLL_CORE or DLL_HOOK



//
//
// PROTOTYPES
//
//


BOOL DCS_Init(void);
void DCS_FinishInit(void);
void DCS_Term(void);





//
// DCS_NotifyUI()
//
// DESCRIPTION:
// Called by app sharing to notify the front end of various changes and
// actions.
//
void DCS_NotifyUI(UINT event, UINT parm1, UINT parm2);


void DCSLocalDesktopSizeChanged( UINT width, UINT height );



#define DCS_MAIN_WINDOW_CLASS   "AS_MainWindow"


LRESULT CALLBACK DCSMainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);





#define SHP_POLICY_NOAPPSHARING         0x0001
#define SHP_POLICY_NOSHARING            0x0002
#define SHP_POLICY_NODOSBOXSHARE        0x0004
#define SHP_POLICY_NOEXPLORERSHARE      0x0008
#define SHP_POLICY_SHAREMASK            (SHP_POLICY_NODOSBOXSHARE | SHP_POLICY_NOEXPLORERSHARE)
#define SHP_POLICY_NODESKTOPSHARE       0x0010
#define SHP_POLICY_NOTRUECOLOR          0x0020

#define SHP_POLICY_NOCONTROL            0x2000
#define SHP_POLICY_NOOLDWHITEBOARD      0x8000

#define SHP_SETTING_TRUECOLOR           0x0001


//
// EVENTS
//

enum
{
    SH_EVT_APPSHARE_READY = SPI_BASE_EVENT,
    SH_EVT_SHARE_STARTED,
    SH_EVT_SHARING_STARTED,
    SH_EVT_SHARE_ENDED,
    SH_EVT_PERSON_JOINED,
    SH_EVT_PERSON_LEFT,
    SH_EVT_CONTROLLABLE,
    SH_EVT_STARTCONTROLLED,
    SH_EVT_STOPCONTROLLED,
    SH_EVT_PAUSEDCONTROLLED,
    SH_EVT_UNPAUSEDCONTROLLED,
    SH_EVT_STARTINCONTROL,
    SH_EVT_STOPINCONTROL,
    SH_EVT_PAUSEDINCONTROL,
    SH_EVT_UNPAUSEDINCONTROL
};


//
// Function PROTOTYPES
//



#if defined(DLL_CORE)

#include <ias.h>



HRESULT     SHP_GetPersonStatus(UINT dwID, IAS_PERSON_STATUS * pStatus);


#define SHP_DESKTOP_PROCESS     0xFFFFFFFF

HRESULT     SHP_LaunchHostUI(void);
BOOL        SHP_Share(HWND hwnd, IAS_SHARE_TYPE uType);
HRESULT     SHP_Unshare(HWND hwnd);


//
// COLLABORATION
//
HRESULT     SHP_TakeControl(IAS_GCC_ID PersonOf);
HRESULT     SHP_CancelTakeControl(IAS_GCC_ID PersonOf);
HRESULT     SHP_ReleaseControl(IAS_GCC_ID PersonOf);
HRESULT     SHP_PassControl(IAS_GCC_ID PersonOf, UINT PersonTo);

HRESULT     SHP_AllowControl(BOOL fAllow);
HRESULT     SHP_GiveControl(IAS_GCC_ID PersonTo);
HRESULT     SHP_CancelGiveControl(IAS_GCC_ID PersonTo);
HRESULT     SHP_RevokeControl(IAS_GCC_ID PersonTo);
HRESULT     SHP_PauseControl(IAS_GCC_ID PersonControlledBy, BOOL fPaused);


void        DCS_Share(HWND hwnd, IAS_SHARE_TYPE uType);
void        DCS_Unshare(HWND hwnd);

#endif // DLL_CORE



#endif // _H_DCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\gdc.h ===
//
// General Data Compression
//

#ifndef _H_GDC
#define _H_GDC


//
//
// CONSTANTS
//
//


//
// Scratch buffer mutex
//
#define GDC_MUTEX_NAME "GDCMutex"


//
// Compression Types (bit flags)
//
#define GCT_NOCOMPRESSION    0x0000
#define GCT_PKZIP            0x0001
#define GCT_PERSIST_PKZIP    0x0002
#define GCT_DEFAULT          (GCT_PKZIP | GCT_PERSIST_PKZIP)

//
// Compression Options for GCT_PKZIP
//
#define GDCCO_MAXSPEED        0
#define GDCCO_MAXCOMPRESSION  1



//
// Data sizes used to determine the saved dictionary space in our work 
// buffer.
//
#define GDC_DATA_SMALL          1024
#define GDC_DATA_MEDIUM         2048
#define GDC_DATA_MAX            4096


//
// Persistent Dictionaries used for compression/decompression
//
enum
{
    GDC_DICT_UPDATES = 0,
    GDC_DICT_MISC,
    GDC_DICT_INPUT,
    GDC_DICT_COUNT
};


typedef struct tagGDC_DICTIONARY
{
    UINT        cbUsed;                     // Amount of saved data
    BYTE        pData[GDC_DATA_MAX];      // Saved uncompressed data
} GDC_DICTIONARY;
typedef GDC_DICTIONARY * PGDC_DICTIONARY;


//
// Byte runs that can be replaced with smaller bit sequences
//
#define GDC_MINREP              2
#define GDC_MAXREP              (GDC_MINREP+(8*1)+2+4+8+16+32+64+128+256-4)
// GDC_MAXREP is 516, 129*4


//
// Holds uncompressed data for both compression/decompression
//
#define GDC_UNCOMPRESSED        (GDC_MAXREP + 2*GDC_DATA_MAX)

// 
// We don't need to double-buffer compressed data--we just read it out
// of the caller's source or write it into the caller's dest directly.
//
// NOTE:  With real PKZIP, which mostly reads from/writes to files,
// they don't have memory pointers containing raw data already.  That's
// whe original code we got used Read/Write routine callbacks.  This is
// no longer necessary.
//



//
// Random, little understood PKZIP table values, codes
//
#define KMP_THRESHOLD       10


#define GDC_LIT_SIZE        (256 + GDC_MAXREP + 2) 
// GDC_LIT_SIZE is 774


// EOF is last index of Lit array
#define EOF_CODE            (GDC_LIT_SIZE-1)
#define ABORT_CODE          (EOF_CODE+1)


//
// EXT_DIST_BITS is the # of bits needed to store an index into a GDC_DIST_SIZE
// array.  That's defined to be 64, which is 2^6, hence 6 bits.  Smaller
// dictionary compressions use fewer bits and hence not all of the DIST
// items.  The mask
// is used to pull the 6-bit sized index out of a byte.
//
#define GDC_DIST_SIZE               64

#define EXT_DIST_BITS_MIN           4
#define EXT_DIST_BITS_MEDIUM        5
#define EXT_DIST_BITS_MAC           6


#define GDC_LEN_SIZE                16
#define GDC_DECODED_SIZE            256


//
// The hash function has 4*256+5*256 different values, which means
// we need that many entries in our hash array.
//
#define GDC_HASHFN(x)               (4*(x)[0] + 5*(x)[1])
#define GDC_HASH_SIZE               (4*256 + 5*256)





//
// Structure:   GDC_IMPLODE
//
// Workspace for compressing our data.  We have simplified and shrunk this
// structure a fair amount, by having constant code/bit tables and not
// double-buffering the compressed result.  PKZIP's implode calculates the
// LitBits & LitCodes every time through (rather than storing 2 774 byte
// arrays in data--which would be a pain to declare anyway!), and makes a 
// private copy of the DistBits & DistCodes.  
//

typedef struct tagGDC_IMPLODE
{
    //
    // NO SOURCE INFO--we copy source chunks and maybe dictionary into 
    // RawData.  Then at the end we copy RawData back into the dictionary
    // if there is one.
    //

    //
    // Destination info
    //
    LPBYTE              pDst;       // Current Dest ptr (advances as we write)
    UINT                cbDst;      // Amount of Dest left (shrinks as we write)
    UINT                iDstBit;    // Current bit pos in Current Dest ptr byte

    //
    // Compression info
    //
    UINT                cbDictSize;
    UINT                cbDictUsed;
    UINT                ExtDistBits;
    UINT                ExtDistMask;

    //
    // Working info
    //
    UINT                Distance;            
    UINT                ibRawData;

    // NOTE: GDC_UNCOMPRESSED is a multiple of 4
    BYTE                RawData[GDC_UNCOMPRESSED];

    // NOTE:  This is DWORD aligned (GDC_MAXREP is a multiple of 4
    // and the extra 2 WORDS == 1 DWORD
    short               Next[2 + GDC_MAXREP];

    // NOTE: GDC_UNCOMPRESED is a multiple of 4
    WORD                SortArray[GDC_UNCOMPRESSED];

    // NOTE: This is DWORD aligned since GDC_HASH_SIZE is a multiple of 4
    WORD                HashArray[GDC_HASH_SIZE];
} GDC_IMPLODE, * PGDC_IMPLODE;



//
// GDC_EXPLODE
// Workspace for uncompressing our data.  We have vastly simplified and
// shrunk this structure as per the comments for GDC_IMPLODE.
//

typedef struct tagGDC_EXPLODE
{
    //
    // Source info
    //
    LPBYTE              pSrc;       // Current Src ptr (advances as we read)
    UINT                cbSrc;      // Amount of Src left (shrinks as we read)
    UINT                SrcByte;    // Look ahead byte in source
    UINT                SrcBits;    // Remainded src bits

    //
    // NO DEST INFO--we copy maybe dictionary into RawData at the beginning.
    // Then at the end we maybe copy RawData back into the dictionary.
    //

    //
    // Compression info
    //
    UINT                ExtDistBits;
    UINT                ExtDistMask;
    UINT                cbDictUsed;

    UINT                Distance;   
    UINT                iRawData;   // Current index into RawData
    BYTE                RawData[GDC_UNCOMPRESSED];
} GDC_EXPLODE, *PGDC_EXPLODE;


#define GDC_WORKBUF_SIZE    max(sizeof(GDC_IMPLODE), sizeof(GDC_EXPLODE))



//
// EXTERNAL FUNCTIONS
//

//
// API FUNCTION: GDC_Init()
//
// DESCRIPTION:
//
// Initialises the General Data Compressor.
// Must be called before any other GDC functions.
//
// PARAMETERS:
//
//
//
void GDC_Init(void);



//
// FUNCTION: GDC_Compress(..)
//
// DESCRIPTION:
//
// Compresses source data into a destination buffer.
//
//
// PARAMETERS:
//
// pDictionary              - NULL if old PKZIP, valid ptr if persistent
//
// Options                  - specifies whether speed of compression or
//      size of the compressed data is the most important factor.  This
//      basically affects the amount of previous data saved for looking
//      backwards.  MAXSPEED means smaller dictionary.  MAXCOMPRESSION
//      means a bigger one.  The dictionary size is basically the amount
//      of overlap in the source data used when calculating the hash
//      index.
//
//   GDCCO_MAXSPEED         - compress the data as quickly as possible, at
//                            the expense of increased compressed data size
//
//   GDCCO_MAXCOMPRESSION   - compress the data as much as possible, at the
//                            expense of increased compression time.
// With a persistent dictionary, only GDCCO_MAXCOMPRESSION is meaningful.
//
// pSrc                     - pointer to the source (uncompressed) data.
//
// cbSrcSize                - the number of bytes of source.
//
// pDst                     - pointer to the destination, where the
//                            compressed result will go.
//
// pcbDstSize               - pointer to the maximum amount the destina-
//                            tion can hold.  If the compressed result ends
//                            up being bigger than this amount, we bail
//                            out and don't compress the source at all.
//                            Otherwise the resulting size is written back.
//
// RETURNS:
//
// TRUE if success, FALSE if failure.
//
//
BOOL GDC_Compress
(
    PGDC_DICTIONARY     pDictionary,
    UINT                Options,
    LPBYTE              pWorkBuf,
    LPBYTE              pSrc,
    UINT                cbSrcSize,
    LPBYTE              pDst,
    UINT *              pcbDstSize
);


//
// API FUNCTION: GDC_Decompress(..)
//
// DESCRIPTION:
//
// Decompresses source data into a destination buffer.
//
//
// PARAMETERS:
//
// pDictionary              - NULL if old PKZIP, ptr to saved data if
//                            persistent.
//
// pSrc                     - pointer to the source (compressed) data.
//
// cbSrcSize                - the number of bytes of source.
//
// pDst                     - pointer to the destination, where the
//                            uncompressed result will go.
//
// pcbDstSize               - pointer to the maximum amount the desina-
//                            tion can hold.  If the uncompressed result
//                            ends up being bigger than this amount, we
//                            bail out since we can't decompress it.
//                            Otherwise the resulting size is written back.
//
// RETURNS:
//
// TRUE if success, FALSE if failure.

//
BOOL GDC_Decompress
(
    PGDC_DICTIONARY     pDictionary,
    LPBYTE              pWorkBuf,
    LPBYTE              pSrc,
    UINT                cbSrcSize,
    LPBYTE              pDst,
    UINT *              pcbDstSize
);




//
// INTERNAL FUNCTIONS
//


void GDCCalcDecode(const BYTE * pBits, const BYTE * pCodes, UINT size, LPBYTE pDecode);

LPBYTE GDCGetWorkBuf(void);
void   GDCReleaseWorkBuf(LPBYTE);


UINT GDCFindRep(PGDC_IMPLODE pgdcImp, LPBYTE Start);

void GDCSortBuffer(PGDC_IMPLODE pgdcImp, LPBYTE low, LPBYTE hi);

BOOL GDCOutputBits(PGDC_IMPLODE pgdcImp, WORD Cnt, WORD Code);



UINT GDCDecodeLit(PGDC_EXPLODE);

UINT GDCDecodeDist(PGDC_EXPLODE pgdcExp, UINT Len);

BOOL GDCWasteBits(PGDC_EXPLODE pgdcExp, UINT Bits);


#endif // _H_GDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\ndcgver.h ===
//
// NDCGVER.H
// NM app sharing version for display driver/app checking
//
// Copyright (c) Microsoft 1997-
//
#define DCS_BUILD_STR "4.3.0."VERSIONBUILD_STR

#define DCS_BUILD_NUMBER    0

//
// This allows the ring 3 code and ring 0 code to check each other, make
// sure they are the same version.  We're changing setup and getting close
// to shipping version 2.0, we want to prevent weird faults and blue
// screens caused by mismatched components.  This is not something we will
// do forever.  When NT 5 is here, we'll dyna load and init our driver at
// startup and terminate it at shutdown.  But for now, since installing
// one of these beasts is messsy, an extra sanity check is a good thing.
//
#define DCS_PRODUCT_NUMBER  3               // Version 3.0 of NM
#define DCS_MAKE_VERSION()  MAKELONG(VERSIONBUILD, DCS_PRODUCT_NUMBER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\host.h ===
//
// Hosting (local or remote)
//

#ifndef _H_HET
#define _H_HET



//
// DC-Share includes
//
#include <osi.h>




//
// Names of special classes
//

#define HET_MENU_CLASS          "#32768"        // Moved around
#define HET_TOOLTIPS98_CLASS    "ToolTips"      // Win98 moved around
#define HET_TOOLTIPSNT5_CLASS   "#32774"        // NT5 moved around
#define HET_DIALOG_CLASS        "#32770"
#define HET_SCREEN_SAVER_CLASS  "WindowsScreenSaverClass"
#define HET_OLEDRAGDROP_CLASS   "CLIPBRDWNDCLASS"

//
// Policy windows
//
#define HET_CMD95_CLASS         "tty"
#define HET_CMDNT_CLASS         "ConsoleWindowClass"
#define HET_EXPLORER_CLASS      "ExploreWClass"
#define HET_CABINET_CLASS       "CabinetWClass"

//
// Maximum size of a class name queried.  This should be at least as large
// as the size of HET_MENU_CLASS, HET_PROPERTY_CLASS and
// HET_SCREEN_SAVER_CLASS.
//
#define HET_CLASS_NAME_SIZE     32


#if defined(DLL_CORE)


//
// Refresh timer
//
#define IDT_REFRESH         51
#define PERIOD_REFRESH      10000

typedef struct tagHOSTENUM
{
    BASEDLIST       list;
    UINT            count;
    UINT            countShared;
}
HOSTENUM, * PHOSTENUM;


BOOL    HET_GetAppsList(IAS_HWND_ARRAY **ppHwnds);
void    HET_FreeAppsList(IAS_HWND_ARRAY * pArray);

BOOL    HET_IsWindowShareable(HWND hwnd);
BOOL    HET_IsWindowShared(HWND hwnd);
BOOL CALLBACK HostEnumProc(HWND, LPARAM);


BOOL    HET_Init(void);
void    HET_Term(void);

INT_PTR CALLBACK HostDlgProc(HWND, UINT, WPARAM, LPARAM);
void    HOST_InitDialog(HWND);
void    HOST_OnCall(HWND, BOOL);
void    HOST_OnSharing(HWND, BOOL);
void    HOST_OnControllable(HWND, BOOL);
void    HOST_UpdateTitle(HWND, UINT);
BOOL    HOST_MeasureItem(HWND, LPMEASUREITEMSTRUCT);
BOOL    HOST_DeleteItem(HWND, LPDELETEITEMSTRUCT);
BOOL    HOST_DrawItem(HWND, LPDRAWITEMSTRUCT);
void    HOST_EnableCtrl(HWND, UINT, BOOL);

enum
{
    CHANGE_UNSHARED = 0,
    CHANGE_SHARED,
    CHANGE_TOGGLE,
    CHANGE_ALLUNSHARED
};
void    HOST_ChangeShareState(HWND hwnd, UINT change);

void    HOST_FillList(HWND hwnd);
void    HOST_OnSelChange(HWND hwnd);



//
// Private messages to host dialog
//
enum
{
    HOST_MSG_OPEN = WM_APP,
    HOST_MSG_CLOSE,
    HOST_MSG_CALL,
    HOST_MSG_UPDATELIST,
    HOST_MSG_HOSTSTART,
    HOST_MSG_HOSTEND,
    HOST_MSG_ALLOWCONTROL,
    HOST_MSG_CONTROLLED
};


//
// Host dialog list item
//
typedef struct HOSTITEM
{
    HWND    hwnd;
    HICON   hIcon;
    BOOL    fShared:1;
    BOOL    fAvailable:1;
}
HOSTITEM, * PHOSTITEM;

#endif // DLL_CORE

//
// Hosting Property name
//
#define HET_ATOM_NAME               "MNMHosted"


//
// Property values, flags
//

//
// Here's the general idea with the following cases:
//
// An explictly shared process/thread
//      We enumerate all its top level windows, and mark the showing ones
//      with the VISIBLE option, which contributes to the hosted count,
//      and mark the hidden ones with the INVISIBLE option.  Those become
//      hosted VISIBLE the second they are shown.  They will always
//      be shared as long as they exist or the process/thread is shared.
//
//      From then on, we watch for CREATEs of new top level windows in the
//      same process, and mark them the same way.
//
//      On SHOWs, we change the state to visible, and update the visible
//      top level count.  On HIDEs, we change the state to invisible, and
//      update the visible top level count.  We wipe any properties off
//      real children to make sure that SetParent() of a top level window
//      (like OLE insitu) to a child doesn't keep garbage around.  We do
//      the opposite for children that have become top level, like tear off
//      toolbars.  On a SHOW, if there are other non-TEMPORARY hosted windows
//      in the same thread/process, we mark this dude as shared also.
//
// Unshared process/thread
//      On CREATE, if this is the first window in this thread/process, and
//      its parent process is shared (has at least one shared window of any
//      kind, temporary or invisible even, we mark this guy.  From then on,
//      it behaves like an explicitly shared process.
//
//      On SHOW, if this is a top level window, we look for any other window
//      visible on this thread which is shared.  If so, we show this one
//      TEMPORARILY also.  We also look at the owner of this window.  If
//      it is shared in any way, we also share this one TEMPORARILY.  When
//      TEMP shared, we enum all other windows in this thread and mark
//      the visible ones as TEMP shared also.  This takes care of the cached
//      global popup menu window case.
//
//      On HIDE, if this is TEMP shared, we unshare it.  This is only for
//      the BYWINDOW case.
//
// WINHLP32.EXE
//      Creation the first time works normally via task tracking.  But
//      if you have Help up in one app then go to another app, not shared,
//      and choose Help, it will come up shared there also.  WINHLP32 doesn't
//      go away, it keeps a couple invisible MS_ class windows around.  The
//      dialogs are destroyed.
//

//
// Classes to skip
//

// Flags:
#define HET_HOSTED_BYPROCESS    0x0010
#define HET_HOSTED_BYTHREAD     0x0020
#define HET_HOSTED_BYWINDOW     0x0040      // CURRENTLY ONLY FOR TEMPORARY

// Hosted types:
#define HET_HOSTED_PERMANENT    0x0001
#define HET_HOSTED_TEMPORARY    0x0002
#define HET_HOSTED_MASK         0x000F

// App types
#define HET_WOWVDM_APP          0x0001
#define HET_WINHELP_APP         0x0002      // Not used, but maybe someday

//
// NOTE that all HET_ property values are non-zero.  That way all possible
// permutations of known properties are non-zero.  Only windows with no
// property at all will get zero back from HET_GetHosting().
//


#if (defined(DLL_CORE) || defined(DLL_HOOK))

UINT_PTR __inline HET_GetHosting(HWND hwnd)
{
    extern ATOM g_asHostProp;

    return((UINT_PTR)GetProp(hwnd, MAKEINTATOM(g_asHostProp)));
}

BOOL __inline HET_SetHosting(HWND hwnd, UINT_PTR hostType)
{
    extern ATOM g_asHostProp;

    return(SetProp(hwnd, MAKEINTATOM(g_asHostProp), (HANDLE)hostType));
}


UINT_PTR __inline HET_ClearHosting(HWND hwnd)
{
    extern ATOM g_asHostProp;

    return((UINT_PTR)RemoveProp(hwnd, MAKEINTATOM(g_asHostProp)));
}

typedef struct tagGUIEFFECTS
{
    UINT_PTR            hetAdvanced;
    UINT_PTR            hetCursorShadow;
    ANIMATIONINFO   hetAnimation;
}
GUIEFFECTS;

void  HET_SetGUIEffects(BOOL fOn, GUIEFFECTS * pEffects);



#endif // DLL_CORE or DLL_HOOK


//
// Define escape codes
//

// These are normal
enum
{
    // These are normal
    HET_ESC_SHARE_DESKTOP       = OSI_HET_ESC_FIRST,
    HET_ESC_UNSHARE_DESKTOP,
    HET_ESC_VIEWER
};


// These are WNDOBJ_SETUP
enum
{
    HET_ESC_SHARE_WINDOW = OSI_HET_WO_ESC_FIRST,
    HET_ESC_UNSHARE_WINDOW,
    HET_ESC_UNSHARE_ALL
};



//
// Structure passed with a HET_ESC_SHARE_WINDOW request
//
typedef struct tagHET_SHARE_WINDOW
{
    OSI_ESCAPE_HEADER   header;
    DWORD_PTR           winID;          // window to share
    DWORD               result;         // Return code from HET_DDShareWindow
}
HET_SHARE_WINDOW;
typedef HET_SHARE_WINDOW FAR * LPHET_SHARE_WINDOW;

//
// Structure passed with a HET_ESC_UNSHARE_WINDOW request
//
typedef struct tagHET_UNSHARE_WINDOW
{
    OSI_ESCAPE_HEADER   header;
    DWORD_PTR               winID;          // window to unshare
}
HET_UNSHARE_WINDOW;
typedef HET_UNSHARE_WINDOW FAR * LPHET_UNSHARE_WINDOW;

//
// Structure passed with a HET_ESC_UNSHARE_ALL request
//
typedef struct tagHET_UNSHARE_ALL
{
    OSI_ESCAPE_HEADER   header;
}
HET_UNSHARE_ALL;
typedef HET_UNSHARE_ALL FAR * LPHET_UNSHARE_ALL;


//
// Structure passed with HET_ESC_SHARE_DESKTOP
//
typedef struct tagHET_SHARE_DESKTOP
{
    OSI_ESCAPE_HEADER   header;
}
HET_SHARE_DESKTOP;
typedef HET_SHARE_DESKTOP FAR * LPHET_SHARE_DESKTOP;


//
// Structure passed with HET_ESC_UNSHARE_DESKTOP
//
typedef struct tagHET_UNSHARE_DESKTOP
{
    OSI_ESCAPE_HEADER   header;
}
HET_UNSHARE_DESKTOP;
typedef HET_UNSHARE_DESKTOP FAR * LPHET_UNSHARE_DESKTOP;


//
// Structure passed with HET_ESC_VIEWER
//
typedef struct tagHET_VIEWER
{
    OSI_ESCAPE_HEADER   header;
    LONG                viewersPresent;
}
HET_VIEWER;
typedef HET_VIEWER FAR * LPHET_VIEWER;



#ifdef DLL_DISP

#ifndef IS_16
//
// Number of rectangles allocated per window structure.  If a visible
// region exceeds that number, we will merge rects together and end up
// trapping a bit more output than necessary.
//
#define HET_WINDOW_RECTS        10


//
// HET's version of ENUMRECTS.  This is the same as Windows', except that
// it has HET_WINDOW_RECTS rectangles, not 1
//
typedef struct tagHET_ENUM_RECTS
{
    ULONG   c;                          // count of rectangles in use
    RECTL   arcl[HET_WINDOW_RECTS];     // rectangles
} HET_ENUM_RECTS;
typedef HET_ENUM_RECTS FAR * LPHET_ENUM_RECTS;

//
// The Window Structure kept for each tracked window
//
typedef struct tagHET_WINDOW_STRUCT
{
    BASEDLIST           chain;             // list chaining info
    HWND             hwnd;              // hwnd of this window
    WNDOBJ         * wndobj;            // WNDOBJ for this window
    HET_ENUM_RECTS   rects;             // rectangles
} HET_WINDOW_STRUCT;
typedef HET_WINDOW_STRUCT FAR * LPHET_WINDOW_STRUCT;


//
// Initial number of windows for which space is allocated
// We alloc about 1 page for each block of windows.  Need to account for
// the BASEDLIST at the front of HET_WINDOW_MEMORY.
//
#define HET_WINDOW_COUNT        ((0x1000 - sizeof(BASEDLIST)) / sizeof(HET_WINDOW_STRUCT))


//
// Layout of memory ued to hold window structures
//
typedef struct tagHET_WINDOW_MEMORY
{
    BASEDLIST              chain;
    HET_WINDOW_STRUCT   wnd[HET_WINDOW_COUNT];
} HET_WINDOW_MEMORY;
typedef HET_WINDOW_MEMORY FAR * LPHET_WINDOW_MEMORY;

#endif // !IS_16



#ifdef IS_16

void    HETDDViewing(BOOL fViewers);

#else

void    HETDDViewing(SURFOBJ *pso, BOOL fViewers);

BOOL    HETDDShareWindow(SURFOBJ *pso, LPHET_SHARE_WINDOW  pReq);
void    HETDDUnshareWindow(LPHET_UNSHARE_WINDOW  pReq);
void    HETDDUnshareAll(void);

BOOL    HETDDAllocWndMem(void);
void    HETDDDeleteAndFreeWnd(LPHET_WINDOW_STRUCT pWnd);

VOID CALLBACK HETDDVisRgnCallback(WNDOBJ *pwo, FLONG fl);
#endif


#endif // DLL_DISP




//
// HET_IsShellThread()
// HET_IsShellWindow()
// Returns TRUE if this window is in the thread of the tray or the desktop
// and therefore should be ignored.
//

BOOL HET_IsShellThread(DWORD dwThreadID);
BOOL HET_IsShellWindow(HWND hwnd);




#ifdef DLL_DISP

//
// INIT, TERM.  TERM is used to free the window list blocks when NetMeeting
// shuts down.  Otherwise that memory will stay allocated in the display
// driver forever.
//

void HET_DDTerm(void);


//
//
// Name:        HET_DDProcessRequest
//
// Description: Handle a DrvEscape request for HET
//
// Params:      pso   - pointer to a SURFOBJ
//              cjIn  - size of input buffer
//              pvIn  - input buffer
//              cjOut - size of output buffer
//              pvOut - output buffer
//
//
#ifdef IS_16

BOOL    HET_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);

#else

ULONG   HET_DDProcessRequest(SURFOBJ  *pso,
                                        UINT cjIn,
                                        void *  pvIn,
                                        UINT cjOut,
                                        void *  pvOut);
#endif // IS_16


//
//
// Name:        HET_DDOutputIsHosted
//
// Description: determines whether a point is inside a hosted area
//
// Params:      pt - point to query
//
// Returns:     TRUE  - output is hosted
//              FALSE - output is not hosted
//
// Operation:
//
//
BOOL HET_DDOutputIsHosted(POINT pt);


//
//
// Name:        HET_DDOutputRectIsHosted
//
// Description: determines whether a rect intersects a hosted area
//
// Params:      pRect - rect to query
//
// Returns:     TRUE  - output is hosted
//              FALSE - output is not hosted
//
// Operation:
//
//
BOOL HET_DDOutputRectIsHosted(LPRECT pRect);

#endif // DLL_DISP


//
// Functions for window, task tracking (hook dll for NT, hook/dd for Win95)
//
void WINAPI HOOK_Init(HWND dcsCore, ATOM atom);     // NT only
void        HOOK_Load(HINSTANCE hInst);             // NT only
void        HOOK_NewThread(void);                   // NT only


typedef struct tagHET_SHARE_INFO
{
    int     cWnds;
    UINT    uType;
    DWORD   dwID;
} HET_SHARE_INFO, FAR* LPHET_SHARE_INFO;


void          HET_Clear(void);
BOOL CALLBACK HETShareCallback(HWND hwnd, LPARAM lParam);
BOOL CALLBACK HETUnshareCallback(HWND hwnd, LPARAM lParam);




#if defined(DLL_CORE) || defined(DLL_HOOK)

//
// HET_GetShellTray
//
__inline HWND HET_GetShellTray(void)
{
    #define HET_SHELL_TRAY_CLASS        "Shell_TrayWnd"

    return(FindWindow(HET_SHELL_TRAY_CLASS, NULL));
}


//
// HET_GetShellDesktop
//
__inline HWND HET_GetShellDesktop(void)
{
    return(GetShellWindow());
}

#endif // DLL_CORE || DLL_HOOK


//
// Functions in the Core Process DLL
//
BOOL CALLBACK HETUnshareAllWindows(HWND hwnd, LPARAM lParam);

BOOL CALLBACK HETRepaintWindow(HWND hwnd, LPARAM lParam);


//
// Internal Hook functions
//
#ifdef DLL_HOOK

BOOL HET_WindowIsHosted(HWND hwnd);

#ifdef IS_16
LRESULT CALLBACK HETEventProc(int, WPARAM, LPARAM);
LRESULT CALLBACK HETTrackProc(int, WPARAM, LPARAM);
#else


//
// The following definitions are taken from <ntddk.h> and <ntdef.h>.  They
// are required to make use of the <NtQueryInformationProcess> function
// in NTDLL.DLL.
//
typedef struct _PEB *PPEB;
typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;
typedef LONG KPRIORITY;
typedef LONG NTSTATUS;


//
// Types of Win Event hook/unhook functions
//
typedef HWINEVENTHOOK (WINAPI * SETWINEVENTHOOK)(
                                                DWORD        eventMin,
                                                DWORD        eventMax,
                                                HMODULE      hmodWinEventProc,
                                                WINEVENTPROC lpfnWinEventProc,
                                                DWORD        idProcess,
                                                DWORD        idThread,
                                                DWORD        dwFlags);

typedef BOOL (WINAPI * UNHOOKWINEVENT)(HWINEVENTHOOK hEventId);

//
// Process Information Classes
//
typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,          // Note: this is kernel mode only
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    ProcessWx86Information,
    ProcessHandleCount,
    ProcessAffinityMask,
    ProcessPriorityBoost,
    MaxProcessInfoClass
    } PROCESSINFOCLASS;

//
// Basic Process Information
//  NtQueryInformationProcess using ProcessBasicInfo
//
typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    KAFFINITY AffinityMask;
    KPRIORITY BasePriority;
    ULONG UniqueProcessId;
    ULONG InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;

//
// Declare our function prototype for <NtQueryInformationProcess>.
//
typedef NTSTATUS (NTAPI* NTQIP)(HANDLE ProcessHandle,
                                PROCESSINFOCLASS ProcessInformationClass,
                                void* ProcessInformation,
                                ULONG ProcessInformationLength,
                                PULONG ReturnLength);

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)


//
// Name of the DLL containing <NtQueryInformationProcess>.
//
#define NTDLL_DLL       "ntdll.dll"


#define HET_MIN_WINEVENT        EVENT_OBJECT_CREATE
#define HET_MAX_WINEVENT        EVENT_OBJECT_HIDE


void CALLBACK HETTrackProc(HWINEVENTHOOK hEvent, DWORD event, HWND hwnd,
        LONG idObject, LONG idChild, DWORD dwThreadId, DWORD dwmsEventTime);

#endif // IS_16


void    HETHandleCreate(HWND);
void    HETHandleDestroy(HWND);
void    HETHandleShow(HWND, BOOL);
void    HETHandleHide(HWND);
void    HETCheckParentChange(HWND);

//
// We try to do just one enumerate (and stop as soon as we can) on events
// for purposes of speed.
//

BOOL CALLBACK HETShareEnum(HWND, LPARAM);

typedef struct tagHET_TRACK_INFO
{
    HWND    hwndUs;
#ifndef IS_16
    BOOL    fWOW;
#endif
    UINT    cWndsApp;
    UINT    cWndsSharedThread;
    UINT    cWndsSharedProcess;
    DWORD   idProcess;
    DWORD   idThread;
} HET_TRACK_INFO, FAR* LPHET_TRACK_INFO;

void    HETGetParentProcessID(DWORD processID, LPDWORD pParentProcessID);

void    HETNewTopLevelCount(void);
BOOL CALLBACK   HETCountTopLevel(HWND, LPARAM);
BOOL CALLBACK   HETUnshareWOWServiceWnds(HWND, LPARAM);


#endif // DLL_HOOK


BOOL WINAPI OSI_ShareWindow(HWND hwnd, UINT uType, BOOL fRepaint, BOOL fUpdateCount);
BOOL WINAPI OSI_UnshareWindow(HWND hwnd, BOOL fUpdateCount);

//
// OSI_StartWindowTracking()
// Called when we start sharing the very first app
//
BOOL WINAPI OSI_StartWindowTracking(void);


//
// OSI_StopWindowTracking()
// Called when we stop sharing the very last app
//
void WINAPI OSI_StopWindowTracking(void);


//
// Utility functions for windows
//
BOOL WINAPI OSI_IsWindowScreenSaver(HWND hwnd);

#define GCL_WOWWORDS    -27
BOOL WINAPI OSI_IsWOWWindow(HWND hwnd);



#endif // _H_HET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\im.h ===
//
// Input Manager
//

#ifndef _H_IM
#define _H_IM


#if defined(DLL_CORE) || defined(DLL_HOOK)

//
//
// CONSTANTS
//
//


//
// Values used when accumulating events to return from IEM_TranslateLocal
// and IEM_TranslateRemote.
//
#define IEM_EVENT_CTRL_DOWN         1
#define IEM_EVENT_CTRL_UP           2
#define IEM_EVENT_SHIFT_DOWN        3
#define IEM_EVENT_SHIFT_UP          4
#define IEM_EVENT_MENU_DOWN         5
#define IEM_EVENT_MENU_UP           6
#define IEM_EVENT_FORWARD           7
#define IEM_EVENT_CONSUMED          8
#define IEM_EVENT_REPLAY            9
#define IEM_EVENT_REPLAY_VK         10
#define IEM_EVENT_REPLAY_VK_DOWN    11
#define IEM_EVENT_REPLAY_VK_UP      12
#define IEM_EVENT_CAPS_LOCK_UP      13
#define IEM_EVENT_CAPS_LOCK_DOWN    14
#define IEM_EVENT_NUM_LOCK_UP       15
#define IEM_EVENT_NUM_LOCK_DOWN     16
#define IEM_EVENT_SCROLL_LOCK_UP    17
#define IEM_EVENT_SCROLL_LOCK_DOWN  18
#define IEM_EVENT_REPLAY_SPECIAL_VK 21
#define IEM_EVENT_EXTENDED_KEY      22
#define IEM_EVENT_REPLAY_SECONDARY  23
#define IEM_EVENT_SYSTEM            24
#define IEM_EVENT_NORMAL            25

#define IEM_EVENT_HOTKEY_BASE       50
//
// Range of hotkeys is 0 - 99
//
#define IEM_EVENT_KEYPAD0_DOWN      150
//
// Range of keypad down is 0-9
//
#define IEM_EVENT_KEYPAD0_UP        160

//
// The flags used in the return value from VkKeyScan.
//
#define IEM_SHIFT_DOWN              0x0001
#define IEM_CTRL_DOWN               0x0002
#define IEM_MENU_DOWN               0x0004


//
// Virtual key codes.
//
#define VK_INVALID      0xFF


//
// Given the keyboard packet flags the following macros tell us things
// about the key event.
//

//
// This is TRUE if this event is a key press.  It is FALSE for key releases
// and key repeats.
//
#define IS_IM_KEY_PRESS(A) \
(((A) & (TSHR_UINT16)(IM_FLAG_KEYBOARD_RELEASE | IM_FLAG_KEYBOARD_DOWN))==0)

//
// This is TRUE if this event is a key release.  It is FALSE for key
// presses and key repeats.  Note that it is also TRUE for the
// theoretically impossible case of a key release when the key is already
// up (this combination could conceviably be generated if events are
// discarded by USER or our emulation of USER).
//
#define IS_IM_KEY_RELEASE(A) (((A) & IM_FLAG_KEYBOARD_RELEASE))

//
// This is TRUE if this event is a key repeat.  It is FALSE for key presses
// and key releases.
//
#define IS_IM_KEY_REPEAT(A) \
(((A) & (IM_FLAG_KEYBOARD_RELEASE | IM_FLAG_KEYBOARD_DOWN))==\
IM_FLAG_KEYBOARD_DOWN)

//
// This is TRUE if the key is the right-variant of a modifier.  It is FALSE
// otherwise.
//
#define IS_IM_KEY_RIGHT(A) (((A) & IM_FLAG_KEYBOARD_RIGHT))


//
// The maximum amount of time that we expect an injected event to take to
// pass through USER.
//
#define IM_EVENT_PERCOLATE_TIME 300

//
// Max VK sync attempts.
//
#define IM_MAX_VK_SYNC_ATTEMPTS     10

//
// Declare our function prototype for <ImmGetVirtualKey>.
//
typedef UINT (WINAPI* IMMGVK)(HWND);



//
//
// MACROS
//
//
//
// Macros to convert between logical mouse co-ordinates (e.g. (320,240) for
// the centre of a VGA screen to the full 16-bit range co-ordinates used
// by Windows (e.g. (320,240) is (32767, 32767).
//
#define IM_MOUSEPOS_LOG_TO_OS(coord, size)                                  \
        (((65535L * (TSHR_UINT32)coord) + 32768L) / (TSHR_UINT32)size)

//
// Macros extracting information from the mouse event flags field (event
// mask).
//
#define IM_MEV_MOVE_ONLY(e) ((e).event.mouse.flags == MOUSEEVENTF_MOVE)
#define IM_MEV_MOVE(e) (((e).event.mouse.flags & MOUSEEVENTF_MOVE) != 0 )
#define IM_MEV_ABS_MOVE(e) ((((e).event.mouse.flags &                   \
                 (MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE)) ==             \
                             (MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE) ))
#define IM_MEV_BUTTON_DOWN(e) \
           (((e).event.mouse.flags & IM_MOUSEEVENTF_BUTTONDOWN_FLAGS) != 0 )
#define IM_MEV_BUTTON_UP(e)   \
           (((e).event.mouse.flags & IM_MOUSEEVENTF_BUTTONUP_FLAGS) != 0 )

#define IM_EVMASK_B1_DOWN(m) (((m) & MOUSEEVENTF_LEFTDOWN)   != 0 )
#define IM_EVMASK_B1_UP(m)   (((m) & MOUSEEVENTF_LEFTUP)     != 0 )
#define IM_EVMASK_B2_DOWN(m) (((m) & MOUSEEVENTF_RIGHTDOWN)  != 0 )
#define IM_EVMASK_B2_UP(m)   (((m) & MOUSEEVENTF_RIGHTUP)    != 0 )
#define IM_EVMASK_B3_DOWN(m) (((m) & MOUSEEVENTF_MIDDLEDOWN) != 0 )
#define IM_EVMASK_B3_UP(m)   (((m) & MOUSEEVENTF_MIDDLEUP)   != 0 )

#define IM_MEV_BUTTON1_DOWN(e) (IM_EVMASK_B1_DOWN((e).event.mouse.flags))
#define IM_MEV_BUTTON2_DOWN(e) (IM_EVMASK_B2_DOWN((e).event.mouse.flags))
#define IM_MEV_BUTTON3_DOWN(e) (IM_EVMASK_B3_DOWN((e).event.mouse.flags))
#define IM_MEV_BUTTON1_UP(e) (IM_EVMASK_B1_UP((e).event.mouse.flags))
#define IM_MEV_BUTTON2_UP(e) (IM_EVMASK_B2_UP((e).event.mouse.flags))
#define IM_MEV_BUTTON3_UP(e) (IM_EVMASK_B3_UP((e).event.mouse.flags))

#define IM_KEV_KEYUP(e)    ((e).event.keyboard.flags & KEYEVENTF_KEYUP)
#define IM_KEV_KEYDOWN(e)  (!IM_KEV_KEYUP(e))
#define IM_KEV_VKCODE(e)   ((e).event.keyboard.vkCode)

#define IM_MOUSEEVENTF_BASE_FLAGS  ( MOUSEEVENTF_MOVE       | \
                                     MOUSEEVENTF_LEFTUP     | \
                                     MOUSEEVENTF_LEFTDOWN   | \
                                     MOUSEEVENTF_RIGHTUP    | \
                                     MOUSEEVENTF_RIGHTDOWN  | \
                                     MOUSEEVENTF_MIDDLEUP   | \
                                     MOUSEEVENTF_MIDDLEDOWN )

#define IM_MOUSEEVENTF_CLICK_FLAGS ( MOUSEEVENTF_LEFTUP     | \
                                     MOUSEEVENTF_LEFTDOWN   | \
                                     MOUSEEVENTF_RIGHTUP    | \
                                     MOUSEEVENTF_RIGHTDOWN  | \
                                     MOUSEEVENTF_MIDDLEUP   | \
                                     MOUSEEVENTF_MIDDLEDOWN )


#define IM_MOUSEEVENTF_BUTTONDOWN_FLAGS ( MOUSEEVENTF_LEFTDOWN  |   \
                                          MOUSEEVENTF_RIGHTDOWN |   \
                                          MOUSEEVENTF_MIDDLEDOWN )

#define IM_MOUSEEVENTF_BUTTONUP_FLAGS ( MOUSEEVENTF_LEFTUP  |   \
                                        MOUSEEVENTF_RIGHTUP |   \
                                        MOUSEEVENTF_MIDDLEUP )



typedef struct tagKBDEV
{
    WORD    vkCode;
    WORD    scanCode;
    DWORD   flags;
    DWORD   time;
    DWORD   dwExtraInfo;
}
KBDEV, FAR *LPKBDEV;


typedef struct tagMSEV
{
    POINTL  pt;
    DWORD   cButtons;
    DWORD   mouseData;
    DWORD   flags;
    DWORD   time;
    DWORD   dwExtraInfo;
}
MSEV, FAR *LPMSEV;


//
// The IMOSEVENTS which we queue as they arrive from the mouse or
// keyboard hooks or after IMINCOMINGEVENTS have been translated into local
// events by the IEM.
//
typedef struct tagIMOSEVENT
{
    TSHR_UINT32      type;
        #define IM_MOUSE_EVENT      1
        #define IM_KEYBOARD_EVENT   2

    TSHR_UINT32      flags;
        #define IM_FLAG_DONT_REPLAY     0x0001
        #define IM_FLAG_UPDATESTATE     0x0002

    TSHR_UINT32     time;
    union
    {
        MSEV    mouse;
        KBDEV   keyboard;
    }
    event;
}
IMOSEVENT;
typedef IMOSEVENT FAR * LPIMOSEVENT;




#define IM_TRANSFER_EVENT_BUFFER_SIZE   32
#define IM_MAX_TRANSFER_EVENT_INDEX     (IM_TRANSFER_EVENT_BUFFER_SIZE-1)


typedef struct tagIMTRANSFEREVENT
{
    LONG        fInUse;
    IMOSEVENT   event;
}
IMTRANSFEREVENT, FAR * LPIMTRANSFEREVENT;



//
// For handling keyboard events in hooks
//
#define IM_MASK_KEYBOARD_SYSFLAGS           0xE100
#define IM_MASK_KEYBOARD_SYSSCANCODE        0x00FF

#define IM_MAX_DEAD_KEYS                    20

#define IM_SIZE_EVENTQ                      40
#define IM_SIZE_OSQ                         80  // 2*EVENTQ size - key up/down

//
// Define the flags that can be returned by IMConvertIMPacketToOSEvent().
//
#define IM_IMQUEUEREMOVE    0x0001
#define IM_OSQUEUEINJECT    0x0002

//
// For managing our key state arrays.
//
#define IM_KEY_STATE_FLAG_TOGGLE    (BYTE)0x01
#define IM_KEY_STATE_FLAG_DOWN      (BYTE)0x80

//
// Bounds for local mouse spoiling and packet piggyback target withhold
// Note that these are local spoiling values, to prevent the data pipe from
// getting clogged and introducing unnecessary latency.  Now, you may think
// that 30 move messages per second is a little low, but put this up any
// higher and USER at the other end will just spoil them when it injects
// them into the app - that would be totally wasteful of precious bandwidth.
//
#define IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS    100
#define IM_LOCAL_MOUSE_SAMPLING_GAP_MEDIUM_MS  75
#define IM_LOCAL_MOUSE_SAMPLING_GAP_HIGH_MS    50
#define IM_LOCAL_WITHHOLD_DELAY               150
#define IM_LOCAL_MOUSE_WITHHOLD                 5
#define IM_LOCAL_KEYBOARD_WITHHOLD              2

//
// For pacing the accumulation and injecting of mouse events.
// We should play back at the same rate as the highest local sampling rate
// less a small amount for processing delay on the remote system
//
#define IM_REMOTE_MOUSE_PLAYBACK_GAP_MS     20

//
// The amount of time to hold on to a mouse button down event in case a the
// user is just clicking on eg a scroll button.  If we did not hold on to
// the mouse button down event then the mouse button up would be sent in
// the next packet.  On a slow network this means the remote application
// may process the down period for much longer than the user wanted.
//
#define IM_MOUSE_UP_WAIT_TIME  50

#define IM_MIN_RECONVERSION_INTERVAL_MS     150


//
// #define used non-Windows to flag a VK code that equates to an ascii char
//
#define IM_TYPE_VK_ASCII       ((TSHR_UINT16)0x8880)


//
// Used for checking events about to be injected.
//
#define IM_KEY_IS_TOGGLE(A) \
(((A)==VK_CAPITAL)||((A)==VK_SCROLL)||((A)==VK_NUMLOCK))

#define IM_KEY_IS_MODIFIER(A) \
(((A)==VK_SHIFT)||((A)==VK_CONTROL)||((A)==VK_MENU))

//
// Used to check values in key state arrays.
//
#define IM_KEY_STATE_IS_UP(A) (!((A)&IM_KEY_STATE_FLAG_DOWN))
#define IM_KEY_STATE_IS_DOWN(A) ((A)&IM_KEY_STATE_FLAG_DOWN)

//
// Used to determine what sort of mouse event this is from the flags.
//
#define IM_IS_MOUSE_MOVE(A) \
    ((A) & IM_FLAG_MOUSE_MOVE)

#define IM_IS_MOUSE_PRESS(A) \
    ((!IM_IS_MOUSE_MOVE(A)) && ((A) & IM_FLAG_MOUSE_DOWN))

#define IM_IS_MOUSE_RELEASE(A) \
    ((!IM_IS_MOUSE_MOVE(A)) && !((A) & IM_FLAG_MOUSE_DOWN))

#define IM_IS_LEFT_CLICK(A) \
    (((A) & (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOUBLE)) == (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1))
#define IM_IS_LEFT_DCLICK(A) \
    (((A) & (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOUBLE)) == (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOUBLE))



//
// Holds NETWORK events, to person controlled by us, or from person in control
// of us.
//
typedef struct tagIMEVENTQ
{
    DWORD           head;
    DWORD           numEvents;
    IMEVENT         events[IM_SIZE_EVENTQ];
}
IMEVENTQ;
typedef IMEVENTQ FAR * LPIMEVENTQ;


//
// Holds translated events, suitable for injection from person
// in control of us, or pre-translated events to person controlled by us.
//
typedef struct tagIMOSQ
{
    DWORD           head;
    DWORD           numEvents;
    IMOSEVENT       events[IM_SIZE_OSQ];
}
IMOSQ;
typedef IMOSQ FAR * LPIMOSQ;


#define CIRCULAR_INDEX(start, rel_index, size) \
    (((start) + (rel_index)) % (size))




//
// To support collaboration in both NT (background service thread) and Win95
// (win16 code) with as much of the common incoming/outgoing processing in
// one places, the IM data is separated into 4 types.  There are structures
// for each of these types, so that moving a variable from one to another
// is as easy as possible.  Note that the declarations are bitness-safe;
// they are the same size in 16-bit and 32-bit code.  And that the structures
// are DWORD aligned.
//
// (1) IM_SHARED_DATA
// This is data that both the CPI32 library needs to access, and one or
// more of the NT/Win95 implementations of collaboration.
//
// (2) IM_NT_DATA
// This is data that only the NT version of collaboration needs.
//
// (3) IM_WIN95_DATA
// This is data that only the Win95 version of collaboration needs.
//


//
// For NT, this shared structures is just declared in MNMCPI32.NT's data,
// and a pointer to it is used by the common lib.
//
// For Win95, this shared structure is allocated in a global memory block
// that can GlobalSmartPageLock() it as needed for access at interrupt time,
// and a pointer to it is mapped flat and returned to the common lib.
//
typedef struct tagIM_SHARED_DATA
{
#ifdef DEBUG
    DWORD           cbSize;         // To make sure everybody agrees on size
#endif

    //
    // For critical errors -- nonzero if one is up
    //
    DWORD           imSuspended;

    //
    // Control state
    //
    LONG            imControlled;
    LONG            imPaused;
    LONG            imUnattended;
}
IM_SHARED_DATA, FAR* LPIM_SHARED_DATA;


// NT specific IM state variables
typedef struct tagIM_NT_DATA
{
    //
    // Low level hook thread
    //
    DWORD           imLowLevelInputThread;

    //
    // Other desktop injection helper thread
    //
    DWORD           imOtherDesktopThread;

    //
    // Low level hook handles
    //
    HHOOK           imhLowLevelMouseHook;
    HHOOK           imhLowLevelKeyboardHook;
}
IM_NT_DATA, FAR* LPIM_NT_DATA;



// Win95 specific IM state variables
typedef struct tagIM_WIN95_DATA
{
    BOOL            imInjecting;
    BOOL            imLowLevelHooks;

    //
    // High level hook handles
    //
    HHOOK           imhHighLevelMouseHook;
}
IM_WIN95_DATA, FAR* LPIM_WIN95_DATA;



//
//
// MACROS
//
//
#define IM_SET_VK_DOWN(A) (A) |= (BYTE)0x80
#define IM_SET_VK_UP(A)   (A) &= (BYTE)0x7F
#define IM_TOGGLE_VK(A)   (A) ^= (BYTE)0x01

//
//
// PROTOTYPES
//
//


// NT only
BOOL WINAPI OSI_InstallHighLevelMouseHook(BOOL fOn);

BOOL WINAPI OSI_InstallControlledHooks(BOOL fOn, BOOL fDesktop);
void WINAPI OSI_InjectMouseEvent(DWORD flags, LONG x, LONG y,  DWORD mouseData, DWORD dwExtraInfo);
void WINAPI OSI_InjectKeyboardEvent(DWORD flags, WORD vkCode, WORD scanCode, DWORD dwExtraInfo);
void WINAPI OSI_InjectCtrlAltDel(void);
void WINAPI OSI_DesktopSwitch(UINT from, UINT to);


//
// Internal Hook DLL functions.
//
#ifdef DLL_HOOK

#ifdef IS_16
BOOL    IM_DDInit(void);
void    IM_DDTerm(void);
#endif // IS_16

LRESULT CALLBACK IMMouseHookProc(int    code,
                                 WPARAM wParam,
                                 LPARAM lParam);

#endif // DLL_HOOK


#ifdef IS_16
void    IMCheckWin16LockPulse(void);
#else
DWORD   WINAPI IMLowLevelInputProcessor(LPVOID hEventWait);
DWORD   WINAPI IMOtherDesktopProc(LPVOID hEventWait);
LRESULT CALLBACK IMLowLevelMouseProc(int, WPARAM, LPARAM);
LRESULT CALLBACK IMLowLevelKeyboardProc(int, WPARAM, LPARAM);
#endif // IS_16

#endif // DLL_CORE or DLL_HOOK

#endif // _H_IM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\oe.h ===
//
// Order Encoder
//

#ifndef _H_OE
#define _H_OE



//
// Required headers
//
#include <oa.h>
#include <shm.h>
#include <fh.h>



//
// Specific values for OSI escape codes
//
#define OE_ESC(code)            (OSI_OE_ESC_FIRST + code)

#define OE_ESC_NEW_FONTS        OE_ESC(0)
#define OE_ESC_NEW_CAPABILITIES OE_ESC(1)


//
// Structure: OE_NEW_FONTS
//
// Description:
//
// Structure to pass new font data down to the display driver from the
// Share Core.
//
//
typedef struct tagOE_NEW_FONTS
{
    OSI_ESCAPE_HEADER header;           // Common header
    WORD                fontCaps;       // R11 font capabilities
    WORD                countFonts;     // Number of fonts in data block

    LPLOCALFONT         fontData;       // Local font table, containing
                                        // FH_MAX_FONTS entries

    LPWORD              fontIndex;      // Font table index, containing
                                        // FH_LOCAL_INDEX_SIZE entries

} OE_NEW_FONTS;
typedef OE_NEW_FONTS FAR * LPOE_NEW_FONTS;


//
// Structure: OE_NEW_CAPABILITIES
//
// Description:
//
// Structure to pass new capabilities down to the display driver from the
// Share Core.
//
//
typedef struct tagOE_NEW_CAPABILITIES
{
    OSI_ESCAPE_HEADER header;           // Common header

    DWORD           sendOrders;       // Are we allowed to send any
                                        // orders?

    DWORD           textEnabled;      // Are we allowed to send text
                                        // orders?

    DWORD           baselineTextEnabled;
                                        // Flag to indicate if we should
                                        //   encode text orders using
                                        //   baseline alignment.

    LPBYTE          orderSupported;     // Array of BYTE-sized booleans
}
OE_NEW_CAPABILITIES;
typedef OE_NEW_CAPABILITIES FAR * LPOE_NEW_CAPABILITIES;



//
// Flag to indicate support of second level order encoding.  This is used
// as a bitwise flag so that we can easily determine when parties have
// mixed capabilities.  Allowed values are:
//
//  OE2_FLAG_UNKNOWN       - OE2 supported has not been negotiated yet
//  OE2_FLAG_SUPPORTED     - OE2 is supported by at least one person
//  OE2_FLAG_NOT_SUPPORTED - OE2 is not supported by at least one person
//  OE2_FLAG_MIXED         - Oh no!  This results when we have 2 (or more)
//                           nodes that have differing OE2 support.  In
//                           this case we must disable OE2 encoding.
//
#define OE2_FLAG_UNKNOWN            0x00
#define OE2_FLAG_SUPPORTED          0x10
#define OE2_FLAG_NOT_SUPPORTED      0x01
#define OE2_FLAG_MIXED              0x11


//
//
// PROTOTYPES
//
//
#ifdef DLL_DISP



//
// Name:    OE_DDProcessRequest
//
// Purpose: Process an OE specific request from the Share Core
//
// Returns: TRUE if processed OK, FALSE otherwise
//
// Params:  pso   - SURFOBJ associated with ther request
//          cjIn  - size of input buffer
//          pvIn  - pointer to input buffer
//          cjOut - size of output buffer
//          pvOut - pointer to output buffer
//
#ifdef IS_16

BOOL    OE_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);

BOOL    OE_DDInit(void);

void    OE_DDViewing(BOOL fStart);

#else

ULONG   OE_DDProcessRequest(SURFOBJ* pso, UINT cjIn, void* pvIn, UINT cjOut, void* pvOut);

#endif // IS_16

void    OE_DDTerm(void);

void    OEDDSetNewFonts(LPOE_NEW_FONTS pDataIn);

void    OEDDSetNewCapabilities(LPOE_NEW_CAPABILITIES pCaps);

BOOL    OE_SendAsOrder(DWORD order);
BOOL    OE_RectIntersectsSDA(LPRECT lpRect);

#endif // ifdef DLL_DISP


//
// Function prototypes.
//

//
// OE_GetStringExtent(..)
//
// FUNCTION:
//
// Gets the extent (in logical coords) of the specified string.
// The extent returned encloses all pels of the specified string.
//
//
// PARAMETERS:
//
// hdc - DC handle
//
// pMetric - pointer to text metrics for the font for the string; if NULL,
// use the global text metrics
//
// lpszString - pointer to null terminated string
//
// cbString - number of bytes in string
//
// lpDx - pointer to character increments. If NULL, use default character
// increments
//
// pRect - pointer to rect where string extent is returned
//
// RETURNS:
//
// The amount of overhang included in the returned extent
//
//     ------------------------------------....
//     |                                  ****:
//     |                                  *   :
//     |                                 ***  :
//     |                                * |   :
//     |                               *  |   :
//     |                             **** |   :
//     ------------------------------------....
//                                            ^
//                                            :-------- bounds are wider
//                                        ^             than text extent
//                                        |             due to overhang
//                     real text extent ends here
//
//
int OE_GetStringExtent(HDC hdc,
                                TEXTMETRIC*    pMetric,
                                LPSTR       lpszString,
                                UINT         cbString,
                                LPRECT        pRect      );



//
// Macros to lock down the buffer that we want to use.
//
// NOTE: We do not have any OE specific shared memory, so we'll use the OA
// shared data as a surrogate for the lock.  Since the lock is counting, we
// have no worries.
//
#define OE_SHM_START_WRITING  OA_SHM_START_WRITING

#define OE_SHM_STOP_WRITING   OA_SHM_STOP_WRITING

//
// Number of rectangles that can make up a clip region before it is too
// complicated to send as an order.
//
#define COMPLEX_CLIP_RECT_COUNT     4

//
// Mask and valid values for TextOut flAccel flags
//
#define OE_BAD_TEXT_MASK  ( SO_VERTICAL | SO_REVERSED | SO_GLYPHINDEX_TEXTOUT )


#ifdef DLL_DISP
//
// Structure to store brushes used as BLT patterns.
//
// style     - Standard brush style (used in order to send brush type).
//
//             BS_HATCHED
//             BS_PATTERN
//             BS_SOLID
//             BS_NULL
//
// hatch     - Standard hatch definition.  Can be one of the following.
//
//             style = BS_HATCHED
//
//             HS_HORIZONTAL
//             HS_VERTICAL
//             HS_FDIAGONAL
//             HS_BDIAGONAL
//             HS_CROSS
//             HS_DIAGCROSS
//
//             style = BS_PATTERN
//
//             This field contains the first byte of the brush definition
//             from the brush bitmap.
//
// brushData - bit data for the brush.
//
// fore      - foreground color for the brush
//
// back      - background color for the brush
//
// brushData - bit data for the brush (8x8x1bpp - 1 (see above) = 7 bytes)
//
//
typedef struct tagOE_BRUSH_DATA
{
    BYTE  style;
    BYTE  hatch;
    BYTE  pad[2];
    TSHR_COLOR  fore;
    TSHR_COLOR  back;
    BYTE  brushData[7];
} OE_BRUSH_DATA, * POE_BRUSH_DATA;

#ifndef IS_16
//
// Structure allowing sufficient stack to be allocated for an ENUMRECTS
// structure containing more than one (in fact COMPLEX_CLIP_RECT_COUNT)
// rectangles.
// This holds one RECTL more than we need to allow us to determine whether
// there are too many rects for order encoding by making a single call to
// CLIPOBJ_bEnumRects.
//
typedef struct tagOE_ENUMRECTS
{
    ENUMRECTS rects;
    RECTL     extraRects[COMPLEX_CLIP_RECT_COUNT];
} OE_ENUMRECTS;
#endif // !IS_16
#endif

//
// Font Alias table structure.  The font aliases convert non-existant fonts
// to ones that Windows supports in its default installation.
//
// pszOriginalFontName - Name of the non-existant font to be aliased
//
// pszAliasFontName    - Name of the font Windows uses instead of the non
//                       existant font.
//
// charWidthAdjustment - Character adjustment to make a decent match.
//
typedef struct _FONT_ALIAS_TABLE
{
    LPBYTE          pszOriginalFontName;
    LPBYTE          pszAliasFontName;
    TSHR_UINT16     charWidthAdjustment;
}
FONT_ALIAS_TABLE;


//
// ROP4 to ROP3 conversion macros.  Note that we don't use the full Windows
// 3-way ROP code - we are only interested in the index byte.
//
#define ROP3_HIGH_FROM_ROP4(rop) ((TSHR_INT8)((rop & 0xff00) >> 8))
#define ROP3_LOW_FROM_ROP4(rop)  ((TSHR_INT8)((rop & 0x00ff)))

//
// OS specific RECTL to RECT conversion macro.  Note that this macro
// guarantees to return a well-ordered rectangle.
//
#define RECT_FROM_RECTL(dcr, rec) if (rec.right < rec.left)                \
                                    {                                        \
                                        dcr.left   = rec.right;              \
                                        dcr.right  = rec.left;               \
                                    }                                        \
                                    else                                     \
                                    {                                        \
                                        dcr.left   = rec.left;               \
                                        dcr.right  = rec.right;              \
                                    }                                        \
                                    if (rec.bottom < rec.top)                \
                                    {                                        \
                                        dcr.bottom = rec.top;                \
                                        dcr.top    = rec.bottom;             \
                                    }                                        \
                                    else                                     \
                                    {                                        \
                                        dcr.top    = rec.top;                \
                                        dcr.bottom = rec.bottom;             \
                                    }

//
// OS specific RECTFX to RECT conversion macro.  Note that this macro
// guarantees to return a well-ordered rectangle.
//
// A RECTFX uses fixed point (28.4 bit) numbers so we need to truncate the
// fraction and move to the correct integer value, i.e. shift right 4 bits.
//
#define RECT_FROM_RECTFX(dcr, rec)                                         \
                                if (rec.xRight < rec.xLeft)                  \
                                {                                            \
                                    dcr.left  = FXTOLFLOOR(rec.xRight);      \
                                    dcr.right = FXTOLCEILING(rec.xLeft);     \
                                }                                            \
                                else                                         \
                                {                                            \
                                    dcr.left  = FXTOLFLOOR(rec.xLeft);       \
                                    dcr.right = FXTOLCEILING(rec.xRight);    \
                                }                                            \
                                if (rec.yBottom < rec.yTop)                  \
                                {                                            \
                                    dcr.bottom= FXTOLCEILING(rec.yTop);      \
                                    dcr.top   = FXTOLFLOOR(rec.yBottom);     \
                                }                                            \
                                else                                         \
                                {                                            \
                                    dcr.top   = FXTOLFLOOR(rec.yTop);        \
                                    dcr.bottom= FXTOLCEILING(rec.yBottom);   \
                                }

#define POINT_FROM_POINTL(dcp, pnt) dcp.x = pnt.x;                \
                                    dcp.y = pnt.y


#define POINT_FROM_POINTFIX(dcp, pnt) dcp.x = FXTOLROUND(pnt.x);  \
                                      dcp.y = FXTOLROUND(pnt.y)


//
// Macros to check for articular types of ROP code.
//
#define ROP3_NO_PATTERN(rop) ((rop & 0x0f) == (rop >> 4))

#define ROP3_NO_SOURCE(rop)  ((rop & 0x33) == ((rop & 0xCC) >> 2))

#define ROP3_NO_TARGET(rop)  ((rop & 0x55) == ((rop & 0xAA) >> 1))

//
// Checking for SRCCOPY, PATCOPY, BLACKNESS, WHITENESS
//
#define ROP3_IS_OPAQUE(rop)  ( ((rop) == 0xCC) || ((rop) == 0xF0) || \
                               ((rop) == 0x00) || ((rop) == 0xFF) )

//
// 3-way rop equating to the COPYPEN mix.
//
#define OE_COPYPEN_ROP (BYTE)0xf0



#ifdef DLL_DISP

void  OEConvertMask(ULONG  mask, LPUINT pBitDepth, LPUINT pShift);


#ifdef IS_16

//
// GDI never made defines for these, so we will.
//
#define PALETTEINDEX_FLAG   0x01000000L
#define PALETTERGB_FLAG     0x02000000L
#define COLOR_FLAGS         0x03000000L

//
// This is a GLOBAL to cut down on stack space, and is only valid during
// the life of a DDI call that is not reentrant.
//
// When we calculate something, we set the bit saying we did.  This speeds 
// up our code a lot from NM 2.0 which used to calculate the same things
// over and over again.
//

#define OESTATE_SDA_DCB         0x0001  // Send as screen data, use DCBs
#define OESTATE_SDA_SCREEN      0x0002  // Send as screen data, use screen rc
#define OESTATE_SDA_MASK        0x0003  // Send rc as screen data
#define OESTATE_SDA_FONTCOMPLEX 0x0004  // Send as screen data if font too complex
#define OESTATE_OFFBYONEHACK    0x0010  // Add one pixel onto bottom after DDI
#define OESTATE_CURPOS          0x0020  // Save curpos before DDI call
#define OESTATE_DDISTUFF        0x003F

#define OESTATE_COORDS          0x0100
#define OESTATE_PEN             0x0200
#define OESTATE_BRUSH           0x0400
#define OESTATE_REGION          0x0800
#define OESTATE_FONT            0x1000
#define OESTATE_GET_MASK        0x1F00

#define MIN_BRUSH_WIDTH         8
#define MAX_BRUSH_WIDTH         16
#define TRACKED_BRUSH_HEIGHT    8

#define TRACKED_BRUSH_SIZE      8

typedef struct tagOESTATE
{
    UINT            uFlags;
    HDC             hdc;
    LPDC            lpdc;
    RECT            rc;

    //
    // These are used when calcing the bounds is too complicated, so we 
    // let GDI do it for us, albeit slower.
    //
    UINT            uGetDCB;
    UINT            uSetDCB;
    RECT            rcDCB;

    POINT           ptCurPos;
    POINT           ptDCOrg;
    POINT           ptPolarity;
    LOGPEN          logPen;
    LOGBRUSH        logBrush;
    BYTE            logBrushExtra[TRACKED_BRUSH_SIZE];
    LOGFONT         logFont;
    int             tmAlign;
    TEXTMETRIC      tmFont;
    REAL_RGNDATA    rgnData;
} OESTATE, FAR* LPOESTATE;

void    OEGetState(UINT uFlags);
BOOL    OEBeforeDDI(DDI_PATCH ddiType, HDC hdc, UINT flags);
BOOL    OEAfterDDI(DDI_PATCH ddiType, BOOL fWeCare, BOOL fOutputHappened);


#define OECHECK_PEN         0x0001
#define OECHECK_BRUSH       0x0002
#define OECHECK_FONT        0x0004
#define OECHECK_CLIPPING    0x0010
BOOL    OECheckOrder(DWORD order, UINT flags);


LPDC    OEValidateDC(HDC hdc, BOOL fSrc);
void    OEMaybeBitmapHasChanged(LPDC lpdc);

void    OEClipAndAddOrder(LPINT_ORDER pOrder, void FAR* lpExtraInfo);
void    OEClipAndAddScreenData(LPRECT pRect);


void    OELPtoVirtual(HDC hdc, LPPOINT aPts, UINT cPts);
void    OELRtoVirtual(HDC hdc, LPRECT aRcs, UINT cRcs);

void    OEGetPolarity(void);
void    OEPolarityAdjust(LPRECT pRects, UINT cRects);
void    OEPenWidthAdjust(LPRECT lprc, UINT divisor);
BOOL    OETwoWayRopToThree(int, LPDWORD);

BOOL    OEClippingIsSimple(void);
BOOL    OEClippingIsComplex(void);
BOOL    OECheckPenIsSimple(void);
BOOL    OECheckBrushIsSimple(void);

void    OEExpandColor(LPBYTE lpField, DWORD clrSrc, DWORD fieldMask);
void    OEConvertColor(DWORD rgb, LPTSHR_COLOR lptshrDst, BOOL fAllowDither);
void    OEGetBrushInfo(LPTSHR_COLOR pClrBack, LPTSHR_COLOR pClrFore,
    LPTSHR_UINT32 lpBrushStyle, LPTSHR_UINT32 lpBrushHatch, LPBYTE lpBrushExtra);


void    OEAddLine(POINT ptStart, POINT ptEnd);
void    OEAddBlt(DWORD rop);
void    OEAddOpaqueRect(LPRECT);
void    OEAddRgnPaint(HRGN hrgnnPaint, HBRUSH hbrPaint, UINT rop);
void    OEAddPolyline(POINT ptStart, LPPOINT apts, UINT cpts);
void    OEAddPolyBezier(POINT ptStart, LPPOINT apts, UINT cpts);


//
// Cached font width info
//
typedef struct tagFH_CACHE
{
    UINT    fontIndex;
    UINT    fontWidth;
    UINT    fontHeight;
    UINT    fontWeight;
    UINT    fontFlags;
    UINT    charWidths[256];
} FH_CACHE, FAR* LPFH_CACHE;

void    OEAddText(POINT ptDst, UINT uOptions, LPRECT lprcClip, LPSTR lpszText,
            UINT cchText, LPINT lpdxCharSpacing);
int     OEGetStringExtent(LPSTR lpszText, UINT cchText, LPINT lpdxCharSpacing, LPRECT lprcExtent);
BOOL    OECheckFontIsSupported(LPSTR lpszText, UINT cchText, LPUINT pFontHeight,
    LPUINT pFontWidth, LPUINT pFontWeight, LPUINT pFontFlags,
    LPUINT pFontIndex, LPBOOL lpfSendDeltaX);
BOOL    OEAddDeltaX(LPEXTTEXTOUT_ORDER pExtTextOut, LPSTR lpszText, UINT cchText,
    LPINT lpdxCharSpacing, BOOL fSendDeltaX, POINT ptStart);

#else

void    OELPtoVirtual(LPPOINT pPoints, UINT cPoints);
void    OELRtoVirtual(LPRECT pRects, UINT cRects);

void    OEClipAndAddOrder(LPINT_ORDER pOrder, void FAR * pExtraInfo, CLIPOBJ* pco);
void    OEClipAndAddScreenData(LPRECT pRect, CLIPOBJ* pco);

BOOL    OEClippingIsSimple(CLIPOBJ* pco);
BOOL    OEClippingIsComplex(CLIPOBJ* pco);
BOOL    OECheckBrushIsSimple(LPOSI_PDEV ppdev, BRUSHOBJ* pbo, POE_BRUSH_DATA * ppBrush);

void    OEExpandColor(LPBYTE lpField, ULONG clrSrc, ULONG mask);
void    OEConvertColor(LPOSI_PDEV ppdev, LPTSHR_COLOR pDCColor, ULONG osColor, XLATEOBJ* pxlo);
BOOL    OEAddLine(LPOSI_PDEV ppdev,
                             LPPOINT  startPoint,
                             LPPOINT  endPoint,
                             LPRECT   rectTrg,
                             UINT  rop2,
                             UINT  width,
                             UINT  color,
                             CLIPOBJ*  pco);


BOOL  OEAccumulateOutput(SURFOBJ* pso, CLIPOBJ *pco, LPRECT pRect);
BOOL  OEAccumulateOutputRect( SURFOBJ* pso, LPRECT pRect);


BOOL  OEStoreBrush(LPOSI_PDEV ppdev,
                                BRUSHOBJ* pbo,
                                BYTE   style,
                                LPBYTE  pBits,
                                XLATEOBJ* pxlo,
                                BYTE   hatch,
                                UINT  color1,
                                UINT  color2);

BOOL  OECheckFontIsSupported(FONTOBJ*  pfo, LPSTR lpszText, UINT cchText,
    LPUINT fontHeight, LPUINT pFontAscent, LPUINT pFontWidth,
    LPUINT pFontWeight, LPUINT pFontFlags, LPUINT pFontIndex,
    LPBOOL pfSendDeltaX);


void  OETileBitBltOrder(LPINT_ORDER               pOrder,
                                     LPMEMBLT_ORDER_EXTRA_INFO pExtraInfo,
                                     CLIPOBJ*                 pco);

void  OEAddTiledBitBltOrder(LPINT_ORDER               pOrder,
                                         LPMEMBLT_ORDER_EXTRA_INFO pExtraInfo,
                                         CLIPOBJ*                 pco,
                                         int                      xTile,
                                         int                      yTile,
                                         UINT                 tileWidth,
                                         UINT                 tileHeight);

BOOL OEEncodePatBlt(LPOSI_PDEV   ppdev,
                                 BRUSHOBJ   *pbo,
                                 POINTL     *pptlBrush,
                                 BYTE       rop3,
                                 LPRECT     pBounds,
                                 LPINT_ORDER *ppOrder);

#endif // !IS_16

#endif // DLL_DISP



//
// Structures and typedefs.
//

//
// Remote font is the structure we store for each font received from a
// remote party.  It mirrors the NETWORKFONT structure, with the facename
// replaced with an index value (used to map the remote font handle to the
// correct local font handle).
//
typedef struct _OEREMOTEFONT
{
    TSHR_UINT16    rfLocalHandle;
    TSHR_UINT16    rfFontFlags;
    TSHR_UINT16    rfAveWidth;
    TSHR_UINT16    rfAveHeight;
    // lonchanc: rfAspectX and rfAspectY are used in network packet header
    // for both R11 and R20. So, keep it around!
    TSHR_UINT16    rfAspectX;          // New field for r1.1
    TSHR_UINT16    rfAspectY;          // New field for r1.1
    TSHR_UINT8     rfSigFats;          // New field for r2.0
    TSHR_UINT8     rfSigThins;         // New field for r2.0
    TSHR_UINT16    rfSigSymbol;        // New field for r2.0
    TSHR_UINT16    rfCodePage;         // New field for R2.0
    TSHR_UINT16    rfMaxAscent;        // New field for R2.0
}
OEREMOTEFONT, * POEREMOTEFONT;


void    OEMaybeEnableText(void);
BOOL    OERectIntersectsSDA(LPRECT pRectVD);

BOOL    OESendRop3AsOrder(BYTE rop3);



#endif // _H_OE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\oa.h ===
//
// Order Accumulator
//

#ifndef _H_OA
#define _H_OA


#include <osi.h>

//
// Specific values for OSI escape codes
//
#define OA_ESC(code)                (OSI_OA_ESC_FIRST + code)
#define OA_ESC_FLOW_CONTROL         OA_ESC(0)


//
// Flow control constants for sizes/depths when slow, fast, etc.  The
// SLOW/FAST heap sizes are simply for spoiling.  OA_HEAP_MAX is really
// the size of the heap.
//
#define OA_FAST_HEAP                50000
#define OA_SLOW_HEAP                20000

//
// NOTE:  This is 64K - sizeof OA_SHARED_DATA header
//        If you add fields to header, subtract from this value
//
#define OA_HEAP_MAX                 65512

//
// Flow control constants for depth of order spoiling
//
#define OA_FAST_SCAN_DEPTH               50
#define OA_SLOW_SCAN_DEPTH              500


//
// Threshold for switching from FAST to SLOW order accum
//
#define OA_FAST_THRESHOLD           20000

//
// Value to indicate that you have reached the end of the order list
//
#define OA_NO_LIST          -1


#ifdef DLL_DISP

#define OA_SHM_START_WRITING    SHM_StartAccess(SHM_OA_DATA)
#define OA_SHM_STOP_WRITING     SHM_StopAccess(SHM_OA_DATA)

#define OA_FST_START_WRITING    SHM_StartAccess(SHM_OA_FAST)
#define OA_FST_STOP_WRITING     SHM_StopAccess(SHM_OA_FAST)

#else

#define OA_SHM_START_READING    g_poaData[\
        1 - g_asSharedMemory->displayToCore.newBuffer]
#define OA_SHM_STOP_READING


#define OA_SHM_START_WRITING    g_poaData[\
        1 - g_asSharedMemory->displayToCore.newBuffer]
#define OA_SHM_STOP_WRITING


#define OA_FST_START_READING    &g_asSharedMemory->oaFast[\
        1 - g_asSharedMemory->fastPath.newBuffer]
#define OA_FST_STOP_READING     


#define OA_FST_START_WRITING    &g_asSharedMemory->oaFast[\
        1 - g_asSharedMemory->fastPath.newBuffer]
#define OA_FST_STOP_WRITING     


#endif


//
// Maximum memory allowed for variable order data.
//
#define MAX_ADDITIONAL_DATA_BYTES 400000

//
// Invalid value to assign to deallocated order header pointers.
//
#define OA_DEAD_ORDER ((void FAR *)0xffffffff)

//
// Define the space to be reserved at the beginning of the segment
// for heap management.
//
#define RESERVED_HEAP_BYTES 16

//
// Define clip function return codes.
//
#define CR_NO_OVERLAP        1
#define CR_COMPLETE_OVERLAP  2
#define CR_SIMPLE_CLIP       3
#define CR_COMPLEX_OVERLAP   4
#define CR_COMPLEX_CLIP      5

//
// Macros that return the width and height of an order.
//
#define ORDER_WIDTH(pOrder) \
 ( pOrder->OrderHeader.Common.rcsDst.right - \
                                pOrder->OrderHeader.Common.rcsDst.left + 1 )
#define ORDER_HEIGHT(pOrder) \
 ( pOrder->OrderHeader.Common.rcsDst.bottom - \
                                pOrder->OrderHeader.Common.rcsDst.top + 1 )

//
// Define the minimum width and height of an order for us to try to spoil
// previous orders with it.  This helps performance, because it saves us
// trying to spoil earlier orders with very small orders.  However, if the
// order exceeds the FULL_SPOIL values then we spoil as originally, with
// the proviso that flow control may still prevent it.
//
#define FULL_SPOIL_WIDTH  16
#define FULL_SPOIL_HEIGHT 16


//
// Define a macro that calculates whether a rectangle lies completely
// within another rectangle.
//
#define RECT1_WITHIN_RECT2(rect1, rect2)   \
        ( (rect1.left   >= rect2.left  ) &&    \
          (rect1.top    >= rect2.top   ) &&    \
          (rect1.right  <= rect2.right ) &&    \
          (rect1.bottom <= rect2.bottom) )



//
// Structure: OA_NEW_PARAMS
//
// Description:
//
// Structure to pass new OA parameters down to the display driver from the
// Share Core.
//
//

enum
{
    OAFLOW_FAST = 0,
    OAFLOW_SLOW
};

typedef struct tagOA_FLOW_CONTROL
{
    OSI_ESCAPE_HEADER   header;     // Common header
    DWORD               oaFlow;     // Type -- fast, slow, etc.
}
OA_FLOW_CONTROL;
typedef OA_FLOW_CONTROL FAR * LPOA_FLOW_CONTROL;

//
// Structure used to store orders in the shared memory
//
// totalHeapOrderBytes       - Total bytes used in the order heap
//
// totalOrderBytes           - Total bytes used by order data
//
// totalAdditionalOrderBytes - Total bytes used as additional order data
//
// nextOrder                 - Offset for start of next new order
//
// orderListHead             - Order list head (uses standard BASEDLIST
//                             manipulation code)
//
// orderHeap                 - Order heap
//
typedef struct tagOA_SHARED_DATA
{
    DWORD       totalHeapOrderBytes;
    DWORD       totalOrderBytes;
    DWORD       totalAdditionalOrderBytes;
    LONG        nextOrder;

    BASEDLIST      orderListHead;

    BYTE        orderHeap[OA_HEAP_MAX];
}
OA_SHARED_DATA;
typedef OA_SHARED_DATA FAR * LPOA_SHARED_DATA;

//
// Structure used to store orders in the shared memory
//
// ordersAccumulated         - number of orders accumulated in the heap
//                             since the last double buffer swap.
//
//
typedef struct tagOA_FAST_DATA
{
    DWORD     ordersAccumulated;
} OA_FAST_DATA;
typedef OA_FAST_DATA FAR * LPOA_FAST_DATA;


//
//
// INT_ORDER_HEADER
//
// This structure contains the Common header (containing the fields which
// are sent over the network) and some additional fields which are only
// used on the host side)
//
// list
//     Offset to next and previous orders in the list
//     This field does not need to be transmitted across the network.
//
// additionalOrderData
//     Offset to the additional data for this order.
//     This field does not need to be transmitted across the network.
//
// cbAdditionalOrderData
//     Size of the additional data for this order.
//     This field does not need to be transmitted across the network.
//
// Common
//     Common header (which IS sent over the network)
//
// N.B.  If you change this structure, please make sure that you haven't
// broken the code in SBCInitInternalOrders.
//
//
typedef struct INT_ORDER_HEADER
{
    BASEDLIST              list;
    LONG                additionalOrderData;
    WORD                cbAdditionalOrderDataLength;
    WORD                pad1;
    COM_ORDER_HEADER    Common;
} INT_ORDER_HEADER;
typedef INT_ORDER_HEADER FAR *LPINT_ORDER_HEADER;


//
// Define an order with the internal only fields defined (this is only used
// on the sending end)
//
typedef struct _INT_ORDER
{
    INT_ORDER_HEADER    OrderHeader;
    BYTE                abOrderData[1];
} INT_ORDER;
typedef INT_ORDER FAR *LPINT_ORDER;


// Structure: INT_COLORTABLE_ORDER_xBPP
//
// Description: Internal structures used to pass color table data to the
// share core.  These are never sent across the wire.
//
typedef struct tagINT_COLORTABLE_HEADER
{
    TSHR_UINT16    type;           // holds "CT" - INTORD_COLORTABLE
    TSHR_UINT16    bpp;            // 1, 4 or 8
} INT_COLORTABLE_HEADER, FAR * LPINT_COLORTABLE_HEADER;

typedef struct tagINT_COLORTABLE_ORDER_1BPP
{
    INT_COLORTABLE_HEADER   header;
    TSHR_RGBQUAD               colorData[2];
} INT_COLORTABLE_ORDER_1BPP, FAR * LPINT_COLORTABLE_ORDER_1BPP;

typedef struct tagINT_COLORTABLE_ORDER_4BPP
{
    INT_COLORTABLE_HEADER   header;
    TSHR_RGBQUAD               colorData[16];
} INT_COLORTABLE_ORDER_4BPP, FAR * LPINT_COLORTABLE_ORDER_4BPP;

typedef struct tagINT_COLORTABLE_ORDER_8BPP
{
    INT_COLORTABLE_HEADER   header;
    TSHR_RGBQUAD               colorData[256];
} INT_COLORTABLE_ORDER_8BPP, FAR * LPINT_COLORTABLE_ORDER_8BPP;



//
// Macro to calculate a basic internal order size (including the Order
// Header).
//
#define INT_ORDER_SIZE(pOrder) \
(pOrder->OrderHeader.Common.cbOrderDataLength + sizeof(INT_ORDER_HEADER))


//
// Macro to calculate the maximum possible size of an order, including
// any Additional Order Data.
//
#define MAX_ORDER_SIZE(pOrder) \
(INT_ORDER_SIZE(pOrder) + (pOrder->OrderHeader.cbAdditionalOrderDataLength))

//
// Macro to determine whether an order is SCRBLT_ORDER.
//
#define ORDER_IS_SCRBLT(pOrder) \
         (((LPSCRBLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_SCRBLT))

//
// Macro to determine whether an order is MEMBLT_ORDER.
//
#define ORDER_IS_MEMBLT(pOrder) \
     (((LPMEMBLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEMBLT) || \
      ((LPMEMBLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEMBLT_R2))

//
// Macro to determine whether an order is MEM3BLT_ORDER.
//
#define ORDER_IS_MEM3BLT(pOrder) \
    (((LPMEM3BLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEM3BLT) || \
     ((LPMEM3BLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEM3BLT_R2))



//
// PROTOTYPES
//

#ifdef DLL_DISP


//
// FUNCTION:      OA_DDProcessRequest
//
// DESCRIPTION:
//
// Called by the display driver to process an OA specific request
//
// PARAMETERS:    pso   - pointer to surface object
//                cjIn  - (IN)  size of request block
//                pvIn  - (IN)  pointer to request block
//                cjOut - (IN)  size of response block
//                pvOut - (OUT) pointer to response block
//
// RETURNS:       None
//
//
BOOL  OA_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
            DWORD cbResult);


//
//
// FUNCTION: OA_DDAllocOrderMem
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our own private
// Order Heap.
//
// Allocates any Additional Order Memory from global memory.  A pointer to
// the Additional Order Memory is stored within the allocated order's
// header (pOrder->OrderHeader.pAdditionalOrderData).
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated from Global Memory.  If this parameter is zero no
// additional order memory is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER OA_DDAllocOrderMem(UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength );

//
//
// OA_DDFreeOrderMem(..)
//
// Frees order memory allocated by OA_AllocOrderMem(..).
// Frees order memory from our own private heap.
// Frees any Additional Order Memory associated with this order.
//
// Order memory is normally freed when the order is transmitted.
//
// This will be used if order memory has been allocated, and
// subsequently, before the order is passed to AddOrder(..), the
// allocator decides that the order should not be sent (e.g. if it
// is completely clipped out).
//
//
void OA_DDFreeOrderMem(LPINT_ORDER pOrder);

void OA_DDResetOrderList(void);

LPINT_ORDER OA_DDRemoveListOrder(LPINT_ORDER pCondemnedOrder);

void OA_DDSyncUpdatesNow(void);

//
// Name:      OA_DDSpoilOrdersByRect
//
// Purpose:   Try to spoil orders by a given rectangle.
//
// Returns:   Nothing
//
// Params:    IN    pRect - Pointer to the spoiling rectangle
//
// Operation: This function will start at the end of the order heap (from
//            the newest order) and work towards the start of the heap.
//
void OA_DDSpoilOrdersByRect(LPRECT pRect);


//
//
// OA_DDAddOrder(..)
//
// Adds an order to the queue for transmission.
//
// If the new order is completely covered by the current SDA then
// it is spoilt.
//
// If the order is opaque and overlaps earlier orders it may clip
// or spoil them.
//
// Called by the GDI interception code.
//
//
void OA_DDAddOrder(LPINT_ORDER pNewOrder, void FAR * pExtraInfo);


void     OADDAppendToOrderList(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pNewOrder);

LPINT_ORDER OADDAllocOrderMemInt(LPOA_SHARED_DATA lpoaShared, UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength);

void     OADDFreeOrderMemInt(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder);

void     OADDFreeAllOrders(LPOA_SHARED_DATA lpoaShared);

BOOL     OADDCompleteOverlapRect(LPTSHR_RECT16 prcsSrc, LPRECT prcsOverlap);

void     OATrySpoilingByOrders(void);

void     OADDSpoilFromOrder(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder, LPRECT pRect);


#ifdef DEBUG
void    CheckOaHeap(LPOA_SHARED_DATA);
#else
#define CheckOaHeap(lpoaShared)
#endif

#endif // !DLL_DISP

#endif // _H_OA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\od.h ===
//
// Order Decoder
//

#ifndef _H_OD
#define _H_OD



//
// Max # of accumulated bound rects we'll save in the total invalid
// region before simplifying it.
//
#define MAX_UPDATE_REGION_ORDERS 300


//
// Constants used by ODAdjustVGAColor (qv)
//
enum
{
    OD_BACK_COLOR   = 0,
    OD_FORE_COLOR   = 1,
    OD_PEN_COLOR    = 2,
    // number of the above colors.
    OD_NUM_COLORS   = 3
};


COLORREF __inline ODCustomRGB(BYTE r, BYTE g, BYTE b, BOOL fPaletteRGB)
{
    if (fPaletteRGB)
    {
        return(PALETTERGB(r, g, b));
    }
    else
    {
        return(RGB(r, g, b));
    }
}


//
// Structure used by ODAdjustVGAColor (qv)
//
typedef struct tagOD_ADJUST_VGA_STRUCT
{
    COLORREF    color;
    UINT        addMask;
    UINT        andMask;
    UINT        testMask;
    TSHR_COLOR  result;
}
OD_ADJUST_VGA_STRUCT;


//
// This internal routine is implemented as a macro rather than a function.
//
UINT __inline ODConvertToWindowsROP(UINT bRop)
{
    extern const UINT s_odWindowsROPs[256];

    ASSERT(bRop < 256);
    return(s_odWindowsROPs[bRop]);
}



#endif // _H_OD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\oe2.h ===
//
// Order Encoder 2nd Level
//

#ifndef _H_OE2
#define _H_OE2


//
//
// TYPEDEFS
//
//

//
// The party order data structure contains all the data that is used by
// either the 2nd level encoder or decoder to store info on a party.
//
// The encoder contains just 1 instance of this structure, for the local
// party.
//
// The decoder contains 1 instance of the structure per remote party.
//
typedef struct _PARTYORDERDATA
{
    STRUCTURE_STAMP

    //
    // A copy of the last order of each type.
    // These are stored as byte array because we dont have a structure
    // defined that has the header and the particular order defined.
    //
    BYTE LastDstblt[sizeof(COM_ORDER_HEADER)+sizeof(DSTBLT_ORDER)];
    BYTE LastPatblt[sizeof(COM_ORDER_HEADER)+sizeof(PATBLT_ORDER)];
    BYTE LastScrblt[sizeof(COM_ORDER_HEADER)+sizeof(SCRBLT_ORDER)];
    BYTE LastMemblt[sizeof(COM_ORDER_HEADER)+sizeof(MEMBLT_ORDER)];
    BYTE LastMem3blt[sizeof(COM_ORDER_HEADER)+sizeof(MEM3BLT_ORDER)];
    BYTE LastRectangle[sizeof(COM_ORDER_HEADER)+sizeof(RECTANGLE_ORDER)];
    BYTE LastLineTo[sizeof(COM_ORDER_HEADER)+sizeof(LINETO_ORDER)];
    BYTE LastTextOut[sizeof(COM_ORDER_HEADER)+sizeof(TEXTOUT_ORDER)];
    BYTE LastExtTextOut[sizeof(COM_ORDER_HEADER)+sizeof(EXTTEXTOUT_ORDER)];
    BYTE LastOpaqueRect[sizeof(COM_ORDER_HEADER)+sizeof(OPAQUERECT_ORDER)];
    BYTE LastSaveBitmap[sizeof(COM_ORDER_HEADER)+sizeof(SAVEBITMAP_ORDER)];
    BYTE LastDeskScroll[sizeof(COM_ORDER_HEADER)+sizeof(DESKSCROLL_ORDER)];
    BYTE LastMembltR2[sizeof(COM_ORDER_HEADER)+sizeof(MEMBLT_R2_ORDER)];
    BYTE LastMem3bltR2[sizeof(COM_ORDER_HEADER)+sizeof(MEM3BLT_R2_ORDER)];
    BYTE LastPolygon[sizeof(COM_ORDER_HEADER)+sizeof(POLYGON_ORDER)];
    BYTE LastPie[sizeof(COM_ORDER_HEADER)+sizeof(PIE_ORDER)];
    BYTE LastEllipse[sizeof(COM_ORDER_HEADER)+sizeof(ELLIPSE_ORDER)];
    BYTE LastArc[sizeof(COM_ORDER_HEADER)+sizeof(ARC_ORDER)];
    BYTE LastChord[sizeof(COM_ORDER_HEADER)+sizeof(CHORD_ORDER)];
    BYTE LastPolyBezier[sizeof(COM_ORDER_HEADER)+sizeof(POLYBEZIER_ORDER)];
    BYTE LastRoundRect[sizeof(COM_ORDER_HEADER)+sizeof(ROUNDRECT_ORDER)];

    //
    // The type and a pointer to the last order
    //
    BYTE     LastOrderType;
    LPCOM_ORDER  pLastOrder;

    //
    // Details of the last font that was used
    //
    HFONT     LastHFONT;
    UINT      LastCodePage;
    UINT      LastFontWidth;
    UINT      LastFontHeight;
    UINT      LastFontWeight;
    UINT      LastFontFlags;
    UINT      LastFontFaceLen;
    char      LastFaceName[FH_FACESIZE];

    //
    // The last bounds that were used.
    //
    TSHR_RECT16    LastBounds;

    //
    // Font metrics, currently unused by the encoder.
    //
    TEXTMETRIC      LastFontMetrics;

    //
    // An array of pointers to the last orders of each type.
    //
    void *     LastOrder[OE2_NUM_TYPES];
}
PARTYORDERDATA, * PPARTYORDERDATA, * * PPPARTYORDERDATA;


//
//  This structure contains information for a single field in an ORDER
//  structure
//
//  FieldPos          - The byte offset into the order structure to the
//                      start of the field.
//
//  FieldUnencodedLen - The length in bytes of the unencoded field.
//
//  FieldEncodedLen   - The length in bytes of the encoded field.  This
//                      should always be <= to FieldUnencodedLen.
//
//  FieldSigned       - Does this field contain a signed or unsigned value?
//
//  FieldType         - A description of the type of the field - this
//                      is used to determine how to encode / decode the
//                      field.
//
//
typedef struct tagOE2ETFIELD
{
    UINT      FieldPos;
    UINT      FieldUnencodedLen;
    UINT      FieldEncodedLen;
    BOOL      FieldSigned;
    UINT      FieldType;
}OE2ETFIELD;

typedef OE2ETFIELD const FAR * POE2ETFIELD;

//
// Array of pointers to the entries in the encoding table
//
typedef POE2ETFIELD  OE2ETTYPE[OE2_NUM_TYPES];

//
//  This structure contains information allowing an ORDER structure to be
//  encoded or decoded into a DCEO2ORDER structure.
//  The order table comprises
//
//      - an array of POE2ETFIELD pointers, indexed by the encoded type
//         index:
//
//              typedef OE2ETTYPE POE2ETFIELD[OE2_NUM_TYPES]
//
//      - one array of OE2ETFIELD structures for each of the 7 order
//         types (each order type has a different number of fields).
//         Note that there may not be more than 24 entries for a single
//         ORDER type.  The entries for an order type are terminated
//         by an entry with the FieldPos field set to 0.  The first
//         FieldPos is non-zero since it is the offset to the second
//         field of the order (type is ignored).
//
//  pFields - an array of POE2ETFIELD pointers, indexed by the encoded
//             type index.  This is used to identify the entry in this
//             table for an ORDER type.
//
//  NumFields - an array of bytes containing the number of fields in each
//              order structure for each order.
//
//  DstBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the DSTBLT_ORDER
//
//  PatBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the PATBLT_ORDER
//
//  ScrBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the SCRBLT_ORDER
//
//  MemBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the MEMBLT_ORDER
//
//  Mem3BltFields - array of OE2ETFIELD structures (one for each field)
//                     for the MEM3BLT_ORDER
//
//  TextOutFields - array of OE2ETFIELD structures (one for each field)
//                     for the TEXTOUT_ORDER
//
//  ExtTextOutFields - array of OE2ETFIELD structures (one for each field)
//                     for the EXTTEXTOUT_ORDER
//
//  RectangleFields - array of OE2ETFIELD structures (one for each field)
//                     for the RECTANGLE_ORDER
//
//  LineToFields - array of OE2ETFIELD structures (one for each field)
//                    for the LINETO_ORDER
//
//  OpaqueRectFields - array of OE2ETFIELD structures (one for each field)
//                    for the OPQAUERECT_ORDER
//
//  SaveBitmapFields - array of OE2ETFIELD structures (one for each field)
//                    for the SAVEBITMAP_ORDER
//
//  DeskScrollFields - array of OE2ETFIELD structures (one for each field)
//                    for the DESKSCROLL_ORDER
//  etc.
//
//
typedef struct tagOE2ETTABLE
{
        POE2ETFIELD pFields           [OE2_NUM_TYPES];
        BYTE     NumFields         [OE2_NUM_TYPES];
        OE2ETFIELD  DstBltFields      [OE2_NUM_DSTBLT_FIELDS];
        OE2ETFIELD  PatBltFields      [OE2_NUM_PATBLT_FIELDS];
        OE2ETFIELD  ScrBltFields      [OE2_NUM_SCRBLT_FIELDS];
        OE2ETFIELD  MemBltFields      [OE2_NUM_MEMBLT_FIELDS];
        OE2ETFIELD  Mem3BltFields     [OE2_NUM_MEM3BLT_FIELDS];
        OE2ETFIELD  TextOutFields     [OE2_NUM_TEXTOUT_FIELDS];
        OE2ETFIELD  ExtTextOutFields  [OE2_NUM_EXTTEXTOUT_FIELDS];
        OE2ETFIELD  RectangleFields   [OE2_NUM_RECTANGLE_FIELDS];
        OE2ETFIELD  LineToFields      [OE2_NUM_LINETO_FIELDS];
        OE2ETFIELD  OpaqueRectFields  [OE2_NUM_OPAQUERECT_FIELDS];
        OE2ETFIELD  SaveBitmapFields  [OE2_NUM_SAVEBITMAP_FIELDS];
        OE2ETFIELD  DeskScrollFields  [OE2_NUM_DESKSCROLL_FIELDS];
        OE2ETFIELD  MemBltR2Fields    [OE2_NUM_MEMBLT_R2_FIELDS];
        OE2ETFIELD  Mem3BltR2Fields   [OE2_NUM_MEM3BLT_R2_FIELDS];
        OE2ETFIELD  PolygonFields     [OE2_NUM_POLYGON_FIELDS];
        OE2ETFIELD  PieFields         [OE2_NUM_PIE_FIELDS];
        OE2ETFIELD  EllipseFields     [OE2_NUM_ELLIPSE_FIELDS];
        OE2ETFIELD  ArcFields         [OE2_NUM_ARC_FIELDS];
        OE2ETFIELD  ChordFields       [OE2_NUM_CHORD_FIELDS];
        OE2ETFIELD  PolyBezierFields  [OE2_NUM_POLYBEZIER_FIELDS];
        OE2ETFIELD  RoundRectFields   [OE2_NUM_ROUNDRECT_FIELDS];
} OE2ETTABLE;

//
//
// MACROS
//
//
//
// #define used to check that there is enough room left in the buffer
// for the encoded data which is about to be copied in.
//
#define ENOUGH_BUFFER(bend, start, datalen)   \
                  ( ((LPBYTE)(start)+(datalen)) <= (bend) )


//
// FUNCTION: OE2GetOrderType
//
// DESCRIPTION:
//
// This function converts the two byte flag used in an ORDER to record the
// type of order into an internal single byte value
//
// PARAMETERS:
//
//  pOrder    -  A pointer to the order
//
// RETURNS:
//
//  The type of the order (internal single byte value - see above)
//
//
BYTE OE2GetOrderType(LPCOM_ORDER  pOrder);

BOOL OE2CanUseDeltaCoords(void *  pNewCoords,
                                       void *  pOldCoords,
                                       UINT   fieldLength,
                                       BOOL   signedValue,
                                       UINT   numElements);

void OE2CopyToDeltaCoords(LPTSHR_INT8* ppDestination,
                                       void *  pNewCoords,
                                       void *  pOldCoords,
                                       UINT   fieldLength,
                                       BOOL   signedValue,
                                       UINT   numElements);


//
// FUNCTION: OE2EncodeField
//
// DESCRIPTION:
//
// Convert a field which is an array of 1 or more elements, from its
// encoded form to its decoded form.
//
// PARAMETERS:
//
// pSrc            - Array of source values.
// ppDest          - Array of destination values.
// srcFieldLength  - The size of each of the elements in the source array.
// destFieldLength - The size of each of the elements in the destination
//                   array.
// signedValue     - Is the element a signed value ?
// numElements     - The number of elements in the arrays.
//
// RETURNS:
//
// None.
//
//
void OE2EncodeField(void *    pSrc,
                                 PBYTE*  ppDest,
                                 UINT     srcFieldLength,
                                 UINT     destFieldLength,
                                 BOOL     signedValue,
                                 UINT     numElements);


#endif // _H_OE2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\rbc.h ===
//
// Received Bitmap Cache
//

#ifndef _H_RBC
#define _H_RBC


//
// Number of RGB entries in the colour tables.
//
#define RBC_MAX_PALETTE_ENTRIES 256


//
// Information stored for each remote host.
//
typedef struct tagRBC_HOST_INFO
{
    STRUCTURE_STAMP

    BMC_DIB_CACHE   bitmapCache[NUM_BMP_CACHES];
}
RBC_HOST_INFO;

typedef RBC_HOST_INFO  * PRBC_HOST_INFO;



#endif // _H_RBC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\pm.h ===
//
// Palette Manager
//

#ifndef _H_PM
#define _H_PM



//
//
// CONSTANTS
//
//


//
// The number of true greys we want a true color system to deliver from a
// GetDIBits call. To vary this (number of greys and/or grey RGBs)
// -  alter the number defined for PM_GREY_COUNT below
// -  define suitable values for the grey RGBs below (PM_LIGHT_GREY, etc)
// -  change the initialisers for pmOurGreyRGB in wpmdata.c
// -  recompile the entire PM component.
//
#define PM_GREY_COUNT 5

//
// Grey RGBs passed into the true color display driver for conversion to
// a driver representation via an 8bpp GetDIBits.
//
#define PM_GREY1      0x00C0C0C0
#define PM_GREY2      0x00808080
#define PM_GREY3      0x006a6a6a
#define PM_GREY4      0x00555555
#define PM_GREY5      0x00333333



#define PM_NUM_1BPP_PAL_ENTRIES         2
#define PM_NUM_4BPP_PAL_ENTRIES         16
#define PM_NUM_8BPP_PAL_ENTRIES         256
#define PM_NUM_TRUECOLOR_PAL_ENTRIES    0


//
// The color table cache structure
//
typedef struct tagCOLORTABLECACHE
{
    BOOL    inUse;
    UINT    cColors;
    TSHR_RGBQUAD colors[256];
}
COLORTABLECACHE;
typedef COLORTABLECACHE * PCOLORTABLECACHE;



#endif // _H_PM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\sc.h ===
//
// Share Controller
//

#ifndef _H_SC
#define _H_SC


//
//
// CONSTANTS
//
//

//
// Values for compression support array
// - PR_UNKNOWN - don't know (yet) what level this party supports
// - PR_LEVEL1  - Only PKZIP compression is supported.  Compressed packets
//                are identified by the top bit of the compressionType
//                field.  All other bits of compressionType are meaningless
// - PR_LEVEL2  - Multiple compression types are supported.  The compression
//                used for each packet is identified by the compressionType
//                field.
//
#define PR_UNKNOWN  0
#define PR_LEVEL1   1
#define PR_LEVEL2   2




//
// STATES
//
//


enum
{
    SCS_TERM            = 0,
    SCS_INIT,
    SCS_SHAREENDING,
    SCS_SHAREPENDING,
    SCS_SHARING,
    SCS_NUM_STATES
};

//
// Number of supported streams 
// THIS MUST MATCH PROT_STR values!
//
#define SC_STREAM_LOW      1
#define SC_STREAM_HIGH     4
#define SC_STREAM_COUNT    4



//
// Sync status constants
//
#define SC_NOT_SYNCED      0
#define SC_SYNCED          1




//
// PROTOTYPES
//


//
// SC_Init()
// SC_Term()
//
// Init and term routines
//
BOOL SC_Init(void);
void SC_Term(void);



UINT SC_Callback(UINT eventType, MCSID mcsID, UINT cbData1, UINT cbData2, UINT cbData3);

BOOL SC_Start(UINT mcsIDLocal);
void SC_End(void);

//
// SC_CreateShare(): S20_CREATE or S20_JOIN
//
BOOL SC_CreateShare(UINT what);
//
// SC_EndShare()
//
void SC_EndShare(void);


void SCCheckForCMCall(void);

#endif // _H_SC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\s20.h ===
//
// Share 2.0 Interface
//

#ifndef _H_S20
#define _H_S20


BOOL S20_Init(void);
void S20_Term(void);


//
// We can send to one person or broadcast to everyone listening to the
// app sharing channel.  The userID for one person is the mcsID, we get it
// in S20 create/join/respond packets along with name + caps.
//

PS20DATAPACKET S20_AllocDataPkt(UINT streamID, UINT_PTR nodeID, UINT_PTR len);
void S20_FreeDataPkt(PS20DATAPACKET pPacket);
void S20_SendDataPkt(UINT streamID, UINT_PTR nodeID, PS20DATAPACKET pPacket);


//
// API FUNCTION: S20_UTEventProc
//
// DESCRIPTION:
//
// Handles NET_EVENTS
//
// PARAMETERS: standard UT event handler
//
// RETURNS: standard UT event handler
//
BOOL CALLBACK S20_UTEventProc(LPVOID userData, UINT event, UINT_PTR data1, UINT_PTR data2);


//
//
// CONSTANTS
//
//


//
// States
//
typedef enum
{
    S20_TERM                = 0,
    S20_INIT,
    S20_ATTACH_PEND,
    S20_JOIN_PEND,
    S20_NO_SHARE,
    S20_SHARE_PEND,
    S20_SHARE_STARTING,
    S20_IN_SHARE,
    S20_NUM_STATES
}
S20_STATE;


#define S20_MAX_QUEUED_CONTROL_PACKETS             20

//
// These pool sizes and latencies control how DC Share T120 flow control
// behaves.  They are tuned for performance so you had better understand
// what you are doing if you change them!
//
// For example, can you explain why any setting other than 0 for the medium
// priority will break DC Share?  If not then go and read/understand
// amgcflo.c and then look at how DC-Share will interact with it.
//
// To summarize:
//
// We don't control the top priority or medium priority pools because they
// carry non-spoilable data that must therefore flow at a lower bandwidth
// than the transport.  In fact, applying back pressure to these streams
// will cause DC-Share to fail in some cases.
//
// Low priority is where flow control really takes effect, since we want
// the pipe to open right up (to 200K per ping) over fast transports but
// to throttle back (to 1K per second possibly!) over slow transports.
//
//
#define S20_LATENCY_TOP_PRIORITY                    0
#define S20_LATENCY_HIGH_PRIORITY                   0
#define S20_LATENCY_MEDIUM_PRIORITY                 0
#define S20_LATENCY_LOW_PRIORITY                 7000

#define S20_SIZE_TOP_PRIORITY                       0
#define S20_SIZE_HIGH_PRIORITY                      0
#define S20_SIZE_MEDIUM_PRIORITY                    0
#define S20_SIZE_LOW_PRIORITY                   99000


//
//
// MACROS
//
//

#define S20_GET_CREATOR(A) ((TSHR_UINT16)(A & 0xFFFF))


//
//
// TYPEDEFS
//
//
typedef struct tagS20CONTROLPACKETQENTRY
{
    UINT            what;
    TSHR_UINT32     correlator;
    UINT            who;
    UINT            priority;
}
S20CONTROLPACKETQENTRY;

typedef S20CONTROLPACKETQENTRY * PS20CONTROLPACKETQENTRY;

//
//
// PROTOTYPES
//
//

BOOL S20CreateOrJoinShare(
    UINT    what,
    UINT_PTR    callID);

void S20LeaveOrEndShare(void);

UINT S20MakeControlPacket(
    UINT      what,
    UINT      correlator,
    UINT      who,
    PS20PACKETHEADER * ppPacket,
    LPUINT     pLength,
    UINT      priority);

UINT S20FlushSendOrQueueControlPacket(
    UINT      what,
    UINT      correlator,
    UINT      who,
    UINT      priority);

UINT S20FlushAndSendControlPacket(
    UINT      what,
    UINT    correlator,
    UINT      who,
    UINT      priority);

UINT S20SendControlPacket(
    PS20PACKETHEADER  pPacket,
    UINT      length,
    UINT      priority);

UINT S20SendQueuedControlPackets(void);

void S20AttachConfirm(NET_UID userID, NET_RESULT result, UINT callID);
void S20DetachIndication(NET_UID userID, UINT callID);
void S20LeaveIndication(NET_CHANNEL_ID channelID, UINT callID);

void S20JoinConfirm(PNET_JOIN_CNF_EVENT pEvent);
void S20SendIndication(PNET_SEND_IND_EVENT pEvent);

void S20Flow(UINT priority, UINT newBufferSize);


void S20CreateMsg(PS20CREATEPACKET  pS20Packet);
void S20JoinMsg(PS20JOINPACKET  pS20Packet);
void S20RespondMsg(PS20RESPONDPACKET  pS20Packet);
void S20DeleteMsg(PS20DELETEPACKET  pS20Packet);
void S20LeaveMsg(PS20LEAVEPACKET  pS20Packet);
void S20EndMsg(PS20ENDPACKET  pS20Packet);
void S20DataMsg(PS20DATAPACKET  pS20Packet);
void S20CollisionMsg(PS20COLLISIONPACKET pS20Packet);

BOOL S20MaybeAddNewParty(MCSID mcsID,
    UINT      lenCaps,
    UINT      lenName,
    LPBYTE    pData);

void S20MaybeIssuePersonDelete(MCSID mcsID);

UINT S20NewCorrelator(void);

NET_PRIORITY S20StreamToS20Priority(UINT  streamID);


#endif // _H_S20

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\sbc.h ===
//
// Sent Bitmap Cache
//

#ifndef _H_SBC
#define _H_SBC


#include <oa.h>
#include <shm.h>
#include <osi.h>
#include <ch.h>
#include <bmc.h>


//
//
// Constants
//
//



#define SBC_NUM_THRASHERS   8       // The number of bitmaps we monitor for
                                    // "thrashiness" at any given time.

#define SBC_THRASH_INTERVAL 50      // The interval (in centi-seconds) at
                                    // which bitmaps have to change in
                                    // order to be classified as thrashers


//
// Eviction categories
//
#define SBC_NUM_CATEGORIES        3


//
// Specific values for OSI escape codes
//
#define SBC_ESC(code)                   (OSI_SBC_ESC_FIRST + code)

#define SBC_ESC_NEW_CAPABILITIES        SBC_ESC(0)



//
// Value indicating that a bitmap should not be fast pathed
//
#define SBC_DONT_FASTPATH       0xffffffff


//
// Index into sbcTileWorkInfo at which the data for various tile sizes is
// stored.
//
#define SBC_MEDIUM_TILE_INDEX       SHM_MEDIUM_TILE_INDEX
#define SBC_LARGE_TILE_INDEX        SHM_LARGE_TILE_INDEX
#define SBC_NUM_TILE_SIZES          SHM_NUM_TILE_SIZES





//
//
// Macros
//
//

//
// Calculate the number of bytes required for a tile entry of the given
// dimensions.
//
#define SBC_BYTES_PER_TILE(WIDTH, HEIGHT, BPP)              \
            (BYTES_IN_BITMAP((WIDTH), (HEIGHT), (BPP))      \
                + sizeof(SBC_TILE_DATA))                    \



//
// SBC_TILE_TYPE
//
// Given an SBC tile Id, return the tile type.
//
// Returns one of:
//      SBC_SMALL_TILE
//      SBC_LARGE_TILE
//
// The top bit of the Id is clear for small tiles, and set for large tiles.
//
#define SBC_TILE_TYPE(TILEID)  \
    (((TILEID) & 0x8000) ? SBC_LARGE_TILE_INDEX : SBC_MEDIUM_TILE_INDEX)





//
//
// Structures
//
//

//
// Structure: SBC_SHM_CACHE_INFO
//
// Description: Structure which is used to pass information about a bitmap
// cache from the share core to the display driver.
//
//
typedef struct tagSBC_SHM_CACHE_INFO
{
    WORD    cEntries;       // The number of entries in this cache.
    WORD    cCellSize;      // The maximum bytes available for each cache entry.
}
SBC_SHM_CACHE_INFO;
typedef SBC_SHM_CACHE_INFO FAR * LPSBC_SHM_CACHE_INFO;


//
// Structure: SBC_TILE_DATA
//
// Description: Structure used to pass the DIB bits for tile in a MEMBLT
// order from the driver to the share core.  There is an array of these
// structures in each SBC shunt buffer.
//
// Notes: The inUse field should only be set to TRUE by the driver when it
// has finished filling in the entry, and to FALSE by the share core when
// it has finished processing the data held in the entry.  When inUse is
// FALSE, the remaining data is not valid, and should not be accessed by
// the share core.
//
// The width and height fields give the dimensions of the data which is
// held in the bitData field.  If the tile is set up to hold a maximum
// of 32x32, the scanlines in bitData will always be 32 even if width is
// set to less than 32 - there will just be unused data at the end of each
// scanline.
//
//
typedef struct tagSBC_TILE_DATA
{
    WORD        inUse;              // Is this entry in use?
    WORD        tileId;             // An identifier for this entry.  This
                                    //   matches an ID stored in the
                                    //   cacheId field of a MEMBLT order
                                    //   passed from the driver to the
                                    //   share core in the order buffer.

    DWORD       bytesUsed;          // The number of bytes of data in
                                    //   bitData which is actually used for
                                    //   this entry.

    WORD        srcX;               // The source coordinates of the Mem(3)Blt
    WORD        srcY;

    WORD        width;              // The dimensions of the data in bitData
    WORD        height;

    WORD        tilingWidth;        // The dimensions at which tiling was
    WORD        tilingHeight;       //   carried out.  This is not
                                    //   necessarily the same as the
                                    //   dimensions of the tiles in this
                                    //   shunt buffer.

    DWORD_PTR   majorCacheInfo;     // Information which the share core can
    DWORD       minorCacheInfo;     //   use to optimize cache handling.
                                    //   A value of SBC_DONT_FASTPATH for
                                    //   majorCacheInfo indicates that the
                                    //   optimization should not be used.
                                    //

    DWORD_PTR   majorPalette;       // Palette information for the fast
    DWORD       minorPalette;       //   pathing.  These two fields
                                    //   uniquely identify the colour
                                    //   conversion object associated with
                                    //   the bitmap.

    BYTE        bitData[4];         // Start of the bit data.  The total
                                    //   number of bits is given by the
                                    //   numBits field of the
                                    //   SBC_SHUNT_BUFFER structure at the
                                    //   head of the shunt buffer which
                                    //   this entry is placed in.
} SBC_TILE_DATA;
typedef SBC_TILE_DATA FAR * LPSBC_TILE_DATA;



//
// Structure: SBC_SHUNT_BUFFER
//
// Description: Structure placed at the head of a shunt buffer used to pass
// bit data from the driver to the share core.  It is followed by an array
// of SBC_TILE_DATA structures.
//
// Note: The SBC_TILE_DATA structures are all the same size, but the size
// is not fixed at compile time (there are a variable number of bits), so
// do not use array notation to reference them.
//
//
typedef struct tagSBC_SHUNT_BUFFER
{
    DWORD           numBytes;       // The number of bytes in the bitData
                                    //   fields of the SBC_TILE_DATA stryct
    DWORD           structureSize;  // The total size of each SBC_TILE_DATA
                                    //   structure
    DWORD           numEntries;     // The number of SBC_TILE_DATA
                                    //   structures in the shunt buffer
    SBC_TILE_DATA   firstEntry;     // The first SBC_TILE_DATA entry

} SBC_SHUNT_BUFFER;
typedef SBC_SHUNT_BUFFER FAR * LPSBC_SHUNT_BUFFER;



//
// Structure: SBC_NEW_CAPABILITIES
//
// Description:
//
// Structure to pass new capabilities down to the display driver from the
// Share Core.
//
//
typedef struct tagSBC_NEW_CAPABILITIES
{
    OSI_ESCAPE_HEADER header;               // Common header

    DWORD               sendingBpp;         // Bpp at which bitmaps are sent

    LPSBC_SHM_CACHE_INFO cacheInfo;         // Caching details

} SBC_NEW_CAPABILITIES;
typedef SBC_NEW_CAPABILITIES FAR * LPSBC_NEW_CAPABILITIES;


//
// Structure: SBC_ORDER_INFO
//
// Description: This structure holds all the information SBC needs about
// the two internal orders which it stores to hold data color table and bit
// data for a MEMBLT order.
//
// pColorTableOrder is allocated with enough color table entries for
// usrSendingbpp bitmaps.
//
// pBitmapBitsOrder is allocated with enough room for the maximum tile size
// which we will send out at usrSendingbpp.
//
// If sentColorTable is TRUE, the data in pColorTableOrder may not be
// valid.
//
// If sentBitmapBits is TRUE, the data in pBitmapBitsOrder may not be
// valid.
//
//
typedef struct tagSBC_ORDER_INFO
{
    LPINT_ORDER  pColorTableOrder;       // Pointer to a color table order.
    LPINT_ORDER  pBitmapBitsOrder;       // Pointer to a bitmap bits order.
    DWORD        bitmapBitsDataSize;     // The number of bytes allocated
                                        //   for the data field of the
                                        //   bitmap bits order.
    LPINT_ORDER  pOrder;                 // Pointer to the MEMBLT order for
                                        //   which we currently hold data.
                                        //   DO NOT DEREFERENCE THIS - IT
                                        //   IS FOR NUMERICAL COMPARISON
                                        //   ONLY
    DWORD       validData;              // Do we have valid data for
                                        //   pOrder ?
    DWORD       sentColorTable;         // Has the color table been sent
                                        //   over the wire ?
    DWORD       sentBitmapBits;         // Have the bitmap bits been sent
                                        //   over the wire ?
    DWORD       sentMemBlt;             // Has the MEMBLT order itself been
                                        //   sent over the wire ?

}
SBC_ORDER_INFO, FAR * LPSBC_ORDER_INFO;



//
// Structure: SBC_TILE_WORK_INFO
//
// Description: This structure contains all the elements required for
// manipulating tiles of a given size.  There should be an array of these
// structures - one per tile size.
//
//
typedef struct tagSBC_TILE_WORK_INFO
{
    LPSBC_SHUNT_BUFFER   pShuntBuffer;   // Pointer to the shunt buffer to
                                        //   containing tiles of this tile
                                        //   size.
    UINT            mruIndex;       // The last entry accessed in
                                        //   the shunt buffer pointed to by
                                        //   pShuntBuffer.
    HBITMAP         workBitmap;     // The bitmap to use for processing
                                        //   this tile size.  This is
                                        //   tileWidth x tileHeight at
                                        //   native bpp.
#ifndef DLL_DISP
    LPBYTE          pWorkBitmapBits;// Pointer to the start of the bits
#endif // DLL_DISP
                                        //   in the bitmap.
    UINT            tileWidth;      // The width of workBitmap.
    UINT            tileHeight;     // The height of workBitmap.
} SBC_TILE_WORK_INFO, FAR * LPSBC_TILE_WORK_INFO;



//
// Structure: SBC_FASTPATH_ENTRY
//
// Description: Structure holding one entry in the SBC fast path.
//
//
typedef struct tagSBC_FASTPATH_ENTRY
{
    BASEDLIST      list;           // Offsets to the next / prev entries in
                                //   the fast path
    DWORD_PTR   majorInfo;      // Major cache info field passed up in the
                                //   shunt buffer for this cache entry
    DWORD       minorInfo;      // Minor cache info field passed up in the
                                //   shunt buffer for this cache entry
    DWORD_PTR   majorPalette;   // Major palette info from the shunt buffer
                                //   This is the pointer to the XLATEOBJ
    DWORD       minorPalette;   // Minor palette info from the shunt buffer
                                //   This is the iUniq of the XLATEOBJ

    LONG        srcX;           // The coordinate in the source bitmap of
    LONG        srcY;           //   the source of the MemBlt
    DWORD       width;          // The width / height of the entry in the
    DWORD       height;         //   cache.

    WORD        cache;          // The cache and index at which the bitmap
    WORD        cacheIndex;     //   stored.
    WORD        colorIndex;
    WORD        pad;

} SBC_FASTPATH_ENTRY, FAR * LPSBC_FASTPATH_ENTRY;


//
// Structure: SBC_FASTPATH
//
// Description: Structure holding the SBC fast pathing information.
//
//

#define SBC_FASTPATH_ENTRIES    100

typedef struct tagSBC_FASTPATH
{
    STRUCTURE_STAMP

    BASEDLIST              usedList;   // Offsets to the first / last used
                                    //   entries in the fast path.
    BASEDLIST              freeList;   // Offsets to the first / last free
                                    //   entries in the fast path.
    SBC_FASTPATH_ENTRY      entry[SBC_FASTPATH_ENTRIES];
}
SBC_FASTPATH;
typedef SBC_FASTPATH FAR * LPSBC_FASTPATH;


#ifdef DLL_DISP

// Structure: SBC_THRASHERS
//
// Description: Structure which is used to hold information about when a
// source surface (bitmap) last changed, in order to determine whether the
// surface will cause thrashing in the bitmap cache.
//

typedef struct tagSBC_THRASHERS
{
#ifdef IS_16
    HBITMAP     hsurf;
#else
    HSURF       hsurf;          // The hsurf of the surface object being
                                //   monitored.
    DWORD       iUniq;          // The last noted iUniq field from the
                                //   surface object being monitored.
#endif // IS_16
    DWORD       tickCount;      // The system tick count (in centi-seconds)
                                //   at which we last saw this surface
                                //   change
} SBC_THRASHERS;
typedef SBC_THRASHERS FAR * LPSBC_THRASHERS;


//
//
// Function prototypes
//
//


void SBCDDSetNewCapabilities(LPSBC_NEW_CAPABILITIES pRequest);

BOOL SBCDDGetNextFreeTile(int tileSize, LPSBC_TILE_DATA FAR * ppTileData);

DWORD SBCDDGetTickCount(void);

#ifdef IS_16
BOOL SBCDDCreateShuntBuffers(void);
#else
BOOL SBCDDCreateShuntBuffers(LPOSI_PDEV ppDev, LPBYTE psbcMem, DWORD sbcMem);
#endif

#ifndef IS_16
BOOL SBCDDIsBitmapThrasher(SURFOBJ * pSurfObj);
#endif // !IS_16


#endif // DLL_DISP


//
// SBC_TILE_PTR_FROM_INDEX
//
// Given a pointer to a shunt buffer and a tile index, return a pointer to
// the tile at the given index.
//
// Get a pointer to the first entry in the shunt buffer, and add INDEX
// times the size of each entry.
//
__inline LPSBC_TILE_DATA SBCTilePtrFromIndex(LPSBC_SHUNT_BUFFER pBuffer, UINT index)
{
    LPSBC_TILE_DATA lpsbc;

    lpsbc = (LPSBC_TILE_DATA)((LPBYTE)&pBuffer->firstEntry +
        index * pBuffer->structureSize);
    return(lpsbc);
}




#ifdef DLL_DISP

//
//
// Typedefs
//
//

#ifdef IS_16

typedef struct tagMEMBLT_ORDER_EXTRA_INFO
{
    HDC             hdcSrc;
    UINT            fuColorUse;
    LPVOID          lpBits;
    LPBITMAPINFO    lpbmi;
    HPALETTE        hpalDst;
    UINT            uPad;
} MEMBLT_ORDER_EXTRA_INFO, FAR* LPMEMBLT_ORDER_EXTRA_INFO;

#else
//
// Structure: MEMBLT_ORDER_EXTRA_INFO
//
// Description: Extra information required by SBC to process a MEMBLT
// order.
//
//
typedef struct tagMEMBLT_ORDER_EXTRA_INFO
{
    SURFOBJ*    pSource;        // Pointer to the source surface of the
                                //   MemBlt
    SURFOBJ*    pDest;          // Pointer to the destination surface of
                                //   the MemBlt
    XLATEOBJ*   pXlateObj;      // Pointer to the XlateObj used in the
                                //   MemBlt
} MEMBLT_ORDER_EXTRA_INFO, FAR * LPMEMBLT_ORDER_EXTRA_INFO;
#endif // !IS_16


//
// Name:      SBC_DDProcessRequest
//
// Purpose:   Process a request from the share core
//
// Returns:   TRUE if the request is processed successfully,
//            FALSE otherwise.
//
// Params:    IN     pso   - Pointer to surface object for our driver
//            IN     cjIn  - Size of the input data
//            IN     pvIn  - Pointer to the input data
//            IN     cjOut - Size of the output data
//            IN/OUT pvOut - Pointer to the output data
//
#ifdef IS_16
BOOL  SBC_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult, DWORD cbResult);
void  SBC_DDTossFromCache(HBITMAP);
#else
BOOL  SBC_DDProcessRequest(SURFOBJ*  pso, DWORD fnEscape,
            LPOSI_ESCAPE_HEADER pRequest, LPOSI_ESCAPE_HEADER pResult, DWORD cbResult);
#endif


//
// Name:      SBC_DDInit
//
// Purpose:   Initialize the device driver SBC specific "stuff".
//
#ifdef IS_16
BOOL SBC_DDInit(HDC hdc, LPDWORD ppShuntBuffers, LPDWORD pBitmasks);
#else
BOOL SBC_DDInit(LPOSI_PDEV ppDev, LPBYTE pRestOfMemory, DWORD cbRestOfMemory,
    LPOSI_INIT_REQUEST pResult);
#endif


//
// Name:      SBC_DDTerm
//
// Purpose:   Terminate the device driver SBC specific "stuff"
//
// Returns:   Nothing
//
// Params:    None
//
void SBC_DDTerm(void);


//
// Name:       SBC_DDIsMemScreenBltCachable
//
// Purpose:    Check to see whether a MemBlt is cachable.
//
// Returns:    TRUE if the MemBlt is cachable, FALSE otherwise.
//
// Params:     IN  pMemBltInfo - Info about the MEMBLT to be cached.
//
// Operation:  Note that if this function returns TRUE, it DOES NOT
//             guarantee that SBC_DDCacheMemScreenBlt will succeed.
//             However, a FALSE return code does guarantee that
//             SBC_DDCacheMemScreenBlt would fail.
//
BOOL SBC_DDIsMemScreenBltCachable(LPMEMBLT_ORDER_EXTRA_INFO pMemBltInfo);


//
// Name:      SBC_DDCacheMemScreenBlt
//
// Purpose:   Try to cache a memory to screen blt operation
//
// Returns:   TRUE if the memory to screen blt was handled as an order
//            (i.e. the src bitmap could be cached)
//
//            FALSE if the memory to screen blt could not be handled as an
//            order.  In this case the caller should add the destination
//            rectangle of the blt into the Screen Data Area.
//
// Params:    IN  pOrder      - Pointer to either a MEMBLT order or a
//                              MEM3BLT order.  This order must be
//                              initialized before calling this function.
//            IN  pMemBltInfo - Extra info about the MEMBLT to be cached.
//
// Operation: Before calling this function, the caller should call
//            SBC_DDMaybeQueueColorTable() to queue a color table for the
//            MemBlt (if required).
//
BOOL SBC_DDCacheMemScreenBlt(LPINT_ORDER pOrder, LPMEMBLT_ORDER_EXTRA_INFO pMemBltInfo);

//
// THIS CAN GO WHEN 2.x COMPAT DOES -- the SEND TILE SIZES WON'T BE
// NEGOTIATED.
//
BOOL SBC_DDQueryBitmapTileSize(UINT bmpWidth, UINT bmpHeight,
            UINT * pTileWidth, UINT * pTileHeight);


//
// Name:      SBC_DDSyncUpdatesNow
//
// Purpose:   Discard any pending orders.
//
// Returns:   Nothing
//
// Params:    IN  ppDev - Pointer to our device PDEV
//
// Operation: This function will mark all entries in the shunt buffers as
//            being free.  It is vital that this operation is synched with
//            the share core operation of removing all orders from the
//            order buffer to ensure that there are no MemBlt orders left
//            which refer to freed shunt buffer entries.
//
#ifdef IS_16
void SBC_DDSyncUpdatesNow(void);
#else
void SBC_DDSyncUpdatesNow(LPOSI_PDEV ppDev);
#endif // IS_16


//
// Name:      SBC_DDOrderSpoiltNotification
//
// Purpose:   Called to notify SBC that a Mem(3)Blt order has been spoilt
//            before being passed to the share core.  This function marks
//            the corresponding shunt buffer entry as being free.
//
// Returns:   Nothing
//
// Params:    IN  pOrder - Pointer to the Mem(3)Blt order being spoilt.
//
void SBC_DDOrderSpoiltNotification(LPINT_ORDER pOrder);


//
// Name:      SBC_DDMaybeQueueColorTable
//
// Purpose:   If our device palette has changed since the last time we
//            queued a color table order to the share core, queue a new
//            color table order with details of the new palette.
//
// Returns:   TRUE if the color table was queued, or no color table was
//            required.
//
//            FALSE if a color table is required, but could not be queued.
//
// Params:    IN ppDev - a pointer to our device PDEV
//
// Operation: This function should be called before SBC_DDCacheMemScreenBlt
//            to queue the color table used for the Mem(3)Blt.  If this
//            function fails (returns FALSE), the caller should not call
//            SBC_DDCacheMemScreenBlt, but add the area covered by the
//            Mem(3)Blt to the screen data area instead.
//
//            This function is required to work round a limitation in the
//            order heap which means that we cannot have more than one
//            OA_AllocOrderMem outstanding waiting for an OA_AddOrder.
//
//            i.e. We cannot queue the color table order from
//            SBC_DDCacheMemScreenBlt because this gives the following
//            sequence of calls.
//
//              OA_AllocOrderMem for Mem(3)Blt
//              OA_AllocOrderMem for color table
//              OA_AddOrder for color table
//              OA_AddOrder for Mem(3)Blt
//
#ifdef IS_16
BOOL SBC_DDMaybeQueueColorTable(void);
#else
BOOL SBC_DDMaybeQueueColorTable(LPOSI_PDEV ppDev);
#endif


#endif // DLL_DISP



#endif // _H_SBC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\osi.h ===
//
// OS Isolation (BOGUS!)
//

#ifndef _H_OSI
#define _H_OSI


//
// Control for shared code
//


//
// Maximum number of entries in a palette.
//
#define OSI_MAX_PALETTE             256


// Structure: OSI_ESCAPE_HEADER
//
// Description: Structure common to all display driver requests.  These
// fields are checked before the Display Driver will attempt to process the
// request.
//
typedef struct tagOSI_ESCAPE_HEADER
{
    DWORD       padding;        // For faulty drivers
    DWORD       identifier;     // Unique identifier for all our requests.
    DWORD       escapeFn;       // Function to be processed.  In the case
                                // of ESC_QUERYSUPPORT, this is the ID
                                // of the function to be queried.
    DWORD       version;        // Version #
}
OSI_ESCAPE_HEADER;
typedef OSI_ESCAPE_HEADER FAR * LPOSI_ESCAPE_HEADER;


//
// Unique identifier for all our requests
//
#define OSI_ESCAPE_IDENTIFIER   0xDC123BED


//
// Unique escape code for all our DC-Share specific requests.
//
#define OSI_ESC_CODE            31170


//
// Internal Windows NT Escape Function WNDOBJ_SETUP.  This is the Escape
// code that must be called in order for the Display Driver to be allowed
// to call EngCreateWindow.  Unfortunately, it is defined in winddi.h,
// which can't be included in User-mode compilations.
//
// I define it here: if it changes in winddi.h, this line will fail to
// compile in a Display Driver compilation.
//
#define WNDOBJ_SETUP    4354        // for live video ExtEscape


//
// Allowed ranges of escape functions
//
#define OSI_ESC_FIRST           0
#define OSI_ESC_LAST            0xFF

#define OSI_OE_ESC_FIRST        0x100
#define OSI_OE_ESC_LAST         0x1FF

#define OSI_HET_ESC_FIRST       0x200
#define OSI_HET_ESC_LAST        0x2FF

#define OSI_SBC_ESC_FIRST       0x400
#define OSI_SBC_ESC_LAST        0x4FF

#define OSI_HET_WO_ESC_FIRST    0x500
#define OSI_HET_WO_ESC_LAST     0x5FF

#define OSI_SSI_ESC_FIRST       0x600
#define OSI_SSI_ESC_LAST        0x6FF

#define OSI_CM_ESC_FIRST        0x700
#define OSI_CM_ESC_LAST         0x7FF

#define OSI_OA_ESC_FIRST        0x800
#define OSI_OA_ESC_LAST         0x8FF

#define OSI_BA_ESC_FIRST        0x900
#define OSI_BA_ESC_LAST         0x9FF


//
// Specific values for OSI escape codes
//
#define OSI_ESC(code)                   (OSI_ESC_FIRST + code)

#define OSI_ESC_INIT                    OSI_ESC(0)
#define OSI_ESC_TERM                    OSI_ESC(1)
#define OSI_ESC_SYNC_NOW                OSI_ESC(2)



//
// Used to determine if our driver is around, hosting is possible, and to
// returned mapped shared memory if so after initializing.
//

#define SHM_SIZE_USED   (sizeof(SHM_SHARED_MEMORY) + 2*sizeof(OA_SHARED_DATA))

#define SHM_MEDIUM_TILE_INDEX       0
#define SHM_LARGE_TILE_INDEX        1
#define SHM_NUM_TILE_SIZES          2

typedef struct tagOSI_INIT_REQUEST
{
    OSI_ESCAPE_HEADER   header;
    DWORD               result;
    LPVOID              pSharedMemory;
    LPVOID              poaData[2];

    DWORD               sbcEnabled;
    LPVOID              psbcTileData[SHM_NUM_TILE_SIZES];
    DWORD               aBitmasks[3];
} OSI_INIT_REQUEST;
typedef OSI_INIT_REQUEST FAR* LPOSI_INIT_REQUEST;


//
// Used when shutting down to cleanup any allocated objects and memory
//
typedef struct tagOSI_TERM_REQUEST
{
    OSI_ESCAPE_HEADER   header;
} OSI_TERM_REQUEST;
typedef OSI_TERM_REQUEST FAR* LPOSI_TERM_REQUEST;



#ifdef DLL_DISP


#ifndef IS_16
//
// We have a circular structure dependency, so prototype the necessary data
// here.
//
typedef struct tagOSI_DSURF OSI_DSURF;



//
// Tag used to identify all memory allocated by the display driver.
//
#define OSI_ALLOC_TAG     'DDCD'


// Structure: OSI_PDEV
//
// Description:
//
// Contents of our private data pointer; GDI always passes this to us on
// each call to the display driver. This structure is initialized in
// DrvEnablePDEV handling.
//
typedef struct  tagOSI_PDEV
{
    //
    // Rendering extensions colour information.
    //
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen
    OSI_DSURF*  pdsurfScreen;           // Our private DSURF for the screen

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cBitsPerPel;            // Bits per pel (8,15,16,24,32,etc)
        // This is only 8 or 24 on NT 5.0!

    //
    // Color/pixel format
    //
    ULONG       iBitmapFormat;          // Current colour depth as defined
    FLONG       flRed;                  // Red mask for bitmask modes
    FLONG       flGreen;                // Green mask for bitmask modes
    FLONG       flBlue;                 // Blue mask for bitmask modes                                        // by the BMF_xBPP flags.

    //
    // Palette stuff
    //
    HPALETTE    hpalCreated;            // For NT 5.0 we have to return a palette
    PALETTEENTRY* pPal;                 // The palette if palette managed
    BOOL        paletteChanged;         // Set whenever the palette is
                                        //   changed.
}
OSI_PDEV;
typedef OSI_PDEV FAR * LPOSI_PDEV;


// Structure: OSI_DSURF
//
// Description:
//
// Surface specific information.  We need this structure to pass on to
// EngCreateSurface() during initializtion.  We ignore it subsequently.
//
typedef struct tagOSI_DSURF
{
    SIZEL     sizl;         // Size of the original bitmap
    LPOSI_PDEV ppdev;        // Pointer to the assocaited PDEV

}
OSI_DSURF;
typedef OSI_DSURF FAR * LPOSI_DSURF;



void OSI_DDInit(LPOSI_PDEV, LPOSI_INIT_REQUEST);
void OSI_DDTerm(LPOSI_PDEV);
#else
void OSI_DDTerm(void);
#endif // !IS_16

#else

//
// Used for other desktops thread.
//
enum
{
    OSI_WM_SETGUIEFFECTS = WM_USER,
    OSI_WM_DESKTOPREPAINT,
    OSI_WM_DESKTOPSWITCH,
    OSI_WM_MOUSEINJECT,
    OSI_WM_KEYBDINJECT,
    OSI_WM_INJECTSAS
};

#endif // DLL_DISP


//
// OSI_Load()
// Called when nmas.dll is first loaded.
//
void    OSI_Load(void);


//
// OSI_Unload()
// Called when nmas.dll is unloaded.
//
void    OSI_Unload(void);




//
// OSI_Init()
// Called when app sharing initializes in its service thread.  We determine
// if we can host, and get hold of buffers, data structures, etc. needed
// for hosting if so.
//
// Returns FALSE on severe failure.  The display driver on NT not being
// present isn't failure.  The graphic patches on Win95 not being safe isn't
// failure either.  In those two cases, AS will simply mark itself as
// unable to host, but can view fine.
//
void    OSI_Init(void);

//
// OSI_Term()
// Called when app sharing deinitializes in its service thread.
//
void    OSI_Term(void);


//
// OSI_FunctionRequest()
// Used to communicate with the display driver piece, the part which tracks
// graphical output in shared apps on the screen.
//
BOOL    OSI_FunctionRequest(DWORD functionId, LPOSI_ESCAPE_HEADER pRequest, DWORD requestLen);


// NT only!
void OSI_InitDriver50(BOOL fInit);

// NT only!
void OSI_RepaintDesktop(void);

// NT only!
void OSI_SetGUIEffects(BOOL fOff);

// NT only!
void WINAPI OSI_SetDriverName(LPCSTR szDriverName);


#ifdef DLL_DISP


#ifdef IS_16
BOOL    OSI_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);
#else
ULONG   OSI_DDProcessRequest(SURFOBJ* pso, UINT cjIn, void* pvIn, UINT cjOut, void* pvOut);

BOOL    OSIInitializeMode(const GDIINFO* pGdiRequested, const DEVMODEW* pdmRequested,
    LPOSI_PDEV ppdev, GDIINFO* pgdiReturn, DEVINFO* pdiReturn);    

#endif // !IS_16



#endif // DLL_DISP

#endif // _H_OSI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\resource.h ===
//
// Resource header
//


//
// Menus
//
#define IDM_FRAME                       100
    #define IDSM_CONTROL                  0
    #define IDSM_VIEW                     1
    #define IDSM_WINDOW                   2
    #define IDSM_HELP                     3
    
  

//
// Commands
//

// CONTROL
#define POS_CONTROLCMD                    0
#define POS_FORWARDCONTROLCMD             1

#define CMD_TOPMOST                     100
#define CMD_TAKECONTROL                 101
#define CMD_RELEASECONTROL              102
#define CMD_CANCELCONTROL               103
#define CMD_CTRLALTDEL                  104
#define CMD_VIEWSTATUSBAR               105
#define CMD_VIEWWINDOWBAR               106
#define CMD_VIEWFULLSCREEN              107
#define CMD_HELPTOPICS                  108
#define CMD_HELPABOUT                   109



// WINDOW
#define CMD_APPSTART                   1000
#define CMD_APPMAX                     5000

#define CMD_FORWARDCONTROLSTART        5000
#define CMD_FORWARDCONTROLMAX         10000



//
// STRINGS
// CVRTRES can't handle enum types, what a pain.
//

#define IDS_ABOUT                         1     // NO REAL STRING
#define IDS_RESTORE                       2

#define IDS_FONT_CURSORTAG              100

#define IDS_TITLE_SHAREDPROGRAMS        101
#define IDS_TITLE_SHAREDDESKTOP         102
#define IDS_TITLE_CONTROLLABLE          103
#define IDS_TITLE_INCONTROL             104

#define IDS_CMD_CTRLALTDEL              110
#define IDS_CMD_TAKECONTROL             111
#define IDS_CMD_CANCELCONTROL           112
#define IDS_CMD_RELEASECONTROL          113
#define IDS_CMD_BLANKPROGRAM            114

#define IDS_HIDDEN_WINDOW               115
#define IDS_NOTHING                     116
#define IDS_DESKTOP                     117
#define IDS_DESKTOP_LOWER               118
#define IDS_PROGRAMS                    119
#define IDS_PROGRAMS_LOWER              120
#define IDS_NOTINCALL                   121
#define IDS_SHARING_FORMAT              122
#define IDS_TOPMOST                     123

#define IDS_ALLOWCONTROL                124
#define IDS_PREVENTCONTROL              125
#define IDS_MSG_TOPREVENTCONTROL        126
#define IDS_MSG_TOALLOWCONTROL          127

#define IDS_STATUS_NONE                   0
#define IDS_STATUS_WAITINGFORCONTROL    150
#define IDS_STATUS_CONTROLPAUSED        151

//
// Inform dialog 
// NOTE:  Keep these in same order as CARESULT_ values
//
#define IDS_TITLE_TAKECONTROL_FAILED            200
#define IDS_ERR_TAKECONTROL_MIN                 200
#define IDS_ERR_TAKECONTROL_FIRST               202
#define IDS_ERR_TAKECONTROL_FAILED_BUSY         202
#define IDS_ERR_TAKECONTROL_FAILED_USER         203
#define IDS_ERR_TAKECONTROL_FAILED_WRONGSTATE   204
#define IDS_ERR_TAKECONTROL_FAILED_TIMEDOUT     205
#define IDS_ERR_TAKECONTROL_LAST                IDS_ERR_TAKECONTROL_FAILED_TIMEDOUT


//
// Query dialogs
//
#define IDS_TITLE_QUERY_TAKECONTROL             250
#define IDS_MSG_QUERY_TAKECONTROL               251
#define IDS_TITLE_QUERY_GIVECONTROL             252
#define IDS_MSG_QUERY_GIVECONTROL               253
#define IDS_TITLE_QUERY_FORWARDCONTROL          254
#define IDS_MSG_QUERY_FORWARDCONTROL            255
#define IDS_TITLE_QUERY_YIELDCONTROL            256
#define IDS_MSG_QUERY_YIELDCONTROL              257


//
// Add this to CMD id above & get status bar string
// SO KEEP THESE IN THE SAME ORDER AS THE CMD_ IDs ABOVE
//
#define IDS_STATUS_MENU_CONTROL                 400
#define IDS_STATUS_MENU_VIEW                    401
#define IDS_STATUS_MENU_WINDOW                  402
#define IDS_STATUS_MENU_HELP                    403
#define IDS_STATUS_MENU_FORWARDCONTROL          404
#define IDS_STATUS_CMDS_APP                     405
#define IDS_STATUS_CMDS_FORWARD                 406

#define IDS_STATUS_CMD_START                    500
#define IDS_STATUS_CMD_TOPMOST                  600
#define IDS_STATUS_CMD_TAKECONTROL              601
#define IDS_STATUS_CMD_RELEASECONTROL           602
#define IDS_STATUS_CMD_CANCELCONTROL            603
#define IDS_STATUS_CMD_CTRLALTDEL               604
#define IDS_STATUS_CMD_VIEWSTATUSBAR            605
#define IDS_STATUS_CMD_VIEWWINDOWBAR            606
#define IDS_STATUS_CMD_VIEWFULLSCREEN           607
#define IDS_STATUS_CMD_HELPTOPICS               608
#define IDS_STATUS_CMD_HELPABOUT                609


//
// DIALOGS
//

#define IDD_HOSTUI                          100
    #define CTRL_PROGRAM_LIST               50
    #define CTRL_SHARE_BTN                  51
    #define CTRL_UNSHARE_BTN                52
    #define CTRL_UNSHAREALL_BTN             53
    #define CTRL_ENABLETRUECOLOR_CHECK      54
    #define CTRL_CONTROL_MSG                55
    #define CTRL_ALLOWCONTROL_BTN           56
    #define CTRL_PREVENTCONTROL_BTN         57
    #define CTRL_AUTOACCEPTCONTROL_CHECK    58
    #define CTRL_TEMPREJECTCONTROL_CHECK    59

#define IDD_INFORM                      101
    #define CTRL_INFORM                  50
#define IDD_QUERY                       102
    #define CTRL_QUERY                   50
#define IDD_ABOUT                       103
    #define CTRL_ABOUTVERSION            50

//
// BITMAPS
//

#define IDB_HATCH32X32                  100
#define IDB_OBSCURED                    101


//
// ICONS
//
#define IDI_SHAREICON                   101
#define IDI_DESKTOPICON                 102
#define IDI_CANCELFULLSCREEN            103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\om.h ===
//
// Object Manager
//

#ifndef _H_OM
#define _H_OM



#include <gdc.h>
#include <ast120.h>

//
//
// CONSTANTS
//
//



//
// Function Profiles (apps)
//
#define OMFP_FIRST        0

typedef enum
{
    OMFP_AL = OMFP_FIRST,
    OMFP_OM,
    OMFP_WB,                  // For old whiteboard
    OMFP_MAX
}
OMFP;


//
// These are the corresponding strings (part of the protocol)
//
#define AL_FP_NAME                  "APP-LOAD-1.0"
#define OM_FP_NAME                  "OMCONTROL-1.0"
#define WB_FP_NAME                  "WHITEBOARD-1.0"



//
// ObMan clients
//
#define OMCLI_FIRST     0
typedef enum
{
    OMCLI_AL = OMCLI_FIRST,
    OMCLI_WB,
    OMCLI_MAX
}
OMCLI;


//
// ObMan workset groups
//
#define OMWSG_FIRST     0
typedef enum
{
    OMWSG_OM    = OMWSG_FIRST,
    OMWSG_AL,
    OMWSG_WB,
    OMWSG_MAX,
    OMWSG_MAXPERCLIENT
}
OMWSG;



//
// These are the corresponding strings (part of the protocol)
//
#define OMC_WSG_NAME            "OBMANCONTROL"
#define AL_WSG_NAME             "APP-LOADER"
#define WB_WSG_NAME             "WHITEBOARD"


//
// Specify this in place of a valid Domain handle to create/move a workset
// group outside of any calls:
//

#define OM_NO_CALL            NET_INVALID_DOMAIN_ID


//
//
// SYSTEM LIMITS
//
// These are limits imposed by the architecture/design of the system.
//
//

//
// Workset group names
//
// Workset groups names are null-terminated strings, up to 32 characters
// long (including the NULL character).  They are intended to be
// human-readable names, and must contain only ASCII characters between
// 0x2C and 0x5B.  This range includes all uppercase characters, all digits
// and certain punctuation marks.
//

#define OM_MAX_WSGROUP_NAME_LEN          32

//
// Function Profile names
//
// Function profile names must be no longer than 16 characters (including
// the NULL character).  The range of characters allowable is the same as
// for workset group names.
//

#define OM_MAX_FP_NAME_LEN               16


//
// Maximum number of changes allowed to a workset
//
// Each time a workset is changed, we increment its "generation number",
// which is used in resequencing operations.  The largest size for an
// integer is 32 bits, so the maximum generation number using a convenient
// type is 2^32-1.
//
//

#define OM_MAX_GENERATION_NUMBER         0xffffffff

//
// Maximum size of an object
//
// This derives from the maximum size of a huge memory block under Windows
// (16MB less 64KB):
//

#define OM_MAX_OBJECT_SIZE               ((UINT) (0x1000000 - 0x10000))

//
// Maximum update size of an object
//
// This derives from the necessity to send updates atomically in one
// network packet (see SFR 990)
//

#define OM_MAX_UPDATE_SIZE               ((UINT) (0x00001f00))

//
// Maximum number of worksets per workset group
//
// This derives from the desire to make workset IDs 8-bit quantities so
// that they can fit in DC-Groupware events with a workset group handle and
// an object ID:
//
// Note: this value must be at most 255 so that certain ObMan for-loops
//       don't cycle for ever.
//

#define OM_MAX_WORKSETS_PER_WSGROUP         255

//
// Maximum number of workset groups per Domain
//
// This derives from the use of the ObManControl workset group: it has one
// control workset and then one workset for each workset group in the
// Domain, so there can only be this many workset groups in a Domain:
//
// Note: this number must be at most one less that
//       OM_MAX_WORKSETS_PER_WSGROUP
//

#define OM_MAX_WSGROUPS_PER_DOMAIN          64


//
// Special WSGROUPID for OMC:
//
#define WSGROUPID_OMC           0

//
//
// RETURN CODES
//
// Return codes are defined relative to the OM_BASE_RC base
//
//

enum
{
    OM_RC_NO_MORE_HANDLES = OM_BASE_RC,
    OM_RC_WORKSET_DOESNT_EXIST,
    OM_RC_WORKSET_EXHAUSTED,
    OM_RC_OBJECT_DELETED,
    OM_RC_BAD_OBJECT_ID,
    OM_RC_NO_SUCH_OBJECT,
    OM_RC_WORKSET_LOCKED,
    OM_RC_TOO_MANY_CLIENTS,
    OM_RC_TOO_MANY_WSGROUPS,
    OM_RC_ALREADY_REGISTERED ,
    OM_RC_CANNOT_MOVE_WSGROUP,
    OM_RC_LOCAL_WSGROUP,
    OM_RC_ALREADY_IN_CALL,
	OM_RC_NOT_ATTACHED,
    OM_RC_WORKSET_ALREADY_OPEN,
    OM_RC_OUT_OF_RESOURCES,
    OM_RC_NETWORK_ERROR,
    OM_RC_TIMED_OUT,
    OM_RC_NO_PRIMARY,
    OM_RC_WSGROUP_NOT_FOUND,
    OM_RC_WORKSET_NOT_FOUND,
    OM_RC_OBJECT_NOT_FOUND,
    OM_RC_WORKSET_LOCK_GRANTED,
    OM_RC_SPOILED,
    OM_RC_RECEIVE_CB_NOT_FOUND,
    OM_RC_OBJECT_PENDING_DELETE,
    OM_RC_NO_NODES_READY,
    OM_RC_BOUNCED
};


//
// Setting defaults
//
#define OM_LOCK_RETRY_COUNT_DFLT            10

#define OM_LOCK_RETRY_DELAY_DFLT            1000

#define OM_REGISTER_RETRY_COUNT_DFLT        40

#define OM_REGISTER_RETRY_DELAY_DFLT        5000

//
// This is the number of bytes we zero at the start of each object
// allocated.  It must be less than DCMEM_MAX_SIZE, since ObjectAlloc
// assumes that this many bytes at the start of an object are all in the
// same segment.
//

#define OM_ZERO_OBJECT_SIZE               0x400


//
// EVENTS
// Public then Internal
//

enum
{
    OM_OUT_OF_RESOURCES_IND = OM_BASE_EVENT,
    OM_WSGROUP_REGISTER_CON,
    OM_WSGROUP_MOVE_CON,
    OM_WSGROUP_MOVE_IND,
    OM_WORKSET_OPEN_CON,
    OM_WORKSET_NEW_IND,
    OM_WORKSET_LOCK_CON,
    OM_WORKSET_UNLOCK_IND,
    OM_WORKSET_CLEAR_IND,
    OM_WORKSET_CLEARED_IND,
    OM_OBJECT_ADD_IND,
    OM_OBJECT_MOVE_IND,
    OM_OBJECT_DELETE_IND,
    OM_OBJECT_REPLACE_IND,
    OM_OBJECT_UPDATE_IND,
    OM_OBJECT_LOCK_CON,
    OM_OBJECT_UNLOCK_IND,
    OM_OBJECT_DELETED_IND,
    OM_OBJECT_REPLACED_IND,
    OM_OBJECT_UPDATED_IND,
    OM_PERSON_JOINED_IND,
    OM_PERSON_LEFT_IND,
    OM_PERSON_DATA_CHANGED_IND,

    OMINT_EVENT_LOCK_TIMEOUT,
	OMINT_EVENT_SEND_QUEUE,
	OMINT_EVENT_PROCESS_MESSAGE,
	OMINT_EVENT_WSGROUP_REGISTER,
    OMINT_EVENT_WSGROUP_MOVE,
	OMINT_EVENT_WSGROUP_REGISTER_CONT,
	OMINT_EVENT_WSGROUP_DEREGISTER,
	OMINT_EVENT_WSGROUP_DISCARD
};




//
// Data transmission constants:
//

#define OM_NET_MAX_TRANSFER_SIZE             60000

//
// These constants identify the types of network buffer pools we use:
//

#define OM_NET_OWN_RECEIVE_POOL              1
#define OM_NET_OMC_RECEIVE_POOL              2
#define OM_NET_WSG_RECEIVE_POOL              3
#define OM_NET_SEND_POOL                     4

//
// These constants are the sizes of the receive pools for each priority and
// for each type of channel we join:
//

#define OM_NET_RECEIVE_POOL_SIZE             0x00002000

#define OM_NET_OWN_RECEIVE_POOL_TOP          OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OWN_RECEIVE_POOL_HIGH         OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OWN_RECEIVE_POOL_MEDIUM       OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OWN_RECEIVE_POOL_LOW          OM_NET_RECEIVE_POOL_SIZE

#define OM_NET_OMC_RECEIVE_POOL_TOP          OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OMC_RECEIVE_POOL_HIGH         OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OMC_RECEIVE_POOL_MEDIUM       OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OMC_RECEIVE_POOL_LOW          OM_NET_RECEIVE_POOL_SIZE

#define OM_NET_WSG_RECEIVE_POOL_TOP          OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_WSG_RECEIVE_POOL_HIGH         OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_WSG_RECEIVE_POOL_MEDIUM       OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_WSG_RECEIVE_POOL_LOW          OM_NET_RECEIVE_POOL_SIZE

#define OM_NET_SEND_POOL_SIZE                0x00004000

#define OM_NET_SEND_POOL_TOP                 OM_NET_SEND_POOL_SIZE
#define OM_NET_SEND_POOL_HIGH                OM_NET_SEND_POOL_SIZE
#define OM_NET_SEND_POOL_MEDIUM              OM_NET_SEND_POOL_SIZE
#define OM_NET_SEND_POOL_LOW                 OM_NET_SEND_POOL_SIZE

//
// These constants are used to decide what priority to send data transfers
// at when a Client has specified OBMAN_CHOOSES_PRIORITY for the workset:
//
#define OM_NET_HIGH_PRI_THRESHOLD            0x0100
#define OM_NET_MED_PRI_THRESHOLD             0x1000

#define OM_CHECKPOINT_WORKSET                OM_MAX_WORKSETS_PER_WSGROUP



//
//
// DATA STRUCTURES
//
// This section defines the main data structures of the ObMan API.
//
//


typedef struct tagOM_CLIENT *        POM_CLIENT;
typedef struct tagOM_PRIMARY *          POM_PRIMARY;


// Client objects are record pointers
typedef struct tagOM_OBJECT *           POM_OBJECT;
typedef struct tagOM_WSGROUP *          POM_WSGROUP;
typedef struct tagOM_DOMAIN *           POM_DOMAIN;


//
// ObMan correlators
//
typedef WORD    OM_CORRELATOR;


//
// Workset ID
//
// Within a workset group, worksets are identified by an 8-bit ID.
//

typedef BYTE                              OM_WSGROUP_HANDLE;

typedef BYTE                              OM_WORKSET_ID;
typedef OM_WORKSET_ID *                  POM_WORKSET_ID;

//
// Object structure
//
// Objects and object pointers are defined as follows:
//

typedef struct tagOM_OBJECTDATA
{
   TSHR_UINT32      length;      // length of the data field
   BYTE             data[1];     // object data, uninterpreted by ObMan;
                                  // in reality, not 1 byte but <length>
                                  // bytes long
}
OM_OBJECTDATA;
typedef OM_OBJECTDATA *             POM_OBJECTDATA;
typedef POM_OBJECTDATA *            PPOM_OBJECTDATA;

//
// Note that the maximum permitted size of an object, INCLUDING the
// <length> field, is 16MB less 64KB.
//

void __inline ValidateObjectData(POM_OBJECTDATA pData)
{
    ASSERT(!IsBadWritePtr(pData, sizeof(OM_OBJECTDATA)));
    ASSERT((pData->length > 0) && (pData->length < OM_MAX_OBJECT_SIZE));
}


//
// Object IDs
//
// Internally, object IDs are a combination of a network ID and a four-byte
// sequence counter:
//

typedef struct tagOM_OBJECT_ID
{
    TSHR_UINT32     sequence;
    NET_UID         creator;       // MCS user ID of node which created it
    WORD            pad1;
} OM_OBJECT_ID;
typedef OM_OBJECT_ID *             POM_OBJECT_ID;



//
// Partitioning of the first parameter on an event for INDICATION events
//

typedef struct tagOM_EVENT_DATA16
{
    OM_WSGROUP_HANDLE   hWSGroup;
    OM_WORKSET_ID       worksetID;
}
OM_EVENT_DATA16;
typedef OM_EVENT_DATA16 *  POM_EVENT_DATA16;

//
// Partitioning of the second parameter on an event for CONFIRM events
//

typedef struct tagOM_EVENT_DATA32
{
    WORD                result;
    OM_CORRELATOR       correlator;
}
OM_EVENT_DATA32;
typedef OM_EVENT_DATA32 *  POM_EVENT_DATA32;



//
//
// OBMANCONTROL
//
// This section describes the ObManControl Function Profile, as used by the
// Object Manager.
//
//


//
//
// DESCRIPTION
//
// In addition to the purely local records of workset groups, all instances
// of ObMan attached to a given Domain jointly maintain a control workset
// group containing
//
// - one workset (workset #0) listing the name, Function Profile, ID
//   and MCS channel of each of the "standard" workset groups in
//   the Domain, as well as the MCS user IDs of all the instances of ObMan
//   in the Domain
//
// - one "registration workset" per workset group (worksets #1-#255)
//   listing the MCS user IDs of the instances of ObMan which have one or
//   more local Clients registered with the workset group.
//
// Creating a new workset group in a Domain causes ObMan to
//
// - add a new identification object to workset #0 and
//
// - create a new registration workset
//
// Registering with a workset group causes ObMan to
//
// - add a registration object to the appropriate registration workset.
//

//
//
// USAGE
//
// ObMan Clients can register with the ObManControl workset group, and then
// open and examine the contents of workset #0 to discover the names and
// Function Profiles of all the workset groups existing in a Domain.
//
// ObMan Clients must not attempt to lock or change the contents of this
// workset group in any way.
//
//

//
//
// OBJECT DEFINITIONS
//
// This section provides the definitions for the objects contained in the
// worksets of the ObManControl workset group.
//
//


typedef BYTE                        OM_WSGROUP_ID;
typedef OM_WSGROUP_ID *            POM_WSGROUP_ID;


//
//
// WORKSET GROUP IDENTIFICATION OBJECT
//
// This structure identifies a workset within a Domain.  Objects of this
// form reside in workset #0 of ObManControl, known as the INFO workset.
//
//

#define OM_INFO_WORKSET             ((OM_WORKSET_ID) 0)

//
// NET PROTOCOL
//
typedef struct
{
   TSHR_UINT32          length;           // size of this structure, less four
                                       // bytes (for length field itself)

   DC_ID_STAMP       idStamp;          // == OM_WSGINFO_ID_STAMP

   NET_CHANNEL_ID    channelID;        // workset group's MCS channel

   NET_UID           creator;          // NET user ID of instance of ObMan
                                       // which created workset group

   OM_WSGROUP_ID     wsGroupID;        // Domain-unique ID
    BYTE pad1;
    WORD pad2;

   char            functionProfile[ OM_MAX_FP_NAME_LEN ];

                                       // function profile

   char            wsGroupName[ OM_MAX_WSGROUP_NAME_LEN ];

                                       // Client-supplied name
}
OM_WSGROUP_INFO;
typedef OM_WSGROUP_INFO *         POM_WSGROUP_INFO;

#define OM_WSGINFO_ID_STAMP            DC_MAKE_ID_STAMP('O', 'M', 'W', 'I')

void __inline ValidateObjectDataWSGINFO(POM_WSGROUP_INFO pInfoObj)
{
    ValidateObjectData((POM_OBJECTDATA)pInfoObj);
    ASSERT(pInfoObj->idStamp == OM_WSGINFO_ID_STAMP);
}


//
//
// WORKSET GROUP REGISTRATION OBJECTS
//
// This structure identifies a node's usage of a workset group.  These
// objects can reside in any ObManControl workset.
//
// In the case of workset #0, these objects identify a node's usage of the
// ObManControl workset group itself.  Since all instances of ObMan in a
// Domain are use the ObManControl workset group, the registration objects
// in workset #0 form a complete list of all the instances of ObMan in a
// Domain.
//
//

//
// NET PROTOCOL
//
typedef struct
{
   TSHR_UINT32          length;           // size of this structure, less four
                                       // bytes (for length field itself)

   DC_ID_STAMP       idStamp;          // == OM_WSGREGREC_ID_STAMP

   NET_UID           userID;           // user ID of ObMan to which the
                                       // object relates
   TSHR_UINT16          status;           // see below for status values

   TSHR_PERSON_DATA   personData;
}
OM_WSGROUP_REG_REC;
typedef OM_WSGROUP_REG_REC *      POM_WSGROUP_REG_REC;

#define OM_WSGREGREC_ID_STAMP          DC_MAKE_ID_STAMP('O', 'M', 'R', 'R')


void __inline ValidateObjectDataWSGREGREC(POM_WSGROUP_REG_REC pRegObject)
{
    ValidateObjectData((POM_OBJECTDATA)pRegObject);
    ASSERT(pRegObject->idStamp == OM_WSGREGREC_ID_STAMP);
}


//
// Value for <status> field:
//

#define CATCHING_UP     1
#define READY_TO_SEND   2



//
//
// LATE JOINER PROTOCOL
//
// If a Client registers with a workset group which already exists
// elsewhere in the Domain, that Client is considered a late joiner for
// that workset group.  The protocol for bringing late joiners up to date
// is as follows (except where explicitly stated, "ObMan" means "the local
// instance of ObMan"):
//
// OVERVIEW
//
// A late-joiner node asks another "helper" node for a copy of the workset
// group.  The helper node broadcasts a low-priority sweep message to all
// other nodes in the call and when it has received their replies, sends
// what it believes to be the current copy of the workset to the
// late-joiner.
//
// DETAILS
//
// At the local node, ObMan
//
// 1.  locks the ObManControl workset group (one effect of this is that no
//     other ObMan in the Domain will discard any workset groups it has
//     local copies of)
//
// 2.  examines the ObManControl workset group to determine
//
//     - the MCS channel ID for the workset group
//
//     - the MCS user ID of an instance of ObMan which has a copy of the
//       workset group
//
// 3.  requests to join the workset group channel
//
// 4.  waits for the join to succeed
//
// 5.  sends an OMNET_WSGROUP_SEND_REQ at high priority on the user ID
//     channel of that instance of ObMan, known as the "helper"
//
// 6.  broadcasts an OMNET_WORKSET_UNLOCK message at low priority to unlock
//     the ObManControl workset group (on the ObManControl channel)
//
// At the helper node, ObMan
//
// 7.  receives the OMNET_WSGROUP_SEND_REQ
//
// 8.  marks its copy of the workset group as non-discardable
//
// 9.  examines the ObManControl workset to determine the MCS user IDs
//     of the remote instances of ObMan which already have copies
//     of the workset group
//
// 10.  broadcasts an OMNET_WSGROUP_SWEEP_REQ message on the workset group
//      channel at high priority
//
// At each of the nodes queried in step 10, ObMan
//
// 11.  receives the OMNET_WSGROUP_SWEEP_REQ
//
// 12.  sends an OMNET_WSGROUP_SWEEP_REPLY message to the helper node at
//      low priority
//
// Back at the helper node, ObMan
//
// 13.  records each OMNET_WSGROUP_SWEEP_REPLY until all have been
//      received*
//
// 14.  sends one OMNET_WORKSET_NEW message for each workset in the workset
//      group (on the late-joiners single-member channel)
//
// 15.  sends an OMNET_OBJECT_ADD message for each object in each workset,
//      again on the late-joiner's single member channel
//
// 16.  sends an OMNET_WSGROUP_SEND_COMPLETE to the late-joiner; this
//      message serves as a back marker for the late-joiner so that it
//      knows when it has caught up with the state of the workset group as
//      it was when it joined
//
// ASSUMPTIONS
//
// This protocol relies on the following assumptions:
//
// - The helper node receives the OMNET_WSGROUP_SEND_REQ message before
//   the OMNET_WORKSET_UNLOCK message (as otherwise there is a window
//   where its copy of the workset group may be discarded).
//
//   This assumption is based on the fact that low-priority MCS data does
//   not overtake high priority MCS data sent from the same node EVEN ON
//   DIFFERENT CHANNELS.
//
//   If this assumption proves invalid then either
//
//   - the OMNET_WSGROUP_SEND_REQ message must be acknowledged before the
//     late joiner can unlock the ObManControl workset, or
//
//   - the OMNET_WSGROUP_SEND_REQ must be sent on the ObManControl
//     broadcast channel, with an extra field indicating the node for which
//     it is intended.
//
// - Any data received at the helper node after stage 14 begins is
//   forwarded by MCS to the late-joiner.
//
//   This assumption is based on the fact that the late-joiner is marked
//   at the helper's MCS system as joined to the relevant channel before
//   stage 14 begins.  MCS guarantees that once a NET_CHANNEL_JOIN_IND has
//   been received locally, the MCS system at every other node in the
//   Domain is aware that the late-joiner has joined the channel.
//
// Note that in R1.1, the helper node will discover, at step 9, that there
// are no other nodes in the Domain.  Therefore, steps 10-13 are eliminated
// i.e.  the helper sends its copy of the workset as soon as it receives
// the request from the late-joiner.
//
// This is a major simplification and the code to implement these steps is
// not to be included in R1.1.
//
// * The glib "until all have been received" condition is actually
//   difficult to implement since nodes may disappear while the helper is
//   waiting.  The solution to this is deferred to R2.0 (but see section on
//   locking for suggested implementation).
//
//

//
//
// WORKSET LOCKING PROTOCOL
//
// In what follows, the "state" refers to the lock state of the workset, as
// stored in the workset record.
//
// At the locking node, ObMan does the following:
//
// 1.  if the state is LOCK_GRANTED, post FAILURE then quit
//
// 2.  examine the workset in ObManControl which corresponds to the
//     workset group containing the workset to be locked, to determine the
//     IDs of the other nodes which are in using the workset group (at most
//     1 node in R1.1); put these IDs in a list of "expected respondents"
//     (Note: do not include own ID in this list)
//
// 3.  if this list is empty, we have succeeded so post SUCCESS and quit
//
// 4.  else broadcast an OMNET_WORKSET_LOCK_REQ message on the workset
//     group channel (i.e.  to each of these nodes)
//
// 5.  set the workset state to LOCKING and post a delayed
//     OMINT_EVENT_LOCK_TIMEOUT event
//
// At the other node(s), ObMan does the following:
//
// 6.  receive the OMNET_WORKSET_LOCK_REQ message from the locking node
//
// 7.  examine its current workset state
//
// 8.  if it is LOCK_REQUESTED and the MCS user ID of the locking node is
//     less than that of the current node, goto DENY
//
// 9.  else, goto GRANT
//
// DENY:
//
// 10.  send an OMNET_WORKSET_LOCK_DENY message to the locking node
//
// GRANT:
//
// 11.  if the state if LOCKING, then we are giving the lock to a higher
//      "priority" ObMan even though we wanted it ourselves, so post
// FAILURE
//      locally (continue to 12)
//
// 12.  set the state to LOCK_GRANTED
//
// 13.  send an OMNET_WORKSET_LOCK_GRANT message to the locking node
//
// Back at the locking node, one of the following happens:
//
//  ObMan receives an OMNET_WORKSET_LOCK_GRANT message
//
//        it then deletes the ID of the node which sent it from the list of
//        expected respondents
//
//        if this list is now empty, all nodes have replied so post SUCCESS
//        to Client
//
// OR
//
//  ObMan receives an OMNET_WORKSET_LOCK_DENY message
//
//        if the state is LOCKING, set it to READY, post FAILURE and quit
//
//        if the state is anything else, this reply has come too late
//        (we've timed out) so ignore it
//
// OR
//
//  ObMan receives the OMINT_EVENT_LOCK_TIMEOUT event
//
//        if the state is not LOCKING, the lock has succeeded so ignore the
//        timeout
//
//        otherwise, ObMan checks the ObManControl workset as in step 2 to
//        see if any nodes still on the expected respondents list have in
//        fact disappeared; if so post SUCCESS
//
//        else post FAILURE.
//
//
//
// The state machine for the locking process is as follows (R1.1 version):
//
//                         |---------+-----------+---------+--------------|
//                         |UNLOCKED | LOCKING   | LOCKED  | LOCK_GRANTED |
//                         |   1     |    2      |   3     |      4       |
//                         |---------+-----------+---------+--------------|
// WorksetLock()           |broadcast|   FAIL    |  FAIL   |     FAIL     |
//                         |LOCK_REQ,|           |         |              |
//                         | ->2     |           |         |              |
//                         |---------+-----------+---------+--------------|
// WorksetUnlock()         |   X     |broadcast UNLOCK, ->1|      X       |
//                         |---------+-----------+---------+--------------|
// OMNET_WORKSET_LOCK_REQ  |reply    |compare    |reply    |      -       |
//                         |GRANT,   |MCS IDs:   |DENY     |              |
//                         | ->4     |if we're   |         | (in R1.1,    |
//                         |         |greater,   |         | this should  |
//                         |         |reply DENY |         | be an error) |
//                         |         |else reply |         |              |
//                         |         |GRANT, ->4 |         |              |
//                         |---------+-----------+---------+--------------|
// OMNET_WORKSET_LOCK_GRANT|   -     |SUCCESS,   |   -     |     -        |
//                         |         | ->3       |         |              |
//                         |---------+-----------+---------+--------------|
// OMNET_WORKSET_LOCK_DENY |   -     |FAIL, ->1  |   X     |     -        |
//                         |         |           |         |              |
//                         |---------+-----------+---------+--------------|
// OMINT_EVENT_LOCK_TIMEOUT      |   -     |if other   |   -     |     -        |
//                         |         |box gone,  |         |              |
//                         |         |SUCCESS,   |         |              |
//                         |         |->3, else  |         |              |
//                         |         |FAIL, ->1  |         |              |
//                         |---------+-----------+---------+--------------|
// OMNET_WORKSET_UNLOCK    |   -     |    -      |   X     |     ->1      |
//                         |---------+-----------+---------+--------------|
//
//
// where 'X' indicates an error condition and '-' indicates that the event
// or message is ignored.
//
//

//
//
// NOTES FOR R2.0 WORKSET LOCKING
//
// 1.  If A tries to lock a workset and B grants the lock but C denies it,
//     B will think that A has the lock.  A has to broadcast an unlock,
//     or else B has to realise that the conflict will be resolved in
//     favour of C over A.
//
//


//
//
// DATA PROPAGATION and FLOW NOTIFICATION PROTOCOL
//
// When a local Client adds an object to a workset, or replaces or updates
// an existing object in a workset, ObMan broadcasts an appropriate
// OMNET_...  message on the workset group channel.
//
// This header message identifies the object and the type of operation to
// be performed.  It also includes a correlator value and the total size of
// the data to be sent in the following data packets.
//
// After sending the header, ObMan broadcasts one or more
// OMNET_GENERIC_DATA packets on the same channel.  These packets, which
// are of arbitrary size, all contain the same correlator value as was
// included in the header packet.
//
// No sequence numbers are included as MCS guarantees that data packets
// sent at the same priority on the same channel from the same node will
// arrive at all other nodes in the sequence in which they were sent.
//
// It is the responsibility of the receiving node to detect when all data
// packets have arrived and then to insert, update or replace the object in
// the local copy of the workset.
//
// In addition, the receiving node, on receipt of EACH data packet sends a
// data acknowledgment message (OMNET_DATA_ACK) to the sending node (on its
// single-user channel), indicating the number of bytes received in that
// data packet.
//
//

//
//
// STANDARD OPERATION BROADCAST PROTOCOL
//
// When a local Client deletes or moves an object in a workset, or clears
// or creates a workset, ObMan broadcasts a single uncorrelated operation
// packet on the workset group channel.
//
// It is the responsibility of the receiving node to implement the
// operation locally.
//
//

//
//
// OPERATION SEQUENCING AND RESEQUENCING
//
// In order to consistently sequence operations which may arrive in
// different sequences at different nodes, each operation carries with it
// enough information for ObMan to reconstruct the workset, at each node,
// as if all the operations on it had arrived in the same sequence.
//
// To do this, all operations are assigned a sequence stamp before being
// broadcast.  When ObMan receives an operation from the network, it
// compares its stamp to various stamps it maintains locally.  Whether and
// how to perform the operation locally is determined on the basis of these
// comparisons, according to the rules defined below.
//
//

//
//
// SEQUENCE STAMPS AND THE WORKSET GENERATION NUMBER
//
// The sequencing order must be a globally consistent method of ordering
// events ("global" here refers to geographical distribution of all nodes
// operating on a given workset; it is not necessary that events be
// sequenced across different worksets, since operations on separate
// worksets can never interfere).
//
// We define an ObMan sequence stamp to be a combination of the workset
// generation number and the node id.
//
// The node ID is the user ID allocated by the MCS subsystem to the ObMan
// task and is therefore unique within a Domain.
//
// The workset generation number
//
// - is set to zero when the workset is created
//
// - is incremented each time ObMan performs an operation on behalf
//   of a local Client
//
// - is, whenever an operation arrives from the network, set to the
//   greater of its existing local value and the value in the
//   operation's sequence stamp.
//
// The ordering of sequence stamps is defined as follows (notation: stampX
// = wsetGenX.nodeX):
//
// - if wsetGen1 < wsetGen2, then stamp1 < ("is lower than") stamp2
//
// - elsif wsetGen1 = wsetGen2, then
//
//     - if node1 < node2, then stamp1 < stamp2
//
// - else stamp2 < stamp1.
//
// For the purposes of sequencing the different types of operations, ObMan
// maintains
//
// - one sequence stamp per workset:
//
//   - the last 'time' it was cleared (the clear stamp)
//
// - four sequence stamps per object:
//
//   - the 'time' the object was added (the addition stamp)
//
//   - the 'time' the object was last moved (the position stamp)
//
//   - the 'time' the object was last updated (the update stamp)
//
//   - the 'time' the object was last replace (the replace stamp; in
//     reality, only one of the update/replace stamps is required for
//     sequencing but both are needed for optimum spoiling).
//
// The initial values of the position, update and replace stamps are set to
// the value of the addition stamp.
//
// The initial value of the clear stamp is set to <0.ID> where ID is the ID
// of the node which created the workset.
//
// In addition, each object has a position field (either FIRST or LAST in
// R1.1) which indicates where the object was most recently positioned i.e.
// it is set when the object is added and then each time the object is
// moved within the workset.
//
//

//
//
// SEQUENCING PROTOCOLS
//
// The treatment of each type of operation is now considered in turn.
//
// 1.  Operations on unknown objects or worksets
//
// ObMan may at any time receive operations on objects or worksets which do
// not exist locally.  These operations may be on objects or worksets which
//
// - this node has not yet heard of, or
//
// - have been deleted.
//
// Operations on the first kind need to be delayed and reprocessed at a
// later time.  Operations on the second kind can be thrown away (note that
// there are no workset operations of this kind as once opened, worksets
// are never deleted in the lifetime of the workset group).
//
// To differentiate between the two, ObMan keeps a record of deleted
// objects.  When an operation on a deleted object arrives, it is
// discarded.  When an operation arrives for an object which is not in
// either the active object list or the deleted object list, ObMan bounces
// the event from the network layer back to its event loop, with a suitable
// delay, and attempts to process it later.
//
// For simplicity, the deleted object list is implemented by flagging
// deleted objects as such and leaving them in the main list of objects
// (i.e.  the workset), rather than moving them to a separate list.  The
// object data is, however, discarded; only the object record needs to be
// kept.
//
// Events from the network layer referring to operations on unknown
// worksets are automatically bounced back onto ObMan's event queue.
//
// 2.  Adding an object
//
// If ObMan receives an Add operation for an object which it has already
// added to a workset (i.e.  the object IDs are the same), it discards the
// operation.
//
// This normally will not happen since each object is added by only one
// node, and no node adds an object with the same ID twice.
//
// However, while a late-joiner is catching up with the contents of a
// workset, it is possible that it will receive notification of a
// particular object from both
//
// - the node which added the object
//
// - the helper node which is sending it the entire workset
//   contents.
//
// Therefore, the late-joiner checks object IDs as they arrive and discards
// them if they have already been received.  Note that since the
// positioning algorithm presented below will position each occurrence of
// the object in adjacent positions, checking for ID clashes is a simple
// matter, performed after the correct position has been found.
//
// 3.  Positioning (adding or moving) an object in a workset
//
// The desired sequence of objects in a workset is defined to be one
// whereby
//
// - all the objects which were positioned at the start of a workset (FIRST
//   objects) are before all the objects which were positioned at the end
//   of a workset (LAST objects)
//
// - the position stamps of all the FIRST objects decrease monotonically
//   from the start of the workset forward
//
// - the position stamps of all the LAST objects decrease monotonically
//   from the end of the workset backward.
//
// Accordingly, the protocol when positioning an object at the start of a
// workset is as follows (instructions for end-of-workset positioning in
// brackets):
//
// ObMan searches forward (back) from the start (end) of the workset until
// if finds an object which either
//
// - is not a FIRST (LAST) object, or
//
// - has a lower (lower) position stamp
//
// ObMan inserts the new/moved object before (after) this object.
//
// 4.  Clearing a workset
//
// On receiving a Clear operation, ObMan searches through the workset and
// deletes all objects which have an addition stamp lower than the clear
// operation's stamp.
//
// On receiving an addition to a workset, ObMan discards the operation if
// its stamp is lower than the workset's clear stamp.
//
// 5.  Updating an object
//
// On receiving an Update operation, ObMan compares its stamp with the
// object's update and replace stamps.  If the operation's stamp is higher
// than both, the operation is performed; otherwise, the operation is
// discarded (since an Update is superceded either by a later Replace or by
// a later Update).
//
// 6.  Replacing an object
//
// On receiving a Replace operation, ObMan compares its stamp with the
// object's replace stamp.  If the operation's stamp is higher, the
// operation is performed; otherwise, the operation is discarded (since a
// Replace is superceded by a later Replace but not by a later Update).
//
// 7.  Deleting an object
//
// By definition, a Delete is the last operation that should be performed
// on an object.  Delete operations are therefore processed immediately by
// setting the <deleted> flag in the object record to TRUE.
//
//

//
//
// OPERATION RESEQUENCING - SUMMARY
//
// In summary, therefore,
//
// - all object operations are discarded if object found on the deleted
//   object queue
//
// - Add operations are discarded if they refer to an existing object.
//
// - Add/Clear operations are requeued if the workset is not present
//   locally
//
// - Update/Replace/Move/Delete operations are requeued if the object or
//   workset is not present locally
//
// - Update operations are discarded if an Update or a Replace with a later
//   sequence stamp has already been received.
//
// - Replace operations are discarded if a Replace with a later sequence
//   stamp has already been received.
//
// By default, all operations are performed.
//
//


//
//
// OBJECT IDS
//
// Object IDs are structures which identify an object within a workset.
// For a given workset, they are unique throughout the Domain.
//
// To ensure uniqueness, the MCS user ID is used as a (two-byte) prefix to
// a four-byte sequence number generated locally, on a per workset basis.
//
// Workset groups can exist independently of a Domain, and therefore
// potentially before ObMan has been allocated an MCS user ID.  When
// allocating object IDs in this situation, ObMan uses zero (0) as the
// prefix to the sequence number.
//
// If that workset group is subsequently moved into a Domain, for all
// subsequent ID allocations ObMan uses its MCS user ID for that Domain as
// the prefix.  Other instances of ObMan may also start adding objects to
// the worksets in the group at this point, and they too use their MCS user
// IDs as the object ID prefix.  Uniqueness is preserved by the MCS
// guarantee that zero is never a valid user ID, so no post-share generated
// ID can conflict with a pre-share generated ID.
//
//


//
//
// SEQUENCE STAMPS
//
// Sequence stamps define a Domain-wide ordering for operations.  They are
// used to correctly execute operations which may arrive at a node in an
// indeterminate order.
//
//

typedef struct tagOM_SEQUENCE_STAMP
{
   TSHR_UINT32      genNumber;            // the workset generation number
                                           // which was current when the
                                           // stamp was issued
   NET_UID          userID;               // the MCS user ID for ObMan at
                                           // the node which issued it

    WORD            pad1;
} OM_SEQUENCE_STAMP;

typedef OM_SEQUENCE_STAMP *            POM_SEQUENCE_STAMP;


//
//
// OBJECT POSITION STAMPS
//
// When an object is added to or moved within a workset, it is important to
// know where it has been added.  Therefore, Add and Move operations
// include within them a position field, with the following type:
//
//

typedef BYTE            OM_POSITION;

//
// Possible values for an OM_POSITION variable:
//

#define LAST            1
#define FIRST           2
#define BEFORE          3
#define AFTER           4



//
//
// SEQUENCE STAMP MANIPULATION
//
// These macro manipulate sequence stamps.
//
//

//
//
// STAMP_IS_LOWER(stamp1, stamp2)
//
// This macro compares one sequence stamp with another.  It evaluates to
// TRUE if the first stamp is lower than the second.
//
//

#define STAMP_IS_LOWER(stamp1, stamp2)                                      \
                                                                            \
   (((stamp1).genNumber  <  (stamp2).genNumber) ?                           \
    TRUE :                                                                  \
    (((stamp1).genNumber == (stamp2).genNumber)                             \
     &&                                                                     \
     ((stamp1).userID    <  (stamp2).userID)))


//
//
// SET_NULL_SEQ_STAMP(stamp)
//
// This macro sets the sequence stamp <stamp> to NULL.
//
//

#define SET_NULL_SEQ_STAMP(stamp)                                           \
                                                                            \
   (stamp).userID     = 0;                                                  \
   (stamp).genNumber  = 0

//
//
// SEQ_STAMP_IS_NULL(stamp)
//
// This macro evaluates to TRUE if the sequence stamp <stamp> is a NULL
// sequence stamp.
//
//

#define SEQ_STAMP_IS_NULL(stamp)                                            \
                                                                            \
   ((stamp.userID == 0) && (stamp.genNumber == 0))

//
//
// COPY_SEQ_STAMP(stamp1, stamp2)
//
// This macro sets the value of the first sequence stamp to that of the
// second.
//
//

#define COPY_SEQ_STAMP(stamp1, stamp2)                                      \
                                                                            \
   (stamp1).userID    = (stamp2).userID;                                    \
   (stamp1).genNumber = (stamp2).genNumber


//
//
// MESSAGE FORMATS
//
// This section describes the formats of the messages sent between
// different instances of ObMan.
//
// The names of these messages are prefixed OMNET_...
//
// These events have the following format:
//
//    typedef struct
//    {
//       OMNET_PKT_HEADER   header;
//       :
//       : [various event specific fields]
//       :
//
//    } OMNET_...
//
// The OMNET_PKT_HEADER type is defined below.
//
//

typedef TSHR_UINT16                OMNET_MESSAGE_TYPE;

typedef struct tagOMNET_PKT_HEADER
{
    NET_UID              sender;            // MCS user ID of sender
    OMNET_MESSAGE_TYPE   messageType;       // == OMNET_...
}
OMNET_PKT_HEADER;
typedef OMNET_PKT_HEADER *             POMNET_PKT_HEADER;

//
// Possible values for a OMNET_MESSAGE_TYPE variable:
//

#define OMNET_NULL_MESSAGE             ((OMNET_MESSAGE_TYPE)  0x00)

#define OMNET_HELLO                    ((OMNET_MESSAGE_TYPE)  0x0A)
#define OMNET_WELCOME                  ((OMNET_MESSAGE_TYPE)  0x0B)

#define OMNET_LOCK_REQ                 ((OMNET_MESSAGE_TYPE)  0x15)
#define OMNET_LOCK_GRANT               ((OMNET_MESSAGE_TYPE)  0x16)
#define OMNET_LOCK_DENY                ((OMNET_MESSAGE_TYPE)  0x17)
#define OMNET_UNLOCK                   ((OMNET_MESSAGE_TYPE)  0x18)
#define OMNET_LOCK_NOTIFY              ((OMNET_MESSAGE_TYPE)  0x19)

#define OMNET_WSGROUP_SEND_REQ         ((OMNET_MESSAGE_TYPE)  0x1E)
#define OMNET_WSGROUP_SEND_MIDWAY      ((OMNET_MESSAGE_TYPE)  0x1F)
#define OMNET_WSGROUP_SEND_COMPLETE    ((OMNET_MESSAGE_TYPE)  0x20)
#define OMNET_WSGROUP_SEND_DENY        ((OMNET_MESSAGE_TYPE)  0x21)

#define OMNET_WORKSET_CLEAR            ((OMNET_MESSAGE_TYPE)  0x28)
#define OMNET_WORKSET_NEW              ((OMNET_MESSAGE_TYPE)  0x29)
#define OMNET_WORKSET_CATCHUP          ((OMNET_MESSAGE_TYPE)  0x30)

#define OMNET_OBJECT_ADD               ((OMNET_MESSAGE_TYPE)  0x32)
#define OMNET_OBJECT_CATCHUP           ((OMNET_MESSAGE_TYPE)  0x33)
#define OMNET_OBJECT_REPLACE           ((OMNET_MESSAGE_TYPE)  0x34)
#define OMNET_OBJECT_UPDATE            ((OMNET_MESSAGE_TYPE)  0x35)
#define OMNET_OBJECT_DELETE            ((OMNET_MESSAGE_TYPE)  0x36)
#define OMNET_OBJECT_MOVE              ((OMNET_MESSAGE_TYPE)  0x37)

#define OMNET_MORE_DATA                ((OMNET_MESSAGE_TYPE)  0x46)


//
//
// GENERIC OPERATION PACKET
//
// ObMan uses this structure for the following messages:
//
//   OMNET_MORE_DATA                uses first 1 field (4 bytes), plus data
//
//   OMNET_WORKSET_NEW              } use first 7 fields (24 bytes)
//   OMNET_WORKSET_CATCHUP          }
//
//   OMNET_WORKSET_CLEAR            uses first 6 fields (16 bytes);
//                                  doesn't use <position), <flags>
//
//   OMNET_OBJECT_MOVE              uses first 7 fields (24 bytes);
//                                  doesn't use <flags>
//
//   OMNET_OBJECT_DELETE            uses first 7 fields (24 bytes);
//                                  doesn't use <position), <flags>
//
//   OMNET_OBJECT_REPLACE           } use first 8 fields (28 bytes), plus
//   OMNET_OBEJCT_UPDATE            } data; don't use <position), <flags>
//
//   OMNET_OBJECT_ADD               uses first 9 fields (32 bytes), plus
//                                  data; doesn't use <flags>
//
//   OMNET_OBJECT_CATCHUP           uses all 12 fields (56 bytes), plus
//                                  data
//
//

typedef struct tagOMNET_OPERATION_PKT
{
    OMNET_PKT_HEADER     header;

    OM_WSGROUP_ID        wsGroupID;
    OM_WORKSET_ID        worksetID;
    BYTE                 position;       // <position> for Add/Move/Catchup
    BYTE                 flags;          // <flags> for ObjectCatchUp

       //
       // Note: for WORKSET_NEW/CATCHUP messages, the two bytes occupied by
       // the <position> and <flags> fields hold a NET_PRIORITY value.
       //

    OM_SEQUENCE_STAMP    seqStamp;       // operation sequence stamp
                                        // (== addStamp for ObjectCatchUp,
                                        // curr stamp for WorksetCatchUp)
    OM_OBJECT_ID         objectID;

       //
       // Note: for WORKSET_NEW/CATCHUP messages, the first byte occupied
       // by the <objectID> field holds a BOOL indicating whether the
       // workset is persistent.
       //

    TSHR_UINT32             totalSize;      // total size of transfer
    TSHR_UINT32             updateSize;

    OM_SEQUENCE_STAMP       positionStamp;
    OM_SEQUENCE_STAMP       replaceStamp;
    OM_SEQUENCE_STAMP       updateStamp;
}
OMNET_OPERATION_PKT;
typedef OMNET_OPERATION_PKT *          POMNET_OPERATION_PKT;

#define OMNET_MORE_DATA_SIZE               4
#define OMNET_WORKSET_NEW_SIZE             24
#define OMNET_WORKSET_CATCHUP_SIZE         24
#define OMNET_WORKSET_CLEAR_SIZE           16
#define OMNET_OBJECT_MOVE_SIZE             24
#define OMNET_OBJECT_DELETE_SIZE           24
#define OMNET_OBJECT_REPLACE_SIZE          28
#define OMNET_OBJECT_UPDATE_SIZE           28
#define OMNET_OBJECT_ADD_SIZE              32
#define OMNET_OBJECT_CATCHUP_SIZE          56

//
// These define the sizes of the packets we used in R1.1: we must only send
// packets of this size to R1.1 systems.
//

//
//
// HELLO/WELCOME MESSAGE
//
// When ObMan attaches to a Domain that contains an outgoing call, it
// broadcasts an OMNET_WELCOME message on the well-known ObManControl
// channel.
//
// When ObMan attaches to a Domain that contains an incoming call, it
// broadcasts an OMNET_HELLO message on the well-known ObManControl
// channel.
//
// When ObMan receives a HELLO message, it replies with a WELCOME message,
// just as if it had just joined the call.
//
// This allows each late-joining ObMan in the call to discover the user ID
// of each of the other instances of ObMan.
//
// A late-joining ObMan uses this information by asking one of the nodes
// which WELCOMEd it for a copy of the ObManControl workset group.
//
// HELLO/WELCOME packets are NEVER compressed.
//
// WELCOME and HELLO messages have the following format:
//
//

typedef struct tagOMNET_JOINER_PKT
{
    OMNET_PKT_HEADER    header;
    TSHR_UINT32         capsLen;             // == 4 in this version.
    TSHR_UINT32         compressionCaps;     // bitwise OR of OM_CAPS_ bits
}
OMNET_JOINER_PKT;
typedef OMNET_JOINER_PKT *     POMNET_JOINER_PKT;


//
// The actual compression type used in any given packet is specified as the
// first byte of the packet (before the header and other structures
// specified in this file).  The compression type is the numeric value of
// the bit position corresponding to the compression capability.  For
// example, if XYZ compression has a capability value of 0x8, then packets
// compressed with XYZ will have 3 in their first byte.
//
// '0' is never valid as an OM_PROT_...  compression type (which is why bit
// 1 is not used as an OM_CAPS_...  flag).
//
#define OM_PROT_PKW_COMPRESSED      0x01
#define OM_PROT_NOT_COMPRESSED      0x02

//
// Values for compressionCaps.  These must be separate bits, since they may
// be ORed together if a node supports multiple compression types.
//
// Note that OM_CAPS_NO_COMPRESSION is always supported.
//
// Bit 1 is not used.
//
#define OM_CAPS_PKW_COMPRESSION     0x0002
#define OM_CAPS_NO_COMPRESSION      0x0004


//
//
// LATE-JOINER PROTOCOL - WORKSET GROUP SEND REQUEST/SEND COMPLETE
//
// The SEND_REQUEST message is sent when ObMan has "late-joined" a
// particular workset group and would like another node to send it the
// current contents.
//
// The message is sent to an arbitrary "helper" node (known to have a copy
// of the workset group) on its single-user channel.
//
// The recipient responds by flushing the relevant channel (in R1.1, a
// no-op; in R2.0, perform a WORKSET_CHECKPOINT) and then sending the
// contents of the workset.
//
// When the WORKSET_CATCHUP messages have been sent, we send a
// WSGROUP_SEND_MIDWAY message to let the late joiner know that it now
// knows about all the worksets which are currently in use (otherwise, it
// might create a workset already in use which happened to be locked on the
// sending machine add then an object to it.
//
// The SEND_MIDWAY message also containing the max sequence number
// previously used by the late joiner's ID in this workset group (to
// prevent re-use of object IDs).
//
// When the contents have been sent, i.e.  after the last data packet of
// the last object in the last workset of the group, the helper sends a
// SEND_COMPLETE message.
//
// If the chosen helper node is not in a position to send the contents of
// the workset group, it must repsond with a SEND_DENY message, upon
// receipt of which the late joiner will choose someone else to catch up
// from.
//
// The SEND_REQUEST, SEND_MIDWAY, SEND_COMPLETE and SEND_DENY message
// packets have the following structure:
//
//

typedef struct tagOMNET_WSGROUP_SEND_PKT
{
    OMNET_PKT_HEADER    header;
    OM_WSGROUP_ID       wsGroupID;
    BYTE                pad1;
    TSHR_UINT16         correlator;         // Holds the catchup correlator
    OM_OBJECT_ID        objectID;
    TSHR_UINT32         maxObjIDSeqUsed;
}
OMNET_WSGROUP_SEND_PKT;
typedef OMNET_WSGROUP_SEND_PKT *       POMNET_WSGROUP_SEND_PKT;


//
//
// LOCKING PROTOCOL - LOCK PACKET
//
// When ObMan wants to lock a workset/object, it broadcasts one of these
// packets (with type == OMNET_LOCK_REQ).
//
// When ObMan receives one of these packets, it decides to deny or grant
// the lock to the sender, and replies with another packet of the same
// structure but with type == OMNET_LOCK_DENY or OMNET_LOCK_GRANT as
// appropriate.
//
// When ObMan wants to unlock a workste/object it has previously locked, it
// broadcasts one of these packets with type == OMNET_UNLOCK.
//

typedef struct tagOMNET_LOCK_PKT
{
    OMNET_PKT_HEADER     header;
    OM_WSGROUP_ID        wsGroupID;
    OM_WORKSET_ID        worksetID;
    TSHR_UINT16          data1;          // used as correlator for GRANT/DENY
                                        // used to indicate who's got lock
                                        // for NOTIFY
    // lon: need to keep pLockReqCB field for backward compatability!
    void *              pLockReqCB;     // R1.1 uses this to find the lock
                                        // request CB
}
OMNET_LOCK_PKT;
typedef OMNET_LOCK_PKT *            POMNET_LOCK_PKT;


//
//
// DATA STRUCTURES
//
//


//
//
// OPERATION TYPES
//
// This is the type defined for operations which Clients may perform on
// objects and worksets.  Pending operation lists use this type.
//
//

typedef TSHR_UINT16             OM_OPERATION_TYPE;

//
// Possible values for a OM_OPERATION_TYPE variable:
//

#define NULL_OP              ((OM_OPERATION_TYPE)  0)
#define WORKSET_CLEAR        ((OM_OPERATION_TYPE)  1)
#define OBJECT_ADD           ((OM_OPERATION_TYPE)  2)
#define OBJECT_MOVE          ((OM_OPERATION_TYPE)  3)
#define OBJECT_DELETE        ((OM_OPERATION_TYPE)  4)
#define OBJECT_REPLACE       ((OM_OPERATION_TYPE)  5)
#define OBJECT_UPDATE        ((OM_OPERATION_TYPE)  6)


//
//
// PENDING OPERATION LISTS
//
// When ObMan receives a request (either from a local Client or over the
// network) to delete, update or replace an object, or to clear a workset,
// it cannot perform the operation until the local Client has confirmed it.
// These operations are therefore put in a list and processed when the
// appropriate Confirm function is invoked.
//
// This list is hung off the workset record; its elements have the
// following format:
//
//

typedef struct tagOM_PENDING_OP
{
    STRUCTURE_STAMP

    BASEDLIST                  chain;

    POM_OBJECT              pObj;        // NULL if a clear operation
    POM_OBJECTDATA          pData;

    OM_SEQUENCE_STAMP       seqStamp;    // the sequence stamp which was
                                     // current in the workset when the
                                     // operation was invoked

    OM_OPERATION_TYPE       type;        // == WORKSET_CLEAR, OBJECT_DELETE,
                                    // OBJECT_UPDATE or OBJECT_REPLACE

    WORD    pad1;

}
OM_PENDING_OP;
typedef OM_PENDING_OP *         POM_PENDING_OP;


//
//
// OBJECT RECORDS
//
// This structure holds information about a particular object,
//
typedef struct tagOM_OBJECT
{
    STRUCTURE_STAMP

    BASEDLIST              chain;

    OM_OBJECT_ID        objectID;           // Unique within domain
    POM_OBJECTDATA      pData;              // Ptr to data

    OM_SEQUENCE_STAMP   addStamp;            // the sequence stamps used
    OM_SEQUENCE_STAMP   positionStamp;          OM_SEQUENCE_STAMP   replaceStamp;
    OM_SEQUENCE_STAMP   updateStamp;

    UINT                updateSize;         // size of (all) updates

    BYTE                flags;               // defined below
    OM_POSITION         position;            // either LAST or FIRST,
                                             // indicating where the object
                                             // was most recently placed
    WORD pad1;
}
OM_OBJECT;


BOOL __inline ValidObject(POM_OBJECT pObj)
{
    return(!IsBadWritePtr(pObj, sizeof(OM_OBJECT)));
}
void __inline ValidateObject(POM_OBJECT pObj)
{
    ASSERT(ValidObject(pObj));
}


//
// Flags used:
//

#define DELETED             0x0001
#define PENDING_DELETE      0x0002


//
//
// UNUSED OBJECTS LISTS
//
// When a Client allocates an object using OM_ObjectAlloc, a reference to
// the memory allocated is stored in the Client's unused objects list for
// this workset group.
//
// The reference is removed when the Client either
//
// - discards the object using OM_ObjectDiscard, or
//
// - inserts the object in a workset with an Add, Update or Replace
//   function.
//
// This list of objects (which is hung off the usage record) is checked
// when a workset is closed to discard any objects the Client didn't
// explicitly discard or use.
//
// The elements of the list have the following form:
//
//

typedef struct tagOM_OBJECTDATA_LIST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;
    POM_OBJECTDATA      pData;

    UINT                size;       // Used to verify that Client hasn't grown size

    OM_WORKSET_ID       worksetID;
    BYTE                pad1;
    WORD                pad2;
}
OM_OBJECTDATA_LIST;
typedef OM_OBJECTDATA_LIST *     POM_OBJECTDATA_LIST;


//
//
// OBJECTS-IN-USE LISTS
//
// When a Client reads an object using OM_ObjectRead, the use count of the
// chunk of memory containing the object is increased.
//
// The use count is deceremented again when the Client calls
// OM_ObjectRelease, but if the Client abends, or simply closes a workset
// without releasing the objects it has read, we still need to be able to
// free the memory.
//
// Therefore we keep a list, on a per-workset-group basis, of the objects
// that a Client is using.  Objects (identified by handles) are added to
// the list when a Client calls OM_ObjectRead, and removed from the list
// when the Client calls OM_ObjectRelease.
//
// In addition, the list is checked when a workset is closed to release any
// handles the Client didn't release explicitly.
//
// Like the unused objects list, this list is hung off the usage record.
//
// The elements of these lists have the following form:
//
//

typedef struct tagOM_OBJECT_LIST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;
    POM_OBJECT          pObj;

    OM_WORKSET_ID       worksetID;        // the ID of the workset
    BYTE                pad1;
    WORD                pad2;
}
OM_OBJECT_LIST;
typedef OM_OBJECT_LIST *          POM_OBJECT_LIST;


//
//
// NODE LIST STRUCTURES
//
// When requesting locks etc.  from other nodes in a Domain, ObMan keeps a
// list of remote nodes which it expects a reply from.  A node is
// identified by the MCS user ID of the instance of ObMan running on that
// node.
//
// The elements of these lists have the folllowing form:
//
//

typedef struct tagOM_NODE_LIST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;

    NET_UID          userID;         // user ID of remote ObMan

    WORD             pad1;
}
OM_NODE_LIST;

typedef OM_NODE_LIST *           POM_NODE_LIST;


//
//
// LOCK REQUEST CONTROL BLOCKS
//
// When ObMan is in the process of getting a lock for a workset or object
// it creates one of these structures to correlate the lock replies.
//
//

typedef struct tagOM_LOCK_REQ
{
    STRUCTURE_STAMP

    BASEDLIST               chain;

    PUT_CLIENT           putTask;           // task to notify on success
                                             // or failure
    OM_CORRELATOR        correlator;          // returned by WorksetLockReq
    OM_WSGROUP_ID        wsGroupID;           // workset group and workset
    OM_WORKSET_ID        worksetID;           // containing the lock

    POM_WSGROUP          pWSGroup;

    BASEDLIST               nodes;               // MCS user IDs of nodes which
                                             // haven't yet replies to req
                                             // (an OM_NODE_LIST list)

    WORD                retriesToGo;        // Decremented on each timeout
    OM_WSGROUP_HANDLE   hWSGroup;
    BYTE                type;               // PRIMARY or SECONDARY
}
OM_LOCK_REQ;
typedef OM_LOCK_REQ *                    POM_LOCK_REQ;

#define LOCK_PRIMARY        0x01
#define LOCK_SECONDARY      0x02



//
//
// CLIENT LIST STRUCTURE
//
// The lists of Clients stored per workset group and per workset contain
// elements of this type.  The <hWSGroup> field refers to the workset group
// handle by which the Client knows the workset group concerned.
//
//

typedef struct tagOM_CLIENT_LIST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;
    PUT_CLIENT          putTask;         // the Client's putTask
    WORD                mode;
    OM_WSGROUP_HANDLE   hWSGroup;
    BYTE                pad1;
}
OM_CLIENT_LIST;
typedef OM_CLIENT_LIST *      POM_CLIENT_LIST;


//
//
// WORKSET RECORDS
//
// This structure holds the state information for a workset.  It resides at
// offset zero (0) in the huge memory block associated with this workset.
//
// ObMan allocates a workset record when a workset is created and discards
// it when the workset is discarded.
//
//

typedef struct tagOM_WORKSET
{
    STRUCTURE_STAMP

    UINT                numObjects;    // the current number of objects in
                                       // workset (excluding the sentinels)

    UINT                genNumber;     // current workset generation number

    OM_SEQUENCE_STAMP   clearStamp;    // the clear stamp for the workset

    NET_PRIORITY        priority;      // MCS priority for the workset
    OM_WORKSET_ID       worksetID;
    BYTE                lockState;     // one of the values defined below

    WORD                lockCount;     // LOCAL lock count
    NET_UID             lockedBy;      // MCS user ID of node which has the
                                       //  lock, if any

    BASEDLIST              objects;       // root of list of workset's objects

    UINT                bytesUnacked;  // bytes still to be acked

    BASEDLIST              pendingOps;    // root of list of operations which
                                       // are pending for this workset

    BASEDLIST              clients;       // root of list of Clients which
                                       // have this workset open
    BOOL                fTemp;
}
OM_WORKSET;
typedef OM_WORKSET   *            POM_WORKSET;

void __inline ValidateWorkset(POM_WORKSET pWorkset)
{
    ASSERT(!IsBadWritePtr(pWorkset, sizeof(OM_WORKSET)));
}

//
// Possible values for the <lockState> field above:
//

#define UNLOCKED              0x00
#define LOCKING               0x01
#define LOCKED                0x02
#define LOCK_GRANTED          0x03


//
//
// WORKSET GROUP RECORDS
//
// This structure holds information about a workset group.
//
// ObMan maintains one of these structures for each workset group with
// which one or more local Clients are registered.
//
// It will be discarded when the last local Client registered with the
// workset group deregisters from it.
//
//

typedef struct tagOM_WSGROUP
{
    STRUCTURE_STAMP

    BASEDLIST       chain;

    OMWSG           wsg;
    OMFP            fpHandler;

    NET_CHANNEL_ID  channelID;      // MCS channel ID used for WSG
    OM_WSGROUP_ID   wsGroupID;      // workset group ID
    BYTE            state;          // one of the values defined below

    POM_OBJECT   pObjReg;     // Registration object in the OMC workset

    BASEDLIST          clients;        // the Clients using the WSG

    POM_DOMAIN      pDomain;

    NET_UID         helperNode;     // ID of the node we are catching up from.
    WORD            valid:1;
    WORD            toBeDiscarded:1;

    UINT            bytesUnacked;   // sum of bytesUnacked field for each
                                     // workset in the workset group

    BYTE            sendMidwCount;  // # of SEND_MIDWAYs received
    BYTE            sendCompCount;  // # of SEND_MIDWAYs received
    OM_CORRELATOR   catchupCorrelator; // Used to correlate SEND_REQUESTS
                                        // to SEND_MIDWAYs and
                                        // SEND_COMPLETEs.
    POM_WORKSET     apWorksets[ OM_MAX_WORKSETS_PER_WSGROUP + 1];
}
OM_WSGROUP;



void __inline ValidateWSGroup(POM_WSGROUP pWSGroup)
{
    ASSERT(!IsBadWritePtr(pWSGroup, sizeof(OM_WSGROUP)));
}



//
// Workset group <state> values
//

#define INITIAL                  0x00
#define LOCKING_OMC              0x01
#define PENDING_JOIN             0x02
#define PENDING_SEND_MIDWAY      0x03
#define PENDING_SEND_COMPLETE    0x04
#define WSGROUP_READY            0x05


//
//
// USAGE RECORDS
//
// A usage record identifies a Client's use of a particular workset group
// and holds state information about that usage.
//
// Usage records reside in the OMGLBOAL memory block at the offset (from
// the base) specified in the Client record.
//
//

typedef struct tagOM_USAGE_REC
{
    STRUCTURE_STAMP

    POM_WSGROUP      pWSGroup;         // Client pointer to workset group

    BASEDLIST           unusedObjects;    // start sentinel in list of
                                         // pointers to unused objects

    BASEDLIST           objectsInUse;     // OM_OBJECT_LIST

    BYTE             mode;
    BYTE             flags;

    BYTE             worksetOpenFlags[(OM_MAX_WORKSETS_PER_WSGROUP + 7)/8];

                                         // bitfield array of flags
                                         // indicating the worksets the
                                         // Client has open
}
OM_USAGE_REC;
typedef OM_USAGE_REC *               POM_USAGE_REC;

__inline void ValidateUsageRec(POM_USAGE_REC pUsageRec)
{
    ASSERT(!IsBadWritePtr(pUsageRec, sizeof(OM_USAGE_REC)));
}

//
// Values for flags:
//

#define ADDED_TO_WSGROUP_LIST       0x0002
#define PWSGROUP_IS_PREGCB          0x0004

//
//
// LOCK STACKS
//
// Clients must request and release object and workset locks in accordance
// with the Universal Locking Order as defined in the Functional Spec (in
// order to avoid deadlock).
//
// In order to detect lock order violations, ObMan maintains, for each
// Client, a stack of locks which the Client holds or has requested.  This
// stack is implemented as a linked list, with the most recently acquired
// lock (which must, by definition, be the one latest in the Universal
// Locking Order) being the first element.
//
// A Client's lock stack is initialised when the Client registers with
// ObMan and discarded when the Client deregisters from ObMan.  Lock stacks
// are hung off the Client record.
//
// Note that we need the store the object ID here, as opposed to the
// handle, since we must enforce the universal lock order across all nodes.
//
// Elements of lock stacks have the following form:
//
//

typedef struct tagOM_LOCK
{
    STRUCTURE_STAMP

    BASEDLIST                chain;

    POM_WSGROUP           pWSGroup;      // Client pointer to workset group
                                        // needed to detect lock violations

    OM_OBJECT_ID          objectID;      // the object ID is 0 if this is a
                                        // workset lock (in R1.1, always).
    OM_WORKSET_ID         worksetID;
    BYTE pad1;
    WORD pad2;
}
OM_LOCK;
typedef OM_LOCK *                   POM_LOCK;


int __inline CompareLocks(POM_LOCK pLockFirst, POM_LOCK pLockSecond)
{
    int     result;

    result = (pLockSecond->pWSGroup->wsg - pLockFirst->pWSGroup->wsg);

    if (result == 0)
    {
        // Same WSG, so compare worksets
        result = (pLockSecond->worksetID - pLockFirst->worksetID);
    }

    return(result);
}


//
//
// CLIENT RECORD
//
// ObMan maintains instance data for every registered Client.  This
// structure, a Client record, holds the Client instance data.
//
// A Client's ObMan handle is a Client pointer to this structure.
//
// A Client's workset group handle is an index into the array of usage record
// ptrs.
//
// If the value of apUsageRecs is 0 or -1, x is not a valid workset
// group handle.
//
//

typedef struct tagOM_CLIENT
{
    STRUCTURE_STAMP

    PUT_CLIENT      putTask;

    BOOL            exitProcReg:1;
    BOOL            hiddenHandlerReg:1;

    BASEDLIST          locks;        // root of list of locks held

    POM_USAGE_REC   apUsageRecs[OMWSG_MAXPERCLIENT];
    BOOL            wsgValid[OMWSG_MAXPERCLIENT];
}
OM_CLIENT;



BOOL __inline ValidWSGroupHandle(POM_CLIENT pomClient, OM_WSGROUP_HANDLE hWSGroup)
{
    return((hWSGroup != 0) &&
           (pomClient->wsgValid[hWSGroup]) &&
           (pomClient->apUsageRecs[hWSGroup] != NULL));
}


//
//
// DOMAIN RECORD
//
// This structure holds information about a Domain.  We support two:
//      * The current call
//      * Limbo (no call) for cleanup after a call and maintenance of info
//          across calls
//
typedef struct tagOM_DOMAIN
{
    STRUCTURE_STAMP

    BASEDLIST          chain;

    UINT            callID;             // MCS Domain Handle

    NET_UID         userID;             // ObMan's MCS user ID and token ID
    NET_TOKEN_ID    tokenID;            //  for this domain

    NET_CHANNEL_ID  omcChannel;         // ObMan's broadcast channel
    BYTE            state;              // one of the values defined below
    BYTE            omchWSGroup;        // ObMan's hWSGroup for this domain's

    BOOL            valid:1;
    BOOL            sendEventOutstanding:1;

    UINT            compressionCaps;    // Domain-wide compression caps

    BASEDLIST          wsGroups;           // root of list of workset groups
    BASEDLIST          pendingRegs;        // root of list of pending workset
                                        // group registration request
    BASEDLIST          pendingLocks;       // root of list of pending
                                        // lock requests
    BASEDLIST          receiveList;        // root of list of control blocks
                                        // for receives in progress
    BASEDLIST          bounceList;         // root of list of control blocks
                                        // for bounced messages
    BASEDLIST          helperCBs;          // root of list of helper CBs for
                                        // checkpoints in progress

    BASEDLIST          sendQueue[NET_NUM_PRIORITIES];
                                        // array of roots of list of send
                                        // queue instructions (by priority)
    BOOL            sendInProgress[NET_NUM_PRIORITIES];
                                        // array of send-in-progress flags
}
OM_DOMAIN;


//
// Possible values for <state> field:
//

#define PENDING_ATTACH         0x01
#define PENDING_JOIN_OWN       0x02
#define PENDING_JOIN_OMC       0x03
#define PENDING_TOKEN_ASSIGN   0x04
#define PENDING_TOKEN_GRAB     0x05
#define PENDING_TOKEN_INHIBIT  0x06
#define PENDING_WELCOME        0x07
#define GETTING_OMC            0x08
#define DOMAIN_READY           0x09




//
//
// SHARED MEMORY STRUCTURE
//
// This structure holds various private (to ObMan) state information.
//
// The ObMan task allocates and initialises one instance of this structure
// when it initialises; it resides at the base of the OMGLOBAL memory
// block.
//
// It is discarded when the ObMan task terminates.
//
//

typedef struct tagOM_PRIMARY
{
    STRUCTURE_STAMP

    PUT_CLIENT      putTask;
    PMG_CLIENT      pmgClient;              // OM's network layer handle
    PCM_CLIENT      pcmClient;              // OM's Call Manager handle

    BASEDLIST       domains;                // Domains
    OM_CLIENT       clients[OMCLI_MAX];     // Secondaries

    UINT            objectIDsequence;

    BOOL            exitProcReg:1;
    BOOL            eventProcReg:1;

    OM_CORRELATOR   correlator;
    WORD            pad1;

    LPBYTE          pgdcWorkBuf;
    BYTE            compressBuffer[OM_NET_SEND_POOL_SIZE / 2];
}
OM_PRIMARY;


void __inline ValidateOMP(POM_PRIMARY pomPrimary)
{
    ASSERT(!IsBadWritePtr(pomPrimary, sizeof(OM_PRIMARY)));
}


void __inline ValidateOMS(POM_CLIENT pomClient)
{
    extern POM_PRIMARY  g_pomPrimary;

    ValidateOMP(g_pomPrimary);

    ASSERT(!IsBadWritePtr(pomClient, sizeof(OM_CLIENT)));

    ASSERT(pomClient < &(g_pomPrimary->clients[OMCLI_MAX]));
    ASSERT(pomClient >= &(g_pomPrimary->clients[OMCLI_FIRST]));
}




//
//
// Workset group registration/move request control block
//
// This structure is used to pass the parameters of a workset group
// registration/move request to the ObMan task (from a Client task).
//
// Not all fields are used by both the registration and the move process.
//
// The <type> field is used to distinguish between a WSGroupMove and a
// WSGroupRegister.
//
//

typedef struct tagOM_WSGROUP_REG_CB
{
    STRUCTURE_STAMP

    BASEDLIST          chain;
    PUT_CLIENT      putTask;
    UINT            callID;

    OMWSG           wsg;
    OMFP            fpHandler;

    OM_CORRELATOR   correlator;
    OM_CORRELATOR   lockCorrelator;
    OM_CORRELATOR   channelCorrelator;
    WORD            retryCount;

    POM_USAGE_REC   pUsageRec;
    POM_WSGROUP     pWSGroup;

    POM_DOMAIN      pDomain;            // ObMan pointer to Domain record
    BOOL            valid;

    OM_WSGROUP_HANDLE   hWSGroup;
    BYTE            type;               // REGISTER or MOVE
    BYTE            mode;               // PRIMARY or SECONDARY
    BYTE            flags;              // see below
}
OM_WSGROUP_REG_CB;
typedef OM_WSGROUP_REG_CB *         POM_WSGROUP_REG_CB;

//
// Values for the <type> field:
//

#define WSGROUP_MOVE       0x01
#define WSGROUP_REGISTER   0x02

//
// Flags for the <flags> field:
//

#define BUMPED_CBS         0x0001    // indicates whether we bumped use
                                        // counts of pWSGroup, pDomain
#define LOCKED_OMC         0x0002    // indicates whether we've locked
                                        // ObManControl

//
// Values for the <mode> field (we use the flag macro because the values
// may be ORed together and so need to be bit-independent):
//

#define PRIMARY            0x0001
#define SECONDARY          0x0002


//
//
// HELPER CONTROL BLOCK
//
// When we receive a WSG_SEND_REQUEST from a remote node, we checkpoint the
// workset group requested.  This is an asynchronous process (it's
// essentially getting a lock on a dummy workset), so we need to store the
// details of the remote node away somewhere.  We do this using a help CB
// with the following structure:
//
//

typedef struct tagOM_HELPER_CB
{
    STRUCTURE_STAMP

    BASEDLIST          chain;

    NET_UID         lateJoiner;             // MCS user ID of late joiner
    OM_CORRELATOR   remoteCorrelator;

    POM_WSGROUP     pWSGroup;               // pWSGroup is bumped during
                                            //  checkpoint

    OM_CORRELATOR   lockCorrelator;         // returned by WorksetLockReq
                                           //  and recd in WORKSET_LOCK_CON

    WORD            pad1;
}
OM_HELPER_CB;
typedef OM_HELPER_CB *         POM_HELPER_CB;



//
//
// THE SEND QUEUE
//
// For each Domain, and for each network priority, ObMan maintains a queue
// of message and data to be sent to the network.  Clients, when executing
// API functions, cause instructions to be added to the tail of one of
// these queues.
//
// The ObMan task, in response to an OMINT_EVENT_SEND_QUEUE event, processes as
// many send queue operations as possible, giving up for a while when it
// runs out of network buffers.
//
// This is subject to the restriction that no operations are processed from
// one send queue when operations exist on a queue of higher priority in
// the same Domain.
//
// Instructions on the send queue have the following format:
//
//

typedef struct tagOM_SEND_INST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;

    UINT                callID;         // the relevant Domain

    NET_CHANNEL_ID      channel;       // the channel to send the event on
    NET_PRIORITY        priority;      // priority to send event on

    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POMNET_PKT_HEADER   pMessage;
    POM_OBJECT          pObj;

    POM_OBJECTDATA      pDataStart;
    POM_OBJECTDATA      pDataNext;

    WORD                messageSize;   // length of message at pMessage
    OMNET_MESSAGE_TYPE  messageType;   // == OMNET_OBJECT_ADD, etc.

    UINT                dataLeftToGo;  // number of bytes of data left to
                                       // be sent

    UINT                compressOrNot; // Some packets are never compressed

}
OM_SEND_INST;
typedef OM_SEND_INST *             POM_SEND_INST;

//
//
// RECEIVE LIST
//
// ObMan maintains a list of structures holding information about data
// transfers (receives) which have begun but not finished.  This is known
// as the receive list.
//
// When ObMan receives a header packet for an Add, Update or Replace
// operation, it adds an entry to the receive list.  Subsequent data
// packets are then correlated with this entry, until the entire object has
// been received, at which point the Add/Update/Replace operation is
// carried out.
//
// The receive list is a linked list of entries with the following format:
//
//

typedef struct tagOM_RECEIVE_CB
{
    STRUCTURE_STAMP

    BASEDLIST               chain;

    POM_DOMAIN           pDomain;     // Domain record pointer

    POMNET_OPERATION_PKT pHeader;        // ObMan pointer to message header

    void *               pData;          // ObMan pointer to the data that
                                        // is being transferred

    UINT                 bytesRecd;      // total bytes received so far for
                                        // this transfer

    LPBYTE               pCurrentPosition;  // points to where next chunk
                                           // of data should be copied

    NET_PRIORITY         priority;       // priority of data transfer
    NET_CHANNEL_ID       channel;

}
OM_RECEIVE_CB;
typedef OM_RECEIVE_CB *             POM_RECEIVE_CB;



//
// HANDLE <--> PTR CONVERSION ROUTINES
// Object, usage, domain, workset group, worksets
//


POM_WSGROUP  __inline GetOMCWsgroup(POM_DOMAIN pDomain)
{
    POM_WSGROUP pWSGroup;

    pWSGroup = (POM_WSGROUP)COM_BasedListFirst(&(pDomain->wsGroups),
        FIELD_OFFSET(OM_WSGROUP, chain));

    ValidateWSGroup(pWSGroup);

    return(pWSGroup);
}



POM_WORKSET  __inline GetOMCWorkset(POM_DOMAIN pDomain, OM_WORKSET_ID worksetID)
{
    POM_WSGROUP pWSGroup;

    pWSGroup = GetOMCWsgroup(pDomain);
    return(pWSGroup->apWorksets[worksetID]);
}




OM_CORRELATOR __inline NextCorrelator(POM_PRIMARY pomPrimary)
{
    return(pomPrimary->correlator++);
}



void __inline UpdateWorksetGeneration(POM_WORKSET pWorkset, POMNET_OPERATION_PKT pPacket)
{
    pWorkset->genNumber = max(pWorkset->genNumber, pPacket->seqStamp.genNumber) + 1;
}


//
//
// CHECK_WORKSET_NOT_EXHAUSTED(pWorkset)
//
// This macro checks that the specified workset is not exhausted.  If it
// is, it calls DC_QUIT.
//
//

#define CHECK_WORKSET_NOT_EXHAUSTED(pWorkset)                               \
                                                                            \
   if (pWorkset->genNumber == OM_MAX_GENERATION_NUMBER)                     \
   {                                                                        \
      WARNING_OUT(("Workset %hx exhausted", pWorkset->worksetID));          \
      rc = OM_RC_WORKSET_EXHAUSTED;                                         \
      DC_QUIT;                                                              \
   }

//
//
// CHECK_WORKSET_NOT_LOCKED(pWorkset)
//
// This macro checks that the specified workset is not locked.  If it is,
// it calls DC_QUIT with an error.
//
//

#define CHECK_WORKSET_NOT_LOCKED(pWorkset)                                  \
                                                                            \
   if (pWorkset->lockState == LOCK_GRANTED)                                 \
   {                                                                        \
      rc = OM_RC_WORKSET_LOCKED;                                            \
      WARNING_OUT(("Workset %hx locked - can't proceed", worksetID));       \
      DC_QUIT;                                                              \
   }


//
//
// OBJECT ID MANIPULATION
//
// These macros manipulate object IDs.
//
//

//
//
// OBJECT_ID_IS_NULL(objectID)
//
// This macro evaluates to TRUE if the supplied object ID is a null ID,
// and FALSE otherwise.
//
//

#define OBJECT_ID_IS_NULL(objectID)                                         \
                                                                            \
   (((objectID).creator  == 0) && ((objectID).sequence == 0))

//
//
// GET_NEXT_OBJECT_ID(objectID, pDomain, pWorkset)
//
// This macro allocates a new object ID for the workset specified by
// <pWorkset>.  It copies the ID into the structure specified by
// <objectID>.
//
// The first field in the ID is ObMan's MCS user ID in the Domain to which
// the workset group <pWSGroup> belongs.
//
//

#define GET_NEXT_OBJECT_ID(objectID, pDomain, pomPrimary)                 \
   (objectID).creator     = pDomain->userID;                             \
   (objectID).sequence    = pomPrimary->objectIDsequence++;                  \
   (objectID).pad1        = 0

//
//
// OBJECT_IDS_ARE_EQUAL(objectID1, objectID2)
//
// Evaluates to TRUE if the two object IDs are equal and FALSE otherwise.
//
//

#define OBJECT_IDS_ARE_EQUAL(objectID1, objectID2)                          \
                                                                            \
   (memcmp(&(objectID1), &(objectID2), sizeof(OM_OBJECT_ID)) == 0)

//
//
// SEQUENCE STAMP MANIPULATION
//
// These macro manipulate sequence stamps.
//
//

//
//
// GET_CURR_SEQ_STAMP(stamp, pWSGroup, pWorkset)
//
// This macro copies the current sequence stamp of the workset specified by
// <pWorkset> into the sequence stamp structure identified by <stamp>.
//
//

#define GET_CURR_SEQ_STAMP(stamp, pDomain, pWorkset)                     \
                                                                            \
   (stamp).userID     = pDomain->userID;                                 \
   (stamp).genNumber  = pWorkset->genNumber


//
// GenerateMessage(...)
//
// Allocates and initialises an OMNET_OPERATION_PKT of the specified type.
// Note that the <size> field is set to zero even if <messageType> is an
// add, update or replace.  The QueueMessage function will set the size to
// the correct value when the message is queued.
//
UINT GenerateOpMessage(                             POM_WSGROUP                pWSGroup,
                                      OM_WORKSET_ID              worksetID,
                                      POM_OBJECT_ID              pObjectID,
                                      POM_OBJECTDATA             pData,
                                      OMNET_MESSAGE_TYPE         messageType,
                                      POMNET_OPERATION_PKT *    ppPacket);


//
//
// QueueMessage(...)
//
// This function creates a send instruction for the specified message and
// places the instruction on the specified send queue for the specified
// Domain.  It them sends an event to ObMan prompting it to examine the
// queue.
//
//

UINT QueueMessage(PUT_CLIENT putTask,
                         POM_DOMAIN pDomain,
                                     NET_CHANNEL_ID       channelID,
                                     NET_PRIORITY         priority,
                                     POM_WSGROUP          pWSGroup,
                                     POM_WORKSET         pWorkset,
                                     POM_OBJECT      pObjectRec,
                                     POMNET_PKT_HEADER    pPacket,
                                     POM_OBJECTDATA          pData,
                                     BOOL               compressOrNot);

//
// GetMessageSize(...)
//
UINT GetMessageSize(OMNET_MESSAGE_TYPE  messageType);


//
// PreProcessMessage(...)
//
UINT PreProcessMessage(POM_DOMAIN            pDomain,
                                      OM_WSGROUP_ID             wsGroupID,
                                      OM_WORKSET_ID             worksetID,
                                      POM_OBJECT_ID             pObjectID,
                                      OMNET_MESSAGE_TYPE        messageType,
                                      POM_WSGROUP      *    ppWSGroup,
                                      POM_WORKSET     *    ppWorkset,
                                      POM_OBJECT  *    ppObjectRec);


//
//
// PurgeNonPersistent(...)
//
// Purges any objects added by <userID> from non-persistent worksets in the
// workset group identified by <wsGroupID> in the specified domain.
//
//

void PurgeNonPersistent(POM_PRIMARY pomPrimary,
                                         POM_DOMAIN      pDomain,
                                         OM_WSGROUP_ID       wsGroupID,
                                         NET_UID             userID);

//
// ProcessWorksetNew(...)
//
UINT ProcessWorksetNew(PUT_CLIENT putTask,
                                          POMNET_OPERATION_PKT   pPacket,
                                          POM_WSGROUP            pWSGroup);


//
// ProcessWorksetClear(...)
//
UINT ProcessWorksetClear(PUT_CLIENT putTask, POM_PRIMARY pomPrimary,
                                            POMNET_OPERATION_PKT  pPacket,
                                            POM_WSGROUP           pWSGroup,
                                            POM_WORKSET          pWorkset);


//
// ProcessObjectAdd(...)
//
UINT ProcessObjectAdd(PUT_CLIENT putTask,
                                         POMNET_OPERATION_PKT    pPacket,
                                         POM_WSGROUP             pWSGroup,
                                         POM_WORKSET            pWorkset,
                                         POM_OBJECTDATA         pData,
                                         POM_OBJECT *       ppObj);


//
// ProcessObjectMove(...)
//
void ProcessObjectMove(PUT_CLIENT putTask,
                                        POMNET_OPERATION_PKT    pPacket,
                                        POM_WORKSET            pWorkset,
                                        POM_OBJECT         pObjectRec);


//
// ProcessObjectDRU(...)
//
UINT ProcessObjectDRU(PUT_CLIENT putTask,
                                         POMNET_OPERATION_PKT  pPacket,
                                         POM_WSGROUP           pWSGroup,
                                         POM_WORKSET          pWorkset,
                                         POM_OBJECT       pObj,
                                         POM_OBJECTDATA      pData);


//
// ObjectAdd(...)
//
UINT ObjectAdd(PUT_CLIENT putTask, POM_PRIMARY pomPrimary,
                                  POM_WSGROUP             pWSGroup,
                                  POM_WORKSET            pWorkset,
                                  POM_OBJECTDATA         pData,
                                  UINT                updateSize,
                                  OM_POSITION             position,
                                  OM_OBJECT_ID     *  pObjectID,
                                  POM_OBJECT *   ppObj);




//
// WSGroupEventPost(...)
//
// This function posts the specified event to all local Clients registered
// with the workset group.  The <param2> parameter is the second parameter
// on the event to be posted.
//
//

UINT WSGroupEventPost(PUT_CLIENT    putTaskFrom,
                                       POM_WSGROUP         pWSGroup,
                                       BYTE             target,
                                       UINT             event,
                                       OM_WORKSET_ID       worksetID,
                                       UINT_PTR param2);


//
//
// This function is called by
//
// - OM_WorksetOpen, when a Client creates a new workset
//
// - ProcessLockRequest, when a lock request arrives for a workset we
//   don't yet know about
//
// - xx, when an OMNET_WORKSET_NEW message arrives.
//
// It creates the local data structures for the workset and posts an event
// to all local Clients registered with the workset group.
//
//

//
//
// WorksetCreate(...)
//
// This function creates a new workset in the specified workset group.
//
// It calls GenerateMessage, ProcessWorksetNew and QueueMessage.
//
//

UINT WorksetCreate(PUT_CLIENT putTask,
                                      POM_WSGROUP           pWSGroup,
                                      OM_WORKSET_ID         worksetID,
                                      BOOL                  fTemp,
                                      NET_PRIORITY          priority);


//
//
// WorksetEventPost(...)
//
// This function posts the specified event to all local Clients which have
// the workset open (at most 1 Client in R1.1).
//
// The <putTask> parameter is the putTask of the invoking task (and NOT
// the handle of the task to post the event to).
//
// The number of Clients the event was successfully posted to is returned
// in *pNumPosts, if pNumPosts is not NULL.  A caller which wishes to
// ignore the number of events posted can pass in NULL as the pNumPosts
// parameter.
//
//

UINT WorksetEventPost(PUT_CLIENT putTask,
                                       POM_WORKSET        pWorkset,
                                       BYTE             target,
                                       UINT             event,
                                       POM_OBJECT   pObj);


//
// WorksetDoClear(...)
//
void WorksetDoClear(PUT_CLIENT putTask,
                                     POM_WSGROUP        pWSGroup,
                                     POM_WORKSET       pWorkset,
                                     POM_PENDING_OP    pPendingOp);



//
//
// ProcessLockRequest(...)
//
// This function is called when ObMan receives an OMNET_LOCK_REQ message
// from another node.
//
// If we
//
// - have the workset locked already, or
//
// - are trying to lock the workset and our MCS user ID is greater than the
//   node which sent us the request,
//
// we deny the lock (i.e.  send back a negative OMNET_LOCK_REPLY).
//
// In all other cases, we grant the lock (i.e.  send back an affirmative
// OMNET_LOCK_REPLY).
//
// If we grant the lock to the remote node when we were trying to get it
// for ourselves, our attempt to lock the workset has failed so we call
// WorksetLockResult with a failure code.
//
//

void ProcessLockRequest(POM_PRIMARY pomPrimary,
                                     POM_DOMAIN     pDomain,
                                     POMNET_LOCK_PKT    pLockReqPkt);


//
//
// QueueLockReply(...)
//
// This function is called when we have decided to grant or deny a lock
// request received from another node.  It queues the appropriate response
// on ObMan's send queue.
//
//

void QueueLockReply(POM_PRIMARY pomPrimary,
                                   POM_DOMAIN           pDomain,
                                   OMNET_MESSAGE_TYPE       result,
                                   NET_CHANNEL_ID           destination,
                                   POMNET_LOCK_PKT          pLockReqPkt);


//
//
// QueueLockNotify(...)
//
// Queues a LOCK_NOTIFY command on the broadcast channel for the workset
// group, indicating that we have granted the lock to the <locker>.
//
//

void QueueLockNotify(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN          pDomain,
                                    POM_WSGROUP             pWSGroup,
                                    POM_WORKSET            pWorkset,
                                    NET_UID                 locker);


//
//
// ProcessLockReply(...)
//
// This function is called when ObMan receives an OMNET_LOCK_GRANT or
// OMNET_LOCK_DENY message from another node, in response to an
// OMNET_LOCK_REQ message we sent out earlier.
//
// The function removes this node from the list of expected respondents for
// this lock (if it is in the list).
//
// If the list is now empty, the lock has succeeded so WorksetLockResult is
// called.
//
// Otherwise, nothing else happens for the moment.
//
//

void ProcessLockReply(POM_PRIMARY pomPrimary,
                                   POM_DOMAIN       pDomain,
                                   NET_UID              sender,
                                   OM_CORRELATOR        correlator,
                                   OMNET_MESSAGE_TYPE   replyType);


//
// PurgeLockRequests(...)
//
void PurgeLockRequests(POM_DOMAIN      pDomain,
                                    POM_WSGROUP         pWSGroup);


//
//
// ProcessLockTimeout(...)
//
// This function is called when ObMan receives a lock timeout event.  It
// checks to see if any of the nodes from whom we are still expecting lock
// replies have in fact gone away; if they have, it removes them from the
// list of expected respondents.
//
// If this list is now empty, the lock has succeeded and WorksetLockResult
// is called.
//
// If the list is not empty, then another delayed lock timeout event is
// posted to ObMan, unless we have already had the maximum number of
// timeouts for this lock, in which case the lock has failed and
// WorksetLockResult is called.
//
//

void ProcessLockTimeout(POM_PRIMARY  pomPrimary,
                                     UINT          retriesToGo,
                                     UINT          callID);



//
//
// WorksetLockReq(...)
//
// This function is called
//
// - by OM_WorksetLockReq, when a Client wants to lock a workset
//
// - by LockObManControl, when ObMan wants to lock workset #0 in
//   ObManControl.
//
// The function decides whether the lock can be granted or refused
// synchronously, and if so calls WorksetLockResult.  If not, it posts an
// OMINT_EVENT_LOCK_REQ event to the ObMan task, which results in the
// ProcessLocalLockRequest function being called later.
//
// The <hWSGroup> parameter is the workset group handle which will be
// included in the eventual OM_WORKSET_LOCK_CON event.  Its value is not
// used in the function; when this function is called in the ObMan task
// this value is set to zero (since the ObMan task doesn't use workset
// group handles).
//
// On successful completion, the <pCorrelator> parameter points to the
// correlator value which will be included in the eventual
// OM_WORKSET_LOCK_CON event.
//
//

void WorksetLockReq(PUT_CLIENT putTask, POM_PRIMARY pomPrimary,
                                     POM_WSGROUP       pWSGroup,
                                     POM_WORKSET      pWorkset,
                                     OM_WSGROUP_HANDLE  hWSGroup,
                                     OM_CORRELATOR    * pCorrelator);


//
//
// WorksetLockResult(...)
//
// This function is called when we have finished processing a request to
// obtain a workset lock.  The function sets the workset state accordingly,
// posts an appropriate event to the task which requested the lock, and
// frees the lock request control block.
//
//
void WorksetLockResult(PUT_CLIENT putTask,
                                        POM_LOCK_REQ *   ppLockReq,
                                        UINT             result);


//
//
// BuildNodeList(...)
//
// This function builds a list of the remote nodes which are registered
// with the workset group referenced in the lock request CB passed in.
//
//

UINT BuildNodeList(POM_DOMAIN pDomain, POM_LOCK_REQ pLockReq);


//
//
// HandleMultLockReq(...)
//
// This function searches the global list of pending lock requests (stored
// in the root data structure) for any lock requests matching the Domain,
// workset group and workset specified.
//
//

void HandleMultLockReq(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN         pDomain,
                                    POM_WSGROUP            pWSGroup,
                                    POM_WORKSET           pWorkset,
                                    UINT               result);


//
//
// FindLockReq(...)
//
// This function searches the global list of pending lock requests (stored
// in the root data structure) for a lock request that matches the Domain,
// workset group and workset specified.
//
// If found, a pointer to the lock request is returned in <ppLockReq>.
//
// It can search for a primary lock request if needed
//
//

void FindLockReq(POM_DOMAIN         pDomain,
                              POM_WSGROUP            pWSGroup,
                              POM_WORKSET           pWorkset,
                              POM_LOCK_REQ *     ppLockreq,
                              BYTE               lockType);


//
// ReleaseAllNetLocks(...)
//
void ReleaseAllNetLocks(POM_PRIMARY pomPrimary,
                                     POM_DOMAIN      pDomain,
                                     OM_WSGROUP_ID       wsGroupID,
                                     NET_UID             userID);

//
//
// ProcessUnlock(...)
//
// This function is called when an OMNET_UNLOCK message is received from
// the network.  The function is a wrapper which just derives a workset
// pointer and calls ProcessUnlock (above).
//
//

void ProcessUnlock(POM_PRIMARY pomPrimary,
                                POM_WORKSET        pWorkset,
                                NET_UID             sender);

//
// WorksetUnlock(...)
//
void WorksetUnlock(PUT_CLIENT putTask, POM_WSGROUP     pWSGroup,
                                    POM_WORKSET    pWorkset);

//
// WorksetUnlockLocal(...)
//
void WorksetUnlockLocal(PUT_CLIENT putTask, POM_WORKSET     pWorkset);



//
//
// ObjectDoDelete(...)
//
// This function deletes an object in a workset.  It is called by
//
// - OM_ObjectDeleteConfirm, when a Client confirms the deletion of an
//   object.
//
// - WorksetDoClear, to delete each individual object
//
// - ProcessObjectDelete when ObMan receives a Delete message from the
//   network for an object in a workset which no local Clients have open.
//
//

void ObjectDoDelete(PUT_CLIENT putTask,
                                     POM_WSGROUP        pWSGroup,
                                     POM_WORKSET       pWorkset,
                                     POM_OBJECT    pObj,
                                     POM_PENDING_OP    pPendingOp);


//
//
// ObjectDRU(...)
//
// This function generate, processes and queues a message of type DELETE,
// REPLACE or UPDATE (as specified by <type>).
//
//
UINT ObjectDRU(PUT_CLIENT putTask,
                                  POM_WSGROUP             pWSGroup,
                                  POM_WORKSET            pWorkset,
                                  POM_OBJECT         pObj,
                                  POM_OBJECTDATA            pData,
                                  OMNET_MESSAGE_TYPE      type);


//
//
// ObjectRead(...)
//
// This function converts an object handle to a pointer to the object data.
// An invalid handle causes an assertion failure.
//
//

void ObjectRead(POM_CLIENT pomClient,
                            POM_OBJECT pObj,
                             POM_OBJECTDATA *    ppData);


//
// ObjectInsert(...)
//
void ObjectInsert(POM_WORKSET pWorkset,
                               POM_OBJECT   pObj,
                               OM_POSITION       position);


//
// ObjectDoMove(...)
//
void ObjectDoMove(POM_OBJECT   pObjToMove,
                               POM_OBJECT   pOtherObjectRec,
                               OM_POSITION       position);


//
// ObjectDoUpdate(...)
//
void ObjectDoUpdate(PUT_CLIENT putTask,
                                    POM_WSGROUP      pWSGroup,
                                     POM_WORKSET       pWorkset,
                                     POM_OBJECT    pObj,
                                     POM_PENDING_OP    pPendingOp);


//
// ObjectDoReplace(...)
//
void ObjectDoReplace(PUT_CLIENT putTask,
                                    POM_WSGROUP      pWSGroup,
                                      POM_WORKSET       pWorkset,
                                      POM_OBJECT    pObj,
                                      POM_PENDING_OP    pPendingOp);


//
// ObjectIDToPtr(...)
//
UINT ObjectIDToPtr(POM_WORKSET pWorkset,
                                        OM_OBJECT_ID              objectID,
                                        POM_OBJECT *        ppObj);



//
// FindPendingOp(...)
//
void FindPendingOp(POM_WORKSET             pWorkset,
                                    POM_OBJECT          pObj,
                                    OM_OPERATION_TYPE        type,
                                    POM_PENDING_OP *    ppPendingOp);


//
// WSGRecordFind(...)
//
void WSGRecordFind(POM_DOMAIN pDomain, OMWSG wsg, OMFP fpHandler,
                                    POM_WSGROUP *  ppWSGroup);


//
// DeterminePriority(...)
//
void DeterminePriority(NET_PRIORITY *   pPriority,
                                    POM_OBJECTDATA          pData);


//
// RemoveClientFromWSGList(...)
//
// The second parameter is the putTask of the Client to be deregistered.
// It is NOT (well, not necessarily) the putTask of the calling task, and
// for this reason (to avoid it being used as such) is passed as a 32-bit
// integer.
//
void RemoveClientFromWSGList(
                                    PUT_CLIENT putUs,
                                    PUT_CLIENT putTask,
                                              POM_WSGROUP    pWSGroup);


//
// AddClientToWSGList(...)
//
UINT AddClientToWSGList(PUT_CLIENT putTask,
                                       POM_WSGROUP             pWSGroup,
                                       OM_WSGROUP_HANDLE    hWSGroup,
                                       UINT         mode);


//
// AddClientToWsetList(...)
//
UINT AddClientToWsetList(PUT_CLIENT putTask,
                                    POM_WORKSET           pWorkset,
                                    OM_WSGROUP_HANDLE   hWSGroup,
                                    UINT            mode,
                                    POM_CLIENT_LIST * pClientListEntry);


//
// PostWorksetNewEvents(...)
//
UINT PostWorksetNewEvents(PUT_CLIENT putFrom,
                                       PUT_CLIENT       putTask,
                                       POM_WSGROUP      pWSGroup,
                                       OM_WSGROUP_HANDLE hWSGroup);


//
//
// QueueUnlock(...)
//
// This function queues a workset unlock packet for sending to the
// specified destination.
//
//

UINT QueueUnlock(PUT_CLIENT putTask,
                                    POM_DOMAIN      pDomain,
                                    OM_WSGROUP_ID       wsGroupID,
                                    OM_WORKSET_ID       worksetID,
                                    NET_UID             destination,
                                    NET_PRIORITY        priority);

//
// PurgeReceiveCBs(...)
//
void PurgeReceiveCBs(POM_DOMAIN        pDomain,
                                  NET_CHANNEL_ID        channel);


//
// FreeSendInst()
//
void FreeSendInst(POM_SEND_INST pSendInst);


//
// SetPersonData(...)
//
UINT SetPersonData(POM_PRIMARY   pomPrimary,
                                      POM_DOMAIN   pDomain,
                                      POM_WSGROUP      pWSGroup);


//
//
// FindInfoObject(...)
//
// This function searches workset #0 in the ObManControl workset group in
// the specified Domain for a matching info object.
//
// The match is performed as follows:
//
// - if functionProfile and wsGroupName are not NULL, the first object
//   matching both is returned
//
// - if functionProfile is not NULL but wsGroupName is, the first object
//   matching functionProfile is returned
//
// - if functionProfile is NULL, the first object matching wsGroupID is
//   returned.
//
//

void FindInfoObject(POM_DOMAIN         pDomain,
                                     OM_WSGROUP_ID      wsGroupID,
                                     OMWSG              wsg,
                                     OMFP               fpHandler,
                                     POM_OBJECT *  ppInfoObjectRec);


//
//
// FindPersonObject(...)
//
// This function searches the specified workset in ObManControl looking for
// a registration object which has
//
// - the same user ID as <userID>, if <searchType> == FIND_THIS
//
// - a different user ID from <userID>, if <searchType> == FIND_OTHERS.
//
//

void FindPersonObject(POM_WORKSET          pOMCWorkset,
                                       NET_UID               userID,
                                       UINT              searchType,
                                       POM_OBJECT * ppRegObjectRec);

#define FIND_THIS          1
#define FIND_OTHERS        2

//
// ProcessOMCWorksetNew(...)
//
void ProcessOMCWorksetNew(POM_PRIMARY pomPrimary, OM_WSGROUP_HANDLE hWSGroup,
                                       OM_WORKSET_ID      worksetID);


//
// ProcessOMCObjectEvents(...)
//
void ProcessOMCObjectEvents(POM_PRIMARY pomPrimary,
                                         UINT            event,
                                        OM_WSGROUP_HANDLE   hWSGroup,
                                         OM_WORKSET_ID      worksetID,
                                         POM_OBJECT     pObj);


//
// GeneratePersonEvents(...)
//
void GeneratePersonEvents(POM_PRIMARY pomPrimary,
                                       UINT            event,
                                       POM_WSGROUP        pWSGroup,
                                       POM_OBJECT   pObj);


//
// PostAddEvents(...)
//
UINT PostAddEvents(PUT_CLIENT putTaskFrom,
                                      POM_WORKSET       pWorkset,
                                    OM_WSGROUP_HANDLE   hWSGroup,
                                      PUT_CLIENT        putTaskTo);


//
// RemovePersonObject(...)
//
void RemovePersonObject(POM_PRIMARY pomPrimary,
                                     POM_DOMAIN         pDomain,
                                     OM_WSGROUP_ID          wsGroupID,
                                     NET_UID                detachedUserID);


//
// RemoveInfoObject(...)
//
void RemoveInfoObject(POM_PRIMARY pomPrimary, POM_DOMAIN   pDomain,
                                       OM_WSGROUP_ID    wsGroupID);




//
//
// DEBUG ONLY FUNCTIONS
//
// These functions are debug code only - for normal compilations, the
// declarations are #defined to nothing and the definitions are
// preprocessed out altogether.
//
//

#ifndef _DEBUG

#define CheckObjectCount(x, y)
#define CheckObjectOrder(x)
#define DumpWorkset(x, y)

#else // _DEBUG

//
//
// CheckConstants(...)
//
// The ObMan code relies on certain assumptions about the sizes and formats
// of various data structures, and the values of certain constants.
//
//
// The OMNET_OPERATION_PKT type has two one-byte fields, <position> and
// <flags>, which are used to hold
//
// - a NET_PRIORITY value which indicates the priority for the
//   workset for WORKSET_NEW/WORKSET_CATCHUP messages, and
//
// - a UINT (the number of bytes being acknowledged) in the case
//   of a DATA_ACK message.
//
// GenerateOpMessage and AckData cast the <position> field to a two-byte
// quantity for this purpose.  Therefore, it is necessary that these two
// fields exist, that they are adjacent and that the <position> one
// comes first.
//
// In addition, since the priority information is a NET_PRIORITY, we
// must ensure that a NET_PRIORITY is indeed two bytes long.
//
//
// ASSERT((sizeof(NET_PRIORITY) == (2 * sizeof(BYTE))));
//
// ASSERT((offsetof(OMNET_OPERATION_PKT, position) + 1 ==
//            offsetof(OMNET_OPERATION_PKT, flags)));
//
//
// In many places, for-loops use workset IDs as the loop variable and
// OM_MAX_WORKSETS_PER_WSGROUP as the end condition.  To avoid infinite
// loops, this constant must be less than 256:
//
// ASSERT((OM_MAX_WORKSETS_PER_WSGROUP < 256));
//
// The OMC WSG has one workset for each WSG in the Domain.  Since the
// number of worksets per WSG is limited, the # of WSGs per Domain is
// limited in the same way:
//
// ASSERT(OM_MAX_WSGROUPS_PER_DOMAIN <= OM_MAX_WORKSETS_PER_WSGROUP);
//


//
//
// CheckObjectCount(...)
//
// This function counts the number of non-deleted objects in the specified
// workset and compares this against the <numObjects> field of the workset
// record.  A mismatch causes an assertion failure.
//
//
void CheckObjectCount(POM_WSGROUP        pWSGroup,
                                   POM_WORKSET       pWorkset);

//
// CheckObjectOrder(...)
//
void CheckObjectOrder(POM_WORKSET pWorkset);


#endif // _DEBUG


//
//
// WORKSET OPEN/CLOSE BITFIELD MANIPULATION MACROS
//
// ObMan maintains one usage record for each workset group a Client is
// registered with.  One of the fields of the usage record is an 32-byte
// bitfield which is interpreted as an array of 256 booleans, indicating
// whether a Client has the corresponding workset open.
//
// These macros use the EXTRACT_BIT, SET_BIT and CLEAR_BIT macros to set and clear the bit
// for <worksetID> in the <worksetOpenFlags> bitfield of the usage record.
//
//

BOOL __inline WORKSET_IS_OPEN(POM_USAGE_REC pUsageRec, OM_WORKSET_ID worksetID)
{
    return((pUsageRec->worksetOpenFlags[worksetID / 8] & (0x80 >> (worksetID % 8))) != 0);
}

void __inline WORKSET_SET_OPEN(POM_USAGE_REC pUsageRec, OM_WORKSET_ID worksetID)
{
    pUsageRec->worksetOpenFlags[worksetID / 8] |= (0x80 >> (worksetID % 8));
}

void __inline WORKSET_SET_CLOSED(POM_USAGE_REC pUsageRec, OM_WORKSET_ID worksetID)
{
    pUsageRec->worksetOpenFlags[worksetID / 8] &= ~(0x80 >> (worksetID % 8));
}


//
//
// ReleaseAllLocks(...)
//
// This function releases all the locks held by a particular Client for a
// particular workset.  In R1.1, this is at most one lock (the workset
// lock) but if/when object locking is supported, this function will also
// release all object locks held.
//
// This function is closed when a Client is closing a workset.
//
//

void ReleaseAllLocks(POM_CLIENT       pomClient,
                                  POM_USAGE_REC   pUsageRec,
                                  POM_WORKSET    pWorkset);


//
//
// ReleaseAllObjects(...)
//
// This function releases all the objects held by a particular Client in a
// particular workset.
//
// This function is called when a Client closes a workset.
//
void ReleaseAllObjects(POM_USAGE_REC pUsageRec, POM_WORKSET pWorkset);


//
//
// ConfirmAll(...)
//
// This function confirms any pending operations for the workset specified.
//
// The function is called when a Client closes a workset.
//
// Since this function may call WorksetDoClear, the caller must hold the
// workset group mutex.
//
//

void ConfirmAll(POM_CLIENT       pomClient,
                             POM_USAGE_REC   pUsageRec,
                             POM_WORKSET    pWorkset);


//
//
// DiscardAllObjects(...)
//
// This function discards any objects allocated for the specified Client
// for the specified workset but so far unused.
//
// The function is called when a Client closes a workset.
//
//
void DiscardAllObjects(POM_USAGE_REC   pUsageRec,
                                    POM_WORKSET    pWorkset);


//
//
// RemoveFromUnusedList
//
// This function removes an object (specified by a pointer to the object)
// from the Client's list of unused objects.  It is called by
//
// - OM_ObjectAdd, OM_ObjectUpdate and OM_ObjectReplace when a
//   Client inserts an object into a workset, or
//
// - OM_ObjectDiscard, when a Client discards an unused object.
//
//

void RemoveFromUnusedList(POM_USAGE_REC pUsageRec, POM_OBJECTDATA pData);


//
//
// OM_ObjectAdd(...)
//
// This function adds an object to a worksets, in the specified position.
//
// Although it is not strictly an API function, it performs full parameter
// validation and could be externalised easily.
//
//

UINT OM_ObjectAdd(POM_CLIENT           pomClient,
                                 OM_WSGROUP_HANDLE hWSGroup,
                                 OM_WORKSET_ID       worksetID,
                                 POM_OBJECTDATA *   ppData,
                                 UINT            updateSize,
                                 POM_OBJECT *   ppObj,
                                 OM_POSITION         position);


//
//
// OM_ObjectMove(...)
//
// This function moves an object to the start or end of a workset.  It is
// called by OM_ObjectMoveFirst and OM_ObjectMoveLast.
//
// Although it is not strictly an API function, it performs full parameter
// validation and could be externalised easily.
//
//

UINT OM_ObjectMove(POM_CLIENT           pomClient,
                                  OM_WSGROUP_HANDLE hWSGroup,
                                  OM_WORKSET_ID       worksetID,
                                  POM_OBJECT    pObj,
                                  OM_POSITION         position);


//
//
// ValidateParamsX(...)
//
// These functions are used to validate parameters and convert them to
// various pointers, as follows:
//
// ValidateParams2 - checks pomClient, hWSGroup
//                 - returns pUsageRec, pWSGroup
//
// ValidateParams3 - checks pomClient, hWSGroup, worksetID,
//                 - returns pUsageRec, pWorkset
//
//                   Note: also asserts that workset is open
//
// ValidateParams4 - checks pomClient, hWSGroup, worksetID, pObj
//
// Each of the functions uses DCASSERT to bring down the calling task if an
// invalid parameter is detected.
//
//

__inline void ValidateParams2(POM_CLIENT          pomClient,
                                  OM_WSGROUP_HANDLE hWSGroup,
                                  UINT          requiredMode,
                                  POM_USAGE_REC  *  ppUsageRec,
                                  POM_WSGROUP       *  ppWSGroup)
{
    ValidateOMS(pomClient);
    ASSERT(ValidWSGroupHandle(pomClient, hWSGroup));

    *ppUsageRec = pomClient->apUsageRecs[hWSGroup];
    ValidateUsageRec(*ppUsageRec);
    ASSERT(requiredMode & (*ppUsageRec)->mode);

    *ppWSGroup = (*ppUsageRec)->pWSGroup;
    ValidateWSGroup(*ppWSGroup);
}


__inline void ValidateParams3(POM_CLIENT                pomClient,
                                  OM_WSGROUP_HANDLE     hWSGroup,
                                  OM_WORKSET_ID         worksetID,
                                  UINT                  requiredMode,
                                  POM_USAGE_REC     *   ppUsageRec,
                                  POM_WORKSET      *    ppWorkset)
{
    POM_WSGROUP pWSGroup;

    ValidateParams2(pomClient, hWSGroup, requiredMode, ppUsageRec, &pWSGroup);

    ASSERT(WORKSET_IS_OPEN(*ppUsageRec, worksetID));

    *ppWorkset = pWSGroup->apWorksets[worksetID];
    ValidateWorkset(*ppWorkset);
}


__inline void ValidateParams4(POM_CLIENT                pomClient,
                                  OM_WSGROUP_HANDLE     hWSGroup,
                                  OM_WORKSET_ID         worksetID,
                                  POM_OBJECT            pObj,
                                  UINT                  requiredMode,
                                  POM_USAGE_REC     *   ppUsageRec,
                                  POM_WORKSET      *    ppWorkset)
{
    ValidateParams3(pomClient, hWSGroup, worksetID, requiredMode, ppUsageRec,
        ppWorkset);

    ValidateObject(pObj);
    ASSERT(!(pObj->flags & DELETED));
}



//
//
// SetUpUsageRecord(...)
//
UINT SetUpUsageRecord(POM_CLIENT             pomClient,
                                     UINT           mode,
                                     POM_USAGE_REC* ppUsageRec,
                                     OM_WSGROUP_HANDLE * phWSGroup);


//
// FindUnusedWSGHandle()
//
UINT FindUnusedWSGHandle(POM_CLIENT pomClient, OM_WSGROUP_HANDLE * phWSGroup);


//
//
// ObjectRelease(...)
//
// This function releases the specified Client's hold on the the specified
// object and removes the relevant entry from the Client's objects-in-use
// list.
//
// If <pObj> is NULL, the function releases the first object held by
// this Client in the specified workset, if any.  If there are none, the
// function returns OM_RC_OBJECT_NOT_FOUND.
//
//

UINT ObjectRelease(POM_USAGE_REC             pUsageRec,
                                  OM_WORKSET_ID             worksetID,
                                  POM_OBJECT            pObj);


//
//
// WorksetClearPending(...)
//
// Look for a CLEAR_IND which is outstanding for the given workset which,
// when confirmed, will cause the given object to be deleted.
//
// Returns TRUE if such a CLEAR_IND is outstanding, FALSE otherwise.
//
//

BOOL WorksetClearPending(POM_WORKSET pWorkset, POM_OBJECT pObj);




UINT OM_Register(PUT_CLIENT putTask, OMCLI omClient, POM_CLIENT * ppomClient);

//
//
//   Description:
//
// This function registers a DC-Groupware task as an ObMan Client.  A task
// must be a registered ObMan Client in order to call any of the other API
// functions.
//
// On successful completion, the value at <ppomClient> is this Client's ObMan
// handle, which must be passed as a parameter to all other API functions.
//
// This function registers an event handler and an exit procedure for the
// Client, so Clients must have previously registered fewer than the maximum
// number of Utility Service event handlers and exit procedures.
//
// If the are too many Clients already registered with ObMan, an error is
// returned.
//
//   Ensuing Events:
//
// None
//
//   Return Codes
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_TOO_MANY_CLIENTS
//
//

void OM_Deregister(POM_CLIENT * ppomCient);
void CALLBACK OMSExitProc(LPVOID pomClient);

//
//
//   Description:
//
// This function deregisters an ObMan Client.
//
// On completion, the ObMan handle which the Client was using becomes
// invalid and the value at <ppomClient> is set to NULL to prevent the task
// from using it again.
//
// This function deregisters the Client from any workset groups with which
// it was registered.
//
//   Ensuing Events:
//
// None
//
//   Return Codes
//
// None
//
//

UINT OM_WSGroupRegisterPReq(POM_CLIENT  pomClient,
                                              UINT         call,
                                              OMFP          fpHandler,
                                              OMWSG         wsg,
                                              OM_CORRELATOR *        pCorrelator);

//
//
//   Description:
//
// This is an asynchronous function which requests that ObMan register a
// Client with a particular workset group for PRIMARY access.  The workset
// group is determined by the following:
//
// - <call> is the DC-Groupware Call which contains/is to contain the
//          workset group (or OM_NO_CALL if the workset group is/is to
//          be a local workset group)
//
// - <functionProfile> is the Function Profile for the workset group
//
// - <wsGroupName> is the name of the workset group.
//
// The <pomClient> parameter is the ObMan handle returned by the OM_Register
// function.
//
// If a Client wishes to create a new, or register with an existing, workset
// group which exists only on the local machine, the value OM_NO_CALL should
// be specified for the <call> parameter.  Workset groups created in this
// way for purely local use may be subsequently transferred into a call by
// invoking OM_WSGroupMoveReq at some later time.
//
// If this function completes successfully, the Client will subsequently
// receive an OM_WSGROUP_REGISTER_CON event indicating the success or
// failure of the registration.
//
// Registering with a workset group is a prerequisite to opening any of its
// worksets.
//
// If no workset group with this name and function profile exists in the
// specified call (or locally, if OM_NO_CALL specified), a new, empty
// workset group is created and assigned <wsGroupName> as its name.  This
// name must be a valid workset group name.
//
// If the workset group already exists in the Call, its contents are copied
// from another node.  This data transfer is made at low priority (note that
// subsequent receipt of the OM_WSGROUP_REGISTER_CON event does not indicate
// that this data transfer has completed).
//
// If there are worksets existing in the workset group, the Client will
// receive one or more OM_WORKSET_NEW_IND events after receiving the
// OM_WSGROUP_REGISTER_CON event.
//
// Note also that the contents of the workset group may be copied to this
// node in any order.  Therefore, if objects in a workset reference other
// objects, the Client should not assume that the referenced object is
// present locally once the reference arrives.
//
// Clients registered for primary access to a workset group have full read
// and write access to the workset group and have a responsilibity to
// confirm destructive operations (such as workset clear and object delete,
// update and replace operations), as described in the relevant sections
// below.
//
// At most one Client per node may be registered with a given workset group
// for primary access.  If a second Client attempts to register for primary
// access, OM_RC_TOO_MANY_CLIENTS is returned asynchronously via the
// OM_WSGROUP_REGISTER_CON event.
//
// On successful completion of the function, the return parameter
// <pCorrelator> points to a value which may be used by the Client to
// correlate this call with the event it generates.  Notification of a
// successful registration will contain a workset group handle which the
// Client must uses subsequently when invoking other ObMan functions
// relating to this workset group.
//
// If the maximum number of workset groups in concurrent use per call has
// been reached, the OM_RC_TOO_MANY_WSGROUPS error is returned
// asynchronously.  If the maximum number of workset groups in use by one
// Client is reached, OM_RC_NO_MORE HANDLES is returned synchronously.  If
// ObMan cannot create a new workset group for any other reason, the
// OM_RC_CANNOT_CREATE_WSG error is returned (synchronously or
// asynchronously).
//
// Note that separate DC-Groupware tasks must each register independently
// with the workset groups they wish to use, as workset group handles may
// not be passed between tasks.
//
//   Ensuing Events:
//
// Invoking this function will cause the OM_WSGROUP_REGISTER_CON event to be
// posted to the invoking Client.
//
// If ObMan is forced at some later stage to move the workset group out of
// the call for which it was intended (usually at call end time), the Client
// will receive an OM_WSGROUP_MOVE_IND event.
//
// When a Client has successfully registered with a workset group, it will
// receive OM_PERSON_JOINED_IND, OM_PERSON_LEFT_IND and
// OM_PERSON_DATA_CHANGED_IND events as primaries (including the calling
// Client) register and deregister from the workset group and change their
// person data.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_NO_MORE_HANDLES
//
//

UINT OM_WSGroupRegisterS(POM_CLIENT                 pomClient,
                                   UINT             call,
                                   OMFP             fpHandler,
                                   OMWSG            wsg,
                                OM_WSGROUP_HANDLE * phWSGroup);

//
//
//   Description:
//
// This is a synchronous function which requests that ObMan register a
// Client with a particular workset group for SECONDARY access.  The workset
// group is determined by the following:
//
// - <call> is the DC-Groupware call which contains the workset group (or
//          OM_NO_CALL if the workset group is a local workset group)
//
// - <functionProfile> is the Function Profile of the workset group
//
// - <wsGroupName> is the name of the workset group.
//
// The <pomClient> parameter is the ObMan handle returned by the OM_Register
// function.
//
// A Client may only register for secondary access for a workset group when
// there is already a local Client fully registered for primary access to
// that workset group.  If there is no such local primary, OM_RC_NO_PRIMARY
// is returned.
//
// If there are worksets existing in the workset group, the Client will
// receive one or more OM_WORKSET_NEW_IND events after this function
// completes.
//
// Registering for secondary access to a workset group gives a Client the
// same access privileges as a primary Client except for:
//
// - creating worksets
//
// - moving workset groups into/out of Calls
//
// - locking worksets and objects
//
// In addition, secondary Clients of a workset group will receive events
// relating to the workset group in the same way as primary Clients.
// However, the following important difference applies: secondary Clients
// will receive notification of object deletes, updates and replaces AFTER
// the associated operations have taken place (as opposed to primary
// Clients, who are informed BEFORE action is taken and must invoke the
// relevant confirmation function).
//
// To highlight this difference, these events have a primary and a secondary
// variety:
//
//
//
//    Primary                               Secondary
//
//  - OM_WORKSET_CLEAR_IND                  OM_WORKSET_CLEARED_IND
//  - OM_OBJECT_DELETE_IND                  OM_OBJECT_DELETED_IND
//  - OM_OBJECT_REPLACE_IND                 OM_OBJECT_REPLACED_IND
//  - OM_OBJECT_UPDATE_IND                  OM_OBJECT_UPDATED_IND
//
//
//
// Several Clients per node, up to a defined limit, may be registered with
// a given workset group for secondary access.  Once this limit is reached,
// OM_RC_TOO_MANY_CLIENTS is returned.
//
// On successful completion of the function, the return parameter
// <phWSGoup> points to a workset group handle which the Client must uses
// subsequently when invoking other ObMan functions relating to this
// workset group.
//
// Note that separate DC-Groupware tasks must each register independently
// with the workset groups they wish to use, as workset group handles may
// not be passed between tasks.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_NO_MORE_HANDLES
//  OM_RC_NO_PRIMARY
//  OM_RC_TOO_MANY_CLIENTS
//
//

UINT OM_WSGroupMoveReq(POM_CLIENT           pomClient,
                            OM_WSGROUP_HANDLE hWSGroup,
                                          UINT            callID,
                                          OM_CORRELATOR *          pCorrelator);

//
//
//   Description:
//
// This function requests that ObMan move a local workset group previously
// created as a local workset group (i.e.  created specifying the OM_NO_CALL
// for the Call ID parameter) into the DC-Groupware Call identified by
// <callID>.  If the move is successful, the workset group becomes available
// at all nodes in the Call.
//
// The workset group to move is specified by <hWSGroup>, which must be a
// valid workset group handle.
//
// If the function completes successfully, the OM_WSGROUP_MOVE_CON event is
// posted to the Client when the attempt to move the workset group into the
// Call has completed.  This event indicates whether the attempt was
// successful.
//
// If there is already a (different) workset group in the specified Call
// with the same name and Function Profile, this function will fail
// asynchronously.
//
//   Ensuing Events:
//
// Invoking this function causes the OM_WSGROUP_MOVE_CON to be posted to the
// invoking Client.  If the move is successful, the OM_WSGROUP_MOVE_IND
// event is also posted to all local Clients which are registered with the
// workset group, including the invoking Client.
//
//   Return Codes:
//
//  0 (== OK)
//  OM_RC_ALREADY_IN_CALL
//  Utility Service return codes
//
//

void OM_WSGroupDeregister(POM_CLIENT pomClient, OM_WSGROUP_HANDLE * phWSGroup);

//
//
//   Description:
//
// This function deregisters the Client from the workset group specified by
// the handle at <phWSGroup>.  Any worksets which the Client had open in
// the workset group are closed (thereby releasing all locks), and the
// Client will receive no more events relating to this workset group.
//
// This call may cause the local copy of the workset group and its worksets
// to be discarded; in this sense, this function is destructive.
//
// This call sets the value at <phWSGroup> to NULL to prevent the Client
// using this handle in further calls to ObMan.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_WorksetOpenPReq(POM_CLIENT            pomClient,
                               OM_WSGROUP_HANDLE     hWSGroup,
                                  OM_WORKSET_ID         worksetID,
                                  NET_PRIORITY          priority,
                                  BOOL              fTemp,
                                  OM_CORRELATOR *            pCorrelator);

UINT OM_WorksetOpenS(POM_CLIENT               pomClient,
                                        OM_WSGROUP_HANDLE   hWSGroup,
                                        OM_WORKSET_ID       worksetID);

//
//
//   Description:
//
// These functions open a specified workset for a Client.
//
// OM_WorksetOpenPReq is an asynchronous function which will create the
// workset if it does not exist.  Only primary Clients of this workset group
// may call this function.
//
// OM_WorksetOpenS is a synchronous function which will return
// OM_RC_WORKSET_DOESNT_EXIST if the workset does not exist.  Only secondary
// Clients of this workset group may call this function.
//
// In the asynchronous (primary) case, when ObMan has opened the workset for
// the Client, or failed to do so, it posts an OM_WORKSET_OPEN_CON event to
// the Client indicating success or the reason for failure.  This event will
// contain the correlator value returned in <pCorrelator> by this function.
//
// If this action results in the creation of a new workset, <priority> will
// specify the MCS priority at which data relating to the workset will be
// transmitted.  Note that NET_TOP_PRIORITY is reserved for ObMan's private
// use and must not be specified as the <priority> parameter.
//
// If OM_OBMAN_CHOOSES_PRIORITY is specified as the <priority> parameter,
// ObMan will prioritise data transfers according to size.
//
// If the workset already exists, the Client will receive an
// OM_OBJECT_ADD_IND event for each object that is in the workset when it is
// opened.
//
// Opening a workset is a prerequisite to performing any operations on it or
// its contents.  Once a Client has opened a workset it will receive events
// when changes are made to the workset or its contents.
//
// If this Client has already opened this workset,
// OM_RC_WORKSET_ALREADY_OPEN is returned.  No 'use count' of opens is
// maintained, so the first OM_WorksetClose will close the workset,
// irrespective of how many times it has been opened.
//
//   Ensuing Events:
//
// Invoking OM_WorksetOpenPReq causes the OM_WORKSET_OPEN_CON event to be
// posted to the invoking Client.
//
// If this action results in the creation of a new workset, an
// OM_WORKSET_NEW_IND is posted to all Clients which are registered with the
// workset group, including the invoking Client.
//
// In both the primary and secondary cases, if the workset contains any
// objects, an OM_OBJECT_ADD_IND event will be posted to the Client for each
// one.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_DOESNT_EXIST
//  OM_RC_WORKSET_ALREADY_OPEN
//
//

#define OM_OBMAN_CHOOSES_PRIORITY   (NET_INVALID_PRIORITY)


void OM_WorksetClose(POM_CLIENT pomClient,
                                      OM_WSGROUP_HANDLE hWSGroup,
                                      OM_WORKSET_ID           worksetID);

//
//
//   Description:
//
// This function closes the workset in <hWSGroup> identified by <worksetID>.
// The Client may no longer access this workset and will receive no more
// events relating to it.  ObMan will however continue to update the
// contents of the workset in the background; in this sense, this function
// is non-destructive.
//
// When a Client closes a workset, ObMan automatically releases the
// following resources:
//
// - any locks the Client has relating to this workset
//
// - any objects which the Client had been reading or had allocated
//   for writing in the workset.
//
// If indication events which require a Confirm function to be invoked have
// been received by the Client but not yet confirmed, these Confirms are
// implicitly executed by ObMan AND THE CLIENT MUST NOT SUBSEQUENTLY ATTEMPT
// TO CONFIRM THEM.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

void   OM_WorksetFlowQuery(POM_CLIENT           pomClient,
                                   OM_WSGROUP_HANDLE    hWSGroup,
                                   OM_WORKSET_ID       worksetID,
                                   UINT*           pBytesOutstanding);

//
//
//   Description:
//
// A Client calls this function whenever it wishes to discover the size of
// the backlog of data relating to the workset identified by <hWSGroup> and
// <worksetID>.
//
// The "backlog" is defined as the total number of bytes of object data
// which ObMan has been given by its local Clients and which have not yet
// been acknowledged by all remote nodes where there are Clients registered
// with the workset group.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_WorksetLockReq(POM_CLIENT               pomClient,
                                   OM_WSGROUP_HANDLE hWSGroup,
                                          OM_WORKSET_ID         worksetID,
                                          OM_CORRELATOR *       pCorrelator);

//
//
//   Description:
//
// This is an asynchronous function which requests a lock for the workset in
// <hWSGroup> identified by <worksetID>.  When ObMan has processed the lock
// request, it will send an OM_WORKSET_LOCK_CON event to the Client
// indicating success or the reason for failure.
//
// Holding a workset lock prevents other Clients from making any changes to
// the workset or any of its objects.  Specifically, the following functions
// are prohibited:
//
// - locking the same workset
//
// - locking an object in the workset
//
// - moving an object within the workset
//
// - adding an object to the workset
//
// - deleting an object from the workset
//
// - updating or replacing an object in the workset.
//
// Locking a workset does not prevent other Clients from reading its
// contents.
//
// The function will cause an assertion failure if the Client requesting the
// lock already holds or has requested a lock which is equal to or after
// this one in the Universal Locking Order.
//
// On successful completion of the function, the value at <pCorrelator> is a
// value which the Client can use to correlate the subsequent
// OM_OBJECT_LOCK_CON event with this request.
//
// A Client must release the lock when it no longer needs it, using the
// OM_WorksetUnlock function.  Locks will be automatically released when a
// Client closes the workset or deregisters from the workset group.
//
// Only primary Clients of a workset group may call this function.
//
//   Ensuing Events:
//
// Invoking this function will cause the OM_WORKSET_LOCK_CON event to be
// posted to the invoking Client at some later time.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//
//

void OM_WorksetUnlock(POM_CLIENT               pomClient,
                                       OM_WSGROUP_HANDLE hWSGroup,
                                       OM_WORKSET_ID           worksetID);

//
//
//   Description:
//
// This function unlocks the workset in <hWSGroup> identified by
// <worksetID>.  This must be the lock most recently acquired or requested
// by the Client; otherwise, the lock violation error causes an assertion
// failure.
//
// If this function is called before the OM_WORKSET_LOCK_CON event is
// received, the Client will not subsequently receive the event.
//
//   Ensuing Events:
//
// This function causes an OM_WORKSET_UNLOCK_IND to be posted to all Clients
// which have the workset open, including the invoking Client.
//
//   Return Codes:
//
// None
//
//

void OM_WorksetCountObjects(
                                    POM_CLIENT              pomClient,
                                    OM_WSGROUP_HANDLE       hWSGroup,
                                    OM_WORKSET_ID           worksetID,
                                    UINT*               pCount);

//
//
//   Description:
//
// On successful completion of this function , the value at <pCount> is the
// number of objects in the workset in <hWSGroup> identified by
// <worksetID>.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_WorksetClear(POM_CLIENT               pomClient,
                                        OM_WSGROUP_HANDLE   hWSGroup,
                                        OM_WORKSET_ID   worksetID);

//
//
//   Description:
//
// This function requests that ObMan clear (i.e.  delete the contents of)
// the workset in <hWSGroup> identified by <worksetID>.
//
// When this function is invoked, all Clients with the workset open
// (including the invoking Client) are notified of the impending clear via
// the OM_WORKSET_CLEAR_IND event.  In response, each Client must invoke the
// OM_WorksetClearConfirm function; its view of the workset will not be
// cleared until it has done so.
//
//   Ensuing Events:
//
// This function will result in the OM_WORKSET_CLEAR_IND being posted to all
// Clients which have the workset open, including the invoking Client.
//
//   Return Codes
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_EXHAUSTED
//
//

void OM_WorksetClearConfirm(
                                    POM_CLIENT          pomClient,
                                    OM_WSGROUP_HANDLE   hWSGroup,
                                    OM_WORKSET_ID       worksetID);

//
//
//   Description:
//
// A Client must call this function after it receives an
// OM_WORKSET_CLEAR_IND.  When the function is invoked, ObMan clears this
// Client's view of the workset.  It is bad Groupware programming practice
// for a Client to unduly delay invoking this function.
//
// Note however that this function has a purely local effect: delaying (or
// executing) a clear confirm at one node will not affect the contents of
// the workset group at any other node.
//
// It is illegal to call this function when a Client has not received an
// OM_WORKSET_CLEAR_IND event.
//
// The arguments to the function must be the same as the workset group
// handle and workset ID included with the OM_WORKSET_CLEAR_IND event.
//
// The function will fail if ObMan is not expecting a clear-confirmation for
// this workset.
//
// This function causes all objects being read in this workset, and all
// object locks in this workset, to be released (i.e.  the function performs
// implicit OM_ObjectUnlock and OM_ObjectRelease functions).  It does not
// cause objects allocated using OM_ObjectAlloc to be discarded.
//
// If there are indication events for object Deletes, Replaces or Confirms
// which have been posted to the Client but not yet confirmed, these
// confirmations are implicitly executed.
//
//   Ensuing Events:
//
// When the primary Client of a workset group confirms a clear using this
// function, an OM_WORKSET_CLEARED_IND is posted to all local secondary
// Clients of the workset group.
//
//   Return Codes:
//
// None
//
//


//
//
//   Description:
//
// These functions add an object to the workset in <hWSGroup> identified by
// <worksetID>.  The <ppObject> parameter is a pointer to a pointer to the
// object.
//
// The position to add the object is determined as follows:
//
// - OM_ObjectAddLast: after the last object in the workset
//
// - OM_ObjectAddFirst: before the first object in the workset
//
// - OM_ObjectAddAfter: after the object specified by <hExistingObject>
//
// - OM_ObjectAddBefore: before the object specified by <hExistingObject>.
//
// Note that the OM_ObjectAddAfter and OM_ObjectAddBefore functions require
// that the invoking Client holds a workset lock, whereas the
// OM_ObjectAddFirst and OM_ObjectAddLast functions will fail if the workset
// is locked by another Client.
//
// ------------------------------------------------------------------------
//
// Note: OM_ObjectAddAfter and OM_ObjectAddBefore are not implemented in
//       DC-Groupware R1.1.
//
// ------------------------------------------------------------------------
//
// On successful completion of the function, <phNewObject> points to the
// newly created handle of the object added.  The Client should use this
// handle in all subsequent ObMan calls relating to this object.
//
// The <ppObject> parameter must be a pointer to a valid object pointer
// returned by the OM_ObjectAlloc function.  If the function completes
// successfully, ObMan assumes ownership of the object and the value at
// <ppObject> is set to NULL to prevent the Client using the object pointer
// again.
//
// The <updateSize> parameter is the size (in bytes) of that portion of the
// object which may be updated using the OM_ObjectUpdate function (not
// counting the <length> field).
//
// Additions to a workset will be sequenced identically at all nodes which
// have the workset open, but the actual sequence arising from simultaneous
// additions by multiple Clients cannot be predicted in advance.
//
// If a set of Clients wishes to impose a particular sequence, they can
// enforce this using an agreed locking protocol based on the workset
// locking (in most cases, it is only necessary that the order is the same
// everywhere, which is why locking is not enforced by ObMan).
//
//   Ensuing Events:
//
// This function causes an OM_OBJECT_ADD_IND to be posted to all Clients
// which have the workset open, including the invoking Client.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_LOCKED (AddFirst, AddLast only)
//  OM_RC_WORKSET_EXHAUSTED
//
//


//
//
//   Description:
//
// These functions move an object within a workset.  The workset is
// specified by <worksetID> and <hWSGroup> and the handle of the object to
// be moved is specified by <pObj>
//
// The position to which the object is moved is determined as follows:
//
// - OM_ObjectMoveLast: after the last object in the workset
//
// - OM_ObjectMoveFirst: before the first object in the workset
//
// - OM_ObjectMoveAfter: after the object specified by <pObj2>
//
// - OM_ObjectMoveBefore: before the object specified by <pObj2>.
//
// Note that OM_ObjectMoveAfter and OM_ObjectMoveBefore require that the
// invoking Client holds a workset lock, whereas the OM_ObjectMoveFirst and
// OM_ObjectMoveLast functions will fail if the workset is locked by another
// Client.
//
// ------------------------------------------------------------------------
//
// Note: OM_ObjectMoveAfter and OM_ObjectMoveBefore are not implemented in
//       DC-Groupware R1.1.
//
// ------------------------------------------------------------------------
//
// Locked objects may be moved.
//
// Neither the handle nor the ID of an object is altered by moving it within
// a workset.
//
//   Ensuing Events
//
// This action causes the OM_OBJECT_MOVE_IND to be posted to all Clients
// which have the workset open, including the invoking Client.
//
//   Return Codes
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_EXHAUSTED
//  OM_RC_WORKSET_LOCKED (MoveFirst, MoveLast only)
//
//

UINT OM_ObjectDelete(
                               POM_CLIENT               pomClient,
                               OM_WSGROUP_HANDLE	hWSGroup,
                               OM_WORKSET_ID           worksetID,
                               POM_OBJECT       pObj);

//
//
//   Description:
//
// This function requests that ObMan delete an object from a workset.  The
// workset is specified by <worksetID> and <hWSGroup> and the handle of the
// object to be deleted is <pObj>.
//
// The local copy of the object is not actually deleted until the Client
// invokes OM_ObjectDeleteConfirm in response to the OM_OBJECT_DELETE_IND
// event which this function generates.
//
// When this function is invoked, all Clients with the workset open
// (including the invoking Client) are notified of the impending deletion
// via the OM_OBJECT_DELETE_IND event.  In response, each Client must invoke
// the OM_ObjectDeleteConfirm function; each Client will have access to the
// object until it has done so.
//
// If this object is already pending deletion (i.e.  a DELETE_IND event has
// been posted to the Client but not yet Confirmed) this function returns
// the OM_RC_OBJECT_DELETED error.
//
// ObMan guarantees not to reuse a discarded object handle in the same
// workset within the lifetime of the workset group.
//
//   Ensuing Events:
//
// This function causes the OM_OBJECT_DELETE_IND to be posted to all Clients
// which have the workset open, including the invoking Client (except as
// where stated above).
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_LOCKED
//  OM_RC_WORKSET_EXHAUSTED
//  OM_RC_OBJECT_DELETED
//
//

void   OM_ObjectDeleteConfirm(
                                      POM_CLIENT               pomClient,
                                      OM_WSGROUP_HANDLE	hWSGroup,
                                      OM_WORKSET_ID           worksetID,
                                      POM_OBJECT pObj);

//
//
//   Description:
//
// A Client must call this function after it receives an
// OM_OBJECT_DELETE_IND.  When the function is invoked, ObMan deletes the
// object specified by <hWSGroup>, <worksetID> and the value at <ppObj>.
// It is bad Groupware programming practice for a Client to unduly delay
// invoking this function.
//
// Note however that this function has a purely local effect: delaying (or
// executing) a delete confirm at one node will not affect the contents of
// the workset group at any other node.
//
// On successful completion, the handle of the deleted object becomes
// invalid and the value at <ppObj> is set to NULL to prevent the Client
// from further accessing this object.
//
// Any pointer to the previous version of this object which the Client had
// obtained using OM_ObjectRead becomes invalid and should not be referred
// to again (i.e.  the function performs an implicit OM_ObjectRelease).
//
// The function will cause an assertion failure if ObMan is not expecting a
// delete-confirmation for this object.
//
//   Ensuing Events:
//
// When the primary Client of a workset group confirms a delete using this
// function, an OM_OBJECT_DELETED_IND is posted to all local secondary
// Clients of the workset group.
//
//   Return Codes:
//
// None
//
//

UINT OM_ObjectReplace(
                                POM_CLIENT               pomClient,
                                OM_WSGROUP_HANDLE	hWSGroup,
                                OM_WORKSET_ID           worksetID,
                                POM_OBJECT      pObj,
                                POM_OBJECTDATA *   ppData);

UINT OM_ObjectUpdate(
                                POM_CLIENT               pomClient,
                                OM_WSGROUP_HANDLE	hWSGroup,
                                OM_WORKSET_ID           worksetID,
                                POM_OBJECT      pObj,
                                POM_OBJECTDATA *    ppData);

//
//
//   Description:
//
// This function requests that ObMan replaces/updates the object specified
// by <pObj> in the workset specified by <worksetID> and <hWSGroup>.
//
// "Replacing" one object with another causes the previous object to be
// lost.  "Updating" an object causes only the first N bytes of the object
// to be replaced by the <data> field of the object supplied, where N is the
// <length> field of the update.  The rest of the object data remains the
// same, as does the length of the object.
//
// The local copy of the object is not actually replaced/updated until the
// Client invokes OM_ObjectReplaceConfirm/OM_ObjectUpdateConfirm in response
// to the OM_OBJECT_REPLACE_IND/OM_OBJECT_UPDATE_IND which this function
// generates.
//
// The <ppObject> parameter must be a pointer to a valid object pointer
// returned by the OM_ObjectAlloc function.  If the function completes
// successfully, ObMan assumes ownership of the object and the value at
// <ppObject> is set to NULL to prevent the Client using the object pointer
// again.
//
// Neither the handle nor the ID of an object is altered by replacing or
// updating the object.
//
// If the object is pending deletion i.e.  if ObMan has posted an
// OM_OBJECT_DELETE_IND event which has not yet been confirmed, the
// OM_RC_OBJECT_DELETED error is returned.
//
// If the object is pending replace or update i.e.  if ObMan has posted an
// OM_OBJECT_REPLACE_IND/OM_OBJECT_UPDATE_IND event which has not yet been
// confirmed, this replace/update spoils the previous one.  In this case, no
// further event is posted, and when the outstanding event is confirmed, the
// most recent replace/update is performed.
//
// The <reserved> parameter to OM_ObjectUpdate is not used in DC-Groupware
// R1.1 and must be set to zero.
//
// For a replace, the size of the object specified by <ppObject> must be at
// least as large as the <updateSize> specified when the object was
// originally added.
//
// For an update, the size of the object specified by <ppObject> must be the
// same as the <updateSize> specified when the object was originally added.
//
// Object replaces/updates will be sequenced identically at all nodes, but
// the actual sequence arising from simultaneous replace/update operations
// by multiple Clients cannot be predicted in advance.
//
// If a set of Clients wishes to impose a particular sequence, they should
// use an agreed locking protocol based on object or workset locking (in
// most cases, it is only necessary that the order is the same everywhere,
// which is why locking is not enforced by ObMan).
//
// Replaces and updates may be spoiled by ObMan so Client should not assume
// that an event will be generated for each replace or update carried out.
//
//   Ensuing Events:
//
// This function causes the OM_OBJECT_REPLACE_IND/OM_OBJECT_UPDATE_IND to be
// posted to all Clients which have the workset open, including the invoking
// Client.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_LOCKED
//  OM_RC_OBJECT_LOCKED
//  OM_RC_OBJECT_DELETED
//
//

void OM_ObjectReplaceConfirm(
                                     POM_CLIENT               pomClient,
                                     OM_WSGROUP_HANDLE	hWSGroup,
                                     OM_WORKSET_ID           worksetID,
                                     POM_OBJECT     pObj);

void OM_ObjectUpdateConfirm(
                                     POM_CLIENT               pomClient,
                                     OM_WSGROUP_HANDLE	hWSGroup,
                                     OM_WORKSET_ID           worksetID,
                                     POM_OBJECT     pObj);

//
//
//   Description:
//
// When a Client receives an OM_OBJECT_REPLACE_IND/OM_OBJECT_UPDATE_IND, it
// must confirm the relevant operation by calling OM_ObjectReplaceConfirm or
// OM_ObjectUpdateConfirm.
//
// When the functions are invoked, ObMan replaces/updates the object
// specified by <hWSGroup>, <worksetID> and <pObj>.  It is bad Groupware
// programming practice for a Client to unduly delay invoking this function.
//
// Note however that these functions have a purely local effect: delaying
// (or executing) replace/update confirms at one node will not affect the
// contents of the workset group at any other node.
//
// Any pointer to the previous version of this object which the Client had
// obtained using OM_ObjectRead becomes invalid and should not be referred
// to again (i.e.  the functions perform an implicit OM_ObjectRelease).
//
// The functions will cause an assertion failure if ObMan is not expecting a
// replace- or update-confirmation for this object.
//
//   Ensuing Events:
//
// When the primary Client of a workset group confirms an update or replace
// using this function, an OM_OBJECT_UPDATED_IND/OM_OBJECT_REPLACED_IND is
// posted to all local secondary Clients of the workset group.
//
//   Return Codes
//
// None
//
//


UINT OM_ObjectLockReq(POM_CLIENT pomClient, OM_WSGROUP_HANDLE hWSGroup,
        OM_WORKSET_ID worksetID, POM_OBJECT pObj, BOOL reserved,
        OM_CORRELATOR * pCorrelator);


//
//
//   Description:
//
// This is an asynchronous function which requests a lock for the object
// specified by <pObj> in the workset identified by <worksetID> and
// <hWSGroup>.  When ObMan has processed the lock request, it will send an
// OM_OBJECT_LOCK_CON to the Client indicating success or the reason for
// failure.
//
// ------------------------------------------------------------------------
//
// Note: OM_ObjectLockReq and OM_ObjectUnlock are not implemented in
//       DC-Groupware R1.1.
//
// ------------------------------------------------------------------------
//
// Holding an object lock prevents other Clients from
//
// - locking the workset
//
// - locking the object
//
// - updating or replacing the object
//
// - deleting the object.
//
// It does not prevent other Clients from reading the object or moving it
// within a workset.
//
// The function will cause an assertion failure if the Client requesting the
// lock already holds or has requested a lock which is equal to or after
// this one in the Universal Locking Order.
//
// On successful completion of the function, the value at <pCorrelator> is a
// value which the Client can use to correlate the subsequent
// OM_OBJECT_LOCK_CON event with this request.
//
// The <reserved> parameter is not used in DC-Groupware R1.1 and must be set
// to zero.
//
// A Client must release the lock when it no longer needs it, using the
// OM_ObjectUnlock function.  Locks will be automatically released when a
// Client closes the workset or deregisters from the workset group.
//
//   Ensuing Events:
//
// Invoking this function will cause the OM_OBJECT_LOCK_CON event to be
// posted to the invoking Client at some later time.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//
//

void   OM_ObjectUnlock(
                               POM_CLIENT               pomClient,
                               OM_WSGROUP_HANDLE	hWSGroup,
                               OM_WORKSET_ID           worksetID,
                               POM_OBJECT       pObj);

//
//
//   Description:
//
// This function unlocks the object specified by <worksetID> and <pObj>.
// This must be the lock most recently acquired or requested by the Client;
// otherwise, the lock violation error causes an assertion failure.
//
// If this function is called before the OM_OBJECT_LOCK_CON event is
// received, the Client will not subsequently receive the event.
//
// ------------------------------------------------------------------------
//
// Note: OM_ObjectLockReq and OM_ObjectUnlock are not implemented in
//       DC-Groupware R1.1.
//
// ------------------------------------------------------------------------
//
//   Ensuing Events:
//
// This function causes an OM_OBJECT_UNLOCK_IND to be posted to all other
// Clients which have the workset open.
//
//   Return Codes:
//
// None
//
//

UINT OM_ObjectH(POM_CLIENT               pomClient,
                                        OM_WSGROUP_HANDLE	hWSGroup,
                                        OM_WORKSET_ID           worksetID,
                                        POM_OBJECT      pObjOther,
                                        POM_OBJECT *    pObj,
                                        OM_POSITION omPos);

UINT OM_ObjectRead(POM_CLIENT               pomClient,
                                      OM_WSGROUP_HANDLE	hWSGroup,
                                      OM_WORKSET_ID     worksetID,
                                      POM_OBJECT     pObj,
                                      POM_OBJECTDATA *  ppData);

//
//
//   Description:
//
// This function enables a Client to read the contents of an object by
// converting an object handle into a pointer to the object.
//
// On successful completion, the value at <ppObject> points to the specified
// object.
//
// Invoking this function causes the object to be held in memory at the
// location indicated by the return value at <ppObject>.  When it has
// finished reading the object, the Client must release it using the
// OM_ObjectRelease function.  Holding object pointer for extended lengths
// of time may adversely affect ObMan's ability to efficiently manage its
// memory.
//
// This pointer is valid until the Client releases the object, either
// explicitly with OM_ObjectRelease or implicitly.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//
//

void OM_ObjectRelease(POM_CLIENT               pomClient,
                                       OM_WSGROUP_HANDLE	hWSGroup,
                                       OM_WORKSET_ID           worksetID,
                                       POM_OBJECT       pObj,
                                       POM_OBJECTDATA *    ppData);

//
//
//   Description:
//
// Calling this function indicates to ObMan that the Client has finished
// reading the object specified by the handle <pObj>.  The <ppObject>
// parameter is a pointer to a pointer to the object, which was previously
// obtained using OM_ObjectRead.
//
// On successful completion, the pointer to this object which the Client
// acquired using OM_ObjectRead becomes invalid (as the object may
// subsequently move in memory) and the value at <ppObject> is set to NULL
// to prevent the Client from using it again.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_ObjectAlloc(POM_CLIENT            pomClient,
                                       OM_WSGROUP_HANDLE	hWSGroup,
                                       OM_WORKSET_ID        worksetID,
                                       UINT                 length,
                                       POM_OBJECTDATA *     ppData);

//
//
//   Description:
//
// This function allocates a new, empty object the <data> field of which is
// <length> bytes long.  The object must be intended for subsequent
// insertion into the workset specified by <hWSGroup> and <worksetID>.
//
// Note that the <length> parameter is the length of the object's data field
// (so the total memory requirement for this function is length+4 bytes).
//
// The contents of the memory allocated are undefined, and it is the
// Client's responsibility to fill in the <length> field at the start of the
// object.
//
// On successful completion, the value at <ppObject> points to the new
// object.  This pointer is valid until the Client returns the object to
// ObMan using one of the functions mentioned here.
//
// A Client may write in this object and will normally insert it in the
// workset for which it was allocated using one of the object add, update or
// replace functions.  However, if a Client fails to do so or decides for
// some other reason not to do so, it must free up the object by calling the
// OM_ObjectDiscard function.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//
//

void OM_ObjectDiscard(POM_CLIENT             pomClient,
                                       OM_WSGROUP_HANDLE	hWSGroup,
                                       OM_WORKSET_ID         worksetID,
                                       POM_OBJECTDATA *     ppData);

//
//
//   Description:
//
// This function discards an object which a Client previously allocated
// using OM_ObjectAlloc.  A Client will call this function if for some
// reason it does not want to or cannot insert the object into the workset
// for which it was allocated.  A Client must not call this function for an
// object which it has already added to a workset or used to update or
// replace an object in a workset.
//
// On successful completion, the value at <ppObject> is set to NULL to
// prevent the Client from accessing the object again.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_ObjectIDToPtr(POM_CLIENT            pomClient,
                                            OM_WSGROUP_HANDLE	hWSGroup,
                                            OM_WORKSET_ID        worksetID,
                                            OM_OBJECT_ID         objectID,
                                            POM_OBJECT *    ppObj);

//
//
//   Description:
//
// This functions converts an object ID to an object handle.  If no object
// with the specified ID is found in the specified workset, an error is
// returned.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  OM_RC_BAD_OBJECT_ID
//
//

void OM_ObjectPtrToID(POM_CLIENT            pomClient,
                                OM_WSGROUP_HANDLE   hWSGroup,
                                          OM_WORKSET_ID        worksetID,
                                          POM_OBJECT        pObj,
                                          POM_OBJECT_ID        pObjectID);

//
//
//   Description:
//
// This functions converts an object handle to an object ID.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//



//
//
//   Description
//
// These functions return information about a particular primary Client
// (identified by <hPerson>) of the workset group identified by <hWSGroup>
// <function profile> combination.
//
// If the person handle <hPerson> is invalid, the OM_RC_NO_SUCH_PERSON error
// is returned.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  OM_RC_NO_SUCH_PERSON
//  Utility Service return codes
//
//

UINT OM_GetNetworkUserID(
                                   POM_CLIENT                   pomClient,
                                   OM_WSGROUP_HANDLE    hWSGroup,
                                   NET_UID            *    pNetUserID);

//
//
//   Description:
//
// This functions returns ObMan's Network user ID for the call which
// contains the workset group specified by <hWSGroup>.
//
// This network ID corresponds to the <creator> field of objects defined by
// the Object Manager Function Profile.
//
// If the specified workset group is a local workset group (i.e.  its
// "call" is OM_NO_CALL), then the function returns OM_RC_LOCAL_WSGROUP.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  OM_RC_LOCAL_WSGROUP
//
//


BOOL CALLBACK OMSEventHandler(LPVOID pomClient, UINT event, UINT_PTR param1, UINT_PTR param2);

//
//
//   Description
//
// This is the handler that ObMan registers (as a Utility Service event
// handler) for Client tasks to trap ObMan events.  It serves two main
// purposes:
//
// - some state changes associated with events posted to Client tasks
//   are better made when the event arrives than when it is posted
//
// - this handler can detect and discard "out-of-date" events, such as
//   those arriving for a workset which a Client has just closed.
//
// The first parameter is the Client's ObMan handle, as returned by
// OM_Register, cast to a UINT.
//
// The second parameter is the event to be processed.
//
// The third and fourth parameters to the function are the two parameters
// associated with the event.
//
//


//
//
// OM_OUT_OF_RESOURCES_IND
//
//   Description:
//
// This abnormal failure event is posted when ObMan cannot allocate
// sufficient resources to complete a particular action, usually one
// prompted by a network event.
//
// Clients should treat this event as a fatal error and attempt to
// terminate.
//
// The parameters included with the event are reserved.
//
//

//
//
// OM_WSGROUP_REGISTER_CON
//
//   Description:
//
// This event is posted when ObMan has finished processing a request to
// register a Client with a workset group.  The parameters included with
// the event are defined as follows:
//
// - the second parameter is an OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the value which was returned by
//       the corresponding invocation of the OM_WSGroupRegisterPReq
//       function
//
//     - the <result> field is one of
//
//          0 (== OK)
//          Utility Service return codes
//          OM_RC_OUT_OF_RESOURCES
//          OM_RC_TOO_MANY_CLIENTS
//          OM_RC_TOO_MANY_WSGROUPS
//          OM_RC_ALREADY_REGISTERED
//          OM_RC_CANNOT_CREATE_WSG
//
// - if the <result> field is 0 (== OK), the first parameter is an
//   OM_EVENT_DATA16 structure which contains a newly created handle
//   to the workset group involved (the <worksetID> field is
//   reserved).
//
// Once a Client has received this notification, it will receive
// OM_WORKSET_NEW_IND events to notify it of the existing worksets in the
// group, if there are any.
//
//

//
//
// OM_WSGROUP_MOVE_CON
//
//   Description:
//
// This event is posted when ObMan has finished processing a request to
// move an existing workset group into a Call.  The parameters included
// with the event are defined as follows:
//
// - the second parameter is an OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the value which was returned by
//       the corresponding invocation of the OM_WSGroupMoveReq
//       function
//
//     - the <result> field is one of
//
//          0 (== OK)
//          Utility Service return codes
//          OM_RC_CANNOT_MOVE_WSGROUP
//
// - the first parameter is a OM_EVENT_DATA16 structure which contains the
//   handle of the workset group involved (the <worksetID> field is
//   reserved).
//
//

//
//
// OM_WSGROUP_MOVE_IND
//
//   Description:
//
// This event is posted when ObMan has moved a workset group either into or
// out of a Call.
//
// This will happen
//
// - when the workset group is moved out of a Call (because e.g.  the call
//   has ended), thus becoming a local workset group
//
// - when a local Client requests to move a local workset group into a
//   Call.
//
// The parameters included with the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group involved (the <worksetID> field is reserved).
//
// - the second parameter is the handle of the Call into which the
//   workset group has been moved (== OM_NO_CALL when the workset group
//   has been moved out of a Call).
//
// If the workset group has been moved out of a call, it continues in
// existence as a local workset group and the Client may continue to use it
// as before.  However, no updates will be sent to or received from Clients
// residing on other nodes.
//
// If a Client wishes to move this workset group into another Call, it can
// do so using the OM_WSGroupMoveReq function.  Note that an attempt to move
// the workset group back into the same Call is likely to fail due to a name
// clash since the original version probably still exists in the Call.
//
// This event may also be prompted by the failure to allocate memory for a
// large object being transferred from another node.
//
//

//
//
// OM_WORKSET_NEW_IND
//
//   Description:
//
// This event is posted when a new workset has been created (by the
// receiving Client or by another Client).  The parameters included with
// the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is reserved.
//
//

//
//
// OM_WORKSET_OPEN_CON
//
//   Description:
//
// This event is posted when ObMan has finished processing a request to
// open a workset for a specific Client.
//
// The parameters included with the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is a OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the correlator which was
//       returned by the corresponding invocation of the
//       OM_WorksetOpenReq function
//
//     - the <result> field is one of
//
//          0 (== OK)
//          OM_RC_OUT_OF_RESOURCES.
//
// In all but the case of OK, the open request has failed and the Client
// does not have the workset open.
//
//

//
//
// OM_WORKSET_LOCK_CON
//
//   Description:
//
// This event is posted to a Client when ObMan has succeeded in obtaining,
// or failed to obtain, a workset lock which the Client had requested.  The
// parameters included with the event are as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is a OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the correlator which was
//       returned by the corresponding invocation of the
//       OM_WorksetLockReq function
//
//     - the <result> field is one of
//
//       0 (== OK)
//       OM_RC_OUT_OF_RESOURCES
//       OM_RC_WORKSET_LOCKED
//       OM_RC_OBJECT_LOCKED.
//
// In all but the case of OK, the lock request has failed and the Client
// does not hold the lock.
//
//

//
//
// OM_WORKSET_UNLOCK_IND
//
//   Description:
//
// This event is posted when a workset is unlocked using the
// OM_WorksetUnlock function.  The parameters included with the event are
// as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is reserved.
//
//

//
//
// OM_WORKSET_CLEAR_IND
//
//   Description:
//
// This event is posted (to primary Clients only) after a local or remote
// Client has invoked the OM_WorksetClear function.  After a Client receives
// this event, it must call OM_WorksetClearConfirm to enable ObMan to clear
// the workset.
//
// The parameters included with the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is reserved.
//
//

//
//
// OM_WORKSET_CLEARED_IND
//
//   Description:
//
// This event is posted (to secondary Clients only) when a workset has been cleared.
//
// The parameters included with the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is reserved.
//
//

//
//
// OM_OBJECT_ADD_IND
//
//   Description:
//
// This event is posted after a new object has been added to a workset.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_OBJECT_MOVE_IND
//
//   Description:
//
// This event is posted after a new object has been moved within a workset.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_OBJECT_DELETE_IND
//
//   Description:
//
// This event is posted (to primary Clients only) after a local or remote
// Client has invoked the OM_ObjectDelete function.  After a Client
// receives this event, it must call OM_ObjectDeleteConfirm to enable ObMan
// to delete the object.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
// See also OM_OBJECT_DELETED_IND.
//
//

//
//
// OM_OBJECT_REPLACE_IND
// OM_OBJECT_UPDATE_IND
//
//   Description:
//
// These events are posted (to primary Clients only) after a local or remote
// Client has invoked the OM_ObjectReplace/OM_ObjectUpdate function.  After
// a Client receives this event, it must call OM_ObjectReplaceConfirm/
// OM_ObjectUpdateConfirm to enable ObMan to replace/update the object.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
// See also OM_OBJECT_REPLACED_IND/OM_OBJECT_UPDATED_IND.
//
//

//
//
// OM_OBJECT_DELETED_IND
//
//   Description:
//
// This event is posted (to secondary Clients only) when an object has been
// deleted from a workset.  The handle it contains is thus invalid and can
// only be used to cross-reference against lists maintained by the Client.
//
// The Client must not invoke the OM_ObjectDeleteConfirm function on
// receipt of this event.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 identifying the workset
//   group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_OBJECT_REPLACED_IND
// OM_OBJECT_UPDATED_IND
//
//   Description:
//
// These events are posted (to secondary Clients only) when an object has
// been replaced or updated.  When the Client receives this event, the
// previous data is thus inaccessible.
//
// The Client must not invoke the OM_ObjectReplaceConfirm/
// OM_ObjectUpdateConfirm function on receipt of this event.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 identifying the workset
//   group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_OBJECT_LOCK_CON
//
//   Description:
//
// This event is posted to a Client when ObMan has succeeded in obtaining
// (or failed to obtain) an object lock which the Client had requested.
// The parameters included with the event are defined as follows:
//
// - the first parameter is reserved
//
// - the second parameter is a OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the correlator which was
//       returned by the corresponding invocation of the
//       OM_ObjectLockReq function
//
//     - the <result> field is one of
//
//       0 (== OK)
//       Utility Service return codes
//       OM_RC_WORKSET_LOCKED
//       OM_RC_OBJECT_LOCKED.
//
// In all but the case of OK, the lock request has failed and the Client
// does not hold the lock.
//
//

//
//
// OM_OBJECT_UNLOCK_IND
//
//   Description:
//
// This event is posted when a Client has released an object lock using the
// OM_ObjectUnlock function.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_PERSON_JOINED_IND
// OM_PERSON_LEFT_IND
// OM_PERSON_DATA_CHANGED_IND
//
//  Description:
//
// These events inform clients registered with a workset group when clients
// register with the workset group, deregister from it and set their person
// data, respectively.
//
// A client will also receive the appropriate events when it performs these
// actions itself.
//
//  Parameters:
//
// The first parameter in an OM_EVENT_DATA16 which identifies the workset
// group to which the event relates.  The <worksetID> field of the structure
// is undefined.
//
// The second parameter is the POM_EXTOBJEECT for the person to which the
// event relates.  These handles are not guaranteed to be still valid.  In
// particular, the handle received on the OM_PERSON_LEFT_IND is never valid.
// If a client wishes to correlate these events with a list of clients,
// then it is responsible for maintaining the list itself.
//
//


//
// OMP_Init()
// OMP_Term()
//

BOOL OMP_Init(BOOL * pfCleanup);
void OMP_Term(void);


void CALLBACK OMPExitProc(LPVOID pomPrimary);
BOOL CALLBACK OMPEventsHandler(LPVOID pomPrimary, UINT event, UINT_PTR param1, UINT_PTR param2);


//
//
// ProcessNetData(...)
//
// This function is called when a NET_EV_SEND_INDICATION event is received,
// indicating the arrival of a message from another instance of ObMan.  The
// function determines which OMNET_...  message is contained in the network
// packet and invokes the appropriate ObMan function to process the
// message.
//
//

void ProcessNetData(POM_PRIMARY          pomPrimary,
                    POM_DOMAIN           pDomain,
                    PNET_SEND_IND_EVENT  pNetEvent);


//
//
// ProcessNetDetachUser(...)
//
// This function is called when a NET_EV_DETACH_INDICATION event is received
// from the network layer.
//
// The function determines whether
//
// - we have been thrown out of the Domain by MCS, or
//
// - someone else has left/been thrown out
//
// and calls ProcessOwnDetach or ProcessOtherDetach as appropriate.
//
//

void ProcessNetDetachUser(POM_PRIMARY pomPrimary, POM_DOMAIN pDomain,
        NET_UID userID);

//
//
// ProcessNetAttachUser(...)
//
// This function is called when a NET_ATTACH_INDICATION event is received
// from the network layer.  The function calls MG_ChannelJoin to join us
// to our own single-user channel.
//
//

void ProcessNetAttachUser(POM_PRIMARY pomPrimary, POM_DOMAIN pDomain,
        NET_UID userID, NET_RESULT result);


//
//
// ProcessNetJoinChannel(...)
//
// This function is called when a NET_EV_JOIN_CONFIRM event is received from
// the network layer.  This function determines whether the join was
// successful and whether the channel joined is
//
// - our own single-user channel
//
// - the well-known ObManControl channel
//
// - a regular workset group channel
//
// and then takes appropriate action.
//
//

void ProcessNetJoinChannel(POM_PRIMARY        pomPrimary,
                                          POM_DOMAIN       pDomain,
                                          PNET_JOIN_CNF_EVENT  pNetJoinCnf);


//
//
// ProcessNetLeaveChannel(...)
//
// This function is called when a NET_EV_LEAVE_INDICATION event is received
// from the network layer, indicating that we've been thrown out of a
// channel.  This function determines whether the channel is
//
// - our own single-user channel
//
// - the well-known ObManControl channel
//
// - a regular workset group channel
//
// and then takes appropriate action; in the first two cases, this means
// behaving as if we've been thrown out of the Domain altogether, whereas
// we treat the last case just as if a Client had asked to move the workset
// group into the local Domain.
//
//

UINT ProcessNetLeaveChannel(POM_PRIMARY      pomPrimary,
                                           POM_DOMAIN     pDomain,
                                           NET_CHANNEL_ID     channel);


//
//
// DomainRecordFindOrCreate(...)
//
//

UINT DomainRecordFindOrCreate(POM_PRIMARY        pomPrimary,
                                            UINT             callID,
                                            POM_DOMAIN * ppDomain);


//
//
// DomainDetach(...)
//
void DomainDetach(POM_PRIMARY pomPrimary, POM_DOMAIN * ppDomain, BOOL fExit);


//
//
// DeregisterLocalClient(...)
//
// This function is called by the ObMan task after the local client
// deregisters from a workset group.  It causes this node's person object
// for the workset group to be deleted.
//
// If this node was the last node to be registered with the workset group,
// it also causes the relevant INFO object to be discarded.
//
// If this in turn causes the last workset group in the domain (which must
// be ObManControl) to be removed, ObMan is detached from the domain and
// the domain record becomes invalid.  In this case, the ppDomain
// pointer passed in is nulled out.
//
//

void DeregisterLocalClient(POM_PRIMARY pomPrimary,
                                        POM_DOMAIN *   ppDomain,
                                        POM_WSGROUP            pWSGroup,
                                        BOOL fExit);


//
//
// GetOMCWorksetPtr(...)
//
// This function derives a pointer to a specified workset in the
// ObManControl workset in the specified Domain.
//
//

UINT GetOMCWorksetPtr(POM_PRIMARY       pomPrimary,
                                     POM_DOMAIN      pDomain,
                                     OM_WORKSET_ID       worksetID,
                                     POM_WORKSET *  ppWorkset);


//
//
// SayWelcome(...)
//
// This function is called
//
// - when the "top" ObMan finishes initalizing (the WELCOME is broadcast)
//
// - when ObMan receives an HELLO message from a late joiner (the WELCOME
//   is sent to the late joiner)
//
//

UINT SayWelcome(POM_PRIMARY        pomPrimary,
                               POM_DOMAIN       pDomain,
                               NET_CHANNEL_ID       channel);


//
//
// ProcessWelcome(...)
//
// Called when a WELCOME is received from another node.  This may be in
// response to a HELLO, or it may be the "top" ObMan announcing the
// completion of its initialization.
//
// If this is the first WELCOME we've got for this Domain, we merge the
// capabilities and reply to the sender, asking for a copy of the
// ObManControl workset group.
//
//

UINT ProcessWelcome(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   POMNET_JOINER_PKT  pWelcomePkt,
                                   UINT           lengthOfPkt);


//
//
// SayHello(...)
//
// Called when we join that domain and determine that we're not the "top"
// ObMan.  We expect a WELCOME to come in response.  We include our
// capabilities in the broadcast HELLO packet so that everyone knows what
// we support.
//
//

UINT SayHello(POM_PRIMARY   pomPrimary,
                             POM_DOMAIN  pDomain);


//
//
// ProcessHello(...)
//
// Called when we get a HELLO from another node.  If we've completed our
// own initialization in the domain, we merge in that node's capabilities,
// then we respond with a WELCOME.
//
//

UINT ProcessHello(POM_PRIMARY        pomPrimary,
                                 POM_DOMAIN       pDomain,
                                 POMNET_JOINER_PKT    pHelloPkt,
                                 UINT             lengthOfPkt);


//
//
// MergeCaps(...)
//
// Called by ProcessHello and ProcessWelcome to merge in capabilities
// received in the packet (which will be, respectively, a late joiner's
// capabilities or the domain-wide capabilities as determined by the sender
// of the WELCOME).
//
//

void MergeCaps(POM_DOMAIN       pDomain,
                            POMNET_JOINER_PKT    pJoinerPkt,
                            UINT             lengthOfPkt);


//
//
// ProcessOwnDetach(...)
//
// This function is called when a NET_EV_DETACH_INDICATION is received for a
// user ID that matches our own.  The function moves all of the workset
// groups for this Domain into ObMan's own "local" Domain.
//
//
UINT ProcessOwnDetach(POM_PRIMARY    pomPrimary,
                                     POM_DOMAIN   pDomain);


//
//
// ProcessOtherDetach(...)
//
// This function is called when a NET_EV_DETACH_INDICATION is received for a
// user ID that doesn't match our own.  The function examines each workset
// in the ObManControl workset group and deletes any registration objects
// that the departed node may have put there.
//
// If any local Clients have any of these worksets open, they are informed
// of the delete.  However, OBEJCT_DELETE messages are not broadcast
// throughout the Domain, since each ObMan will do them locally.
//
//

UINT ProcessOtherDetach(POM_PRIMARY     pomPrimary,
                                       POM_DOMAIN    pDomain,
                                       NET_UID           detachedUserID);


//
//
// WSGRegisterStage1(...)
//
// This function is ObMan's handler for the OMINT_EVENT_WSGROUP_REGISTER
// function.  It is the first step in the chain of functions running in the
// ObMan context which are invoked during the workset group registration
// process (the OM_WSGroupRegisterReq, running in the Client context,
// posted the original OMINT_EVENT_WSGROUP_REGISTER event).
//
// This function ensures that we are fully attached to the Domain (if not,
// it starts the Domain attach procedure and reposts a delayed
// OMINT_EVENT_WSGROUP_REGISTER event) and then starts the process of locking
// workset #0 in the ObManControl workset group.
//
//

void WSGRegisterStage1(POM_PRIMARY        pomPrimary,
                                    POM_WSGROUP_REG_CB   pRegistrationCB);


//
// ProcessOMCLockConfirm(...)
//
void ProcessOMCLockConfirm(POM_PRIMARY pomPrimary, OM_CORRELATOR cor, UINT result);


//
// ProcessCheckpoint(...)
//
void ProcessCheckpoint(POM_PRIMARY pomPrimary, OM_CORRELATOR cor, UINT result);


//
//
// WSGRegisterStage2(...)
//
// This function is called when we have successfully locked workset #0 in
// ObManControl.
//
// The function checks workset #0 in ObManControl to see if the workset
// group we're trying to register the Client with already exists in the
// Domain.
//
// If it does, it finds the channel number and requests to join the
// channel.
//
// If it doesn't, it requests to join a new channel and also calls
// WSGGetNewID to generate a new workset group ID (unique within the
// Domain).
//
//

void WSGRegisterStage2(POM_PRIMARY        pomPrimary,
                                    POM_WSGROUP_REG_CB   pRegistrationCB);


//
//
// WSGGetNewID(...)
//
// This function is called by WSGRegisterStage2 to generate a new workset
// group ID, in the case where the workset group doesn't already exist.
//
// It also creates a new workset in ObManControl with the same ID as the ID
// just generated.  This workset which will hold the registration objects
// for the new workset group
//
//

UINT WSGGetNewID(POM_PRIMARY     pomPrimary,
                                POM_DOMAIN    pDomain,
                                POM_WSGROUP_ID    pWSGroupID);


//
//
// WSGRegisterStage3(...)
//
// This function is called by ProcessNetJoinChannel when a Join event
// arrives for a workset group channel.
//
// Depending on whether or not the workset was created in Stage2, the
// function calls WSGAnnounce (if it was) or WSGCatchUp (if it was not).
//
// It then unlocks the ObManControl workset and calls WSGRegisterResult.
//
//

void WSGRegisterStage3(POM_PRIMARY         pomPrimary,
                                    POM_DOMAIN        pDomain,
                                    POM_WSGROUP_REG_CB    pRegistrationCB,
                                    NET_CHANNEL_ID        channelID);


//
//
// CreateAnnounce(...)
//
// This function is called by WSGRegisterStage3 after we have joined the
// channel for a new workset group.
//
// The function announces the new workset group throughout the Domain by
// adding an object containing the name, Function Profile, ObMan ID and MCS
// channel of the workset group to workset #0 in ObManControl.
//
// Note that this "announcement" cannot be made before the Join completes
// since we only learn the ID of the channel joined when we receive the
// Join event.
//
//

UINT CreateAnnounce(POM_PRIMARY    pomPrimary,
                                   POM_DOMAIN   pDomain,
                                   POM_WSGROUP      pWSGroup);


//
//
// RegAnnounceBegin(...)
//
// This function adds a registration object to a workset in ObManControl.
// The workset is determined by the ID of the workset group identified by
// <pWSGroup>.
//
// This function is called
//
// - when ObMan creates a workset group
//
// - when ObMan receives a request to send a workset group to a late
//   joiner.
//
// In the first case, the registration object identifies this node's use of
// the workset group.  In the second case, the reg object identifies the
// late joiner's use of the workset group.
//
// The object ID returned is the ID of the reg object added.
//
//

UINT RegAnnounceBegin(POM_PRIMARY          pomPrimary,
                                     POM_DOMAIN         pDomain,
                                     POM_WSGROUP            pWSGroup,
                                     NET_UID                nodeID,
                                     POM_OBJECT *   ppObjReg);


//
//
// RegAnnounceComplete(...)
//
// This function is called when we are fully caught up with a workset group
// we have joined, either because we have received the SEND_COMPLETE
// message or because we just created the group ourselves.
//
// The function updates the reg object specified by <regObjectID> by
// changing the <status> field to READY_TO_SEND.
//
//

UINT RegAnnounceComplete(POM_PRIMARY    pomPrimary,
                                        POM_DOMAIN   pDomain,
                                        POM_WSGROUP      pWSGroup);


//
//
// WSGCatchUp(...)
//
// This function is called by Stage3 after we have joined the channel
// belonging to a workset group which already exists in the Domain.
//
// The function examines ObManControl to find the MCS ID of an instance of
// ObMan which claims to have a copy of this workset group, then sends it a
// request to transfer the workset group.
//
// The function also posts a delayed timeout event so we don't wait for
// ever to get a workset group from a particular node (this timeout is
// processed in ProcessWSGSendTimeout).
//
//

UINT WSGCatchUp(POM_PRIMARY          pomPrimary,
                               POM_DOMAIN         pDomain,
                               POM_WSGROUP            pWSGroup);


//
//
// WSGRegisterResult(...)
//
// This function is called wherever any of the workset group registration
// functions have done enough processing to know the outcome of the
// registration attempt.  If all is well, it will be called by Stage3 but
// it may also be called earlier if an error occurs.
//
// The function posts an OM_WSGROUP_REGISTER_CON event to the Clientn which
// initiated the workset group registration.
//
//

void WSGRegisterResult(POM_PRIMARY        pomPrimary,
                                    POM_WSGROUP_REG_CB   pRegistrationCB,
                                    UINT             result);


//
//
// WSGRegisterRetry(...)
//
// This function is called wherever any of the workset group registration
// functions encounter a recoverable "error" situation, such as failing to
// get the ObManControl lock.
//
// This function checks if we've exceeded the retry count for this
// registration attempt and if not, reposts the OMINT_EVENT_WSGROUP_REGISTER
// event, so that the whole process is started again from Stage1.
//
// If we've run out of retries, WSGRegisterResult is invoked to post
// failure to the Client.
//
//

void WSGRegisterRetry(POM_PRIMARY       pomPrimary,
                                   POM_WSGROUP_REG_CB  pRegistrationCB);


//
//
// ProcessSendReq(...)
//
// This function is called when an OMNET_WSGROUP_SEND_REQ message is
// received from another node (i.e.  a late joiner)
//
// The function starts the process of sending the workset group contents to
// the late joiner.
//
//
void ProcessSendReq(POM_PRIMARY pomPrimary,
                                 POM_DOMAIN           pDomain,
                                 POMNET_WSGROUP_SEND_PKT  pSendReq);


//
//
// SendWSGToLateJoiner(...)
//
// This function is called when the checkpointing for a workset has
// completed.  It sends the contents to the late joiner node.
//
//

void SendWSGToLateJoiner(POM_PRIMARY pomPrimary,
                                      POM_DOMAIN        pDomain,
                                      POM_WSGROUP           pWSGroup,
                                      NET_UID               lateJoiner,
                                      OM_CORRELATOR          remoteCorrelator);

//
//
// ProcessSendMidway(...)
//
// This function is called when an OMNET_WSGROUP_SEND_MIDWAY message is
// received from another node (the node which was helping us by sending us
// the contents of a workset group).
//
// We have now received all the WORKSET_CATCHUP messages (one for each
// workset).  If all is well we inform the client that registration has
// been successful and set the workset group state to
// PENDING_SEND_COMPLETE.
//
//

void ProcessSendMidway(POM_PRIMARY           pomPrimary,
                                    POM_DOMAIN          pDomain,
                                    POMNET_WSGROUP_SEND_PKT pSendMidwayPkt);


//
//
// ProcessSendComplete(...)
//
// This function is called when an OMNET_WSGROUP_SEND_COMPLETE message is
// received from another node (the node which was helping us by sending us
// the contents of a workset group).
//
// If this message relates to the ObManControl workset group, we now have
// most of the ObManControl workset group (only "most" since there could be
// some recent objects still flying around).
//
// However, we do know that we have ALL the contents of workset #0 in
// ObManControl, since that workset is only ever altered under lock.
//
// Accordingly, we now consider ourselves to be fully-fledged members of
// the Domain, in the sense that we can correctly process our Clients
// requests to register with workset groups.
//
// If the message relates to another workset group, we now have enough of
// its contents to consider ourselves eligible to help other late joiners
// (as we have just been).  Therefore, we announce this eligibilty
// throughout the Domain (using the ObManControl workset group).
//
//

UINT ProcessSendComplete(
                         POM_PRIMARY             pomPrimary,
                         POM_DOMAIN            pDomain,
                         POMNET_WSGROUP_SEND_PKT   pSendCompletePkt);


//
//
// MaybeRetryCatchUp(...)
//
// This function is called on receipt of a DETACH indication from MCS or a
// SEND_DENY message from another node.  In both cases we compare the
// helperNode field in OM_WSGROUP structure with the userID and if they
// match then we retry the catch up.
//
// Depending on the workset group status we do the following:
//
// PENDING_SEND_MIDWAY : Retry the registration from the top.
// PENDING_SEND_COMPLETE : Just repeat the catch up.
//
// If there is no one to catch up from then we do the following depending
// on the workset group status:
//
// PENDING_SEND_MIDWAY : Retry the registration from the top.  Regardless
// of whether someone else is out there or not (they cannot be in the
// READY_TO_SEND state) we will end up in a consistent state.
//
// PENDING_SEND_COMPLETE : If two (or more) nodes are in this state and
// catching up from the same box who then leaves, they will have two
// partial sets of objects one of which may or may not be a subset of the
// other.  If there is no one else in the READY_TO_SEND state then each
// node needs to obtain a copy of all the objects in a given workset at the
// other node.
//
//

void MaybeRetryCatchUp(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN      pDomain,
                                    OM_WSGROUP_ID       wsGroupID,
                                    NET_UID             userID);


//
//
// IssueSendDeny(...)
//
// This function issues a SEND_DENY message to a remote node.
//
//
void IssueSendDeny(POM_PRIMARY pomPrimary,
                                  POM_DOMAIN    pDomain,
                                  OM_WSGROUP_ID     wsGroupID,
                                  NET_UID           sender,
                                  OM_CORRELATOR        remoteCorrelator);


//
//
// WSGRecordMove(...)
//
// This function moves the record for specified workset group from one
// Domain record to another, and posts events to all relevant Clients.  If
// does not check for name contention in the destination Domain.
//
//

void WSGRecordMove(POM_PRIMARY         pomPrimary,
                                POM_DOMAIN        pDestDomainRec,
                                POM_WSGROUP           pWSGroup);


//
//
// WSGMove(...)
//
// This function moves the record for specified workset group from one
// Domain record to another, and posts events to all relevant Clients.  If
// does not check for name contention in the destination Domain.
//
//

UINT WSGMove(POM_PRIMARY         pomPrimary,
                            POM_DOMAIN        pDestDomainRec,
                            POM_WSGROUP           pWSGroup);


//
//
// DomainAttach(...)
//
// This function calls MG_AttachUser to start the process of attaching to
// a Domain.  It also allocates and initialises the local structures
// associated with the Domain (the Domain record).
//
// A pointer to the newly-created Domain record is returned.
//
//

UINT DomainAttach(POM_PRIMARY          pomPrimary,
                                 UINT               callID,
                                 POM_DOMAIN *   ppDomainord);


//
//
// WSGRecordFindOrCreate(...)
//
// This function searches the workset group list in the specified Domain
// record for a workset group record whose name and FP match the ones
// specified.  If none is found, a new workset group record is allocated,
// initialised and inserted into the list.
//
// A pointer to the found-or-created workset group record is returned.
//
// NOTE: This function does not cause ObMan to join the workset group
//       channel or copy the workset group from another node if it
//       exists elsewhere; it merely creates the local structures for
//       the workset group.
//
//

UINT WSGRecordFindOrCreate(POM_PRIMARY pomPrimary,
                                          POM_DOMAIN     pDomain,
                                          OMWSG             wsg,
                                          OMFP            fpHandler,
                                          POM_WSGROUP *  ppWSGroup);


//
//
// ProcessSendQueue(...)
//
// This function prompts ObMan to examine the send queues for the specified
// Domain.  If there are any messages queued for sending (including remains
// of messages which have been partly sent), ObMan will try to send more
// data.  ObMan stops when either the send queues are all empty or the
// network layer has stopped giving us memory.
//
// The <domainRecBumped> flag indicates whether the Domain record has had
// its use count bumped; if TRUE, then this function calls UT_SubFreeShared
// to decrement the use count.
//
//

void ProcessSendQueue(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   BOOL             domainRecBumped);



//
// ProcessWSGDiscard(...)
//
void ProcessWSGDiscard(POM_PRIMARY pomPrimary, POM_WSGROUP pWSGroup);


//
// ProcessWSGMove(...)
//
UINT ProcessWSGMove(POM_PRIMARY    pomPrimary, long moveCBOffset);


//
// ProcessNetTokenGrab(...)
//
UINT ProcessNetTokenGrab(POM_PRIMARY           pomPrimary,
                                        POM_DOMAIN          pDomain,
                                        NET_RESULT              result);


//
// ProcessCMSTokenAssign(...)
//
void ProcessCMSTokenAssign(POM_PRIMARY         pomPrimary,
                                        POM_DOMAIN        pDomain,
                                        BOOL             success,
                                        NET_TOKEN_ID          tokenID);


//
// ProcessNetTokenInhibit(...)
//
UINT ProcessNetTokenInhibit(POM_PRIMARY          pomPrimary,
                                           POM_DOMAIN         pDomain,
                                           NET_RESULT             result);

//
// CreateObManControl(...)
//
UINT ObManControlInit(POM_PRIMARY   pomPrimary,
                                     POM_DOMAIN  pDomain);


//
// WSGDiscard(...)
//
void WSGDiscard(POM_PRIMARY pomPrimary,
                             POM_DOMAIN  pDomain,
                             POM_WSGROUP     pWSGroup,
                            BOOL fExit);


//
// IssueSendReq(...)
//
UINT IssueSendReq(POM_PRIMARY      pomPrimary,
                                 POM_DOMAIN     pDomain,
                                 POM_WSGROUP        pWSGroup,
                                 NET_UID            remoteNode);


//
// GenerateUnlockMessage(...)
//
UINT GenerateUnlockMessage(POM_PRIMARY          pomPrimary,
                                          POM_DOMAIN         pDomain,
                                          OM_WSGROUP_ID          wsGroupID,
                                          OM_WORKSET_ID          worksetID,
                                          POMNET_LOCK_PKT *  ppUnlockPkt);


//
// ProcessWSGRegister(...)
//
void ProcessWSGRegister(POM_PRIMARY  pomPrimary, POM_WSGROUP_REG_CB pRegCB);


//
// LockObManControl(...)
//
void LockObManControl(POM_PRIMARY         pomPrimary,
                                   POM_DOMAIN        pDomain,
                                   OM_CORRELATOR    *  pLockCorrelator);


//
//
// MaybeUnlockObManControl(...)
//
// If the LOCKED_OMC flag is set in the registration CB, then unlock the
// Obman Control workset and clear the LOCKED_OMC flag.
//
//

void MaybeUnlockObManControl(POM_PRIMARY      pomPrimary,
                                          POM_WSGROUP_REG_CB pRegistrationCB);


//
// WSGRecordCreate(...)
//
UINT WSGRecordCreate(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN     pDomain,
                                    OMWSG          wsg,
                                    OMFP           fpHandler,
                                    POM_WSGROUP *  ppWSGroup);


//
//
// WorksetDiscard(...)
//
// This function is called by WSGDiscard to discard the individual worksets
// of a workset group when the last local Client deregisters.  It discards
// the contents of the workset, frees the workset record itself and clears
// the worksets's entry in the workset group record.
//
// It is not called when a workset is closed, since closing a workset does
// not discard its contents.
//
//

void WorksetDiscard(POM_WSGROUP pWSGroup, POM_WORKSET * pWorkset, BOOL fExit);


//
// ProcessLockNotify(...)
//
void ProcessLockNotify(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN      pDomain,
                                    POM_WSGROUP         pWSGroup,
                                    POM_WORKSET        pWorkset,
                                    NET_UID             owner);


//
// SendMessagePkt(...)
//
UINT SendMessagePkt(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   POM_SEND_INST      pSendInst);


//
// SendMoreData(...)
//
UINT SendMoreData(POM_PRIMARY      pomPrimary,
                                 POM_DOMAIN     pDomain,
                                 POM_SEND_INST      pSendInst);


//
// StartReceive(...)
//
UINT StartReceive(POM_PRIMARY     pomPrimary,
                                 POM_DOMAIN    pDomain,
                                 POMNET_OPERATION_PKT pHeaderPkt,
                                 POM_WSGROUP       pWSGroup,
                                 POM_WORKSET      pWorkset,
                                 POM_OBJECT   pObj);


//
// ProcessMessage(...)
//
// This function takes a receive control block (generated by ReceiveData)
// and tries to process it as an ObMan message.  If the message can not be
// processed at this time, it is put on the bounce list.  If the message is
// an "enabling" message (one which might enable previously bounced
// messages to be processed now) the bounce queue is flushed.
//
// Since this function is also called to process bounced messages, and
// since we want to prevent deep recursion as one bounced "enabling"
// message prompts re-examination of the bounce queue etc., we use the
// <whatNext> parameter to determine whether the bounce list should be
// examined.
//
//

UINT ProcessMessage(POM_PRIMARY        pomPrimary,
                                   POM_RECEIVE_CB       pReceiveCB,
                                   UINT             whatNext);

#define OK_TO_RETRY_BOUNCE_LIST     1
#define DONT_RETRY_BOUNCE_LIST      2

//
// ReceiveData(...)
//
UINT ReceiveData(POM_PRIMARY        pomPrimary,
                                POM_DOMAIN       pDomain,
                                PNET_SEND_IND_EVENT  pNetSendInd,
                                POMNET_OPERATION_PKT pNetMessage);


//
// TryToSpoilOp
//
UINT TryToSpoilOp(POM_SEND_INST pSendInst);


//
// DecideTransferSize(...)
//
void DecideTransferSize(POM_SEND_INST  pSendInst,
                                     UINT *        pTransferSize,
                                     UINT *        pDataTransferSize);


//
// CreateReceiveCB(...)
//
UINT CreateReceiveCB(POM_DOMAIN       pDomain,
                                    PNET_SEND_IND_EVENT  pNetSendInd,
                                    POMNET_OPERATION_PKT pNetMessage,
                                    POM_RECEIVE_CB * ppReceiveCB);


//
// FindReceiveCB(...)
//
UINT FindReceiveCB(POM_DOMAIN        pDomain,
                                  PNET_SEND_IND_EVENT   pNetSendInd,
                                  POMNET_OPERATION_PKT  pDataPkt,
                                  POM_RECEIVE_CB *  ppReceiveCB);

//
// WSGRegisterAbort(...)
//
void WSGRegisterAbort(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   POM_WSGROUP_REG_CB pRegistrationCB);


//
//
// BounceMessage(...)
//
// cmf
//
//

void BounceMessage(POM_DOMAIN        pDomain,
                                POM_RECEIVE_CB        pReceiveCB);


//
//
// NewDomainRecord(...)
//
//

UINT NewDomainRecord(POM_PRIMARY pomPrimary, UINT callID, POM_DOMAIN * ppDomain);

void FreeDomainRecord(POM_DOMAIN * ppDomain);


//
// ProcessBouncedMessages(...)
//
void ProcessBouncedMessages(POM_PRIMARY      pomPrimary,
                                         POM_DOMAIN     pDomain);


void WSGResetBytesUnacked(POM_WSGROUP            pWSGroup);

//
// NewHelperCB()
// FreeHelperCB()
//
BOOL NewHelperCB(POM_DOMAIN        pDomain,
                                POM_WSGROUP           pWSGroup,
                                NET_UID               lateJoiner,
                                OM_CORRELATOR            remoteCorrelator,
                                POM_HELPER_CB   * ppHelperCB);

void FreeHelperCB(POM_HELPER_CB   * ppHelperCB);


void PurgePendingOps(POM_WORKSET pWorkset, POM_OBJECT pObj);



OMFP    OMMapNameToFP(LPCSTR szName);
LPCSTR  OMMapFPToName(OMFP fp);

OMWSG   OMMapNameToWSG(LPCSTR szName);
LPCSTR  OMMapWSGToName(OMWSG wsg);


#endif // _H_OM

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\sch.h ===
//
// Scheduler
//

#ifndef _H_SCH
#define _H_SCH


//
//
// CONSTANTS
//
//
#define SCH_MODE_ASLEEP  0
#define SCH_MODE_NORMAL  1
#define SCH_MODE_TURBO   2


//
// All of the following values are times in milliseconds.
//
#define SCH_PERIOD_NORMAL        200
#define SCH_PERIOD_TURBO         100
#define SCH_TURBO_MODE_DURATION 1000


#define SCH_EVENT_NAME "DCS_SCHEDULE_EVENT"



//
//
// PROTOTYPES
//
//
// Name:      SCH_Init
//
// Purpose:   Scheduler initialization function.
//
// Params:    None.
//
BOOL SCH_Init(void);

// Name:      SCH_Term
//
// Purpose:   Scheduler termination function.
//
// Returns:   Nothing.
//
// Params:    None.
//
void SCH_Term(void);

// Name:      SCH_ContinueScheduling
//
// Purpose:   Called by components when they want periodic scheduling to
//            continue.  They are guaranteed to get at least one more
//            periodic callback following a call to this function.
//            If they want further callbacks then they must call this
//            function again during their periodic processing.
//
// Returns:   Nothing.
//
// Params:    schedulingMode - either SCH_MODE_NORMAL or SCH_MODE_TURBO
//
// Operation:
//            SCH_MODE_NORMAL triggers periodic processing at 200ms
//            intervals (5 times a second)
//
//            SCH_MODE_TURBO triggers periodic processing at 100ms
//            intervals (10 times a second)
//
//            The scheduler automatically drops from SCH_MODE_TURBO back
//            to SCH_MODE_NORMAL after 1 second of turbo mode processing.
//
//            SCH_MODE_TURBO overrides SCH_MODE_NORMAL, so if calls to
//            this function are made with SCH_MODE_NORMAL when the
//            scheduler is in TURBO mode, TURBO mode continues.
//
//            If this function is not called during processing of a
//            scheduler callback message then the scheduler enters
//            SLEEP mode - and will not generate any more periodic
//            callbacks until it is woken by another call to
//            this function, or until the output accumulation code
//            signals the scheduler's event.
//
void SCH_ContinueScheduling(UINT schedulingMode);

// Name:      SCH_SchedulingMessageProcessed
//
// Purpose:   A feedback function called by the Share Core to signal that
//            a scheduler message has been received.  This ensures that
//            that the scheduler only ever has one scheduler message
//            outstanding at a time.
//
// Returns:   Nothing.
//
// Params:    None.
//
void SCH_SchedulingMessageProcessed(void);

// Name:      SCH_PacingProcessor
//
// Purpose:   The main function executed by the scheduling thread.
//
// Returns:   Zero.
//
// Params:    syncObject - object to pass back to COM_SignalThreadStarted
//
// Operation: The thread enters a main loop which continues while the
//            scheduler is initialized.
//
//            The thread sets its priority to TIME_CRITICAL in order
//            that it runs as soon as possible when ready.
//
//            The thread waits on an event (schEvent) with a timeout that
//            is set according to the current scheduler mode.
//
//            The thread runs due to either:
//              - the timeout expiring, which is the normal periodic
//                scheduler behavior, or
//              - schEvent being signalled, which is how the scheduler is
//                woken from ASLEEP mode.
//
//            The thread then posts a scheduler message the the Share Core
//            (if there is not one already outstanding) and loops back
//            to wait on schEvent.
//
//            Changes in the scheduler mode are caused by calls to
//            SCH_ContinueScheduling updating variables accessed in this
//            routine, or by calculations made within the main loop of
//            this routine (e.g. TURBO mode timeout).
//
DWORD WINAPI SCH_PacingProcessor(LPVOID lpParam);



void SCHSetMode(UINT newMode);
void SCHPostSchedulingMessage(void);


#endif // _H_SCH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\shm.h ===
//
// Shared Memory Manager
//

#ifndef _H_SHM
#define _H_SHM


#include <oa.h>
#include <ba.h>
#include <osi.h>
#include <sbc.h>
#include <cm.h>


//
// List of component IDs for the data blocks passed around using shared
// memory.
//
#define SHM_OA_DATA                     0
#define SHM_OA_FAST                     1
#define SHM_BA_FAST                     2
#define SHM_CM_FAST                     3

//
// Number of components (actual number of entries in the above list).
//
#define SHM_NUM_COMPONENTS              4

//
// Structure to keep track of the buffer being used to pass data between
// the display driver and the share core.
//
// busyFlag      - indicates whether the display driver is using the memory
//
// newBuffer     - index for which buffer the display driver should next
//                 use to access the memory.
//
// currentBuffer - index for the buffer in use by the display driver if
//                 busyFlag is set.
//                 THIS FIELD IS USED ONLY BY THE DISPLAY DRIVER
//
// indexCount    - count of how many times we have recursed into accessing
//                 the buffer.  The busyFlag and currentBuffer should only
//                 be updated if indexCount was set to or changed from 0.
//                 THIS FIELD IS USED ONLY BY THE DISPLAY DRIVER
//
// bufferBusy    - indicates whether a particular buffer is being used
//                 by the display driver.
//
//
typedef struct tagBUFFER_CONTROL
{
    long    busyFlag;
    long    newBuffer;
    long    currentBuffer;
    long    indexCount;
    long    bufferBusy[2];
} BUFFER_CONTROL;
typedef BUFFER_CONTROL FAR * LPBUFFER_CONTROL;


//
// Shared memory as used by the display driver and share core to
// communicate.
//
// On Win95, we can not easily address memory that isn't in a 64K segment
// So on both platforms, when we map the shared memory, we also return pointers
// to the CM_FAST_DATA structures anda the OA_FAST_DATA structures, each of
// which lives in its own segment.
//
// On NT, the CM_FAST_DATA blocks come right after this one, then the 
// OA_SHARED_DATA blocks.
//
//
//  GENERAL
//  =======
//
// dataChanged   - flags to indicate if a data block has been altered
//                 (only used by the share core)
//
//  FAST PATH DATA
//  ==============
//
// fastPath      - buffer controls
//
// oaFast        - OA fast changing data
//
// baFast        - BA fast changing data
//
//  DISPLAY DRIVER -> SHARE CORE
//  ============================
//
// displayToCore - buffer controls
//
//
typedef struct tagSHM_SHARED_MEMORY
{
    //
    // Flag set by display driver when the display is in full screen mode.
    // (e.g. DOS full screen).
    //
    DWORD           fullScreen;

    //
    // Flag set by display driver or core when system palette has altered
    //
    LONG            pmPaletteChanged;

    //
    // Flag set by display driver when the cursor is hidden.
    //
    LONG            cmCursorHidden;

    //
    // Data passed from the Display Driver up to the Share Core.
    //
    BUFFER_CONTROL  displayToCore;


    long            dataChanged[SHM_NUM_COMPONENTS];

    //
    // Data passed regularly from the Display Driver to the Share Core.
    //
    // This buffer is switched on each periodic processing by the share
    // core.  If the criteria for reading are satisfied, the main DD->SHCO
    // buffer is switched.
    //
    BUFFER_CONTROL  fastPath;

    BA_FAST_DATA    baFast[2];

    OA_FAST_DATA    oaFast[2];

    CM_FAST_DATA    cmFast[2];

    //
    // DO NOT BUMP SHARED MEMORY SIZE PAST 64K
    // 16-bit display driver puts each oaData in a 64K block
    // The SHM_ESC_MAP_MEMORY request returns back the pointers
    // to each oaData in addition to the shared memory block.  In the
    // the case of the 32-bit NT display driver, the memory allocated is
    // in fact contiguous, so there's no waste in that case.
    //
} SHM_SHARED_MEMORY;
typedef SHM_SHARED_MEMORY FAR * LPSHM_SHARED_MEMORY;



//
// Macros to access the shared memory
//
//
//  OVERVIEW
//  ~~~~~~~~
//
// Note the following sets of macros are split into two parts - one for
// accessing memory from the NT kernel and one for the Share Core.  This
// code plays a significant role in the synchronization of the shared
// memory, so make sure you know how it works...
//
// The shared memory is double buffered, so that the kernel mode display
// driver can come in at any point and is NEVER blocked by the share core
// for access.  The data is split into two major blocks - one to pass data
// from the kernel to the Share Core and the other to pass the data back.
//
// The macros assume a certain structure to the shared memory which is
// described below.
//
// NO VALIDATION OF POINTERS IS DONE IN THESE MACROS.
//
//
//  DISPLAY DRIVER ACCESS
//  ~~~~~~~~~~~~~~~~~~~~~
//
//                    Ŀ
//                     Shared Memory                
//                     ~~~~~~~~~~~~~                
//                                                  
//                     ͻ  ͻ 
//                                              
//                      kernel       fast path  
//                       -> SHCO                
//                                              
//                                              
//                      (details                
//                         below)               
//                                              
//                     ͼ  ͼ 
//                    
//
//
//
//        ͻ
//         Kernel to share core data block                     
//         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                     
//          Ŀ               Ŀ  
//                            busyFlag                     
//           Share Core           1        Display Driver  
//                                                         
//           (read buffer)    newBuffer    (write buffer)  
//                                                        
//                         <>                 
//           bufferBusy                    bufferBusy      
//               0                             1           
//                          currentBuffer                  
//                                                        
//                                >                 
//                                                         
//                                                         
//                           indexCount                    
//                                5                        
//                           
//                                                             
//                                                             
//        ͼ
//
// The entire major block has a busyFlag, which indicates if the display
// driver is accessing any of its shared memory.  This flag is set as soon
// as the display driver needs access to the shared memory (i.e.  on entry
// to the display driver graphics functions).
//
// The display driver then reads the index (newBuffer in the above drawing)
// to decide which buffer to use.  This is stored in the currentBuffer
// index to use until the display driver releases the shared memory.  The
// secondary bufferBusy is now set for the buffer in use.
//
// The indexCount is maintained of the number of times the display driver
// has started access to a block of memory so that (both) busyFlag and
// bufferBusy can be released when the display driver has truly finished
// with the memory.
//
//
//  SHARE CORE ACCESS
//  ~~~~~~~~~~~~~~~~~
//
// To access the shared memory, the share core just pulls out the data from
// the buffer that the Share Core is not using (ie.  the buffer pointed to
// by NOT newBuffer).
//
// The synchronization between the two processes comes from the buffer
// switch.
//
//
//  BUFFER SWITCHING (AND SYNCHRONIZATION)
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Buffer switching is determined by the Share Core.  Data is accumulated
// by the Share Core and sent on the periodic timing events.  For full
// details on the swapping method, refer to NSHMINT.C
//
// Data (such as window tracking) can be passed down at the meoment it is
// generated by using the OSI functions.
//
// The Share Core also determines when it wants to get the latest set of
// orders and screen data area and forces the switch.  This is detailed in
// NSHMINT.C
//
//
//  THE MACROS!
//  ~~~~~~~~~~~
//
// So, now we know a bit about the shared memory, what macros do we have to
// access the shared memory?  Here goes...
//
//
//  SHM_SYNC_READ      - Force a sync of the read buffer between the tasks.
//                       This should be called only by the Share Core.
//
//  SHM_SYNC_FAST      - Force a sync of the fast path buffer.
//                       This should be called only by the Share Core.
//
//
#ifdef DLL_DISP

LPVOID  SHM_StartAccess(int block);

void    SHM_StopAccess(int block);


//
// Macro to check any pointers that we are going to dereference.
//
#ifdef _DEBUG
void    SHM_CheckPointer(LPVOID ptr);
#else
#define SHM_CheckPointer(ptr)
#endif // _DEBUG


#else // !DLL_DISP

void  SHM_SwitchReadBuffer(void);

void  SHM_SwitchFastBuffer(void);

#endif // DLL_DISP


#endif // _H_SHM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\swl.h ===
//
// Shared Window List
//

#ifndef _H_SWL
#define _H_SWL


//
// Max # of entries we can send in SWL packet; backwards compat thing.
// Also, we keep a bunch of static arrays around so we know if stuff has
// changed.
//
#define SWL_MAX_WINDOWS             100


//
// Return codes.
//

#define SWL_RC_ERROR    0
#define SWL_RC_SENT     1
#define SWL_RC_NOT_SENT 2




//
// CONSTANTS
//

//
// Window property flags
//
#define SWL_PROP_INVALID        0x00000000
#define SWL_PROP_COUNTDOWN_MASK 0x00000003
#define SWL_PROP_INITIAL        0x00000004
#define SWL_PROP_TAGGABLE       0x00000020
#define SWL_PROP_TASKBAR        0x00000040
#define SWL_PROP_SHADOW         0x00000100
#define SWL_PROP_IGNORE         0x00000200
#define SWL_PROP_HOSTED         0x00000400
#define SWL_PROP_TRANSPARENT    0x00000800
#define SWL_PROP_SAVEBITS       0x00001000


//
// We still need this SWL token stuff for backwards compatibility (<= NM 2.1)
// Those systems treat the shared apps from all the different participants
// in a global fashion.
//
// Even so, back level systems may not be able to keep up if a lot of NM 3.0
// systems are sharing--but that happens even among an all 2.1 conference.
// With collisions, zordering, etc. a sharer may back off or drop packets.
//
#define SWL_SAME_ZORDER_INC             1
#define SWL_NEW_ZORDER_INC              2
#define SWL_NEW_ZORDER_ACTIVE_INC       3
#define SWL_NEW_ZORDER_FAKE_WINDOW_INC  4
#define SWL_EXIT_INC                    5

#define SWL_MAKE_TOKEN(index, inc)  (TSHR_UINT16)(((index) << 4) | (inc))

#define SWL_GET_INDEX(token)            ((token) >> 4)
#define SWL_MAX_TOKEN_INDEX             0x0FFF

#define SWL_GET_INCREMENT(token)        ((token) & 0x000F)




//
// This is the number of times we must consecutively see a window as
// invisible before we believe it is - see comments in aswlint.c explaining
// why we must do this.
//
#define SWL_BELIEVE_INVISIBLE_COUNT   2


//
// Name of the SWL Global Atom
//
#define SWL_ATOM_NAME               "AS_StateInfo"


//
// For each sharer in the conference, we remember the last shared list
// they sent us--the HWNDs (on their machine, no meaning on ours), the
// state information, and the position.  
//
// We use this for several purposes:
// (1) 2.x compatibility
//      2.x sharers, when they send SWL lists, do not fill in the position
// of shadows representing other remote app windows.  Those will appear
// in the list if they obscure parts of shared windows on the 2.x host.  The
// old 2.x code would look up the last position info in the global shared
// list, and use that.  We need the position info to accurately compute
// the obscured regions for a particular host.  3.0 sharers don't have
// shadows, they never send incomplete info.
//
// (2) For better UI in the host view
//      We can remember where the window on top is, where the active window
// is (if a 3.0 host), if a window is minimized, etc.  Since we don't have
// independent fake windows floating with tray buttons you can manipulate
// on a remote to manipulate the host, minimized windows will disappear.
// Only Alt-Tabbing (when controlling) can activate and restore them.
//


//
// DESKTOP types
//
enum
{
    DESKTOP_OURS = 0,
    DESKTOP_WINLOGON,
    DESKTOP_SCREENSAVER,
    DESKTOP_OTHER
};

#define NAME_DESKTOP_WINLOGON       "Winlogon"
#define NAME_DESKTOP_SCREENSAVER    "Screen-saver"
#define NAME_DESKTOP_DEFAULT        "Default"

#define SWL_DESKTOPNAME_MAX         64


#ifdef __cplusplus

// Things we need for enumeration of top level windows
typedef struct tagSWLENUMSTRUCT
{
    class ASHost *   pHost;
    BOOL        fBailOut;
    UINT        transparentCount;
    UINT        count;
    LPSTR       newWinNames;
    PSWLWINATTRIBUTES   newFullWinStruct;
}
SWLENUMSTRUCT, * PSWLENUMSTRUCT;

#endif // __cplusplus


BOOL CALLBACK SWLDestroyWindowProperty(HWND, LPARAM);


BOOL CALLBACK SWLEnumProc(HWND hwnd, LPARAM lParam);


#endif // _H_SWL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\usr.h ===
//
// Update Shared Regions
//

#ifndef _H_USR
#define _H_USR

//
//                                                                         
// CONSTANTS                                                               
//                                                                         
//

//
// Drawing order support constants.                                        
//
#define MAX_X_SIZE               128
#define MEGA_X_SIZE              256
#define MEGA_WIDE_X_SIZE        1024




//
// Used for bitmap and cache hatching.
//
#define USR_HATCH_COLOR_RED  1
#define USR_HATCH_COLOR_BLUE 2



//
// Default order packet sizes.                                             
//                                                                         
// Note that this is the size of the initially allocated packet.  After the
// packet has been processed by the General Data Compressor (GDC) the      
// transmitted packet size may well be smaller than the specified value.   
//                                                                         
// Also note that (in general) the smaller the order packets are, the worse
// the GDC compression ratio will be (it prefers to compress big packets). 
//                                                                         
//

#define SMALL_ORDER_PACKET_SIZE  0x0C00
#define LARGE_ORDER_PACKET_SIZE  0x7800




//
//                                                                         
// PROTOTYPES                                                              
//                                                                         
//


//
//
// Force the window to redraw along with all its children.  (Need to use   
// RDW_ERASENOW flag because otherwise RedrawWindow makes the mistake of  
// posting the WM_PAINT before the WM_ERASE.  BeginPaint call will validate
// all of the window so the WM_ERASE will have a null update region).      
//
#if defined(DLL_CORE) || defined(DLL_HOOK)
 
void __inline USR_RepaintWindow(HWND hwnd)
{
    UINT    flags = RDW_FRAME | RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN;

    if (hwnd)
    {
        //
        // Only erasenow/updatenow for top level windows.  The desktop's
        // children are all on different threads, this would cause out-of-
        // order results.
        //
        flags |= RDW_ERASENOW | RDW_UPDATENOW;
    }

    RedrawWindow(hwnd, NULL, NULL, flags);
}

#endif // DLL_CORE or DLL_HOOK




#endif // _H_USR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\ssi.h ===
//
// SaveScreenbits Interceptor
//

#ifndef _H_SSI
#define _H_SSI


//
// CONSTANTS
//
#define ST_FAILED_TO_SAVE           0
#define ST_SAVED_BY_DISPLAY_DRIVER  1
#define ST_SAVED_BY_BMP_SIMULATION  2


//
// Maximum depth of save bitmaps we can handle.
//
#define SSB_MAX_SAVE_LEVEL  6

//
// Define the values that can be passed in the flags field of
// SaveScreenBits.
//
// These should be defined in a Windows header - but they are not. In any
// case they are referred to in generic code, so need to be defined here.
//

//
// There are the display driver's SaveBits routine command values, and we
// use them also in our protocol.
//
#define ONBOARD_SAVE        0x0000
#define ONBOARD_RESTORE     0x0001
#define ONBOARD_DISCARD     0x0002


//
//
// MACROS
//
//

//
// Macro that makes it easier (more readable) to access the current
// local SSB state.
//
#define CURRENT_LOCAL_SSB_STATE \
  g_ssiLocalSSBState.saveState[g_ssiLocalSSBState.saveLevel]


#define ROUNDUP(val, granularity) \
  ((val+(granularity-1)) / granularity * granularity)


//
// Specific values for OSI escape codes
//
#define SSI_ESC(code)                   (OSI_SSI_ESC_FIRST + code)

#define SSI_ESC_RESET_LEVEL             SSI_ESC(0)
#define SSI_ESC_NEW_CAPABILITIES        SSI_ESC(1)


//
//
// TYPES
//
//

//
// Local SaveScreenBitmap state structures.
//
typedef struct tagSAVE_STATE
{
    int         saveType;           // ST_xxxx
    HBITMAP     hbmpSave;           // SPB bitmap from USER
    BOOL        fSavedRemotely;
    DWORD       remoteSavedPosition;// valid if (fSavedRemotely == TRUE)
    DWORD       remotePelsRequired; // valid if (fSavedRemotely == TRUE)
    RECT        rect;
} SAVE_STATE, FAR * LPSAVE_STATE;

typedef struct tagLOCAL_SSB_STATE
{
    WORD        xGranularity;
    WORD        yGranularity;
    int         saveLevel;
    SAVE_STATE  saveState[SSB_MAX_SAVE_LEVEL];
} LOCAL_SSB_STATE, FAR* LPLOCAL_SSB_STATE;

//
// Remote SaveScreenBitmap structures.
//
typedef struct tagREMOTE_SSB_STATE
{
    DWORD           pelsSaved;
}
REMOTE_SSB_STATE, FAR* LPREMOTE_SSB_STATE;


//
// SSI_RESET_LEVEL
//
// Resets saved level
//
typedef struct tagSSI_RESET_LEVEL
{
    OSI_ESCAPE_HEADER   header;
}
SSI_RESET_LEVEL;
typedef SSI_RESET_LEVEL FAR * LPSSI_RESET_LEVEL;


//
// Structure: SSI_NEW_CAPABILITIES
//
// Description:
//
// Structure to pass new capabilities down to the display driver from the
// Share Core.
//
//
typedef struct tagSSI_NEW_CAPABILITIES
{
    OSI_ESCAPE_HEADER header;           // Common header

    DWORD           sendSaveBitmapSize;  // Size of the save screen bitmap

    WORD            xGranularity;     // X granularity for SSB

    WORD            yGranularity;     // Y granularity for SSB

}
SSI_NEW_CAPABILITIES;
typedef SSI_NEW_CAPABILITIES FAR * LPSSI_NEW_CAPABILITIES;



//
// FUNCTION: SSI_SaveScreenBitmap
//
//
// DESCRIPTION:
//
// The main SaveScreenBitmap function, called by the SaveScreenBitmap
// Interceptor (SSI).
//
// Saves, restores and discards the specified bits using the Display Driver
// and/or our own SaveScreenBitmap simulation.
//
// Sends the SaveScreenBitmap function as an order if possible.
//
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords).
//
// wCommand - SaveScreenBitmap command (SSB_SAVEBITS, SSB_RESTOREBITS,
// SSB_DISCARDBITS).
//
//
// RETURNS:
//
// TRUE if operation succeeded.  FALSE if operation failed.
//
//
BOOL SSI_SaveScreenBitmap(LPRECT lpRect, UINT wCommand);


#ifdef DLL_DISP
//
// FUNCTION:      SSI_DDProcessRequest
//
// DESCRIPTION:
//
// Called by the display driver to process an SSI specific request
//
// PARAMETERS:    pso   - pointer to surface object
//                cjIn  - (IN)  size of request block
//                pvIn  - (IN)  pointer to request block
//                cjOut - (IN)  size of response block
//                pvOut - (OUT) pointer to response block
//
// RETURNS:       None
//
//
BOOL    SSI_DDProcessRequest(UINT escapeFn, LPOSI_ESCAPE_HEADER pRequest, DWORD cbResult);

BOOL SSI_DDInit(void);
void SSI_DDTerm(void);

#ifdef IS_16

void SSI_DDViewing(BOOL);

void SSISaveBits(HBITMAP, LPRECT);
BOOL SSIRestoreBits(HBITMAP);
BOOL SSIDiscardBits(HBITMAP);
BOOL SSIFindSlotAndDiscardAbove(HBITMAP);

#else

BOOL SSISaveBits(LPRECT lpRect);
BOOL SSIRestoreBits(LPRECT lpRect);
BOOL SSIDiscardBits(LPRECT lpRect);
BOOL SSIFindSlotAndDiscardAbove(LPRECT lpRect);

#endif // IS_16

#endif // DLL_DISP


void SSIResetSaveScreenBitmap(void);


BOOL SSISendSaveBitmapOrder( LPRECT lpRect, UINT  wCommand );

void SSISetNewCapabilities(LPSSI_NEW_CAPABILITIES pssiNew);

DWORD SSIRemotePelsRequired(LPRECT lpRect);

     
#endif // _H_SSI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\view.h ===
//
// View UI to present shared applications/desktop of a remote host
//

#ifndef _H_VIEW
#define _H_VIEW


//
//
// CONSTANTS
//
//

//
// The class name of the frame containing the view of shared applications
// from a particular user.
//
#define VIEW_FRAME_CLASS_NAME           "AS_Frame"
#define VIEW_CLIENT_CLASS_NAME          "AS_Client"
#define VIEW_WINDOWBAR_CLASS_NAME       "AS_WindowBar"
#define VIEW_WINDOWBARITEMS_CLASS_NAME  "AS_WindowBarItems"
#define VIEW_FULLEXIT_CLASS_NAME        "AS_FullExit"


//
// Metrics
//

//
// LAURABU:  For international, consider making this larger (i.e, German,
// Slavic, and DBCS systems)
//
#define VIEW_MAX_ITEM_CHARS             20

//
// IDs
//
#define IDVIEW_ITEMS         1      // Window bar item list
#define IDVIEW_SCROLL        2      // Window bar scroll
#define IDT_AUTOSCROLL      50      // Period is DoubleClick time metric


//
// WindowBar ITEM struct
//
typedef struct tagWNDBAR_ITEM
{
    STRUCTURE_STAMP

    BASEDLIST           chain;

    UINT_PTR            winIDRemote;
    TSHR_UINT32         flags;
    char                szText[SWL_MAX_WINDOW_TITLE_SEND + 1];
}
WNDBAR_ITEM;
typedef WNDBAR_ITEM *   PWNDBAR_ITEM;


//
// Init/Term
//
BOOL VIEW_Init(void);
void VIEW_Term(void);


//
// Frame
//
LRESULT CALLBACK VIEWFrameWindowProc(HWND, UINT, WPARAM, LPARAM);


//
// View
//
LRESULT CALLBACK VIEWClientWindowProc(HWND, UINT, WPARAM, LPARAM);

//
// WindowBar
//
LRESULT CALLBACK VIEWWindowBarProc(HWND, UINT, WPARAM, LPARAM);

//
// WindowBar Items
//
LRESULT CALLBACK VIEWWindowBarItemsProc(HWND, UINT, WPARAM, LPARAM);

//
// FullScreen Exit
//
LRESULT CALLBACK VIEWFullScreenExitProc(HWND, UINT, WPARAM, LPARAM);

//
// Informational dialog
//
INT_PTR    CALLBACK VIEWDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // _H_VIEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\t_share.h ===
//
// T.SHARE protocol
//

#ifndef _H_T_SHARE
#define _H_T_SHARE


//
// TSHARE PROTOCOL STRUCTURES
// These are defined in a way that keeps the offsets and total sizes the 
// same, regardless of whether this header is included in 32-bit code, 
// 16-bit code, big-endian code, etc.
//
// We make special types to avoid inadvertenly altering something else and
// breaking the structure.  The TSHR_ prefix helps make this clear.
//


////////////////////////////////
//
// BASIC TYPES
//
////////////////////////////////

typedef char                                  TSHR_CHAR;
typedef TSHR_CHAR           FAR*            LPTSHR_CHAR;
typedef TSHR_CHAR UNALIGNED FAR*            LPTSHR_CHAR_UA;


typedef signed char                           TSHR_INT8;
typedef TSHR_INT8           FAR*            LPTSHR_INT8;
typedef TSHR_INT8 UNALIGNED FAR*            LPTSHR_INT8_UA;

typedef BYTE                                  TSHR_UINT8;
typedef TSHR_UINT8          FAR*            LPTSHR_UINT8;  
typedef TSHR_UINT8 UNALIGNED FAR *          LPTSHR_UINT8_UA;


typedef short                                 TSHR_INT16;
typedef TSHR_INT16          FAR*            LPTSHR_INT16;
typedef TSHR_INT16 UNALIGNED FAR *          LPTSHR_INT16_UA;

typedef unsigned short                        TSHR_UINT16;
typedef TSHR_UINT16         FAR*            LPTSHR_UINT16;
typedef TSHR_UINT16 UNALIGNED FAR *         LPTSHR_UINT16_UA;


typedef long                                  TSHR_INT32;
typedef TSHR_INT32          FAR*            LPTSHR_INT32;
typedef TSHR_INT32  UNALIGNED FAR *         LPTSHR_INT32_UA;

typedef unsigned long                         TSHR_UINT32;
typedef TSHR_UINT32         FAR*            LPTSHR_UINT32;
typedef TSHR_UINT32 UNALIGNED FAR *         LPTSHR_UINT32_UA;

// TSHR_PERSONID
typedef TSHR_UINT32         TSHR_PERSONID;
typedef TSHR_PERSONID *     LPTSHR_PERSONID;



// TSHR_POINT16 -- POINT with WORD fields

typedef struct tagTSHR_POINT16
{
    TSHR_INT16      x;
    TSHR_INT16      y;
}
TSHR_POINT16;
typedef TSHR_POINT16 FAR * LPTSHR_POINT16;



// TSHR_POINT32 -- POINT with DWORD fields

typedef struct tagTSHR_POINT32
{
    TSHR_INT32      x;
    TSHR_INT32      y;
}
TSHR_POINT32;
typedef TSHR_POINT32 FAR * LPTSHR_POINT32;



// Conversion Macros
_inline void TSHR_POINT16_FROM_POINT(LPTSHR_POINT16 pPt16, POINT pt)
{
    pPt16->x = (TSHR_INT16)pt.x;
    pPt16->y = (TSHR_INT16)pt.y;
}

_inline void POINT_FROM_TSHR_POINT16(LPPOINT pPt, TSHR_POINT16 pt16)
{
    pPt->x = pt16.x;
    pPt->y = pt16.y;
}



// TSHR_RECT16 -- RECT with WORD fields

typedef struct tagTSHR_RECT16
{
    TSHR_INT16      left;
    TSHR_INT16      top;
    TSHR_INT16      right;
    TSHR_INT16      bottom;
}
TSHR_RECT16;
typedef TSHR_RECT16 FAR *   LPTSHR_RECT16;


// TSHR_RECT32 -- RECT with DWORD fields

typedef struct tagTSHR_RECT32
{
    TSHR_INT32      left;
    TSHR_INT32      top;
    TSHR_INT32      right;
    TSHR_INT32      bottom;
}
TSHR_RECT32;
typedef TSHR_RECT32 FAR *   LPTSHR_RECT32;



// Conversion Macros
#ifdef IS_16
#define TSHR_RECT16_FROM_RECT(lprcTshr, rc) \
    CopyRect((LPRECT)lprcTshr, &rc)

#define RECT_FROM_TSHR_RECT16(lprc, tshrrc) \
    CopyRect(lprc, (LPRECT)&tshrrc)

#else
_inline void TSHR_RECT16_FROM_RECT(LPTSHR_RECT16 pRect16, RECT rect)
{
    pRect16->left   = (TSHR_INT16)rect.left;
    pRect16->top    = (TSHR_INT16)rect.top;
    pRect16->right  = (TSHR_INT16)rect.right;
    pRect16->bottom = (TSHR_INT16)rect.bottom;
}

__inline void RECT_FROM_TSHR_RECT16(LPRECT pRect, TSHR_RECT16 rect16)
{
    pRect->left   = rect16.left;
    pRect->top    = rect16.top;
    pRect->right  = rect16.right;
    pRect->bottom = rect16.bottom;
}
#endif // IS_16



//
// TSHR_RGBQUAD
// =======
// rgbBlue         : blue value.
// rgbGreen        : green value.
//
// rgbRed          : red value.
// rgbReserved     : reserved.
//
typedef struct tagTSHR_RGBQUAD
{
    TSHR_UINT8   rgbBlue;
    TSHR_UINT8   rgbGreen;
    TSHR_UINT8   rgbRed;
    TSHR_UINT8   rgbReserved;
}
TSHR_RGBQUAD;
typedef TSHR_RGBQUAD FAR * LPTSHR_RGBQUAD;


//
// TSHR_COLOR
// =======
// red             : red value.
// green           : green value.
// blue            : blue value.
//
typedef struct tagTSHR_COLOR
{
    TSHR_UINT8   red;
    TSHR_UINT8   green;
    TSHR_UINT8   blue;
}
TSHR_COLOR;
typedef TSHR_COLOR FAR * LPTSHR_COLOR;


//
// TSHR_COLORS
// ========
// fg              : foreground color.
// bg              : background color.
//
typedef struct tagTSHR_COLORS
{
    TSHR_COLOR fg;
    TSHR_COLOR bg;
}
TSHR_COLORS;
typedef TSHR_COLORS FAR * LPTSHR_COLORS;


//
// BITMAPINFO_ours                                                         
// ===============                                                         
// bmiHeader       :                                                       
// bmiColors       :                                                       
//
typedef struct tagBITMAPINFO_ours
{
    BITMAPINFOHEADER   bmiHeader;
    TSHR_RGBQUAD          bmiColors[256];
}
BITMAPINFO_ours;



#define TSHR_RGBQUAD_TO_TSHR_COLOR(TshrRGBQuad, TshrColor)  \
        TshrColor.red = TshrRGBQuad.rgbRed;           \
        TshrColor.green = TshrRGBQuad.rgbGreen;       \
        TshrColor.blue = TshrRGBQuad.rgbBlue

#define TSHR_COLOR_TO_PALETTEENTRY(TshrColor, pe) \
        pe.peGreen = TshrColor.green;          \
        pe.peRed = TshrColor.red;              \
        pe.peBlue = TshrColor.blue;            \
        pe.peFlags = 0

#define TSHR_RGBQUAD_TO_PALETTEENTRY(TshrRGBQuad, pe) \
        pe.peRed   = TshrRGBQuad.rgbRed;           \
        pe.peGreen = TshrRGBQuad.rgbGreen;         \
        pe.peBlue  = TshrRGBQuad.rgbBlue;          \
        pe.peFlags = 0





//
// DATE
// =======
// day             : day of the month (1-31).
// month           : month (1-12).
// year            : year (e.g. 1996).
//
typedef struct tagTSHR_DATE
{
    TSHR_UINT8   day;
    TSHR_UINT8   month;
    TSHR_UINT16 year;
} TSHR_DATE;
typedef TSHR_DATE FAR * LPTSHR_DATE;


//
// TSHR_TIME
// =======
// hour            : hour (0-23).
// min             : minute (0-59).
// sec             : seconds (0-59).
// hundredths      : hundredths of a second (0-99).
//
typedef struct tagTSHR_TIME
{
    TSHR_UINT8   hour;
    TSHR_UINT8   min;
    TSHR_UINT8   sec;
    TSHR_UINT8   hundredths;
}
TSHR_TIME;
typedef TSHR_TIME FAR * LPTSHR_TIME;



//
// Maximum length of a person name                                         
//
#define TSHR_MAX_PERSON_NAME_LEN     48



//
// Common person information:  This is an ObMan object
//
typedef struct tagTSHR_PERSON_DATA
{
    char                personName[TSHR_MAX_PERSON_NAME_LEN];
    TSHR_PERSONID       personHandle;     // Call manager ID
}
TSHR_PERSON_DATA;
typedef TSHR_PERSON_DATA *  PTSHR_PERSON_DATA;




////////////////////////////////
//
// CAPABILITIES
//
////////////////////////////////


//
// Version numbers.
//
#define CAPS_VERSION_20         0x0200          // NM 2.x
#define CAPS_VERSION_30         0x0300          // NM 3.0
#define CAPS_VERSION_OLDEST_SUPPORTED   CAPS_VERSION_20
#define CAPS_VERSION_CURRENT            CAPS_VERSION_30

//
// Operating system and operating system version numbers.
//
#define CAPS_WINDOWS            0x0001

#define CAPS_WINDOWS_31         0x0001
#define CAPS_WINDOWS_95         0x0002
#define CAPS_WINDOWS_NT         0x0003

//
// Logical capabilities field values.
//
#define CAPS_UNDEFINED          0
#define CAPS_SUPPORTED          1
#define CAPS_UNSUPPORTED        2

//
// Number of order fields in the orders array.  This must never change
// because the fields within the capabilities structure must never move.
// If more orders fields are required then they must be added to the end of
// the capabilities structure.
//
#define CAPS_MAX_NUM_ORDERS     32

//
// String length of the driver name field in the capabilities structure.
// This allows for an 8.3 driver name (eg VGA.DRV), a NULL, and padding.
//
#define CAPS_DRIVER_NAME_LENGTH  16

//
// Capabilities (group structures) IDs currently defined.  Each ID
// corresponds to a different PROTCAPS structure. (See below).
//
#define CAPS_ID_GENERAL      1
#define CAPS_ID_SCREEN       2
#define CAPS_ID_ORDERS       3
#define CAPS_ID_BITMAPCACHE  4
#define CAPS_UNUSED_HCA      5
#define CAPS_UNUSED_FE       6
#define CAPS_UNUSED_AWC      7
#define CAPS_ID_CM           8
#define CAPS_ID_SC           9
#define CAPS_ID_PM          10
#define CAPS_UNUSED_SWL     11      // Used to be for regional window stuff




//
// Capabilities structure header.
//
typedef struct tagPROTCAPSHEADER
{
    TSHR_UINT16         capID;
    TSHR_UINT16         capSize;
}
PROTCAPSHEADER;


//
// Structure passed to CPC_RegisterCapabilities and returned by
// CPC_EnumerateCapabilities. The data field is of variable length (but
// always ends dword aligned).
//
typedef struct tagPROTCAPS
{
    PROTCAPSHEADER      header;
    TSHR_UINT32         data[1];
}
PROTCAPS;
typedef PROTCAPS *PPROTCAPS;



//
// Structure returned by CPC_GetCombinedCapabilities and as part of a
// NET_EV_PERSON_ADD event.
//
typedef struct tagPROTCOMBINEDCAPS_HEADER
{
    TSHR_UINT16         numCapabilities;
    TSHR_UINT16         pad1;
}
PROTCOMBINEDCAPS_HEADER;
typedef PROTCOMBINEDCAPS_HEADER * PPROTCOMBINEDCAPS_HEADER;

typedef struct tagPROTCOMBINEDCAPS
{
    PROTCOMBINEDCAPS_HEADER header;
    PROTCAPS            capabilities[1];
}
PROTCOMBINEDCAPS;
typedef PROTCOMBINEDCAPS * PPROTCOMBINEDCAPS;
typedef PPROTCOMBINEDCAPS * PPPROTCOMBINEDCAPS;




//
//
// Curent capabilities structure (corresponding to the generic structures
// defined above)....
//
// Note that these must be DWORD padded in size for the current code to
// work correctly on all platforms.
//
//


//
// AS type flags
//
#define AS_SERVICE      0x0001
#define AS_UNATTENDED   0x0002

//
// General capabilities.
//
typedef struct tagPROTCAPS_GENERAL
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         OS;                         
    TSHR_UINT16         OSVersion;                  
    TSHR_UINT16         version;                    
    TSHR_UINT16         supportsDOS6Compression;    // OBSOLETE
    TSHR_UINT16         genCompressionType;         // OBSOLETE
    TSHR_UINT16         typeFlags;                  // NEW FOR 3.0
    TSHR_UINT16         supportsCapsUpdate;         // almost OBSOLETE
    TSHR_UINT16         supportsRemoteUnshare;      // OBSOLETE

    // NEW FOR NM 2.0 NT && NM 2.1 WIN95
    TSHR_UINT16         genCompressionLevel;
    TSHR_UINT16         pad1;
}
PROTCAPS_GENERAL;
typedef PROTCAPS_GENERAL *PPROTCAPS_GENERAL;

#define PROTCAPS_GENERAL_SIZE_NM20      FIELD_OFFSET(PROTCAPS_GENERAL, genCompressionLevel)


//
// Values for genCompressionLevel
//
// Level 0 : Only GDC_PKZIP compression is allowed in entire share session
//           (genCompressionType indicates if a node supports it)
//           Bit 15 (PT_COMPRESSED) of packetType field is used to
//           indicate if a packet is compressed.
//
// Level 1 : Each nodes genCompressionType indicates which compression
//           algorithms it can use to DECOMPRESS packets.
//           A node can compress a packet with any compression algorithm
//           that the receiving node(s) can decompress with.
//           The top byte of packetType indicates which compression
//           algorithm a packet ahs been compressed with.
//
// If the genCompressionLevel field is not present in a nodes GENERAL
// capabilities then that node is assumed to be use level 0.
//
#define CAPS_GEN_COMPRESSION_LEVEL_0    ((TSHR_UINT16)0x0000)
#define CAPS_GEN_COMPRESSION_LEVEL_1    ((TSHR_UINT16)0x0001)

//
// Bitmap capabilities.
//
typedef struct tagPROTCAPS_SCREEN
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         capsBPP;
    TSHR_UINT16         capsSupports1BPP;           // OBSOLETE 3.0
    TSHR_UINT16         capsSupports4BPP;           // Almost OBSOLETE
    TSHR_UINT16         capsSupports8BPP;           // Almost OBSOLETE
    TSHR_UINT16         capsScreenWidth;
    TSHR_UINT16         capsScreenHeight;

    //
    // Need to keep this field unused for NM 2.0 interop.  
    // Can be reused when only care about NM 2.1 and above.
    //
    TSHR_UINT16         capsSupportsV1Compression;      // OBSOLETE

    TSHR_UINT16         capsSupportsDesktopResize;
    TSHR_UINT16         capsSupportsV2Compression;      // OBSOLETE

    //
    // NM 2.1 and earlier did NOT zero-init the caps structures.  Therefore
    // old pad fields can't be recovered until we only care about NM 3.0
    // compatibility and above.
    //
    TSHR_UINT16         pad1;

    // NEW FOR NM 3.0
    TSHR_UINT16         capsSupports24BPP;
    TSHR_UINT16         pad2;               // INIT THIS TO 0 ALWAYS; THEN IT CAN BE USED IN THE FUTURE
}
PROTCAPS_SCREEN;
typedef PROTCAPS_SCREEN *PPROTCAPS_SCREEN;

#define PROTCAPS_SCREEN_SIZE_NM21       FIELD_OFFSET(PROTCAPS_SCREEN, capsSupportsTrueColor)



//
// Orders capabilities.
//
typedef struct tagPROTCAPS_ORDERS
{
    PROTCAPSHEADER     header;
    TSHR_CHAR          capsDisplayDriver[CAPS_DRIVER_NAME_LENGTH];  // OBSOLETE
    TSHR_UINT32        capsSaveBitmapSize;
    TSHR_UINT16        capsSaveBitmapXGranularity;
    TSHR_UINT16        capsSaveBitmapYGranularity;
    TSHR_UINT16        capsSaveBitmapMaxSaveLevel;                  // OBSOLETE
    TSHR_UINT16        capsMaxOrderlevel;
    TSHR_UINT16        capsNumFonts;                                // OBSOLETE
    TSHR_UINT16        capsEncodingLevel;  // See below
    BYTE               capsOrders[CAPS_MAX_NUM_ORDERS];
    TSHR_UINT16        capsfFonts;         // only introduced at r1.1
    TSHR_UINT16        pad1;           // For DWORD alignment

    //
    // The size of the SSI save bitmap.
    //
    TSHR_UINT32        capsSendSaveBitmapSize;          // OBSOLETE
    //
    // The size of the SSI receive bitmap.
    //
    TSHR_UINT32        capsReceiveSaveBitmapSize;       // OBSOLETE
    TSHR_UINT16        capsfSendScroll;                 // OBSOLETE

    // NEW FOR NM 2.0 NT && NM 2.1 WIN95
    TSHR_UINT16        pad2;
}
PROTCAPS_ORDERS;
typedef PROTCAPS_ORDERS *PPROTCAPS_ORDERS;

#define PROTCAPS_ORDERS_SIZE_NM20       FIELD_OFFSET(PROTCAPS_ORDERS, pad2)



//
// Define the size of the bitmap used for the SaveBitmap order.            
// These dimensions must be multiples of the granularity values below.     
//
#define     TSHR_SSI_BITMAP_WIDTH           400
#define     TSHR_SSI_BITMAP_HEIGHT          400
#define     TSHR_SSI_BITMAP_SIZE            (TSHR_SSI_BITMAP_WIDTH * TSHR_SSI_BITMAP_HEIGHT)

#define     TSHR_SSI_BITMAP_X_GRANULARITY   1
#define     TSHR_SSI_BITMAP_Y_GRANULARITY   20


//
//
// These flags can be set in the capsfFonts fields. See also the defines
// below related to these flags (which must be updated when a new flag
// is defined).
//
#define CAPS_FONT_ASPECT            0x0001
#define CAPS_FONT_SIGNATURE         0x0002
#define CAPS_FONT_CODEPAGE          0x0004
#define CAPS_FONT_RESERVED1         0x0008      // Reserved for future BiDi support
#define CAPS_FONT_OLD_NEED_X        0x0010
#define CAPS_FONT_NEED_X_SOMETIMES  0x0020
#define CAPS_FONT_NEED_X_ALWAYS     0x0040
#define CAPS_FONT_R20_SIGNATURE     0x0080
#define CAPS_FONT_EM_HEIGHT         0x0100
#define CAPS_FONT_ALLOW_BASELINE    0x0200

//
// How the CAPS_FONT_XXX flags should be combined when adding a person to
// the share.
//
    //
    // AND these flags... the capability is relevant only if ALL parties
    // have it
    //
#define CAPS_FONT_AND_FLAGS     ( CAPS_FONT_ASPECT           \
                                | CAPS_FONT_SIGNATURE        \
                                | CAPS_FONT_R20_SIGNATURE    \
                                | CAPS_FONT_EM_HEIGHT        \
                                | CAPS_FONT_CODEPAGE         \
                                | CAPS_FONT_RESERVED1        \
                                | CAPS_FONT_ALLOW_BASELINE )
    //
    // OR these flags... the capability is relevant if ANY ONE party
    // requires it.
    //
#define CAPS_FONT_OR_FLAGS      ( CAPS_FONT_OLD_NEED_X       \
                                | CAPS_FONT_NEED_X_SOMETIMES \
                                | CAPS_FONT_NEED_X_ALWAYS    )

//
// Which of the CAPS_FONT_XXX flags should be switched on/off in the
// combined received capabilities when a person joins the call who does not
// have the capsfFonts field.
//
#define CAPS_FONT_OFF_FLAGS     ( CAPS_FONT_ASPECT    \
                                | CAPS_FONT_SIGNATURE \
                                | CAPS_FONT_CODEPAGE  \
                                | CAPS_FONT_RESERVED1 \
                                | CAPS_FONT_ALLOW_BASELINE )
#define CAPS_FONT_ON_FLAGS      ( 0                   )

#ifdef _DEBUG // for assertion
#define CAPS_FONT_R11_TEST_FLAGS    ( CAPS_FONT_ASPECT    \
                                    | CAPS_FONT_SIGNATURE \
                                    | CAPS_FONT_CODEPAGE  \
                                    | CAPS_FONT_RESERVED1 )
#endif

#define CAPS_FONT_R20_TEST_FLAGS    ( CAPS_FONT_R20_SIGNATURE \
                                    | CAPS_FONT_EM_HEIGHT )

//
// Level of order encoding support (capsEncodingLevel)
//
// These flags specify the types of order encoding and the level of
// negotiation supported.  The flags and their meanings are as follows.
//
// CAPS_ENCODING_BASE_OE
// - The base OE protocol is supported.  R1.1 does not support this.
// CAPS_ENCODING_OE2_NEGOTIABLE
// - We can negotiate whether OE2 is supported.  R1.1 does not support this.
// CAPS_ENCODING_OE2_DISABLED
// - OE2 is disabled on this machine.  This flag is apparently upside down
// so that we can support R1,1, which will set it to 0 (because the
// capability didn;t exist in R1.1).
// CAPS_ENCODING_ALIGNED_OE
// - The aligned OE protocol is supported.  R1.1 does not support this.
//
//
#define CAPS_ENCODING_BASE_OE               0x0001
#define CAPS_ENCODING_OE2_NEGOTIABLE        0x0002
#define CAPS_ENCODING_OE2_DISABLED          0x0004
#define CAPS_ENCODING_ALIGNED_OE            0x0008

//
// Encoding level
//
#define CAPS_ENCODING_DCGC20    ( CAPS_ENCODING_BASE_OE \
                                | CAPS_ENCODING_OE2_NEGOTIABLE)
//
// Encoding level supported by Millennium codebase
//
#define CAPS_ENCODING_DEFAULT   ( CAPS_ENCODING_OE2_NEGOTIABLE )

//
// Bitmap Cache capabilities.
//
typedef struct tagPROTCAPS_BITMAPCACHE_DETAILS
{
    TSHR_UINT16         capsSmallCacheNumEntries;
    TSHR_UINT16         capsSmallCacheCellSize;
    TSHR_UINT16         capsMediumCacheNumEntries;
    TSHR_UINT16         capsMediumCacheCellSize;
    TSHR_UINT16         capsLargeCacheNumEntries;
    TSHR_UINT16         capsLargeCacheCellSize;
}
PROTCAPS_BITMAPCACHE_DETAILS;

typedef struct tagPROTCAPS_BITMAPCACHE
{
    PROTCAPSHEADER  header;

    //
    // The following fields (which MUST immediately follow the header) are
    // used by the point to point R1.1 implementation only {
    //
    PROTCAPS_BITMAPCACHE_DETAILS r11Obsolete;       // OBSOLETE

    //
    // } end of fields used by point to point implementation only.
    //
    // The rest of this structure is only used by the multi-party code.
    //

    PROTCAPS_BITMAPCACHE_DETAILS sender;
    PROTCAPS_BITMAPCACHE_DETAILS receiver;          // OBSOLETE
}
PROTCAPS_BITMAPCACHE;
typedef PROTCAPS_BITMAPCACHE *PPROTCAPS_BITMAPCACHE;




//
// CM capabilities.
//
typedef struct tagPROTCAPS_CM
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         capsSupportsColorCursors;
    TSHR_UINT16         capsCursorCacheSize;
}
PROTCAPS_CM;
typedef PROTCAPS_CM * PPROTCAPS_CM;

#define TSHR_CM_CACHE_ENTRIES   25




//
// PM capabilities.
//
typedef struct tagPROTCAPS_PM
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         capsColorTableCacheSize;

    // NEW FOR NM 2.0 NT && NM 2.1 WIN95
    TSHR_UINT16         pad1;
}
PROTCAPS_PM;
typedef PROTCAPS_PM * PPROTCAPS_PM;

#define PROTCAPS_PM_SIZE_NM20   FIELD_OFFSET(PROTCAPS_PM, pad1)


#define TSHR_PM_CACHE_ENTRIES       6




//
// SC capabilities.
//
typedef struct tagPROTCAPS_SC
{
    PROTCAPSHEADER      header;
    TSHR_PERSONID       gccID;
}
PROTCAPS_SC;
typedef PROTCAPS_SC * PPROTCAPS_SC;




// If you add a PROTCAPS_ strcuture to CPCALLCAPS, update the count
#define PROTCAPS_COUNT      7

typedef struct tagCPCALLCAPS
{
    PROTCOMBINEDCAPS_HEADER header;
    PROTCAPS_GENERAL        general;
    PROTCAPS_SCREEN         screen;
    PROTCAPS_ORDERS         orders;
    PROTCAPS_BITMAPCACHE    bitmaps;
    PROTCAPS_CM             cursor;
    PROTCAPS_PM             palette;
    PROTCAPS_SC             share;
}
CPCALLCAPS;
typedef CPCALLCAPS * PCPCALLCAPS;



#if 0
//
// New 3.0 CAPS.  We've accumulated a lot of obsolete or garbage caps.  This
// is a condensed new basic set.  Note that orders is separated from general
// since it is the most likely one to be periodically added to.
//      * General
//      * Orders
//      * Hosting
//

#define ASCAPS_GENERAL          0
#define ASCAPS_ORDERS           1
#define ASCAPS_HOSTING          2

typedef struct tagTSHRCAPS_GENERAL
{
    PROTCAPSHEADER      header;

    TSHR_UINT16         protVersion;
    TSHR_UINT16         asMode;             // Unattended, streaming, service, no host, no view, etc.
    
    TSHR_UINT16         gccPersonID;        // GCC node ID;
    TSHR_UINT16         pktCompression;     // None, PKZIP, PersistPKZIP

    TSHR_UINT16         protBPPs;           // Color depths supported (4, 8, 24)
    TSHR_UINT16         screenBPP;
    TSHR_UINT16         screenWidth;
    TSHR_UINT16         screenHeight;
}
TSHRCAPS_GENERAL;
typedef TSHRCAPS_GENERAL * PTSHRCAPS_GENERAL;


typedef struct tagTSHRCAPS_ORDERS
{
    PROTCAPSHEADER      header;

}
TSHRCAPS_ORDERS;
typedef TSHRCAPS_ORDERS * PTSHRCAPS_ORDERS;



typedef struct tagTSHRCAPS_HOSTING
{
    PROTCAPSHEADER      header;

    //
    // These are zero if the host doesn't have such a thing, and viewers
    // should not therefore allocate memory for the caches.
    //
    TSHR_UINT32         ssiSaveBitsPixels;
    TSHR_UINT16         ssiSaveBitsXGranularity;
    TSHR_UINT16         ssiSaveBitsYGranularity;

    TSHR_UINT16         cmCursorCacheEntries;
    TSHR_UINT16         fhGlyphSetCacheEntries;
    TSHR_UINT16         pmPaletteCacheEntries;
    TSHR_UINT16         pad1;

    TSHR_UINT16         sbcSmallBmpCacheEntries;
    TSHR_UINT16         sbcSmallBmpCacheBytes;
    TSHR_UINT16         sbcMediumBmpCacheEntries;
    TSHR_UINT16         sbcMediumBmpCacheEntries;
    TSHR_UINT16         sbcLargeBmpCacheEntries;
    TSHR_UINT16         sbcLargeBmpCacheBytes;
}
TSHRCAPS_HOSTING;
typedef TSHRCAPS_HOSTING * PTSHRCAPS_HOSTING;


typedef struct tagTSHRCAPS_ORDERS
{
    PROTCAPSHEADER      header;

    TSHR_UINT16         ordCompression;     // Encoding types

    TSHR_UINT16         fhFontMatching;     // Font matching
    TSHR_UINT32         localeID;
    TSHR_UINT16         fhInternational;    // International text stuff

    TSHR_UINT16         ordNumOrders;       // Size of orders array
    TSHR_UINT8          ordOrders[CAPS_MAX_NUM_ORDERS];
}
TSHRCAPS_ORDERS;
typedef TSHRCAPS_ORDERS * PTSHRCAPS_ORDERS;

#endif

////////////////////////////////
//
// ORDERS
//
////////////////////////////////


//
//
// COM_ORDER_HEADER
//
// Any orders supplied to the accumulation functions must have
// the following fields filled in:
//
// cbOrderDataLength
//   The length in bytes of the order data (i.e. EXCLUDING the
//   header - which is always a fixed size).
//
// fOrderFlags
//   This can hold a combination of the following flags:
//
//   OF_SPOILER - the order can spoil earlier SPOILABLE ones that it
//                overlaps
//
//   OF_SPOILABLE - the order can be spoilt by SPOILER orders that overlap
//                  it
//
//   OF_BLOCKER - no orders before this one may be spoilt
//
//   OF_PRIVATE - a private order (used by bitmap caching code)
//
//   OF_NOTCLIPPED - this flag is set by OD2 on the DECODING side of the
//                   order processing to indicate that the order is not
//                   clipped. ie the rectangle is the bounding rectangle
//                   but does not result in any clipping taking place.
//                   THIS FLAG IS NOT TRANSMITTED ACROSS THE NETWORK.
//
//   OF_INTERNAL - the order is an internal order, and should not be sent
//                 over the wire.  An internal order is used to pass data
//                 from the device driver to the share core.
//
//   OF_DESTROP - the order has a ROP which relies on the contents of the
//                destination (relies on what is already on the screen).
//
// rcsDst
//   The bounding rectangle of the order in INCLUSIVE screen (pel) coords.
//
//
typedef struct tagCOM_ORDER_HEADER
{
    TSHR_UINT16         cbOrderDataLength;
    TSHR_UINT16         fOrderFlags;
    TSHR_RECT16         rcsDst;
}
COM_ORDER_HEADER;
typedef COM_ORDER_HEADER FAR * LPCOM_ORDER_HEADER;


//
// COM_ORDER_HEADER fOrderFlags values
//
#define OF_SPOILER          0x0001
#define OF_SPOILABLE        0x0002
#define OF_BLOCKER          0x0004
#define OF_PRIVATE          0x0008
#define OF_NOTCLIPPED       0x0010
#define OF_SPOILT           0x0020
#define OF_INTERNAL         0x0040
#define OF_DESTROP          0x0080


//
// Each type of order's structure is the bytes in abOrderData[].
//
typedef struct tagCOM_ORDER
{
    COM_ORDER_HEADER    OrderHeader;
    BYTE                abOrderData[1];
}
COM_ORDER;
typedef COM_ORDER           FAR * LPCOM_ORDER;
typedef COM_ORDER UNALIGNED FAR * LPCOM_ORDER_UA;


//
// Macro to calculate a basic common order size (including the Order
// Header).
//
#define COM_ORDER_SIZE(pOrder) \
    (pOrder->OrderHeader.cbOrderDataLength + sizeof(COM_ORDER_HEADER))




//
// The various drawing order structures have the following design objectives
//
//      the first field - type - is common to all orders.
//      field ordering is kept as regular as possible amongst similar
//          orders so that compression may find more regular sequences
//      fields are naturally aligned (dwords on dword boundaries etc)
//      fields are reordered so to preserve alignment rather than add
//          padding
//      padding is added as a last resort.
//      variable sized data comes at the end of the structure.
//
// All rectangles are inclusive of start and end points.
//
// All points are in screen coordinates, with (0,0) at top left.
//
// Interpretation of individual field values is as in Windows
//      in particular pens, brushes and font are as defined for Windows 3.1
//



//
// Orders - the high word is used as an index into a table
//        - the low word is a 2 character ASCII type descriptor and is the
//          only part actually passed in the order.
//
#define ORD_DSTBLT_INDEX        0x0000
#define ORD_PATBLT_INDEX        0x0001
#define ORD_SCRBLT_INDEX        0x0002
#define ORD_MEMBLT_INDEX        0x0003
#define ORD_MEM3BLT_INDEX       0x0004
#define ORD_TEXTOUT_INDEX       0x0005
#define ORD_EXTTEXTOUT_INDEX    0x0006
#define ORD_RECTANGLE_INDEX     0x0007
#define ORD_LINETO_INDEX        0x0008
#define ORD_UNUSED_INDEX        0x0009
#define ORD_OPAQUERECT_INDEX    0x000A
#define ORD_SAVEBITMAP_INDEX    0x000B
#define ORD_RESERVED_INDEX      0x000C
#define ORD_MEMBLT_R2_INDEX     0x000D
#define ORD_MEM3BLT_R2_INDEX    0x000E
#define ORD_POLYGON_INDEX       0x000F
#define ORD_PIE_INDEX           0x0010
#define ORD_ELLIPSE_INDEX       0x0011
#define ORD_ARC_INDEX           0x0012
#define ORD_CHORD_INDEX         0x0013
#define ORD_POLYBEZIER_INDEX    0x0014
#define ORD_ROUNDRECT_INDEX     0x0015
//
// It IS OK to use order 000C!  These numbers don't clash with OE2_* in
// aoe2int.h.  Replace ORD_RESERVED_INDEX (0xC) for the next new order.
//
// NOTE: When you use this index, OE_GetLocalOrderSupport must be updated
// to allow the order.
//

#define ORD_DSTBLT_TYPE         0x4244      // "DB"
#define ORD_PATBLT_TYPE         0x4250      // "PB"
#define ORD_SCRBLT_TYPE         0x4253      // "SB"
#define ORD_MEMBLT_TYPE         0x424d      // "MB"
#define ORD_MEM3BLT_TYPE        0x4233      // "3B"
#define ORD_TEXTOUT_TYPE        0x4f54      // "TO"
#define ORD_EXTTEXTOUT_TYPE     0x5445      // "ET"
#define ORD_RECTANGLE_TYPE      0x5452      // "RT"
#define ORD_LINETO_TYPE         0x544c      // "LT"
#define ORD_OPAQUERECT_TYPE     0x524f      // "OR"
#define ORD_SAVEBITMAP_TYPE     0x5653      // "SV"
#define ORD_MEMBLT_R2_TYPE      0x434d      // "MC"
#define ORD_MEM3BLT_R2_TYPE     0x4333      // "3C"
#define ORD_POLYGON_TYPE        0x4750      // "PG"
#define ORD_PIE_TYPE            0x4950      // "PI"
#define ORD_ELLIPSE_TYPE        0x4c45      // "EL"
#define ORD_ARC_TYPE            0x5241      // "AR"
#define ORD_CHORD_TYPE          0x4443      // "CD"
#define ORD_POLYBEZIER_TYPE     0x5A50      // "PZ"
#define ORD_ROUNDRECT_TYPE      0x5252      // "RR"


#define ORD_DSTBLT          MAKELONG(ORD_DSTBLT_TYPE, ORD_DSTBLT_INDEX)
#define ORD_PATBLT          MAKELONG(ORD_PATBLT_TYPE, ORD_PATBLT_INDEX)
#define ORD_SCRBLT          MAKELONG(ORD_SCRBLT_TYPE, ORD_SCRBLT_INDEX)
#define ORD_MEMBLT          MAKELONG(ORD_MEMBLT_TYPE, ORD_MEMBLT_INDEX)
#define ORD_MEM3BLT         MAKELONG(ORD_MEM3BLT_TYPE, ORD_MEM3BLT_INDEX)
#define ORD_TEXTOUT         MAKELONG(ORD_TEXTOUT_TYPE, ORD_TEXTOUT_INDEX)
#define ORD_EXTTEXTOUT      MAKELONG(ORD_EXTTEXTOUT_TYPE, ORD_EXTTEXTOUT_INDEX)
#define ORD_RECTANGLE       MAKELONG(ORD_RECTANGLE_TYPE, ORD_RECTANGLE_INDEX)
#define ORD_LINETO          MAKELONG(ORD_LINETO_TYPE, ORD_LINETO_INDEX)
#define ORD_OPAQUERECT      MAKELONG(ORD_OPAQUERECT_TYPE, ORD_OPAQUERECT_INDEX)
#define ORD_SAVEBITMAP      MAKELONG(ORD_SAVEBITMAP_TYPE, ORD_SAVEBITMAP_INDEX)
#define ORD_MEMBLT_R2       MAKELONG(ORD_MEMBLT_R2_TYPE, ORD_MEMBLT_R2_INDEX)
#define ORD_MEM3BLT_R2      MAKELONG(ORD_MEM3BLT_R2_TYPE, ORD_MEM3BLT_R2_INDEX)
#define ORD_POLYGON         MAKELONG(ORD_POLYGON_TYPE, ORD_POLYGON_INDEX)
#define ORD_PIE             MAKELONG(ORD_PIE_TYPE, ORD_PIE_INDEX)
#define ORD_ELLIPSE         MAKELONG(ORD_ELLIPSE_TYPE, ORD_ELLIPSE_INDEX)
#define ORD_ARC             MAKELONG(ORD_ARC_TYPE, ORD_ARC_INDEX)
#define ORD_CHORD           MAKELONG(ORD_CHORD_TYPE, ORD_CHORD_INDEX)
#define ORD_POLYBEZIER      MAKELONG(ORD_POLYBEZIER_TYPE, ORD_POLYBEZIER_INDEX)
#define ORD_ROUNDRECT       MAKELONG(ORD_ROUNDRECT_TYPE, ORD_ROUNDRECT_INDEX)


//
// The following order is special - support is not negotiated by the
// capsOrders field in the orders capabilities structure.
// The high words start at 32, ie after CAPS_MAX_NUM_ORDERS.
//
// ORD_NUM_INTERNAL_ORDERS is the number of orders we use internally - this
// include all CAPS_MAX_NUM_ORDERS, plus any of these special orders.
//
#define ORD_DESKSCROLL_INDEX    0x0020
#define ORD_DESKSCROLL_TYPE     0x5344      // "DS"
#define ORD_DESKSCROLL          MAKELONG(ORD_DESKSCROLL_TYPE, ORD_DESKSCROLL_INDEX)

#define INTORD_COLORTABLE_INDEX 0x000C
#define INTORD_COLORTABLE_TYPE  0x5443      // "CT"
#define INTORD_COLORTABLE       MAKELONG(INTORD_COLORTABLE_TYPE, INTORD_COLORTABLE_INDEX)

#define ORD_NUM_INTERNAL_ORDERS 33
#define ORD_NUM_LEVEL_1_ORDERS  22

#define ORD_LEVEL_1_ORDERS      1

//
// The maximum length of string which we will send as an order (either as
// TextOut or ExtTextOut) when a delta X array is supplied or not.
//
//
// NOTE:  THESE MUST TOTAL LESS THAN 256 BECAUSE THE TOTAL ENCODED SIZE 
// MUST FIT IN ONE BYTE.
//
//      STRING_LEN_WITHOUT_DELTAS       --  1 byte per char
//      STRING_LEN_WITH_DELTAS          --  1 byte per char + 1 byte per delta
//      ORD_MAX_POLYGON_POINTS          --  4 bytes per point (2 each coord)
//      ORD_MAX_POLYBEZIER_POINTS       --  4 bytes per point (2 each coord)
//
#define ORD_MAX_STRING_LEN_WITHOUT_DELTAS   255
#define ORD_MAX_STRING_LEN_WITH_DELTAS      127
#define ORD_MAX_POLYGON_POINTS              63
#define ORD_MAX_POLYBEZIER_POINTS           63

//
// Direction codes for arc drawing orders (pie, arc, chord).
// Specifies direction that pie, arc, and chord figures are drawn.
//
#define     ORD_ARC_COUNTERCLOCKWISE            1
#define     ORD_ARC_CLOCKWISE                   2

//
// Fill-mode codes for polygon drawing.
//
// Alternate fills area between odd-numbered and even-numbered polygon
// sides on each scan line.
//
// Winding fills any region with a nonzero winding value.
//
#define     ORD_FILLMODE_ALTERNATE              1
#define     ORD_FILLMODE_WINDING                2

//
// DstBlt (Destination only Screen Blt)
//
typedef struct _DSTBLT_ORDER
{
    TSHR_UINT16     type;           // holds "DB" - ORD_DSTBLT
    TSHR_INT16      pad1;

    TSHR_INT32      nLeftRect;      // x upper left
    TSHR_INT32      nTopRect;       // y upper left
    TSHR_INT32      nWidth;         // dest width
    TSHR_INT32      nHeight;        // dest height

    TSHR_UINT8      bRop;           // ROP
    TSHR_UINT8      pad2[3];
} DSTBLT_ORDER, FAR * LPDSTBLT_ORDER;

//
// PatBlt (Pattern to Screen Blt)
//
typedef struct _PATBLT_ORDER
{
    TSHR_UINT16    type;           // holds "PB" - ORD_PATBLT
    TSHR_INT16     pad1;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_COLOR         BackColor;
    TSHR_UINT8      pad2;
    TSHR_COLOR         ForeColor;
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

} PATBLT_ORDER, FAR * LPPATBLT_ORDER;

//
// ScrBlt (Screen to Screen Blt)
//
typedef struct _SCRBLT_ORDER
{
    TSHR_UINT16    type;           // holds "SB" - ORD_SCRBLT
    TSHR_INT16     pad1;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

} SCRBLT_ORDER, FAR * LPSCRBLT_ORDER;

//
// @@@ The common parts of MEMBLT_ORDER / MEMBLT_R2_ORDER and MEM3BLT_ORDER
// / MEM3BLT_R2_ORDER should be merged into a single structure.  There is
// code which assumes that the common fields have the same types which goes
// wrong if these are not the same.
//


//
// Define the structure for Bitmap Cache Orders.
// These are sent in Order Packets as "private" orders.
//

//
// Define the possible Bitmap Cache Packet Types.
//
#define BMC_PT_BITMAP_BITS_UNCOMPRESSED   0
#define BMC_PT_COLOR_TABLE                1
#define BMC_PT_BITMAP_BITS_COMPRESSED     2


//
// NOTE: avoid unions to get structure size / alignment correct.
//


// Structure: BMC_BITMAP_BITS_DATA
//
// Description: This is the part of the bitmap bits order which is common
// to both R1 and R2 protocols.
//
typedef struct tagBMC_BITMAP_BITS_DATA
{
    TSHR_UINT8      bmcPacketType;      // One of:
                                    //   BMC_PT_BITMAP_BITS_COMPRESSED
                                    //   BMC_PT_BITMAP_BITS_UNCOMPRESSED
    TSHR_UINT8      cacheID;            // Cache ID
    // lonchanc: do not remove iCacheEntryR1 for backward compatibility
    TSHR_UINT8      iCacheEntryR1;      // Cache index (only used for R1
                                    //   protocol
    TSHR_UINT8      cxSubBitmapWidth;   // Bitmap width
    TSHR_UINT8      cySubBitmapHeight;  // Bitmap height
    TSHR_UINT8      bpp;                // Number of bits per pel of bitmap
    TSHR_UINT16     cbBitmapBits;       // Number of bytes of data required to
                                    //   send the bits.
}
BMC_BITMAP_BITS_DATA;
typedef BMC_BITMAP_BITS_DATA           FAR  * PBMC_BITMAP_BITS_DATA;
typedef BMC_BITMAP_BITS_DATA UNALIGNED FAR * PBMC_BITMAP_BITS_DATA_UA;




// Structure: BMC_BITMAP_BITS_ORDER_R2
//
// Description: The data which is sent across the wire for an R2 bitmap
// bits order.  The data field is the start of an array of bytes of length
// header.cbBitmapBits
//
// We need a 16 bit cache index in R2.  We could add another 8 bit entry
// and merge with the R1 field, but in the interests of protocol
// cleanliness we should add a whole 16 bit field and make the R1 index
// "reserved" in the protocol documentation.
//
//
typedef struct tagBMC_BITMAP_BITS_ORDER_R2
{
    BMC_BITMAP_BITS_DATA    header;         // Common header information
    TSHR_UINT16             iCacheEntryR2;  // R2 cache index.  The high
                                            //   byte is a color table
                                            //   index, and the low byte
                                            //   is the bitmap bits cache
                                            //   index.
    TSHR_UINT8              data[2];        // Start of the bitmap bits.
}
BMC_BITMAP_BITS_ORDER_R2;
typedef BMC_BITMAP_BITS_ORDER_R2 FAR           * PBMC_BITMAP_BITS_ORDER_R2;
typedef BMC_BITMAP_BITS_ORDER_R2 UNALIGNED FAR * PBMC_BITMAP_BITS_ORDER_R2_UA;


//
// Structure sent for color data.  The data field is the first entry in an
// array of colorTableSize entries.
//
typedef struct tagBMC_COLOR_TABLE_ORDER
{
    TSHR_UINT8         bmcPacketType;      // BMC_PT_COLORTABLE
    TSHR_UINT8         index;              // Color table cache index
    TSHR_UINT16        colorTableSize;     // Number of entries in the
                                        //   color table being sent.
    TSHR_RGBQUAD       data[1];            // Start of an array of color table
                                        //   entries.
}
BMC_COLOR_TABLE_ORDER;
typedef BMC_COLOR_TABLE_ORDER FAR            * PBMC_COLOR_TABLE_ORDER;
typedef BMC_COLOR_TABLE_ORDER UNALIGNED FAR * PBMC_COLOR_TABLE_ORDER_UA;



//
// MemBlt (Memory to Screen Blt)
// R1 protocol
//
typedef struct _MEMBLT_ORDER
{
    TSHR_UINT16    type;           // holds "MB" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

}
MEMBLT_ORDER, FAR * LPMEMBLT_ORDER;


//
// MemBltR2 (Memory to Screen Blt for R2 protocol)
// Added cache index
//
typedef struct _MEMBLT_R2_ORDER
{
    TSHR_UINT16    type;           // holds "MC" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

    TSHR_UINT16    cacheIndex;

} MEMBLT_R2_ORDER, FAR * LPMEMBLT_R2_ORDER;


//
// Mem3Blt (Memory Pattern to Screen 3 way ROP Blt)
//
typedef struct _MEM3BLT_ORDER
{
    TSHR_UINT16    type;           // holds "MB" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

    TSHR_COLOR     BackColor;
    TSHR_UINT8      pad1;
    TSHR_COLOR     ForeColor;
    TSHR_UINT8      pad2;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad3;

} MEM3BLT_ORDER, FAR * LPMEM3BLT_ORDER;

//
// Mem3Blt (Memory to Screen Blt) for R2 (multipoint) protocols
// Add a cache index field rather than using nXSrc.
//
typedef struct _MEM3BLT_R2_ORDER
{
    TSHR_UINT16    type;           // holds "MB" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

    TSHR_COLOR     BackColor;
    TSHR_UINT8      pad1;
    TSHR_COLOR     ForeColor;
    TSHR_UINT8      pad2;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad3;

    TSHR_UINT16    cacheIndex;

} MEM3BLT_R2_ORDER, FAR * LPMEM3BLT_R2_ORDER;

//
// Variable length text structure as used by TextOut and ExtTextOut orders
//
typedef struct tagVARIABLE_STRING
{
    TSHR_UINT32    len;
    TSHR_CHAR   string[ORD_MAX_STRING_LEN_WITHOUT_DELTAS];
    TSHR_UINT8        pad;
} VARIABLE_STRING;

//
// Variable length position deltas as used by ExtTextOut.
//
typedef struct tagVARIABLE_DELTAX
{
    TSHR_UINT32    len;
    TSHR_INT32     deltaX[ORD_MAX_STRING_LEN_WITH_DELTAS];
} VARIABLE_DELTAX, FAR * LPVARIABLE_DELTAX;

//
// Variable length point array used by Polygon.
//
typedef struct tagVARIABLE_POINTS
{
    TSHR_UINT32    len;   // byte count of point array
    TSHR_POINT16   aPoints[ORD_MAX_POLYGON_POINTS];
} VARIABLE_POINTS, FAR * LPVARIABLE_POINTS;

//
// Variable length point array used by PolyBezier.
//
typedef struct tagVARIABLE_BEZIERPOINTS
{
    TSHR_UINT32    len;   // byte count of point array
    TSHR_POINT16   aPoints[ORD_MAX_POLYBEZIER_POINTS];
} VARIABLE_BEZIERPOINTS, FAR * LPVARIABLE_BEZIERPOINTS;

//
// The common part of the TEXTOUT and EXTTEXTOUT orders
//
typedef struct tagCOMMON_TEXTORDER
{
    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nXStart;        // X location of string
    TSHR_INT32     nYStart;        // Y location of string

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     CharExtra;      // extra character spacing
    TSHR_INT32     BreakExtra;     // justification break amount
    TSHR_INT32     BreakCount;     // justification break count

    TSHR_INT32     FontHeight;
    TSHR_INT32     FontWidth;
    TSHR_UINT32    FontWeight;
    TSHR_UINT32    FontFlags;
    TSHR_UINT32    FontIndex;
} COMMON_TEXTORDER, FAR * LPCOMMON_TEXTORDER;

//
// TextOut
//
typedef struct _TEXTOUT_ORDER
{
    TSHR_UINT16    type;           // holds "TO" - ORD_TEXTOUT
    TSHR_INT16     pad1;

    COMMON_TEXTORDER common;

    //
    // The following variable data occurs here.  (Remember to change the
    // code in OD2CalculateTextOutBounds if you change these).
    //
    VARIABLE_STRING variableString;

} TEXTOUT_ORDER, FAR * LPTEXTOUT_ORDER;


//
// ExtTextOut
//
typedef struct _EXTTEXTOUT_ORDER
{
    TSHR_UINT16    type;           // holds "ET" - ORD_EXTTEXTOUT
    TSHR_INT16     pad1;

    COMMON_TEXTORDER common;

    TSHR_UINT16        fuOptions;      // option flags
    TSHR_UINT16        pad4;

    TSHR_RECT32     rectangle;

    //
    // The following variable data occurs here.
    //
    //      char[cbString]  - the string of chars to be output
    //      TSHR_INT32[cbString] - X deltas for the string
    //
    // (Remember to change the code in OD2CalculateExtTextOutBounds if you
    // change these).
    //
    VARIABLE_STRING variableString;

    VARIABLE_DELTAX variableDeltaX;

} EXTTEXTOUT_ORDER, FAR * LPEXTTEXTOUT_ORDER;

//
// Rectangle
//
typedef struct _RECTANGLE_ORDER
{
    TSHR_UINT16    type;           // holds "RT" - ORD_RECTANGLE
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left
    TSHR_INT32     nTopRect;       // y top
    TSHR_INT32     nRightRect;     // x right
    TSHR_INT32     nBottomRect;    // y bottom

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;
} RECTANGLE_ORDER, FAR * LPRECTANGLE_ORDER;

//
// LineTo
//
typedef struct _LINETO_ORDER
{
    TSHR_UINT16    type;           // holds "LT" - ORD_LINETO
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nXStart;        // x line start
    TSHR_INT32     nYStart;        // y line start
    TSHR_INT32     nXEnd;          // x line end
    TSHR_INT32     nYEnd;          // y line end

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad3;
} LINETO_ORDER, FAR * LPLINETO_ORDER;

//
// OpaqueRect
//
typedef struct _OPAQUE_RECT
{
    TSHR_UINT16    type;           // holds "OR" - ORD_OPAQUERECT
    TSHR_INT16     pad1;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_COLOR     Color;          // opaque color
    TSHR_UINT8      pad2;
} OPAQUERECT_ORDER, FAR * LPOPAQUERECT_ORDER;

//
// SaveBitmap (incorporating RestoreBitmap)
//
#define SV_SAVEBITS      0
#define SV_RESTOREBITS   1

typedef struct _SAVEBITMAP_ORDER
{
    TSHR_UINT16    type;           // holds "SV" - ORD_SAVEBITMAP
    TSHR_INT16     pad1;

    TSHR_UINT32    SavedBitmapPosition;

    TSHR_INT32     nLeftRect;      // x left
    TSHR_INT32     nTopRect;       // y top
    TSHR_INT32     nRightRect;     // x right
    TSHR_INT32     nBottomRect;    // y bottom

    TSHR_UINT32    Operation;      // SV_xxxxxxxx
} SAVEBITMAP_ORDER, FAR * LPSAVEBITMAP_ORDER;

//
// Desktop scroll order
//
// The desktop order is special - it is a non-private order which is second
// level encoded, BUT support is not negotiated via its own entry in the
// capsOrdesr array in the orders capabilities.
//
// (Sending support is determined via a number of factors - at r2.x receive
// support for ORD_SCRBLT implies support for ORD_DESKSCROLL as well).
//
//
typedef struct _DESKSCROLL_ORDER
{
    TSHR_UINT16    type;           // holds "DS" - ORD_DESKSCROLL
    TSHR_INT16     pad1;

    TSHR_INT32     xOrigin;
    TSHR_INT32     yOrigin;
} DESKSCROLL_ORDER, FAR * LPDESKSCROLL_ORDER;


//
// Polygon
//
typedef struct _POLYGON_ORDER
{
    TSHR_UINT16    type;           // holds "PG" - ORD_POLYGON
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;

    TSHR_UINT32    FillMode;       // ORD_FILLMODE_ALTERNATE or
                                // ORD_FILLMODE_WINDING

    //
    // The following variable data occurs here.
    //
    VARIABLE_POINTS variablePoints;

} POLYGON_ORDER, FAR * LPPOLYGON_ORDER;


//
// Pie
//
typedef struct _PIE_ORDER
{
    TSHR_UINT16    type;           // holds "PI" - ORD_PIE
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box
    TSHR_INT32     nXStart;        // x of starting point
    TSHR_INT32     nYStart;        // y of starting point
    TSHR_INT32     nXEnd;          // x of ending point
    TSHR_INT32     nYEnd;          // y of ending point

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;


    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;

    TSHR_UINT32    ArcDirection;   // ORD_ARC_COUNTERCLOCKWISE or
                                // ORD_ARC_CLOCKWISE
} PIE_ORDER, FAR * LPPIE_ORDER;


//
// Ellipse
//
typedef struct _ELLIPSE_ORDER
{
    TSHR_UINT16    type;           // holds "EL" - ORD_ELLIPSE
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;
} ELLIPSE_ORDER, FAR * LPELLIPSE_ORDER;


//
// Arc
//
typedef struct _ARC_ORDER
{
    TSHR_UINT16    type;           // holds "AR" - ORD_ARC
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box
    TSHR_INT32     nXStart;        // x of starting point
    TSHR_INT32     nYStart;        // y of starting point
    TSHR_INT32     nXEnd;          // x of ending point
    TSHR_INT32     nYEnd;          // y of ending point

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad3;

    TSHR_UINT32    ArcDirection;   // AD_COUNTERCLOCKWISE or AS_CLOCKWISE
} ARC_ORDER, FAR * LPARC_ORDER;


//
// Chord
//
typedef struct _CHORD_ORDER
{
    TSHR_UINT16    type;           // holds "CD" - ORD_CHORD
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box
    TSHR_INT32     nXStart;        // x of starting point
    TSHR_INT32     nYStart;        // y of starting point
    TSHR_INT32     nXEnd;          // x of ending point
    TSHR_INT32     nYEnd;          // y of ending point

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;

    TSHR_UINT32    ArcDirection;   // AD_COUNTERCLOCKWISE or AD_CLOCKWISE
} CHORD_ORDER, FAR * LPCHORD_ORDER;


//
// PolyBezier
//
typedef struct _POLYBEZIER_ORDER
{
    TSHR_UINT16    type;           // holds "PZ" - ORD_POLYBEZIER
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad4;

    //
    // The following variable data occurs here.
    //
    VARIABLE_BEZIERPOINTS variablePoints;

} POLYBEZIER_ORDER, FAR * LPPOLYBEZIER_ORDER;


//
// RoundRect
//
typedef struct _ROUNDRECT_ORDER
{
    TSHR_UINT16    type;           // holds "RR" - ORD_ROUNDRECT
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left
    TSHR_INT32     nTopRect;       // y top
    TSHR_INT32     nRightRect;     // x right
    TSHR_INT32     nBottomRect;    // y bottom

    TSHR_INT32     nEllipseWidth;  // ellipse width
    TSHR_INT32     nEllipseHeight; // ellipse height

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;
}
ROUNDRECT_ORDER, FAR * LPROUNDRECT_ORDER;



////////////////////////////////
//
// ORDER ENCODING
//
////////////////////////////////


//
// Overview of Second Order Encoding
//
// Second order encoding works by only sending over the network the fields
// in an order which have changed since the last time the order was sent.
// A copy of the last example of each order sent is maintained at the
// encoding end and at the decoding end.  Whilst encoding, the fields in
// the order being encoded are checked against the fields in the copy of
// the last order of this type encoded.  The data in the field is only
// encoded if it has changed. The decoding end then only needs to copy the
// changed fields into its copy of the order.
//


//
// Encoded Order types.
//
// Note that most of these agree with the ORD_XXXXX defines, but not all,
// which is probably a mistake.  However it doesn't matter since the code
// does not assume equivalence.  It is unfortunately too late to change
// since the the shipping code uses the 2 sets of numbers:
//
//     - the OE2 protocol uses these numbers
//     - the capabilities structure uses the ORD_XXXXX numbers.
//
// Since this split exists, the DESKTOP SCROLL order, whose highword places
// it outside the CAPS_MAX_NUM_ORDERS range, is also mapped to a different
// number, so that the OE2 values have no gaps.
//
#define OE2_DSTBLT_ORDER      (HIWORD(ORD_DSTBLT))
#define OE2_PATBLT_ORDER      (HIWORD(ORD_PATBLT))
#define OE2_SCRBLT_ORDER      (HIWORD(ORD_SCRBLT))
#define OE2_MEMBLT_ORDER      (HIWORD(ORD_MEMBLT))
#define OE2_MEM3BLT_ORDER     (HIWORD(ORD_MEM3BLT))
#define OE2_TEXTOUT_ORDER     (HIWORD(ORD_TEXTOUT))
#define OE2_EXTTEXTOUT_ORDER  (HIWORD(ORD_EXTTEXTOUT))
// 0x07 was FastFrame, which is no longer supported.
#define OE2_RECTANGLE_ORDER   0x08
#define OE2_LINETO_ORDER      0x09
#define OE2_OPAQUERECT_ORDER  (HIWORD(ORD_OPAQUERECT))
#define OE2_SAVEBITMAP_ORDER  (HIWORD(ORD_SAVEBITMAP))
#define OE2_DESKSCROLL_ORDER  0x0c
#define OE2_MEMBLT_R2_ORDER   (HIWORD(ORD_MEMBLT_R2))
#define OE2_MEM3BLT_R2_ORDER  (HIWORD(ORD_MEM3BLT_R2))
#define OE2_POLYGON_ORDER     (HIWORD(ORD_POLYGON))
#define OE2_PIE_ORDER         (HIWORD(ORD_PIE))
#define OE2_ELLIPSE_ORDER     (HIWORD(ORD_ELLIPSE))
#define OE2_ARC_ORDER         (HIWORD(ORD_ARC))
#define OE2_CHORD_ORDER       (HIWORD(ORD_CHORD))
#define OE2_POLYBEZIER_ORDER  (HIWORD(ORD_POLYBEZIER))
#define OE2_ROUNDRECT_ORDER   (HIWORD(ORD_ROUNDRECT))
#define OE2_UNKNOWN_ORDER     0xFF


//
// #defines used to extract fields from a pointer to one of the text orders
//
#define TEXTFIELD(order)   ((TEXTOUT_ORDER*)(order->abOrderData))
#define EXTTEXTFIELD(order)   ((EXTTEXTOUT_ORDER*)(order->abOrderData))

//
// Number of order types.
//
#define OE2_NUM_TYPES  22

//
// Constants defining the number of changeable fields in an ORDER
// (including the "type" field which is always a word at the beginning of
// each order)
//
#define    OE2_NUM_DSTBLT_FIELDS       6
#define    OE2_NUM_PATBLT_FIELDS       13
#define    OE2_NUM_SCRBLT_FIELDS       8
#define    OE2_NUM_MEMBLT_FIELDS       9
#define    OE2_NUM_MEM3BLT_FIELDS      16
#define    OE2_NUM_TEXTOUT_FIELDS      15
#define    OE2_NUM_EXTTEXTOUT_FIELDS   22
#define    OE2_NUM_RECTANGLE_FIELDS    17
#define    OE2_NUM_LINETO_FIELDS       11
#define    OE2_NUM_OPAQUERECT_FIELDS   6
#define    OE2_NUM_SAVEBITMAP_FIELDS   7
#define    OE2_NUM_DESKSCROLL_FIELDS   3
#define    OE2_NUM_MEMBLT_R2_FIELDS    10
#define    OE2_NUM_MEM3BLT_R2_FIELDS   17
#define    OE2_NUM_POLYGON_FIELDS      15
#define    OE2_NUM_PIE_FIELDS          22
#define    OE2_NUM_ELLIPSE_FIELDS      17
#define    OE2_NUM_ARC_FIELDS          16
#define    OE2_NUM_CHORD_FIELDS        22
#define    OE2_NUM_POLYBEZIER_FIELDS   9
#define    OE2_NUM_ROUNDRECT_FIELDS    19


//
// ControlFlags:
//
// Information about how the order is encoded.  (See OE2_CF_XXX flags
// description).
//
// EncodedOrder:
//
// Contains N bytes of flags followed by an array of bytes containing the
// fields which have changed since this order was last encoded.  (If there
// are M fields in the order then N is M/8).  The position of each bit set
// in the flags gives the relative position of the entry for a field in the
// encoding table (if the first bit is set, then the entry is the first one
// in the encoding table etc.)
//
//
typedef struct tagDCEO2ORDER
{
    BYTE     ControlFlags;
    BYTE     EncodedOrder[1];
}
DCEO2ORDER;
typedef DCEO2ORDER FAR * PDCEO2ORDER;



//
// FLAGS USED INTERNALLY BY OE2
//
//  The encoded order (DCEO2ORDER) Flags field contains information
//  about which fields in the ORDER HEADER need updating
//  These control bits are the same for all orders and have the following
//  values:
//
#define OE2_CF_STANDARD_ENC     0x01U // standard encoding follows...
#define OE2_CF_UNENCODED        0x02U // not encoded
#define OE2_CF_BOUNDS           0x04U // bounding (clip) rectangle supplied
#define OE2_CF_TYPE_CHANGE      0x08U // type of order different from previous
#define OE2_CF_DELTACOORDS      0x10U // coords are TSHR_INT8 deltas from previous
#define OE2_CF_RESERVED1        0x20U //
#define OE2_CF_RESERVED2        0x40U //
#define OE2_CF_RESERVED3        0x80U //


//
// Flags use by OE2EncodeBounds and OE2DecodeBounds to indicate how the
// four coordinates in the bounding rectangle were encoded relative the the
// previous bounding rectangle.  The encoding used is a byte of flags
// followed by a variable number of 16bit coordinate values and 8bit delta
// coordinate values (which may be interleaved).  See functions for more
// information.
//
#define OE2_BCF_LEFT            0x01
#define OE2_BCF_TOP             0x02
#define OE2_BCF_RIGHT           0x04
#define OE2_BCF_BOTTOM          0x08
#define OE2_BCF_DELTA_LEFT      0x10
#define OE2_BCF_DELTA_TOP       0x20
#define OE2_BCF_DELTA_RIGHT     0x40
#define OE2_BCF_DELTA_BOTTOM    0x80

//
// OE2ETFIELD entry flag types.
//
#define OE2_ETF_FIXED           0x01
#define OE2_ETF_VARIABLE        0x02
#define OE2_ETF_COORDINATES     0x04
#define OE2_ETF_DATA            0x08

//
// Define the maximum sizes of fields within encoded orders.
//
#define  OE2_CONTROL_FLAGS_FIELD_SIZE       1
#define  OE2_TYPE_FIELD_SIZE                1
#define  OE2_MAX_FIELD_FLAG_BYTES           4
#define  OE2_MAX_ADDITIONAL_BOUNDS_BYTES    1




//////////////////////////////////////////
//
// T.SHARE PACKETS, FLOW CONTROL
//
//////////////////////////////////////////

//
// Maximum size of application packets (bytes).
// NOTE:
// Packet size can not just change.  There are no caps for it currently.
// Moreover, even though theoretically the field size is a WORD, flow
// control uses the high bit to determine flow packets.
//


//
// HEADER in front of TSHR_FLO_CONTROL/S20PACKETs
//

typedef struct tagTSHR_NET_PKT_HEADER
{
    TSHR_UINT16         pktLength;
}
TSHR_NET_PKT_HEADER;
typedef TSHR_NET_PKT_HEADER * PTSHR_NET_PKT_HEADER;


//
// Packet types:                                                           
// S20 packets have pktLength <  TSHR_PKT_FLOW            
// FLO packets have pktLength == TSHR_PKT_FLOW
//
#define TSHR_PKT_FLOW                                 0x8000


// WE'RE STUCK WITH THIS OUTGOING VALUE BECAUSE OF FLOW CONTROL!  IT ASSUMES
// PACKETS of size > MG_PKT_FLOW are flow control packets.  Back level dudes
// are hosted because of it...

#define TSHR_MAX_SEND_PKT         32000



typedef struct TSHR_FLO_CONTROL
{
    TSHR_UINT16             packetType;
    TSHR_UINT8              stream;
    TSHR_UINT8              pingPongID;
    TSHR_UINT16             userID;
}
TSHR_FLO_CONTROL;
typedef TSHR_FLO_CONTROL * PTSHR_FLO_CONTROL;


//
// TSHR_FLO_CONTROL packetType values
//
#define PACKET_TYPE_NOPING   0x0040
#define PACKET_TYPE_PING     0x0041
#define PACKET_TYPE_PONG     0x0042
#define PACKET_TYPE_PANG     0x0043




//////////////////////////////////////////
//
// T.SHARE CONTROL PACKETS
//
//////////////////////////////////////////

//
// CORRELATORS
//
// Most S20 messsages contain a correlator field.  This field is used
// to identify which share the message belongs to and is used to
// resolve races at share start up and discard stale messages received.
//
// A correlator is a 32 bit number which contains two parts.  The first
// 16 bits (the low word in Intel format) contains the user ID of the
// party which created the share.  The second 16 bits contains a count
// supplied by the party which created the share (ie the first share
// they create is 1 the second 2 etc).  This should ensure unique
// correlators for every share created for a long enough period to
// ensure no stale data is left.
//
// A new correlator is always present on a create message.  All
// respond, delete and leave messages must contain the correct
// correlator for the share.  A join message does not contain a
// correlator.  A party which issues a join message will find out the
// share's correlator on the first respond message they receive.
//
// Respond messages also contain the user ID of the party which sent
// out the original create or join to which they are responding.  There
// is one exception when a `sweep-up' respond is sent which contains
// zero in the originator field.  This respond is sent by a party which
// is joining a share as soon as they receive the first response (and
// therefore know the share correlator).  This sweep-up respond handles
// simultaneous joiners where a party was joining when it too received
// a join message.  When this happens the party ignores the join and
// will later receive a sweep-up respond message which they will
// process.
//


typedef struct tagS20PACKETHEADER
{
    TSHR_UINT16     packetType;
    TSHR_UINT16     user;
}
S20PACKETHEADER;
typedef S20PACKETHEADER * PS20PACKETHEADER;


//
// S20PACKETHEADER packetType values
//
// A single bit means that this version will only interoperate
// with itself.  More than one bit indicates cross version
// interoperability.
//
// IN NM 4.0, GET RID OF S20_2X_VERSION SUPPORT!
//
#define S20_PACKET_TYPE_MASK    0x000F
#define S20_2X_VERSION          0x0010
#define S20_30_VERSION          0x0020

#define S20_CURRENT_VERSION     S20_30_VERSION
#define S20_ALL_VERSIONS        (S20_2X_VERSION | S20_30_VERSION)

#define S20_CREATE              1
#define S20_JOIN                2
#define S20_RESPOND             3
#define S20_DELETE              4
#define S20_LEAVE               5
#define S20_END                 6
#define S20_DATA                7
#define S20_COLLISION           8



//
// To create the share
//
typedef struct tagS20CREATEPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     lenName;
    TSHR_UINT16     lenCaps;
    TSHR_UINT8      data[1];         // Name & Caps
}
S20CREATEPACKET;
typedef S20CREATEPACKET * PS20CREATEPACKET;



//
// To join a share created by somebody else
//
typedef struct tagS20JOINPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT16     lenName;
    TSHR_UINT16     lenCaps;
    TSHR_UINT8      data[1];         // Name & Caps
}
S20JOINPACKET;
typedef S20JOINPACKET * PS20JOINPACKET;




//
// To respond to a create packet
//
typedef struct tagS20RESPONDPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     originator;
    TSHR_UINT16     lenName;
    TSHR_UINT16     lenCaps;
    TSHR_UINT8      data[1];         // Name & Caps
}
S20RESPONDPACKET;
typedef S20RESPONDPACKET * PS20RESPONDPACKET;




//
// To remove a person from a share (if the creator can't join the person in)
//
typedef struct tagS20DELETEPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     target;
    TSHR_UINT16     lenName;         // OBSOLETE - no name/caps at end
    TSHR_UINT8      data[1];
}
S20DELETEPACKET;
typedef S20DELETEPACKET * PS20DELETEPACKET;



//
// To leave a share yourself
//
typedef struct tagS20LEAVEPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
}
S20LEAVEPACKET;
typedef S20LEAVEPACKET * PS20LEAVEPACKET;




//
// To end a share you created
//
typedef struct tagS20ENDPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     lenName;         // OBSOLETE - no name/caps at end
    TSHR_UINT8      data[1];
}
S20ENDPACKET;
typedef S20ENDPACKET * PS20ENDPACKET;


//
// To tell somebody creating a share that one already exists
//
typedef struct tagS20COLLISIONPACKET
{
    S20PACKETHEADER     header;
    TSHR_UINT32         correlator;
}
S20COLLISIONPACKET;
typedef S20COLLISIONPACKET * PS20COLLISIONPACKET;





/////////////////////////////////
//
// T.SHARE DATA PACKETS
//
/////////////////////////////////


//
// Data sent when in share (this structure is followed by the different
// packets described below)
//
typedef struct tagDATAPACKETHEADER
{
    TSHR_UINT8      dataType;             // DT_ identifier
    TSHR_UINT8      compressionType;
    TSHR_UINT16     compressedLength;
}
DATAPACKETHEADER;
typedef DATAPACKETHEADER * PDATAPACKETHEADER;


//
// DATAPACKETHEADER dataType values
//

#define DT_UP                   0x02
#define DT_UNUSED_USR_FH_10     0x09    // OBSOLETE
#define DT_UNUSED_USR_FH_11     0x0A    // OBSOLETE
#define DT_FH                   0x0B

#define DT_CA                   0x14    // OLD (2.x)
#define DT_CA30                 0x15    // NEW (3.0)
#define DT_HET30                0x16    // NEW (3.0)
#define DT_AWC                  0x17
#define DT_SWL                  0x18
#define DT_HET                  0x19    // OLD (2.x)
#define DT_UNUSED_DS            0x1A    // OBSOLETE
#define DT_CM                   0x1B
#define DT_IM                   0x1C    
#define DT_UNUSED_HCA           0x1D    // OBSOLETE
#define DT_UNUSED_SC            0x1E    // OBSOLETE
#define DT_SNI                  0x1F
#define DT_CPC                  0x20


//
// DATAPACKETHEADER compressionType values
//
// There are two formats for this field.
//
// If all nodes participating in the share session have the capability
// genCompressionLevel >= 1 then the compressionType is a one of the
// following 8bit integers.
//
// Otherwise the the packet is compressed with GCT_PKZIP if the top bit is
// set and the packet is not compressed if it is not set.  The remaining
// bits are undefined (and will NOT be all zero)
//
//
// Note: Each of these values has a GCT_... value associated with it.
//       These values indicate which bit of the GCT_... values this
//       compression type represents.  Eg. a value of 5 here pairs with the
//       value 0x0010 (ie bit 5 set)
//
#define     CT_NONE                 0
#define     CT_PKZIP                1
#define     CT_PERSIST_PKZIP        2
#define     CT_OLD_COMPRESSED       0x80




typedef struct tagS20DATAPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT8      ackID;                  // OBSOLETE
    TSHR_UINT8      stream;
    TSHR_UINT16     dataLength;

    DATAPACKETHEADER    data;
    // data specific to DT_ type follows here
}
S20DATAPACKET;
typedef S20DATAPACKET * PS20DATAPACKET;


//
// S20DATAPACKET stream values
//
//
// The streams and priotities used by AppSharing
//
#define PROT_STR_INVALID                0          
#define PROT_STR_UPDATES                1       // SNI_STREAM_LOW
#define PROT_STR_MISC                   2          
#define PROT_STR_UNUSED                 3       // NOT USED!    
#define PROT_STR_INPUT                  4
#define NUM_PROT_STR                    5





//
// DT_AWC
// Active Window packets
//

typedef struct tagAWCPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         token;          // OBSOLETE
    UINT_PTR            data1;
    UINT_PTR            data2;
}
AWCPACKET;
typedef AWCPACKET *PAWCPACKET;




//
// AWCPACKET msg values
//
#define AWC_MSG_INVALID                         0x0000
#define AWC_MSG_ACTIVE_CHANGE_LOCAL             0x0001
#define AWC_MSG_ACTIVE_CHANGE_SHARED            0x0002
#define AWC_MSG_ACTIVE_CHANGE_INVISIBLE         0x0003  
#define AWC_MSG_ACTIVE_CHANGE_CAPTURED          0x0004  // OBSOLETE
#define AWC_MSG_ACTIVATE_WINDOW                 0x8001
#define AWC_MSG_CLOSE_WINDOW                    0x8002  // OBSOLETE
#define AWC_MSG_RESTORE_WINDOW                  0x8003
#define AWC_MSG_TASKBAR_RBUTTON                 0x8004  // OBSOLETE
#define AWC_MSG_SAS                             0x8005
#define AWC_MSG_SYSCOMMAND_HELPKEYS             0x8011  // OBSOLETE
#define AWC_MSG_SYSCOMMAND_HELPINDEX            0x8012  // OBSOLETE
#define AWC_MSG_SYSCOMMAND_HELPEXTENDED         0x8013  // OBSOLETE



//
// DT_CA
// OLD Control Arbitration packets
//

typedef struct tagCAPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         data1;
    UINT_PTR            data2;
}
CAPACKET;
typedef CAPACKET *PCAPACKET;





//
// CAPACKET msg values, 2.x
// These are all broadcasted, control is global
//
#define CA_MSG_NOTIFY_STATE         0       // NEW FOR NM 3.0
#define CA_OLDMSG_REQUEST_CONTROL   1       // NM 2.x
#define CA_OLDMSG_GRANTED_CONTROL   2       // NM 2.x
#define CA_OLDMSG_DETACH            3       // NM 2.x
#define CA_OLDMSG_COOPERATE         4       // NM 2.x


//
// Notification (broadcast) packet
//
typedef struct tagCANOTPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         state;
    UINT_PTR            controllerID;
}
CANOTPACKET;
typedef CANOTPACKET * PCANOTPACKET;

//
// CA_MSG_NOTIFY_STATE
//  state               - controllable or not
//  controllerID        - controller net ID or 0 if nobody
//

// state flags:
#define CASTATE_ALLOWCONTROL        0x0001




//
// CA_OLDMSG_REQUEST_CONTROL
// Broadcasted to request taking of global control
//      data1   -   unused
//      data2   -   unused
//

//
// CA_OLDMSG_GRANTED_CONTROL
// Broadcasted by node(s) who think they own the control token, when they
// grant the control token to node who asked for it via REQUEST.
//      data1   -   netID of person given control
//      data2   -   control token generation
//

//
// CA_OLDMSG_DETACH
// Broadcasted when node stops collaborating
//      data1   -   unused
//      data2   -   unused
//

//
// CA_OLDMSG_COOPERATE
// Broadcasted when node starts collaborating
//      data1   -   unused
//      data2   -   unused
//




//
// DT_CA30
// NEW Control packets
//


//
// These are PRIVATE SEND packets, on PROT_STR_INPUT, from one node to another.
// They go out in order, and are queued if not able to send for retry later.
//

//
// Common header for CA30 packets.
//
typedef struct tagCA30PACKETHEADER
{
    S20DATAPACKET       header;
    TSHR_UINT32         msg;
}
CA30PACKETHEADER;
typedef CA30PACKETHEADER * PCA30PACKETHEADER;


//
// CA30PACKETHEADER msg values
//
#define CA_REQUEST_TAKECONTROL          1       // From viewer to host
#define CA_REPLY_REQUEST_TAKECONTROL    2       // From host to viewer
#define CA_REQUEST_GIVECONTROL          3       // From host to viewer
#define CA_REPLY_REQUEST_GIVECONTROL    4       // From viewer to host
#define CA_PREFER_PASSCONTROL           5       // From controller to host

#define CA_INFORM_RELEASEDCONTROL       0x8001  // From controller to host
#define CA_INFORM_REVOKEDCONTROL        0x8002  // From host to controller
#define CA_INFORM_PAUSEDCONTROL         0x8003  // From host to controller
#define CA_INFORM_UNPAUSEDCONTROL       0x8004  // From host to controller


//
// REPLY packet result values
//
#define CARESULT_CONFIRMED                      0
#define CARESULT_DENIED                         1
#define CARESULT_DENIED_BUSY                    2
#define CARESULT_DENIED_USER                    3
#define CARESULT_DENIED_WRONGSTATE              4
#define CARESULT_DENIED_TIMEDOUT                5



//
// ALL packets also have a CA30PACKETHEADER in front of them.
//


//
// CA_REQUEST_TAKECONTROL
//  Sender      is viewer
//  Receiver    is host
//      viewerControlID -   unique viewer request ID
//
// Receiver should reply with CA_REPLY_REQUEST_TAKECONTROL
// Sender should cancel with CA_INFORM_RELEASEDCONTROL
//
typedef struct tagCA_RTC_PACKET
{
    TSHR_UINT32         viewerControlID;
}
CA_RTC_PACKET;
typedef CA_RTC_PACKET * PCA_RTC_PACKET;



//
// CA_REPLY_REQUEST_TAKECONTROL
//  Sender      is host
//  Receiver    is viewer, who sent original TAKECONTROL request
//      viewerControlID -   viewer request ID from TAKECONTROL request
//      hostControlID   -   unique host request ID
//      result          -   CARESULT value, success or failure
//
typedef struct tagCA_REPLY_RTC_PACKET
{
    TSHR_UINT32         viewerControlID;
    TSHR_UINT32         result;
    TSHR_UINT32         hostControlID;
}
CA_REPLY_RTC_PACKET;
typedef CA_REPLY_RTC_PACKET * PCA_REPLY_RTC_PACKET;




//
// CA_PREFER_PASSCONTROL
//  Sender      is controller
//  Receiver    is host
//      viewerControlID -   controller request ID from take operation
//      hostControlID   -   host request ID from reply to take operation.
//      mcsPassTo       -   MCS ID of viewer to pass to
//
// No reply is required
// Sender is not in control when this gets out
// Receiver can then, if he chooses, turn around and ask 3rd party to control
//
typedef struct tagCA_PPC_PACKET
{
    TSHR_UINT32         viewerControlID;
    TSHR_UINT32         hostControlID;
    UINT_PTR            mcsPassTo;
}
CA_PPC_PACKET;
typedef CA_PPC_PACKET * PCA_PPC_PACKET;




//
// CA_REQUEST_GIVECONTROL
//  Sender      is host
//  Receiver    is viewer
//      hostControlID   -   unique host request ID
//      mcsPassFrom     -   person passing control, zero if none
//
// Receiver should reply with CA_REPLY_REQUEST_GIVECONTROL
// Sender should cancel with CA_INFORM_REVOKEDCONTROL
//
typedef struct tagCA_RGC_PACKET
{
    TSHR_UINT32         hostControlID;
    UINT_PTR            mcsPassFrom;
}
CA_RGC_PACKET;
typedef CA_RGC_PACKET * PCA_RGC_PACKET;



//
// CA_REPLY_REQUEST_GIVECONTROL
//  Sender      is viewer
//  Receiver    is host, who sent original TAKECONTROL invite
//      hostControlID   -   host request ID from TAKECONTROL invite
//      mcsPassFrom     -   person passing us control, 0 if none
//      result          -   CARESULT value, success or failure
//      viewerControlID -   unique viewer request ID
//
typedef struct tagCA_REPLY_RGC_PACKET
{
    TSHR_UINT32         hostControlID;
    TSHR_UINT32         mcsPassFrom;
    TSHR_UINT32         result;
    TSHR_UINT32         viewerControlID;
}
CA_REPLY_RGC_PACKET;
typedef CA_REPLY_RGC_PACKET * PCA_REPLY_RGC_PACKET;




//
// INFORM packets
// These are sent to cancel a REQUEST packet, or after the control
// operation has completed, to terminate it.  If cancelling, then the 
// other party's controlID will be zero since we won't have heard back from
// them yet to get it.
//
typedef struct tagCA_INFORM_PACKET
{
    TSHR_UINT32         viewerControlID;
    TSHR_UINT32         hostControlID;
}
CA_INFORM_PACKET;
typedef CA_INFORM_PACKET * PCA_INFORM_PACKET;


//
// CA_INFORM_RELEASEDCONTROL
//  Sender      is controller
//  Receiver    is host
//      viewerControlID -   viewer request ID from 
//          REQUEST_TAKECONTROL 
//          REPLY_REQUEST_GIVECONTROL
//      hostControlID   -   host request ID from
//          REPLY_REQUEST_TAKECONTROL
//          REQUEST_GIVECONTROL
//
// If viewer is cancelling REQUEST_TAKECONTROL then hostControlID is 0
//

//
// CA_INFORM_REVOKEDCONTROL
//  Sender      is host
//  Receiver    is controller
//      viewerControlID -   viewer request ID from
//          REQUEST_TAKECONTROL
//          REPLY_REQUEST_GIVECONTROL
//      hostControlID   -   host request ID from
//          REPLY_REQUEST_TAKECONTROL
//          REQUEST_GIVECONTROL
//
// If host is cancelling REQUEST_GIVECONTROL then viewerControlID is 0
//

//
// CA_INFORM_PAUSEDCONTROL
// CA_INFORM_UNPAUSEDCONTROL
//  Sender      is host
//  Receiver    is controller
//      viewerControlID -   viewer request ID from
//          REQUEST_TAKECONTROL
//          REPLY_REQUEST_GIVECONTROL
//      hostControlID   -   host request ID from
//          REPLY_REQUEST_TAKECONTROL
//          REQUEST_GIVECONTROL
//



//
// DT_CM
// Cursor shape/position packets
//      There are three types of shape packets: mono bitmaps, color cached,
//      constant IDs
//


typedef struct tagCMPACKETHEADER
{
    S20DATAPACKET       header;

    TSHR_UINT16         type;
    TSHR_UINT16         flags;
}
CMPACKETHEADER;
typedef CMPACKETHEADER * PCMPACKETHEADER;




//
// CMPACKETHEADER type values
//
#define CM_CURSOR_ID                        1
#define CM_CURSOR_MONO_BITMAP               2
#define CM_CURSOR_MOVE                      3
#define CM_CURSOR_BITMAP_COMPRESSED         4   // OBSOLETE
#define CM_CURSOR_COLORTABLE                5   // OBSOLETE
#define CM_CURSOR_COLOR_BITMAP              6
#define CM_CURSOR_COLOR_CACHE               7


//
// CMPACKETHEADER sync flag values
//
#define CM_SYNC_CURSORPOS                   0x0001
    //
    // This will be set if, when we played back input, the cursor
    // didn't end up where it was asked to go.  This could happen if an
    // app clips the cursor or snaps it.  As such, we mark this field
    // when we send a notification of our current pos so that the controller
    // knows to move his cursor to be in line with ours.
    //



//
// type CM_CURSOR_ID
//
// This packet is sent when the cursor has changed and it is now one of
// the system cursors.
//
typedef struct tagCMPACKETID
{
    CMPACKETHEADER      header;

    TSHR_UINT32         idc;
}
CMPACKETID;
typedef CMPACKETID * PCMPACKETID;




//
// CMPACKETID idc values
//
#define CM_IDC_NULL         0
#define CM_IDC_ARROW        32512


//
// type CM_CURSOR_MONO_BITMAP
//
// This packet is sent when the cursor has changed and it is now an
// application defined mono cursor.
//
// The cursor size cannot be greater than 32x32.
typedef struct tagCMPACKETMONOBITMAP
{
    CMPACKETHEADER  header;

    TSHR_UINT16     xHotSpot;
    TSHR_UINT16     yHotSpot;
    TSHR_UINT16     width;
    TSHR_UINT16     height;
    TSHR_UINT16     cbBits;
    BYTE            aBits[1];
}
CMPACKETMONOBITMAP;
typedef CMPACKETMONOBITMAP * PCMPACKETMONOBITMAP;





//
// type CM_CURSOR_COLOR_BITMAP
//
// This packet is sent when the cursor has changed and it is now an
// application defined color cursor.
//
typedef struct tagCMPACKETCOLORBITMAP
{
    CMPACKETHEADER  header;

    TSHR_UINT16     cacheIndex;
    TSHR_UINT16     xHotSpot;
    TSHR_UINT16     yHotSpot;
    TSHR_UINT16     cxWidth;
    TSHR_UINT16     cyHeight;
    TSHR_UINT16     cbANDMask;
    TSHR_UINT16     cbXORBitmap;
    BYTE            aBits[1];
}
CMPACKETCOLORBITMAP;
typedef CMPACKETCOLORBITMAP * PCMPACKETCOLORBITMAP;





//
// type CM_CURSOR_COLOR_CACHE
//
// This packet is sent out when the cursor changes and the new
// definition resides in the cache.
//
//
typedef struct tagCMPACKETCOLORCACHE
{
    CMPACKETHEADER      header;

    TSHR_UINT16         cacheIndex;
}
CMPACKETCOLORCACHE;
typedef CMPACKETCOLORCACHE * PCMPACKETCOLORCACHE;






//
// type CM_CURSOR_MOVE
//
// This packet is sent whenever the CM is told that the application has
// moved the cursor.
//
typedef struct tagCMPACKETMOVE
{
    CMPACKETHEADER      header;

    TSHR_UINT16         xPos;
    TSHR_UINT16         yPos;
}
CMPACKETMOVE;
typedef CMPACKETMOVE * PCMPACKETMOVE;





//
// DT_CPC
// Capabilities change packet
//
typedef struct tagCPCPACKET
{
    S20DATAPACKET       header;

    PROTCAPS            caps;
}
CPCPACKET;
typedef CPCPACKET * PCPCPACKET;




//
// DT_FH
// Supported local font list packet
//



//
// The NETWORKFONT is the font description which is sent across the network
// when negotiating font support.
//

//
// Flags for the nfFontFlags field
//
#define NF_FIXED_PITCH      0x0001
#define NF_FIXED_SIZE       0x0002
#define NF_ITALIC           0x0004
#define NF_UNDERLINE        0x0008
#define NF_STRIKEOUT        0x0010

#define NF_OEM_CHARSET      0x0020
#define NF_RESERVED1        0x0040      // Reserved for future BiDi support
#define NF_TRUE_TYPE        0x0080
#define NF_BASELINE         0x0100

#define NF_PRE_R11      (NF_FIXED_PITCH | NF_FIXED_SIZE | \
                         NF_ITALIC | NF_UNDERLINE | NF_STRIKEOUT)

//
// Mask for local-only font flags - that must not flow on the wire.
//
#define NF_LOCAL            (NF_OEM_CHARSET | NF_TRUE_TYPE)

//
// A special value for the signature field which means no signature.
//
#define NF_NO_SIGNATURE 0

//
// The FH_FACESIZE is equal to the Windows specific constant LF_FACESIZE.
//
#define FH_FACESIZE 32


//
// SFRFONT
// Let us define these things more fully...
// nfFaceName   font face name (not family name, not style)
// nfFontFlags  see above
// nfAveWidth   in Windows set to tmAveCharWidth
// nfAveHeight  NOT THE AVERAGE HEIGHT but the height of a character with
//              full ascender (but no accent) AND descender.  There is no
//              such character but never mind.
//              Windows: set to tmHeight - tmInternalLeading
// nfAspectX
// nfAspectY
// nfSignature: in R11 set to an obscure checksum
//              in R20 set to two one-byte values and one two byte value.
//              Based on the widths of the actual text for fixed width
//              fonts and on 16x16 scalable fonts.  .
//              (The 16x16 is effectively part of the protocol)
//              nfSigFats   the sum of the widths (in pels) of the chars
//                          0-9,@-Z,$,%,&. divided by two: the fat chars
//              nfSigThins  the sum of the widths (in pels) of the chars
//                          0x20->0x7F EXCLUDING those summed in nfSigFats.
//                          Again - divided by two.  The thin chars.
//              nfSigSymbol The sum of the widths (in pels) of the chars
//                          x80->xFF.
// nfCodePage:  new use in R20: code page (not charset)
//              This field is set to 0 for ANSI (meaning WINDOWS ANSI)
//                         is set to 255 for OEM (meaning Windows OEM font)
//                         is set to the defined codepage if known
//                         is set to 0xFFFF when not known.
//
// nfMaxAscent:     The height of a character with no descender, plus any
//              internal leading.
//              = tmAscent in windows
//              For fixed size fonts we send the values you would expect.
//              For scalable fonts, we get the tmAscent (or equivalent) for
//              a very large font (say height-by-width of 100x100).  The
//              size selected must be the same on ALL platforms so is
//              effectively part of the protocol - hence is defined in
//              this file as NF_MAXASCENT_HEIGHT and .._WIDTH.
//
//
#define NF_CP_WIN_ANSI      0
#define NF_CP_WIN_SYMBOL    2
#define NF_CP_WIN_OEM       255
#define NF_CP_UNKNOWN       0xFFFF

//
// Define the start and end point of the ASCII sub-range
//
#define NF_ASCII_FIRST       0x20
#define NF_ASCII_LAST        0x7F
#define NF_ASCII_ZERO        0x30
#define NF_ASCII_Z           0x5B
#define NF_ASCII_DOLLAR      0x24
#define NF_ASCII_PERCENT     0x25
#define NF_ASCII_AMPERSAND   0x26


//
// The height/width of the font to ask for when getting the metrics info
// for scalable fonts.
// These (in particular the height) are CHARACTER SIZES not CELL sizes.
// This is because the font protocol exchanges character sizes not cell
// sizes.  (The char height is the cell height minus any internal leading.)
//
#define NF_METRICS_HEIGHT 100
#define NF_METRICS_WIDTH  100

//
// The wire-format font information structure
//
typedef struct tagNETWORKFONT
{
    TSHR_CHAR      nfFaceName[FH_FACESIZE];
    TSHR_UINT16    nfFontFlags;
    TSHR_UINT16    nfAveWidth;
    TSHR_UINT16    nfAveHeight;
    TSHR_UINT16    nfAspectX;          // New field for r1.1
    TSHR_UINT16    nfAspectY;          // New field for r1.1
    TSHR_UINT8     nfSigFats;          // New field for r2.0
    TSHR_UINT8     nfSigThins;         // New field for r2.0
    TSHR_UINT16    nfSigSymbol;        // New field for r2.0
    TSHR_UINT16    nfCodePage;         // New field for R2.0
    TSHR_UINT16    nfMaxAscent;        // New field for R2.0
}
NETWORKFONT;
typedef NETWORKFONT * LPNETWORKFONT;


typedef struct tagFHPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         cFonts;
    TSHR_UINT16         cbFontSize;
    NETWORKFONT         aFonts[1];
}
FHPACKET;
typedef FHPACKET * PFHPACKET;




//
// DT_HET
// Hosting state (nothing, apps, desktop)
//

typedef struct tagHETPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         hostState;  // ONLY ONE VALUE FOR MSG; IF MORE MAKE MORE STRUCTS
}
HETPACKET;
typedef HETPACKET * PHETPACKET;



//
// HETPACKET msg values
//
#define HET_MSG_NUMHOSTED           1


//
// HETPACKET hostState values
//
#define HET_NOTHOSTING              0
#define HET_APPSSHARED              0x0001      // Packet only
#define HET_DESKTOPSHARED           0xFFFF      // Packet and per-person data



//
// DT_IM
// Input events
//

//
// This is the base keyboard event (IM_TYPE_ASCII, IM_TYPE_VK1,
// IM_TYPE_VK2).  Future keyboard events may append extra fields.  The
// flags defined in the base keyboard event must be set to reasonable
// values in all future keyboard events.
//
// flags:
//
//  bit 0-6: unused (available for future keyboard events)
//  bit 7: Secondary key (unused).
//  bit 8: SET - extended key, RESET - normal key
//  bit 9-11: unused (available for future keyboard events)
//  bit 12: SET - when replayed this key stroke should NOT cause
// anything to happen
//  bit 13: reserved - this flag is not part of the protocol and is
// never sent.  It is used internally by IEM when processing received
// packets.
//  bit 14: SET - previously down, RESET previously up
//  bit 15: SET - key release, RESET key press
//
//
typedef struct tagIMKEYBOARD
{
    TSHR_UINT16     flags;
    TSHR_UINT16     keyCode;
}
IMKEYBOARD;
typedef IMKEYBOARD * PIMKEYBOARD;


//
// IMKEYBOARD flags values
//
#define IM_FLAG_KEYBOARD_RIGHT              0x0001
#define IM_FLAG_KEYBOARD_UPDATESTATE        0x0002  // not sent; just internal
#define IM_FLAG_KEYBOARD_SECONDARY          0x0080
#define IM_FLAG_KEYBOARD_EXTENDED           0x0100
#define IM_FLAG_KEYBOARD_QUIET              0x1000
#define IM_FLAG_KEYBOARD_ALT_DOWN           0x2000
#define IM_FLAG_KEYBOARD_DOWN               0x4000
#define IM_FLAG_KEYBOARD_RELEASE            0x8000

//
// This is the base mouse event (IM_TYPE_3BUTTON).  Future mouse events
// may append extra fields but they must include all the fields in the
// base mouse event and these must be set to reasonable values.
//
// flags:
//
//  bit 0-8: ignored by old systems
//           new systems: signed wheel rotation amount if bit 9 set
//  bit 9:   ignored by old systems
//           new systems: SET - wheel rotate, RESET - other event
//                          (takes precedent over bit 11 - mouse move)
//
//  bit 10:  SET - double click, RESET - single click
//  bit 11:  SET - mouse move (ignore bits 9,10, 12-15), RESET - mouse
//           action
//  bit 12:  SET - button 1 (left button)
//  bit 13:  SET - button 2 (right button)
//  bit 14:  SET - button 3 (middle button)
//  bit 15:  SET - button press, RESET - button release
//
//
typedef struct tagIMMOUSE
{
    TSHR_UINT16    flags;
    TSHR_INT16     x;
    TSHR_INT16     y;
}
IMMOUSE;
typedef IMMOUSE * PIMMOUSE;


//
// IMMOUSE flags values
//
#define IM_FLAG_MOUSE_WHEEL             0x0200
#define IM_FLAG_MOUSE_DIRECTION         0x0100
#define IM_FLAG_MOUSE_ROTATION_MASK     0x01FF
#define IM_FLAG_MOUSE_DOUBLE            0x0400
#define IM_FLAG_MOUSE_MOVE              0x0800
#define IM_FLAG_MOUSE_BUTTON1           0x1000
#define IM_FLAG_MOUSE_BUTTON2           0x2000
#define IM_FLAG_MOUSE_BUTTON3           0x4000
#define IM_FLAG_MOUSE_DOWN              0x8000


typedef struct tagIMEVENT
{
    TSHR_UINT32     timeMS;
    TSHR_UINT16     type;
    union
    {
        IMKEYBOARD      keyboard;
        IMMOUSE         mouse;
    }
    data;
}
IMEVENT;
typedef IMEVENT *     PIMEVENT;
typedef IMEVENT FAR * LPIMEVENT;


//
// IMEVENT type values
//
#define IM_TYPE_SYNC            0x0000          // OBSOLETE 2.X
#define IM_TYPE_ASCII           0x0001
#define IM_TYPE_VK1             0x0002
#define IM_TYPE_VK2             0x0003
#define IM_TYPE_3BUTTON         0x8001


typedef struct tagIMPACKET
{
    S20DATAPACKET   header;

    TSHR_UINT16     numEvents;
    TSHR_UINT16     padding;
    IMEVENT         aEvents[1];
}
IMPACKET;
typedef IMPACKET *     PIMPACKET;
typedef IMPACKET FAR * LPIMPACKET;




//
// DT_UP
// Update packet (orders, screen data, palettes)
//


typedef struct tagUPPACKETHEADER
{
    S20DATAPACKET       header;

    TSHR_UINT16         updateType;
    TSHR_UINT16         padding;
}
UPPACKETHEADER;
typedef UPPACKETHEADER * PUPPACKETHEADER;




//
// UPPACKETHEADER updateType values
//
#define UPD_ORDERS       0
#define UPD_SCREEN_DATA  1
#define UPD_PALETTE      2
#define UPD_SYNC         3


//
// UPD_ORDERS
//
typedef struct tagORDPACKET
{
    UPPACKETHEADER      header;

    TSHR_UINT16         cOrders;
    TSHR_UINT16         sendBPP;
    BYTE                data[1];
}
ORDPACKET;
typedef ORDPACKET * PORDPACKET;




//
// UPD_SCREEN_DATA
//
// Bitmap packet contains bitmap image of window changes made by a shared
// application.  These packets are sent when a screen update occurs that
// can not be sent as an order. The structure contains the following
// fields:
//
//  winID - window handle of the shared window from which the update came
//  position - virtual desktop position of the update
//  realWidth - width of update bitmap
//  realHeight - height of update bitmap
//  format - bits per pel of update bitmap
//  dataSize - size in bytes of following bitmap data
//  firstData - first byte in array of bytes that contains the bitmap
//
// Note that the realWidth is not always the same as the width of the
// update as given by the position field rectangle. This is because a
// number of fixed size cached bitmaps are used for speed when generating
// the update packets. The bitmap data (firstData onwards) should be
// set into a bitmap of realWidth, realHeight dimensions by the receiver
// and then the appropriate portion blted to the desired destination
// determined by the position rectangle. The valid portion of the bitmap
// always starts 0,0 within the bitmap.
//
typedef struct tagSDPACKET
{
    UPPACKETHEADER      header;

    TSHR_RECT16         position;
    TSHR_UINT16         realWidth;
    TSHR_UINT16         realHeight;
    TSHR_UINT16         format;
    TSHR_UINT16         compressed;
    TSHR_UINT16         dataSize;
    BYTE                data[1];
}
SDPACKET;
typedef SDPACKET * PSDPACKET;




//
// UPD_PALETTE
//
// Palette packet.  This is sent before any SDPACKETS to define the
// colors in the bitmap data.  The fields are as follows:
//
//  numColors - the number of colors in the palette
//  firstColor - the first entry in an array of TSHR_COLORs
//
// The TSHR_COLOR structures are 3 bytes long (r,g,b) and are NOT padded.
//
//
typedef struct tagPMPACKET
{
    UPPACKETHEADER      header;

    TSHR_UINT32         numColors;
    TSHR_COLOR          aColors[1];
}
PMPACKET;
typedef PMPACKET * PPMPACKET;



//
// UPD_SYNC
//
typedef struct tagUPSPACKET
{
    UPPACKETHEADER      header;
}
UPSPACKET;
typedef UPSPACKET * PUPSPACKET;




//
// DT_SNI
// Share controller packet
//

typedef struct tagSNIPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         message;
    TSHR_UINT16         destination;
}
SNIPACKET;
typedef SNIPACKET * PSNIPACKET;



//
// SNIPACKET message values
//
#define SNI_MSG_SYNC    1

//
// For a SNI_MSG_SYNC,
// The network ID of the destination (all syncs are broadcast
// and discarded at the destination if they are not for the
// destination).
//




//
// DT_SWL
// Shared window list packet
//

#define SWL_MAX_WINDOW_TITLE_SEND       50
#define SWL_MAX_NONRECT_SIZE            10240

//
// Structures used to define the window structure (Z-order and
// position).  
//
typedef struct tagSWLWINATTRIBUTES
{
    UINT_PTR    winID;
            //
            // The window ID for shared windows - otherwise 0.  Note that
            // this is the window ID on the machine hosting the application
            // even for view frames.
            //
    TSHR_UINT32    extra;
            //
            // Extra information for the window.  The contents depend on
            // the flags.
            //
            // For SWL_FLAG_WINDOW_HOSTED this contains the appID of the
            // application which owns the window.
            //
            // For SWL_FLAG_WINDOW_SHADOW this contains the person ID of
            // the party which is hosting the app
            //
            // For SWL_FLAG_WINDOW_LOCAL this entry is 0.
            //
    TSHR_UINT32    ownerWinID;
            //
            // The window ID of the owner of this window.  Only valid for
            // shared, hosted windows.  NULL is a valid owner ID.
            //
    TSHR_UINT32    flags;
            //
            // Flags describing window
            //
            //  SWL_FLAG_WINDOW_MINIMIZED
            //  SWL_FLAG_WINDOW_TAGGABLE
            //  SWL_FLAG_WINDOW_HOSTED
            //  SWL_FLAG_WINDOW_SHADOW
            //  SWL_FLAG_WINDOW_LOCAL
            //  SWL_FLAG_WINDOW_TOPMOST
            //
            //  SWL_FLAG_WINDOW_TASKBAR - window appears on Win95 task bar
            //  SWL_FLAG_WINDOW_NOTASKBAR - window not on Win95 task bar
            //
            //  (SWL_FLAG_WINDOW_TRANSPARENT - this is not sent but is used
            //  during the creation of the packet)
            //
            #define SWL_FLAG_WINDOW_MINIMIZED    0x00000001
            #define SWL_FLAG_WINDOW_TAGGABLE     0x00000002
            #define SWL_FLAG_WINDOW_HOSTED       0x00000004
            #define SWL_FLAG_WINDOW_LOCAL        0x00000010
            #define SWL_FLAG_WINDOW_TOPMOST      0x00000020

            //
            // New for NM 1.0, non-R11
            //
            #define SWL_FLAG_WINDOW_TASKBAR      0x00010000
            #define SWL_FLAG_WINDOW_NOTASKBAR    0x00020000
            #define SWL_FLAG_WINDOW_TRANSPARENT  0x40000000

            //
            // New for NM 2.0
            //
            #define SWL_FLAG_WINDOW_NONRECTANGLE 0x00040000

            //
            // Obsolete in NM 3.0
            // These were used at some point in backlevel versions.
            // If you reuse these bits, DO A LOT OF INTEROP TESTING.
            //
            #define SWL_FLAG_WINDOW_SHADOW       0x00000008
            #define SWL_FLAG_WINDOW_DESKTOP      0x00080000
            #define SWL_FLAG_WINDOW_REQD         0x80000000

            //
            // NM 3.0 INTERNAL only; not transmitted
            //
            #define SWL_FLAG_INTERNAL_SEEN      0x000001000

            //
            // These are valid to SEND in a packet or PROCESS when RECEIVED
            //
            #define SWL_FLAGS_VALIDPACKET           \
                (SWL_FLAG_WINDOW_MINIMIZED      |   \
                 SWL_FLAG_WINDOW_TAGGABLE       |   \
                 SWL_FLAG_WINDOW_HOSTED         |   \
                 SWL_FLAG_WINDOW_TOPMOST        |   \
                 SWL_FLAG_WINDOW_TASKBAR        |   \
                 SWL_FLAG_WINDOW_NONRECTANGLE   |   \
                 SWL_FLAG_WINDOW_SHADOW)

    TSHR_RECT16    position;
            //
            // The bounding rectangle of the window in inclusive virtual
            // desktop coordinates.
            //
}
SWLWINATTRIBUTES;
typedef SWLWINATTRIBUTES *PSWLWINATTRIBUTES;


//
// The SWL packet consists of an array of SWLWINATTRIBUTES structures,
// followed by some variable length string data (the window titles)
// followed by zero or more, word aligned, additional chunks of data.
//
// The only currently defined chunk is for the non-rectangular window
// data.
//
typedef struct
{
    TSHR_UINT16    size;
            //
            // Total size in bytes of this chunk
            //
    TSHR_UINT16    idChunk;
            //
            // An identifier for the contents of this chunk.
            //
            #define SWL_PACKET_ID_NONRECT   0x524e  // "NR"
}
SWLPACKETCHUNK;
typedef SWLPACKETCHUNK * PSWLPACKETCHUNK;



typedef struct tagSWLPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;        // ONLY ONE VALUE FOR MSG; MAKE MORE STRUCTS IF ADDED
    TSHR_UINT16         flags;
    TSHR_UINT16         numWindows;
    TSHR_UINT16         tick;
    TSHR_UINT16         token;
    TSHR_UINT16         reserved;
    SWLWINATTRIBUTES    aWindows[1];

    //
    // The last SWLWINATTRIBUTES structure is followed by the
    // window title data.  This is made up as follows.
    //
    // For each window which is a window from a shared, hosted
    // application (ie winID and appID are non-zero) #either -
    //
    //  (char)0xFF - not a `task window' - give it a NULL title
    //  or -
    //  a null terminated string up to MAX_WINDOW_TITLE_SEND
    // characters
    //
    // The titles appear in the same order as the corresponding
    // windows in the SWLWINSTRUCTURE.
    //
    
    //
    // The last TITLE is followed by the regional data,
    // SWLPACKETCHUNK, if there is any.  One for each NONRECT window in 
    // the list.
    //
}
SWLPACKET;
typedef SWLPACKET *PSWLPACKET;




//
// SWLPACKET msg values
//
#define SWL_MSG_WINSTRUCT   1


//
// SWLPACKET flags values
//
#define SWL_FLAG_STATE_SYNCING      0x0001


#endif // _H_T_SHARE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\ut.h ===
//
// Utilities
//

#ifndef _H_UT
#define _H_UT



//
// Data types stored in the profile information.
//
#define COM_PROFTYPE_STRING     1L
#define COM_PROFTYPE_INT        2L
#define COM_PROFTYPE_BOOL       3L
#define COM_PROFTYPE_UNKNOWN    4L


#define COM_MAX_SUBKEY         256
#define COM_MAX_BOOL_STRING    5



//
//
// TYPEDEFS
//
//


//
// Priorities for UT_RegisterEventProc()
//
// Event procedures are registered with a priority that affects the order
// that the event procedures are called in.
//
// All event procedures of a given priority are called before event
// procedures of a numerically lower priority.
//
// The priority can be any number between 0 and UT_MAX_PRIORITY
//
// The following values have been defined for specific uses:
//  UT_PRIORITY_OBMAN :     Used by OBMAN so its client event procedures
//                            are called before those of the client
//  UT_PRIORITY_APPSHARE    : Used by the DCShare Core to ensure it sees
//                            events before 'Normal' event procs.
//  UT_PRIORITY_NORMAL      : For all cases where the order of callling is
//                            not important.
//  UT_PRIORITY_NETWORK     : Used by the Network Layer to free any
//                            unprocessed network buffers.
//  UT_PRIORITY_LAST        : Used by the Utility Services to get the
//                            default event procedure called last
//
//
typedef enum
{
    UT_PRIORITY_LAST = 0,
    UT_PRIORITY_NETWORK,
    UT_PRIORITY_NORMAL,
    UT_PRIORITY_APPSHARING,
    UT_PRIORITY_OBMAN,
    UT_PRIORITY_MAX
} UT_PRIORITY;
typedef UT_PRIORITY * PUT_PRIORITY;



//
// SYSTEM LIMITS
//

//
// Maximum number of event handlers for each task
//
#define UTEVENT_HANDLERS_MAX            4

//
// Maximum number of exit procedures
//
#define UTEXIT_PROCS_MAX                4


//
// The groupware critsects, identified by constant
//
#define UTLOCK_FIRST        0
typedef enum
{
    UTLOCK_UT = UTLOCK_FIRST,
    UTLOCK_OM,              // obman
    UTLOCK_AL,              // app loader
    UTLOCK_T120,            // gcc/mcs
    UTLOCK_AS,              // app sharing
    UTLOCK_MAX
}
UTLOCK;


// Event message
#define WM_UTTRIGGER_MSG    (WM_APP)


//
// BASEDLIST
//
// This is a list structure with based offsets
//
// next            : the next item in the list
// prev            : the previous item in the list
//
//
typedef struct tagBASEDLIST
{
    DWORD       next;
    DWORD       prev;
}
BASEDLIST;
typedef BASEDLIST FAR * PBASEDLIST;


typedef struct
{
    BASEDLIST  chain;
    void FAR *pData;
}
SIMPLE_LIST, FAR * PSIMPLE_LIST;



//
//
// MACROS
//
//
//
// List handling
// =============
// The common functions support the concept of a doubly linked list of
// objects.  Objects can be inserted and removed from specified locations
// in the list.
//
// At start of day the calling application must call COM_BasedListInit with a
// pointer to a private piece of memory for a BASEDLIST structure.  The list
// handling will initialise this structure.  The application must not
// release this memory while the list is active.  (Nor must it release any
// object while it is in a list!)
//
// The list functions can only manage a single list, however the app
// can load objects with multiple lists.  Each call to the common list
// functions takes a BASEDLIST pointer as the object handle and if the
// application defines multiple BASEDLIST structures within an object then it
// may manage them through the list functions.
//
//
// List chaining
// =============
// For normal list chaining, we have something like
//
//   while (pointer != NULL)
//   {
//     do something;
//     pointer = pointer->next;
//   }
//
// When using lists whose elements contain offsets (in this case, relative
// offsets) to the next element, we have to cast to a 32-bit integer before
// we can add the offset.  This macro encapsulates this, and the example
// above would be modified as follows to use it:
//
//   while (pointer != NULL)
//   {
//     do something;
//     pointer = (TYPE) COM_BasedNextListField(pointer);
//   }
//
// Note also that the value returned by the macro is a pointer to a generic
// list object i.e.  a PBASEDLIST, and so must be cast back to the
// appropriate type.
//
//

//
// List traversing macros
// ======================
// These macros make use of DC_NEXT and DC_PREV, but also take the type of
// list being traversed in order to return the start pointer of the chained
// structure.
//
// The LIST_FIND macro supports the searching of a list, matching a key
// value to a selected structure element.
//
// The parameters to the macros are as follows:
//
//   pHead (type: PBASEDLIST)
//   -----
//      a pointer the root of the list
//
//   pEntry (type: STRUCT FAR * FAR *)
//   ------
//      a pointer to pointer to structure to chain from
//
//   STRUCT (a type name)
//   ------
//      the type of **pEntry
//
//   chain (a field name)
//   -----
//      the text name of the field in STRUCT which is the link along which
//      you wish to traverse
//
//   field (a field name)
//   -----
//      when FINDing, the text name of the field in STRUCT against which
//      you wish to match
//
//   key (a value, of the same type as STRUCT.field)
//   ---
//      when FINDing, the value to match against STRUCT.field against
//
//



//
// Offset arithmetic
// =================
// Using offsets within memory blocks, rather than pointers, to refer to
// objects in shared memory (as necessitated by the DC-Groupware shared
// memory architecture) presents certain difficulties.  Pointer arithmetic
// in C assumes that addition/subtraction operations involve objects of the
// same type and the offsets are presented as number of units of that
// particular type, rather than number of bytes.
//
// Therefore, pointers must be cast to integers before performing
// arithmetic on them (note that casting the pointers to byte pointers is
// not enough since on segmented architectures C performs bounds checking
// when doing pointer arithmetic which we don't want).
//
// Since this would make for cumbersome code if repeated everywhere, we
// define some useful macros to convert
//
// - an (offset, base) pair to a pointer (OFFSETBASE_TO_PTR)
//
// - a (pointer, base) pair to an offset (PTRBASE_TO_OFFSET)
//
// - a NULL pointer value to an offset(NULLBASE_TO_OFFSET)
//
// The offset calculated is the offset of the first parameter from the
// second.  As described above, the pointers passed in must be cast to
// 32-bit unsigned integers first, subtracted to get the offset, and then
// cast to 32-bit signed.
//
// The NULLBASE_TO_OFFSET value gives an offset that after translation back
// to a pointer gives a NULL.  This is NOT the same as a NULL offset, since
// this translates back to the base pointer (which is a perfectly valid
// address).
//
//
#define PTRBASE_TO_OFFSET(pObject, pBase)                               \
      (LONG)(((DWORD_PTR)(pObject)) - ((DWORD_PTR)(pBase)))

#define OFFSETBASE_TO_PTR(offset, pBase)                                \
      ((void FAR *) ((DWORD_PTR)(pBase) + (LONG)(offset)))

#define NULLBASE_TO_OFFSET(pBase)                                       \
      ((DWORD_PTR) (0L - (LONG_PTR)(pBase)))


__inline BOOL COM_BasedListIsEmpty ( PBASEDLIST pHead )
{
    ASSERT((pHead->next == 0 && pHead->prev == 0) ||
           (pHead->next != 0 && pHead->prev != 0));
    return (pHead->next == 0);
}

__inline void FAR * COM_BasedFieldToStruct ( PBASEDLIST pField, UINT nOffset )
{
    return (void FAR *) ((DWORD_PTR)pField - nOffset);
}

__inline PBASEDLIST COM_BasedStructToField ( void FAR * pStruct, UINT nOffset )
{
    return (PBASEDLIST) ((DWORD_PTR) pStruct + nOffset);
}

__inline PBASEDLIST COM_BasedNextListField ( PBASEDLIST p )
{
    return (PBASEDLIST) OFFSETBASE_TO_PTR(p->next, p);
}

__inline PBASEDLIST COM_BasedPrevListField ( PBASEDLIST p )
{
    return (PBASEDLIST) OFFSETBASE_TO_PTR(p->prev, p);
}

void FAR * COM_BasedListNext ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset );
void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset );
void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset );
void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset );

typedef enum
{
    LIST_FIND_FROM_FIRST,
    LIST_FIND_FROM_NEXT
}
LIST_FIND_TYPE;

void COM_BasedListFind ( LIST_FIND_TYPE   eType,
                           PBASEDLIST          pHead,
                           void FAR * FAR*  ppEntry,
                           UINT           nOffset,
                           int           nOffsetKey,
                           DWORD_PTR     Key,
                           int           cbKeySize );


PSIMPLE_LIST COM_SimpleListAppend ( PBASEDLIST pHead, void FAR * pData );
void FAR *   COM_SimpleListRemoveHead ( PBASEDLIST pHead );

//
//
// FUNCTION PROTOTYPES
//
//

//
// API FUNCTION: COM_Rect16sIntersect(...)
//
// DESCRIPTION:
// ============
// Checks whether two TSHR_RECT16s rectangles intersect.  Rectangles are
// defined to be inclusive of all edges.
//
// PARAMETERS:
// ===========
// pRect1          : pointer to a TSHR_RECT16 rectangle.
// pRect2          : pointer to a TSHR_RECT16 rectangle.
//
// RETURNS:
// ========
// TRUE - if the rectangles intersect
// FALSE - otherwise.
//
//
__inline BOOL COM_Rect16sIntersect(LPTSHR_RECT16 pRect1, LPTSHR_RECT16 pRect2)
{
    if ((pRect1->left > pRect2->right) ||
        (pRect1->right < pRect2->left) ||
        (pRect1->top > pRect2->bottom) ||
        (pRect1->bottom < pRect2->top))
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}


//
// API FUNCTION: COM_BasedListInit(...)
//
// DESCRIPTION:
// ============
// Initialise a list root.
//
// PARAMETERS:
// ===========
// pListRoot       : pointer to the list root.
//
// RETURNS:
// ========
// Nothing.
//
//
__inline void COM_BasedListInit(PBASEDLIST pListRoot)
{
    //
    // The <next> and <prev> items in a list are the offsets, from the list
    // item, of the next and previous list items.
    //
    // In an empty list, the next item after the root is the root itself,
    // so the <next> offset is zero.  Likewise for <prev>.
    //
    pListRoot->next = 0;
    pListRoot->prev = 0;
}


//
// API FUNCTION: COM_BasedListInsertBefore(...)
// Inserts an item into a list.  To insert an item at the start of a list,
// specify the list root as the <pListLink> parameter.
//
void COM_BasedListInsertBefore(PBASEDLIST pListLink, PBASEDLIST pNewLink);


//
// API FUNCTION: COM_BasedListInsertAfter(...)
// Inserts an item into a list.  To insert an item at the start of a list,
// specify the list root as the <pListLink> parameter.
//
//
void COM_BasedListInsertAfter(PBASEDLIST pListLink,  PBASEDLIST pNewLink);

//
// API FUNCTION: COM_BasedListRemove(...)
//
// DESCRIPTION:
// ============
// This function removes an item from a list.  The item to be removed is
// specified by a pointer to the BASEDLIST structure within the item.
//
// PARAMETERS:
// ===========
// pListLink       : pointer to link of the item to be removed.
//
// RETURNS:
// ========
// Nothing.
//
//
void COM_BasedListRemove(PBASEDLIST pListLink);


//
// API FUNCTION: COM_ReadProfInt(...)
//
// DESCRIPTION:
// ============
// This reads a private profile integer from the registry.
//
// PARAMETERS:
// ===========
// pSection        : section containing the entry to read.
// pEntry          : entry name of integer to retrieve.
// defaultValue    : default value to return
// pValue          : buffer to return the entry in.
//
// RETURNS:
// ========
// Nothing.
//
//
void COM_ReadProfInt(LPSTR pSection, LPSTR pEntry, int defValue, int * pValue);

//
// API FUNCTION: COM_GetSiteName(...)
//
// DESCRIPTION:
// ============
// Reads the site name out of the system registry.
//
// PARAMETERS:
// ===========
// siteName        : pointer to string to fill in with the site name.
// siteNameLen     : length of this string.
//
// RETURNS:
// ========
// None
//
//
void COM_GetSiteName(LPSTR siteName, UINT  siteNameLen);


#ifndef DLL_DISP
//
// API FUNCTION: DCS_StartThread(...)
//
// DESCRIPTION:
// ============
// Start a new thread of execution
//
// PARAMETERS:
// ===========
// entryFunction   : A pointer to the thread entry point.
//
//
BOOL DCS_StartThread(LPTHREAD_START_ROUTINE entryFunction);
#endif // DLL_DISP



#ifndef DLL_DISP
BOOL COMReadEntry(HKEY    topLevelKey,
                                 LPSTR pSection,
                                 LPSTR pEntry,
                                 LPSTR pBuffer,
                                 int  bufferSize,
                                 ULONG expectedDataType);
#endif // DLL_DISP





#define MAKE_SUBALLOC_PTR(pPool, chunkOffset)   OFFSETBASE_TO_PTR(chunkOffset, pPool)

#define MAKE_SUBALLOC_OFFSET(pPool, pChunk)     PTRBASE_TO_OFFSET(pChunk, pPool)


//
//
// Return codes - all offset from UT_BASE_RC
//
//

enum
{
    UT_RC_OK                    = UT_BASE_RC,
    UT_RC_NO_MEM
};


//
// The maximum number of UT events which we try to process without yielding
//
#define MAX_EVENTS_TO_PROCESS    10


//
//
// Types
//
//

//
// Utility Functions Interface handle
//
typedef struct tagUT_CLIENT *    PUT_CLIENT;


#define UTTASK_FIRST        0
typedef enum
{
    UTTASK_UI = UTTASK_FIRST,
    UTTASK_CMG,
    UTTASK_OM,
    UTTASK_AL,
    UTTASK_DCS,
    UTTASK_WB,
    UTTASK_MAX
}
UT_TASK;


//
// Event procedure registered by UT_RegisterEvent().
//
// Takes event handler registered data, event number and 2 parameters
//      Returns TRUE if event processed
//      Returns FALSE if not and event should be passed on to next handler
//
//
typedef BOOL (CALLBACK * UTEVENT_PROC)(LPVOID, UINT, UINT_PTR, UINT_PTR);

//
// Exit procedure
//
typedef void (CALLBACK * UTEXIT_PROC)( LPVOID exitData );

//
// The name of the class used to create UT windows
//
#define UT_WINDOW_CLASS     "DCUTWindowClass"

//
// The ID of the timer to use for trigger events.
//
#define UT_DELAYED_TIMER_ID 0x10101010


//
//
// Prototypes
//
//

//
//
// Task routines
//
//   UT_WndProc()              Subclassing window procedure
//   UT_InitTask()             Initialise a task
//   UT_TermTask()             Terminate a task
//   UT_RegisterEvent()        Register an event handler
//   UT_DeregisterEvent()      Deregisters an event handler
//   UT_RegisterExit()         Register an exit routine
//   UT_DeregisterExit()       Deregister an exit routine
//   UT_PostEvent()            Send an event to a task
//
//

LRESULT CALLBACK  UT_WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL UT_InitTask(UT_TASK task, PUT_CLIENT * pputTask);

//
//
// Overview:
//   This registers a task and assigns it a handle.
//   All other Utility Functions require this handle to be passed to them.
//
//   If a task has already been registered with the same process ID, the
//   utilities handle that has already been allocated is returned.
//   This is to allows the Utility Functions to be used in the context of
//   tasks that DC-SHARE has intercepted the graphics calls for.
//
//   Each task is identified by a name.
//
// Parameters:
//
//   task
//     Unique it for identifying task
//
//   pUtHandle (returned)
//     Utility Services handle to be used for all calls to the Utility
//     Services by this task
//
//


void UT_TermTask(PUT_CLIENT * pputTask);
//
//
// Overview:
//   This de-registers a task
//   All task resources are freed and the utHandle is released
//
// Parameters:
//
//   utHandle
//     Utility Functions Handle
//

void UT_RegisterEvent(PUT_CLIENT      putTask,
                                UTEVENT_PROC eventProc,
                                LPVOID       eventData,
                                UT_PRIORITY  priority);

void UT_DeregisterEvent(PUT_CLIENT  putTask,
                                UTEVENT_PROC eventProc,
                                LPVOID      eventData);

void UT_PostEvent(PUT_CLIENT putTaskFrom,
                                     PUT_CLIENT putTaskTo,
                                     UINT    delay,
                                     UINT    eventNo,
                                     UINT_PTR param1,
                                     UINT_PTR param2);

#define NO_DELAY        0

//
//
// Overview:
//   This posts an event to another task.
//
// Parameters:
//
//   utHandle
//     Utility Functions handle of invoking task
//
//   toHandle
//     Utility Functions TASK handle of task to post event to
//
//   delay
//     Delay (in milliseconds) before event is posted
//
//   eventNo
//     event to be posted (see autevt.h for details of events)
//
//   param1
//     parameter 1 for event (meaning depends on event)
//
//   param2
//     parameter 2 for event (meaning depends on event)
//
//
// NOTES:
//
//   1)  The delay time is in milliseconds.  This may not be supported by
//       underlying OS but the setting and checking of the pop time value
//       is OS specific.
//
//   2)  The posting of events is asynchronous, the delay is simply
//       the time before the event is posted.  The task the event is
//       posted to will receive the event NOT BEFRE this time is up.
//
//   3)  If an event is posted with a delay specified, the sending task
//       must continue to process messages for the event to be posted
//

void UT_RegisterExit(PUT_CLIENT putTask, UTEXIT_PROC exitProc, LPVOID exitData);
void UT_DeregisterExit(PUT_CLIENT putTask, UTEXIT_PROC exitProc, LPVOID exitData);



//
// Memory routines
//      UT_MallocRefCount
//      UT_BumpUpRefCount
//      UT_FreeRefCount
//


void *  UT_MallocRefCount(UINT cbSizeMem, BOOL fZeroMem);
void    UT_BumpUpRefCount(void * pMemory);
void    UT_FreeRefCount(void ** ppMemory, BOOL fNullOnlyWhenFreed);


// Ref count allocs
typedef struct tagUTREFCOUNTHEADER
{
    STRUCTURE_STAMP
    UINT    refCount;
}
UTREFCOUNTHEADER;
typedef UTREFCOUNTHEADER * PUTREFCOUNTHEADER;



//
// UT_MoveMemory()
// Replacement for CRT memmove(); handles overlapping
//
void *  UT_MoveMemory(void * dst, const void * src, size_t count);



//
// Locks
// - UT_Lock()       - Locks a lock
// - UT_Unlock()     - Unlocks a lock
//

#ifndef DLL_DISP
extern CRITICAL_SECTION g_utLocks[UTLOCK_MAX];

__inline void UT_Lock(UTLOCK lock)
{
    ASSERT(lock >= UTLOCK_FIRST);
    ASSERT(lock < UTLOCK_MAX);

    EnterCriticalSection(&g_utLocks[lock]);
}

__inline void UT_Unlock(UTLOCK lock)
{
    ASSERT(lock >= UTLOCK_FIRST);
    ASSERT(lock < UTLOCK_MAX);

    LeaveCriticalSection(&g_utLocks[lock]);
}

#endif // DLL_DISP


//
// Tasks
// UT_HandleProcessStart()
// UT_HandleProcessEnd()
// UT_HandleThreadEnd()
//

BOOL UT_HandleProcessStart(HINSTANCE hInstance);

void UT_HandleProcessEnd(void);

void UT_HandleThreadEnd(void);



//
// Structure for holding an event.  The first two fields allow the event to
// be held on the delayed event Q to be scheduled later.
//
typedef struct tagUTEVENT_INFO
{
    STRUCTURE_STAMP

    BASEDLIST       chain;

    // Params
    UINT            event;
    UINT_PTR        param1;
    UINT_PTR        param2;

    PUT_CLIENT      putTo;
    UINT            popTime;
}
UTEVENT_INFO;
typedef UTEVENT_INFO  * PUTEVENT_INFO;


#ifndef DLL_DISP
void __inline ValidateEventInfo(PUTEVENT_INFO pEventInfo)
{
    ASSERT(!IsBadWritePtr(pEventInfo, sizeof(UTEVENT_INFO)));
}
#endif // DLL_DISP


//
// Information held about each exit procedure
//
typedef struct tagUTEXIT_PROC_INFO
{
    UTEXIT_PROC     exitProc;
    LPVOID          exitData;
} UTEXIT_PROC_INFO;
typedef UTEXIT_PROC_INFO * PUTEXIT_PROC_INFO;

//
// Information held about each event procedure
//
typedef struct tagUTEVENT_PROC_INFO
{
    UTEVENT_PROC    eventProc;
    LPVOID          eventData;
    UT_PRIORITY     priority;
}
UTEVENT_PROC_INFO;
typedef UTEVENT_PROC_INFO * PUTEVENT_PROC_INFO;


//
//
// UT_CLIENT
//
// Information stored about each Utilities registered task.  A pointer to
// this structure is returned as the UT Handle from UT_InitTask(), and is
// passed in as a parameter to subsequent calls to UT.
//
// This structure is allocated in the shared memory bank.
//
// This should be a multiple of 4 bytes to ensure DWORD alignment of the
// allocated memory
//
//
typedef struct tagUT_CLIENT
{
    DWORD               dwThreadId;
    HWND                utHwnd;         // Window to post UT events to

    UTEXIT_PROC_INFO    exitProcs[UTEXIT_PROCS_MAX];
                                         // Exit procedures registered for
                                         //   this task.
    UTEVENT_PROC_INFO   eventHandlers[UTEVENT_HANDLERS_MAX];
                                         // Event procedures registered for
                                         //   this task.

    BASEDLIST           pendingEvents;   // List of events for this task
                                         //   which are ready to be
                                         //   processed.
    BASEDLIST           delayedEvents;   // List of delayed events destined
                                         //   for this task.
}
UT_CLIENT;


#ifndef DLL_DISP
void __inline ValidateUTClient(PUT_CLIENT putTask)
{
    extern UT_CLIENT    g_autTasks[UTTASK_MAX];

    ASSERT(putTask >= &(g_autTasks[UTTASK_FIRST]));
    ASSERT(putTask < &(g_autTasks[UTTASK_MAX]));
    ASSERT(putTask->dwThreadId);
}
#endif // DLL_DISP


//
//
// UTTaskEnd(...)
//
//   This routine frees all resources associated with the task and
//   releases the handle
//
// Parameters:
//
//   pTaskData - The Utility Functions handle for the task that is ending
//
//
void UTTaskEnd(PUT_CLIENT putTask);



//
//
// Overview:
// This routine is called to check the status of delayed events and to post
// them to the target process if required.
//
// Parameters:
//
//   utHandle
//     Utility Functions handle of invoking task
//
// NOTES:
//
// 1) This routine is called periodically or whenever the application
//       believes a delayed event has popped.
//
// Return codes: None
//
//
void UTCheckEvents(PUT_CLIENT putTask);
void UTCheckDelayedEvents(PUT_CLIENT putTask);


//
//
// UTProcessEvent(...)
//
// Overview:
//   This process an event for the current task
//
//
// Parameters:
//
//   utHandle
//     Utility Functions Handle
//
//   event
//     The event to process
//
//   param1
//     The 1st parameter for the event
//
//   param2
//     The 2nd parameter for the event
//
//
void UTProcessEvent(PUT_CLIENT putTask, UINT event, UINT_PTR param1, UINT_PTR param2);


//
//
// UTProcessDelayedEvent(...)
//
// A delayed event destined for the current task is ready to be processed.
//
//   pTaskData   - The current tasks data.
//   eventOffset - Offset into the shared memory bank at which the event
//                 is stored.
//
//
void UTProcessDelayedEvent(PUT_CLIENT putTask, DWORD eventOffset);



//
//
// UTPostImmediateEvt(...)
//
// This function adds an event to a task's pending event queue, and posts
// a trigger event if required.
//
//   pSrcTaskData    - originating tasks data
//   pDestTaskData   - destination tasks data
//   event           - event data
//   param1          - parm1
//   param2          - parm2
//
//
void UTPostImmediateEvt(PUT_CLIENT          putTaskFrom,
                        PUT_CLIENT          putTaskTo,
                        UINT                event,
                        UINT_PTR            param1,
                        UINT_PTR            param2);


//
//
// UTPostDelayedEvt(...)
//
// This function adds an event to a task's delayed event queue, and starts
// a timer (on the destination's task) to get that task to process the
// event when the timer ticks.
//
//   pSrcTaskData    - originating tasks data
//   pDestTaskData   - destination tasks data
//   delay           - the delay (in milliseconds)
//   event           - event data
//   param1          - parm1
//   param2          - parm2
//
//
void UTPostDelayedEvt(PUT_CLIENT            putTaskFrom,
                                    PUT_CLIENT  putTaskTo,
                                   UINT         delay,
                                   UINT         event,
                                   UINT_PTR     param1,
                                   UINT_PTR     param2);

//
//
// Overview:
//   This posts a event to another task
//
// Parameters:
//
//   pSrcTaskInfo  - task data for the source task
//   pDestTaskInfo - task data for the dest task
//
void UTTriggerEvt(PUT_CLIENT putTaskFrom, PUT_CLIENT putTaskTo);


//
//
// Overview:
//   This starts a delayed-event timer for a task.
//
// Parameters:
//   pTaskData
//     The task data for the task
//
//   popTime
//     The target time for the timer to pop - this is an OS specific value
//     in the same format as that returned by UTPopTime().
//
//
void UTStartDelayedEventTimer(PUT_CLIENT putTask, UINT popTime);



#endif // _H_UT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\hook\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\hook\im.cpp ===
#include "precomp.h"


//
// IM.CPP
// Input Manager (controlling) Code
//
// Copyright(c) Microsoft 1997-
//


//
// FUNCTION: OSI_InstallHighLevelMouseHook
//
// DESCRIPTION:
//
// This function installs the IM high level mouse hook.  The mouse hook is
// used to block remote mouse input to non-hosted apps.
//
// PARAMETERS: None.
//
//
BOOL WINAPI OSI_InstallHighLevelMouseHook(BOOL fEnable)
{
    BOOL    rc = TRUE;

    DebugEntry(OSI_InstallHighLevelMouseHook);

    if (fEnable)
    {
        //
        // Check the hook is already installed.  This is quite possible.
        //
        if (g_imMouseHook)
        {
            TRACE_OUT(( "Mouse hook installed already"));
        }
        else
        {
            //
            // Install the mouse hook
            //
            g_imMouseHook = SetWindowsHookEx(WH_MOUSE, IMMouseHookProc,
                g_hookInstance, 0);

            if (!g_imMouseHook)
            {
                ERROR_OUT(("Failed to install mouse hook"));
                rc = FALSE;
            }
        }
    }
    else
    {
        //
        // Check the hook is already removed.  This is quite possible.
        //
        if (!g_imMouseHook)
        {
            TRACE_OUT(("Mouse hook not installed"));
        }
        else
        {
            //
            // Remove the mouse hook
            //
            UnhookWindowsHookEx(g_imMouseHook);
            g_imMouseHook = NULL;
        }
    }

    DebugExitBOOL(OSI_InstallHighLevelMouseHook, rc);
    return(rc);
}





//
// FUNCTION: IMMouseHookProc
//
// DESCRIPTION:
//
//
// PARAMETERS:
//
// See MouseProc documentation
//
// RETURNS:
//
// See MouseProc documentation (FALSE - allow event through, TRUE - discard
// event)
//
//
LRESULT CALLBACK IMMouseHookProc(int    code,
                                 WPARAM wParam,
                                 LPARAM lParam)
{
    LRESULT             rc;
    BOOL                block          = FALSE;
    BOOL                fShared;
    PMOUSEHOOKSTRUCT    lpMseHook    = (PMOUSEHOOKSTRUCT) lParam;

    DebugEntry(IMMouseHookProc);

    if (code < 0)
    {
        //
        // Pass the hook on if the code is negative (Windows hooking
        // protocol).
        //
        DC_QUIT;
    }

    //
    // Now decide if we should block this event.  We will block this event
    // if it is not destined for a hosted window.
    //
    // Note that on NT screensavers run in a different desktop.  We do not
    // journalrecord (and can't for winlogon/security reasons) on that
    // desktop and therefore never will see an HWND that is a screensaver.
    //
    fShared = HET_WindowIsHosted(lpMseHook->hwnd);

    if (wParam == WM_LBUTTONDOWN)
        g_fLeftDownOnShared = fShared;

    //
    // If this is some kind of mouse message to a window that isn't shared,
    // check if the window is the OLE32 dragdrop dude.
    //
    if (!fShared && g_fLeftDownOnShared)
    {
        TCHAR   szName[HET_CLASS_NAME_SIZE];

        if (::GetClassName(lpMseHook->hwnd, szName, CCHMAX(szName)) &&
            !lstrcmpi(szName, HET_OLEDRAGDROP_CLASS) &&
            (::GetCapture() == lpMseHook->hwnd))
        {
            //
            // Note side-effect of this:
            // Mouse moves over non-shared areas when in OLE drag drop mode
            // WILL be passed on to non-shared window.
            //
            // But that's way better than it not working at all.
            //
            WARNING_OUT(("NMASNT: Hacking OLE drag drop; left click down on shared window then OLE took capture"));
            fShared = TRUE;
        }
    }

    block  = !fShared;

    TRACE_OUT(("MOUSEHOOK: hwnd %08lx -> block: %s",
             lpMseHook->hwnd,
             block ? "YES" : "NO"));

DC_EXIT_POINT:
    //
    // Call the next hook.
    //
    rc = CallNextHookEx(g_imMouseHook, code, wParam, lParam);

    if (block)
    {
        //
        // We want to block this event so return a non-zero value.
        //
        rc = 1;
    }

    DebugExitDWORD(IMMouseHookProc, (DWORD)rc);
    return(rc);
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\hook\globals.cpp ===
//
// GLOBALS.CPP
// Global Variable Storage
//
// Copyright(c) Microsoft 1997-
//

#include "precomp.h"


#include <datainit.h>
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\h\wb.hpp ===
//
// Whiteboard Applet Functions
//

#ifndef _HPP_WB
#define _HPP_WB


extern "C"
{
    #include <al.h>
}


//
// Page in use flag for page state structure
//
#define PAGE_IN_USE                         1
#define PAGE_NOT_IN_USE                     2

//
// Page sub-states used during add and delete of pages.  Different actions
// are required depending on whether the page is being added/deleted
// locally or remotely.
//
#define PAGE_STATE_EMPTY                    1
#define PAGE_STATE_LOCAL_OPEN_CONFIRM       2
#define PAGE_STATE_EXTERNAL_OPEN_CONFIRM    3
#define PAGE_STATE_READY                    4
#define PAGE_STATE_EXTERNAL_ADD             5

#define PAGE_STATE_LOCAL_DELETE             6
#define PAGE_STATE_LOCAL_DELETE_CONFIRM     7
#define PAGE_STATE_EXTERNAL_DELETE          8
#define PAGE_STATE_EXTERNAL_DELETE_CONFIRM  9

//
// Page manipulation values
//
#define OPEN_LOCAL                          1
#define OPEN_EXTERNAL                       2

#define PAGE_FIRST                          1
#define PAGE_LAST                           2
#define PAGE_BEFORE                         3
#define PAGE_AFTER                          4

//
// Workset Ids
//
#define USER_INFORMATION_WORKSET            0
#define PAGE_CONTROL_WORKSET                1
#define SYNC_CONTROL_WORKSET                2

#define FIRST_PAGE_WORKSET                  5

//
// Number of pages to initialize during registration.  During registration
// the number of pages defined here will have worksets opened for them and
// will be ready to be allocated through WBP_PageAdd calls.
//
#define PREINITIALIZE_PAGES               10

//
// Object types for Page Control Workset objects
//
#define TYPE_CONTROL_PAGE_ORDER            1
#define TYPE_CONTROL_LOCK                  2

//
// Registration state table
//
// The following table shows the transitions made during registration.
//
// S0    = STATE_ERROR
// S1    = STATE_REG_START
// S2    = STATE_REG_PENDING_WSGROUP_CON
// S3    = STATE_REG_PENDING_WORKSET_OPEN
// S4    = STATE_REG_PENDING_LOCK
// S5    = STATE_REG_PENDING_PAGE_CONTROL
// S6    = STATE_REG_PENDING_UNLOCK
// SIDLE = STATE_IDLE
//
//                          S0    S1    S2    S3    S4    S5    S6    SIDLE
//
// WBP_Start                -     A1    AE    AE    AE    AE    AE    AE
// OM_WSGROUP_REGISTER_CON  i     i     A2    e     e     e     e     e
// OM_WORKSET_OPEN_CON      i     i     e     A3    e     e     e     *
// OM_WORKSET_LOCK_CON      i     i     e     e     A4    e     e     e
// OM_OBJECT_ADD_IND        i     i     i     i     i     A5    e     *
// OM_WORKSET_UNLOCK_IND    i     i     i     i     i     i     A6    *
// OM_NETWORK_LOST_IND      A7    i     A7    A7    A7    A7    A7    A7
// OM_OUT_OF_RESOURCES_IND  i     i     AR1   AR1   AR2   AR2   AR1   AR1
// WBP_Stop                 AD0   AN    AD0   AD0   AD2   AD2   AD0   AD0
//
// WBP_... called           AE    AN    AN    AN    AN    AN    AN    *
//
// Actions:
//
// e    Error - log unexpected event and ignore
// i    Ignore
// *    Not described in this table
//
// AN   Return a "Not registered" error to caller
//      (No state change)
//
// AE   Return an "Out of resources" error to caller
//      (No state change)
//
// A1   Call OM_Register
//      Call OM_WSGroupRegister
//      Move to S2
//
// A2   Open all worksets (0, 1, 2, and 5-254)
//      If error perform AD0
//      Else move to S3
//
// A3   If all worksets open
//          If Page Control Object exists
//              Move to SIDLE
//          Else
//              Request lock
//              Move to S4
//          Endif
//      Endif
//
// A4   If lock acquired OK
//          Add Page Control Object
//          Move to S5
//      Else
//          If locked by another person
//              Move to S5
//          Else
//              Perform AD
//          Endif
//      Endif
//
// A5   If add is for Page Control Object
//          If we have the Page Control Workset lock
//              Release the lock
//          Else
//              Perform A6
//          Endif
//      Endif
//
// A6   Post WBP_EVENT_REGISTERED to client
//      If a lock is present
//          Post lock notification to client
//      Endif
//      Move to SIDLE
//
// A7   Post WBP_EVENT_NETWORK_LOST to client
//      (No state change.)
//
// AD2  Unlock Page Control Workset
// AD0  Deregister from ObMan
//      Post WBP_EVENT_DEREGISTERED to client
//      Move to S1
//
//

//
// Major states occupied by a client
//
#define STATE_EMPTY                     0
#define STATE_STARTING                  1
#define STATE_STARTED                   2
#define STATE_REGISTERING               3
#define STATE_IDLE                      4

//
// Sub-states occupied during start-up
//
#define STATE_START_START                    1
#define STATE_START_REGISTERED_EVENT         2
#define STATE_START_REGISTERED_OM            3
#define STATE_START_REGISTERED_EXIT          4

//
// Sub-states occupied after start-up, but before joining a call.
//
#define STATE_STARTED_START                  5

//
// Sub-states occupied during registration.  These must be defined to
// increase monotonically as we step through the registration process.
//
#define STATE_REG_START                      6
#define STATE_REG_PENDING_WSGROUP_CON        7
#define STATE_REG_PENDING_USER_WORKSET       8
#define STATE_REG_PENDING_WORKSET_OPEN       9
#define STATE_REG_USER_OBJECT_ADDED         10
#define STATE_REG_PENDING_LOCK              11
#define STATE_REG_PENDING_PAGE_CONTROL      12
#define STATE_REG_PENDING_SYNC_CONTROL      13
#define STATE_REG_PENDING_UNLOCK            14
#define STATE_REG_PENDING_PAGE_ORDER        15
#define STATE_REG_PENDING_READY_PAGES       16
#define STATE_REG_END                       17

#define STATE_REG_PENDING_WSGROUP_MOVE      18
#define STATE_REG_PENDING_NEW_USER_OBJECT   19

//
// Error states
//
#define ERROR_STATE_EMPTY               0
#define ERROR_STATE_FATAL               1

//
// Lock states
//
typedef enum
{
    LOCK_STATE_EMPTY    = 0,
    LOCK_STATE_PENDING_LOCK,
    LOCK_STATE_PENDING_ADD,
    LOCK_STATE_GOT_LOCK,
    LOCK_STATE_PENDING_DELETE,
    LOCK_STATE_LOCKED_OUT,
    LOCK_STATE_CANCEL_LOCK
}
WB_LOCK_STATE;

//
// Load states
//
#define LOAD_STATE_EMPTY                0
#define LOAD_STATE_PENDING_CLEAR        1
#define LOAD_STATE_PENDING_DELETE       2
#define LOAD_STATE_LOADING              3
#define LOAD_STATE_PENDING_NEW_PAGE     4


//
// Call id for local calls
//
#define WB_NO_CALL OM_NO_CALL

//
// Limit defines
//
// Maximum number of pages allowed in the Whiteboard
//
#define WB_MAX_PAGES               250

//
// Length of font face (must be a multiple of 4)
//
#define WB_FACENAME_LEN              32

//
// Lock type definitions
//
typedef enum
{
    WB_LOCK_TYPE_NONE = 0,
    WB_LOCK_TYPE_PAGE_ORDER,
    WB_LOCK_TYPE_CONTENTS
}
WB_LOCK_TYPE;

//
// Graphic lock definitions
//
typedef enum
{
    WB_GRAPHIC_LOCK_NONE = 0,
    WB_GRAPHIC_LOCK_LOCAL,
    WB_GRAPHIC_LOCK_REMOTE
}
WB_GRAPHIC_LOCK_TYPE;


//
// Return codes
//

enum
{
    WB_RC_NOT_LOCKED = WB_BASE_RC,
    WB_RC_LOCKED,
    WB_RC_BAD_FILE_FORMAT,
    WB_RC_WRITE_FAILED,
    WB_RC_BAD_PAGE_HANDLE,
    WB_RC_BAD_PAGE_NUMBER,
    WB_RC_CHANGED,
    WB_RC_NOT_CHANGED,
    WB_RC_NO_SUCH_PAGE,
    WB_RC_NO_SUCH_GRAPHIC,
    WB_RC_NO_SUCH_PERSON,
    WB_RC_TOO_MANY_PAGES,
    WB_RC_ALREADY_LOADING,
    WB_RC_BUSY,
    WB_RC_GRAPHIC_LOCKED,
    WB_RC_GRAPHIC_NOT_LOCKED,
    WB_RC_NOT_LOADING,
    WB_RC_CREATE_FAILED,
    WB_RC_READ_FAILED
};


//
// Events
//

enum
{
    WBPI_EVENT_LOAD_NEXT                = WB_BASE_EVENT,
    WBP_EVENT_JOIN_CALL_OK,
    WBP_EVENT_JOIN_CALL_FAILED,
    WBP_EVENT_NETWORK_LOST,
    WBP_EVENT_ERROR,
    WBP_EVENT_CONTENTS_LOCKED,
    WBP_EVENT_UNLOCKED,
    WBP_EVENT_LOCK_FAILED,
    WBP_EVENT_PAGE_CLEAR_IND,
    WBP_EVENT_PAGE_ORDER_UPDATED,
    WBP_EVENT_PAGE_DELETE_IND,
    WBP_EVENT_PAGE_ORDER_LOCKED,
    WBP_EVENT_GRAPHIC_ADDED,
    WBP_EVENT_GRAPHIC_MOVED,
    WBP_EVENT_GRAPHIC_UPDATE_IND,
    WBP_EVENT_GRAPHIC_REPLACE_IND,
    WBP_EVENT_GRAPHIC_DELETE_IND,
    WBP_EVENT_PERSON_JOINED,
    WBP_EVENT_PERSON_LEFT,
    WBP_EVENT_PERSON_UPDATE,
    WBP_EVENT_PERSON_REPLACE,
    WBP_EVENT_LOAD_FAILED,
    WBP_EVENT_INSERT_OBJECTS,
    WBP_EVENT_INSERT_NEXT,
    WBP_EVENT_SYNC_POSITION_UPDATED,
    WBP_EVENT_LOAD_COMPLETE
};


//
// Type declarations
//


//
// Page handle.  This is actually an index into the array of pages.
//
typedef OM_WORKSET_ID               WB_PAGE_HANDLE;
typedef WB_PAGE_HANDLE *        PWB_PAGE_HANDLE;
typedef PWB_PAGE_HANDLE *       PPWB_PAGE_HANDLE;

#define WB_PAGE_HANDLE_NULL         ((WB_PAGE_HANDLE) 0)

//
// Graphic handle.  These are handles to graphic objects in the various
// page worksets.
//
typedef POM_OBJECT           WB_GRAPHIC_HANDLE;
typedef WB_GRAPHIC_HANDLE *     PWB_GRAPHIC_HANDLE;
typedef PWB_GRAPHIC_HANDLE *    PPWB_GRAPHIC_HANDLE;


//
// Workset type constants
//
#define TYPE_FILE_HEADER                  0
#define TYPE_END_OF_PAGE                  1
#define TYPE_END_OF_FILE                  2

//
// Graphic type constants
//
#define TYPE_GRAPHIC_FREEHAND             3
#define TYPE_GRAPHIC_LINE                 4
#define TYPE_GRAPHIC_RECTANGLE            5
#define TYPE_GRAPHIC_FILLED_RECTANGLE     6
#define TYPE_GRAPHIC_ELLIPSE              7
#define TYPE_GRAPHIC_FILLED_ELLIPSE       8
#define TYPE_GRAPHIC_TEXT                 9
#define TYPE_GRAPHIC_DIB                 10


//
// Objects used in the Page Control and Lock worksets are used only by the
// API functions.  They are never passed back to the Client.
//

//
// Structure used to build the Page Control Object kept in the Page Control
// Workset.  This object contains a list of workset IDs in page order (i.e.
// the ID for page 1 comes first).
//
// The structure allows for the maximum number of pages.  When it is
// written to the Page Control Object only as many entries as are in use
// are written.
//
// Note that the generation number field has been split into a hiword and
// a loword - this is because the original definition had an unaligned
// TSHR_UINT32 which caused the compiler to insert padding into the structure,
// thus breaking backwards compatibility.
//
typedef struct tagWB_PAGE_ORDER
{
  TSHR_UINT16       objectType;            // Object type = TYPE_CONTROL_PAGES
  TSHR_UINT16       generationLo;          // Generation number of object
  TSHR_UINT16       generationHi;
  TSHR_UINT16       countPages;            // Number of active pages
  OM_WORKSET_ID  pages[WB_MAX_PAGES];   // List of worksets (in page order)
} WB_PAGE_ORDER;

typedef WB_PAGE_ORDER  *        PWB_PAGE_ORDER;
typedef PWB_PAGE_ORDER *        PPWB_PAGE_ORDER;

//
// Lock object - kept in the Page Control Workset indicating the type and
// owner of the current lock.
//
typedef struct tagWB_LOCK
{
  TSHR_UINT16       objectType;            // Object type = TYPE_CONTROL_LOCK
  TSHR_UINT16       lockType;              // Type of lock
                                        // WB_LOCK_TYPE_NONE
                                        // WB_LOCK_TYPE_PAGE_ORDER
                                        // WB_LOCK_TYPE_CONTENTS
  OM_OBJECT_ID   personID;              // Id of person holding lock
} WB_LOCK;

typedef WB_LOCK *               PWB_LOCK;
typedef PWB_LOCK *              PPWB_LOCK;


//
// Graphic object header.
//

//
// WB Tool Types (not type; toolType)
//
#define WBTOOL_PEN          1
#define WBTOOL_TEXT         3

typedef struct tagWB_GRAPHIC
{
  //
  // All graphic and file objects must start with these three fields
  //
  TSHR_UINT32  length;                 // Total length of structure
  TSHR_UINT16  type;                   // Type of object
  TSHR_UINT16  dataOffset;             // Offset to graphic data from start

  //
  // All graphic objects have these fields
  //
  TSHR_RECT16  rectBounds;          // Bounding rectangle
  TSHR_COLOR   color;                  // Pen color (3 bytes)
  TSHR_UINT8   locked;                 // Flag indicating a person is editing
  TSHR_UINT16  penWidth;               // Pen width
  TSHR_UINT16  penStyle;               // Pen style
  TSHR_RECT16  rect;                   // Rectangle used for defining object
  OM_OBJECT_ID lockPersonID;        // ID of locking person. This field is
                                    // maintained by the core and should not
                                    // be altered by clients.
  TSHR_UINT16  rasterOp;               // Drawing mode
  TSHR_UINT8   smoothed;               // Use curve smoothing algorithm
  TSHR_UINT8   toolType;               // Type of tool used
  TSHR_UINT16  loadedFromFile;         // Was this object loaded from file?
  NET_UID   loadingClientID;        // ID of the client which loaded this
                                    // object from file (only used if the
                                    // loadedFromFile field is set).
                                    // (This is defined as a TSHR_UINT16).
  TSHR_UINT32  reserved1;              // Extra space for later additions
  TSHR_UINT32  reserved2;              // Extra space for later additions
} WB_GRAPHIC;

typedef WB_GRAPHIC *           PWB_GRAPHIC;
typedef PWB_GRAPHIC *          PPWB_GRAPHIC;

//
// Freehand line
//
typedef struct tagWB_GRAPHIC_FREEHAND
{
  WB_GRAPHIC header;                // Basic information
  TSHR_UINT16   pointCount;            // Number of points in the polyline
  TSHR_POINT16  points[1];             // Array of points
} WB_GRAPHIC_FREEHAND;

typedef WB_GRAPHIC_FREEHAND *   PWB_GRAPHIC_FREEHAND;
typedef PWB_GRAPHIC_FREEHAND *  PPWB_GRAPHIC_FREEHAND;

//
// Text
//
typedef struct tagWB_GRAPHIC_TEXT
{
    WB_GRAPHIC header;                // Basic information
    TSHR_INT16    charHeight;            // Character height
    TSHR_UINT16   averageCharWidth;      // Average character width
    TSHR_UINT16   strokeWeight;          // Stroke weight (normal, bold)
    TSHR_UINT8    italic;                // Italic flag
    TSHR_UINT8    underline;             // Underline flag
    TSHR_UINT8    strikeout;             // Strikeout flag
    TSHR_UINT8    pitch;                 // Fixed/variable pitch
    TSHR_CHAR     faceName[WB_FACENAME_LEN]; // Font face name
    TSHR_UINT16   codePage;              // Font code page
    TSHR_UINT16   stringCount;           // Number of lines of text
    TSHR_CHAR  text[1];               // Null-terminated text strings
}
WB_GRAPHIC_TEXT;

typedef WB_GRAPHIC_TEXT  *      PWB_GRAPHIC_TEXT;
typedef PWB_GRAPHIC_TEXT *      PPWB_GRAPHIC_TEXT;

//
// Bitmap image
//
typedef struct tagWB_GRAPHIC_DIB
{
  WB_GRAPHIC header;                // Basic information
                                    // Data bytes follow this structure
} WB_GRAPHIC_DIB;

typedef WB_GRAPHIC_DIB  *       PWB_GRAPHIC_DIB;
typedef PWB_GRAPHIC_DIB *       PPWB_GRAPHIC_DIB;

//
// Person object
//
typedef struct tagWB_PERSON
{
    TSHR_CHAR       personName[TSHR_MAX_PERSON_NAME_LEN]; // Person name
    TSHR_UINT16       colorId;               // Color identifier for the person
    TSHR_UINT8        synced;                // Sync flag
    WB_PAGE_HANDLE    currentPage;           // Handle of current page
    TSHR_RECT16    visibleRect;           // Area person can see in window
    TSHR_UINT8       pointerActive;         // Remote pointer in use flag
    WB_PAGE_HANDLE pointerPage;           // Page for remote pointer
    TSHR_POINT16      pointerPos;            // Position of pointer in page
    TSHR_PERSONID cmgPersonID;           // Call Manager personID.
    TSHR_UINT32       reserved1;             // Reserved for future use.
    TSHR_UINT32       reserved2;             // Reserved for future use.
}
WB_PERSON;

typedef WB_PERSON  *              PWB_PERSON;
typedef PWB_PERSON *              PPWB_PERSON;

//
// size used by core to update the user object - front ends should only
// replace user objects via the WBP_SetLocalPersonData API function.
//
#define WB_PERSON_OBJECT_UPDATE_SIZE   (FIELD_OFFSET(WB_PERSON, synced))

//
// Sync object
//
typedef struct tagWB_SYNC
{
    TSHR_UINT32       length;                // Length of the structure
    TSHR_UINT16       dataOffset;            // Offset to data from start
    WB_PAGE_HANDLE currentPage;           // Handle of current page
    TSHR_UINT8        pad;                   // Pad
    TSHR_RECT16    visibleRect;           // Area visible in person's window
    TSHR_UINT16       zoomed;                // Zoom sync participants
}
WB_SYNC;

typedef WB_SYNC  *              PWB_SYNC;
typedef PWB_SYNC *              PPWB_SYNC;


//
// Constant to use instead of sizeof(WB_SYNC).
//
// The WB_SYNC structure was not defined correctly in previous versions
// of Groupware (it was not padded correctly to a multiple of 4 bytes).
// Some compilers (e.g. on NT) insert padding, so the structure is not the
// same size as on Win95 for example.  This results in an assert from
// Obman...  So we define a constant which is the same whatever compiler we
// use.
//
#define WB_SYNC_SIZE    18


//
// File header for Whiteboard format files
//
typedef struct tagWB_FILE_HEADER
{
  TSHR_UINT32 length;                  // Total length of object
  TSHR_UINT16 type;                    // Type of file object
  TSHR_UINT16 dataOffset;              // Not used (but must be here)
  char   functionProfile[OM_MAX_FP_NAME_LEN];
} WB_FILE_HEADER;

typedef WB_FILE_HEADER *        PWB_FILE_HEADER;
typedef PWB_FILE_HEADER *       PPWB_FILE_HEADER;

//
// End-of-page object for writing to file
//
typedef struct tagWB_END_OF_PAGE
{
  TSHR_UINT32 length;                  // Total length of object
  TSHR_UINT16 type;                    // Type of file object
  TSHR_UINT16 dataOffset;              // Not used (but must be here)
} WB_END_OF_PAGE;

typedef WB_END_OF_PAGE *        PWB_END_OF_PAGE;
typedef PWB_END_OF_PAGE *       PPWB_END_OF_PAGE;

//
// End-of-file object
//
typedef WB_END_OF_PAGE              WB_END_OF_FILE;
typedef WB_END_OF_FILE *        PWB_END_OF_FILE;
typedef PWB_END_OF_FILE *       PPWB_END_OF_FILE;



//
// Structure used for determining the current sync page
//
typedef struct tagWB_SYNC_CONTROL
{
  OM_OBJECT_ID personID;                // ID of person who wrote object
  WB_SYNC      sync;                    // Sync position details
} WB_SYNC_CONTROL;

typedef WB_SYNC_CONTROL  *      PWB_SYNC_CONTROL;
typedef PWB_SYNC_CONTROL *      PPWB_SYNC_CONTROL;

//
// Constant to use instead of sizeof(WB_SYNC_CONTROL).
//
// The WB_SYNC structure was not defined correctly in previous versions
// of Groupware (it was not padded correctly to a multiple of 4 bytes).
// Some compilers (e.g. on NT) insert padding, so the structure is not the
// same size as on Win95 for example.  This results in an assert from
// Obman...  So we define a constant which is the same whatever compiler we
// use.
//
#define WB_SYNC_CONTROL_SIZE (sizeof(OM_OBJECT_ID) + WB_SYNC_SIZE)


//
// Structures used for maintaining and accessing the page list internally.
// The page state structure combine the internal and external page state.
//
typedef struct tagWB_PAGE_STATE
{
    TSHR_UINT16 state;                       // Page in use flag
    TSHR_UINT16 subState;                    // Page state
    OM_CORRELATOR   worksetOpenCorrelator;
}
WB_PAGE_STATE;

typedef WB_PAGE_STATE  *         PWB_PAGE_STATE;
typedef PWB_PAGE_STATE *         PPWB_PAGE_STATE;

//
// Secondary shared memory structure.
//
// Although we are adding objects, not pages, since each objects can be
// placed on a new page, this structure is limited to the max number of
// pages.
//
#define WB_MAX_INSERTS  250

#if WB_MAX_PAGES > WB_MAX_INSERTS
#error Number of pages is now greater than number of insertable objects
#endif // WB_MAX_PAGES > WB_MAX_INSERTS



//
// Values for changedFlagAction
//
#define  RESET_CHANGED_FLAG      0
#define  DONT_RESET_CHANGED_FLAG  1


//
// Convert between page handles, workset IDs and indices into the page list
// array of pages.
//
#define PAGE_HANDLE_TO_INDEX(hPage) \
                          ((TSHR_UINT16) ((hPage) - FIRST_PAGE_WORKSET))

#define PAGE_INDEX_TO_HANDLE(index) \
                          ((WB_PAGE_HANDLE) ((index) + FIRST_PAGE_WORKSET))

#define PAGE_WORKSET_ID_TO_INDEX(worksetID) \
                          ((TSHR_UINT16) ((worksetID) - FIRST_PAGE_WORKSET))

#define PAGE_INDEX_TO_WORKSET_ID(index) \
                          ((OM_WORKSET_ID) ((index) + FIRST_PAGE_WORKSET))



//
// Client interface
//
#undef INTERFACE
#define INTERFACE   IWbClient

DECLARE_INTERFACE(IWbClient)
{
    STDMETHOD_(void, WBP_Stop)(THIS_ UTEVENT_PROC) PURE;
    STDMETHOD_(void, WBP_PostEvent)(THIS_ UINT delay, UINT event, UINT_PTR param1, UINT_PTR param2) PURE;
    STDMETHOD_(UINT, WBP_JoinCall)(THIS_ BOOL keep, UINT callID) PURE;

    STDMETHOD_(UINT, WBP_ValidateFile)(THIS_ LPCSTR fileName, HANDLE * phFile) PURE;
    STDMETHOD_(UINT, WBP_CancelLoad)(THIS_) PURE;
    STDMETHOD_(UINT, WBP_ContentsLoad)(THIS_ LPCSTR fileName) PURE;
    STDMETHOD_(UINT, WBP_ContentsSave)(THIS_ LPCSTR fileName) PURE;
    STDMETHOD_(UINT, WBP_ContentsDelete)(THIS_) PURE;
    STDMETHOD_(UINT, WBP_ContentsCountPages)(THIS_) PURE;
    STDMETHOD_(BOOL, WBP_ContentsChanged)(THIS_) PURE;
    STDMETHOD_(void, WBP_ContentsLock)(THIS_) PURE;

    STDMETHOD_(void, WBP_PageOrderLock)(THIS_) PURE;
    STDMETHOD_(void, WBP_Unlock)(THIS_) PURE;
    STDMETHOD_(WB_LOCK_TYPE, WBP_LockStatus)(THIS_ POM_OBJECT * ppObjPersonLock) PURE;

    STDMETHOD_(UINT, WBP_PageClear)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(void, WBP_PageClearConfirm)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(UINT, WBP_PageAddBefore)(THIS_ WB_PAGE_HANDLE hRefPage, PWB_PAGE_HANDLE phPage) PURE;
    STDMETHOD_(UINT, WBP_PageAddAfter)(THIS_ WB_PAGE_HANDLE hRefPage, PWB_PAGE_HANDLE phPage) PURE;
    STDMETHOD_(UINT, WBP_PageHandle)(THIS_ WB_PAGE_HANDLE hRefPage, UINT where, PWB_PAGE_HANDLE phPageResult) PURE;
    STDMETHOD_(UINT, WBP_PageHandleFromNumber)(THIS_ UINT pageNumber, PWB_PAGE_HANDLE phPage) PURE;
    STDMETHOD_(UINT, WBP_PageNumberFromHandle)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(UINT, WBP_PageDelete)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(void, WBP_PageDeleteConfirm)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(UINT, WBP_PageMove)(THIS_ WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where) PURE;
    STDMETHOD_(UINT, WBP_PageCountGraphics)(THIS_ WB_PAGE_HANDLE hPage) PURE;

    STDMETHOD_(UINT, WBP_GraphicAllocate)(THIS_ WB_PAGE_HANDLE hPage, UINT length, PPWB_GRAPHIC ppGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicAddLast)(THIS_ WB_PAGE_HANDLE hPage, PWB_GRAPHIC pGraphic, PWB_GRAPHIC_HANDLE phGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicUpdateRequest)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicUpdateConfirm)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicReplaceRequest)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicReplaceConfirm)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicDeleteRequest)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicDeleteConfirm)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicMove)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, UINT where) PURE;
    STDMETHOD_(UINT, WBP_GraphicSelect)(THIS_ WB_PAGE_HANDLE hPage, POINT pt, WB_GRAPHIC_HANDLE hRefGraphic, UINT where, PWB_GRAPHIC_HANDLE phGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicGet)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PPWB_GRAPHIC ppGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicRelease)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicUnlock)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicHandle)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hRefGraphic, UINT where, PWB_GRAPHIC_HANDLE phGraphic) PURE;

    STDMETHOD_(void, WBP_PersonHandleFirst)(THIS_ POM_OBJECT * ppObjUser) PURE;
    STDMETHOD_(UINT, WBP_PersonHandleNext)(THIS_ POM_OBJECT pObj, POM_OBJECT * ppObjNext) PURE;
    STDMETHOD_(void, WBP_PersonHandleLocal)(THIS_ POM_OBJECT * ppObjLocal) PURE;
    STDMETHOD_(UINT, WBP_PersonCountInCall)(THIS_) PURE;
    STDMETHOD_(UINT, WBP_GetPersonData)(THIS_ POM_OBJECT pObjPerson, PWB_PERSON pPerson) PURE;
    STDMETHOD_(UINT, WBP_SetLocalPersonData)(THIS_ PWB_PERSON pPerson) PURE;
    STDMETHOD_(void, WBP_PersonUpdateConfirm)(THIS_ POM_OBJECT pObj) PURE;
    STDMETHOD_(void, WBP_PersonReplaceConfirm)(THIS_ POM_OBJECT pObj) PURE;
    STDMETHOD_(void, WBP_PersonLeftConfirm)(THIS_ POM_OBJECT pObj) PURE;

    STDMETHOD_(UINT, WBP_SyncPositionGet)(THIS_ PWB_SYNC pSync) PURE;
    STDMETHOD_(UINT, WBP_SyncPositionUpdate)(THIS_ PWB_SYNC pSync) PURE;
};

class WbClient : public IWbClient
{
public:
// IWbClient interface
    STDMETHODIMP_(void) WBP_Stop(UTEVENT_PROC eventProc);
    STDMETHODIMP_(void) WBP_PostEvent(UINT delay, UINT event, UINT_PTR param1, UINT_PTR param2);
    STDMETHODIMP_(UINT) WBP_JoinCall(BOOL keep, UINT callID);

    STDMETHODIMP_(UINT) WBP_ValidateFile(LPCSTR fileName, HANDLE * phFile);
    STDMETHODIMP_(UINT) WBP_CancelLoad(void);
    STDMETHODIMP_(UINT) WBP_ContentsLoad(LPCSTR fileName);
    STDMETHODIMP_(UINT) WBP_ContentsSave(LPCSTR fileName);
    STDMETHODIMP_(UINT) WBP_ContentsDelete(void);
    STDMETHODIMP_(UINT) WBP_ContentsCountPages(void);
    STDMETHODIMP_(BOOL) WBP_ContentsChanged(void);
    STDMETHODIMP_(void) WBP_ContentsLock(void);

    STDMETHODIMP_(void) WBP_PageOrderLock(void);
    STDMETHODIMP_(void) WBP_Unlock(void);
    STDMETHODIMP_(WB_LOCK_TYPE) WBP_LockStatus(POM_OBJECT * ppObjPersonLock);

    STDMETHODIMP_(UINT) WBP_PageClear(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(void) WBP_PageClearConfirm(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(UINT) WBP_PageAddBefore(WB_PAGE_HANDLE hRefPage, PWB_PAGE_HANDLE phPage);
    STDMETHODIMP_(UINT) WBP_PageAddAfter(WB_PAGE_HANDLE hRefPage, PWB_PAGE_HANDLE phPage);
    STDMETHODIMP_(UINT) WBP_PageHandle(WB_PAGE_HANDLE hRefPage, UINT where, PWB_PAGE_HANDLE phPageResult);
    STDMETHODIMP_(UINT) WBP_PageHandleFromNumber(UINT pageNumber, PWB_PAGE_HANDLE phPage);
    STDMETHODIMP_(UINT) WBP_PageNumberFromHandle(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(UINT) WBP_PageDelete(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(void) WBP_PageDeleteConfirm(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(UINT) WBP_PageMove(WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where);
    STDMETHODIMP_(UINT) WBP_PageCountGraphics(WB_PAGE_HANDLE hPage);

    STDMETHODIMP_(UINT) WBP_GraphicAllocate(WB_PAGE_HANDLE hPage, UINT length, PPWB_GRAPHIC ppGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicAddLast(WB_PAGE_HANDLE hPage, PWB_GRAPHIC pGraphic, PWB_GRAPHIC_HANDLE phGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicUpdateRequest(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic);
    STDMETHODIMP_(void) WBP_GraphicUpdateConfirm(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicReplaceRequest(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic);
    STDMETHODIMP_(void) WBP_GraphicReplaceConfirm(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicDeleteRequest(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(void) WBP_GraphicDeleteConfirm(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicMove(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, UINT where);
    STDMETHODIMP_(UINT) WBP_GraphicSelect(WB_PAGE_HANDLE hPage, POINT pt, WB_GRAPHIC_HANDLE hRefGraphic, UINT where, PWB_GRAPHIC_HANDLE phGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicGet(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PPWB_GRAPHIC ppGraphic);
    STDMETHODIMP_(void) WBP_GraphicRelease(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic);
    STDMETHODIMP_(void) WBP_GraphicUnlock(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicHandle(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hRefGraphic, UINT where, PWB_GRAPHIC_HANDLE phGraphic);

    STDMETHODIMP_(void) WBP_PersonHandleFirst(POM_OBJECT * ppObjUser);
    STDMETHODIMP_(UINT) WBP_PersonHandleNext(POM_OBJECT pObj, POM_OBJECT * ppObjNext);
    STDMETHODIMP_(void) WBP_PersonHandleLocal(POM_OBJECT * ppObjLocal);
    STDMETHODIMP_(UINT) WBP_PersonCountInCall(void);
    STDMETHODIMP_(UINT) WBP_GetPersonData(POM_OBJECT pObjPerson, PWB_PERSON pPerson);
    STDMETHODIMP_(UINT) WBP_SetLocalPersonData(PWB_PERSON pPerson);
    STDMETHODIMP_(void) WBP_PersonUpdateConfirm(POM_OBJECT pObj);
    STDMETHODIMP_(void) WBP_PersonReplaceConfirm(POM_OBJECT pObj);
    STDMETHODIMP_(void) WBP_PersonLeftConfirm(POM_OBJECT pObj);

    STDMETHODIMP_(UINT) WBP_SyncPositionGet(PWB_SYNC pSync);
    STDMETHODIMP_(UINT) WBP_SyncPositionUpdate(PWB_SYNC pSync);

    BOOL    WbInit(PUT_CLIENT putClient, UTEVENT_PROC eventProc);

protected:
// Internal functions
    PWB_PAGE_STATE GetPageState(WB_PAGE_HANDLE hPage)
    {
        ASSERT((hPage >= FIRST_PAGE_WORKSET) && (hPage <= FIRST_PAGE_WORKSET + WB_MAX_PAGES - 1));
        return(&((m_pageStates)[PAGE_HANDLE_TO_INDEX(hPage)]));
    }

    void    wbContentsDelete(UINT changedFlagAction);
    UINT    wbLock(WB_LOCK_TYPE lockType);
    void    wbUnlock(void);
    UINT    wbPageHandle(WB_PAGE_HANDLE hPage, UINT where, PWB_PAGE_HANDLE phPage);
    UINT    wbPageHandleFromNumber(UINT pageNumber, PWB_PAGE_HANDLE phPage);
    UINT    wbPageClear(WB_PAGE_HANDLE hPage, UINT changedFlagAction);
    void    wbPageClearConfirm(WB_PAGE_HANDLE hPage);
    UINT    wbPageAdd(WB_PAGE_HANDLE hRefPage, UINT where, PWB_PAGE_HANDLE phPage, UINT changedFlagAction);
    BOOL    wbGetNetUserID(void);
    UINT    wbPageMove(WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where);
    UINT    wbPersonGet(POM_OBJECT pObjPerson, PWB_PERSON pPerson);
    UINT    wbWriteSyncControl(PWB_SYNC pSync, BOOL create);
    BOOL    wbGraphicLocked(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, POM_OBJECT* ppObjPersonLock);
    UINT    wbGraphicSelectPrevious(WB_PAGE_HANDLE hPage, LPPOINT pPoint, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC_HANDLE phGraphic);

    void    wbError(void);
    void    wbJoinCallError(void);
    UINT    wbAddLocalUserObject(void);
    UINT    wbPersonUpdate(PWB_PERSON pUser);

    WB_PAGE_HANDLE  wbGetEmptyPageHandle(void);
    WB_PAGE_HANDLE  wbGetReadyPageHandle(void);
    PWB_PAGE_STATE  wbPageState(WB_PAGE_HANDLE hPage);
    void    wbPagesPageAdd(WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where);
    UINT    wbPageOrderPageNumber(PWB_PAGE_ORDER pPageOrder, WB_PAGE_HANDLE hPage);
    void    wbPageOrderPageAdd(PWB_PAGE_ORDER pPageOrder, WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where);
    void    wbPageOrderPageDelete(PWB_PAGE_ORDER pPageOrder, WB_PAGE_HANDLE hPage);

    friend BOOL CALLBACK wbCoreEventHandler(LPVOID clientData, UINT event, UINT_PTR param1, UINT_PTR param2);
    BOOL    wbEventHandler(UINT event, UINT_PTR param1, UINT_PTR param2);

    friend void CALLBACK wbCoreExitHandler(LPVOID clientData);
    void    wbExitHandler(void);

    BOOL    wbOnWsGroupRegisterCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWsGroupMoveCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWsGroupMoveInd(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWorksetOpenCon(UINT_PTR param1, UINT_PTR param2);
    void    wbOnControlWorksetOpenCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnPageWorksetOpenCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWorksetLockCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWorksetUnlockInd(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWorksetClearInd(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnObjectAddInd(UINT_PTR param1, POM_OBJECT pObj);
    BOOL    wbOnObjectMoveInd(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnObjectDeleteInd(UINT_PTR param1, POM_OBJECT pObj);
    BOOL    wbOnObjectUpdateInd(UINT_PTR param1, POM_OBJECT pObj);
    BOOL    wbOnObjectReplaceInd(UINT_PTR param1, POM_OBJECT pObj);

    void    wbOnControlWorksetsReady(void);
    void    wbProcessLockNotification(void);
    void    wbCompleteRegistration(void);
    void    wbLeaveCall(void);

    void    wbOnGraphicObjectAddInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);
    void    wbOnGraphicObjectUpdateInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);
    void    wbOnGraphicObjectReplaceInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);
    void    wbOnGraphicObjectMoveInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);
    void    wbOnGraphicObjectDeleteInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);

    UINT    wbPageWorksetOpen(WB_PAGE_HANDLE hPage, UINT localOrExternal);
    BOOL    wbOnWBPPageClearInd(WB_PAGE_HANDLE hPage);
    void    wbOnPageDelete(void);
    UINT    wbPageSave(WB_PAGE_HANDLE hPage, HANDLE hFile);
    UINT    wbObjectSave(HANDLE hFile, LPBYTE pData, UINT length);
    void    wbStartContentsLoad(void);
    void    wbPageLoad(void);
    UINT    wbObjectLoad(HANDLE hFile, WB_PAGE_HANDLE hPage, PPWB_GRAPHIC ppGraphic);

    UINT    wbGetPageObjectType(POM_OBJECT pObj, UINT * pObjectType);
    void    wbOnPageObjectAddInd(POM_OBJECT pObj);
    void    wbOnPageControlObjectAddInd(POM_OBJECT pObj);
    void    wbOnPageObjectReplaceInd(POM_OBJECT pObj);
    void    wbOnPageObjectDeleteInd(POM_OBJECT pObj);
    void    wbOnLockControlObjectDeleteInd(POM_OBJECT pObj);
    void    wbOnPageControlObjectReplaceInd(void);

    void    wbProcessPageControlChanges(void);
    UINT    wbWriteLock(void);
    void    wbReadLock(void);
    void    wbSendLockNotification(void);
    UINT    wbWritePageControl(BOOL create);

    UINT    wbCreateSyncControl(void);
    void    wbOnSyncObjectAddInd(POM_OBJECT pObj);
    void    wbOnSyncObjectReplaceInd(POM_OBJECT pObj);

    void    wbOnUserObjectAddInd(POM_OBJECT pObj);
    void    wbOnUserObjectDeleteInd(POM_OBJECT pObj);
    void    wbOnUserObjectUpdateInd(POM_OBJECT pObj);
    void    wbOnUserObjectReplaceInd(POM_OBJECT pObj);

    UINT    wbSelectPersonColor(void);
    void    wbCheckPersonColor(POM_OBJECT hCheckObject);

    BOOL    wbOnWBPLock(void);
    BOOL    wbOnWBPLockFailed(void);
    BOOL    wbOnWBPUnlocked(void);
    BOOL    wbOnWBPPageOrderUpdated(void);
    void    wbProcessInsertObjects(void);
    UINT    wbDiscardInsertObjects(UINT cObject);

    void    wbClientReset(void);
    BOOL    wbCheckReadyPages(void);


// Data
    PUT_CLIENT      m_putTask;            // Task handle
    POM_CLIENT      m_pomClient;          // ObMan handle
    PCM_CLIENT      m_pcmClient;          // Call Manager secondary handle.

    OM_WSGROUP_HANDLE   m_hWSGroup;
    BYTE            m_changed;
    NET_UID         m_clientNetID;        // Net ID of local person

    UINT            m_state;              // Major state
    UINT            m_subState;           // Sub-state of major state

    UINT            m_errorState;         // Fatal error indicator

    OM_CORRELATOR   m_wsgroupCorrelator;
    OM_CORRELATOR   m_worksetOpenCorrelator;

    POM_OBJECT      m_pObjPageControl;
    POM_OBJECT      m_pObjSyncControl;

    POM_OBJECT      m_pObjLocal;       // Ptr to local person
    OM_OBJECT_ID    m_personID;           // OM ID of local person
                                        // adding clientNetID field

    WB_LOCK_STATE   m_lockState;          // Lock state
    OM_CORRELATOR   m_lockCorrelator;     // Correlator for locking
    WORD            m_lockRequestType;    // Type of lock request
    WB_LOCK_TYPE    m_lockType;           // Current lock type

    POM_OBJECT      m_pObjLock;        // Handle of the lock object
    POM_OBJECT      m_pObjPersonLock;  // Person who has lock.

    UINT            m_loadState;          // Load state
    HANDLE          m_hLoadFile;          // File handle (used during loading)
    WB_PAGE_HANDLE  m_loadPageHandle;     // Page handle (used during loading)

    UINT            m_colorId;            // Color id for the local person
    UINT            m_countReadyPages;    // Number of page worksets ready
                                        // for use.
    WB_PAGE_ORDER   m_pageOrder;          // List of active pages
    WB_PAGE_STATE   m_pageStates[WB_MAX_PAGES]; // List of page state flags
};



//
//
// Name:    CreateWBObject()
//
// Purpose: Register the caller with the Whiteboard Core.  This function
//          gives the core the ability to inform the front-end of events
//          caused by other call participants.
//
//          The front-end should follow this call by a call to WBP_JoinCall.
//
//
BOOL WINAPI CreateWBObject(UTEVENT_PROC eventProc, IWbClient** ppwbClient);


//
// Convert between ObMan object pointers and core graphic pointers
//
PWB_GRAPHIC __inline GraphicPtrFromObjectData(POM_OBJECTDATA pData)
{
    return((PWB_GRAPHIC)&(pData->data));
}

POM_OBJECTDATA  __inline ObjectDataPtrFromGraphic(PWB_GRAPHIC pGraphic)
{
    return((POM_OBJECTDATA)((LPBYTE)pGraphic - offsetof(OM_OBJECTDATA, data)));
}


//
// QUIT_LOCKED
//
// Leave the function if another person has the contents or page order
// lock.
//
//
#define QUIT_LOCKED(result)                                         \
    if (m_lockState == LOCK_STATE_LOCKED_OUT)                         \
    {                                                                        \
      result = WB_RC_LOCKED;                                                 \
      DC_QUIT;                                                               \
    }

//
// QUIT_IF_CANCELLING_LOCK
//
// Leave the function if we are processing a lock-cancel request
//
//
#define QUIT_IF_CANCELLING_LOCK(result, errCode)                    \
    if (m_lockState == LOCK_STATE_CANCEL_LOCK)                        \
    {                                                                        \
        TRACE_OUT(("Already cancelling lock"));                            \
        result = errCode;                                                    \
        DC_QUIT;                                                             \
    }

//
// QUIT_CONTENTS_LOCKED
//
// Leave the function if another person has the contents lock.
//
//
#define QUIT_CONTENTS_LOCKED(result)                                \
    if (  (m_lockState == LOCK_STATE_LOCKED_OUT)                                        \
        && (m_lockType == WB_LOCK_TYPE_CONTENTS))                     \
    {                                                                        \
      result = WB_RC_LOCKED;                                                 \
      DC_QUIT;                                                               \
    }

//
// QUIT_NOT_GOT_LOCK
//
// Leave the function if the client does not have a lock.
//
//
#define QUIT_NOT_GOT_LOCK(result)                                   \
    if (m_lockState != LOCK_STATE_GOT_LOCK)                          \
    {                                                                        \
      result = WB_RC_NOT_LOCKED;                                             \
      DC_QUIT;                                                               \
    }

//
// QUIT_NOT_PROCESSING_LOCK
//
// Leave the function if the client has not previoulsy requested a lock.
//
//
#define QUIT_NOT_PROCESSING_LOCK(result)                            \
    if ( (m_lockState != LOCK_STATE_GOT_LOCK    ) &&                  \
         (m_lockState != LOCK_STATE_PENDING_LOCK) &&                  \
         (m_lockState != LOCK_STATE_PENDING_ADD) )                    \
    {                                                                        \
        TRACE_OUT((                                                          \
                   "Not locked: Client lock state %d", m_lockState)); \
        result = WB_RC_NOT_LOCKED;                                           \
        DC_QUIT;                                                             \
    }

//
// QUIT_NOT_GOT_CONTENTS_LOCK
//
// Leave the function if the client does not have the contents lock.
//
//
#define QUIT_NOT_GOT_CONTENTS_LOCK(result)                          \
                                                                             \
    QUIT_NOT_GOT_LOCK(result);                                      \
                                                                             \
    if (m_lockType != WB_LOCK_TYPE_CONTENTS)                          \
    {                                                                        \
      result = WB_RC_NOT_LOCKED;                                             \
      DC_QUIT;                                                               \
    }

//
// QUIT_NOT_GOT_PAGE_ORDER_LOCK
//
// This is currently the same as QUIT_NOT_GOT_LOCK as there are only the
// page order and contents locks.  The contents lock is considered to
// include the page order lock.
//
//
#define QUIT_NOT_GOT_PAGE_ORDER_LOCK(result)                        \
    QUIT_NOT_GOT_LOCK(result)

//
// QUIT_GRAPHIC_LOCKED
//
// Leave the function if another person has the graphic locked.
//
//
#define QUIT_GRAPHIC_LOCKED(hPage, hGraphic, result)                \
  {                                                                          \
    POM_OBJECT pObjPerson;                                              \
    if (wbGraphicLocked(hPage, hGraphic, &pObjPerson))    \
    {                                                                        \
      if (pObjPerson != m_pObjLocal)                             \
      {                                                                      \
          result = WB_RC_GRAPHIC_LOCKED;                                     \
          DC_QUIT;                                                           \
      }                                                                      \
    }                                                                        \
  }


//
// QUIT_GRAPHIC_NOT_LOCKED
//
// Leave the function if the local user does not have the graphic locked.
//
//
#define QUIT_GRAPHIC_NOT_LOCKED(pGraphic, result)                            \
    if (pGraphic->locked != WB_GRAPHIC_LOCK_LOCAL)                           \
    {                                                                        \
      result = WB_RC_GRAPHIC_NOT_LOCKED;                                     \
      DC_QUIT;                                                               \
    }




//
//
// Name:    WBP_JoinCall
//
// Purpose: Join a call.  This function registers with the Whiteboard
//          workset group.  It is asynchronous giving one of the following
//          events as a result:
//
//          WBP_EVENT_JOIN_CALL_OK
//          WBP_EVENT_JOIN_CALL_FAILED.
//
//          No other WBP_... functions should be called until the call
//          has been successfully joined.
//
// Returns: 0 if successful
//          OM_RC_...     - in case of workset registration/move failure:
//                          see om.h
//
//

//
//
// Name:    WBP_ContentsLoad
//
// Purpose: Load a new file from disc into the Whiteboard worksets.  The
//          caller must hold the Whiteboard page order lock before calling
//          this function. This function is asynchronous; when it returns,
//          the file will not be completely loaded. The front-end will
//          receive a WBP_EVENT_LOAD_COMPLETE when the load completes, or
//          a WBP_EVENT_LOAD_FAILED if an asynchronous error occurs
//
// Returns: 0 if successful
//          WB_RC_LOCKED          - the whiteboard is locked by another user
//          WB_RC_NOT_LOCKED      - the caller doesnt have the contents lock
//          WB_RC_NO_FILE         - the specified file could not be found
//          WB_RC_BAD_FILE_FORMAT - the file is not of the correct format
//
//

//
//
// Name:    WBP_ContentsSave
//
// Purpose: Save the current Whiteboard contents to disc.  The Whiteboard
//          contents can be updated by other users while this function is
//          processing.  To prevent this acquire the Whiteboard contents
//          lock before calling it.
//
// Returns: 0 if successful
//          WB_RC_DISK_FULL       - not enough space on disk
//          WB_RC_PATH_NOT_FOUND  - the specified path does not exist
//          WB_RC_WRITE_FAILED    - writing to the file failed - the file is
//                                  read-only.
//
//


//
//
// Name:    WBP_ContentsDelete
//
// Purpose: Delete all the Whiteboard pages (leaving only an empty page 1).
//          The caller must hold the Whiteboard contents or page order lock
//          before calling this function.
//
//          For each page to be deleted, each person in the call receives
//          the following event:
//
//          WBP_EVENT_PAGE_DELETE_IND
//
// Returns: 0 if successful
//          WB_RC_LOCKED     - another person has the contents lock
//          WB_RC_NOT_LOCKED - the local person does not hold the page order
//                             lock.
//
//


//
//
// Name:    WBP_ContentsChanged
//
// Purpose: Returns an indication of whether the contents of the Whiteboard
//          have changed since WBP_ContentsSave) WBP_ContentsLoad or
//          WBP_ContentsDelete was last called.
//
//


//
//
// Name:    WBP_ContentsLock
//
// Purpose: Lock the Whiteboard contents.  This is an asynchronous function
//          generating one of the following events:
//
//          WBP_EVENT_CONTENTS_LOCKED
//          WBP_EVENT_LOCK_FAILED.
//
// Returns: none
//
//


//
//
// Name:    WBP_PageOrderLock
//
// Purpose: Lock the Whiteboard page order.  This is an asynchronous
//          function generating one of the following events:
//
//          WBP_EVENT_PAGES_LOCKED
//          WBP_EVENT_LOCK_FAILED.
//
//
// Returns: none
//
//


//
//
// Name:    WBP_Unlock
//
// Purpose: Unlock the Whiteboard.  This is an asynchronous function
//          generating the following event:
//
//          WBP_EVENT_UNLOCKED
//
//          This function may be called anytine after a call to WBP_Lock -
//          an application does not need to wait for a WBP_EVENT_LOCKED
//          event after calling WBP_Lock before calling WBP_Unlock.
//
//


//
//
// Name:    WBP_LockStatus
//
// Purpose: Return the current state of the available locks
//
//
// Returns: None (always succeeds)
//
//


//
//
// Name:    WBP_ContentsCountPages
//
// Purpose: Return the number of pages in the Whiteboard.
//
// Returns: None
//
//


//
//
// Name:    WBP_PageClear
//
// Purpose: Clear the page (deleting all graphic objects on it).  This is
//          an asynchronous function generating the following event:
//
//          WBP_EVENT_PAGE_CLEARED
//
//          No objects are actually deleted until the WBP_PageClearConfirm
//          function is called in response to the event.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE   - the specified page handle is bad
//          WB_RC_LOCKED            - another user has a lock on the white-
//                                    board contents.
//
//


//
//
// Name:    WBP_PageClearConfirm
//
// Purpose: Confirm the clearing of a page.  All graphic objects on the page
//          will be removed.
//
// Returns: none
//
//


//
//
// Name:    WBP_PageAddBefore
//
// Purpose: Add a new page before a specified page.  This
//          function requires that the caller hold the Whiteboard contents
//          or page order lock before it is called. The following event is
//          generated for each user in the call:
//
//          WBP_EVENT_PAGE_ORDER_UPDATED
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the hRefPage handle is invalid
//          WB_RC_LOCKED          - the whiteboard is locked by another
//                                  user
//          WB_RC_NOT_LOCKED      - the local user does not hold the page
//                                  order lock
//          WB_RC_TOO_MANY_PAGES  - the maximum number of pages has been
//                                  reached.
//
//


//
//
// Name:    WBP_PageAddAfter
//
// Purpose: Add a new page after a specified page.  This
//          function requires that the caller hold the Whiteboard contents
//          or page order lock before it is called. The following event is
//          generated for each user in the call:
//
//          WBP_EVENT_PAGE_ORDER_UPDATED
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the hRefPage handle is invalid
//          WB_RC_LOCKED          - the whiteboard is locked by another user
//          WB_RC_NOT_LOCKED      - the local user does not hold the page
//                                  order lock
//          WB_RC_TOO_MANY_PAGES  - the maximum number of pages has been
//                                  reached.
//
//


//
//
// Name:    WBP_PageHandle
//
// Purpose: Return the handle of another page in the Whiteboard.
//
// Returns: 0 if successful
//
//


//
//
// Name:    WBP_PageHandleFromNumber
//
// Purpose: Return the handle of the page specified by page number
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_NUMBER - pageNumber is not a valid page number
//
//


//
//
// Name:    WBP_PageNumberFromHandle
//
// Purpose: Return the number of the page specified by handle
//
//


//
//
// Name:    WBP_PageDelete
//
// Purpose: Delete the specified page. The local user must have the white-
//          board contents or page order lock before calling this function.
//          This call gives rise to two events:
//
//          WBP_EVENT_PAGE_CLEARED_IND - indicating that all the objects in
//                                 the page have been deleted. The front-end
//                                 must respond by calling
//                                 WBP_PageClearConFirm - no graphic objects
//                                 will be deleted until this is done.
//
//          WBP_EVENT_PAGE_ORDER_UPDATED - informing the front-end that the
//                                 list of pages has changed
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the specified page handle is invalid
//          WB_RC_LOCKED          - another client has the contents locked
//          WB_RC_NOT_LOCKED      - the local user does not have the page
//                                  order lock.
//
//


//
//
// Name:    WBP_PageDeleteConfirm
//
// Purpose: Confirm the deletion of a page.
//
// Returns: none
//
//


//
//
// Name:    WBP_PageMove
//
// Purpose: Moves one page after or before another.  The user must hold
//          the Whiteboard contents or page order lock before calling this
//          function.  If successful this function will result in a
//          WBP_EVENT_PAGE_ORDER_UPDATED event.
//
// Returns: 0 if successful
//          WB_RC_LOCKED          - another client has the contents locked
//          WB_RC_NOT_LOCKED      - the local user does not have the page
//                                  order lock.
//          WB_RC_BAD_PAGE_HANDLE - either hRefPage or hPage is not a valid
//                                  page handle
//
//


//
//
// Name:    WBP_PageCountGraphics
//
// Purpose: Return the number of graphics on the page
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicAllocate
//
// Purpose: Allocate memory for a graphic object. Note: All memory used for
//          graphics passed to the Whiteboard core must be allocated using
//          the function described here.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the specified page handle is invalid
//          WB_RC_OUT_OF_MEMORY   - could not allocate the amount of memory
//                                  requested.
//
//


//
//
// Name:    WBP_GraphicAddLast
//
// Purpose: Add a graphic object to the Whiteboard contents.  The graphic
//          must previously have been allocated using WBP_GraphicAllocate.
//          It is added to the end (topmost Z-Order) of the specified page.
//          The following event is generated:
//
//          WBP_EVENT_GRAPHIC_ADDED.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the specified page handle is invalid
//
//


//
//
// Name:    WBP_GraphicUpdateRequest
//
// Purpose: Update a graphic object in the Whiteboard contents.  This call
//          allows only the WB_GRAPHIC header part of the graphic object
//          to be altered.
//
//          This call only starts the process of updating a graphic.  If
//          this function is successful a WBP_EVENT_GRAPHIC_UPDATE_IND event
//          will be posted to the caller.  The caller must then call
//          WBP_GraphicUpdateConfirm.
//
// Returns: 0 if successful
//          WB_RC_LOCKED             - another client has the whiteboard
//                                     contents locked
//          WB_RC_OBJECT_LOCKED      - another client has the specified
//                                     graphic object locked.
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_GRAPHIC_HANDLE - the specified graphic handle is
//                                     invalid
//
//
//


//
//
// Name:    WBP_GraphicUpdateConfirm
//
// Purpose: Complete the process of updating a graphic object.
//          (See WBP_GraphicUpdateRequest.)
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicReplaceRequest
//
// Purpose: Replace a graphic object in the Whiteboard contents.  This call
//          allows the entire object to be replaced with another object.
//
//          This call only starts the process of replacing a graphic.  If
//          this function is successful a WBP_EVENT_GRAPHIC_REPLACE_IND
//          event will be posted to the caller.  The caller must then call
//          WBP_GraphicReplaceConfirm.
//
// Returns: 0 if successful
//          WB_RC_LOCKED             - another client has the whiteboard
//                                     contents locked
//          WB_RC_OBJECT_LOCKED      - another client has the specified
//                                     graphic object locked.
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_GRAPHIC_HANDLE - the specified graphic handle is
//                                     invalid
//
//


//
//
// Name:    WBP_GraphicReplaceConfirm
//
// Purpose: Complete the process of replacing a graphic object.
//          (See WBP_GraphicReplaceRequest.)
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicDeleteRequest
//
// Purpose: Delete a graphic object in the Whiteboard contents.
//
//          This call only starts the process of deleting a graphic.  If
//          this function is successful a WBP_EVENT_GRAPHIC_DELETE_IND event
//          will be posted to the caller.  The caller must then call
//          WBP_GraphicDeleteConfirm.
//
// Returns: 0 if successful
//
//          WB_RC_LOCKED             - another client has the whiteboard
//                                     contents locked
//          WB_RC_OBJECT_LOCKED      - another client has the specified
//                                     graphic object locked.
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_GRAPHIC_HANDLE - the specified graphic handle is
//                                     invalid
//


//
//
// Name:    WBP_GraphicDeleteConfirm
//
// Purpose: Complete the process of deleting a graphic object.
//          (See WBP_UpdateGraphicRequest.)
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicMove
//
// Purpose: Move a graphic to the end of the page (topmost Z-order).
//          On successful completion, the following event is generated:
//
//          WBP_EVENT_GRAPHIC_MOVED
//
// Returns: 0 if successful
//          WB_RC_LOCKED             - another user has the whiteboard
//                                     contents locked.
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_GRAPHIC_HANDLE - the specified graphic handle is
//                                     invalid
//
//


//
//
// Name:    WBP_GraphicSelect
//
// Purpose: Retrieve the handle of the topmost Z-order graphic whose
//          bounding rectangle contains the specified point.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_NO_SUCH_GRAPHIC    - there is no graphic at the point
//                                     specified.
//
//


//
//
// Name:    WBP_GraphicGet
//
// Purpose: Retrieve a graphic object.  After this graphic has been
//          retrieved it will remain in memory until explicitly released
//          by a call to WBP_ReleaseGraphic.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_OBJECT_HANDLE  - the specified graphic handle is
//                                     invalid.
//
//


//
//
// Name:    WBP_GraphicRelease
//
// Purpose: Release a previously retrieved graphic.
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicUnlock
//
// Purpose: Unlock a graphic. This function succeeds even if the contents
//          are locked.
//
// Returns: none
//
//



//
//
// Name:    WBP_GraphicHandle
//
// Purpose: Return the handle of the first graphic in the specified page.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//
//


//
//
// Name:    WBP_PersonHandleFirst
//
// Purpose: Return the handle of the first user in the call
//
// Returns: None
//
//


//
//
// Name:    WBP_PersonHandleNext
//
// Purpose: Return the handle of the next user in the call
//
// Returns: 0 if successful
//          WB_RC_BAD_USER_HANDLE    - the specified user handle is invalid
//          WB_RC_NO_SUCH_USER       - there is no next user: hRefUser is
//                                     the last in the users workset.
//
//

//
//
// Name:    WBP_PersonHandleLocal
//
// Purpose: Return the handle of the local user
//
// Returns: None
//
//


//
//
// Name:    WBP_PersonCountInCall
//
// Purpose: Retrieves information about the global state of the Whiteboard
//          FP in the call.
//
//


//
//
// Name:    WBP_GetPersonData
//
// Purpose: Retrieve the person object specified by <hPerson>.
//
// Returns: 0 if successful
//          OM_RC_...
//          WB_RC_BAD_PERSON_HANDLE - the specified person handle is invalid
//
//

//
//
// Name:    WBP_SetLocalPersonData
//
// Purpose: Sets the data for the local person.
//
// Returns: 0 if successful
//          OM_RC_...
//          WB_RC_BAD_PERSON_HANDLE - the specified person handle is invalid
//
//



//
//
// Name:    WBP_PersonUpdateConfirm
//
// Purpose: Complete the process of updating a user object.
//
// Returns: None
//
//


//
//
// Name:    WBP_PersonReplaceConfirm
//
// Purpose: Complete the process of replacing a user object.
//
// Returns: None
//
//

//
//
// Name:    WBP_PersonLeftConfirm
//
// Purpose: Complete the process of updating a user object.
//
// Returns: None
//
//


//
//
// Name:    WBP_SyncPositionGet
//
// Purpose: Retrieve the details of the current sync position.
//
// Returns: 0 if successful
//
//


//
//
// Name:    WBP_SyncPositionUpdate
//
// Purpose: Set the current sync details
//
// Returns: 0 if successful
//
//

//
//
// Name:    WBP_CancelLoad
//
// Purpose: Cancel a load in progress
//
// Returns: 0 if successful
//          WB_RC_NOT_LOADING   if a load is not in progress
//
//


//
//
// Name:    WBP_ValidateFile
//
// Purpose: Validate a whiteboard file
//
// Returns: 0 if successful
//          Error if not
//
//



//
//
// Event Descriptions
//
// The following event are generated during core processing.
//
//
//

//
//
// Name:    WBP_EVENT_JOIN_CALL_OK
//
// Purpose: Inform the client that the call was joined successfully.
//          This is the very first event that the client will receive
//          after successful registration and joining of a call.
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_JOIN_CALL_FAILED
//
// Purpose: Inform the client that joining of the call failed. The core is
//          not in any call. The next call made to it should be one of
//          WBP_JoinCall and WBP_Stop.
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_NETWORK_LOST
//
// Purpose: Inform the client that communication with other clients
//          is no longer possible. The contents of the core are still
//          available. Any locks held by remote people have been released.
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_ERROR
//
// Purpose: Inform the client that a fatal error has occurred in the core.
//          The client should deregister (WBP_ContentsSave can be called
//          before the application quits but may not be successful).
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_CONTENTS_LOCKED
//          WBP_EVENT_PAGE_ORDER_LOCKED
//
// Purpose: Inform the client that the contents are now locked. This event
//          is be generated both when remote clients get the lock and when
//          the local client acquires it. The parameter indicates who now
//          has the lock. Note that this should always be tested even if
//          this event arrives when the local client is waiting for lock
//          confirmation: it may indicate that the remote client got in
//          just before the local.
//
//          These events can indicate a change in lock status rather than a
//          lock being acquired. For example a client which holds the
//          Page Order Lock can upgrade that lock to a Contents Lock by
//          calling WBP_ContentsLock. All other clients will then receive
//          WBP_EVENT_CONTENTS_LOCKED events informing them of the change.
//
// Params:  param16 reserved
//          param32 Handle of person who has acquired the lock
//
//

//
//
// Name:    WBP_EVENT_UNLOCKED
//
// Purpose: Inform the client that the contents are no longer locked. This
//          event is only received when a remote client releases the lock.
//          Local clients call the synchronous WBP_Unlock - the lock is
//          released on return from the function.
//
// Params:  param16 reserved
//          param32 Handle of person who has released the lock
//
//

//
//
// Name:    WBP_EVENT_LOCK_FAILED
//
// Purpose: Inform the client that the lock request issued previously has
//          failed. This will usually be because another person has acquired
//          the lock.
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_PAGE_CLEAR_IND
//
// Purpose: Inform the client that a page clear has been requested. The
//          client should call WBP_PageClearConfirm as soon as possible.
//
// Params:  param16 Handle of the page to be cleared
//
//

//
//
// Name:    WBP_EVENT_PAGE_ORDER_UPDATED
//
// Purpose: Inform the client that the order of pages has changed. This
//          event is generated by WBP_PageMove... and WBP_PageAdd...
//          functions (from both the local and remote clients).
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_PAGE_DELETE_IND
//
// Purpose: Inform the client that a delete request has been issued for
//          a page. The client should call WBP_PageDeleteConfirm as soon
//          as possible.
//
// Params:  param16 Handle of the page being deleted
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_ADDED
//
// Purpose: Inform the client that a new graphic object has been added to
//          a page. This event is generated for all object adds including
//          those originating with the client.
//
// Params:  param16 Handle of the page to which the object has been added
//          param32 Handle of the object which has been added
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_MOVED
//
// Purpose: Inform the client that a graphic object has been moved within
//          a page. This event is generated for all object moves including
//          those originating with the client.
//
// Params:  param16 Handle of the page affected
//          param32 Handle of the object affected
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_UPDATE_IND
//
// Purpose: Inform the client that a request to update a graphic object has
//          been issued. No changes have yet been made to the graphic.
//          The client should call WBP_GraphicUpdateConfirm as soon as
//          possible.
//
// Params:  param16 Handle of the page affected
//          param32 Handle of the object affected
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_REPLACE_IND
//
// Purpose: Inform the client that a request to replace a graphic object has
//          been issued. No changes have yet been made to the graphic.
//          The client should call WBP_GraphicReplaceConfirm as soon as
//          possible.
//
// Params:  param16 Handle of the page affected
//          param32 Handle of the object affected
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_DELETE_IND
//
// Purpose: Inform the client that a request to delete a graphic object has
//          been issued. No changes have yet been made to the graphic.
//          The client should call WBP_GraphicDeleteConfirm as soon as
//          possible.
//
// Params:  param16 Handle of the page affected
//          param32 Handle of the object affected
//
//

//
//
// Name:    WBP_EVENT_PERSON_JOINED
//
// Purpose: Inform the client that a new person has joined the call.
//
// Params:  param16 reserved
//          param32 Handle of the person that has just joined
//
//

//
//
// Name:    WBP_EVENT_PERSON_LEFT
//
// Purpose: Inform the client that a person has left the call.
//
// Params:  param16 reserved
//          param32 Handle of the person that has just left
//
//

//
//
// Name:    WBP_EVENT_PERSON_UPDATED
//
// Purpose: Inform the client that the some person information has changed.
//
// Params:  param16 reserved
//          param32 Handle of the person affected
//
//

//
//
// Name:    WBP_EVENT_LOAD_COMPLETE
//
// Purpose: Inform the client that an attempt to load a Whiteboard file
//          has completed successfully.
//
// Params:  none
//
//

//
//
// Name:    WBP_EVENT_LOAD_FAILED
//
// Purpose: Inform the client that an attempt to load a page from a
//          whiteboard file has failed. The load is cancelled at the point
//          the error occurred, but any objects/pages which were
//          successfully read in will remain.
//
// Params:  none
//
//

//
//
// Name:    WBP_EVENT_INSERT_OBJECTS
//
// Purpose: Inform the client that objects created by the secondary api
//          client may be inserted. This event is posted when the whiteboard
//          lock has been released.
//
// Params:  none
//
//

//
//
// Name:    WBP_EVENT_INSERT_NEXT
//
// Purpose: Inform the client that the next secondary api object may be
//          inserted.
//
// Params:  param16 index of the object to be inserted
//          param32 reserved
//
//

//
//
// Name:    WBP_EVENT_SYNC_POSITION_UPDATED
//
// Purpose: Inform the client that the sync position information has been
//          updated.
//
// Params:  param16 reserved
//          param32 reserved
//
//





#endif // _HPP_WB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\hook\het.cpp ===
#include "precomp.h"


//
// HET.CPP
// Window, task tracking hooks
//
// Copyright(c) Microsoft 1997-
//



//
// Entry Point
//
int APIENTRY DllMain (HINSTANCE hInstance, DWORD reason, LPVOID plReserved)
{
    //
    // DONT ADD ANY TRACING TO THIS FUNCTION OR ANY FUNCTIONS CALLED FROM
    // HERE - WE CANNOT GUARANTEE THAT THE TRACE DLL IS IN A FIT STATE TO
    // DO ANYTHING FROM HERE.
    //

    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            InitDebugModule(TEXT("MNMHOOK"));
#endif // _DEBUG

            DBG_INIT_MEMORY_TRACKING(hInstance);

            HOOK_Load(hInstance);
        }
        break;

        case DLL_PROCESS_DETACH:
        {
            TRACE_OUT(("HOOK unloaded for app %s", GetCommandLine()));

            DBG_CHECK_MEMORY_TRACKING(hInstance);

#ifdef _DEBUG
            //
            // NULL this out in debug to see if our hooks get called on
            // this process while we are exiting.
            //
            g_hookInstance = NULL;

            ExitDebugModule();
#endif
        }
        break;

        case DLL_THREAD_ATTACH:
        {
            HOOK_NewThread();
        }
        break;
    }

    return(TRUE);
}


//
// HOOK_Load()
// This saves our instance handle and gets hold of various routines we
// need for window tracking.  We can not link to these functions directly
// since some of them only exist in NT 4.0 SP-3, but we want you to be able
// to view and control without it.
//
void    HOOK_Load(HINSTANCE hInst)
{
    DWORD   dwExeType;
    LPSTR   lpT;
    LPSTR   lpNext;
    LPSTR   lpLastPart;
    char    szExeName[MAX_PATH+1];

    DebugEntry(HOOK_Load);

    //
    // Save our instance
    //
    g_hookInstance = hInst;

    //
    // (1) NtQueryInformationProcess() in NTDLL
    // (2) SetWinEventHook() in           USER32
    // (3) UnhookWinEventHook() in        USER32
    //

    // Get hold of NtQueryInformationProcess
    hInst = GetModuleHandle(NTDLL_DLL);
    g_hetNtQIP = (NTQIP) GetProcAddress(hInst, "NtQueryInformationProcess");

    // Get hold of the WinEvent routines
    hInst = GetModuleHandle(TEXT("USER32.DLL"));
    g_hetSetWinEventHook = (SETWINEVENTHOOK)GetProcAddress(hInst, "SetWinEventHook");
    g_hetUnhookWinEvent = (UNHOOKWINEVENT)GetProcAddress(hInst, "UnhookWinEvent");

    //
    // Figure out what type of app we are.  We want to treat separate groupware
    // process applets and WOW16 apps specially.
    //
    GetModuleFileName(NULL, szExeName, sizeof(szExeName));
    ASSERT(*szExeName);

    TRACE_OUT(("HOOK loaded for app %s", szExeName));

    //
    // Start at the beginning, and work our way to the last part after the
    // last slash, if there is one.  We know the path is fully qualified.
    //
    lpT = szExeName;
    lpLastPart = szExeName;

    while (*lpT)
    {
        lpNext = AnsiNext(lpT);

        if (*lpT == '\\')
        {
            //
            // This points to the next character AFTER the backwhack.
            // If we're at the end of the string somehow, *lpLastPart will
            // be zero, and worst that can happen is that our lstrcmpis fail.
            //
            lpLastPart = lpNext;
        }

        lpT = lpNext;
    }

    ASSERT(*lpLastPart);

    //
    // NOTE:
    // GetModuleFileName() dies sometimes for a WOW app--it doesn't always
    // NULL terminate.  So we will do this on our own.
    //
    lpT = lpLastPart;

    //
    // Get to the '.' part of the 8.3 final file name
    //
    while (*lpT && (*lpT != '.'))
    {
        lpT = AnsiNext(lpT);
    }

    //
    // Skip past the next three chars
    //
    if (*lpT == '.')
    {
        lpT = AnsiNext(lpT);
        if (lpT && *lpT)
            lpT = AnsiNext(lpT);
        if (lpT && *lpT)
            lpT = AnsiNext(lpT);
        if (lpT && *lpT)
            lpT = AnsiNext(lpT);

        //
        // And null terminate after the 3rd char past the '.' extension.
        // This isn't great, but it covers .COM, .DLL, etc. dudes.  The
        // worst that will happen is GetBinaryType() will fail and we won't
        // recognize a WOW app with some strange extension (not 3 chars)
        // starting up.
        //
        if (lpT)
        {
            if (*lpT != 0)
            {
                WARNING_OUT(("WOW GetModuleFileName() bug--didn't NULL terminate string"));
            }

            *lpT = 0;
        }
    }

    if (!lstrcmpi(lpLastPart, "WOWEXEC.EXE"))
    {
        TRACE_OUT(("New WOW VDM starting up"));

        //
        // A new WOW VDM is starting up.  We don't want to share anything
        // in the first thread, the WOW service thread, because those windows
        // never go away.
        //
        g_appType = HET_WOWVDM_APP;
    }
    else if (!GetBinaryType(szExeName, &dwExeType))
    {
        ERROR_OUT(("Unable to determine binary type for %s", szExeName));
    }
    else if (dwExeType == SCS_WOW_BINARY)
    {
        TRACE_OUT(("New WOW APP in existing VDM starting up"));

        //
        // A new 16-bit app thread is starting in an existing WOW vdm.
        //
        g_idWOWApp = GetCurrentThreadId();
        g_fShareWOWApp = (BOOL)HET_GetHosting(GetForegroundWindow());

        TRACE_OUT(("For new WOW app %08ld, foreground is %s",
            g_idWOWApp, (g_fShareWOWApp ? "SHARED" : "not SHARED")));

        //
        // Remember who was really active when this WOW dude was started
        // up.  On the first window create, we'll share him based on the
        // status of it.
        //
    }

    DebugExitVOID(HOOK_ProcessAttach);
}



//
// HOOK_NewThread()
// For WOW apps, each app is really a thread.  The first thread created
// in NTVDM is the WOW service thread.  We don't want to share any windows
// in it.  Unfortunately, the first window created is a console window, so
// that happens in CONF's context and we can't get any info.  The next window
// created in this thread is a WOW window (WOWEXEC.EXE).  When that happens,
// we want to go back and unshare the console window.
//
// If the WOW VDM is already running when another 16-bit app starts up,
// we don't have these troubles.
//
void HOOK_NewThread(void)
{
    DebugEntry(HOOK_NewThread);

    TRACE_OUT(("App thread %08ld starting", GetCurrentThreadId()));

    if (g_appType == HET_WOWVDM_APP)
    {
        TRACE_OUT(("Unsharing WOW service thread windows"));

        //
        // We want to go unshare the previously created WOW windows.  We
        // never want to keep shared the dudes in the WOW service thread.
        //
        g_appType = 0;
        EnumWindows(HETUnshareWOWServiceWnds, GetCurrentProcessId());
    }

    // Update our "share windows on this thread" state.
    g_idWOWApp = GetCurrentThreadId();
    g_fShareWOWApp = (BOOL)HET_GetHosting(GetForegroundWindow());

    TRACE_OUT(("For new app thread %08ld, foreground is %s",
        g_idWOWApp, (g_fShareWOWApp ? "SHARED" : "not SHARED")));

    DebugExitVOID(HOOK_NewThread);
}




//
// HETUnshareWOWServiceWnds()
// This unshares any windows that accidentally got shared in the first
// service thread in a WOW VDM.  This can happen if a WOW app is launched
// by a 32-bit app, and it's the first WOW app ever.  The first window
// created is a console window, and the notification happens in CONF's
// process without the right styles that tell us it's in a WOW process.
//
BOOL CALLBACK HETUnshareWOWServiceWnds(HWND hwnd, LPARAM lParam)
{
    DWORD   idProcess;

    DebugEntry(HETUnshareWOWServiceWnds);

    if (GetWindowThreadProcessId(hwnd, &idProcess) &&
        (idProcess == (DWORD)lParam))
    {
        TRACE_OUT(("Unsharing WOW service window %08lx", hwnd));
        OSI_UnshareWindow(hwnd, TRUE);
    }

    DebugExitVOID(HETUnshareWOWServiceWnds);
    return(TRUE);
}




//
// HOOK_Init()
// This saves away the core window and atom used in the high level input
// hooks and when sharing.
//
void WINAPI HOOK_Init(HWND hwndCore, ATOM atomTrack)
{
    DebugEntry(HOOK_Init);

    g_asMainWindow = hwndCore;
    g_asHostProp   = atomTrack;

    DebugExitVOID(HOOK_Init);
}



//
// OSI_StartWindowTracking()
// This installs our WinEvent hook so we can watch windows coming and going.
//
BOOL WINAPI OSI_StartWindowTracking(void)
{
    BOOL        rc = FALSE;

    DebugEntry(OSI_StartWindowTracking);

    ASSERT(!g_hetTrackHook);

    //
    // If we can't find the NTDLL + 2 USER32 routines we need, we can't
    // let you share.
    //
    if (!g_hetNtQIP || !g_hetSetWinEventHook || !g_hetUnhookWinEvent)
    {
        ERROR_OUT(("Wrong version of NT; missing NTDLL and USER32 routines needed to share"));
        DC_QUIT;
    }


    //
    // Install our hook.
    //
    g_hetTrackHook = g_hetSetWinEventHook(HET_MIN_WINEVENT, HET_MAX_WINEVENT,
            g_hookInstance, HETTrackProc, 0, 0,
            WINEVENT_INCONTEXT | WINEVENT_SKIPOWNPROCESS);

    if (!g_hetTrackHook)
    {
        ERROR_OUT(("SetWinEventHook failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSI_StartWindowTracking, rc);
    return(rc);
}



//
// OSI_StopWindowTracking()
// Removes our hooks for window/task spying, if installed.
//
void WINAPI OSI_StopWindowTracking(void)
{
    DebugEntry(OSI_StopWindowTracking);

    if (g_hetTrackHook)
    {
        // Uninstall the WinEvent hook
        ASSERT((g_hetUnhookWinEvent != NULL));
        g_hetUnhookWinEvent(g_hetTrackHook);

        g_hetTrackHook = NULL;

    }

    DebugExitVOID(OSI_StopWindowTracking);
}



//
// OSI_IsWindowScreenSaver()
//
// On NT the screensaver runs in a different desktop.  We'll never get
// an HWND for it.
//
BOOL WINAPI OSI_IsWindowScreenSaver(HWND hwnd)
{
#ifdef _DEBUG
    char className[HET_CLASS_NAME_SIZE];

    if (GetClassName(hwnd, className, sizeof(className)) > 0)
    {
        ASSERT(lstrcmp(className, HET_SCREEN_SAVER_CLASS));
    }
#endif // _DEBUG

    return(FALSE);
}



//
// OSI_IsWOWWindow()
// Returns TRUE if the window is from a WOW (emulated 16-bit) application
//
BOOL WINAPI OSI_IsWOWWindow(HWND hwnd)
{
    BOOL    rc = FALSE;
    DWORD_PTR*  pWOWWords;

    DebugEntry(OSI_IsWOWWindow);

    //
    // Get a pointer to the potential WOW words.  We make use of an
    // undocumented field which is only valid for NT4.0.
    //
    pWOWWords = (DWORD_PTR*) GetClassLongPtr(hwnd, GCL_WOWWORDS);

    //
    // Check that we can use this as a pointer.
    //
    if (!pWOWWords || IsBadReadPtr(pWOWWords, sizeof(DWORD)))
    {
        DC_QUIT;
    }

    //
    // This is a valid pointer so try to dereference it.
    //
    if (0 == *pWOWWords)
    {
        DC_QUIT;
    }

    //
    // The value pointed at by <pWOWWords> is non-zero so this must be a
    // WOW app.
    //
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Let the world know what we've found.
    //
    TRACE_OUT(( "Window %#x is a %s window", hwnd, rc ? "WOW" : "Win32"));

    DebugExitBOOL(OSI_IsWOWWindow, rc);
    return(rc);
}



//
// HETTrackProc()
// Used to spy on window events
//      CREATE
//      DESTROY
//      SHOW
//      HIDE
//
void CALLBACK HETTrackProc
(
    HWINEVENTHOOK   hEvent,
    DWORD           eventNotification,
    HWND            hwnd,
    LONG            idObject,
    LONG            idChild,
    DWORD           dwThreadId,
    DWORD           dwmsEventTime
)
{
    DebugEntry(HETTrackProc);

    if ((idObject != OBJID_WINDOW) || (idChild != 0))
    {
        DC_QUIT;
    }

    //
    // Work around a bug in SP3 with ring transition callbacks, where this
    // proc gets called before the LoadLibrary is completed.
    //
    if (!g_hookInstance)
    {
        ERROR_OUT(( "WinEvent hook called before LoadLibrary completed!"));
        DC_QUIT;
    }

    switch (eventNotification)
    {
        case EVENT_OBJECT_CREATE:
            HETHandleCreate(hwnd);
            break;

        case EVENT_OBJECT_DESTROY:
            OSI_UnshareWindow(hwnd, TRUE);
            break;

        case EVENT_OBJECT_SHOW:
            // Only if this is a console window do we want to force a repaint.
            //
            // Only console apps cause events to occur in CONF's process (the one
            // that installed the hook)
            //
            HETHandleShow(hwnd, (g_hetTrackHook != NULL));
            break;

        case EVENT_OBJECT_HIDE:
            HETHandleHide(hwnd);
            break;

        case EVENT_OBJECT_PARENTCHANGE:
            HETCheckParentChange(hwnd);
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(HETTrackProc);
}

//
// HETHandleCreate()
//
// If the window isn't a real top level dude (not CHILD style or parent is
// desktop) or is a menu, ignore it.
//
// Otherwise enum the top level windows and decide what to do:
//      * If at least one other in the thread/process is shared in a perm.
//      way, mark this the same
//
//      * If this is the only one in the process, follow the ancestor chain
//      up.
//
void HETHandleCreate(HWND hwnd)
{
    HET_TRACK_INFO  hti;
    UINT            hostType;
#ifdef _DEBUG
    char            szClass[HET_CLASS_NAME_SIZE];

    GetClassName(hwnd, szClass, sizeof(szClass));
#endif

    DebugEntry(HETHandleCreate);

    //
    // Ignore child windows
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            TRACE_OUT(("Skipping child window %08lx create", hwnd));
            DC_QUIT;
        }
    }

    hti.idThread = GetWindowThreadProcessId(hwnd, &hti.idProcess);
    if (!hti.idThread)
    {
        TRACE_OUT(("Window %08lx gone", hwnd));
        DC_QUIT;
    }

    //
    // Ignore special threads
    //
    if (HET_IsShellThread(hti.idThread))
    {
        TRACE_OUT(("Skipping shell thread window %08lx create", hwnd));
        DC_QUIT;
    }

    //
    // We don't need to ignore menus.  Only when first shared do we skip
    // menus.  The cached one we never want to share.  The others will
    // go away almost immediately.  From now on, we treat them the same
    // as other windows.
    //

    //
    // Figure out what to do.
    // NOTE:
    // We don't want to inadvertently share the other windows WOW creates.
    // The first thread in the WOW process has special classes, which aren't
    // WOW wrappers.
    //
    hti.hwndUs      = hwnd;
    hti.fWOW        = OSI_IsWOWWindow(hwnd);
    hti.cWndsApp    = 0;
    hti.cWndsSharedThread = 0;
    hti.cWndsSharedProcess = 0;

    TRACE_OUT(("Create for %s window %08lx class %s process %08ld thread %08ld",
        (hti.fWOW ? "WOW" : "32-bit"), hwnd, szClass, hti.idProcess, hti.idThread));

UpOneLevel:
    EnumWindows(HETShareEnum, (LPARAM)(LPHET_TRACK_INFO)&hti);

    if (hti.cWndsSharedThread)
    {
        TRACE_OUT(("Sharing window %08lx class %s by thread %08ld in process %08ld",
                hwnd, szClass, hti.idThread, hti.idProcess));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYTHREAD;
    }
    else if (hti.cWndsSharedProcess)
    {
        TRACE_OUT(("Sharing window %08lx class %s by process %08ld in thread %08ld",
                hwnd, szClass, hti.idProcess, hti.idThread));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYPROCESS;
    }
    else if (hti.cWndsApp)
    {
        //
        // There's another window in our app, but none are shared.  So don't
        // share us either.
        //
        TRACE_OUT(("Not sharing window %08lx class %s; other unshared windows in thread %08ld process %08ld",
                hwnd, szClass, hti.idThread, hti.idProcess));
        DC_QUIT;
    }
    else if (hti.fWOW)
    {
        //
        // Task tracking code for WOW apps, which are really threads.
        //
        BOOL    fShare;

        //
        // WOW apps are different.  They are threads in the NTVDM process.
        // Therefore parent/child relationships aren't useful.  Instead,
        // the best thing we can come up with is to use the status of the
        // foreground window.  We assume that the currently active app at
        // the time the WOW app started up is the one that launched us.
        //
        // We can't just call GetForegroundWindow() here, because it is too
        // late.
        //
        if (hti.idThread == g_idWOWApp)
        {
            fShare = g_fShareWOWApp;

            g_fShareWOWApp = FALSE;
            g_idWOWApp = 0;
        }
        else
        {
            fShare = FALSE;
        }

        if (!fShare)
        {
            TRACE_OUT(("THREAD window %08lx class %s in thread %08ld not shared",
                    hwnd, szClass, hti.idThread));
            DC_QUIT;
        }

        TRACE_OUT(("First window %08lx class %s of WOW app %08ld, shared since foreground is",
            hwnd, szClass, hti.idThread));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYTHREAD;
    }
    else
    {
        //
        // Task tracking code for 32-bit apps.
        //
        DWORD   idParentProcess;

        //
        // First window of a WIN32 app.
        //

        // Loop through our ancestor processes (no thread info at this point)
        HETGetParentProcessID(hti.idProcess, &idParentProcess);

        if (!idParentProcess)
        {
            TRACE_OUT(("Can't get parent of process %08ld", hti.idProcess));
            DC_QUIT;
        }

        //
        // We know if we got here that all our favorite fields are still
        // zero.  So just loop!  But NULL out idThread to avoid matching
        // anything while we look at our parent.
        //
        TRACE_OUT(("First window %08lx class %s in process %08ld %s, checking parent %08ld",
            hwnd, szClass, hti.idProcess, GetCommandLine(), idParentProcess));

        hti.idThread    = 0;
        hti.idProcess   = idParentProcess;
        goto UpOneLevel;
    }

    //
    // OK, we are going to share this.  We do have to repaint console
    // windows--we get the notifications asynchronously.  If the window isn't
    // visible yet, redrawing will do nothing.  After this, the property is
    // set, and we will catch all ouput.  If it has already become visible,
    // invalidating it now will still work, and we will ignore the queued
    // up show notification because the property is set.
    //
    OSI_ShareWindow(hwnd, hostType, (g_hetTrackHook != NULL), TRUE);

DC_EXIT_POINT:
    DebugExitVOID(HETHandleCreate);
}




//
// HETHandleShow()
//
void HETHandleShow
(
    HWND    hwnd,
    BOOL    fForceRepaint
)
{
    UINT    hostType;
    HET_TRACK_INFO  hti;

    DebugEntry(HETHandleShow);

    hostType = (UINT)HET_GetHosting(hwnd);

    //
    // If this window is a real child, clear the hosting property. Usually
    // one isn't there.  But in the case of a top level window becoming
    // a child of another, we want to wipe out junk.
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            TRACE_OUT(("Skipping child window %08lx show", hwnd));
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%08x from SHOW", hwnd));
                OSI_UnshareWindow(hwnd, TRUE);
            }
            DC_QUIT;
        }
    }

    //
    // Is this window already shared?  Nothing to do if so.  If it's a
    // console guy, we've seen it already on create.
    //
    if (hostType)
    {
        TRACE_OUT(("Window %08lx already shared, ignoring show", hwnd));
        DC_QUIT;
    }

    //
    // Here's where we also enumerate the top level windows and find a
    // match.  But we DO not track across processes in this case.  Instead
    // we look at the owner if there is one.
    //
    // This solves the create-as-a-child then change to a top level
    // window problem, like combo dropdowns.
    //

    hti.idThread = GetWindowThreadProcessId(hwnd, &hti.idProcess);
    if (!hti.idThread)
    {
        TRACE_OUT(("Window %08lx gone", hwnd));
        DC_QUIT;
    }

    //
    // Ignore special shell threads
    //
    if (HET_IsShellThread(hti.idThread))
    {
        TRACE_OUT(("Skipping shell thread window %08lx show", hwnd));
        DC_QUIT;
    }

    hti.hwndUs      = hwnd;
    hti.fWOW        = OSI_IsWOWWindow(hwnd);
    hti.cWndsApp    = 0;
    hti.cWndsSharedThread = 0;
    hti.cWndsSharedProcess = 0;

    EnumWindows(HETShareEnum, (LPARAM)(LPHET_TRACK_INFO)&hti);

    //
    // These kinds of windows are always only temp shared.  They don't
    // start out as top level windows that we saw from the beginning or
    // watched created.  These are SetParent() or menu kinds of dudes, so
    // for a lot of reasons we're plain safer sharing these babies only
    // temporarily
    //

    //
    // Anything else shared on this thread/process, the decision is easy.
    // Otherwise, we look at the ownership trail.
    //
    if (!hti.cWndsSharedThread && !hti.cWndsSharedProcess)
    {
        HWND    hwndOwner;

        //
        // Does it have an owner that is shared?
        //
        hwndOwner = hwnd;
        while (hwndOwner = GetWindow(hwndOwner, GW_OWNER))
        {
            if (HET_GetHosting(hwndOwner))
            {
                TRACE_OUT(("Found shared owner %08lx of window %08lx", hwndOwner, hwnd));
                break;
            }
        }

        if (!hwndOwner)
        {
            DC_QUIT;
        }
    }

    //
    // For console apps, we get notifications asynchronously posted to us,
    // in NM's process.  The window may have painted already without our
    // seeing it.  So force it to repaint just in case.  The g_hetTrackHook
    // variable is only around when this is NM.
    //
    TRACE_OUT(("Sharing temporary window %08lx", hwnd));

    OSI_ShareWindow(hwnd, HET_HOSTED_BYWINDOW | HET_HOSTED_TEMPORARY,
        fForceRepaint, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(HETHandleShow);
}




//
// HETHandleHide()
// This handles a window being hidden.  If it was temporary, it is unshared.
// If it is permanent, it is marked as hidden.
//
void HETHandleHide(HWND hwnd)
{
    UINT    hostType;

    DebugEntry(HETHandleHide);

    hostType = (UINT)HET_GetHosting(hwnd);

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            TRACE_OUT(("Skipping child window %08lx hide", hwnd));
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%08x from HIDE", hwnd));
                OSI_UnshareWindow(hwnd, TRUE);
            }
            DC_QUIT;
        }
    }

    if (!hostType)
    {
        //
        // Console apps give us notifications out of context.  Make
        // sure the count is up to date.
        //
        if (g_hetTrackHook)
        {
            HETNewTopLevelCount();
        }
        else
        {
            TRACE_OUT(("Window %08lx not shared, ignoring hide", hwnd));
        }
    }
    else if (hostType & HET_HOSTED_TEMPORARY)
    {
        //
        // Temporarily shared window are only shared when visible.
        //
        TRACE_OUT(("Unsharing temporary window %08lx", hwnd));
        OSI_UnshareWindow(hwnd, TRUE);
    }
    else
    {
        ASSERT(hostType & HET_HOSTED_PERMANENT);

        // Nothing to do.
        TRACE_OUT(("Window %08lx permanently shared, ignoring hide", hwnd));
    }


DC_EXIT_POINT:
    DebugExitVOID(HETHandleHide);
}


//
// HETCheckParentChange()
//
// PARENTCHANGE is 100% reliable, compared to Win9x stuff.
//
void HETCheckParentChange(HWND hwnd)
{
    DebugEntry(HETCheckParentChange);

    WARNING_OUT(("Got PARENTCHANGE for hwnd 0x%08x", hwnd));

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            UINT    hostType;

            hostType = (UINT)HET_GetHosting(hwnd);
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%08x from MOVE", hwnd));
                OSI_UnshareWindow(hwnd, TRUE);
            }
        }
    }

    DebugExitVOID(HETCheckParentChange);
}




//
// OSI_ShareWindow
// This shares a window, calling the display driver to add it to the visrgn
// list.  It is called when
//      * An app is shared
//      * A new window in a shared app is created
//      * A temporary window with a relationship to a shared window is shown
//
// This returns TRUE if it shared a window.
//
BOOL OSI_ShareWindow
(
    HWND    hwnd,
    UINT    hostType,
    BOOL    fRepaint,
    BOOL    fUpdateCount
)
{
    BOOL                rc = FALSE;
    HET_SHARE_WINDOW    req;

    DebugEntry(OSI_ShareWindow);

    //
    // Set the property
    //
    if (!HET_SetHosting(hwnd, hostType))
    {
        ERROR_OUT(("Couldn't set shared property on window %08lx", hwnd));
        DC_QUIT;
    }

    //
    // Tell the display driver
    //
    req.winID       = HandleToUlong(hwnd);
    req.result      = 0;
    if (!OSI_FunctionRequest(HET_ESC_SHARE_WINDOW, (LPOSI_ESCAPE_HEADER)&req,
            sizeof(req)) ||
        !req.result)
    {
        ERROR_OUT(("Driver couldn't add window %08lx to list", hwnd));

        HET_ClearHosting(hwnd);
        DC_QUIT;
    }

    TRACE_OUT(("Shared window %08lx of type %08lx", hwnd, hostType));

    //
    // Repaint it
    //
    if (fRepaint)
    {
        USR_RepaintWindow(hwnd);
    }

    if (fUpdateCount)
    {
        PostMessage(g_asMainWindow, DCS_NEWTOPLEVEL_MSG, TRUE, 0);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSI_ShareWindow, rc);
    return(rc);
}



//
// OSI_UnshareWindow()
// This unshares a window.  This is called when
//      * An app is unshared
//      * A window is destroyed
//      * A temporarily shared window is hidden
//
// It returns TRUE if a shared window has been unshared.
//
BOOL OSI_UnshareWindow
(
    HWND    hwnd,
    BOOL    fUpdateCount
)
{
    BOOL    rc = FALSE;
    UINT    hostType;
    HET_UNSHARE_WINDOW req;

    DebugEntry(OSI_UnshareWindow);

    //
    // This gets the old property and clears it in one step.
    //
    hostType = (UINT)HET_ClearHosting(hwnd);
    if (!hostType)
    {
        if (fUpdateCount && g_hetTrackHook)
        {
            //
            // We always get async notifications for console apps.  In that
            // case, the window is really gone before this comes to us.
            // So redetermine the count now.
            //
            HETNewTopLevelCount();
        }

        DC_QUIT;
    }

    //
    // OK, stuff to do.
    //
    TRACE_OUT(("Unsharing window %08lx of type %08lx", hwnd, hostType));

    //
    // Tell the display driver
    //
    req.winID = HandleToUlong(hwnd);
    OSI_FunctionRequest(HET_ESC_UNSHARE_WINDOW, (LPOSI_ESCAPE_HEADER)&req, sizeof(req));

    //
    // Update the top level count
    //
    if (fUpdateCount)
    {
        PostMessage(g_asMainWindow, DCS_NEWTOPLEVEL_MSG, FALSE, 0);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSI_UnshareWindow, rc);
    return(rc);
}



//
//  HETShareEnum()
//
//  This is the EnumWindows() callback.  We stop when we find the first
//  matching shared window (thread or process).  We keep a running tally
//  of the count of all top level windows in our process (not shared by
//  thread or process) at the same time.  This lets us do tracking.
//
BOOL CALLBACK HETShareEnum(HWND hwnd, LPARAM lParam)
{
    LPHET_TRACK_INFO    lphti = (LPHET_TRACK_INFO)lParam;
    DWORD               idProcess;
    DWORD               idThread;
    UINT                hostType;
    BOOL                rc = TRUE;

    DebugEntry(HETShareEnum);

    // Skip ourself.
    if (hwnd == lphti->hwndUs)
    {
        DC_QUIT;
    }

    // Skip if window is gone.
    idThread = GetWindowThreadProcessId(hwnd, &idProcess);
    if (!idThread)
    {
        DC_QUIT;
    }

    //
    // Do the apps match?  If not, ignore this window.
    //
    if ((idProcess != lphti->idProcess) ||
        ((lphti->fWOW) && (idThread != lphti->idThread)))
    {
        DC_QUIT;
    }

    lphti->cWndsApp++;

    hostType = (UINT)HET_GetHosting(hwnd);
    if (!hostType)
    {
        DC_QUIT;
    }

    //
    // Now, if this window is shared by thread or process, do the right
    // thing.
    //
    if (hostType & HET_HOSTED_BYPROCESS)
    {
        // We have a match.  We can return immediately.
        lphti->cWndsSharedProcess++;
        rc = FALSE;
    }
    else if (hostType & HET_HOSTED_BYTHREAD)
    {
        //
        // For WOW apps, we don't want this one, if in a separate thread, to
        // count.  No matter what.
        //
        if (idThread == lphti->idThread)
        {
            lphti->cWndsSharedThread++;
            rc = FALSE;
        }
    }


DC_EXIT_POINT:
    DebugExitBOOL(HETShareEnum, rc);
    return(rc);
}


//
// HETNewTopLevelCount()
// This does a quick new tally of the shared top level visible count
//
void HETNewTopLevelCount(void)
{
    UINT    newCount;

    DebugEntry(HETNewTopLevelCount);

    newCount = 0;
    EnumWindows(HETCountTopLevel, (LPARAM)&newCount);

    PostMessage(g_asMainWindow, DCS_RECOUNTTOPLEVEL_MSG, newCount, 0);

    DebugExitVOID(HETNewTopLevelCount);
}



//
// HETCountTopLevel()
// This counts shared windows
//
BOOL CALLBACK HETCountTopLevel(HWND hwnd, LPARAM lParam)
{
    DebugEntry(HETCountTopLevel);

    if (HET_GetHosting(hwnd))
    {
        (*(LPUINT)lParam)++;
    }

    DebugExitBOOL(HETCountTopLevel, TRUE);
    return(TRUE);
}



//
// HET_IsShellThread()
// Returns TRUE if thread is one of shell's special threads
//
BOOL  HET_IsShellThread(DWORD threadID)
{
    BOOL    rc;

    DebugEntry(HET_IsShellThread);

    if ((threadID == GetWindowThreadProcessId(HET_GetShellDesktop(), NULL)) ||
        (threadID == GetWindowThreadProcessId(HET_GetShellTray(), NULL)))
    {
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    DebugExitBOOL(HET_IsShellThread, rc);
    return(rc);
}



//
// HET_WindowIsHosted()
// This is called by the high level mouse hook.  Unlike the version in
// MNMCPI32, it doesn't check (or know) if the whole desktop is shared.
//
// LAURABU BOGUS
// Note that this may need to be revised.  The high level hooks are handy
// in desktop sharing also.  For the keyboard, we track the toggle key
// states.  For the mouse, we block messages to non-shared windows.
//
BOOL  HET_WindowIsHosted(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    hwndParent;

    DebugEntry(HET_WindowIsHosted);

    if (!hwnd)
        DC_QUIT;

    //
    // Walk up to the top level window this one is inside of
    //
    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == GetDesktopWindow())
            break;

        hwnd = hwndParent;
    }

    rc = (BOOL)HET_GetHosting(hwnd);

DC_EXIT_POINT:
    DebugExitBOOL(HET_WindowIsHosted, rc);
    return(rc);
}



//
// HETGetParentProcessID()
// This gets the ID of the process which created the passed in one.  Used
// for task tracking
//
void HETGetParentProcessID
(
    DWORD       processID,
    LPDWORD     pParentProcessID
)
{
    HANDLE                      hProcess;
    UINT                        intRC;
    PROCESS_BASIC_INFORMATION   basicInfo;

    DebugEntry(HETGetParentProcessID);

    *pParentProcessID = 0;

    //
    // Open a handle to the process.  If we don't have security privileges,
    // or it is gone, this will fail.
    //
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
            FALSE, processID);
    if (NULL == hProcess)
    {
        WARNING_OUT(("Can't get process handle for ID %08lx", processID));
        DC_QUIT;
    }

    //
    // Get back an information block for this process, one item of which is
    // the parent.
    //
    ASSERT(g_hetNtQIP);

    intRC = g_hetNtQIP(hProcess, ProcessBasicInformation, &basicInfo,
        sizeof(basicInfo),  NULL);

    if (!NT_SUCCESS(intRC))
    {
        ERROR_OUT(("Can't get info for process ID %08lx, handle %08lx -- error %u",
            processID, hProcess, intRC));
    }
    else
    {
        *pParentProcessID = basicInfo.InheritedFromUniqueProcessId;
    }

    //
    // Close the process handle
    //
    CloseHandle(hProcess);

DC_EXIT_POINT:
    DebugExitVOID(HETGetParentProcessID);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\hook\globals.h ===
//
// GLOBALS.H
// Global Variable Declaration
//
// NOTE:
// Variables in .sdata, shared segment, MUST HAVE INITIALIZED VALUES.
// Otherwise, the linker will just stick them silently into .data.
//


#include <host.h>
#include <usr.h>
#include <im.h>


//
// Per process data
//

// These are meaningful in all processes
DC_DATA(HINSTANCE,          g_hookInstance);
DC_DATA(NTQIP,              g_hetNtQIP);
DC_DATA(UINT,               g_appType);
DC_DATA(BOOL,               g_fLeftDownOnShared);

// These are meaningful only in WOW apps
DC_DATA(DWORD,              g_idWOWApp);
DC_DATA(BOOL,               g_fShareWOWApp);

// These are set in CONF's process and NULL in others
DC_DATA(SETWINEVENTHOOK,    g_hetSetWinEventHook);
DC_DATA(UNHOOKWINEVENT,     g_hetUnhookWinEvent);
DC_DATA(HWINEVENTHOOK,      g_hetTrackHook);


//
// Shared data, accessible in all processes
//
#ifdef DC_DEFINE_DATA
#pragma data_seg("SHARED")
#endif


DC_DATA_VAL(HWND,           g_asMainWindow,    NULL);
DC_DATA_VAL(ATOM,           g_asHostProp,      0);
DC_DATA_VAL(HHOOK,          g_imMouseHook,      NULL);
DC_DATA_VAL(char,           g_osiDriverName[CCHDEVICENAME], "");
DC_DATA_VAL(char,           s_osiDisplayName[8], "DISPLAY");

#ifdef DC_DEFINE_DATA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\hook\osi.cpp ===
#include "precomp.h"


//
// OSI.CPP
// OS Isolation layer, NT version in HOOK
//
// Copyright(c) Microsoft 1997-
//

#include <osi.h>
#include <version.h>
#include <ndcgver.h>


//
// OSI_SetDriverName()
// This saves or clears the driver name so in OSI_FunctionRequest we can
// create a DC to communicate with our display driver.  On NT4.x this is a 
// display DC; on NT5 this is a direct DC to our driver.
//
void OSI_SetDriverName(LPCSTR szDriverName)
{
    DebugEntry(OSI_SetDriverName);

    if (!szDriverName)
    {
        // Clear it
        g_osiDriverName[0] = 0;
    }
    else
    {
        // Set it
        ASSERT(!g_osiDriverName[0]);
        lstrcpy(g_osiDriverName, szDriverName);
    }

    DebugExitVOID(OSI_SetDriverName);
}



//
// OSI_FunctionRequest - see osi.h
//
BOOL OSI_FunctionRequest
(
    DWORD escapeFn,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD requestLen
)
{
    BOOL            rc = FALSE;
    ULONG           iEsc;
    HDC             hdc;    

    DebugEntry(OSI_FunctionRequest);

    if (!g_osiDriverName[0])
    {
        // NT 4.x case
        TRACE_OUT(("OSI_FunctionRequest:  Creating %s driver DC",
            s_osiDisplayName));
        hdc = CreateDC(s_osiDisplayName, NULL, NULL, NULL);
    }
    else
    {
        // NT 5 case
        TRACE_OUT(("OSI_FunctionRequest:  Creating %s driver DC",
                g_osiDriverName));
        hdc = CreateDC(NULL, g_osiDriverName, NULL, NULL);
    }

    if (!hdc)
    {
        ERROR_OUT(("Failed to create DC to talk to driver '%s'", g_osiDriverName));
        DC_QUIT;
    }

    TRACE_OUT(("OSI_FunctionRequest:  Created %s driver DC %08x",
            g_osiDriverName, hdc));

    //
    // Pass the request on to the display driver.
    //
    pRequest->padding    = 0;
    pRequest->identifier = OSI_ESCAPE_IDENTIFIER;
    pRequest->escapeFn   = escapeFn;
    pRequest->version    = DCS_MAKE_VERSION();

    if ((escapeFn >= OSI_HET_WO_ESC_FIRST) && (escapeFn <= OSI_HET_WO_ESC_LAST))
    {
        iEsc = WNDOBJ_SETUP;
    }
    else
    {
        iEsc = OSI_ESC_CODE;
    }

    if (0 >= ExtEscape(hdc, iEsc, requestLen, (LPCSTR)pRequest,
            requestLen, (LPSTR)pRequest))
    {
        WARNING_OUT(("ExtEscape %x code %d failed", iEsc, escapeFn));
    }
    else
    {
        rc = TRUE;
    }

DC_EXIT_POINT:
    if (hdc)
    {
        DeleteDC(hdc);
    }

    DebugExitDWORD(OSI_FunctionRequest, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\thk\asthkls.inc ===
; File: asthkls.inc
;
; Nothing here
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\thk\asthk.h ===
// --------------------------------------------------------------------------
//
//  ASTHK.H
//
//  Declarations of 32->16 thunk APIs
//
//  Copyright(c) Microsoft, 1996-
//
//
//  On non x86 platforms, these APIs are #defined instead of implemented,
//  since thunks are in .ASM and that is only x86.  We'll clean this W95-NT
//  stuff up later.
//
// --------------------------------------------------------------------------
#ifndef _H_ASTHK
#define _H_ASTHK


//
// MAIN functions
//

//
// Prototypes for secret KERNEL32 functions
//
BOOL        WINAPI  FT_thkConnectToFlatThkPeer(LPSTR pszDll16, LPSTR pszDll32);
UINT        WINAPI  FreeLibrary16(UINT hmod16);

//
// NMNASWIN.DLL functions
//

// General
void        WINAPI  OSILoad16(LPDWORD lphInst);
BOOL        WINAPI  OSIInit16(DWORD version, HWND hwnd, ATOM atom, LPDWORD ppdcsShared,
    LPDWORD ppoaShared, LPDWORD ppimShared, LPDWORD psbcEnabled,
    LPDWORD pShuntBuffers, LPDWORD pBitmasks);
void        WINAPI  OSITerm16(BOOL fUnloading);
BOOL        WINAPI  OSIFunctionRequest16(DWORD escape, void FAR* lpvEscInfo, DWORD cbEscInfo);

// HET
BOOL        WINAPI  OSIStartWindowTracking16(void);
void        WINAPI  OSIStopWindowTracking16(void);
BOOL        WINAPI  OSIIsWindowScreenSaver16(HWND hwnd);
BOOL        WINAPI  OSIShareWindow16(HWND, UINT, BOOL, BOOL);
BOOL        WINAPI  OSIUnshareWindow16(HWND, BOOL);

// IM
BOOL        WINAPI  OSIInstallControlledHooks16(BOOL fEnable, BOOL fDesktop);
void        WINAPI  OSIInjectMouseEvent16(UINT flags, int x, int y, UINT mouseData, DWORD dwExtraInfo);
void        WINAPI  OSIInjectKeyboardEvent16(UINT flags, WORD vkCode, WORD scanCode, DWORD dwExtraInfo);

#endif // _H_ASTHK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\thk\fltthk.inc ===
; File: fltthk.inc
;
;   Support macros and routines for the flat thunk mode of the thunk
;   compiler.
;
;   Included in *.asm files generated using the 
;   "flatthunks = true" semantic.
;





; Macro: FAPILOG16. Prints out a log message at the start of each thunk.
; Debug only.
FAPILOG16	macro	dwOffset
ifdef DEBUG
	pushd	offset FT_ThunkLogNames + dwOffset
	call	FAPILOG16_Hlp
endif ;DEBUG
endm ;FAPILOG16




ifdef DEBUG

LogApiThkLSF	proto	near stdcall, psz:dword

FAPILOG16_Hlp:
	push	ebp
	mov	ebp,[esp+8]

	invoke	LogApiThkLSF, ebp

	pop	ebp
	ret	4

endif ;DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\api_vers.h ===
#define API_VERSION "CJ006"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\api_up.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   api_up.c  $
 *  $Revision:   1.33  $
 *  $Modtime:   06 Feb 1997 14:37:24  $
 *  $Log:   S:\sturgeon\src\h245\src\vcs\api_up.c_v  $
 *
 *    Rev 1.33   06 Feb 1997 18:14:22   SBELL1
 * took out ossDecoding of returnFunction in FunctionNotSupported PDU.
 *
 *    Rev 1.32   05 Feb 1997 16:46:42   EHOWARDX
 * Was allocating nLength bytes, not WCHARS, for UserInputIndication
 * ASCII to Unicode conversion. Changed to allocate nLength WCHARs.
 *
 *    Rev 1.31   06 Jan 1997 20:38:18   EHOWARDX
 *
 * Changed H245_CONF_CLOSE and H245_CONF_REQ_CLOSE to fill in
 * AccRej with H245_REJ for any errors.
 *
 *    Rev 1.30   19 Dec 1996 21:00:56   EHOWARDX
 * Oops! H245_IND_OPEN_CONF can occur from T103 timeout (it's unique among
 * indications; it's the only one that can happen in response to a timeout!)
 *
 *    Rev 1.29   19 Dec 1996 17:18:22   EHOWARDX
 * Changed to use h245asn1.h definitions instead of _setof3 and _setof8.
 *
 *    Rev 1.28   18 Dec 1996 16:33:18   EHOWARDX
 *
 * Fixed bug in Master Slave Determination Kludge.
 *
 *    Rev 1.27   17 Dec 1996 17:13:20   EHOWARDX
 * Added pSeparateStack to IND_OPEN_T.
 *
 *    Rev 1.26   12 Dec 1996 15:57:12   EHOWARDX
 * Master Slave Determination kludge.
 *
 *    Rev 1.25   21 Oct 1996 16:07:38   EHOWARDX
 * Modified to make sure H245_INDETERMINATE is returned and Master/Slave
 * status if determination fails.
 *
 *    Rev 1.24   17 Oct 1996 18:17:14   EHOWARDX
 * Changed general string to always be Unicode.
 *
 *    Rev 1.23   14 Oct 1996 14:01:12   EHOWARDX
 * Unicode changes.
 *
 *    Rev 1.22   27 Aug 1996 10:54:16   unknown
 * Deleted redundant lines.
 *
 *    Rev 1.22   27 Aug 1996 10:52:28   unknown
 * Deleted redundant lines.
 *
 *    Rev 1.22   27 Aug 1996 09:54:12   unknown
 * Deleted redundant lines.
 *
 *    Rev 1.21   26 Aug 1996 14:19:18   EHOWARDX
 * Added code to send FunctionNotUnderstood indication to remote peer
 * if receive callback returns H245_ERROR_NOSUP.
 *
 *    Rev 1.20   20 Aug 1996 14:44:40   EHOWARDX
 * Changed H245_IND_COMM_MODE_RESPONSE and H245_IND_COMM_MODE_COMMAND
 * callbacks to fill in DataType field in Cap as per Mike Andrews' request.
 *
 *    Rev 1.19   15 Aug 1996 15:20:24   EHOWARDX
 * First pass at new H245_COMM_MODE_ENTRY_T requested by Mike Andrews.
 * Use at your own risk!
 *
 *    Rev 1.18   15 Aug 1996 09:34:20   EHOWARDX
 * Made TOTCAP and MUX structure in process_open_ind static since we are
 * accessing pointers to them after return from the function.
 *
 *    Rev 1.17   29 Jul 1996 19:33:00   EHOWARDX
 *
 * Fixed bug in flow control - missing break in restriction switch statement.
 *
 *    Rev 1.16   19 Jul 1996 14:11:26   EHOWARDX
 *
 * Added indication callback structure for CommunicationModeResponse
 * and CommunicationModeCommand.
 *
 *    Rev 1.15   19 Jul 1996 12:48:00   EHOWARDX
 *
 * Multipoint clean-up.
 *
 *    Rev 1.14   09 Jul 1996 17:09:28   EHOWARDX
 * Fixed pointer offset bug in processing DataType from received
 * OpenLogicalChannel.
 *
 *    Rev 1.13   01 Jul 1996 22:13:04   EHOWARDX
 *
 * Added Conference and CommunicationMode structures and functions.
 *
 *    Rev 1.12   18 Jun 1996 14:50:28   EHOWARDX
 *
 * Changed MLSE confirm handling.
 *
 *    Rev 1.11   14 Jun 1996 18:57:52   EHOWARDX
 * Geneva update.
 *
 *    Rev 1.10   10 Jun 1996 16:55:34   EHOWARDX
 * Removed #include "h245init.x"
 *
 *    Rev 1.9   06 Jun 1996 18:45:52   EHOWARDX
 * Added check for null dwTransId to Tracker routines; changed to use
 * tracker routines instead of PLOCK macros.
 *
 *    Rev 1.8   04 Jun 1996 13:56:46   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.7   30 May 1996 23:39:00   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.6   29 May 1996 15:20:06   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.5   28 May 1996 14:22:58   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.4   20 May 1996 22:17:58   EHOWARDX
 * Completed NonStandard Message and H.225.0 Maximum Skew indication
 * implementation. Added ASN.1 validation to H245SetLocalCap and
 * H245SetCapDescriptor. Check-in from Microsoft drop on 17-May-96.
 *
 *    Rev 1.3   16 May 1996 19:40:46   EHOWARDX
 * Fixed multiplex capability bug.
 *
 *    Rev 1.2   16 May 1996 15:59:24   EHOWARDX
 * Fine-tuning H245SetLocalCap/H245DelLocalCap/H245SetCapDescriptor/
 * H245DelCapDescriptor behaviour.
 *
 *    Rev 1.1   13 May 1996 23:16:26   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.0   09 May 1996 21:06:08   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.23.1.11   09 May 1996 19:31:30   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.23.1.10   01 May 1996 19:30:32   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address types to H245_xxx.
 *
 *    Rev 1.23.1.9   29 Apr 1996 16:02:58   EHOWARDX
 * Changed callback to give second parameters as pointer to specific message
 * instead of pointer to general PDU structure.
 *
 *    Rev 1.23.1.8   27 Apr 1996 21:09:40   EHOWARDX
 * Changed Channel Numbers to words, added H.225.0 support.
 *
 *    Rev 1.23.1.7   26 Apr 1996 15:54:34   EHOWARDX
 * Added H.225.0 Capability support; Changed Capability indication
 * to only callback once with PDU.
 *
 *    Rev 1.23.1.6   24 Apr 1996 20:53:56   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 *
 *    Rev 1.23.1.5   23 Apr 1996 14:45:28   EHOWARDX
 * Disabled Curt's "Conflict Resolution".
 *
 *    Rev 1.23.1.4   19 Apr 1996 12:55:10   EHOWARDX
 * Updated to 1.29
 *
 *    Rev 1.23.1.3   17 Apr 1996 14:37:38   unknown
 * Added load_H222_param(), load_VGMUX_param(), and load_H2250_param() and
 * modified process_open_ind() to use them.
 *
 *    Rev 1.23.1.2   15 Apr 1996 15:10:32   EHOWARDX
 * Updated to match Curt's current version.
 *
 *    Rev 1.23.1.1   03 Apr 1996 17:15:00   EHOWARDX
 * No change.
 *
 *    Rev 1.23.1.0   03 Apr 1996 15:54:04   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.23   01 Apr 1996 16:46:20   cjutzi
 *
 * - changed tracker structure
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 *
 *    Rev 1.22   29 Mar 1996 14:54:28   cjutzi
 * - added UserInput,
 *
 *    Rev 1.21   28 Mar 1996 15:57:46   cjutzi
 * - removed ASSERT line 1290.. close can occur on any channel at any time
 *
 *    Rev 1.20   27 Mar 1996 08:36:40   cjutzi
 * - removed PDU from stack.. made them dynamically allocated
 *
 *    Rev 1.19   26 Mar 1996 13:48:30   cjutzi
 *
 * - dwPreserved in the callback routine was uninitialized..
 *
 *    Rev 1.18   18 Mar 1996 15:23:30   cjutzi
 *
 *
 *
 *    Rev 1.17   13 Mar 1996 14:14:02   cjutzi
 *
 * - clean up and added ASSERTs ..
 *
 *    Rev 1.16   13 Mar 1996 12:06:12   cjutzi
 *
 * - fixed .. CONFIRM open.. for hani.. It released the tracker..
 *     was supposed to simply update the state to IDLE..
 *
 *    Rev 1.15   13 Mar 1996 09:22:12   cjutzi
 *
 * - removed CRITICAL SECTIONS
 *
 *    Rev 1.14   12 Mar 1996 15:52:32   cjutzi
 *
 * - fixed master slave (forgot a break)
 * - fixed callback bug w/ cleanup on termcaps.
 * - implemented End Session
 * - fixed shutdown
 * - Implemented Locking (big changes here.. )
 *
 *    Rev 1.13   08 Mar 1996 14:04:18   cjutzi
 *
 * - implemented the upcall for mux table entries..
 * - implemented capabillity descriptor callback
 *
 *    Rev 1.12   05 Mar 1996 17:36:28   cjutzi
 *
 * - added MasterSlave indication message
 * - remove bzero/bcopy and changed free call
 * - implemented Mux Table down.. (not up)
 *
 *    Rev 1.11   01 Mar 1996 14:16:08   cjutzi
 *
 * - added hani's error messages.. MasterSlave_FAILED.. oppss.. Forgot..
 *
 *    Rev 1.10   01 Mar 1996 13:47:58   cjutzi
 *
 * - added hani's new fsm id's
 *
 *    Rev 1.9   29 Feb 1996 17:26:16   cjutzi
 * - bi-directional channel open working
 *
 *    Rev 1.8   27 Feb 1996 14:56:30   cjutzi
 *
 * - fixed termcap_ack.. pdu was not being zero'd out..
 * - cleaned up the code alittle..
 *
 *    Rev 1.7   26 Feb 1996 17:22:40   cjutzi
 *
 * - Misc Command Indication added
 *
 *    Rev 1.6   26 Feb 1996 11:05:48   cjutzi
 *
 * - lot's o-changes.. (sorry)
 *
 *    Rev 1.5   16 Feb 1996 13:01:54   cjutzi
 *
 *  - got open / close / request close working in both directions.
 *
 *    Rev 1.4   15 Feb 1996 14:11:46   cjutzi
 *
 * - added muxt table to incoming open..
 *
 *    Rev 1.3   15 Feb 1996 10:51:56   cjutzi
 *
 * - termcaps working
 * - changed API interface for MUX_T
 * - changed callback for IND_OPEN
 * - changed constants IND_OPEN/IND_OPEN_NEEDSRSP
 * - cleaned up the open.
 * - modified H223 stuff
 *
 *    Rev 1.2   09 Feb 1996 16:58:28   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *
 *****************************************************************************/

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****                                                                   *****/
/****                   NOTES TO THE READER                             *****/
/****                                                                   *****/
/**** This program has been put together using a a screen which is      *****/
/**** wider than 80 characters.. It is best if a similar screen size is *****/
/**** used.. Of course emacs is my preference but 80 col screens will   *****/
/**** cause you much frustration..                                      *****/
/****                                                                   *****/
/**** Tabs are set to 8                                                 *****/
/****                                                                   *****/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"
#include "h245asn1.h"
#include "fsmexpor.h"
#include "api_util.x"
#include "pdu.x"



HRESULT
LoadUnicastAddress  (H245_TRANSPORT_ADDRESS_T *pOut,
                     UnicastAddress           *pIn)
{
  switch (pIn->choice)
  {
  case UnicastAddress_iPAddress_chosen:
    pOut->type = H245_IP_UNICAST;
    memcpy(pOut->u.ip.network,
           pIn->u.UnicastAddress_iPAddress.network.value,
           4);
    pOut->u.ip.tsapIdentifier = pIn->u.UnicastAddress_iPAddress.tsapIdentifier;
    break;

  case iPXAddress_chosen:
    pOut->type = H245_IPX_UNICAST;
    memcpy(pOut->u.ipx.node,
           pIn->u.iPXAddress.node.value,
           6);
    memcpy(pOut->u.ipx.netnum,
           pIn->u.iPXAddress.netnum.value,
           4);
    memcpy(pOut->u.ipx.tsapIdentifier,
           pIn->u.iPXAddress.tsapIdentifier.value,
           2);
    break;

  case UncstAddrss_iP6Address_chosen:
    pOut->type = H245_IP6_UNICAST;
    memcpy(pOut->u.ip6.network,
           pIn->u.UncstAddrss_iP6Address.network.value,
           16);
    pOut->u.ip6.tsapIdentifier = pIn->u.UncstAddrss_iP6Address.tsapIdentifier;
    break;

  case netBios_chosen:
    pOut->type = H245_NETBIOS_UNICAST;
    memcpy(pOut->u.netBios, pIn->u.netBios.value, 16);
    break;

  case iPSourceRouteAddress_chosen:
    switch (pIn->u.iPSourceRouteAddress.routing.choice)
    {
    case strict_chosen:
      pOut->type = H245_IPSSR_UNICAST;
      break;

    case loose_chosen:
      pOut->type = H245_IPLSR_UNICAST;
      break;

    default:
      return H245_ERROR_INVALID_DATA_FORMAT;
    } // switch
    memcpy(pOut->u.ipSourceRoute.network,
           pIn->u.iPSourceRouteAddress.network.value,
           4);
    pOut->u.ipSourceRoute.tsapIdentifier = pIn->u.iPSourceRouteAddress.tsapIdentifier;
    // TBD - handle route
    break;

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch
  return H245_ERROR_OK;
} // LoadUnicastAddress()



HRESULT
LoadMulticastAddress(H245_TRANSPORT_ADDRESS_T *pOut,
                     MulticastAddress         *pIn)
{
  switch (pIn->choice)
  {
  case MltcstAddrss_iPAddress_chosen:
    pOut->type = H245_IP_MULTICAST;
    memcpy(pOut->u.ip.network,
           pIn->u.MltcstAddrss_iPAddress.network.value,
           4);
    pOut->u.ip.tsapIdentifier = pIn->u.MltcstAddrss_iPAddress.tsapIdentifier;
    break;

  case MltcstAddrss_iP6Address_chosen:
    pOut->type = H245_IP6_MULTICAST;
    memcpy(pOut->u.ip6.network,
           pIn->u.MltcstAddrss_iP6Address.network.value,
           16);
    pOut->u.ip6.tsapIdentifier = pIn->u.MltcstAddrss_iP6Address.tsapIdentifier;
    break;

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch
  return H245_ERROR_OK;
} // LoadMulticastAddress()



HRESULT
LoadTransportAddress(H245_TRANSPORT_ADDRESS_T  *pOut,
                     H245TransportAddress          *pIn)
{
  switch (pIn->choice)
  {
  case unicastAddress_chosen:
    return LoadUnicastAddress  (pOut, &pIn->u.unicastAddress);

  case multicastAddress_chosen:
    return LoadMulticastAddress(pOut, &pIn->u.multicastAddress);

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch
} // LoadTransportAddress()



HRESULT
LoadCommModeEntry(H245_COMM_MODE_ENTRY_T       *pOut,
                  CommunicationModeTableEntry  *pIn)
{
  HRESULT   lResult;

  memset(pOut, 0, sizeof(*pOut));

  if (pIn->bit_mask & CMTEy_nnStndrd_present)
  {
    pOut->pNonStandard = pIn->CMTEy_nnStndrd;
  }

  pOut->sessionID = (unsigned char)pIn->sessionID;

  if (pIn->bit_mask & CMTEy_assctdSssnID_present)
  {
    pOut->associatedSessionID = (unsigned char)pIn->CMTEy_assctdSssnID;
    pOut->associatedSessionIDPresent = TRUE;
  }

  if (pIn->bit_mask & CommunicationModeTableEntry_terminalLabel_present)
  {
    pOut->terminalLabel = pIn->terminalLabel;
    pOut->terminalLabelPresent = TRUE;
  }

  pOut->pSessionDescription       = pIn->sessionDescription.value;
  pOut->wSessionDescriptionLength = (WORD) pIn->sessionDescription.length;

  switch (pIn->dataType.choice)
  {
  case dataType_videoData_chosen:
    pOut->dataType.DataType = H245_DATA_VIDEO;
    break;

  case dataType_audioData_chosen:
    pOut->dataType.DataType = H245_DATA_AUDIO;
    break;

  case dataType_data_chosen:
    pOut->dataType.DataType = H245_DATA_DATA;
    break;

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch

  lResult = build_totcap_cap_n_client_from_capability ((struct Capability *)&pIn->dataType,
                                                       pOut->dataType.DataType,
                                                       pIn->dataType.u.dataType_videoData.choice,
                                                       &pOut->dataType);
  if (lResult != H245_ERROR_OK)
    return lResult;

  if (pIn->bit_mask & CMTEy_mdChnnl_present)
  {
    lResult = LoadTransportAddress(&pOut->mediaChannel, &pIn->CMTEy_mdChnnl);
    if (lResult != H245_ERROR_OK)
      return lResult;
    pOut->mediaChannelPresent = TRUE;
  }

  if (pIn->bit_mask & CMTEy_mdGrntdDlvry_present)
  {
    pOut->mediaGuaranteed = pIn->CMTEy_mdGrntdDlvry;
    pOut->mediaGuaranteedPresent = TRUE;
  }

  if (pIn->bit_mask & CMTEy_mdCntrlChnnl_present)
  {
    lResult = LoadTransportAddress(&pOut->mediaControlChannel, &pIn->CMTEy_mdCntrlChnnl);
    if (lResult != H245_ERROR_OK)
      return lResult;
    pOut->mediaControlChannelPresent = TRUE;
  }

  if (pIn->bit_mask & CMTEy_mdCntrlGrntdDlvry_present)
  {
    pOut->mediaControlGuaranteed = pIn->CMTEy_mdCntrlGrntdDlvry;
    pOut->mediaControlGuaranteedPresent = TRUE;
  }

  return H245_ERROR_OK;
} // LoadCommModeEntry()



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   load_H222_param
 *              load_H223_param
 *              load_VGMUX_param
 *              load_H2250_param
 *              load_H2250ACK_param
 *
 * DESCRIPTION
 *
 *              This routine builds local API-style Logical Parameters out of ASN.1
 *              structure passed to it
 *
 *
 * RETURN:
 *
 *****************************************************************************/

static HRESULT
load_H222_param (H245_H222_LOGICAL_PARAM_T *    pOut,   /* output */
                 H222LogicalChannelParameters * pIn)    /* input  */
{
  /* See setup_H220_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  pOut->resourceID   = pIn->resourceID;
  pOut->subChannelID = pIn->subChannelID;
  if (pIn->bit_mask & pcr_pid_present)
  {
    pOut->pcr_pidPresent = TRUE;
    pOut->pcr_pid = pIn->pcr_pid;
  }
  if (pIn->bit_mask & programDescriptors_present)
  {
    pOut->programDescriptors.length = pIn->programDescriptors.length;
    pOut->programDescriptors.value  = pIn->programDescriptors.value;
  }
  if (pIn->bit_mask & streamDescriptors_present)
  {
    pOut->streamDescriptors.length = pIn->streamDescriptors.length;
    pOut->streamDescriptors.value  = pIn->streamDescriptors.value;
  }
  return H245_ERROR_OK;
} // load_H222_param()

static HRESULT
load_H223_param (H245_H223_LOGICAL_PARAM_T *    pOut,   /* output */
                 H223LogicalChannelParameters * pIn)    /* input  */
{
  HRESULT                lError = H245_ERROR_OK;

  /* See setup_H223_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  pOut->SegmentFlag = pIn->segmentableFlag;

  switch (pIn->adaptationLayerType.choice)
    {
    case H223LCPs_aLTp_nnStndrd_chosen:
      lError = CopyNonStandardParameter(&pOut->H223_NONSTD,
                                         &pIn->adaptationLayerType.u.H223LCPs_aLTp_nnStndrd);
      pOut->AlType = H245_H223_AL_NONSTD;
      break;
    case H223LCPs_aLTp_al1Frmd_chosen:
      pOut->AlType = H245_H223_AL_AL1FRAMED;
      break;
    case H223LCPs_aLTp_al1NtFrmd_chosen:
      pOut->AlType = H245_H223_AL_AL1NOTFRAMED;
      break;
    case H223LCPs_aLTp_a2WSNs_1_chosen:
      pOut->AlType = H245_H223_AL_AL2NOSEQ;
      break;
    case H223LCPs_aLTp_a2WSNs_2_chosen:
      pOut->AlType = H245_H223_AL_AL2SEQ;
      break;
    case H223LCPs_aLTp_al3_chosen:
      pOut->AlType = H245_H223_AL_AL3;
      pOut->CtlFldOctet = (unsigned char)pIn->adaptationLayerType.u.H223LCPs_aLTp_al3.controlFieldOctets;
      pOut->SndBufSize  = pIn->adaptationLayerType.u.H223LCPs_aLTp_al3.sendBufferSize;
      break;
    } /* switch */

  return lError;
} // load_H223_param()

static HRESULT
load_VGMUX_param(H245_VGMUX_LOGICAL_PARAM_T  *pOut,   /* output */
                 V76LogicalChannelParameters *pIn)    /* input  */
{
  /* See setup_VGMUX_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  pOut->crcLength             = pIn->hdlcParameters.crcLength.choice;
  pOut->n401                  = pIn->hdlcParameters.n401;
  pOut->loopbackTestProcedure = pIn->hdlcParameters.loopbackTestProcedure;
  pOut->suspendResume         = pIn->suspendResume.choice;
  pOut->uIH                   = pIn->uIH;
  pOut->mode                  = pIn->mode.choice;
  switch (pIn->mode.choice)
  {
  case eRM_chosen:
    pOut->windowSize          = pIn->mode.u.eRM.windowSize;
    pOut->recovery            = pIn->mode.u.eRM.recovery.choice;
    break;
  } // switch
  pOut->audioHeaderPresent    = pIn->v75Parameters.audioHeaderPresent;
  return H245_ERROR_OK;
} // load_VGMUX_param()

static HRESULT
load_H2250_param(H245_H2250_LOGICAL_PARAM_T *   pOut,   /* output */
                 H2250LogicalChannelParameters *pIn)    /* input  */
{
  HRESULT                lError = H245_ERROR_OK;

  /* See setup_H2250_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  if (pIn->bit_mask & H2250LCPs_nnStndrd_present)
  {
    pOut->nonStandardList = pIn->H2250LCPs_nnStndrd;
  }

  pOut->sessionID = (unsigned char) pIn->sessionID;

  if (pIn->bit_mask & H2250LCPs_assctdSssnID_present)
  {
    pOut->associatedSessionID = (unsigned char)pIn->H2250LCPs_assctdSssnID;
    pOut->associatedSessionIDPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCPs_mdChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaChannel,
                           &pIn->H2250LCPs_mdChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCPs_mdGrntdDlvry_present)
  {
    pOut->mediaGuaranteed = pIn->H2250LCPs_mdGrntdDlvry;
    pOut->mediaGuaranteedPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCPs_mdCntrlChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaControlChannel,
                                    &pIn->H2250LCPs_mdCntrlChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaControlChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCPs_mCGDy_present)
  {
    pOut->mediaControlGuaranteed = pIn->H2250LCPs_mCGDy;
    pOut->mediaControlGuaranteedPresent = TRUE;
  }

  if (pIn->bit_mask & silenceSuppression_present)
  {
    pOut->silenceSuppression = pIn->silenceSuppression;
    pOut->silenceSuppressionPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LogicalChannelParameters_destination_present)
  {
    pOut->destination = pIn->destination;
    pOut->destinationPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCPs_dRTPPTp_present)
  {
    pOut->dynamicRTPPayloadType = (unsigned char)pIn->H2250LCPs_dRTPPTp;
    pOut->dynamicRTPPayloadTypePresent = TRUE;
  }

  if (pIn->bit_mask & mediaPacketization_present)
  {
    switch (pIn->mediaPacketization.choice)
    {
    case h261aVideoPacketization_chosen:
      pOut->h261aVideoPacketization = TRUE;
      break;

    default:
      return H245_ERROR_INVALID_DATA_FORMAT;
    } // switch
  }

  return lError;
} // load_H2250_param()

static HRESULT
load_H2250ACK_param(H245_H2250ACK_LOGICAL_PARAM_T *     pOut,
                    H2250LgclChnnlAckPrmtrs *           pIn)
{
  HRESULT                lError = H245_ERROR_OK;

  /* See setup_H2250ACK_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  if (pIn->bit_mask & H2250LCAPs_nnStndrd_present)
  {
    pOut->nonStandardList = pIn->H2250LCAPs_nnStndrd;
  }

  if (pIn->bit_mask & sessionID_present)
  {
    pOut->sessionID = (unsigned char) pIn->sessionID;
    pOut->sessionIDPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCAPs_mdChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaChannel,
                                    &pIn->H2250LCAPs_mdChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCAPs_mdCntrlChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaControlChannel,
                                     &pIn->H2250LCAPs_mdCntrlChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaControlChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCAPs_dRTPPTp_present)
  {
    pOut->dynamicRTPPayloadType = (unsigned char)pIn->H2250LCAPs_dRTPPTp;
    pOut->dynamicRTPPayloadTypePresent = TRUE;
  }

  return lError;
} // load_H2250ACK_param()



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   build_element_list_from_mux -
 *
 * DESCRIPTION
 *              recursively build H245_MUX_ENTRY_ELEMENT_T list from
 *              ASN1 mux table descriptor entrys.
 *
 * RETURN:
 *
 *****************************************************************************/
static H245_MUX_ENTRY_ELEMENT_T *
build_element_list_from_mux (MultiplexElement *p_ASN_mux_el,
                             H245_ACC_REJ_T   *p_acc_rej)
{
  DWORD                     ii;
  H245_MUX_ENTRY_ELEMENT_T *p_mux_el;
  H245_MUX_ENTRY_ELEMENT_T *p_mux_el_tmp = NULL;
  H245_MUX_ENTRY_ELEMENT_T *p_mux_el_lst = NULL;

  if (!(p_mux_el = (H245_MUX_ENTRY_ELEMENT_T *)MemAlloc(sizeof(H245_MUX_ENTRY_ELEMENT_T))))
    {
      /* too complicated.. ran out of memory */
      H245TRACE(0,1,"build_element_list_from_mux : H245_ERROR_NOMEM");
      *p_acc_rej = H245_REJ_MUX_COMPLICATED;
      return NULL;
    }

  /* zero it out */
  memset (p_mux_el, 0, sizeof(H245_MUX_ENTRY_ELEMENT_T));

  switch (p_ASN_mux_el->type.choice)
    {
    case typ_logicalChannelNumber_chosen:
      /* assign as a logical channel */
      p_mux_el->Kind = H245_MUX_LOGICAL_CHANNEL;
      p_mux_el->u.Channel = p_ASN_mux_el->type.u.typ_logicalChannelNumber;
      break;
    case subElementList_chosen:
      {
        /* if the sub element list doesn't exist .. no go           */
        /* if the sub element list has less than 2 entries.. no go. */
        if ((!p_ASN_mux_el->type.u.subElementList) ||
            (p_ASN_mux_el->type.u.subElementList->count < 2))
          {
            /* invalid Element list.. */
            H245TRACE(0,1,"build_element_list_from_mux : << ERROR >> Element Count < 2");
            *p_acc_rej = H245_REJ;
            free_mux_el_list (p_mux_el);
            return NULL;
          }

        /* assign as entry element */
        p_mux_el->Kind = H245_MUX_ENTRY_ELEMENT;

        /* ok.. for every sub element in the list */
        for (ii=0;ii<p_ASN_mux_el->type.u.subElementList->count;ii++)
          {
            if (!(p_mux_el_tmp = build_element_list_from_mux (&p_ASN_mux_el->type.u.subElementList->value[ii], p_acc_rej)))
              {
                /* *p_acc_rej is set from below */
                free_mux_el_list (p_mux_el);
                return NULL;
              }

            /* if first on the down sub element list.. assign to sub    */
            /* element  portion of mux_el                               */

            if (!p_mux_el_lst)
              p_mux_el->u.pMuxTblEntryElem = p_mux_el_tmp;
            /* otherwise.. just a list.. add it on.. */
            else
              p_mux_el_lst->pNext = p_mux_el_tmp;

            p_mux_el_lst = p_mux_el_tmp;
          }
      }
      break;
    default:
      /* Un supported structure */
      H245TRACE(0,1,"build_element_list_from_mux : INVALID MUX TABLE ENTRY PDU 'type.choice' unknown");
      *p_acc_rej = H245_REJ;
      free_mux_el_list (p_mux_el);
      return NULL;
    }

  switch (p_ASN_mux_el->repeatCount.choice)
    {
    case repeatCount_finite_chosen:
      p_mux_el->RepeatCount = p_ASN_mux_el->repeatCount.u.repeatCount_finite;
      break;
    case untilClosingFlag_chosen:
      p_mux_el->RepeatCount = 0;
      break;
    default:
      /* Un supported structure */
      H245TRACE(0,1,"build_element_list_from_mux : INVALID MUX TABLE ENTRY PDU 'repeatCount.choice' unknown");
      *p_acc_rej = H245_REJ;
      free_mux_el_list (p_mux_el);
      return NULL;
      break;
    }

  return p_mux_el;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_mux_table_ind
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 *****************************************************************************/
static H245_MUX_TABLE_T *
process_mux_table_ind (MltmdSystmCntrlMssg      *p_pdu_ind,
                       unsigned short           *p_seq,
                       H245_ACC_REJ_MUX_T       rej_mux,
                       DWORD                    *p_rej_cnt,
                       DWORD                    *p_acc_cnt)
{
  UINT                          ii;                     /* generic counter */
  MultiplexEntrySend           *p_ASN_mux;              /* ans1 mux entry  */
  MultiplexEntryDescriptorLink  p_ASN_med_desc_lnk;     /* asn1 mux entry descriptor */
  int                           mux_entry;              /* current mux entry descc   */
  H245_MUX_TABLE_T             *p_mux_table_list = NULL;

  ASSERT(p_pdu_ind->choice == MltmdSystmCntrlMssg_rqst_chosen);
  ASSERT(p_pdu_ind->u.MltmdSystmCntrlMssg_rqst.choice == multiplexEntrySend_chosen);

  /* initialize rej_mux */
  for (ii=0;ii<15;ii++)
    {
      rej_mux[ii].AccRej = H245_ACC;
      rej_mux[ii].MuxEntryId = 0;
    }
  *p_rej_cnt = 0;
  *p_acc_cnt = 0;

  p_ASN_mux = &(p_pdu_ind->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend);

  /* get sequence number */
  *p_seq = p_ASN_mux->sequenceNumber;

  /* this should never happen.. */
  if (!(p_ASN_mux->multiplexEntryDescriptors))
    return NULL;

  /* for each descriptor.. ie mux table entry  */
  for (p_ASN_med_desc_lnk = p_ASN_mux->multiplexEntryDescriptors, mux_entry=0;
       p_ASN_med_desc_lnk;
       p_ASN_med_desc_lnk = p_ASN_med_desc_lnk->next, mux_entry++)
    {
      /* remove descriptor from table */
      H245_MUX_TABLE_T  *p_mux_table;
      H245_MUX_TABLE_T  *p_mux_table_lst = NULL;

      if (!(p_mux_table = (H245_MUX_TABLE_T *)MemAlloc(sizeof(H245_MUX_TABLE_T))))
        {
          /* houston.. we have a problem !!!!!!!! */
          /* rejet this one..                     */
          /* and move on..                        */

          rej_mux[mux_entry].MuxEntryId = p_ASN_med_desc_lnk->value.multiplexTableEntryNumber;
          rej_mux[mux_entry].AccRej  = H245_REJ;
          (*p_rej_cnt)++;
          continue;
        }

      /* zero it out */
      memset (p_mux_table, 0, sizeof(H245_MUX_TABLE_T));

      /* assign mux table entry */
      rej_mux[mux_entry].MuxEntryId = (DWORD)
        p_mux_table->MuxEntryId =
          p_ASN_med_desc_lnk->value.multiplexTableEntryNumber;

      /* if element is not present */
      if (p_ASN_med_desc_lnk->value.bit_mask != elementList_present)
        {
          p_mux_table->pMuxTblEntryElem = NULL;
          rej_mux[mux_entry].AccRej = H245_ACC;
          (*p_acc_cnt)++;
        }
      /* if element list present */
      else
        {
          H245_MUX_ENTRY_ELEMENT_T *p_mux_el_lst = NULL;
          H245_MUX_ENTRY_ELEMENT_T *p_mux_el_tmp = NULL;

          /* start if off.. w/ ok */
          rej_mux[mux_entry].AccRej = H245_ACC;

          /* for each element in the element list..    */
          /* build the subelements.. if error .. free  */
          /* what youve done so far.. and break out    */
          for (ii=0;
               ii < p_ASN_med_desc_lnk->value.elementList.count;
               ii++)
            {
              /* if any of the elements fail.. flag the entry w/ reject reason  */
              /*        (this is done inside the build_element_list..)          */
              /*   and break out.. continue on with the next descriptor         */
              if (!(p_mux_el_tmp = build_element_list_from_mux (&(p_ASN_med_desc_lnk->value.elementList.value[ii]),&(rej_mux[mux_entry].AccRej))))
                {
                  /* free the list.. */
                  free_mux_el_list (p_mux_table->pMuxTblEntryElem);
                  break;
                }

              /* ***************************** */
              /* LINK IN THE MUX ENTRY ELEMENT */
              /* ***************************** */

              /* if first time through         */
              if (!p_mux_el_lst)
                p_mux_table->pMuxTblEntryElem = p_mux_el_tmp;
              /* otherwize .. just tag on the end */
              else
                p_mux_el_lst->pNext = p_mux_el_tmp;

              p_mux_el_lst = p_mux_el_tmp;

            } /* for each element in descriptor list */

        } /* if element list present */

      /* if you've accepted the mux table entry descriptor */
      if (rej_mux[mux_entry].AccRej == H245_ACC)
        {
          /* indicate an accept */
          (*p_acc_cnt)++;

          /* ******************************** */
          /* LINK IN THE MUX TABLE DESCRIPTOR */
          /* ******************************** */

          /* first table entry on the list.. (first time through) */
          if (!p_mux_table_list)
            p_mux_table_list = p_mux_table;
          else
            p_mux_table_lst->pNext = p_mux_table;

          p_mux_table_lst = p_mux_table;
        }
      else
        {
          /* indicate a reject */
          (*p_rej_cnt)++;

          /* otherwise.. free it and move on to something better */
          MemFree(p_mux_table);
        }

    } /* for each desriptor in the list */

  return p_mux_table_list;

} /* procedure */

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind__cap_table
 *
 * DESCRIPTION  allocates a new cap link and copies the capabiliites.
 *              links into the tiven capabilityTableLink, and if
 *              Parameters are NONSTANDARD does some gymnastics to copy
 *              data so it can be used..
 *
 *              NOTE: Copied data must be freed when capability is deleted.
 *                    see where the capability is deleted for exceptions
 *                    for "NONSTD" parameter sets .. (this is not pretty)
 *
 * RETURN:
 *
 *****************************************************************************/

static HRESULT
process_term_cap_set_ind__cap_table ( struct InstanceStruct        *pInstance,
                                      struct TerminalCapabilitySet *pTermCapSet,
                                      CapabilityTableLink           pCapLink,
                                      MltmdSystmCntrlMssg          *p_pdu_rsp)
{
  H245_TOTCAP_T                 totcap;
  CapabilityTableLink           pNewLink;
  HRESULT                       lError;

  while (pCapLink)
  {
    if (build_totcap_from_captbl (&totcap,
                                  pCapLink,
                                  H245_REMOTE) == H245_ERROR_OK)
    {
      /* ok.. assume the CapId is set.. find it in the remote table  */
      /* if it exists, delete it so we can add new one in it's place */
      pNewLink = find_capid_by_entrynumber( pTermCapSet, totcap.CapId);
      if (pNewLink)
      {
        del_cap_link ( pTermCapSet, pNewLink );
      }

      /* ok.. if you've deleted the cap.. now see if there is a new one to take it's place */
      if (pCapLink->value.bit_mask & capability_present)
      {
        /* load and link into remote table entry */
        pNewLink = alloc_link_cap_entry (pTermCapSet);
        if (!pNewLink)
        {
          return H245_ERROR_NORESOURCE;
        }

        /* copy the cap over to the remote entry */
        pNewLink->value = pCapLink->value;

        // If it's nonstandard, the above didn't work, so fix it up...
        lError = H245_ERROR_OK;
        switch (pCapLink->value.capability.choice)
        {
        case Capability_nonStandard_chosen:
          lError = CopyNonStandardParameter(&pNewLink->value.capability.u.Capability_nonStandard,
                                             &pCapLink->value.capability.u.Capability_nonStandard);
          break;

        case receiveVideoCapability_chosen:
        case transmitVideoCapability_chosen:
        case rcvAndTrnsmtVdCpblty_chosen:
          if (pCapLink->value.capability.u.receiveVideoCapability.choice == VdCpblty_nonStandard_chosen)
          {
            lError = CopyNonStandardParameter(&pNewLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard,
                                               &pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard);
          }
          break;

        case receiveAudioCapability_chosen:
        case transmitAudioCapability_chosen:
        case rcvAndTrnsmtAdCpblty_chosen:
          if (pCapLink->value.capability.u.receiveAudioCapability.choice == AdCpblty_nonStandard_chosen)
          {
            lError = CopyNonStandardParameter(&pNewLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard,
                                               &pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard);
          }
          break;

        case rcvDtApplctnCpblty_chosen:
        case trnsmtDtApplctnCpblty_chosen:
        case rATDACy_chosen :
          if (pCapLink->value.capability.u.rcvDtApplctnCpblty.application.choice == DACy_applctn_nnStndrd_chosen)
          {
            lError = CopyNonStandardParameter(&pNewLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd,
                                               &pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd);
          }
          break;

        } // switch
        if (lError != H245_ERROR_OK)
          return lError;
      } /* if capability_present */
    } /* if build_totcap_from_captbl succeeded */

    pCapLink = pCapLink->next;
  } /* for all entries in link */

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind__cap_desc
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 *****************************************************************************/

static HRESULT
process_term_cap_set_ind__cap_desc (struct InstanceStruct        *pInstance,
                                    struct TerminalCapabilitySet *pTermCapSet,
                                    CapabilityDescriptor         *pReqCapDesc,
                                    MltmdSystmCntrlMssg          *p_pdu_rsp)
{
  unsigned int                  uCapDescNumber;
  CapabilityDescriptor         *pCapDesc;
  unsigned int                  uCapDesc;
  SmltnsCpbltsLink              pSimCap;
  SmltnsCpbltsLink              pReqSimCap;
  CapabilityDescriptor          TempCapDesc;
  unsigned int                  uSimCount;
  unsigned int                  uReqAltCount;
  unsigned int                  uReqAltCap;
  unsigned int                  uAltCap;
  HRESULT                        lError = H245_ERROR_OK;

  uCapDescNumber = pReqCapDesc->capabilityDescriptorNumber & 255;
  H245TRACE(pInstance->dwInst,20,"API:process_term_cap_set_ind - Remote Capability Descriptor #%d", uCapDescNumber);

  // Find corresponding capability descriptor
  pCapDesc = NULL;
  for (uCapDesc = 0; uCapDesc < pTermCapSet->capabilityDescriptors.count; ++uCapDesc)
  {
    if (pTermCapSet->capabilityDescriptors.value[uCapDesc].capabilityDescriptorNumber == uCapDescNumber)
    {
      // Deallocate old simultaneous capabilities
      pCapDesc = &pTermCapSet->capabilityDescriptors.value[uCapDesc];
      if (pCapDesc->smltnsCpblts)
        dealloc_simultaneous_cap(pCapDesc);
      break;
    } // if
  } // for

  if (pCapDesc == NULL)
  {
    // Allocate a new terminal capability descriptor
    ASSERT(pTermCapSet->capabilityDescriptors.count < 256);
    pCapDesc = &pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count++];
  }

  ASSERT(pCapDesc->smltnsCpblts == NULL);
  if (!(pReqCapDesc->bit_mask & smltnsCpblts_present))
  {
    // Delete the terminal capability descriptor
    pTermCapSet->capabilityDescriptors.count--;
    *pCapDesc = pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count];
    return H245_ERROR_OK;
  }

  // Make a copy of the (volatile) new capability descriptor
  pCapDesc->bit_mask                   = 0;
  pCapDesc->capabilityDescriptorNumber = (CapabilityDescriptorNumber)uCapDescNumber;
  pCapDesc->smltnsCpblts               = NULL;

  // We copy the linked list to a temporary so that it
  // gets reversed twice and ends up in same order
  TempCapDesc.smltnsCpblts = NULL;
  uSimCount = 0;
  pReqSimCap = pReqCapDesc->smltnsCpblts;
  while (pReqSimCap)
  {
    // Allocate a new simultaneous capability list element
    pSimCap = MemAlloc(sizeof(*pSimCap));
    if (pSimCap == NULL)
    {
      H245TRACE(pInstance->dwInst, 1,
                "API:process_term_cap_set_ind: malloc failed");
      lError = H245_ERROR_NOMEM;
      break;
    }

    // Verify that each alternative capability in the request
    // simultaneous capability is valid
    // if so, copy it
    uAltCap = 0;
    uReqAltCount  = pReqSimCap->value.count;
    for (uReqAltCap = 0; uReqAltCap < uReqAltCount; ++uReqAltCap)
    {
      // Is the Capability in the remote Capability Table?
      if (find_capid_by_entrynumber (pTermCapSet, pReqSimCap->value.value[uReqAltCap]) == NULL)
      {
        // can't find the Capability
        H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - Remote Capability Table Entry #%d not found",
                  pReqSimCap->value.value[uReqAltCap]);
        lError = H245_ERROR_UNKNOWN;
      }
      else if (uAltCap >= H245_MAX_ALTCAPS)
      {
        // Exceeded arbitrary limit
        H245TRACE(pInstance->dwInst,1,
                  "API:process_term_cap_set_ind - Too many alternative capabilities (%d)",
                  uAltCap);
        lError = H245_ERROR_NORESOURCE;
        break;
      }
      else
      {
        // Copy the capability number
        pSimCap->value.value[uAltCap++] = pReqSimCap->value.value[uReqAltCap];
      }
    } /* for alternative capbilities */

    if (uAltCap)
    {
      // Verify that we have not exceeded arbitrary limit
      if (++uSimCount > H245_MAX_SIMCAPS)
      {
        // Exceeded arbitrary limit
        H245TRACE(pInstance->dwInst, 1,
                  "API:process_term_cap_set_ind - Too many simultaneous capabilities (%d)",
                  uSimCount);
        MemFree(pSimCap);
        lError = H245_ERROR_NORESOURCE;
      }
      else
      {
        // Add new simultaneous capability to the temporary list
        pSimCap->value.count = (unsigned short)uAltCap;
        pSimCap->next = TempCapDesc.smltnsCpblts;
        TempCapDesc.smltnsCpblts = pSimCap;
      }
    }
    else
    {
      H245TRACE(pInstance->dwInst, 1,
                "API:process_term_cap_set_ind - No valid alternative capabilities found");
      MemFree(pSimCap);
      lError = H245_ERROR_UNKNOWN;
    }

    pReqSimCap = pReqSimCap->next;
  } // while

  while (TempCapDesc.smltnsCpblts)
  {
    // Move elements from temporary to final linked list
    pSimCap = TempCapDesc.smltnsCpblts;
    TempCapDesc.smltnsCpblts = pSimCap->next;
    pSimCap->next = pCapDesc->smltnsCpblts;
    pCapDesc->smltnsCpblts = pSimCap;
  }

  // Error if no simultaneous capabilities found
  if (pCapDesc->smltnsCpblts)
  {
    pCapDesc->bit_mask |= smltnsCpblts_present;
  }
  else
  {
    H245TRACE(pInstance->dwInst, 1,
              "API:process_term_cap_set_ind - No simultaneous capabilities found");
    lError = H245_ERROR_UNKNOWN;
  }

  return lError;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind__mux_cap
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 * NOTES:
 *  We do a copy to set up a capability structure, then do another copy via
 *  H245CopyCap() to create a copy of the capability because the structure
 *  given to us by the ASN.1 decoded may contain pointers to data which will
 *  be deallocated upon return.
 *
 *****************************************************************************/
static HRESULT
process_term_cap_set_ind__mux_cap  (struct InstanceStruct        *pInstance,
                                    struct TerminalCapabilitySet *pTermCapSet,
                                    MultiplexCapability *        pReqMuxCap,
                                    MltmdSystmCntrlMssg          *p_pdu_rsp)
{
  H245_TOTCAP_T         TotCap;

  // Initialize temporary capability structure
  memset(&TotCap, 0, sizeof(TotCap));
  TotCap.Dir      = H245_CAPDIR_RMTRXTX;
  TotCap.DataType = H245_DATA_MUX;

  // Get rid of old remote multiplex capability, if any
  if (pTermCapSet->bit_mask & multiplexCapability_present)
  {
    del_mux_cap(pTermCapSet);
  }

  switch (pReqMuxCap->choice)
  {
  case MltplxCpblty_nonStandard_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_NONSTD = pReqMuxCap->u.MltplxCpblty_nonStandard;
    TotCap.ClientType = H245_CLIENT_MUX_NONSTD;
    H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind__mux_cap - Nonstandard Mux not yet supported");
    break;

  case h222Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_H222 = pReqMuxCap->u.h222Capability;
    TotCap.ClientType = H245_CLIENT_MUX_H222;
    break;

  case h223Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_H223 = pReqMuxCap->u.h223Capability;
    TotCap.ClientType = H245_CLIENT_MUX_H223;
    break;

  case v76Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_VGMUX = pReqMuxCap->u.v76Capability;
    TotCap.ClientType = H245_CLIENT_MUX_VGMUX;
    break;

  case h2250Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_H2250 = pReqMuxCap->u.h2250Capability;
    TotCap.ClientType = H245_CLIENT_MUX_H2250;
    break;

  default:
    H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind__mux_cap - invalid mux cap type %d",
              &pReqMuxCap->choice);
    return H245_ERROR_NOSUP;
  }

  return set_mux_cap(pInstance, pTermCapSet, &TotCap);
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind
 *
 * DESCRIPTION
 *
 **************************************************************
 *
 * (TBD) .. this module will ack all terminal capbilities
 *            need to build reject.. (maybe later??)
 *
 * THIS IS A BIG TBD
 *
 **************************************************************
 *
 * RETURN:
 *
 *****************************************************************************/
static HRESULT
process_term_cap_set_ind (struct InstanceStruct *pInstance,
                          MltmdSystmCntrlMssg   *p_pdu_req,
                          MltmdSystmCntrlMssg   *p_pdu_rsp)
{
  HRESULT                   lError = H245_ERROR_OK;
  TerminalCapabilitySet   *pTermCapSet;

  ASSERT (p_pdu_req->choice == MltmdSystmCntrlMssg_rqst_chosen);
  ASSERT (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.choice == terminalCapabilitySet_chosen);
  H245TRACE(pInstance->dwInst,10,"API:process_term_cap_set_ind <-");

  /* build ack response */
  p_pdu_rsp->choice = MSCMg_rspns_chosen;
  p_pdu_rsp->u.MSCMg_rspns.choice = terminalCapabilitySetAck_chosen;
  p_pdu_rsp->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber =
    p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber;

  pTermCapSet = &pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;

  //***************************
  // Deal with Capability Table
  //***************************
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.bit_mask & capabilityTable_present)
  {
	CapabilityTableLink pCapTable = p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable;
	if (pCapTable->value.capability.choice == Capability_nonStandard_chosen &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.choice == h221NonStandard_chosen &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35CountryCode	 == 0xB5 &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35Extension	 == 0x42 &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == 0x8080)
    {
	  pInstance->bMasterSlaveKludge = TRUE;
	  pCapTable = pCapTable->next;
    }
    lError = process_term_cap_set_ind__cap_table(pInstance,
                                                  pTermCapSet,
                                                  pCapTable,
                                                  p_pdu_rsp);
    if (lError != H245_ERROR_OK)
    {
      H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - cap table error %s",map_api_error(lError));
      /* (TBC) need to reject somehow */
    }
  } /* if Capability Table Present */

  //**************************************
  // Deal with Capability Descriptor Table
  // i.e. simultaneous capabilities
  // NOTE: these are not held in the remote terminal capbility set
  //**************************************
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.bit_mask & capabilityDescriptors_present)
  {
    int des_cnt;
    int ii;

    des_cnt = p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityDescriptors.count;
    H245TRACE(pInstance->dwInst,20,"API:process_term_cap_set_ind - %d Simultaneous Capabilities",des_cnt);
    for (ii = 0; ii < des_cnt; ++ii)
    {
      lError = process_term_cap_set_ind__cap_desc (pInstance,
                                                    pTermCapSet,
                                                    &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.
                                                      terminalCapabilitySet.capabilityDescriptors.value[ii],
                                                    p_pdu_rsp);
      if (lError != H245_ERROR_OK)
      {
        H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - cap desc error %s",map_api_error(lError));
        /* (TBC) need to reject somehow */
      }
    } /* for each descriptor */
  } /* if capability descriptor present */

  /**************************************/
  /* Deal with Multiplex Capability set */
  /**************************************/
  /* NOTE: these are not held in the remote terminal capability set */
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.bit_mask & multiplexCapability_present)
  {
    /* send up the indication to the client for each new entry */
    lError = process_term_cap_set_ind__mux_cap(pInstance,
                                                pTermCapSet,
                                                &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.
                                                  terminalCapabilitySet.multiplexCapability,
                                                p_pdu_rsp);
    if (lError != H245_ERROR_OK)
    {
      H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - mux cap error %s",map_api_error(lError));
      /* (TBC) need to reject somehow */
    }
  }

  H245TRACE(pInstance->dwInst,10,"API:process_term_cap_set_ind -> OK");
  return H245_ERROR_OK;
}



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_open_ind
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 * ASSUME:
 *              Callback must happen inside this routine since the
 *              datastructures passed back to the application are allocated
 *              in this moudle.
 *
 *              Application will <<<COPY>>> the needed data structures when
 *              callback occurs..
 *
 *****************************************************************************/

static HRESULT
process_open_ind (struct InstanceStruct *pInstance,
                  MltmdSystmCntrlMssg   *p_pdu_req,
                  unsigned short        *p_FwdChan,     /* for return on error */
                  H245_ACC_REJ_T        *p_AccRej,      /* for return error */
                  H245_CONF_IND_T       *p_conf_ind)    /* out */
{
  static H245_TOTCAP_T          rx_totcap;      /* for receive caps */
  static H245_TOTCAP_T          tx_totcap;      /* for transmit caps */
  static H245_MUX_T             RxMux;
  static H245_MUX_T             TxMux;
  unsigned short                choice;         /* tmp for type of cap to routine */
  HRESULT                       lError;
  Tracker_T                     *p_tracker;

  H245TRACE(pInstance->dwInst,10,"API:process_open_ind <-");

  *p_AccRej = H245_ACC;

  /********************************/
  /* check for forward parameters */
  /********************************/

  /* get forward Rx channel id */
  p_conf_ind->u.Indication.u.IndOpen.RxChannel =
    *p_FwdChan =
      p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelNumber;

  H245TRACE(pInstance->dwInst,20,"API:process_open_ind - channel = %d",p_conf_ind->u.Indication.u.IndOpen.RxChannel);

  /* get port number */
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
        u.openLogicalChannel.forwardLogicalChannelParameters.bit_mask & fLCPs_prtNmbr_present)
    {
      p_conf_ind->u.Indication.u.IndOpen.RxPort =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.fLCPs_prtNmbr;
    }
  else
    p_conf_ind->u.Indication.u.IndOpen.RxPort = H245_INVALID_PORT_NUMBER;

  /* ok.. forward data type selection */
  switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.dataType.choice)
    {
    case DataType_nonStandard_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx nonStandard");
      /* (TBD) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return H245_ERROR_NOSUP;
    case nullData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx nullData");
      /* (TBD) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return H245_ERROR_NOSUP;
      break;
    case DataType_videoData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx videoData");
      p_conf_ind->u.Indication.u.IndOpen.RxDataType = H245_DATA_VIDEO;
      choice =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.dataType.
            u.DataType_videoData.choice;
      break;
    case DataType_audioData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx audioData");
      p_conf_ind->u.Indication.u.IndOpen.RxDataType = H245_DATA_AUDIO;
      choice =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.dataType.
            u.DataType_audioData.choice;
      break;
    case DataType_data_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx dataData");
      p_conf_ind->u.Indication.u.IndOpen.RxDataType = H245_DATA_DATA;
      choice =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.dataType.
            u.DataType_data.application.choice;
      break;
    case encryptionData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx encryptionData");
      /* (TBC) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return H245_ERROR_NOSUP;
      break;
    default:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx encryptionData");
      /* (TBC) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_UNKNOWN;
      return H245_ERROR_NOSUP;
      break;
    }

  /* load the tot cap's capability and client from capability                   */
  /* this will give us the client type and the Capability for the indication    */
  if ((lError = build_totcap_cap_n_client_from_capability ((struct Capability *)
                          &(p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                            u.openLogicalChannel.forwardLogicalChannelParameters.dataType),
                          p_conf_ind->u.Indication.u.IndOpen.RxDataType,
                          choice,
                          &rx_totcap)) != H245_ERROR_OK)
    {
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return lError;
    }

  /* load it from the totcap you just built.. then toss it aside.. like an empty can of soda.. */
  p_conf_ind->u.Indication.u.IndOpen.RxClientType = rx_totcap.ClientType;
  p_conf_ind->u.Indication.u.IndOpen.pRxCap = &(rx_totcap.Cap);

  /* H.223/H.222 Mux table parameters for forward channel */
  p_conf_ind->u.Indication.u.IndOpen.pRxMux = &RxMux;
  switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.choice)
    {
    case fLCPs_mPs_h223LCPs_chosen:
      /* H.223 Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_H223;
      lError = load_H223_param(&RxMux.u.H223,
                              &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h223LCPs);
      if (lError != H245_ERROR_OK)
        {
          *p_AccRej = H245_REJ_AL_COMB;
          return lError;
        }
      break;

    case fLCPs_mPs_h222LCPs_chosen:
      /* H.222 Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_H222;
      lError = load_H222_param(&RxMux.u.H222,
                              &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h222LCPs);
      break;

    case fLCPs_mPs_v76LCPs_chosen:
      /* VGMUX Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_VGMUX;
      lError =load_VGMUX_param(&RxMux.u.VGMUX,
                              &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_v76LCPs);
      break;

    case fLCPs_mPs_h2250LCPs_chosen:
      /* H.225.0 Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_H2250;
      lError = load_H2250_param(&RxMux.u.H2250,
                               &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h2250LCPs);
      break;

    default:
      lError = H245_ERROR_NOSUP;
    } // switch
  if (lError != H245_ERROR_OK)
    {
      *p_AccRej = H245_REJ;
      return lError;
    }

  /********************************/
  /* check for reverse parameters */
  /********************************/
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)
    {
      switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.choice)
        {
        case DataType_nonStandard_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx nonStandard");
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return H245_ERROR_NOSUP;

        case nullData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx nullData");
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return H245_ERROR_NOSUP;
          break;

        case DataType_videoData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx videoData");
          p_conf_ind->u.Indication.u.IndOpen.TxDataType = H245_DATA_VIDEO;
          choice =
            p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.u.DataType_videoData.choice;
          break;

        case DataType_audioData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx audioData");
          p_conf_ind->u.Indication.u.IndOpen.TxDataType = H245_DATA_AUDIO;
          choice =
            p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.u.DataType_audioData.choice;
          break;

        case DataType_data_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx dataData");
          p_conf_ind->u.Indication.u.IndOpen.TxDataType = H245_DATA_DATA;
          choice =
            p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.u.DataType_data.application.choice;
          break;

        case encryptionData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx encryptionData");
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return H245_ERROR_NOSUP;
          break;

        default:
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_UNKNOWN;
          H245TRACE(pInstance->dwInst,1,"API:process_open_ind - unknown choice %d",
                    p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.choice);
          return H245_ERROR_NOSUP;
        }

      /* load the tot cap's capability and client from capability */
      if ((lError = build_totcap_cap_n_client_from_capability ((struct Capability *)
                                      &(p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                                        u.openLogicalChannel.OLCl_rLCPs.dataType),
                                      p_conf_ind->u.Indication.u.IndOpen.TxDataType,
                                      choice,
                                      &tx_totcap)) != H245_ERROR_OK)
        {
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return lError;
        }

      p_conf_ind->u.Indication.u.IndOpen.TxClientType = tx_totcap.ClientType;
      p_conf_ind->u.Indication.u.IndOpen.pTxCap = &(tx_totcap.Cap);

      /* if H223/H222 Mux table parameters for reverse channel availalbe */
      if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.OLCl_rLCPs.bit_mask & OLCl_rLCPs_mltplxPrmtrs_present)
        {
          switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                  u.openLogicalChannel.OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice)
            {
            case rLCPs_mPs_h223LCPs_chosen:
              p_conf_ind->u.Indication.u.IndOpen.pTxMux = &TxMux;
              p_conf_ind->u.Indication.u.IndOpen.pTxMux->Kind = H245_H223;
              lError = load_H223_param(&TxMux.u.H223,
                                      &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.
                                        OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h223LCPs);
              if (lError != H245_ERROR_OK)
                {
                  *p_AccRej = H245_REJ_AL_COMB;
                  return H245_ERROR_NOSUP;
                }
              break;

            case rLCPs_mPs_v76LCPs_chosen:
              p_conf_ind->u.Indication.u.IndOpen.pTxMux = &TxMux;
              p_conf_ind->u.Indication.u.IndOpen.pTxMux->Kind = H245_VGMUX;
              lError = load_VGMUX_param(&TxMux.u.VGMUX,
                                       &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.
                                         OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_v76LCPs);
              break;

            case rLCPs_mPs_h2250LCPs_chosen:
              p_conf_ind->u.Indication.u.IndOpen.pTxMux = &TxMux;
              p_conf_ind->u.Indication.u.IndOpen.pTxMux->Kind = H245_H2250;
              lError = load_H2250_param(&TxMux.u.H2250,
                                       &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.
                                         OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h2250LCPs);
              break;

            default:
              lError = H245_ERROR_NOSUP;
            }
            if (lError != H245_ERROR_OK)
              {
                *p_AccRej = H245_REJ;
                return lError;
              }
        } /* if H223/H222 mux table reverse parameters */

    } /* if reverse parameters present */

    if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OpnLgclChnnl_sprtStck_present)
    {
      p_conf_ind->u.Indication.u.IndOpen.pSeparateStack =
        &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OpnLgclChnnl_sprtStck;
    }


  /* conflict resolution .. just do it now.. */
  /* only on opens.. of same data type ..    */

#if 0
#ifndef LOOPBACK
  /* if master */
  if (pInstance->API.MasterSlave == APIMS_Master)
    {
      p_tracker = NULL;
      while (p_tracker = find_tracker_by_type (dwInst, API_OPEN_CHANNEL_T, p_tracker))
        {
          /* if allocated locally .. and incoming */
          /* data type == outstanding incoming    */
          /* there is a conflict                      */

          if ((p_tracker->u.Channel.ChannelAlloc == API_CH_ALLOC_LCL) &&
              (p_tracker->u.Channel.DataType == p_conf_ind->u.Indication.u.IndOpen.RxDataType))
            {
              *p_AccRej = H245_REJ;
              return H245_ERROR_INVALID_OP;

            } /* if conflict */

        } /* while */

    } /* if master */

#endif /* LOOPBACK */
#endif
  /* setup a tracker for this guy. */
  p_tracker = alloc_link_tracker (pInstance,
                                  API_OPEN_CHANNEL_T,
                                  0,
                                  API_ST_WAIT_LCLACK,
                                  API_CH_ALLOC_RMT,
                                  (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                                   u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)?API_CH_TYPE_BI:API_CH_TYPE_UNI,
                                  p_conf_ind->u.Indication.u.IndOpen.RxDataType,
                                  H245_INVALID_CHANNEL,
                                  p_conf_ind->u.Indication.u.IndOpen.RxChannel,
                                  0);

  if (!(p_tracker))
    {
      H245TRACE(pInstance->dwInst,1,"API:process_open_ind -> %s",map_api_error(H245_ERROR_NOMEM));
      *p_AccRej = H245_REJ;
      return H245_ERROR_NOMEM;
    }

  H245TRACE(pInstance->dwInst,10,"API:process_open_ind -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_bi_open_rsp
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 * ASSUME:
 *              Callback must happen inside this routine since the
 *              datastructures passed back to the application are allocated
 *              in this moudle.
 *
 *              Application will <<<COPY>>> the needed data structures when
 *              callback occurs..
 *
 *****************************************************************************/

static HRESULT
process_bi_open_rsp (struct InstanceStruct *     pInstance,     /* in */
                     MltmdSystmCntrlMssg        *p_pdu_rsp,     /* in */
                     H245_MUX_T                 *p_RxMux,       /* in  */
                     DWORD                      *p_RxChannel,   /* out */
                     H245_CONF_IND_T            *p_conf_ind     /* out */
                     )
{
  H245TRACE(pInstance->dwInst,10,"API:process_bi_open_rsp <-");

  p_conf_ind->u.Confirm.Error = H245_ERROR_OK;

  // Get Reverse Logical Channel Number
  *p_RxChannel =
    p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.RxChannel =
      p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.reverseLogicalChannelNumber;

  // Get Reverse Port Number
  if (p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.bit_mask & rLCPs_prtNmbr_present)
    {
      p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.RxPort =
        p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.rLCPs_prtNmbr;
    }

  if (p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.bit_mask & OLCAk_rLCPs_mPs_present)
    {
      // Get Reverse Logical Channel ACK Parameters
      switch (p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice)
       {
       case rLCPs_mPs_h222LCPs_chosen:
         p_RxMux->Kind = H245_H222;
         p_conf_ind->u.Confirm.Error = load_H222_param(&p_RxMux->u.H222,
           &p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.u.rLCPs_mPs_h222LCPs);
         p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.pRxMux = p_RxMux;
         break;

       case mPs_h2250LgclChnnlPrmtrs_chosen:
         p_RxMux->Kind = H245_H2250ACK;
         p_conf_ind->u.Confirm.Error = load_H2250_param(&p_RxMux->u.H2250,
           &p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.u. mPs_h2250LgclChnnlPrmtrs);
         p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.pRxMux = p_RxMux;
         break;

       default:
          H245TRACE(pInstance->dwInst,1,"API:process_bi_open_rsp - unknown choice %d",
                    p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice);
          p_conf_ind->u.Confirm.Error = H245_ERROR_NOSUP;
       } // switch
    }

  H245TRACE(pInstance->dwInst,10,"API:process_bi_open_rsp -> OK");
  return H245_ERROR_OK;
}

WORD awObject[64];

unsigned int ArrayFromObject(WORD *pwObject, unsigned uSize, POBJECTID pObject)
{
  register unsigned int uLength = 0;
  while (pObject)
  {
    if (uLength >= uSize)
    {
           H245TRACE(0,1,"API:ArrayFromObject Object ID too long");
      return uLength;
    }
    pwObject[uLength++] = (WORD) pObject->value;
    pObject = pObject->next;
  }
  return uLength;
} // ArrayFromObject()

/*****************************************************************************
 *
 * TYPE:        Callback
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 *****************************************************************************/

static Tracker_T *
TrackerValidate(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:ValidateTracker -> Tracker Not Found");
    return NULL;
  }

  return pTracker;
}

static DWORD_PTR
TranslateTransId(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateTransId -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateTransId -> Tracker Not Found");
    return 0;
  }

  return pTracker->TransId;
}

static void
TrackerFree(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerFree -> NULL Tracker");
    return;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerFree -> Tracker Not Found");
    return;
  }
  unlink_dealloc_tracker (pInstance, pTracker);
}

static DWORD_PTR
TranslateAndFree(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateAndFree -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateAndFree -> Tracker Not Found");
    return 0;
  }
  dwTransId = pTracker->TransId;
  unlink_dealloc_tracker (pInstance, pTracker);
  return dwTransId;
}

static void
TrackerNewState(struct InstanceStruct *pInstance, DWORD_PTR dwTransId, int nNewState)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerNewState -> NULL Tracker");
    return;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerNewState -> Tracker Not Found");
    return;
  }
  pTracker->State = nNewState;
}

static WORD
GetRxChannel(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetRxChannel -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetRxChannel -> Tracker Not Found");
    return 0;
  }

  return (WORD)pTracker->u.Channel.RxChannel;
}

static WORD
GetTxChannel(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetTxChannel -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetTxChannel -> Tracker Not Found");
    return 0;
  }

  return (WORD)pTracker->u.Channel.TxChannel;
}

H245FunctionNotUnderstood(struct InstanceStruct *pInstance, PDU_T *pPdu)
{
    MltmdSystmCntrlMssg Pdu = {0};

    Pdu.choice = indication_chosen;
    Pdu.u.indication.choice = functionNotUnderstood_chosen;
    Pdu.u.indication.u.functionNotUnderstood.choice = pPdu->choice;
    switch (pPdu->choice)
    {
    case FnctnNtUndrstd_request_chosen:
        Pdu.u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_request =
            pPdu->u.MltmdSystmCntrlMssg_rqst;
        break;

    case FnctnNtUndrstd_response_chosen:
        Pdu.u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_response =
            pPdu->u.MSCMg_rspns;
        break;

    case FnctnNtUndrstd_command_chosen:
        Pdu.u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_command =
            pPdu->u.MSCMg_cmmnd;
    default:
        return H245_ERROR_OK;
    }
    return sendPDU(pInstance, &Pdu);
} // H245FunctionNotUnderstood()

HRESULT
H245FsmConfirm    (PDU_t *                  pPdu,
                   DWORD                    dwEvent,
                   struct InstanceStruct *  pInstance,
                   DWORD_PTR                dwTransId,
                   HRESULT                  lError)
{
  H245_CONF_IND_T               ConfInd;
  DWORD                         dwIndex;
  H245_MUX_T                    TxMux;
  H245_MUX_T                    RxMux;
  HRESULT                       lResult = H245_ERROR_OK;

  ASSERT(pInstance != NULL);
  ASSERT(pInstance->API.ConfIndCallBack != NULL);
  H245TRACE(pInstance->dwInst,4,"H245FsmConfirm <- Event=%s (%d)",
            map_fsm_event(dwEvent),dwEvent);

  memset (&ConfInd, 0, sizeof(ConfInd));
  ConfInd.Kind = H245_CONF;
  ConfInd.u.Confirm.Confirm = dwEvent;
  ConfInd.u.Confirm.dwPreserved = pInstance->API.dwPreserved;
  ConfInd.u.Confirm.dwTransId = dwTransId;
  ConfInd.u.Confirm.Error = lError;

  switch (dwEvent)
  {
    /******************************/
    /*                            */
    /* master slave determination */
    /*                            */
    /******************************/
  case  H245_CONF_INIT_MSTSLV:
    ConfInd.u.Confirm.dwTransId = TranslateAndFree(pInstance, dwTransId);

    /* handle errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == mstrSlvDtrmntnAck_chosen);
        pInstance->API.SystemState     = APIST_Connected;
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == master_chosen)
          {
            pInstance->API.MasterSlave = APIMS_Master;
            ConfInd.u.Confirm.u.ConfMstSlv = H245_MASTER;
          }
        else
          {
            pInstance->API.MasterSlave = APIMS_Slave;
            ConfInd.u.Confirm.u.ConfMstSlv = H245_SLAVE;
          }
        break;

      case REJECT:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Master Slave Reject");
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfMstSlv = H245_INDETERMINATE;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfMstSlv = H245_INDETERMINATE;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
//      case MS_FAILED:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Master Slave Error %d", lError);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfMstSlv = H245_INDETERMINATE;
        break;
      }
    break;

    /****************************************/
    /*                                      */
    /* Terminal Capability exchange confirm */
    /*                                      */
    /****************************************/
  case  H245_CONF_SEND_TERMCAP:
    ConfInd.u.Confirm.dwTransId = TranslateAndFree(pInstance, dwTransId);

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == terminalCapabilitySetAck_chosen);
        ConfInd.u.Confirm.u.ConfSndTcap.AccRej = H245_ACC;
        clean_cap_table(&pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
        break;

      case REJECT:
        ConfInd.u.Confirm.Error = H245_ERROR_OK;
        ConfInd.u.Confirm.u.ConfSndTcap.AccRej = H245_REJ;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Term Cap Error %d", lError);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        break;
      }
    break;

    /***************************************/
    /*                                     */
    /* unidirectional logical channel open */
    /*                                     */
    /***************************************/
  case  H245_CONF_OPEN:
    ConfInd.u.Confirm.dwTransId = TranslateTransId(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfOpen.TxChannel = GetTxChannel(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfOpen.RxPort = H245_INVALID_PORT_NUMBER;

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == openLogicalChannelAck_chosen);
        ASSERT((pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present) == 0);

        if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_sprtStck_present)
        {
          ConfInd.u.Confirm.u.ConfOpen.pSeparateStack =
            &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_sprtStck;
        }

        if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & frwrdMltplxAckPrmtrs_present)
        {
          switch (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.choice)
            {
            case h2250LgclChnnlAckPrmtrs_chosen:
              TxMux.Kind = H245_H2250ACK;
              load_H2250ACK_param(&TxMux.u.H2250ACK,
                                  &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.u.h2250LgclChnnlAckPrmtrs);
              ConfInd.u.Confirm.u.ConfOpen.pTxMux = &TxMux;
              break;

            } // switch
        }

        ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_ACC;
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        break;

      case REJECT:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == openLogicalChannelReject_chosen);

        ConfInd.u.Confirm.Error             = H245_ERROR_OK;
        ConfInd.u.Confirm.u.ConfOpen.AccRej =
          pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.cause.choice;
        TrackerFree(pInstance,dwTransId);
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error             = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
        TrackerFree(pInstance,dwTransId);
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Open Channel Error %d", lError);
        ConfInd.u.Confirm.Error             = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
        TrackerFree(pInstance,dwTransId);
      }
    break;

    /***********************************************/
    /*                                             */
    /* bidirectional logical channel open (TBD)??? */
    /*                                             */
    /***********************************************/
  case  H245_CONF_NEEDRSP_OPEN:
    {
      Tracker_T *pTracker;

      pTracker = TrackerValidate(pInstance, dwTransId);
      if (pTracker == NULL)
        return H245_ERROR_OK;

      ConfInd.u.Confirm.dwTransId = pTracker->TransId;
      ConfInd.u.Confirm.u.ConfOpenNeedRsp.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
      ConfInd.u.Confirm.u.ConfOpenNeedRsp.RxPort = H245_INVALID_PORT_NUMBER;

      /* determine errors */
      switch (lError)
        {
        case H245_ERROR_OK:
          ASSERT(pPdu != NULL);
          ASSERT(pPdu->choice == MSCMg_rspns_chosen);
          ASSERT(pPdu->u.MSCMg_rspns.choice == openLogicalChannelAck_chosen);
          ASSERT((pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present) != 0);

          ConfInd.u.Confirm.u.ConfOpenNeedRsp.AccRej = H245_ACC;

          if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_sprtStck_present)
          {
            ConfInd.u.Confirm.u.ConfOpenNeedRsp.pSeparateStack =
              &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_sprtStck;
          }

          if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & frwrdMltplxAckPrmtrs_present)
          {
            switch (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.choice)
              {
              case h2250LgclChnnlAckPrmtrs_chosen:
                TxMux.Kind = H245_H2250ACK;
                load_H2250ACK_param(&TxMux.u.H2250ACK,
                                    &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.u.h2250LgclChnnlAckPrmtrs);
                ConfInd.u.Confirm.u.ConfOpenNeedRsp.pTxMux = &TxMux;
                break;

              } // switch
          }

          /* NOTE Receive Channel is assigned  in this call */
          process_bi_open_rsp (pInstance,
                          pPdu,
                          &RxMux,
                          &(pTracker->u.Channel.RxChannel),
                          &ConfInd);

          /* NOTE: this is a special case since we have to assign   */
          /* the receive channel to the tracker.. otherwise we      */
          /* will not be able to find it later..                    */
          /* Here we have to update both the state, and the channel */
          pTracker->State = API_ST_WAIT_CONF;
          break;

        case REJECT:
          ConfInd.u.Confirm.Confirm = H245_CONF_OPEN;
          ConfInd.u.Confirm.u.ConfOpen.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
          ConfInd.u.Confirm.Error             = H245_ERROR_OK;
          ConfInd.u.Confirm.u.ConfOpen.AccRej =
            pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.cause.choice;
          unlink_dealloc_tracker (pInstance, pTracker);
          break;

        case TIMER_EXPIRY:
        case ERROR_D_TIMEOUT:
        case ERROR_F_TIMEOUT:
          ConfInd.u.Confirm.Confirm = H245_CONF_OPEN;
          ConfInd.u.Confirm.u.ConfOpen.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
          ConfInd.u.Confirm.Error             = H245_ERROR_TIMEOUT;
          ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
          unlink_dealloc_tracker (pInstance, pTracker);
          break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
        default:
          H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Open Channel Error %d", lError);
          ConfInd.u.Confirm.Confirm = H245_CONF_OPEN;
          ConfInd.u.Confirm.u.ConfOpen.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
          ConfInd.u.Confirm.Error             = H245_ERROR_UNKNOWN;
          ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
          unlink_dealloc_tracker (pInstance, pTracker);
      }
    }
    break;

    /************************************************/
    /*                                              */
    /* unidirectional logical channel close         */
    /*                                              */
    /* bidirection logical channel close            */
    /*                                              */
    /************************************************/
  case  H245_CONF_CLOSE:
    ConfInd.u.Confirm.dwTransId = TranslateTransId(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfClose.Channel = GetTxChannel(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfClose.AccRej = H245_ACC;

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == closeLogicalChannelAck_chosen);
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_ACC;
        TrackerFree(pInstance,dwTransId);
        break;

      case REJECT:
        /* should never be rejected */
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Close Channel Rejected");
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_REJ;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_REJ;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Close Channel Error %d", lError);
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_REJ;
      }
    break;

    /***************************/
    /*                         */
    /* request channel close   */
    /*                         */
    /***************************/
  case  H245_CONF_REQ_CLOSE:
    ConfInd.u.Confirm.dwTransId = TranslateTransId(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfReqClose.Channel = GetRxChannel(pInstance, dwTransId);
    TrackerNewState(pInstance,dwTransId,API_ST_IDLE);

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == requestChannelCloseAck_chosen);
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_ACC;
        break;

      case REJECT:
        ConfInd.u.Confirm.Error = H245_ERROR_OK;
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_REJ;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_REJ;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Request Channel Close Error %d", lError);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_REJ;
      }
    break;

    /*******************/
    /*                 */
    /* mux table entry */
    /*                 */
    /*******************/
  case  H245_CONF_MUXTBL_SND:
    {
      UINT ii;
      Tracker_T *pTracker;

      pTracker = TrackerValidate(pInstance, dwTransId);
      if (pTracker == NULL)
        return H245_ERROR_OK;

      ConfInd.u.Confirm.dwTransId = pTracker->TransId;

      switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == multiplexEntrySendAck_chosen);
        for (ii = 0;
             ii < pPdu->u.MSCMg_rspns.u.multiplexEntrySendAck.multiplexTableEntryNumber.count;
             ii ++)
        {
          pTracker->u.MuxEntryCount--;
          ConfInd.u.Confirm.u.ConfMuxSnd.MuxEntryId =
            pPdu->u.MSCMg_rspns.u.multiplexEntrySendAck.multiplexTableEntryNumber.value[ii];
          ConfInd.u.Confirm.u.ConfMuxSnd.AccRej = H245_ACC;

          if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MSCMg_rspns.u.multiplexEntrySendAck) == H245_ERROR_NOSUP)
          {
            H245FunctionNotUnderstood(pInstance, pPdu);
          }
          pTracker = TrackerValidate(pInstance, dwTransId);
          if (pTracker == NULL)
            return H245_ERROR_OK;
        }
        if (pTracker->u.MuxEntryCount == 0)
        {
          unlink_dealloc_tracker (pInstance, pTracker);
        }
        pPdu = NULL;                    // Don't do callback again!
        break;

      case REJECT:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == multiplexEntrySendReject_chosen);
        ConfInd.u.Confirm.Error = H245_ERROR_OK;
        for (ii = 0;
             ii < pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject.rejectionDescriptions.count;
             ++ii)
        {
          pTracker->u.MuxEntryCount--;
          ConfInd.u.Confirm.u.ConfMuxSnd.MuxEntryId =
            pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject.rejectionDescriptions.value[ii].multiplexTableEntryNumber;

          switch (pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject.rejectionDescriptions.value[ii].cause.choice)
          {
          default:
            H245PANIC();
          case MERDs_cs_unspcfdCs_chosen:
            ConfInd.u.Confirm.u.ConfMuxSnd.AccRej = H245_REJ; /* unspecified */
            break;
          case descriptorTooComplex_chosen:
            ConfInd.u.Confirm.u.ConfMuxSnd.AccRej = H245_REJ_MUX_COMPLICATED;
            break;
          }

          if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject) == H245_ERROR_NOSUP)
          {
            H245FunctionNotUnderstood(pInstance, pPdu);
          }
          pTracker = TrackerValidate(pInstance, dwTransId);
          if (pTracker == NULL)
            return H245_ERROR_OK;
        }
        if (pTracker->u.MuxEntryCount == 0)
        {
          unlink_dealloc_tracker (pInstance, pTracker);
        }
        pPdu = NULL;                    // Don't do callback again!
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        unlink_dealloc_tracker (pInstance, pTracker);
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Mux Table Send Error %d", lError);
        unlink_dealloc_tracker (pInstance, pTracker);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
      } // switch
    }
    break;

  case  H245_CONF_RMESE:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == requestMultiplexEntryAck_chosen);
    ConfInd.u.Confirm.u.ConfRmese.dwCount =
      pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.count;
    for (dwIndex = 0; dwIndex < ConfInd.u.Confirm.u.ConfRmese.dwCount; ++dwIndex)
    {
      ConfInd.u.Confirm.u.ConfRmese.awMultiplexTableEntryNumbers[dwIndex] =
        pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.value[dwIndex];
    }
    break;

  case  H245_CONF_RMESE_REJECT:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == rqstMltplxEntryRjct_chosen);
    ConfInd.u.Confirm.u.ConfRmeseReject.dwCount =
      pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.count;
    for (dwIndex = 0; dwIndex < ConfInd.u.Confirm.u.ConfRmeseReject.dwCount; ++dwIndex)
    {
      ConfInd.u.Confirm.u.ConfRmeseReject.awMultiplexTableEntryNumbers[dwIndex] =
        pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.value[dwIndex].multiplexTableEntryNumber;
    }
    break;

  case  H245_CONF_RMESE_EXPIRED:
    ASSERT(pPdu == NULL);
    break;

  case  H245_CONF_MRSE:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == requestModeAck_chosen);
    ConfInd.u.Confirm.u.ConfMrse =
      pPdu->u.MSCMg_rspns.u.requestModeAck.response.choice;
    break;

  case  H245_CONF_MRSE_REJECT:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == requestModeReject_chosen);
    ConfInd.u.Confirm.u.ConfMrseReject =
      pPdu->u.MSCMg_rspns.u.requestModeReject.cause.choice;
    break;

  case  H245_CONF_MRSE_EXPIRED:
    ASSERT(pPdu == NULL);
    break;

  case  H245_CONF_MLSE:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == maintenanceLoopAck_chosen);
    ConfInd.u.Confirm.u.ConfMlse.LoopType =
      pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice;
    switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice)
    {
    case systemLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlse.Channel = 0;
      break;

    case mediaLoop_chosen:
    case logicalChannelLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlse.Channel =
        pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop;
      break;

    default:
      H245TRACE(pInstance->dwInst,1,
                "H245FsmConfirm: Invalid Maintenance Loop Ack type %d",
                pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_CONF_MLSE_REJECT:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == maintenanceLoopReject_chosen);
    ConfInd.u.Confirm.u.ConfMlseReject.LoopType =
      pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice;
    switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice)
    {
    case systemLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlseReject.Channel = 0;
      break;

    case mediaLoop_chosen:
    case logicalChannelLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlseReject.Channel =
        pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop;
      break;

    default:
      H245TRACE(pInstance->dwInst,1,
                "H245FsmConfirm: Invalid Maintenance Loop Reject type %d",
                pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_CONF_MLSE_EXPIRED:
    ASSERT(pPdu == NULL);
    break;

  case  H245_CONF_RTDSE:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == roundTripDelayResponse_chosen);
    break;

  case  H245_CONF_RTDSE_EXPIRED:
    ASSERT(pPdu == NULL);
    break;

  default:
    /* Possible Error */
    H245TRACE(pInstance->dwInst, 1,
              "H245FsmConfirm -> Invalid Confirm Event %d",
              dwEvent);
    return H245_ERROR_SUBSYS;
  } // switch

  if (lResult == H245_ERROR_OK)
  {
    if (pPdu)
    {
      if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MSCMg_rspns.u) == H245_ERROR_NOSUP)
      {
        H245FunctionNotUnderstood(pInstance, pPdu);
      }
    }
    else
    {
      (*pInstance->API.ConfIndCallBack)(&ConfInd, NULL);
    }
    H245TRACE(pInstance->dwInst,4,"H245FsmConfirm -> OK");
  }
  else
  {
    H245TRACE(pInstance->dwInst,1,"H245FsmConfirm -> %s", map_api_error(lResult));
  }
  return lResult;
} // H245FsmConfirm()



HRESULT
H245FsmIndication (PDU_t *                  pPdu,
                   DWORD                    dwEvent,
                   struct InstanceStruct *  pInstance,
                   DWORD_PTR                dwTransId,
                   HRESULT                  lError)
{
  H245_CONF_IND_T               ConfInd;
  DWORD                         dwIndex;
  MltmdSystmCntrlMssg          *pRsp;
  HRESULT                       lResult = H245_ERROR_OK;
#if 1
  int                           nLength;
  WCHAR *                       pwchar = NULL;
#endif

  ASSERT(dwEvent == H245_IND_OPEN_CONF || pPdu != NULL);
  ASSERT(pInstance != NULL);
  ASSERT(pInstance->API.ConfIndCallBack != NULL);
  H245TRACE(pInstance->dwInst,4,"H245FsmIndication <- Event=%s (%d)",
            map_fsm_event(dwEvent),dwEvent);

  memset (&ConfInd, 0, sizeof(ConfInd));
  ConfInd.Kind = H245_IND;
  ConfInd.u.Indication.Indicator = dwEvent;
  ConfInd.u.Indication.dwPreserved = pInstance->API.dwPreserved;

  switch (dwEvent)
  {
    /******************************/
    /*                            */
    /* master slave determination */
    /*                            */
    /******************************/
  case  H245_IND_MSTSLV:

    /* handle errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == mstrSlvDtrmntnAck_chosen);

        pInstance->API.SystemState = APIST_Connected;
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == master_chosen)
        {
          pInstance->API.MasterSlave = APIMS_Master;
          ConfInd.u.Indication.u.IndMstSlv = H245_MASTER;
        }
        else
        {
          pInstance->API.MasterSlave = APIMS_Slave;
          ConfInd.u.Indication.u.IndMstSlv = H245_SLAVE;
        }
        break;

      case MS_FAILED:
      case REJECT:
      case TIMER_EXPIRY:
        ConfInd.u.Indication.u.IndMstSlv = H245_INDETERMINATE;
        break;

//      case ERROR_D_TIMEOUT:
//      case ERROR_F_TIMEOUT:
//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245PANIC();
        /* (TBC) */
        return H245_ERROR_OK;
      }
    break;

    /****************************************/
    /*                                      */
    /* Terminal Capability exchange         */
    /*                                      */
    /****************************************/
    /* decode_termcapset breaks the termcap set up and sends up     */
    /* a single indication to the client */
  case  H245_IND_CAP:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == terminalCapabilitySet_chosen);
    pRsp = (PDU_t *)MemAlloc(sizeof(*pPdu));
    if (pRsp == NULL)
    {
      H245TRACE(pInstance->dwInst,1,"H245FsmIndication TermCap: no memory for response");
      return H245_ERROR_NOMEM;
    }
    memset(pRsp, 0, sizeof(*pRsp));
    process_term_cap_set_ind (pInstance, pPdu, pRsp);
    FsmOutgoing(pInstance, pRsp, 0);
    MemFree (pRsp);
    break;

  case  H245_IND_CESE_RELEASE:
    break;

    /************************************************/
    /*                                              */
    /* unidirectional logical channel open          */
    /*                                              */
    /* bidirectional  logical channel open          */
    /*                                              */
    /************************************************/
  case  H245_IND_OPEN:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == openLogicalChannel_chosen);
    {
      unsigned short  forward_channel;
      H245_ACC_REJ_T  acc_rej;

      /* if error, process_open_ind will tell us what to send for reject */
      if (process_open_ind(pInstance,pPdu,&forward_channel,&acc_rej,&ConfInd) != H245_ERROR_OK)
      {
        // Reject the open
        pRsp = (PDU_t *)MemAlloc(sizeof(*pPdu));
        if (pRsp == NULL)
        {
          H245TRACE(pInstance->dwInst,1,"H245FsmIndication TermCap: no memory for response");
          return H245_ERROR_NOMEM;
        }
        memset(pRsp, 0, sizeof(*pRsp));
        pdu_rsp_open_logical_channel_rej(pRsp, forward_channel, (WORD)acc_rej);
        FsmOutgoing(pInstance, pRsp, 0);
        MemFree (pRsp);
      }
    }
    break;

    /************************************************/
    /*                                              */
    /* Confirm bi-directional open                  */
    /*                                              */
    /************************************************/
  case  H245_IND_OPEN_CONF:
#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      ASSERT(pPdu != NULL);
      ASSERT(pPdu->choice == indication_chosen);
      ASSERT(pPdu->u.indication.choice == opnLgclChnnlCnfrm_chosen);
    }
#endif
    {
      Tracker_T *pTracker;

      pTracker = TrackerValidate(pInstance, dwTransId);
      if (pTracker == NULL)
        return H245_ERROR_OK;

      /* confirm processing */
      ASSERT(pTracker->State == API_ST_WAIT_CONF);
      ASSERT(pTracker->TrackerType == API_OPEN_CHANNEL_T);
      ASSERT(pTracker->u.Channel.ChannelAlloc == API_CH_ALLOC_RMT);
      ASSERT(pTracker->u.Channel.ChannelType == API_CH_TYPE_BI);

      ConfInd.u.Indication.u.IndOpenConf.RxChannel = (WORD)pTracker->u.Channel.RxChannel;
      ConfInd.u.Indication.u.IndOpenConf.TxChannel = (WORD)pTracker->u.Channel.TxChannel;

      pTracker->State = API_ST_IDLE;
    }
    break;

    /************************************************/
    /*                                              */
    /* unidirectional logical channel close         */
    /*                                              */
    /* bidirectional  logical channel close         */
    /*                                              */
    /************************************************/
  case  H245_IND_CLOSE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == closeLogicalChannel_chosen);
    {
      Tracker_T *pTracker;

      ConfInd.u.Indication.u.IndClose.Channel =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber;
      ConfInd.u.Indication.u.IndClose.Reason =
        (pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.source.choice==user_chosen)?H245_USER:H245_LCSE;

      /* find the tracker */
      pTracker = find_tracker_by_rxchannel (pInstance,
                                           ConfInd.u.Indication.u.IndClose.Channel,
                                           API_CH_ALLOC_RMT);
      if (!pTracker)
        {
          H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> close indication - Tracker not found");
          return H245_ERROR_OK;
        }

      unlink_dealloc_tracker (pInstance, pTracker);
    }
    break;

    /************************************************/
    /*                                              */
    /* request channel close                        */
    /*                                              */
    /************************************************/
  case  H245_IND_REQ_CLOSE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == requestChannelClose_chosen);
    {
      Tracker_T *pTracker;

      ConfInd.u.Indication.u.IndReqClose =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestChannelClose.forwardLogicalChannelNumber;

      /* find the tracker */
      pTracker = find_tracker_by_txchannel (pInstance,
                                           ConfInd.u.Indication.u.IndReqClose,
                                           API_CH_ALLOC_LCL);
      if (!pTracker)
        {
          H245TRACE(pInstance->dwInst,4,"H245FsmIndication Request Channel Close: Tracker not found");

          pRsp = (PDU_t *)MemAlloc(sizeof(*pPdu));
          if (pRsp == NULL)
          {
            H245TRACE(pInstance->dwInst,1,"H245FsmIndication Request Channel Close: no memory for response");
            return H245_ERROR_NOMEM;
          }
          memset(pRsp, 0, sizeof(*pRsp));

          /* can't find it.. must be closed.. respond anyway */
          pdu_rsp_request_channel_close_rej(pRsp, (WORD)ConfInd.u.Indication.u.IndReqClose,H245_REJ);
          FsmOutgoing(pInstance, pRsp, 0);
          MemFree(pRsp);
          /* Possible Error.. could have been removed from list or    */
          /* could have been allocated remotely... and this is a protocol */
          /* error                                                    */
          return H245_ERROR_OK;
        }

      ASSERT(pTracker->State == API_ST_IDLE);
      pTracker->State = API_ST_WAIT_LCLACK;
      pTracker->TrackerType = API_CLOSE_CHANNEL_T;
    }
    break;

    /************************************************/
    /*                                              */
    /* Release Close Request                        */
    /*                                              */
    /************************************************/
  case  H245_IND_CLCSE_RELEASE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == rqstChnnlClsRls_chosen);
    {
      Tracker_T *pTracker;

      /* find tracker.. and set to LCLACK_CANCEL */
      /* this will tell api to notify user       */

      pTracker = find_tracker_by_txchannel (pInstance,
                                           pPdu->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber,
                                           API_CH_ALLOC_LCL);
      if (pTracker)
        {
          if (pTracker->State != API_ST_WAIT_LCLACK)
            {
              return H245_ERROR_INVALID_INST;
            }

          pTracker->State = API_ST_WAIT_LCLACK_CANCEL;
        }
      else
        {
          H245TRACE(pInstance->dwInst,1,"H245FsmIndication -> IND_REL_CLSE: Cancel.. NO TRACKER FOUND");
        }
    }
    break;

    /************************************************/
    /*                                              */
    /* mux table entry                              */
    /*                                              */
    /************************************************/
  case  H245_IND_MUX_TBL:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == multiplexEntrySend_chosen);
    {
      unsigned short          seq_num;
      H245_ACC_REJ_MUX_T      rej_mux;
      H245_MUX_TABLE_T       *p_mux_tbl;
      DWORD                   rej_cnt;
      DWORD                   acc_cnt;
      Tracker_T              *pTracker;

      /* process the mux table entry */
      p_mux_tbl = process_mux_table_ind(pPdu,&seq_num,rej_mux,&rej_cnt,&acc_cnt);

      if (rej_cnt)
        {
          /* build the reject pdu from the rej_mux table */
          if (!(pRsp = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
            return H245_ERROR_NOMEM;
          memset(pRsp, 0, sizeof(MltmdSystmCntrlMssg));

          pdu_rsp_mux_table_rej (pRsp,seq_num,rej_mux,(rej_cnt+acc_cnt));
          FsmOutgoing(pInstance, pRsp, 0);
          MemFree(pRsp);
        }

      /* if there are any left to send up. */
      if (p_mux_tbl)
        {
          if (!(pTracker = alloc_link_tracker (pInstance,
                                                API_RECV_MUX_T,
                                                /* use the TransId.. for the sequence number */
                                                seq_num,
                                                API_ST_WAIT_LCLACK,
                                                API_CH_ALLOC_UNDEF,
                                                API_CH_TYPE_UNDEF,
                                                0,
                                                H245_INVALID_CHANNEL, H245_INVALID_CHANNEL,
                                                0)))
            {
              free_mux_table_list (p_mux_tbl);
              H245TRACE(pInstance->dwInst,1,"API:process_open_ind -> %s",map_api_error(H245_ERROR_NOMEM));
              /* (TBC) this should be a fatal error */
              H245PANIC();
              break;
            }

          pTracker->u.MuxEntryCount = acc_cnt;
          ConfInd.u.Indication.u.IndMuxTbl.Count   = acc_cnt;
          ConfInd.u.Indication.u.IndMuxTbl.pMuxTbl = p_mux_tbl;
          if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
          {
            H245FunctionNotUnderstood(pInstance, pPdu);
          }
          free_mux_table_list (p_mux_tbl);
          return H245_ERROR_OK;
        }
    }
    break;

  case  H245_IND_MTSE_RELEASE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == mltplxEntrySndRls_chosen);
    break;

  case  H245_IND_RMESE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == requestMultiplexEntry_chosen);
    ConfInd.u.Indication.u.IndRmese.dwCount =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.count;
    for (dwIndex = 0; dwIndex < ConfInd.u.Indication.u.IndRmese.dwCount; ++dwIndex)
    {
      ConfInd.u.Indication.u.IndRmese.awMultiplexTableEntryNumbers[dwIndex] =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.value[dwIndex];
    }
    break;

  case  H245_IND_RMESE_RELEASE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == rqstMltplxEntryRls_chosen);
    break;

  case  H245_IND_MRSE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == requestMode_chosen);
    ConfInd.u.Indication.u.IndMrse.pRequestedModes =
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.requestedModes;
    break;

  case  H245_IND_MRSE_RELEASE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == requestModeRelease_chosen);
    break;

  case  H245_IND_MLSE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == maintenanceLoopRequest_chosen);
    ConfInd.u.Indication.u.IndMlse.LoopType =
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;
    if (ConfInd.u.Indication.u.IndMlse.LoopType == systemLoop_chosen)
      ConfInd.u.Indication.u.IndMlse.Channel = 0;
    else
      ConfInd.u.Indication.u.IndMlse.Channel =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop;
    break;

  case  H245_IND_MLSE_RELEASE:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == mntnncLpOffCmmnd_chosen);
    break;

  case  H245_IND_NONSTANDARD_REQUEST:
  case  H245_IND_NONSTANDARD_RESPONSE:
  case  H245_IND_NONSTANDARD_COMMAND:
  case  H245_IND_NONSTANDARD:
    ConfInd.u.Indication.u.IndNonstandard.pData        = pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.value;
    ConfInd.u.Indication.u.IndNonstandard.dwDataLength = pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.length;
    switch (pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice)
    {
    case object_chosen:
      ConfInd.u.Indication.u.IndNonstandard.pwObjectId        = awObject;
      ConfInd.u.Indication.u.IndNonstandard.dwObjectIdLength  =
        ArrayFromObject(&awObject[0], sizeof(awObject)/sizeof(awObject[0]),
          pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.object);
      ConfInd.u.Indication.u.IndNonstandard.byCountryCode     = 0;
      ConfInd.u.Indication.u.IndNonstandard.byExtension       = 0;
      ConfInd.u.Indication.u.IndNonstandard.wManufacturerCode = 0;
      break;

    case h221NonStandard_chosen:
      ConfInd.u.Indication.u.IndNonstandard.pwObjectId        = NULL;
      ConfInd.u.Indication.u.IndNonstandard.dwObjectIdLength  = 0;
      ConfInd.u.Indication.u.IndNonstandard.byCountryCode     = (BYTE)
        pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35CountryCode;
      ConfInd.u.Indication.u.IndNonstandard.byExtension       = (BYTE)
        pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35Extension;
      ConfInd.u.Indication.u.IndNonstandard.wManufacturerCode =
        pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
      break;

    default:
      H245TRACE(pInstance->dwInst,1,
                "H245FsmIndication: unrecognized nonstandard identifier type %d",
                pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_MISC_COMMAND:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice  == miscellaneousCommand_chosen);
    break;

  case  H245_IND_MISC:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == miscellaneousIndication_chosen);
    break;

  case  H245_IND_COMM_MODE_REQUEST:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == communicationModeRequest_chosen);
    break;

  case  H245_IND_COMM_MODE_RESPONSE:
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == cmmnctnMdRspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.choice == communicationModeTable_chosen);
    {
      unsigned int                uCount;
      CommunicationModeTableLink  pLink;
      H245_COMM_MODE_ENTRY_T *    pTable;

      uCount = 0;
      pLink = pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.u.communicationModeTable;
      while (pLink)
      {
        ++uCount;
        pLink = pLink->next;
      }

      pTable = MemAlloc(uCount * sizeof(*pTable));
      if (pTable)
      {
        ConfInd.u.Indication.u.IndCommRsp.pTable       = pTable;
        ConfInd.u.Indication.u.IndCommRsp.byTableCount = (BYTE)uCount;
        pLink = pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.u.communicationModeTable;
        while (pLink)
        {
          lResult = LoadCommModeEntry(pTable, &pLink->value);
          if (lResult != H245_ERROR_OK)
          {
            MemFree(pTable);
            return lResult;
          }
          ++pTable;
          pLink = pLink->next;
        }
        if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
        {
          H245FunctionNotUnderstood(pInstance, pPdu);
        }
        MemFree(pTable);
        H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> OK");
        return H245_ERROR_OK;
      }

      lResult = H245_ERROR_NOMEM;
    }
    break;

  case  H245_IND_COMM_MODE_COMMAND:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == communicationModeCommand_chosen);
    {
      unsigned int                  uCount;
      CommunicationModeCommandLink  pLink;
      H245_COMM_MODE_ENTRY_T *      pTable;

      uCount = 0;
      pLink = pPdu->u.MSCMg_cmmnd.u.communicationModeCommand.communicationModeTable;
      while (pLink)
      {
        ++uCount;
        pLink = pLink->next;
      }

      pTable = MemAlloc(uCount * sizeof(*pTable));
      if (pTable)
      {
        ConfInd.u.Indication.u.IndCommCmd.pTable       = pTable;
        ConfInd.u.Indication.u.IndCommCmd.byTableCount = (BYTE)uCount;
        pLink = pPdu->u.MSCMg_cmmnd.u.communicationModeCommand.communicationModeTable;
        while (pLink)
        {
          lResult = LoadCommModeEntry(pTable, &pLink->value);
          if (lResult != H245_ERROR_OK)
          {
            MemFree(pTable);
            return lResult;
          }
          ++pTable;
          pLink = pLink->next;
        }
      {
        H245FunctionNotUnderstood(pInstance, pPdu);
      }
        if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
        {
          H245FunctionNotUnderstood(pInstance, pPdu);
        }
        MemFree(pTable);
        H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> OK");
        return H245_ERROR_OK;
      }

      lResult = H245_ERROR_NOMEM;
    }
    break;

  case  H245_IND_CONFERENCE_REQUEST:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == conferenceRequest_chosen);
    ConfInd.u.Indication.u.IndConferReq.RequestType =
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.choice;
    ConfInd.u.Indication.u.IndConferReq.byMcuNumber = (BYTE)
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.mcuNumber;
    ConfInd.u.Indication.u.IndConferReq.byTerminalNumber = (BYTE)
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.terminalNumber;
    break;

  case  H245_IND_CONFERENCE_RESPONSE:
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == conferenceResponse_chosen);
    ConfInd.u.Indication.u.IndConferRsp.ResponseType =
      pPdu->u.MSCMg_rspns.u.conferenceResponse.choice;
    switch (pPdu->u.MSCMg_rspns.u.conferenceResponse.choice)
    {
    case mCTerminalIDResponse_chosen:
    case terminalIDResponse_chosen:
    case conferenceIDResponse_chosen:
    case passwordResponse_chosen:
      ConfInd.u.Indication.u.IndConferRsp.byMcuNumber = (BYTE)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.mcuNumber;
      ConfInd.u.Indication.u.IndConferRsp.byTerminalNumber = (BYTE)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.terminalNumber;
      ConfInd.u.Indication.u.IndConferRsp.pOctetString =
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.value;
      ConfInd.u.Indication.u.IndConferRsp.byOctetStringLength = (BYTE)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.length;
      break;

    case terminalListResponse_chosen:
      ConfInd.u.Indication.u.IndConferRsp.pTerminalList =
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.value;
      ConfInd.u.Indication.u.IndConferRsp.wTerminalListCount = (WORD)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.count;
      break;

    case videoCommandReject_chosen:
    case terminalDropReject_chosen:
      break;

    case makeMeChairResponse_chosen:
      switch (pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice)
      {
      case grantedChairToken_chosen:
        ConfInd.u.Indication.u.IndConferRsp.ResponseType = H245_RSP_GRANTED_CHAIR_TOKEN;
        break;

      default:
        H245TRACE(pInstance->dwInst, 1,
                  "H245FsmIndication: Invalid make me chair response %d",
                  pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice);

      // Fall-through to next case

      case deniedChairToken_chosen:
        ConfInd.u.Indication.u.IndConferRsp.ResponseType = H245_RSP_DENIED_CHAIR_TOKEN;
      } // switch
      break;

    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid Conference Response type %d",
                pPdu->u.MSCMg_rspns.u.conferenceResponse.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_CONFERENCE_COMMAND:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == conferenceCommand_chosen);
    ConfInd.u.Indication.u.IndConferCmd.CommandType =
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.choice;
    ConfInd.u.Indication.u.IndConferCmd.Channel =
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.brdcstMyLgclChnnl;
    ConfInd.u.Indication.u.IndConferCmd.byMcuNumber = (BYTE)
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.sendThisSource.mcuNumber;
    ConfInd.u.Indication.u.IndConferCmd.byTerminalNumber = (BYTE)
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.sendThisSource.terminalNumber;
    break;

  case  H245_IND_CONFERENCE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == conferenceIndication_chosen);
    ConfInd.u.Indication.u.IndConfer.IndicationType =
      pPdu->u.indication.u.conferenceIndication.choice;
    ConfInd.u.Indication.u.IndConfer.bySbeNumber = (BYTE)
      pPdu->u.indication.u.conferenceIndication.u.sbeNumber;
    ConfInd.u.Indication.u.IndConfer.byMcuNumber = (BYTE)
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.mcuNumber;
    ConfInd.u.Indication.u.IndConfer.byTerminalNumber = (BYTE)
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.terminalNumber;
    break;

  case  H245_IND_SEND_TERMCAP:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == sndTrmnlCpbltySt_chosen);
    break;

  case  H245_IND_ENCRYPTION:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == encryptionCommand_chosen);
    break;

  case  H245_IND_FLOW_CONTROL:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == flowControlCommand_chosen);
    ConfInd.u.Indication.u.IndFlowControl.Scope =
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.choice;
    switch (pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.choice)
    {
    case FCCd_scp_lgclChnnlNmbr_chosen:
      ConfInd.u.Indication.u.IndFlowControl.Channel =
        pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FCCd_scp_lgclChnnlNmbr;
      break;

    case FlwCntrlCmmnd_scp_rsrcID_chosen:
      ConfInd.u.Indication.u.IndFlowControl.wResourceID =
        pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FlwCntrlCmmnd_scp_rsrcID;
      break;

    case FCCd_scp_whlMltplx_chosen:
      break;

    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid Flow Control restriction %d",
                pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    switch (pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice)
    {
    case maximumBitRate_chosen:
      ConfInd.u.Indication.u.IndFlowControl.dwRestriction =
        pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.u.maximumBitRate;
      break;

    case noRestriction_chosen:
      ConfInd.u.Indication.u.IndFlowControl.dwRestriction = H245_NO_RESTRICTION;
      break;

    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid Flow Control restriction %d",
                pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_ENDSESSION:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice  == endSessionCommand_chosen);
    ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_DISCONNECT;
    switch (pPdu->u.MSCMg_cmmnd.u.endSessionCommand.choice)
    {
    case EndSssnCmmnd_nonStandard_chosen:
     ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_NONSTD,
     ConfInd.u.Indication.u.IndEndSession.SessionNonStd =
       pPdu->u.MSCMg_cmmnd.u.endSessionCommand.u.EndSssnCmmnd_nonStandard;
      break;
    case disconnect_chosen:
      break;
    case gstnOptions_chosen:
      switch (pPdu->u.MSCMg_cmmnd.u.endSessionCommand.u.gstnOptions.choice)
      {
      case EndSessionCommand_gstnOptions_telephonyMode_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_TELEPHONY;
        break;
      case v8bis_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V8BIS;
        break;
      case v34DSVD_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V34DSVD;
        break;
      case v34DuplexFAX_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V34DUPFAX;
        break;
      case v34H324_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V34H324;
        break;
      default:
        H245TRACE(pInstance->dwInst, 1,
                  "H245FsmIndication: Invalid End Session GSTN options %d",
                  pPdu->u.MSCMg_cmmnd.u.endSessionCommand.u.gstnOptions.choice);
      } // switch
      break;
    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid End Session type %d",
                pPdu->u.MSCMg_cmmnd.u.endSessionCommand.choice);
    } // switch
    break;

  case  H245_IND_FUNCTION_NOT_UNDERSTOOD:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == functionNotUnderstood_chosen);
    break;

  case  H245_IND_JITTER:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == jitterIndication_chosen);
    break;

  case  H245_IND_H223_SKEW:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == h223SkewIndication_chosen);
    ConfInd.u.Indication.u.IndH223Skew.LogicalChannelNumber1 =
      pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber1;
    ConfInd.u.Indication.u.IndH223Skew.LogicalChannelNumber2 =
      pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber2;
    ConfInd.u.Indication.u.IndH223Skew.wSkew =
      pPdu->u.indication.u.h223SkewIndication.skew;
    break;

  case  H245_IND_NEW_ATM_VC:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == newATMVCIndication_chosen);
    break;

  case  H245_IND_USERINPUT:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == userInput_chosen);
    ConfInd.u.Indication.u.IndUserInput.Kind =
      pPdu->u.indication.u.userInput.choice;
    switch (pPdu->u.indication.u.userInput.choice)
    {
    case UsrInptIndctn_nnStndrd_chosen:
      ConfInd.u.Indication.u.IndUserInput.u.NonStd =
        pPdu->u.indication.u.userInput.u.UsrInptIndctn_nnStndrd;
      break;
    case alphanumeric_chosen:
#if 1
      nLength = MultiByteToWideChar(CP_ACP,             // code page
                                    0,                  // dwFlags
                                    pPdu->u.indication.u.userInput.u.alphanumeric,
                                    -1,                 // ASCII string length (in bytes)
                                    NULL,               // Unicode string
                                    0);                 // max Unicode string length
      pwchar = MemAlloc(nLength * sizeof(WCHAR));
      if (pwchar == NULL)
      {
        H245TRACE(pInstance->dwInst, 1,
                  "H245FsmIndication: no memory for user input", 0);
        lResult = H245_ERROR_NOMEM;
      }
      else
      {
        nLength = MultiByteToWideChar(CP_ACP,             // code page
                                      0,                  // dwFlags
                                      pPdu->u.indication.u.userInput.u.alphanumeric,
                                      -1,                 // ASCII string length (in bytes)
                                      pwchar,             // Unicode string
                                      nLength);           // max Unicode string length
        ConfInd.u.Indication.u.IndUserInput.u.pGenString = pwchar;
      }
#else
      ConfInd.u.Indication.u.IndUserInput.u.pGenString =
        pPdu->u.indication.u.userInput.u.alphanumeric;
#endif
      break;
    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: unrecognized user input type %d",
                pPdu->u.indication.u.userInput.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_H2250_MAX_SKEW:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == h2250MxmmSkwIndctn_chosen);
    ConfInd.u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber1 =
      pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber1;
    ConfInd.u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber2 =
      pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber2;
    ConfInd.u.Indication.u.IndH2250MaxSkew.wSkew =
      pPdu->u.indication.u.h2250MxmmSkwIndctn.maximumSkew;
    break;

  case  H245_IND_MC_LOCATION:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == mcLocationIndication_chosen);
    lResult = LoadTransportAddress(&ConfInd.u.Indication.u.IndMcLocation,
                                  &pPdu->u.indication.u.mcLocationIndication.signalAddress);
    break;

  case  H245_IND_VENDOR_ID:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == vendorIdentification_chosen);
    ConfInd.u.Indication.u.IndVendorId.Identifier =
      pPdu->u.indication.u.vendorIdentification.vendor;
    if (pPdu->u.indication.u.vendorIdentification.bit_mask & productNumber_present)
    {
      ConfInd.u.Indication.u.IndVendorId.pProductNumber =
        pPdu->u.indication.u.vendorIdentification.productNumber.value;
      ConfInd.u.Indication.u.IndVendorId.byProductNumberLength = (BYTE)
        pPdu->u.indication.u.vendorIdentification.productNumber.length;
    }
    if (pPdu->u.indication.u.vendorIdentification.bit_mask & versionNumber_present)
    {
      ConfInd.u.Indication.u.IndVendorId.pVersionNumber =
        pPdu->u.indication.u.vendorIdentification.versionNumber.value;
      ConfInd.u.Indication.u.IndVendorId.byVersionNumberLength = (BYTE)
        pPdu->u.indication.u.vendorIdentification.versionNumber.length;
    }
    break;

  case  H245_IND_FUNCTION_NOT_SUPPORTED:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == IndicationMessage_functionNotSupported_chosen);
    ConfInd.u.Indication.u.IndFns.Cause =
      pPdu->u.indication.u.functionNotSupported.cause.choice;
    ConfInd.u.Indication.u.IndFns.Type = UNKNOWN;

    /*if (pPdu->u.indication.u.functionNotSupported.bit_mask & returnedFunction_present)
    {
      int                  pduNum = MltmdSystmCntrlMssg_PDU;
      OssBuf               ossBuf;
      MltmdSystmCntrlMssg *pPduReturned;
      ossBuf.value  = pPdu->u.indication.u.functionNotSupported.returnedFunction.value;
      ossBuf.length = pPdu->u.indication.u.functionNotSupported.returnedFunction.length;
      if (ossDecode(pInstance->p_ossWorld,
                    &pduNum,
                    &ossBuf,
                    (void * *)&pPduReturned) == PDU_DECODED)
      {
        switch (pPduReturned->choice)
        {
        case MltmdSystmCntrlMssg_rqst_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.MltmdSystmCntrlMssg_rqst.choice -
            RqstMssg_nonStandard_chosen + REQ_NONSTANDARD;
          break;
        case MSCMg_rspns_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.MSCMg_rspns.choice -
            RspnsMssg_nonStandard_chosen + RSP_NONSTANDARD;
          break;
        case MSCMg_cmmnd_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.MSCMg_cmmnd.choice -
            CmmndMssg_nonStandard_chosen + CMD_NONSTANDARD;
          break;
        case indication_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.indication.choice -
            IndctnMssg_nonStandard_chosen + IND_NONSTANDARD;
          break;
        default:
          H245TRACE(pInstance->dwInst, 1,
                    "H245FsmIndication: unrecognized FunctionNotSupported message type %d",
                    pPduReturned->choice);
          lResult = H245_ERROR_NOSUP;
        } // switch
        // Free the PDU
        if (ossFreePDU(pInstance->p_ossWorld, pduNum, pPduReturned))
        {
          H245TRACE(pInstance->dwInst, 1, "H245FsmIndication: FREE FAILURE");
        }
      }
    }
    */
    break;
#if(0) // this isn't in H245 Version 3. and this code did nothing with it anyway
  case  H245_IND_H223_RECONFIG:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == h223AnnxARcnfgrtn_chosen);
    break;

  case  H245_IND_H223_RECONFIG_ACK:
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == h223AnnxARcnfgrtnAck_chosen);
    break;

  case  H245_IND_H223_RECONFIG_REJECT:
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == h223AnnxARcnfgrtnRjct_chosen);
    break;
#endif // if(0)
  default:
    /* Possible Error */
    H245TRACE(pInstance->dwInst, 1,
              "H245FsmIndication -> Invalid Indication Event %d", dwEvent);
    lResult = H245_ERROR_SUBSYS;
  } // switch

#if 1
  if (pwchar)
    MemFree(pwchar);
#endif

  if (lResult == H245_ERROR_OK)
  {
    if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
    {
      H245FunctionNotUnderstood(pInstance, pPdu);
    }
    H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> OK");
  }
  else
  {
    H245TRACE(pInstance->dwInst,1,"H245FsmIndication -> %s", map_api_error(lResult));
  }
  return lResult;
} // H245FsmIndication()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\api.h ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				
 *									
 *   This listing is supplied under the terms of a license agreement	
 *   with INTEL Corporation and may not be used, copied, nor disclosed	
 *   except in accordance with the terms of that agreement.		
 *
 *****************************************************************************/

/******************************************************************************
 *									
 *  $Workfile:   api.h  $
 *  $Revision:   1.5  $
 *  $Modtime:   06 Jun 1996 17:10:36  $
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/api.h_v  $	
 *
 *    Rev 1.5   06 Jun 1996 18:43:08   EHOWARDX
 * Unnested tracker structure and eliminated PLOCK macros.
 *
 *    Rev 1.4   29 May 1996 15:20:40   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.3   20 May 1996 14:31:54   EHOWARDX
 * Got rid of asynchronous EndSession/Shutdown stuff.
 *
 *    Rev 1.2   16 May 1996 15:55:56   EHOWARDX
 * Replaced LocalSequenceNum with LocalCapDescIdNum.
 *
 *    Rev 1.1   13 May 1996 23:15:46   EHOWARDX
 * Fixed remote termcap handling.
 *
 *    Rev 1.0   09 May 1996 21:04:42   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.17   09 May 1996 19:38:20   EHOWARDX
 * Redesigned locking logic and added new functionality.
 *
 *    Rev 1.16   15 Apr 1996 15:58:14   cjutzi
 *
 * - added phase2 back
 *
 *    Rev 1.15   15 Apr 1996 13:59:42   cjutzi
 *
 * - added conflict resolution
 *  needed to change the api data structure to keep track of the
 *   outstanding data type..
 *
 *
 *    Rev 1.13   01 Apr 1996 16:50:48   cjutzi
 *
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 *
 *    Rev 1.12   26 Mar 1996 09:49:08   cjutzi
 *
 * - ok.. Added Enter&Leave&Init&Delete Critical Sections for Ring 0
 *
 *    Rev 1.11   13 Mar 1996 14:11:38   cjutzi
 *
 * - removed trace message from PLOCK and VLOCK
 * d
 *
 *    Rev 1.10   13 Mar 1996 09:14:06   cjutzi
 * - changed LPCRITICAL SECTION to CRITICAL_SECITON *
 *
 *    Rev 1.9   12 Mar 1996 15:49:08   cjutzi
 *
 * - added locking
 *
 *    Rev 1.8   08 Mar 1996 14:08:02   cjutzi
 *
 * - added MuxCapsSet and MuxTable stuff for tracking..
 *
 *    Rev 1.7   05 Mar 1996 09:55:08   cjutzi
 *
 * - added mux table stuff
 *
 *    Rev 1.6   01 Mar 1996 13:47:26   cjutzi
 *
 * - added a state to Tracker for release indications from fsm
 *
 *    Rev 1.5   15 Feb 1996 10:48:00   cjutzi
 * - added some structs to API
 * - added some defines for API
 *
 *    Rev 1.4   09 Feb 1996 16:43:06   cjutzi
 *
 * - added some states
 * - added some tracker types
 *  $Ident$
 *
 *****************************************************************************/

#ifndef _API_H
#define _API_H

/********************************************************/
/*		api Decl				*/
/********************************************************/
#include <h245api.h>		/* Instance and TypeDefs  */
#include <h245sys.x>		/* critical section stuff */
#include <h245asn1.h>		/* for TermCaps		  */

/* STATES */


#define TRANSMIT 		0
#define RECEIVE			1

#define H245_LOCAL 		2
#define H245_REMOTE		3

/* from api_util.c */
HRESULT api_init   (struct InstanceStruct *pInstance);
HRESULT api_deinit (struct InstanceStruct *pInstance);

typedef struct H245_LINK_T
{
  struct H245_LINK_T 	*p_next;
} H245_LINK_T;

typedef
enum {
  API_TERMCAP_T = 0,
  API_OPEN_CHANNEL_T,
  API_CLOSE_CHANNEL_T,
  API_MSTSLV_T,
  API_SEND_MUX_T,
  API_RECV_MUX_T,

} API_TRACKER_T;


typedef
enum {
  API_ST_WAIT_RMTACK = 0x10,		/* waiting for remote ask	*/
  API_ST_WAIT_LCLACK,			/* waiting for local ack 	*/
  API_ST_WAIT_LCLACK_CANCEL,		/* request was canceled.. 	*/
  API_ST_WAIT_CONF,			/* waiting for open confirm (bi only) */
  API_ST_IDLE				/* for open only 		*/

} API_TRACKER_STATE_T;


typedef
enum {
  API_CH_ALLOC_UNDEF = 0x20,
  API_CH_ALLOC_LCL,
  API_CH_ALLOC_RMT
} API_TRACKER_CH_ALLOC_T;

typedef
enum {
  API_CH_TYPE_UNDEF = 0x030,
  API_CH_TYPE_UNI,
  API_CH_TYPE_BI
} API_TRACKER_CH_T;


/* Tracker Structure */
typedef struct
{
  API_TRACKER_CH_ALLOC_T  ChannelAlloc;	/* who allocated the channel 	   */
  API_TRACKER_CH_T	  ChannelType; 	/* either bi or uni 		   */
  DWORD			  TxChannel;	/* for bi&uni-directional channel  */
  DWORD			  RxChannel;	/* for bi-directional channel only */
  H245_CLIENT_T		  DataType;	/* data type used for conflict     */
    					/* detection 			   */
} TrackerChannelStruct;

typedef union
{
  /*
  API_OPEN_CHANNEL_T,
  API_CLOSE_CHANNEL_T,
  */
  TrackerChannelStruct  Channel;

  /*
  API_SEND_MUX_T,
  API_RECV_MUX_T,
  */
  DWORD			MuxEntryCount;

  /* don't care */
  /*
  API_MSTSLV_T,
  API_TERMCAP_T
  */
} TrackerUnion;

typedef struct TrackerStruct
{
  struct TrackerStruct 	*p_next;
  struct TrackerStruct	*p_prev;
  DWORD_PTR 		TransId;
  API_TRACKER_STATE_T	State;
  API_TRACKER_T		TrackerType;
  TrackerUnion          u;
} Tracker_T;

/* API Structure */
typedef struct
{
  enum {
    APIMS_Undef,
    APIMS_InProcess,
    APIMS_Master,
    APIMS_Slave
  }				 MasterSlave;	 /* master or slave or inprocess */
  enum {
    APIST_Undef,
    APIST_Inited,
    APIST_Connecting,
    APIST_Connected,
    APIST_Disconnected
  }				 SystemState;	 /* */

  DWORD				 MuxCapsSet;
  DWORD_PTR  		 dwPreserved;
  H245_CONF_IND_CALLBACK_T	 ConfIndCallBack;/* callback for H245 Client	*/

  H245_CAPID_T                   LocalCapIdNum;
  H245_CAPDESCID_T      	 LocalCapDescIdNum;

  MltmdSystmCntrlMssg		 PDU_LocalTermCap;
  MltmdSystmCntrlMssg		 PDU_RemoteTermCap;
#define TERMCAPSET u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet
  Tracker_T			*pTracker;
} API_STRUCT_T;

#endif // _API_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\api_debu.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   api_Debu.c  $
 *  $Revision:   1.4  $
 *  $Modtime:   10 Jun 1996 12:36:08  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/api_Debu.c_v  $
 * 
 *    Rev 1.4   10 Jun 1996 16:53:06   EHOWARDX
 * Eliminated #include "h245init.x"
 * 
 *    Rev 1.3   06 Jun 1996 18:51:14   EHOWARDX
 * Made tracker dump more aesthetically pleasing.
 *
 *    Rev 1.2   28 May 1996 14:25:36   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   20 May 1996 14:34:42   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.0   09 May 1996 21:06:06   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.7   09 May 1996 19:30:24   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.6   02 Apr 1996 10:14:08   cjutzi
 * - changed tracker structure
 *
 *    Rev 1.5   11 Mar 1996 14:28:48   cjutzi
 *
 * - removed oil debug include
 * d
 *
 *    Rev 1.4   06 Mar 1996 12:33:46   cjutzi
 * - renamed API_MUX_T to API_SEND_MUX_T
 *
 *    Rev 1.3   16 Feb 1996 13:00:30   cjutzi
 *
 * - added tracker dumper
 *
 *    Rev 1.2   15 Feb 1996 15:42:52   cjutzi
 *
 * - std.h and wtypes.h modified.. al'a Loren..
 *
 *    Rev 1.1   09 Feb 1996 16:58:08   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *  $Ident$
 *
 *****************************************************************************/

#ifndef STRICT 
#define STRICT 
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"

/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   dump_tracker
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/

void
dump_tracker(struct InstanceStruct *pInstance)
{
  register Tracker_T *p_tracker;
  register char      *p_str;

  ASSERT (pInstance != NULL);
  H245TRACE(pInstance->dwInst, 0, "************ TRACKER DUMP START ********");

  for (p_tracker = pInstance->API.pTracker; p_tracker; p_tracker = p_tracker->p_next)
    {
      if (p_tracker != pInstance->API.pTracker)
        H245TRACE(pInstance->dwInst, 0, "");
      H245TRACE(pInstance->dwInst, 0, "TransId           %04d(0x%04x)",p_tracker->TransId,p_tracker->TransId);
      switch (p_tracker->TrackerType)
        {
        case API_TERMCAP_T:             p_str="API_TERMCAP_T";      break;
        case API_OPEN_CHANNEL_T:        p_str="API_OPEN_CHANNEL_T"; break;
        case API_CLOSE_CHANNEL_T:       p_str="API_CLOSE_CHANNEL_T";break;
        case API_MSTSLV_T:              p_str="API_MSTSLV_T";       break;
        case API_SEND_MUX_T:            p_str="API_SEND_MUX_T";     break;
        case API_RECV_MUX_T:            p_str="API_RECV_MUX_T";     break;
        default:        p_str="<<UNKNOWN>>";        break;
        }
      H245TRACE(pInstance->dwInst, 0, "Tracker Type      %s",p_str);
      switch (p_tracker->State)
        {
        case API_ST_WAIT_RMTACK:        p_str="API_ST_WAIT_RMTACK"; break;
        case API_ST_WAIT_LCLACK:        p_str="API_ST_WAIT_LCLACK"; break;
        case API_ST_WAIT_LCLACK_CANCEL: p_str="API_ST_WAIT_LCLACK_CANCEL"; break;
        case API_ST_WAIT_CONF:          p_str="API_ST_WAIT_CONF";   break;
        case API_ST_IDLE:               p_str="API_ST_IDLE";        break;
        default:                        p_str="<<UNKNOWN>>";        break;
        }
      H245TRACE(pInstance->dwInst, 0, "Tracker State     %s",p_str);

      if (p_tracker->TrackerType == API_OPEN_CHANNEL_T ||
          p_tracker->TrackerType == API_CLOSE_CHANNEL_T)
        {
          switch (p_tracker->u.Channel.ChannelAlloc)
            {
            case API_CH_ALLOC_UNDEF:    p_str="API_CH_ALLOC_UNDEF"; break;
            case API_CH_ALLOC_LCL:      p_str="API_CH_ALLOC_LCL";   break;
            case API_CH_ALLOC_RMT:      p_str="API_CH_ALLOC_RMT";   break;
            default:                    p_str="<<UNKNOWN>>";        break;
            }
          H245TRACE(pInstance->dwInst, 0, "Channel Alloc     %s",p_str);
          switch (p_tracker->u.Channel.ChannelType)
            {
            case API_CH_TYPE_UNDEF:     p_str="API_CH_TYPE_UNDEF";  break;
            case API_CH_TYPE_UNI:       p_str="API_CH_TYPE_UNI";    break;
            case API_CH_TYPE_BI:        p_str="API_CH_TYPE_BI";     break;
            default:                    p_str="<<UNKNOWN>>";        break;
            }
          H245TRACE(pInstance->dwInst, 0, "Channel Type      %s",p_str);
          if (p_tracker->u.Channel.RxChannel == H245_INVALID_CHANNEL)
            H245TRACE(pInstance->dwInst, 0, "Channel Rx        H245_INVALID_CHANNEL");
          else
            H245TRACE(pInstance->dwInst, 0, "Channel Rx        %d",p_tracker->u.Channel.RxChannel);
          if (p_tracker->u.Channel.TxChannel == H245_INVALID_CHANNEL)
            H245TRACE(pInstance->dwInst, 0, "Channel Tx        H245_INVALID_CHANNEL");
          else
            H245TRACE(pInstance->dwInst, 0, "Channel Tx        %d",p_tracker->u.Channel.TxChannel);
        }
      else if (p_tracker->TrackerType == API_SEND_MUX_T ||
               p_tracker->TrackerType == API_RECV_MUX_T)
        {
          H245TRACE(pInstance->dwInst, 0, "MuxEntryCount     %d",p_tracker->u.MuxEntryCount);
        }
    }

  H245TRACE(pInstance->dwInst, 0, "************ TRACKER DUMP END **********");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\av_asn1.h ===
#ifndef _MS_AV_ASN1_H_
#define _MS_AV_ASN1_H_

#include "nmasn1.h"

#ifdef __cplusplus
extern "C" {
#endif

// lonchanc: copied from ossdll.h
#define DLL_ENTRY       WINAPI
#define DLL_ENTRY_FDEF  WINAPI
#define DLL_ENTRY_FPTR  WINAPI


extern ASN1module_t     H225ASN_Module;

#define q931asn         H225ASN_Module
#define ObjectID_       ASN1objectidentifier_s

typedef ASN1bool_t      ASN1_BOOL;


typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;
}
    ASN1_CODER_INFO;

typedef struct
{
    ULONG           length;
    PBYTE           value;
}
    ASN1_BUF;

int H225_InitModule(void);
int H225_TermModule(void);

int Q931_InitWorld(ASN1_CODER_INFO *pWorld);
int Q931_TermWorld(ASN1_CODER_INFO *pWorld);
int Q931_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, BYTE **ppEncoded, DWORD *pcbEncodedSize);
int Q931_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, BYTE *pEncoded, DWORD cbEncodedSize);

int H245_InitModule(void);
int H245_TermModule(void);
int H245_InitWorld(ASN1_CODER_INFO *pWorld);
int H245_TermWorld(ASN1_CODER_INFO *pWorld);
int H245_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int H245_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);




__inline int freePDU(ASN1_CODER_INFO *pWorld, int nPDU, void *pDecoded, ASN1module_t pModule)
{
    ASN1_FreeDecoded(pWorld->pDecInfo, pDecoded, nPDU);
    return ASN1_SUCCESS;
}


#ifdef __cplusplus
}
#endif

#endif // _MS_AV_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\callcon2.c ===
/****************************************************************************
 *
 * $Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callcon2.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 * Copyright (c) 1996 Intel Corporation.
 *
 * $Revision:   1.35  $
 * $Date:   03 Mar 1997 09:08:16  $
 * $Author:   MANDREWS  $
 *
 * Deliverable:
 *
 * Abstract:
 *
 * Notes:
 *
 ***************************************************************************/
#ifdef GATEKEEPER

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "confman.h"
#include "listman.h"
#include "q931man.h"
#include "h245man.h"
#include "callman.h"
#include "userman.h"
#include "chanman.h"
#include "hangman.h"
#include "linkapi.h"
#include "h245api.h"
#include "ccutils.h"
#include "callman2.h"

#define HResultLeave(x) return x


extern CC_CONFERENCEID	InvalidConferenceID;


//
// Complete CC_xxx Operations
//

HRESULT ListenReject     (CC_HLISTEN hListen, HRESULT Reason)
{
HRESULT						status;
PLISTEN						pListen;
CC_LISTEN_CALLBACK_PARAMS   ListenCallbackParams;
    ASSERT(GKIExists());
	status = LockListen(hListen, &pListen);
	if (status == CC_OK) {
		ListenCallbackParams.hCall = CC_INVALID_HANDLE;
		ListenCallbackParams.pCallerAliasNames = NULL;
		ListenCallbackParams.pCalleeAliasNames = NULL;
		ListenCallbackParams.pNonStandardData = NULL;
		ListenCallbackParams.pszDisplay = NULL;
		ListenCallbackParams.pVendorInfo = NULL;
		ListenCallbackParams.ConferenceID = InvalidConferenceID;
		ListenCallbackParams.pCallerAddr = NULL;
		ListenCallbackParams.pCalleeAddr = NULL;
		ListenCallbackParams.dwListenToken = pListen->dwListenToken;

	    // Invoke the user callback -- the listen object is locked during the callback,
	    // but the associated call object is unlocked (to prevent deadlock if
	    // CC_AcceptCall() or CC_RejectCall() is called during the callback from a
	    // different thread, and the callback thread blocks pending completion of
	    // CC_AcceptCall() or CC_RejectCall())
	    InvokeUserListenCallback(pListen,
							     Reason,
							     &ListenCallbackParams);

	    // Need to validate the listen handle; the associated object may have been
	    // deleted during the user callback by this thread
	    if (ValidateListen(hListen) == CC_OK) {
	        HQ931LISTEN hQ931Listen = pListen->hQ931Listen;
		    UnlockListen(pListen);
	        status = Q931CancelListen(hQ931Listen);
	        if (LockListen(hListen, &pListen) == CC_OK) {
                FreeListen(pListen);
            }
        }
    }

    HResultLeave(status);
} // ListenReject()



HRESULT PlaceCallConfirm    (void *pCallVoid, void *pConferenceVoid)
{
    register PCALL          pCall = (PCALL) pCallVoid;
    HRESULT                 status;
    ASSERT(GKIExists());
    // Free Alias lists
    if (pCall->GkiCall.pCalleeAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeAliasNames);
        pCall->GkiCall.pCalleeAliasNames = NULL;
    }
    if (pCall->GkiCall.pCalleeExtraAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeExtraAliasNames);
        pCall->GkiCall.pCalleeExtraAliasNames = NULL;
    }

    if (pCall->pQ931PeerConnectAddr == NULL) {
        pCall->pQ931PeerConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
        if (pCall->pQ931PeerConnectAddr == NULL)
            return PlaceCallReject(pCallVoid, pConferenceVoid, CC_NO_MEMORY);
    }

    pCall->pQ931PeerConnectAddr->nAddrType             = CC_IP_BINARY;
    pCall->pQ931PeerConnectAddr->bMulticast            = FALSE;
    pCall->pQ931PeerConnectAddr->Addr.IP_Binary.wPort  = pCall->GkiCall.wPort;
    pCall->pQ931PeerConnectAddr->Addr.IP_Binary.dwAddr = ntohl(pCall->GkiCall.dwIpAddress);

    status = PlaceCall(pCall, (PCONFERENCE)pConferenceVoid);
    if (status != CC_OK)
      PlaceCallReject(pCallVoid, pConferenceVoid, status);
    return status;
} // PlaceCallConfirm()



HRESULT PlaceCallReject     (void *pCallVoid, void *pConferenceVoid, HRESULT Reason)
{
register PCALL          pCall = (PCALL) pCallVoid;
register PCONFERENCE    pConference = (PCONFERENCE) pConferenceVoid;
CC_HCONFERENCE			hConference;
HRESULT                 status = CC_OK;
CC_CONNECT_CALLBACK_PARAMS ConnectCallbackParams = {0};
CC_HCALL                hCall;
PCALL                   pCall2;
    ASSERT(GKIExists());
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

    // Free Alias lists
    if (pCall->GkiCall.pCalleeAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeAliasNames);
        pCall->GkiCall.pCalleeAliasNames = NULL;
    }
    if (pCall->GkiCall.pCalleeExtraAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeExtraAliasNames);
        pCall->GkiCall.pCalleeExtraAliasNames = NULL;
    }

    // Inform Call Control client of failure
    ConnectCallbackParams.pNonStandardData     = pCall->pPeerNonStandardData;
    ConnectCallbackParams.pszPeerDisplay       = pCall->pszPeerDisplay;
    ConnectCallbackParams.bRejectReason        = 0;
    ConnectCallbackParams.pTermCapList         = pCall->pPeerH245TermCapList;
    ConnectCallbackParams.pH2250MuxCapability  = pCall->pPeerH245H2250MuxCapability;
    ConnectCallbackParams.pTermCapDescriptors  = pCall->pPeerH245TermCapDescriptors;
    ConnectCallbackParams.pLocalAddr           = pCall->pQ931LocalConnectAddr;
 	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
    ConnectCallbackParams.pVendorInfo          = pCall->pPeerVendorInfo;
    if (pConference->ConferenceMode == MULTIPOINT_MODE)
        ConnectCallbackParams.bMultipointConference = TRUE;
    else
        ConnectCallbackParams.bMultipointConference = FALSE;
    ConnectCallbackParams.pConferenceID        = &pConference->ConferenceID;
    ConnectCallbackParams.pMCAddress           = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress	= NULL;
    ConnectCallbackParams.dwUserToken          = pCall->dwUserToken;
	hConference = pConference->hConference;
    InvokeUserConferenceCallback(pConference,
                                 CC_CONNECT_INDICATION,
                                 Reason,
                                 &ConnectCallbackParams);

    if (ValidateConference(hConference) == CC_OK) {
		// Start up an enqueued call, if one exists
		for ( ; ; ) {
			status = RemoveEnqueuedCallFromConference(pConference, &hCall);
			if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
				break;

			status = LockCall(hCall, &pCall2);
			if (status == CC_OK) {
				pCall2->CallState = PLACED;

				status = PlaceCall(pCall2, pConference);
				UnlockCall(pCall2);
				if (status == CC_OK)
					break;
			}
		}
    }

    HResultLeave(status);
} // PlaceCallReject()



HRESULT AcceptCallConfirm   (void *pCallVoid, void *pConferenceVoid)
{
CC_HCALL        hCall       = ((PCALL)pCallVoid)->hCall;
CC_HCONFERENCE  hConference = ((PCONFERENCE)pConferenceVoid)->hConference;
HRESULT         status;
    ASSERT(GKIExists());
    status = AcceptCall((PCALL)pCallVoid, (PCONFERENCE)pConferenceVoid);
    LockConference(hConference, (PPCONFERENCE)&pConferenceVoid);
    LockCall(hCall, (PPCALL)&pCallVoid);
    if (status != CC_OK && pCallVoid != NULL && pConferenceVoid != NULL)
      AcceptCallReject(pCallVoid, pConferenceVoid, status);
    return status;
} // AcceptCallConfirm()



HRESULT AcceptCallReject    (void *pCallVoid, void *pConferenceVoid, HRESULT Reason)
{
register PCALL          pCall = (PCALL) pCallVoid;
register PCONFERENCE    pConference = (PCONFERENCE) pConferenceVoid;
HRESULT                 status = CC_OK;
CC_CONNECT_CALLBACK_PARAMS ConnectCallbackParams = {0};
    ASSERT(GKIExists());
    status = Q931RejectCall(pCall->hQ931Call,       // Q931 call handle
                            CC_REJECT_GATEKEEPER_RESOURCES,
                            &pCall->ConferenceID,   // Conference Identifier
                            NULL,                   // alternate address
                            pCall->pLocalNonStandardData);

    ConnectCallbackParams.pNonStandardData     = pCall->pPeerNonStandardData;
    ConnectCallbackParams.pszPeerDisplay       = pCall->pszPeerDisplay;
    ConnectCallbackParams.bRejectReason        = 0;
    ConnectCallbackParams.pTermCapList         = pCall->pPeerH245TermCapList;
    ConnectCallbackParams.pH2250MuxCapability  = pCall->pPeerH245H2250MuxCapability;
    ConnectCallbackParams.pTermCapDescriptors  = pCall->pPeerH245TermCapDescriptors;
    ConnectCallbackParams.pLocalAddr           = pCall->pQ931LocalConnectAddr;
 	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
    if (pConference->ConferenceMode == MULTIPOINT_MODE)
        ConnectCallbackParams.bMultipointConference = TRUE;
    else
        ConnectCallbackParams.bMultipointConference = FALSE;
    ConnectCallbackParams.pVendorInfo          = pCall->pPeerVendorInfo;
    ConnectCallbackParams.pConferenceID        = &pConference->ConferenceID;
    ConnectCallbackParams.pMCAddress           = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress	= NULL;
    ConnectCallbackParams.dwUserToken          = pCall->dwUserToken;

    InvokeUserConferenceCallback(pConference,
                                 CC_CONNECT_INDICATION,
                                 Reason,
                                 &ConnectCallbackParams);

    HResultLeave(status);
} // AcceptCallReject()



#if 0

HRESULT CancelCallConfirm   (void *pCallVoid, void *pConferenceVoid)
{
PCALL               pCall = (PCALL) pCallVoid;
PCONFERENCE         pConference = (PCONFERENCE) pConferenceVoid;
HRESULT             status;
H245_INST_T         H245Instance;
HQ931CALL           hQ931Call;
CC_HCONFERENCE      hConference;
HRESULT             SaveStatus;
CC_HCALL            hCall;
    ASSERT(GKIExists());
    H245Instance = pCall->H245Instance;
    hQ931Call    = pCall->hQ931Call;
    hConference  = pCall->hConference;
    FreeCall(pCall);

    if (H245Instance != H245_INVALID_ID)
        SaveStatus = H245ShutDown(H245Instance);
    else
        SaveStatus = H245_ERROR_OK;

    if (SaveStatus == H245_ERROR_OK) {
        SaveStatus = Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
        // Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
        // may have been deleted at this point
        if (SaveStatus == CS_BAD_PARAM)
            SaveStatus = CC_OK;
    } else
        Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);

    // Start up an enqueued call, if one exists
    for ( ; ; ) {
        status = RemoveEnqueuedCallFromConference(pConference, &hCall);
        if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
            break;

        status = LockCall(hCall, &pCall);
        if (status == CC_OK) {
            pCall->CallState = PLACED;

            status = PlaceCall(pCall, pConference);
            UnlockCall(pCall);
            if (status == CC_OK)
                break;
        }
    }
    UnlockConference(pConference);

    if (SaveStatus != CC_OK)
        status = SaveStatus;
    HResultLeave(status);
} // CancelCallConfirm()



HRESULT CancelCallReject    (void *pCallVoid, void *pConferenceVoid)
{
    // I don't care what the Gatekeeper says; I'm shutting down the call!
    return CancelCallConfirm(pCallVoid, pConferenceVoid);
} // CancelCallReject()

#endif



HRESULT OpenChannelConfirm  (CC_HCHANNEL hChannel)
{
HRESULT             status;
PCHANNEL            pChannel;
PCONFERENCE         pConference;
WORD                wNumCalls;
PCC_HCALL           CallList;
HRESULT             SaveStatus;
unsigned            i;
PCALL               pCall;
    ASSERT(GKIExists());
    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status == CC_OK) {
        // Open a logical channel for each established call
        status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
        if (status == CC_OK) {
            SaveStatus = CC_OK;
            for (i = 0; i < wNumCalls; ++i) {
                if (LockCall(CallList[i], &pCall) == CC_OK) {
                    status = H245OpenChannel(pCall->H245Instance,       // H245 instance
                                             pChannel->hChannel,        // dwTransId
                                             pChannel->wLocalChannelNumber,
                                             pChannel->pTxH245TermCap,  // TxMode
                                             pChannel->pTxMuxTable,     // TxMux
                                             H245_INVALID_PORT_NUMBER,  // TxPort
                                             pChannel->pRxH245TermCap,  // RxMode
                                             pChannel->pRxMuxTable,     // RxMux
                                             pChannel->pSeparateStack);
                    if (status == H245_ERROR_OK)
                        (pChannel->wNumOutstandingRequests)++;
                    else
                        SaveStatus = status;
                    UnlockCall(pCall);
                }
            }

            if (CallList != NULL)
                MemFree(CallList);

            if (pChannel->wNumOutstandingRequests == 0) {
                // all open channel requests failed
                FreeChannel(pChannel);
            }
            else {
                UnlockChannel(pChannel);
            }

            if (SaveStatus != CC_OK)
                status = SaveStatus;
        }
        else {
            FreeChannel(pChannel);
        }
        UnlockConference(pConference);
    }


    HResultLeave(status);
} // OpenChannelConfirm()



HRESULT OpenChannelReject   (CC_HCHANNEL hChannel, HRESULT Reason)
{
PCHANNEL            pChannel;
PCONFERENCE         pConference;
CC_HCONFERENCE      hConference;
HRESULT             status;
CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS Params = {0};
    ASSERT(GKIExists());
    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status == CC_OK) {
        // Inform Call Control client of failure
        Params.hChannel         = hChannel;
        Params.pPeerRTPAddr     = pChannel->pPeerRTPAddr;
        Params.pPeerRTCPAddr    = pChannel->pPeerRTCPAddr;
        Params.dwRejectReason   = 0;
        Params.dwUserToken      = pChannel->dwUserToken;

        hConference = pConference->hConference;
        InvokeUserConferenceCallback(pConference,
                                     CC_TX_CHANNEL_OPEN_INDICATION,
                                     Reason,
                                     &Params);

        if (ValidateChannel(hChannel) == CC_OK)
            FreeChannel(pChannel);
        if (ValidateConference(hConference) == CC_OK)
            UnlockConference(pConference);
    }

    HResultLeave(status);
} // OpenChannelReject()



HRESULT AcceptChannelConfirm(CC_HCHANNEL hChannel)
{
HRESULT         status;
PCHANNEL        pChannel;
PCONFERENCE     pConference;
CC_HCONFERENCE  hConference;
PCALL           pCall;
unsigned        i;
H245_MUX_T      H245MuxTable;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS Params;
    ASSERT(GKIExists());
    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status != CC_OK)
        HResultLeave(status);

    status = LockCall(pChannel->hCall, &pCall);
    if (status != CC_OK) {
        UnlockChannel(pChannel);
        UnlockConference(pConference);
        HResultLeave(status);
    }

    if (pChannel->wNumOutstandingRequests != 0) {
        PCC_ADDR pRTPAddr  = pChannel->pLocalRTPAddr;
        PCC_ADDR pRTCPAddr = pChannel->pLocalRTCPAddr;
        if ((pChannel->bMultipointChannel) &&
            (pConference->tsMultipointController == TS_TRUE)) {
            // Supply the RTP and RTCP addresses in the OpenLogicalChannelAck
            if (pConference->pSessionTable != NULL) {
                for (i = 0; i < pConference->pSessionTable->wLength; ++i) {
                    if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
                        pChannel->bSessionID) {
                        pRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
                        pRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
                        break;
                    }
                }
            }
        }

        H245MuxTable.Kind = H245_H2250ACK;
        H245MuxTable.u.H2250ACK.nonStandardList = NULL;

        if (pRTPAddr != NULL) {
            if (pRTPAddr->bMulticast)
                H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
            else
                H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
            H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
                pRTPAddr->Addr.IP_Binary.wPort;
            HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
                                pRTPAddr->Addr.IP_Binary.dwAddr);
            H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
        } else
            H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

        if (pRTCPAddr != NULL) {
            if (pRTCPAddr->bMulticast)
                H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
            else
                H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
            H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
                pRTCPAddr->Addr.IP_Binary.wPort;
            HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
                                pRTCPAddr->Addr.IP_Binary.dwAddr);
            H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
        } else
            H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

        H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
        H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
        H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;

        status = H245OpenChannelAccept(pCall->H245Instance,
                                       0,                   // dwTransId
                                       pChannel->wRemoteChannelNumber, // Rx channel
                                       &H245MuxTable,
                                       0,                       // Tx channel
                                       NULL,                    // Tx mux
                                       H245_INVALID_PORT_NUMBER,// Port
                                       pChannel->pSeparateStack);
        if (status == CC_OK)
            pChannel->wNumOutstandingRequests = 0;
        else
            --(pChannel->wNumOutstandingRequests);
    }

    pChannel->tsAccepted = TS_TRUE;

    Params.hChannel = hChannel;
    if (status == CC_OK)
        UnlockChannel(pChannel);
    else
        FreeChannel(pChannel);
    UnlockCall(pCall);

    hConference = pConference->hConference;
    InvokeUserConferenceCallback(pConference,
                                 CC_ACCEPT_CHANNEL_INDICATION,
                                 status,
                                 &Params);
    if (ValidateConference(hConference) == CC_OK)
        UnlockConference(pConference);

    HResultLeave(status);
} // AcceptChannelConfirm(void()



HRESULT AcceptChannelReject (CC_HCHANNEL hChannel, HRESULT Reason)
{
HRESULT         status;
PCHANNEL        pChannel;
PCONFERENCE     pConference;
CC_HCONFERENCE  hConference;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS Params;
    ASSERT(GKIExists());
    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status == CC_OK) {
        Params.hChannel = hChannel;
        FreeChannel(pChannel);

        hConference = pConference->hConference;
        InvokeUserConferenceCallback(pConference,
                                     CC_ACCEPT_CHANNEL_INDICATION,
                                     Reason,
                                     &Params);
        if (ValidateConference(hConference) == CC_OK)
            UnlockConference(pConference);
    }

    HResultLeave(status);
} // AcceptChannelReject()



//
// Handle gratuitous messages from Gatekeeper
//

// Note: pCall assumed locked when called!

HRESULT Disengage(void *pCallVoid)
{
CC_HCALL            hCall        = ((PCALL)pCallVoid)->hCall;
HRESULT             status;
    UnlockCall((PCALL)pCallVoid);
    status = ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_GATEKEEPER_TERMINATED);
    HResultLeave(status);
} // Disengage()



// Note: pCall assumed locked when called!

HRESULT BandwidthShrunk(void *pCallVoid,
                        void *pConferenceVoid,
                        unsigned uBandwidthAllocated,
                        long lBandwidthChange)
{
PCALL               pCall       = (PCALL) pCallVoid;
PCONFERENCE         pConference = (PCONFERENCE)pConferenceVoid;
CC_BANDWIDTH_CALLBACK_PARAMS Params;
    ASSERT(GKIExists());
    Params.hCall = pCall->hCall;
    Params.dwBandwidthTotal  = uBandwidthAllocated;
    Params.lBandwidthChange  = lBandwidthChange;
    InvokeUserConferenceCallback(pConference,
                                 CC_BANDWIDTH_CHANGED_INDICATION,
                                 CC_OK,
                                 &Params);

    HResultLeave(CC_OK);
} // BandwidthShrunk()

#else  // GATEKEEPER
static char ch; // Kludge around warning C4206: nonstandard extension used : translation unit is empty
#endif // GATEKEEPER

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\callcont.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callcont.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.208  $
 *	$Date:   03 Mar 1997 19:40:58  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#define CALL_CONTROL_EXPORT

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#ifdef FORCE_SERIALIZE_CALL_CONTROL
    #include "cclock.h"
#endif  // FORCE_SERIALIZE_CALL_CONTROL
#include "q931.h"
#include "ccmain.h"
#include "confman.h"
#include "listman.h"
#include "q931man.h"
#include "h245man.h"
#include "callman.h"
#include "userman.h"
#include "chanman.h"
#include "hangman.h"
#include "linkapi.h"
#include "h245api.h"
#include "ccutils.h"


#ifdef    GATEKEEPER
HRESULT InitGkiManager(void);
void    DeInitGkiManager(void);
extern HRESULT GkiRegister(void);
extern HRESULT GkiListenAddr(SOCKADDR_IN* psin);
extern HRESULT GkiUnregister(void);
extern VOID GKI_SetGKAddress(PSOCKADDR_IN pAddr);
extern BOOL fGKEnabled;
extern RASNOTIFYPROC gpRasNotifyProc;

#define GKI_MAX_BANDWIDTH       (0xFFFFFFFF / 100)
#endif // GATEKEEPER
VOID InitCallControl();

CALL_CONTROL_STATE		CallControlState = INITIALIZING_STATE;
BOOL					bISDMLoaded = FALSE;
static HRESULT			InitStatus;
// NumThreads counts the number of threads which are executing code within this DLL.
// NumThreads must be incremented at each DLL entry point (which includes each API
// call, the Q931 callback location and the H245 callback location).
// NumThreads must be decremented upon DLL exit.  The macro LeaveCallControlTop()
// is used to facilitate this operation.  Note that LeaveCallControlTop may accept
// a function call as a parameter; we must call the function first, save its return
// value, then decrement NumThreads, and finally return the saved value.
THREADCOUNT				ThreadCount;
extern CC_CONFERENCEID	InvalidConferenceID;

#define _Unicode(x) L ## x
#define Unicode(x) _Unicode(x)

WORD  ADDRToInetPort(CC_ADDR *pAddr);
DWORD ADDRToInetAddr(CC_ADDR *pAddr);

#ifdef _DEBUG

static const PSTR c_apszDbgZones[] =
{
    "CallCont",
    DEFAULT_ZONES
};

#endif // _DEBUG



BOOL WINAPI DllMain(				HINSTANCE				hInstDll,
									DWORD					fdwReason,
									LPVOID					lpvReserved)
{
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			// The DLL is being mapped into the process's address space
			
			ASSERT(CallControlState == INITIALIZING_STATE);
			ASSERT(CC_OK == CS_OK);
			ASSERT(CC_OK == H245_ERROR_OK);

#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
                (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif
            DBG_INIT_MEMORY_TRACKING(hInstDll);

			InitializeLock(&ThreadCount.Lock);
			ThreadCount.wNumThreads = 0;
// 6/25/98            InitCallControl();
            H245_InitModule();
			break;

		case DLL_THREAD_ATTACH:
			// A thread is being created
			break;

		case DLL_THREAD_DETACH:
			// A thread is exiting cleanly
			break;

		case DLL_PROCESS_DETACH:
			// The DLL is being unmapped from the process's address space

            H245_TermModule();
			DeleteLock(&ThreadCount.Lock);

            DBG_CHECK_MEMORY_TRACKING(hInstDll);
#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif
			break;
	}

	return TRUE;
}

VOID InitCallControl()
{
#ifdef FORCE_SERIALIZE_CALL_CONTROL	
    InitStatus = InitializeCCLock();
    if (InitStatus != CC_OK)
		return;
#endif

    InitStatus = H225Init();
    if (InitStatus != CC_OK)
		return;
		
#ifdef    GATEKEEPER			
	InitStatus = InitGkiManager();
//  an error return is OK for now.  Run totally gatekeeper-less
//	if (InitStatus != CC_OK)
//	
#endif // GATEKEEPER

	InitStatus = InitConferenceManager();
	if (InitStatus != CC_OK)
		return;

	InitStatus = InitCallManager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitChannelManager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitH245Manager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitListenManager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitQ931Manager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitUserManager();
	if (InitStatus != CC_OK)
		return;

	InitStatus = InitHangupManager();
	if (InitStatus != CC_OK)
		return;

	InitStatus = Q931Init();
	if (InitStatus != CS_OK)
		return;

	CallControlState = OPERATIONAL_STATE;
}

CC_API
HRESULT CC_Initialize()
{
    if (CallControlState == OPERATIONAL_STATE)
    {
        return (CC_OK);
    }
    else if((CallControlState == INITIALIZING_STATE) || (CallControlState == SHUTDOWN_STATE))
    {
        InitCallControl();
    }
    return (InitStatus);
}


CC_API
HRESULT CC_AcceptCall(				CC_HCONFERENCE			hConference,
									PCC_NONSTANDARDDATA		pNonStandardData,
									PWSTR					pszDisplay,
									CC_HCALL				hCall,
                                    DWORD                   dwBandwidth,
									DWORD_PTR				dwUserToken)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
HQ931CALL		hQ931Call;
WORD			wNumCalls;
CC_ADDR			AlternateAddr;
PCC_ADDR		pAlternateAddr;
BOOL			bAccept = FALSE;
BYTE			bRejectReason = CC_REJECT_UNDEFINED_REASON;
CC_CONFERENCEID	ConferenceID;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		// note that we can't even tell Q931 to reject the call
		LeaveCallControlTop(status);

	if (pCall->CallState != INCOMING) {
		UnlockCall(pCall);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	ASSERT(pCall->hConference == CC_INVALID_HANDLE);

	hQ931Call = pCall->hQ931Call;
	ConferenceID = pCall->ConferenceID;

	status = AddLocalNonStandardDataToCall(pCall, pNonStandardData);
	if (status != CC_OK) {
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		LeaveCallControlTop(status);
	}

	status = AddLocalDisplayToCall(pCall, pszDisplay);
	if (status != CC_OK) {
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		LeaveCallControlTop(status);
	}

	UnlockCall(pCall);
	status = LockConferenceEx(hConference,
							  &pConference,
							  TS_FALSE);	// bDeferredDelete
	if (status == CC_OK) {
		status = LockCall(hCall, &pCall);
		if (status != CC_OK) {
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
	} else
		LeaveCallControlTop(status);

	if ((pCall->bCallerIsMC == TRUE) &&
		((pConference->tsMultipointController == TS_TRUE) ||
		 (pConference->bMultipointCapable == FALSE))) {
		FreeCall(pCall);
		UnlockConference(pConference);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		if (pConference->bMultipointCapable == FALSE) {
			LeaveCallControlTop(CC_BAD_PARAM);
		} else {
			LeaveCallControlTop(CC_NOT_MULTIPOINT_CAPABLE);
		}
	}

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if ((wNumCalls > 0) &&
		(pConference->bMultipointCapable == FALSE)) {
		FreeCall(pCall);
		UnlockConference(pConference);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		LeaveCallControlTop(CC_NOT_MULTIPOINT_CAPABLE);
	}

	pAlternateAddr = NULL;

	if (EqualConferenceIDs(&pCall->ConferenceID, &pConference->ConferenceID)) {
		if (wNumCalls > 0) {
			if (pConference->tsMultipointController == TS_TRUE) {
				// Accept Call
				status = CC_OK;
				bAccept = TRUE;
			} else { // we're not the MC
				if (pConference->bMultipointCapable) {
					if (pConference->pMultipointControllerAddr != NULL) {
						// Reject Call - route to MC
						status = CC_OK;
						bAccept = FALSE;
						bRejectReason = CC_REJECT_ROUTE_TO_MC;
						AlternateAddr = *pConference->pMultipointControllerAddr;
						pAlternateAddr = &AlternateAddr;
					} else { // we don't have the MC's address
						// XXX -- we may eventually want to enqueue the request
						// and set an expiration timer
						// Error - no MC
						status = CC_NOT_MULTIPOINT_CAPABLE;
					}
				} else { // we're not multipoint capable
					// Error - bad param
					status = CC_BAD_PARAM;
				}
			}
		} else { // wNumCalls == 0
			// Accept Call
			status = CC_OK;
			bAccept = TRUE;
		}
	} else { // pCall->ConferenceID != pConference->ConferenceID
		if (EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) {
			// Accept Call
			status = CC_OK;
			bAccept = TRUE;
		} else { // pConferenceID != InvalidConferenceID
			if (pConference->tsMultipointController == TS_TRUE) {
				// Reject Call - route to MC
				status = CC_OK;
				bAccept = FALSE;
				bRejectReason = CC_REJECT_ROUTE_TO_MC;
				pAlternateAddr = &AlternateAddr;
				if (GetLastListenAddress(pAlternateAddr) != CC_OK) {
					pAlternateAddr = NULL;
					bRejectReason = CC_REJECT_UNDEFINED_REASON;
				}
			} else { // we're not the MC
				if (pConference->bMultipointCapable) {
					if (pConference->pMultipointControllerAddr) {
						// Reject Call - route to MC
						status = CC_OK;
						bAccept = FALSE;
						bRejectReason = CC_REJECT_ROUTE_TO_MC;
						AlternateAddr = *pConference->pMultipointControllerAddr;
						pAlternateAddr = &AlternateAddr;
					} else { // we don't have the MC's address
						// XXX -- we may eventually want to enqueue the request
						// and set an expiration timer
						// Error - no MC
						status = CC_NOT_MULTIPOINT_CAPABLE;
					}
				} else { // we're not multipoint capable
					// Error - bad param
					status = CC_BAD_PARAM;
				}
			}
		}
	}

	if (status != CC_OK) {
		FreeCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (bAccept) {
		pCall->dwUserToken = dwUserToken;

#ifdef    GATEKEEPER
        if(GKIExists())
        {
    		pCall->hConference = hConference;

    		// Fill in Gatekeeper Call fields
    		memset(&pCall->GkiCall, 0, sizeof(pCall->GkiCall));
    		pCall->GkiCall.pCall            = pCall;
    		pCall->GkiCall.hCall            = hCall;
            pCall->GkiCall.pConferenceId    = pCall->ConferenceID.buffer;
    		pCall->GkiCall.bActiveMC        = pCall->bCallerIsMC;
    		pCall->GkiCall.bAnswerCall      = TRUE;
    		
    		if(pCall->pSourceCallSignalAddress)
    		{
    			pCall->GkiCall.dwIpAddress      = ADDRToInetAddr(pCall->pSourceCallSignalAddress);
    		    pCall->GkiCall.wPort            = pCall->pSourceCallSignalAddress->Addr.IP_Binary.wPort;
    		}
    		else
    		{
        		pCall->GkiCall.dwIpAddress      = ADDRToInetAddr(pCall->pQ931PeerConnectAddr);
        		pCall->GkiCall.wPort            = pCall->pQ931PeerConnectAddr->Addr.IP_Binary.wPort;
    		}
    		pCall->GkiCall.CallIdentifier   = pCall->CallIdentifier;
    		
    		if (pConference->bMultipointCapable)
    			pCall->GkiCall.CallType = MANY_TO_MANY;
    		else
    			pCall->GkiCall.CallType = POINT_TO_POINT;
            pCall->GkiCall.uBandwidthRequested = dwBandwidth / 100;
    		status = GkiOpenCall(&pCall->GkiCall, pConference);

            // GkiOpenCall may or may not have called AcceptCall, which unlocks
            // call and conference and may or may not free the call
    	    if (ValidateCall(hCall) == CC_OK)
    			if (status == CC_OK)
    				UnlockCall(pCall);
    			else
    				FreeCall(pCall);
    	    if (ValidateConference(hConference) == CC_OK)
    		    UnlockConference(pConference);

            if (status != CC_OK)
            {
    		    Q931RejectCall( hQ931Call,				        // Q931 call handle
    		  			        CC_REJECT_GATEKEEPER_RESOURCES, // reject reason
    		  			        &ConferenceID,
    		    		        NULL,          			        // alternate address
    		  			        pNonStandardData);		        // non-standard data
            }
        }
        else
        {
            status = AcceptCall(pCall, pConference);
        }
#else  // GATEKEEPER
		status = AcceptCall(pCall, pConference);
#endif // GATEKEEPER

		LeaveCallControlTop(status);
	} else { // bAccept == FALSE
		FreeCall(pCall);
		if (bRejectReason == CC_REJECT_ROUTE_TO_MC) {
			ASSERT(pAlternateAddr != NULL);
			ConferenceID = pConference->ConferenceID;
		} else
			pAlternateAddr = NULL;

		UnlockConference(pConference);
		status = Q931RejectCall(hQ931Call,				// Q931 call handle
								bRejectReason,			// reject reason
								&ConferenceID,
				   				pAlternateAddr,			// alternate address
								pNonStandardData);		// non-standard data
		LeaveCallControlTop(status);
	}
}



CC_API
HRESULT CC_AcceptChannel(			CC_HCHANNEL				hChannel,
									PCC_ADDR				pRTPAddr,
									PCC_ADDR				pRTCPAddr,
									DWORD					dwChannelBitRate)
{
HRESULT			status;
PCHANNEL		pChannel;
PCONFERENCE		pConference;
CC_HCALL		hCall;
PCALL			pCall;
//#ifndef    GATEKEEPER
H245_MUX_T		H245MuxTable;
WORD			i;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS Params;
CC_HCONFERENCE hConference;
//#endif // !GATEKEEPER

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pRTCPAddr != NULL)
		if ((pRTCPAddr->nAddrType != CC_IP_BINARY) ||
			(pRTCPAddr->bMulticast == TRUE))
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);


	// Make sure that hChannel is a receive or proxy channel that
	// hasn't already been accepted
	if (((pChannel->bChannelType != RX_CHANNEL) &&
		 (pChannel->bChannelType != PROXY_CHANNEL)) ||
		 (pChannel->tsAccepted != TS_UNKNOWN)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pChannel->bMultipointChannel) {
		if ((pRTPAddr != NULL) || (pRTCPAddr != NULL)) {
			UnlockChannel(pChannel);
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}
	} else
		if ((pRTPAddr == NULL) || (pRTCPAddr == NULL)) {
			UnlockChannel(pChannel);
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	hCall = pChannel->hCall;
	status = LockCall(hCall, &pCall);
	if (status != CC_OK) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (pChannel->bMultipointChannel == FALSE) {
		status = AddLocalAddrPairToChannel(pRTPAddr, pRTCPAddr, pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockChannel(pChannel);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
	}

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	pChannel->dwChannelBitRate = dwChannelBitRate;
    	UnlockChannel(pChannel);
    	UnlockConference(pConference);
    	status = GkiOpenChannel(&pCall->GkiCall, dwChannelBitRate, hChannel, RX);
    	if (ValidateCall(hCall) == CC_OK)
    		UnlockCall(pCall);
	}
	else
	{
        if (pChannel->wNumOutstandingRequests != 0)
        {
    		if ((pChannel->bMultipointChannel) &&
    			(pConference->tsMultipointController == TS_TRUE))
    		{
    			// Supply the RTP and RTCP addresses in the OpenLogicalChannelAck
    			if (pConference->pSessionTable != NULL) {
    				for (i = 0; i < pConference->pSessionTable->wLength; i++) {
    					if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
    						pChannel->bSessionID) {
    						pRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
    						pRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
    						break;
    					}
    				}
    			}
    		}

    		H245MuxTable.Kind = H245_H2250ACK;
    		H245MuxTable.u.H2250ACK.nonStandardList = NULL;

    		if (pRTPAddr != NULL) {
    			if (pRTPAddr->bMulticast)
    				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
    			else
    				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
    			H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
    				pRTPAddr->Addr.IP_Binary.wPort;
    			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
    								pRTPAddr->Addr.IP_Binary.dwAddr);
    			H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
    		} else
    			H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

    		if (pRTCPAddr != NULL) {
    			if (pRTCPAddr->bMulticast)
    				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
    			else
    				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
    			H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
    				pRTCPAddr->Addr.IP_Binary.wPort;
    			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
    								pRTCPAddr->Addr.IP_Binary.dwAddr);
    			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
    		} else
    			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

    		H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
    		H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
    		H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;
    		
    		status = H245OpenChannelAccept(pCall->H245Instance,
    									   0,					// dwTransId
    									   pChannel->wRemoteChannelNumber, // Rx channel
    									   &H245MuxTable,
    									   0,						// Tx channel
    									   NULL,					// Tx mux
    									   H245_INVALID_PORT_NUMBER,// Port
    									   pChannel->pSeparateStack);
    		if (status == CC_OK)
    			pChannel->wNumOutstandingRequests = 0;
    		else
    			--(pChannel->wNumOutstandingRequests);
    	}

    	pChannel->tsAccepted = TS_TRUE;

        Params.hChannel = hChannel;
        if (status == CC_OK)
            UnlockChannel(pChannel);
        else
            FreeChannel(pChannel);
        UnlockCall(pCall);

        hConference = pConference->hConference;
        InvokeUserConferenceCallback(pConference,
                                     CC_ACCEPT_CHANNEL_INDICATION,
                                     status,
                                     &Params);
    	if (ValidateConference(hConference) == CC_OK)
    		UnlockConference(pConference);
	}
#else  // GATEKEEPER
	if (pChannel->wNumOutstandingRequests != 0) {
		if ((pChannel->bMultipointChannel) &&
			(pConference->tsMultipointController == TS_TRUE)) {
			// Supply the RTP and RTCP addresses in the OpenLogicalChannelAck
			if (pConference->pSessionTable != NULL) {
				for (i = 0; i < pConference->pSessionTable->wLength; i++) {
					if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
						pChannel->bSessionID) {
						pRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
						pRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
						break;
					}
				}
			}
		}

		H245MuxTable.Kind = H245_H2250ACK;
		H245MuxTable.u.H2250ACK.nonStandardList = NULL;

		if (pRTPAddr != NULL) {
			if (pRTPAddr->bMulticast)
				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
			else
				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
			H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
				pRTPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
								pRTPAddr->Addr.IP_Binary.dwAddr);
			H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
		} else
			H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

		if (pRTCPAddr != NULL) {
			if (pRTCPAddr->bMulticast)
				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
			else
				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
			H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
				pRTCPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
								pRTCPAddr->Addr.IP_Binary.dwAddr);
			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
		} else
			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

		H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
		H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
		H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;
		
		status = H245OpenChannelAccept(pCall->H245Instance,
									   0,					// dwTransId
									   pChannel->wRemoteChannelNumber, // Rx channel
									   &H245MuxTable,
									   0,						// Tx channel
									   NULL,					// Tx mux
									   H245_INVALID_PORT_NUMBER,// Port
									   pChannel->pSeparateStack);
		if (status == CC_OK)
			pChannel->wNumOutstandingRequests = 0;
		else
			--(pChannel->wNumOutstandingRequests);
	}

	pChannel->tsAccepted = TS_TRUE;

    Params.hChannel = hChannel;
    if (status == CC_OK)
        UnlockChannel(pChannel);
    else
        FreeChannel(pChannel);
    UnlockCall(pCall);

    hConference = pConference->hConference;
    InvokeUserConferenceCallback(pConference,
                                 CC_ACCEPT_CHANNEL_INDICATION,
                                 status,
                                 &Params);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
#endif // GATEKEEPER

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_AcceptT120Channel(		CC_HCHANNEL				hChannel,
									BOOL					bAssociateConference,
									PCC_OCTETSTRING			pExternalReference,
									PCC_ADDR				pAddr)
{
HRESULT			status;
PCHANNEL		pChannel;
PCALL			pCall;
PCONFERENCE		pConference;
H245_ACCESS_T	SeparateStack;
H245_ACCESS_T	*pSeparateStack;
H245_MUX_T		H245MuxTable;
WORD			i;
WORD			wNumCalls;
PCC_HCALL		CallList;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pAddr != NULL)
		if ((pAddr->nAddrType != CC_IP_BINARY) ||
			(pAddr->bMulticast == TRUE))
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// Make sure that hChannel is a bidirectional channel that was
	// not opened locally and hasn't already been accepted or rejected
	if ((pChannel->bChannelType != TXRX_CHANNEL) ||
		(pChannel->tsAccepted != TS_UNKNOWN) ||
		(pChannel->bLocallyOpened == TRUE)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// If the remote endpoint specified a channel address, it will
	// be contained in the SeparateStack field, and we are not
	// allowed to specify another address in pAddr;
	// if the remote endpoint did not specify a channel address,
	// we must specify one now
	if (((pChannel->pSeparateStack == NULL) && (pAddr == NULL)) ||
	    ((pChannel->pSeparateStack != NULL) && (pAddr != NULL))) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// Add the SeparateStack field to the channel, if necessary
	if (pAddr != NULL) {
		SeparateStack.bit_mask = distribution_present;
		SeparateStack.distribution.choice = unicast_chosen;
		if (pExternalReference != NULL)	{
			SeparateStack.bit_mask |= externalReference_present;
			SeparateStack.externalReference.length = pExternalReference->wOctetStringLength;
			memcpy(SeparateStack.externalReference.value,
				   pExternalReference->pOctetString,
				   pExternalReference->wOctetStringLength);
		}
		SeparateStack.networkAddress.choice = localAreaAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.choice = unicastAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.choice = UnicastAddress_iPAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier =
			pAddr->Addr.IP_Binary.wPort;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.length = 4;
		HostToH245IPNetwork(SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value,
							pAddr->Addr.IP_Binary.dwAddr);
		SeparateStack.associateConference = (char) bAssociateConference;
		pSeparateStack = &SeparateStack;
		AddSeparateStackToChannel(pSeparateStack, pChannel);
	} else
		pSeparateStack = NULL;

    // Send an ACK to the endpoint which requested the channel
	status = LockCall(pChannel->hCall, &pCall);
	if (status != CC_OK) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	H245MuxTable.Kind = H245_H2250ACK;
	H245MuxTable.u.H2250ACK.nonStandardList = NULL;
	H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;
	H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;
	H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
	H245MuxTable.u.H2250ACK.sessionIDPresent = FALSE;

	status = H245OpenChannelAccept(pCall->H245Instance,	// dwInst
								   0,					// dwTransId
								   pChannel->wRemoteChannelNumber, // remote channel
								   &H245MuxTable,			// Rx Mux
								   pChannel->wLocalChannelNumber,	// local channel
								   NULL,					// Tx mux
								   H245_INVALID_PORT_NUMBER,// Port
								   pSeparateStack);
	if (status != CC_OK) {
 		FreeChannel(pChannel);
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}
	pChannel->tsAccepted = TS_TRUE;
	--(pChannel->wNumOutstandingRequests);
	UnlockCall(pCall);

	// If we're the MC in a multipoint conference, forward the
	// open T.120 channel request to all other endpoints in the conference
	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != pChannel->hCall) {
				if (LockCall(CallList[i], &pCall) == CC_OK) {
					status = H245OpenChannel(pCall->H245Instance,		// H245 instance
											 pChannel->hChannel,		// dwTransId
											 pChannel->wLocalChannelNumber,
											 pChannel->pTxH245TermCap,	// TxMode
											 pChannel->pTxMuxTable,		// TxMux
											 H245_INVALID_PORT_NUMBER,	// TxPort
											 pChannel->pRxH245TermCap,	// RxMode
											 pChannel->pRxMuxTable,		// RxMux
											 pChannel->pSeparateStack);
					UnlockCall(pCall);
				}
			}
		}
		MemFree(CallList);
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
}


				
CC_API
HRESULT CC_CallListen(				PCC_HLISTEN				phListen,
									PCC_ADDR				pListenAddr,
									PCC_ALIASNAMES			pLocalAliasNames,
									DWORD_PTR				dwListenToken,
									CC_LISTEN_CALLBACK		ListenCallback)
{
HRESULT		status;
PLISTEN		pListen;
HQ931LISTEN	hQ931Listen;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phListen == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	// set phListen now, in case we encounter an error
	*phListen = CC_INVALID_HANDLE;

	if (pListenAddr == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateAddr(pListenAddr);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasNames(pLocalAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	if (ListenCallback == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = SetQ931Port(pListenAddr);
 	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = AllocAndLockListen(phListen,
								pListenAddr,
								0,				// hQ931Listen
								pLocalAliasNames,
								dwListenToken,
								ListenCallback,
								&pListen);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// Unlock the listen object to prevent deadlock when calling Q931
	UnlockListen(pListen);

	status = Q931Listen(&hQ931Listen, pListenAddr,
						(DWORD)*phListen, (Q931_CALLBACK)Q931Callback);
	if (status != CS_OK) {
		if (LockListen(*phListen, &pListen) == CC_OK)
			FreeListen(pListen);
		*phListen = CC_INVALID_HANDLE;
		LeaveCallControlTop(status);
	}

	status = LockListen(*phListen, &pListen);
	if (status != CC_OK) {
		Q931CancelListen(hQ931Listen);
		LeaveCallControlTop(status);
	}

	ASSERT(pListenAddr != NULL);
	ASSERT(pListenAddr->nAddrType == CC_IP_BINARY);

	pListen->hQ931Listen = hQ931Listen;
	// Copy the binary form of the listen address into the listen object
	pListen->ListenAddr = *pListenAddr;

#ifdef    GATEKEEPER

    if (GkiOpenListen(*phListen,
					   pLocalAliasNames,
					   pListenAddr->Addr.IP_Binary.dwAddr,
					   pListenAddr->Addr.IP_Binary.wPort) != NOERROR)
    {
        WARNING_OUT(("CC_CallListen - Gatekeeper init failed (GkiOpenListen), but still support H.323 calls"));
    }

    UnlockListen(pListen);
   
#else
	status = UnlockListen(pListen);
#endif // GATEKEEPER

	LeaveCallControlTop(status);
}


CC_API
HRESULT CC_EnableGKRegistration(
    BOOL fEnable,
    PSOCKADDR_IN pAddr,
    PCC_ALIASNAMES pLocalAliasNames,
    PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration,
    RASNOTIFYPROC pRasNotifyProc)
{
    HRESULT			status = CC_OK;
    if(!pRasNotifyProc)
       	return CC_BAD_PARAM;
       	
    gpRasNotifyProc = pRasNotifyProc;

   	EnterCallControlTop();
    if(fEnable)
    {
        ASSERT(pLocalAliasNames && pAddr && pVendorInfo);
        if(!pLocalAliasNames || !pAddr)
       		LeaveCallControlTop(CC_BAD_PARAM);
       		
        status = GkiSetRegistrationAliases(pLocalAliasNames);
        if(status != CC_OK)
		    LeaveCallControlTop(status);
		
        status = GkiSetVendorConfig(pVendorInfo, dwMultipointConfiguration);
        if(status != CC_OK)
		    LeaveCallControlTop(status);		
		
		GKI_SetGKAddress(pAddr);
        GkiListenAddr(pAddr);
        status = GkiRegister();
        fGKEnabled = TRUE;
    }
    else
    {
        status = GkiUnregister();
        fGKEnabled = FALSE;
        GkiSetRegistrationAliases(NULL);
        GkiSetVendorConfig(NULL, 0);
    }
	LeaveCallControlTop(status);
}


CC_API
HRESULT CC_CancelCall(				CC_HCALL				hCall)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
HRESULT			SaveStatus;
H245_INST_T		H245Instance;
HQ931CALL		hQ931Call;
WORD			wNumCalls;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pCall->CallState != ENQUEUED) &&
		(pCall->CallState != PLACED) &&
		(pCall->CallState != RINGING) &&
		(pCall->CallState != TERMCAP)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	if (pCall->GkiCall.uGkiCallState != 0)
    	{
	    	GkiCloseCall(&pCall->GkiCall);
    	}
    }
#endif // GATEKEEPER

	H245Instance = pCall->H245Instance;
	hQ931Call = pCall->hQ931Call;
	FreeCall(pCall);

	if (H245Instance != H245_INVALID_ID)
		SaveStatus = H245ShutDown(H245Instance);
	else
		SaveStatus = H245_ERROR_OK;
	
	if (hQ931Call != 0) {
		if (SaveStatus == H245_ERROR_OK) {
			SaveStatus = Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			// Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
			// may have been deleted at this point
			if (SaveStatus == CS_BAD_PARAM)
				SaveStatus = CC_OK;
		} else
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
	}

	for ( ; ; ) {
		// Start up an enqueued call, if one exists
		status = RemoveEnqueuedCallFromConference(pConference, &hCall);
		if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hCall, &pCall);
		if (status == CC_OK) {
			pCall->CallState = PLACED;

			status = PlaceCall(pCall, pConference);
			UnlockCall(pCall);
			if (status == CC_OK)
				break;
		}
	}

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
				(pConference->tsMultipointController != TS_TRUE))
				ReInitializeConference(pConference);
			UnlockConference(pConference);
		}
	} else {
		UnlockConference(pConference);
	}
	if (SaveStatus != CC_OK)
		status = SaveStatus;

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_CancelListen(			CC_HLISTEN				hListen)
{
HRESULT		status;
PLISTEN		pListen;
HQ931LISTEN	hQ931Listen;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hListen == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockListen(hListen, &pListen);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	hQ931Listen = pListen->hQ931Listen;

	// Unlock the listen object to prevent deadlock when calling Q931
	UnlockListen(pListen);

#ifdef    GATEKEEPER
   	status = GkiCloseListen(hListen);
#endif // GATEKEEPER

	status = Q931CancelListen(hQ931Listen);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = LockListen(hListen, &pListen);
	if (status == CC_OK) {
		LeaveCallControlTop(FreeListen(pListen));
	} else
		LeaveCallControlTop(status);
}



CC_API
HRESULT CC_CloseChannel(			CC_HCHANNEL				hChannel)
{
HRESULT		status;
HRESULT		SaveStatus = CC_OK;
PCHANNEL	pChannel;
PCONFERENCE	pConference;
PCALL		pCall;
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;
BOOL		bChannelCloseRequest;
CC_HCALL	hCall;
#ifdef    GATEKEEPER
unsigned    uBandwidth = 0;
#endif // GATEKEEPER

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pChannel->tsAccepted != TS_TRUE) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(status);
	}

	if ((pChannel->bChannelType == RX_CHANNEL) ||
		(pChannel->bChannelType == PROXY_CHANNEL) ||
		((pChannel->bChannelType == TXRX_CHANNEL) &&
		 (pChannel->bLocallyOpened == FALSE))) {
		// Generate a channel close request
		bChannelCloseRequest = TRUE;
	} else {
		bChannelCloseRequest = FALSE;
		while (DequeueRequest(&pChannel->pCloseRequests, &hCall) == CC_OK) {
			if (LockCall(hCall, &pCall) == CC_OK) {
				H245CloseChannelReqResp(pCall->H245Instance,
										H245_ACC,
										pChannel->wLocalChannelNumber);
				UnlockCall(pCall);
			}
		}
#ifdef    GATEKEEPER
        if(GKIExists())
        {
            if (pChannel->bChannelType != TXRX_CHANNEL)
            {
                if (pChannel->bMultipointChannel)
                {
                    // Multicast channel bandwidth is assigned to arbitrary call
    	            uBandwidth = pChannel->dwChannelBitRate / 100;
                }
                else
                {
                    // Channel bandwidth is assigned to a specific call
                    ASSERT(pChannel->hCall != CC_INVALID_HANDLE);
    		        if (LockCall(pChannel->hCall, &pCall) == CC_OK)
    		        {
    			        SaveStatus = GkiCloseChannel(&pCall->GkiCall, pChannel->dwChannelBitRate, hChannel);
    			        UnlockCall(pCall);
                    }
                }
            }
        }
#endif // GATEKEEPER
	}

	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			if (bChannelCloseRequest) {
				if ((pChannel->bChannelType != PROXY_CHANNEL) ||
					(pChannel->hCall == pCall->hCall)) {
					// Note that dwTransID is set to the call handle of
					// the peer who initiated the close channel request.
					// When the close channel response is received,
					// the dwTransID gives us back the call handle to which
					// the response must be forwarded. In this case,
					// the local endpoint initiated the close channel request,
					// so we'll use CC_INVALID_HANDLE as the dwTransId
					// to note this fact.
					status = H245CloseChannelReq(pCall->H245Instance,	// H245 instance
												 CC_INVALID_HANDLE,		// dwTransId
												 pChannel->wRemoteChannelNumber);
				}
			} else {
				status = H245CloseChannel(pCall->H245Instance,	// H245 instance
										  0,					// dwTransId
										  pChannel->wLocalChannelNumber);
#ifdef    GATEKEEPER
                if(GKIExists())
                {
                    if (uBandwidth && uBandwidth <= pCall->GkiCall.uBandwidthUsed)
                    {
                        // Since the bandwidth is multicast, only subtract it from
                        // a single call (does not really matter which one)
    				    SaveStatus = GkiCloseChannel(&pCall->GkiCall, pChannel->dwChannelBitRate, hChannel);
    				    if (SaveStatus == CC_OK)
    				        uBandwidth = 0;
                    }
                }
#endif // GATEKEEPER
			}
			// Note that this channel may not have been accepted on all of the calls,
			// so we could get an H245_ERROR_INVALID_CHANNEL error
			if ((status != H245_ERROR_OK) && (status != H245_ERROR_INVALID_CHANNEL))
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	if (pChannel->bChannelType == PROXY_CHANNEL) {
		// If this is a PROXY channel, keep the channel object around
		// until the channel owner closes it
		pChannel->tsAccepted = TS_FALSE;
		UnlockChannel(pChannel);
	} else {
		// FreeChannel(pChannel);
		// this is asynchronously released in _ConfClose(), in h245man.c
	}
	UnlockConference(pConference);
	LeaveCallControlTop(SaveStatus);
}



CC_API
HRESULT CC_CloseChannelResponse(	CC_HCHANNEL				hChannel,
									BOOL					bWillCloseChannel)
{
HRESULT			status;
PCHANNEL		pChannel;
PCONFERENCE		pConference;
CC_HCALL		hCall;
PCALL			pCall;
H245_ACC_REJ_T	AccRej;
WORD			wNumRequests;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (((pChannel->bChannelType != TX_CHANNEL) &&
		 (pChannel->bChannelType != TXRX_CHANNEL)) ||
	     (pChannel->bLocallyOpened == FALSE)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (bWillCloseChannel)
		AccRej = H245_ACC;
	else
		AccRej = H245_REJ;

	wNumRequests = 0;
	while (DequeueRequest(&pChannel->pCloseRequests, &hCall) == CC_OK) {
		wNumRequests++;
		if (LockCall(hCall, &pCall) == CC_OK) {
			H245CloseChannelReqResp(pCall->H245Instance,
									AccRej,
									pChannel->wLocalChannelNumber);
			UnlockCall(pCall);
		}
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);

	if (wNumRequests == 0)
		status = CC_BAD_PARAM;
	else
		status = CC_OK;

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_ChangeConferenceCapabilities(
									CC_HCONFERENCE			hConference,
									PCC_TERMCAPLIST			pTermCapList,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors)
{
HRESULT		status;
PCONFERENCE	pConference;
PCALL		pCall;
PCC_HCALL	CallList;
WORD		wNumCalls;
WORD		i;
BOOL		bConferenceTermCapsChanged;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pTermCapList == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateTermCapList(pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateTermCapDescriptors(pTermCapDescriptors, pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pConference->LocalEndpointAttached == DETACHED) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = UnregisterTermCapListFromH245(pConference,
										   pConference->pLocalH245TermCapList);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	DestroyH245TermCapList(&pConference->pLocalH245TermCapList);
	status = CopyH245TermCapList(&pConference->pLocalH245TermCapList,
								 pTermCapList);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	status = UnregisterTermCapDescriptorsFromH245(pConference,
												  pConference->pLocalH245TermCapDescriptors);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	DestroyH245TermCapDescriptors(&pConference->pLocalH245TermCapDescriptors);
	// create a new descriptor list if one was not supplied
	if (pTermCapDescriptors == NULL)
		status = CreateH245DefaultTermCapDescriptors(&pConference->pLocalH245TermCapDescriptors,
													 pConference->pLocalH245TermCapList);
	else
		// make a local copy of pTermCapDescriptors
		status = CopyH245TermCapDescriptors(&pConference->pLocalH245TermCapDescriptors,
											pTermCapDescriptors);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else
		bConferenceTermCapsChanged = TRUE;

	if (bConferenceTermCapsChanged) {
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				SendTermCaps(pCall, pConference);
				UnlockCall(pCall);
			}
		}
		if (CallList != NULL)
			MemFree(CallList);
	}

	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_CreateConference(		PCC_HCONFERENCE			phConference,
									PCC_CONFERENCEID		pConferenceID,
									DWORD					dwConferenceConfiguration,
									PCC_TERMCAPLIST			pTermCapList,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors,
									PCC_VENDORINFO			pVendorInfo,
									PCC_OCTETSTRING			pTerminalID,
									DWORD_PTR				dwConferenceToken,
									CC_TERMCAP_CONSTRUCTOR	TermCapConstructor,
									CC_SESSIONTABLE_CONSTRUCTOR	SessionTableConstructor,
									CC_CONFERENCE_CALLBACK	ConferenceCallback)
{
PCONFERENCE				pConference;
HRESULT					status;
BOOL					bMultipointCapable;
BOOL					bForceMultipointController;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phConference == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	// set phConference now, in case we encounter an error
	*phConference = CC_INVALID_HANDLE;

	bMultipointCapable =
		(dwConferenceConfiguration & CC_CONFIGURE_MULTIPOINT_CAPABLE) != 0 ? TRUE : FALSE;
	bForceMultipointController =
		(dwConferenceConfiguration & CC_CONFIGURE_FORCE_MC) != 0 ? TRUE : FALSE;

	if ((bMultipointCapable == FALSE) &&
		(bForceMultipointController == TRUE))
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pTermCapList == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateTermCapList(pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateTermCapDescriptors(pTermCapDescriptors, pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pVendorInfo == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateVendorInfo(pVendorInfo);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateTerminalID(pTerminalID);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (ConferenceCallback == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (SessionTableConstructor == NULL)
		SessionTableConstructor = DefaultSessionTableConstructor;

	if (TermCapConstructor == NULL)
		TermCapConstructor = DefaultTermCapConstructor;

	status = AllocAndLockConference(phConference,
									pConferenceID,
									bMultipointCapable,
									bForceMultipointController,
									pTermCapList,
									pTermCapDescriptors,
									pVendorInfo,
									pTerminalID,
									dwConferenceToken,
									SessionTableConstructor,
									TermCapConstructor,
									ConferenceCallback,
									&pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	LeaveCallControlTop(UnlockConference(pConference));
}



CC_API
HRESULT CC_DestroyConference(		CC_HCONFERENCE			hConference,
									BOOL					bAutoAccept)
{
HRESULT					status;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = AsynchronousDestroyConference(hConference, bAutoAccept);

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_EnumerateConferences(	PWORD					pwNumConferences,
									CC_HCONFERENCE			ConferenceList[])
{
HRESULT	status;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if ((*pwNumConferences != 0) && (ConferenceList == NULL))
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((*pwNumConferences == 0) && (ConferenceList != NULL))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = EnumerateConferences(pwNumConferences, ConferenceList);

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_FlowControl(				CC_HCHANNEL				hChannel,
									DWORD					dwRate)
{
HRESULT		status;
PCHANNEL	pChannel;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		((pChannel->bChannelType != RX_CHANNEL) &&
		 (pChannel->bChannelType != PROXY_CHANNEL)) ||
		(pChannel->tsAccepted != TS_TRUE)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = LockCall(pChannel->hCall, &pCall);
	if (status != CC_OK) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	status = H245FlowControl(pCall->H245Instance,
							 H245_SCOPE_CHANNEL_NUMBER,
							 pChannel->wRemoteChannelNumber,
							 0,			// wResourceID, not used here
							 dwRate);	// H245_NO_RESTRICTION if no restriction

	UnlockCall(pCall);
	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}


CC_API
HRESULT CC_GetCallControlVersion(	WORD					wArraySize,
									PWSTR					pszVersion)
{
WCHAR	pszCCversion[256];
WCHAR	pszQ931version[256];

	EnterCallControlTop();

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (wArraySize == 0)
		LeaveCallControlTop(CC_BAD_PARAM);
	if (pszVersion == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	wcscpy(pszCCversion, L"Call Control ");
	wcscat(pszCCversion, Unicode(__DATE__));
	wcscat(pszCCversion, L" ");
	wcscat(pszCCversion, Unicode(__TIME__));
	wcscat(pszCCversion, L"\n");
	Q931GetVersion(sizeof(pszQ931version)/sizeof(WCHAR), pszQ931version);
	wcscat(pszCCversion, pszQ931version);

	if (wcslen(pszCCversion) >= wArraySize) {
		memcpy(pszVersion, pszCCversion, (wArraySize-1)*sizeof(WCHAR));
		pszVersion[wArraySize-1] = L'\0';
		LeaveCallControlTop(CC_BAD_SIZE);
	}

	wcscpy(pszVersion, pszCCversion);
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_GetConferenceAttributes(	CC_HCONFERENCE				hConference,
									PCC_CONFERENCEATTRIBUTES	pConferenceAttributes)
{
HRESULT		status;
PCONFERENCE	pConference;
WORD		wNumCalls;
BOOL		bLocallyAttached;
PCC_HCALL	CallList;
PCALL		pCall;
WORD		wLimit;
WORD		wIndex;
WORD		wOctetStringLength;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pConferenceAttributes == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	pConferenceAttributes->bMaster =
		(pConference->tsMaster == TS_TRUE ? TRUE : FALSE);
	pConferenceAttributes->bMultipointController =
		(pConference->tsMultipointController == TS_TRUE ? TRUE : FALSE);
	pConferenceAttributes->bMultipointConference =
		(pConference->ConferenceMode == MULTIPOINT_MODE ? TRUE : FALSE);
	pConferenceAttributes->ConferenceID = pConference->ConferenceID;
	pConferenceAttributes->LocalTerminalLabel = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel;
	if (pConference->LocalEndpointAttached == ATTACHED)
		bLocallyAttached = TRUE;
	else
		bLocallyAttached = FALSE;
	if ((pConference->tsMultipointController == TS_TRUE) ||
		(pConference->ConferenceMode == POINT_TO_POINT_MODE))
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	else
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
	pConferenceAttributes->dwConferenceToken = pConference->dwConferenceToken;
	UnlockConference(pConference);
	if (bLocallyAttached)
		pConferenceAttributes->wNumCalls = (WORD)(wNumCalls + 1);
	else
		pConferenceAttributes->wNumCalls = wNumCalls;

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	pConferenceAttributes->dwBandwidthAllocated = 0;
    	pConferenceAttributes->dwBandwidthUsed      = 0;
    	for (wIndex = 0; wIndex < wNumCalls; ++wIndex) {
    		if (LockCall(CallList[wIndex], &pCall) == CC_OK) {
    			pConferenceAttributes->dwBandwidthAllocated += pCall->GkiCall.uBandwidthAllocated;
    			if (pConferenceAttributes->dwBandwidthAllocated > GKI_MAX_BANDWIDTH)
    				pConferenceAttributes->dwBandwidthAllocated = GKI_MAX_BANDWIDTH;
    			pConferenceAttributes->dwBandwidthUsed += pCall->GkiCall.uBandwidthUsed;
    			if (pConferenceAttributes->dwBandwidthUsed > GKI_MAX_BANDWIDTH)
    				pConferenceAttributes->dwBandwidthUsed = GKI_MAX_BANDWIDTH;
    			UnlockCall(pCall);
    		}
    	}
        pConferenceAttributes->dwBandwidthAllocated *= 100;
        pConferenceAttributes->dwBandwidthUsed      *= 100;
    }
#endif // GATEKEEPER

	if (pConferenceAttributes->pParticipantList != NULL) {
		wLimit = pConferenceAttributes->pParticipantList->wLength;
		pConferenceAttributes->pParticipantList->wLength = 0;
		for (wIndex = 0; wIndex < wNumCalls; wIndex++) {
			if (LockCall(CallList[wIndex], &pCall) == CC_OK) {
				if (pCall->pPeerParticipantInfo != NULL) {
					if (pConferenceAttributes->pParticipantList->wLength < wLimit) {
						pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalLabel =
							pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						if ((pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID) &&
							(pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength != 0) &&
							(pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString != NULL) &&
							(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString != NULL)) {
							if (pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength <
							    pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength) {
								wOctetStringLength = pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength;
							} else {
								wOctetStringLength = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength;
								pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength =	wOctetStringLength;
							}
							memcpy(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString,
								   pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
								   wOctetStringLength);
						} else {
							pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength = 0;
							pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString = NULL;								
						}
					}
					pConferenceAttributes->pParticipantList->wLength++;
				}
				UnlockCall(pCall);
			}
		}
		if (bLocallyAttached) {
			if (LockConference(hConference, &pConference) == CC_OK) {
				if (pConferenceAttributes->pParticipantList->wLength < wLimit) {
					pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalLabel =
						pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel;
					if ((pConference->LocalParticipantInfo.TerminalIDState == TERMINAL_ID_VALID) &&
						(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength != 0) &&
						(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString != NULL) &&
						(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString != NULL)) {
						if (pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength <
							pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength) {
							wOctetStringLength = pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength;
						} else {
							wOctetStringLength = pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength;
							pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength =	wOctetStringLength;
						}
						memcpy(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString,
							   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
							   wOctetStringLength);
					} else {
						pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength = 0;
						pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString = NULL;								
					}
				}
				pConferenceAttributes->pParticipantList->wLength++;
				UnlockConference(pConference);
			}
		}
	}
	
	if (CallList != NULL)
		MemFree(CallList);

	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_H245ConferenceRequest(	CC_HCALL				hCall,
									H245_CONFER_REQ_ENUM_T	RequestType,
									CC_TERMINAL_LABEL		TerminalLabel)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((RequestType != H245_REQ_MAKE_ME_CHAIR) &&
		(RequestType != H245_REQ_CANCEL_MAKE_ME_CHAIR) &&
		(RequestType != H245_REQ_DROP_TERMINAL) &&
		(RequestType != H245_REQ_ENTER_H243_TERMINAL_ID) &&
		(RequestType != H245_REQ_ENTER_H243_CONFERENCE_ID))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245ConferenceRequest(pCall->H245Instance,
								   RequestType,
								   TerminalLabel.bMCUNumber,
								   TerminalLabel.bTerminalNumber);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245ConferenceResponse(	CC_HCALL				hCall,
									H245_CONFER_RSP_ENUM_T	ResponseType,
									CC_TERMINAL_LABEL		CC_TerminalLabel,
									PCC_OCTETSTRING			pOctetString,
									CC_TERMINAL_LABEL		*pCC_TerminalList,
									WORD					wTerminalListCount)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
WORD			i;
TerminalLabel	*pH245TerminalList;
BYTE			*pH245OctetString;
BYTE			bH245OctetStringLength;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((ResponseType != H245_RSP_CONFERENCE_ID) &&
		(ResponseType != H245_RSP_PASSWORD) &&
		(ResponseType != H245_RSP_VIDEO_COMMAND_REJECT) &&
		(ResponseType != H245_RSP_TERMINAL_DROP_REJECT) &&
		(ResponseType != H245_RSP_DENIED_CHAIR_TOKEN) &&
		(ResponseType != H245_RSP_GRANTED_CHAIR_TOKEN))
		LeaveCallControlTop(CC_BAD_PARAM);

	if (wTerminalListCount != 0)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pCC_TerminalList == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateOctetString(pOctetString);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pOctetString != NULL)
		if (pOctetString->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (wTerminalListCount == 0) {
		pH245TerminalList = NULL;
	} else {
		pH245TerminalList = (TerminalLabel *)MemAlloc(sizeof(TerminalLabel) * wTerminalListCount);
		if (pH245TerminalList == NULL) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(CC_NO_MEMORY);
		}

		for (i = 0; i < wTerminalListCount; i++) {
			pH245TerminalList[i].mcuNumber = pCC_TerminalList[i].bMCUNumber;
			pH245TerminalList[i].terminalNumber = pCC_TerminalList[i].bTerminalNumber;
		}
	}

	if (pOctetString == NULL) {
		pH245OctetString = NULL;
		bH245OctetStringLength = 0;
	} else {
		pH245OctetString = pOctetString->pOctetString;
		bH245OctetStringLength = (BYTE)pOctetString->wOctetStringLength;
	}

	status = H245ConferenceResponse(pCall->H245Instance,
									ResponseType,
									CC_TerminalLabel.bMCUNumber,
									CC_TerminalLabel.bTerminalNumber,
									pH245OctetString,
									bH245OctetStringLength,
									pH245TerminalList,
									wTerminalListCount);

	if (pH245TerminalList != NULL)
		MemFree(pH245TerminalList);
	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245ConferenceCommand(	CC_HCALL				hCall,
									CC_HCHANNEL				hChannel,
									H245_CONFER_CMD_ENUM_T	CommandType,
									CC_TERMINAL_LABEL		TerminalLabel)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
WORD		wChannelNumber;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((CommandType != H245_CMD_BROADCAST_CHANNEL) &&
		(CommandType != H245_CMD_CANCEL_BROADCAST_CHANNEL) &&
		(CommandType != H245_CMD_BROADCASTER) &&
		(CommandType != H245_CMD_CANCEL_BROADCASTER) &&
		(CommandType != H245_CMD_SEND_THIS_SOURCE) &&
		(CommandType != H245_CMD_CANCEL_SEND_THIS_SOURCE) &&
		(CommandType != H245_CMD_DROP_CONFERENCE))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (hChannel == CC_INVALID_HANDLE) {
		wChannelNumber = 1;
	} else {
		status = LockChannel(hChannel, &pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
		switch (pChannel->bChannelType) {
			case TX_CHANNEL:
				wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			case RX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case TXRX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case PROXY_CHANNEL:
				if (pChannel->hCall == hCall)
					wChannelNumber = pChannel->wRemoteChannelNumber;
				else
					wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			default:
				ASSERT(0);
				break;
		}
		UnlockChannel(pChannel);
	}

	status = H245ConferenceCommand(pCall->H245Instance,
								   CommandType,
								   wChannelNumber,
								   TerminalLabel.bMCUNumber,
								   TerminalLabel.bTerminalNumber);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245ConferenceIndication(CC_HCALL				hCall,
									H245_CONFER_IND_ENUM_T	IndicationType,
									BYTE					bSBENumber,
									CC_TERMINAL_LABEL		TerminalLabel)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((IndicationType != H245_IND_SBE_NUMBER) &&
		(IndicationType != H245_IND_SEEN_BY_ONE_OTHER) &&
		(IndicationType != H245_IND_CANCEL_SEEN_BY_ONE_OTHER) &&
		(IndicationType != H245_IND_SEEN_BY_ALL) &&
		(IndicationType != H245_IND_CANCEL_SEEN_BY_ALL) &&
		(IndicationType != H245_IND_TERMINAL_YOU_ARE_SEEING) &&
		(IndicationType != H245_IND_REQUEST_FOR_FLOOR))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245ConferenceIndication(pCall->H245Instance,
									  IndicationType,
									  bSBENumber,
									  TerminalLabel.bMCUNumber,
									  TerminalLabel.bTerminalNumber);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245MiscellaneousCommand(CC_HCALL				hCall,
									CC_HCHANNEL				hChannel,
									MiscellaneousCommand	*pMiscellaneousCommand)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
WORD		wChannelNumber;
PDU_T		Pdu;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pMiscellaneousCommand == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((pMiscellaneousCommand->type.choice == multipointModeCommand_chosen) ||
		(pMiscellaneousCommand->type.choice == cnclMltpntMdCmmnd_chosen))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (hChannel == CC_INVALID_HANDLE) {
		wChannelNumber = 1;
	} else {
		status = LockChannel(hChannel, &pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
		switch (pChannel->bChannelType) {
			case TX_CHANNEL:
				wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			case RX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case TXRX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case PROXY_CHANNEL:
				if (pChannel->hCall == hCall)
					wChannelNumber = pChannel->wRemoteChannelNumber;
				else
					wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			default:
				ASSERT(0);
				break;
		}
		UnlockChannel(pChannel);
	}

	// Construct an H.245 PDU to hold a miscellaneous command
	Pdu.choice = MSCMg_cmmnd_chosen;
	Pdu.u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
	Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand = *pMiscellaneousCommand;
	Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber = wChannelNumber;

	status = H245SendPDU(pCall->H245Instance,	// H245 instance
						 &Pdu);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245MiscellaneousIndication(
									CC_HCALL				hCall,
									CC_HCHANNEL				hChannel,
									MiscellaneousIndication	*pMiscellaneousIndication)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
WORD		wChannelNumber;
PDU_T		Pdu;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pMiscellaneousIndication == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((pMiscellaneousIndication->type.choice == logicalChannelActive_chosen) ||
		(pMiscellaneousIndication->type.choice == logicalChannelInactive_chosen))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (hChannel == CC_INVALID_HANDLE) {
		wChannelNumber = 1;
	} else {
		status = LockChannel(hChannel, &pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
		switch (pChannel->bChannelType) {
			case TX_CHANNEL:
				wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			case RX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case TXRX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case PROXY_CHANNEL:
				if (pChannel->hCall == hCall)
					wChannelNumber = pChannel->wRemoteChannelNumber;
				else
					wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			default:
				ASSERT(0);
				break;
		}
		UnlockChannel(pChannel);
	}

	// Construct an H.245 PDU to hold a miscellaneous indication
	Pdu.choice = indication_chosen;
	Pdu.u.indication.choice = miscellaneousIndication_chosen;
	Pdu.u.indication.u.miscellaneousIndication = *pMiscellaneousIndication;
	Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber = wChannelNumber;

	status = H245SendPDU(pCall->H245Instance,	// H245 instance
						 &Pdu);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_Hangup(					CC_HCONFERENCE			hConference,
									BOOL					bTerminateConference,
									DWORD_PTR				dwUserToken)
{
HRESULT						status;
HRESULT						SaveStatus;
HHANGUP						hHangup;
PHANGUP						pHangup;
PCHANNEL					pChannel;
PCALL						pCall;
PCONFERENCE					pConference;
CC_HANGUP_CALLBACK_PARAMS	HangupCallbackParams;
HQ931CALL					hQ931Call;
WORD						wNumChannels;
PCC_HCHANNEL				ChannelList;
WORD						wNumCalls;
PCC_HCALL					CallList;
WORD						i;
H245_INST_T					H245Instance;
CALLSTATE					CallState;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// If the local endpoint is not attached, we will only allow a hangup if
	// the local endpoint is the MC in a multipoint conference and
	// conference termination is being requested
	if ((pConference->LocalEndpointAttached != ATTACHED) &&
		((bTerminateConference == FALSE) ||
		 (pConference->ConferenceMode != MULTIPOINT_MODE) ||
		 (pConference->tsMultipointController != TS_TRUE))) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	HangupCallbackParams.dwUserToken = dwUserToken;

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE) &&
		(bTerminateConference == FALSE)) {

		// Send TerminalLeftConference (this call) to all established calls
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				H245ConferenceIndication(pCall->H245Instance,
										 H245_IND_TERMINAL_LEFT,	// Indication Type
										 0,							// SBE number; ignored here
										 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,		 // MCU number
										 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber); // terminal number
				UnlockCall(pCall);
			}
		}
		if (CallList != NULL)
			MemFree(CallList);

		// Delete all TX, RX and bi-directional channels on this conference
		// Leave PROXY_CHANNELs intact
		EnumerateChannelsInConference(&wNumChannels,
									  &ChannelList,
									  pConference,
									  TX_CHANNEL | RX_CHANNEL | TXRX_CHANNEL);
		for (i = 0; i < wNumChannels; i++) {
			if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
				// Notice that since we're going to hangup, we don't need to
				// close any channels
				FreeChannel(pChannel);	
		}
		if (ChannelList != NULL)
			MemFree(ChannelList);

		if (pConference->bDeferredDelete)
        {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		}
        else
        {
            //
            // Set DETACHED _before_ callback; that will call
            // CC_DestroyConference, which will call AsynchronousDestroyConference,
            // which will not do anything if we are still sttached.
            //
            if (pConference->LocalEndpointAttached != DETACHED)
            {
                pConference->LocalEndpointAttached = DETACHED;
                if (pConference->ConferenceCallback)
                {
                    pConference->ConferenceCallback(CC_HANGUP_INDICATION, CC_OK,
                        pConference->hConference, pConference->dwConferenceToken,
                        &HangupCallbackParams);
                }
            }

            if (ValidateConference(hConference) == CC_OK)
            {
	   			UnlockConference(pConference);
        	}
		}
		LeaveCallControlTop(CC_OK);
	}

	status = EnumerateChannelsInConference(&wNumChannels,
										   &ChannelList,
										   pConference,
										   ALL_CHANNELS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// free all the channels
	for (i = 0; i < wNumChannels; i++) {
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
			// Notice that since we're going to hangup, we don't need to
			// close any channels
			FreeChannel(pChannel);	
	}
	if (ChannelList != NULL)
		MemFree(ChannelList);

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, REAL_CALLS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_FALSE) &&
		(bTerminateConference == TRUE)) {
		ASSERT(wNumCalls == 1);
		
		if (LockCall(CallList[0], &pCall) == CC_OK) {
			// Send DropConference command to MC
			H245ConferenceCommand   (
						 pCall->H245Instance,
						 H245_CMD_DROP_CONFERENCE, // Command type
						 1,			// Channel
						 0,			// byMcuNumber
						 0);		// byTerminalNumber
			UnlockCall(pCall);
		}
	}

	status = AllocAndLockHangup(&hHangup,
								hConference,
								dwUserToken,
								&pHangup);
	if (status != CC_OK) {
	    if (CallList != NULL)
		    MemFree(CallList);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// Now close all calls
	SaveStatus = H245_ERROR_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			H245Instance = pCall->H245Instance;
			hQ931Call = pCall->hQ931Call;
			CallState = pCall->CallState;
			FreeCall(pCall);
			if (CallState != ENQUEUED) {
				if (H245Instance != H245_INVALID_ID) {
					status = H245ShutDown(H245Instance);
					if (status == H245_ERROR_OK)
						pHangup->wNumCalls++;
					else
						// The link may already be shut down; if so, don't return an error
						if (status != LINK_INVALID_STATE)
							SaveStatus = status;
				}
				if (SaveStatus == H245_ERROR_OK) {
					if ((CallState == PLACED) ||
						(CallState == RINGING))
						SaveStatus = Q931RejectCall(hQ931Call,
													CC_REJECT_UNDEFINED_REASON,
													&pConference->ConferenceID,
													NULL,	// alternate address
													NULL);	// pNonStandardData
					else
						SaveStatus = Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
					// Q931Hangup may legitimately return CS_BAD_PARAM or LINK_INVALID_STATE,
					// because the Q.931 call object may have been deleted at this point
					if ((SaveStatus == CS_BAD_PARAM) ||
						(SaveStatus == LINK_INVALID_STATE))
						SaveStatus = CC_OK;
				} else
					if ((CallState == PLACED) ||
						(CallState == RINGING))
						Q931RejectCall(hQ931Call,
									   CC_REJECT_UNDEFINED_REASON,
									   &pConference->ConferenceID,
									   NULL,	// alternate address
									   NULL);	// pNonStandardData
					else
						Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
			}
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	// Need to validate the conference object; H245ShutDown may cause us to re-enter
	// Call Control, which may result in deletion of the conference object
	if (ValidateConference(hConference) != CC_OK)
		LeaveCallControlTop(SaveStatus);

	// Delete the virtual calls (if any)
	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
	for (i = 0; i < wNumCalls; i++)
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			FreeCall(pCall);
		}

	if (CallList != NULL)
		MemFree(CallList);

	// XXX -- for sync 2, H245ShutDown() is synchronous, so change wNumCalls
	// to cause the user callback and associated cleanup to occur synchronously
	pHangup->wNumCalls = 0;

	if (pHangup->wNumCalls == 0)
    {
		if (pConference->bDeferredDelete)
        {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		}
        else
        {
            //
            // Set DETACHED _before_ callback; that will call
            // CC_DestroyConference, which will call AsynchronousDestroyConference,
            // which will not do anything if we are still sttached.
            //
            if (pConference->LocalEndpointAttached != DETACHED)
            {
                pConference->LocalEndpointAttached = DETACHED;

                if (pConference->ConferenceCallback)
                {
                    pConference->ConferenceCallback(CC_HANGUP_INDICATION, SaveStatus,
                        pConference->hConference, pConference->dwConferenceToken,
                        &HangupCallbackParams);
                }
            }

  			if (ValidateConference(hConference) == CC_OK)
            {
	    		ReInitializeConference(pConference);
		    	UnlockConference(pConference);
    		}

		}

		if (ValidateHangup(hHangup) == CC_OK)
			FreeHangup(pHangup);
		LeaveCallControlTop(SaveStatus);
	} else {
		UnlockHangup(pHangup);
		LeaveCallControlTop(SaveStatus);
	}
}



CC_API
HRESULT CC_MaximumAudioVideoSkew(	CC_HCHANNEL				hChannelAudio,
									CC_HCHANNEL				hChannelVideo,
									WORD					wMaximumSkew)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannelAudio;
PCHANNEL	pChannelVideo;
PCC_HCALL	CallList;
WORD		wNumCalls;
WORD		i;
WORD		wNumSuccesses;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if ((hChannelAudio == CC_INVALID_HANDLE) || (hChannelVideo == CC_INVALID_HANDLE))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannelAudio, &pChannelAudio, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockChannel(hChannelVideo, &pChannelVideo);
	if (status != CC_OK) {
		UnlockChannel(pChannelAudio);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if ((pChannelAudio->hConference != pChannelVideo->hConference) ||
		(pChannelAudio->bChannelType != TX_CHANNEL) ||
		(pChannelAudio->wNumOutstandingRequests != 0) ||
		(pChannelVideo->bChannelType != TX_CHANNEL) ||
		(pChannelVideo->wNumOutstandingRequests != 0)) {
		UnlockChannel(pChannelAudio);
		UnlockChannel(pChannelVideo);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	wNumSuccesses = 0;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245H2250MaximumSkewIndication(pCall->H245Instance,
											        pChannelAudio->wLocalChannelNumber,
											        pChannelVideo->wLocalChannelNumber,
											        wMaximumSkew);
			UnlockCall(pCall);
			if (status == H245_ERROR_OK)
				wNumSuccesses++;
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	UnlockChannel(pChannelAudio);
	UnlockChannel(pChannelVideo);
	UnlockConference(pConference);
	if (wNumSuccesses == 0) {
		LeaveCallControlTop(status);
	} else {
		LeaveCallControlTop(CC_OK);
	}
}



CC_API
HRESULT CC_Mute(					CC_HCHANNEL				hChannel)
{
HRESULT		status;
HRESULT		SaveStatus;
PCHANNEL	pChannel;
PCONFERENCE	pConference;
PCALL		pCall;
PDU_T		Pdu;
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pChannel->bChannelType != TX_CHANNEL) {
		// can only mute transmit channels
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(status);
	}

	// Construct an H.245 PDU to hold a miscellaneous indication
	// of "logical channel inactive"
	Pdu.choice = indication_chosen;
	Pdu.u.indication.choice = miscellaneousIndication_chosen;
	Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
		pChannel->wLocalChannelNumber;
	Pdu.u.indication.u.miscellaneousIndication.type.choice = logicalChannelInactive_chosen;

	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245SendPDU(pCall->H245Instance,	// H245 instance
								 &Pdu);
			// Note that this channel may not have been accepted on all of the calls,
			// so we could get an H245_ERROR_INVALID_CHANNEL error
			if ((status != H245_ERROR_OK) && (status != H245_ERROR_INVALID_CHANNEL))
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	UnlockConference(pConference);
	UnlockChannel(pChannel);
	LeaveCallControlTop(SaveStatus);
}



CC_API
HRESULT CC_OpenChannel(				CC_HCONFERENCE			hConference,
									PCC_HCHANNEL			phChannel,
									BYTE					bSessionID,
									BYTE					bAssociatedSessionID,
									BOOL					bSilenceSuppression,
									PCC_TERMCAP				pTermCap,
									PCC_ADDR				pLocalRTCPAddr,
									BYTE					bDynamicRTPPayloadType,
									DWORD					dwChannelBitRate,
									DWORD_PTR				dwUserToken)
{
HRESULT		status;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
CC_HCALL	hCall;
PCALL		pCall;
H245_MUX_T	H245MuxTable;
WORD		i;
PCC_ADDR	pLocalRTPAddr;
PCC_ADDR	pPeerRTPAddr;
PCC_ADDR	pPeerRTCPAddr;
BOOL		bFoundSession;
WORD		wNumCalls;
PCC_HCALL	CallList;
//#ifndef GATEKEEPER
HRESULT		SaveStatus;
//#endif // !GATEKEEPER

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phChannel == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	// set phChannel now, in case we encounter an error
	*phChannel = CC_INVALID_HANDLE;
	
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pLocalRTCPAddr != NULL)
		if (pLocalRTCPAddr->nAddrType != CC_IP_BINARY)
			LeaveCallControlTop(CC_BAD_PARAM);
	
	if (pTermCap == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((bDynamicRTPPayloadType != 0) &&
		((bDynamicRTPPayloadType < 96) || (bDynamicRTPPayloadType > 127)))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConferenceEx(hConference,
							  &pConference,
							  TS_FALSE);	// bDeferredDelete
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// XXX -- we may eventually want to support dynamic session generation
	if (bSessionID == 0)
		if ((pConference->tsMaster == TS_TRUE) ||
			(pConference->ConferenceMode == MULTIPOINT_MODE)) {
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}

	if (((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pLocalRTCPAddr != NULL)) ||
		((pConference->ConferenceMode != MULTIPOINT_MODE) &&
		(pLocalRTCPAddr == NULL))) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->ConferenceMode == MULTIPOINT_MODE) {
		// XXX -- We should be able to dynamically create a new session if needed
		// Validate session ID
		pLocalRTPAddr = NULL;
		pLocalRTCPAddr = NULL;
		bFoundSession = FALSE;
		if (pConference->pSessionTable != NULL) {
			for (i = 0; i < pConference->pSessionTable->wLength; i++) {
				if (bSessionID == pConference->pSessionTable->SessionInfoArray[i].bSessionID) {
					bFoundSession = TRUE;
					if (pConference->tsMultipointController == TS_TRUE) {
						pLocalRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
						pLocalRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
					}
					break;
				}
			}
		}
		if (bFoundSession == FALSE) {
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}
		pPeerRTPAddr = pLocalRTPAddr;
		pPeerRTCPAddr = pLocalRTCPAddr;
	} else {
		pLocalRTPAddr = NULL;
		pPeerRTPAddr = NULL;
		pPeerRTCPAddr = NULL;
	}

	H245MuxTable.Kind = H245_H2250;
	H245MuxTable.u.H2250.nonStandardList = NULL;
	if (pLocalRTPAddr != NULL) {
		if (pLocalRTPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaChannel.u.ip.tsapIdentifier =
			pLocalRTPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaChannel.u.ip.network,
							pLocalRTPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaChannelPresent = FALSE;
	if (pLocalRTCPAddr != NULL) {
		if (pLocalRTCPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaControlChannel.u.ip.tsapIdentifier =
			pLocalRTCPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaControlChannel.u.ip.network,
							pLocalRTCPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaControlChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaControlChannelPresent = FALSE;

	if (bDynamicRTPPayloadType == 0)
		H245MuxTable.u.H2250.dynamicRTPPayloadTypePresent = FALSE;
	else {
		H245MuxTable.u.H2250.dynamicRTPPayloadTypePresent = TRUE;
		H245MuxTable.u.H2250.dynamicRTPPayloadType = bDynamicRTPPayloadType;
	}
	H245MuxTable.u.H2250.sessionID = bSessionID;
	if (bAssociatedSessionID == 0)
		H245MuxTable.u.H2250.associatedSessionIDPresent = FALSE;
	else {
		H245MuxTable.u.H2250.associatedSessionIDPresent = TRUE;
		H245MuxTable.u.H2250.associatedSessionID = bAssociatedSessionID;
	}
	H245MuxTable.u.H2250.mediaGuaranteed = FALSE;
	H245MuxTable.u.H2250.mediaGuaranteedPresent = TRUE;
	H245MuxTable.u.H2250.mediaControlGuaranteed = FALSE;
	H245MuxTable.u.H2250.mediaControlGuaranteedPresent = TRUE;
	// The silence suppression field must be present if and only if
	// the channel is an audio channel
	if (pTermCap->DataType == H245_DATA_AUDIO) {
		H245MuxTable.u.H2250.silenceSuppressionPresent = TRUE;
		H245MuxTable.u.H2250.silenceSuppression = (char) bSilenceSuppression;
	} else
		H245MuxTable.u.H2250.silenceSuppressionPresent = FALSE;

	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)
		H245MuxTable.u.H2250.destinationPresent = FALSE;
	else {
		H245MuxTable.u.H2250.destinationPresent = TRUE;
		H245MuxTable.u.H2250.destination.mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
		H245MuxTable.u.H2250.destination.terminalNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber;
	}

	H245MuxTable.u.H2250.h261aVideoPacketization = FALSE;

	// Set hCall in the channel object to indicate which call object
	// the channel is being opened to; if we're in multipoint mode,
	// the channel may be opened to multiple calls, to set hCall
	// to CC_INVALID_HANDLE. If the channel is opened in point-to-point
	// mode, and we later switch to multipoint mode and this peer hangs
	// up, hCall will be used to determine whether this call object
	// should be deleted
	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)	{
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		ASSERT(wNumCalls == 1);
		hCall = CallList[0];
		MemFree(CallList);
	} else {
		hCall = CC_INVALID_HANDLE;
	}

	status = AllocAndLockChannel(phChannel,
								 pConference,
								 hCall,				// hCall
								 pTermCap,			// Tx term cap
								 NULL,				// Rx term cap
								 &H245MuxTable,		// Tx mux table
								 NULL,				// Rx mux table
								 NULL,				// separate stack
								 dwUserToken,
								 TX_CHANNEL,
								 bSessionID,
								 bAssociatedSessionID,
								 0,					// remote channel number
								 pLocalRTPAddr,
								 pLocalRTCPAddr,
								 pPeerRTPAddr,
								 pPeerRTCPAddr,
								 TRUE,				// locally opened
								 &pChannel);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	status = AddChannelToConference(pChannel, pConference);
	if (status != CC_OK) {
		FreeChannel(pChannel);
		UnlockConference(pConference);
		*phChannel = CC_INVALID_HANDLE;
		LeaveCallControlTop(status);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		FreeChannel(pChannel);
		UnlockConference(pConference);
		*phChannel = CC_INVALID_HANDLE;
		LeaveCallControlTop(status);
	}

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	pChannel->dwChannelBitRate = dwChannelBitRate;
    	UnlockChannel(pChannel);
    	UnlockConference(pConference);
        // If point-to-point mode, than wNumCalls == 1 and CallList[0] == hCall
        // If multipoint, choice of which channel to assign TX bandwidth to
        // is arbitrary. Either way, CallList[0] works.
    	status = LockCall(CallList[0], &pCall);
    	if (status == CC_OK)
    	{
    		status = GkiOpenChannel(&pCall->GkiCall, dwChannelBitRate, *phChannel, TX);
        	if (ValidateCall(CallList[0]) == CC_OK)
    	    	UnlockCall(pCall);
    	}
    	MemFree(CallList);
    	LeaveCallControlTop(status);
    }
    else
    {
        SaveStatus = CC_OK;
    	for (i = 0; i < wNumCalls; i++)
    	{
    		if (LockCall(CallList[i], &pCall) == CC_OK)
    		{
    			status = H245OpenChannel(pCall->H245Instance,		// H245 instance
    									 pChannel->hChannel,		// dwTransId
    									 pChannel->wLocalChannelNumber,
    									 pChannel->pTxH245TermCap,	// TxMode
    									 pChannel->pTxMuxTable,		// TxMux
    									 H245_INVALID_PORT_NUMBER,	// TxPort
    									 pChannel->pRxH245TermCap,	// RxMode
    									 pChannel->pRxMuxTable,		// RxMux
    									 pChannel->pSeparateStack);
    			if (status == H245_ERROR_OK)
    				(pChannel->wNumOutstandingRequests)++;
    			else
    				SaveStatus = status;
    			UnlockCall(pCall);
    		}
    	}
    	
    	if (CallList != NULL)
    		MemFree(CallList);
    		
    	if (pChannel->wNumOutstandingRequests == 0)
    	{
    		// all open channel requests failed
    		FreeChannel(pChannel);
    		UnlockConference(pConference);
    		*phChannel = CC_INVALID_HANDLE;
    		LeaveCallControlTop(SaveStatus);
    	}

    	UnlockChannel(pChannel);
    	UnlockConference(pConference);
    	LeaveCallControlTop(CC_OK);
    }
#else  // GATEKEEPER
	// Open a logical channel for each established call
	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245OpenChannel(pCall->H245Instance,		// H245 instance
									 pChannel->hChannel,		// dwTransId
									 pChannel->wLocalChannelNumber,
									 pChannel->pTxH245TermCap,	// TxMode
									 pChannel->pTxMuxTable,		// TxMux
									 H245_INVALID_PORT_NUMBER,	// TxPort
									 pChannel->pRxH245TermCap,	// RxMode
									 pChannel->pRxMuxTable,		// RxMux
									 pChannel->pSeparateStack);
			if (status == H245_ERROR_OK)
				(pChannel->wNumOutstandingRequests)++;
			else
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	if (pChannel->wNumOutstandingRequests == 0) {
		// all open channel requests failed
		FreeChannel(pChannel);
		UnlockConference(pConference);
		*phChannel = CC_INVALID_HANDLE;
		LeaveCallControlTop(SaveStatus);
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
#endif // GATEKEEPER

}



HRESULT CC_OpenT120Channel(			CC_HCONFERENCE			hConference,
                           			PCC_HCHANNEL			phChannel,
									BOOL					bAssociateConference,
									PCC_OCTETSTRING			pExternalReference,
									PCC_ADDR				pAddr,
									DWORD					dwChannelBitRate,
									DWORD_PTR				dwUserToken)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
PCHANNEL		pChannel;
H245_MUX_T		H245MuxTable;
CC_TERMCAP		TermCap;
H245_ACCESS_T	SeparateStack;
H245_ACCESS_T	*pSeparateStack;
BYTE			bSessionID;
WORD			wNumCalls;
PCC_HCALL		CallList;
HRESULT			SaveStatus;
int				i;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	if (pAddr != NULL)
		if ((pAddr->nAddrType != CC_IP_BINARY) ||
            (pAddr->bMulticast == TRUE))
			LeaveCallControlTop(CC_BAD_PARAM);

	if (pExternalReference != NULL)
		if (pExternalReference->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// Assume that T.120 channels are always opened with a session ID of 0
	bSessionID = 0;

	H245MuxTable.Kind = H245_H2250;
	H245MuxTable.u.H2250.nonStandardList = NULL;
	H245MuxTable.u.H2250.mediaChannelPresent = FALSE;
	H245MuxTable.u.H2250.mediaControlChannelPresent = FALSE;
	H245MuxTable.u.H2250.dynamicRTPPayloadTypePresent = FALSE;
	H245MuxTable.u.H2250.sessionID = bSessionID;
	H245MuxTable.u.H2250.associatedSessionIDPresent = FALSE;
	H245MuxTable.u.H2250.mediaGuaranteedPresent = FALSE;
	H245MuxTable.u.H2250.mediaControlGuaranteedPresent = FALSE;
	H245MuxTable.u.H2250.silenceSuppressionPresent = FALSE;
	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)
		H245MuxTable.u.H2250.destinationPresent = FALSE;
	else {
		H245MuxTable.u.H2250.destinationPresent = TRUE;
		H245MuxTable.u.H2250.destination.mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
		H245MuxTable.u.H2250.destination.terminalNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber;
	}
	H245MuxTable.u.H2250.h261aVideoPacketization = FALSE;

	TermCap.Dir = H245_CAPDIR_LCLRXTX;
	TermCap.DataType = H245_DATA_DATA;
	TermCap.ClientType = H245_CLIENT_DAT_T120;
	TermCap.CapId = 0;
	TermCap.Cap.H245Dat_T120.maxBitRate = dwChannelBitRate;
	TermCap.Cap.H245Dat_T120.application.choice = DACy_applctn_t120_chosen;
	TermCap.Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice = separateLANStack_chosen;

	if (pAddr != NULL) {
		SeparateStack.bit_mask = distribution_present;
		SeparateStack.distribution.choice = unicast_chosen;
		if (pExternalReference != NULL)	{
			SeparateStack.bit_mask |= externalReference_present;
			SeparateStack.externalReference.length = pExternalReference->wOctetStringLength;
			memcpy(SeparateStack.externalReference.value,
				   pExternalReference->pOctetString,
				   pExternalReference->wOctetStringLength);
		}
		SeparateStack.networkAddress.choice = localAreaAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.choice = unicastAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.choice = UnicastAddress_iPAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier =
			pAddr->Addr.IP_Binary.wPort;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.length = 4;
		HostToH245IPNetwork(SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value,
							pAddr->Addr.IP_Binary.dwAddr);
		SeparateStack.associateConference = (char) bAssociateConference;
		pSeparateStack = &SeparateStack;
	} else {
		pSeparateStack = NULL;
	}
	
    status = AllocAndLockChannel(phChannel,
						         pConference,
						         CC_INVALID_HANDLE,	// hCall
						         &TermCap,			// Tx term cap
						         &TermCap,			// Rx term cap
						         &H245MuxTable,		// Tx mux table
						         &H245MuxTable,		// Rx mux table
						         pSeparateStack,	// separate stack
						         dwUserToken,
						         TXRX_CHANNEL,
						         bSessionID,
						         0,					// associated session ID
						         0,					// remote channel
								 NULL,				// local RTP addr
						         NULL,				// local RTCP addr
						         NULL,				// peer RTP addr
						         NULL,				// peer RTCP addr
								 TRUE,				// locally opened
						         &pChannel);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	pChannel->tsAccepted = TS_TRUE;

	status = AddChannelToConference(pChannel, pConference);
	if (status != CC_OK) {
		FreeChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245OpenChannel(pCall->H245Instance,		// H245 instance
									 pChannel->hChannel,		// dwTransId
									 pChannel->wLocalChannelNumber,
									 pChannel->pTxH245TermCap,	// TxMode
									 pChannel->pTxMuxTable,		// TxMux
									 H245_INVALID_PORT_NUMBER,	// TxPort
									 pChannel->pRxH245TermCap,	// RxMode
									 pChannel->pRxMuxTable,		// RxMux
									 pChannel->pSeparateStack);
			if (status == H245_ERROR_OK)
				(pChannel->wNumOutstandingRequests)++;
			else
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}
	MemFree(CallList);
	if (pChannel->wNumOutstandingRequests == 0) {
		// All open channel requests failed
		FreeChannel(pChannel);
		status = SaveStatus;
	} else {
		UnlockChannel(pChannel);
		status = CC_OK;
	}
	UnlockConference(pConference);

	LeaveCallControlTop(status);
}



HRESULT CC_Ping(					CC_HCALL				hCall,
									DWORD					dwTimeout)
{
PCALL			pCall;
HRESULT			status;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		LeaveCallControlTop(status);
	
	if ((pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// Set the T105 timeout value as specified by the user;
	// note that the previous timeout value is returned in this parameter
	H245SystemControl(0, H245_SYSCON_SET_FSM_T105, &dwTimeout);

	status = H245RoundTripDelayRequest(pCall->H245Instance,
									   0); // dwTransId

	// Reset the T105 timeout value to its original setting
	H245SystemControl(0, H245_SYSCON_SET_FSM_T105, &dwTimeout);

	UnlockCall(pCall);
	LeaveCallControlTop(status);
}


	
CC_API
HRESULT CC_PlaceCall(				CC_HCONFERENCE			hConference,
									PCC_HCALL				phCall,
									PCC_ALIASNAMES			pLocalAliasNames,
									PCC_ALIASNAMES			pCalleeAliasNames,
									PCC_ALIASNAMES			pCalleeExtraAliasNames,
									PCC_ALIASITEM			pCalleeExtension,
									PCC_NONSTANDARDDATA		pNonStandardData,
									PWSTR					pszDisplay,
									PCC_ADDR				pDestinationAddr,
									PCC_ADDR				pConnectAddr,
                                    DWORD                   dwBandwidth,
									DWORD_PTR				dwUserToken)
{
PCALL				pCall;
CC_HCALL            hCall;
PCONFERENCE			pConference;
HRESULT				status;
CALLTYPE			CallType = CALLER;
CALLSTATE			CallState = PLACED;
WORD				wNumCalls;
BOOL				bCallerIsMC;
GUID                CallIdent;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phCall == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	// set hCall now, in case we encounter an error
	*phCall = CC_INVALID_HANDLE;

	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = Q931ValidateAliasNames(pLocalAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasNames(pCalleeAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasNames(pCalleeExtraAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasItem(pCalleeExtension);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateDisplay(pszDisplay);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pDestinationAddr == NULL) &&
		(pConnectAddr == NULL) &&
		(pCalleeAliasNames == NULL))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateAddr(pDestinationAddr);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateAddr(pConnectAddr);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = SetQ931Port(pDestinationAddr);
 	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = SetQ931Port(pConnectAddr);
 	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = LockConferenceEx(hConference,
							  &pConference,
							  TS_FALSE);	// bDeferredDelete
	if (status != CC_OK)
		LeaveCallControlTop(status);

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls > 0) {
		if (pConference->tsMultipointController == TS_TRUE) {
			// Place Call directly to callee
			status = CC_OK;
			ASSERT(!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID));
			CallType = CALLER;
			CallState = PLACED;
		} else { // we're not the MC
			if (pConference->bMultipointCapable) {
				if (pConference->pMultipointControllerAddr != NULL) {
					// Place Call to MC
					status = CC_OK;
					if (pDestinationAddr == NULL)
						pDestinationAddr = pConnectAddr;
					pConnectAddr = pConference->pMultipointControllerAddr;
					ASSERT(!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID));
					CallType = THIRD_PARTY_INVITOR;
					CallState = PLACED;
				} else { // we don't have an MC address
					if (pConference->tsMaster == TS_UNKNOWN) {
						ASSERT(pConference->tsMultipointController == TS_UNKNOWN);
						status = CC_OK;
						CallType = CALLER;
						CallState = ENQUEUED;
					} else {
						ASSERT(pConference->tsMultipointController == TS_FALSE);
						// Error, no MC
						// XXX -- we may eventually want to enqueue the request
						// and set an expiration timer
						status = CC_NOT_MULTIPOINT_CAPABLE;
						CallType = THIRD_PARTY_INVITOR;
						CallState = ENQUEUED;
					}
				}
			} else { // we're not multipoint capable
				// Error - bad param
				ASSERT(wNumCalls == 1);
				status = CC_BAD_PARAM;
			}
		}
	} else { // wNumCalls == 0
		// Place Call directly to callee
		status = CC_OK;
		CallType = CALLER;
		CallState = PLACED;
	}
	
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (pConference->tsMultipointController == TS_TRUE)
		bCallerIsMC = TRUE;
	else
		bCallerIsMC = FALSE;


    // generate CallIdentifier
   	status = CoCreateGuid(&CallIdent);
    if(status != S_OK)
    {
        // forget what MSDN and other MS documentation says about this
        // -- If there is no net card, some rev's of OS return an error
        // in cases where a reasonable GUID is generated, but not GUARANTEED
        // to be GLOBALLY unique.
        // if that's not good enough, then just use the uninitialized
        // value of CallIdent - whatever was on the stack is our GUID!!
        // But I want to know in debug builds
        ASSERT(0);
    }
	status = AllocAndLockCall(&hCall,
							  hConference,
							  CC_INVALID_HANDLE,	// hQ931Call
							  CC_INVALID_HANDLE,	// hQ931CallInvitor
							  pLocalAliasNames,     // local alias names
							  pCalleeAliasNames,	// remote alias names
							  pCalleeExtraAliasNames,// remote extra alias names
							  pCalleeExtension,		// remote extension
							  pNonStandardData,		// local non-standard data
							  NULL,					// remote non-standard data
							  pszDisplay,			// local display
							  NULL,					// remote display
							  NULL,					// remote vendor info
							  NULL,					// local connect address
							  pConnectAddr,			// peer connect address
							  pDestinationAddr,		// peer destination address
                              NULL,                 // pSourceCallSignalAddress,
							  CallType,				// call type
							  bCallerIsMC,
							  dwUserToken,			// user token
							  CallState,			// call state
							  &CallIdent,           // H225 CallIdentifier
							  &pConference->ConferenceID,
							  &pCall);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	// Fill in Gatekeeper Call fields
    	memset(&pCall->GkiCall, 0, sizeof(pCall->GkiCall));

    	if (pCalleeAliasNames != NULL) {
    		// make a local copy of the peer alias names
    		status = Q931CopyAliasNames(&pCall->GkiCall.pCalleeAliasNames, pCalleeAliasNames);
    		if (status != CS_OK) {
    			FreeCall(pCall);
    			UnlockConference(pConference);
    			LeaveCallControlTop(status);
    		}
    	}

    	if (pCalleeExtraAliasNames != NULL) {
    		// make a local copy of the peer alias names
    		status = Q931CopyAliasNames(&pCall->GkiCall.pCalleeExtraAliasNames,
    									pCalleeExtraAliasNames);
    		if (status != CS_OK) {
    			FreeCall(pCall);
    			UnlockConference(pConference);
    			LeaveCallControlTop(status);
    		}
    	}

    	pCall->GkiCall.pCall            = pCall;
    	pCall->GkiCall.hCall            = hCall;
        pCall->GkiCall.pConferenceId    = pCall->ConferenceID.buffer;
    	pCall->GkiCall.bActiveMC        = pCall->bCallerIsMC;
    	pCall->GkiCall.bAnswerCall      = FALSE;
   		pCall->GkiCall.CallIdentifier   = pCall->CallIdentifier;
   		
    	if (pCall->pQ931PeerConnectAddr) {
    		pCall->GkiCall.dwIpAddress = ADDRToInetAddr(pCall->pQ931PeerConnectAddr);
    		pCall->GkiCall.wPort       = ADDRToInetPort(pCall->pQ931PeerConnectAddr);
    	} else if (pCall->pQ931DestinationAddr) {
    		pCall->GkiCall.dwIpAddress = ADDRToInetAddr(pCall->pQ931DestinationAddr);
    		pCall->GkiCall.wPort       = ADDRToInetPort(pCall->pQ931DestinationAddr);
    	}
        if (pCall->GkiCall.wPort == 0)
            pCall->GkiCall.wPort = CC_H323_HOST_CALL;
    	pCall->GkiCall.wPort = (WORD)((pCall->GkiCall.wPort<<8)|(pCall->GkiCall.wPort>>8));

    	if (pConference->bMultipointCapable)
    		pCall->GkiCall.CallType = MANY_TO_MANY;
    	else
    		pCall->GkiCall.CallType = POINT_TO_POINT;
        pCall->GkiCall.uBandwidthRequested = dwBandwidth / 100;

    	status = GkiOpenCall(&pCall->GkiCall, pConference);
        if (ValidateCall(hCall) == CC_OK) {
            if (status == CC_OK) {
    		    UnlockCall(pCall);
                *phCall = hCall;
            } else {
    		    FreeCall(pCall);
            }
    	}

    	if (ValidateConference(hConference) == CC_OK)
    	    UnlockConference(pConference);
    }
    else
    {
        // clean GkiCall structure just to be safe.
        memset(&pCall->GkiCall, 0, sizeof(pCall->GkiCall));
    	status = PlaceCall(pCall, pConference);
    	if (status == CC_OK)
    	{
    		UnlockCall(pCall);
            *phCall = hCall;
    	}
    	else
    	{
    		FreeCall(pCall);
	    }
	    UnlockConference(pConference);
    }
#else  // GATEKEEPER
	status = PlaceCall(pCall, pConference);
	if (status == CC_OK) {
		UnlockCall(pCall);
        *phCall = hCall;
	} else {
		FreeCall(pCall);
	}

	UnlockConference(pConference);
#endif // GATEKEEPER

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_RejectCall(				BYTE					bRejectReason,
									PCC_NONSTANDARDDATA		pNonStandardData,
									CC_HCALL				hCall)
{
HRESULT			status;
HRESULT			SaveStatus;
PCALL			pCall;
HQ931CALL		hQ931Call;
CC_CONFERENCEID	ConferenceID;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	SaveStatus = CC_OK;

	// validate parameters
	if ((bRejectReason != CC_REJECT_IN_CONF) &&
		(bRejectReason != CC_REJECT_UNDEFINED_REASON) &&
		(bRejectReason != CC_REJECT_DESTINATION_REJECTION) &&
		(bRejectReason != CC_REJECT_NO_ANSWER) &&
		(bRejectReason != CC_REJECT_NOT_IMPLEMENTED) &&
		(bRejectReason != CC_REJECT_SECURITY_DENIED) &&
		(bRejectReason != CC_REJECT_USER_BUSY)) {
		bRejectReason = CC_REJECT_UNDEFINED_REASON;
		SaveStatus = CC_BAD_PARAM;
	}

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		// note that we can't even tell Q931 to reject the call
		LeaveCallControlTop(status);

	if (pCall->CallState != INCOMING) {
		UnlockCall(pCall);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	hQ931Call = pCall->hQ931Call;
	ConferenceID = pCall->ConferenceID;
	FreeCall(pCall);
	Q931RejectCall(hQ931Call,			// Q931 call handle
				   bRejectReason,		// reject reason
				   &ConferenceID,
				   NULL,				// alternate address
				   pNonStandardData);	// non-standard data
	LeaveCallControlTop(SaveStatus);
}



CC_API
HRESULT CC_RejectChannel(			CC_HCHANNEL				hChannel,
									DWORD					dwRejectReason)

{
HRESULT		status;
PCHANNEL	pChannel;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((dwRejectReason != H245_REJ) &&
		(dwRejectReason != H245_REJ_TYPE_NOTSUPPORT) &&
		(dwRejectReason != H245_REJ_TYPE_NOTAVAIL) &&
		(dwRejectReason != H245_REJ_TYPE_UNKNOWN) &&
		(dwRejectReason != H245_REJ_AL_COMB) &&
		(dwRejectReason != H245_REJ_MULTICAST) &&
		(dwRejectReason != H245_REJ_SESSION_ID) &&
		(dwRejectReason != H245_REJ_MASTER_SLAVE_CONFLICT))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// Make sure that hChannel is a receive, proxy or bi-directional
	// channel that hasn't already been accepted
	if (((pChannel->bChannelType != RX_CHANNEL) &&
		 (pChannel->bChannelType != PROXY_CHANNEL) &&
		 (pChannel->bChannelType != TXRX_CHANNEL)) ||
		 (pChannel->tsAccepted != TS_UNKNOWN)) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	pChannel->tsAccepted = TS_FALSE;

	if (pChannel->wNumOutstandingRequests == 0) {
		ASSERT(pChannel->bMultipointChannel == TRUE);
		ASSERT(pChannel->bChannelType == PROXY_CHANNEL);
		ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
		ASSERT(pConference->tsMultipointController == TS_TRUE);
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(CC_OK);
	}

	(pChannel->wNumOutstandingRequests)--;

	if (pChannel->wNumOutstandingRequests == 0) {
		status = LockCall(pChannel->hCall, &pCall);
		if (status != CC_OK) {
			UnlockConference(pConference);
			FreeChannel(pChannel);
			LeaveCallControlTop(status);
		}

		status = H245OpenChannelReject(pCall->H245Instance,
									   pChannel->wRemoteChannelNumber,	// Rx channel
									   (WORD)dwRejectReason);			// rejection reason
		UnlockCall(pCall);
		FreeChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// Don't free the channel; it is a PROXY_CHANNEL and we're the MC,
	// so we need to keep the channel object around until the peer that
	// opened it closes it.
	ASSERT(pChannel->bMultipointChannel == TRUE);
	ASSERT(pChannel->bChannelType == PROXY_CHANNEL);
	ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
	ASSERT(pConference->tsMultipointController == TS_TRUE);
	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_RequestMode(				CC_HCALL				hCall,
									WORD					wNumModeDescriptions,
									ModeDescription			ModeDescriptions[])
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (wNumModeDescriptions == 0)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (ModeDescriptions == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245RequestMode(pCall->H245Instance,
							 pCall->H245Instance,	// trans ID
							 ModeDescriptions,
							 wNumModeDescriptions);

	UnlockCall(pCall);
	UnlockConference(pConference);

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_RequestModeResponse(		CC_HCALL				hCall,
									CC_REQUEST_MODE_RESPONSE RequestModeResponse)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
BOOL		bAccept;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	switch (RequestModeResponse) {
		case CC_WILL_TRANSMIT_PREFERRED_MODE:
			RequestModeResponse = wllTrnsmtMstPrfrrdMd_chosen;
			bAccept = TRUE;
			break;
		case CC_WILL_TRANSMIT_LESS_PREFERRED_MODE:
			RequestModeResponse = wllTrnsmtLssPrfrrdMd_chosen;
			bAccept = TRUE;
			break;
		case CC_MODE_UNAVAILABLE:
			RequestModeResponse = H245_REJ_UNAVAILABLE;
			bAccept = FALSE;
			break;
		case CC_MULTIPOINT_CONSTRAINT:
			RequestModeResponse = H245_REJ_MULTIPOINT;
			bAccept = FALSE;
			break;
		case CC_REQUEST_DENIED:
			RequestModeResponse = H245_REJ_DENIED;
			bAccept = FALSE;
			break;
		default:
			LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = DequeueSpecificRequest(&pConference->pEnqueuedRequestModeCalls,
									hCall);
	if (status != CC_OK) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (bAccept == TRUE) {
		status = H245RequestModeAck(pCall->H245Instance,
									(WORD)RequestModeResponse);
	} else {
		status = H245RequestModeReject(pCall->H245Instance,
									   (WORD)RequestModeResponse);
	}

	UnlockCall(pCall);
	UnlockConference(pConference);
	
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SendNonStandardMessage(	CC_HCALL				hCall,
									BYTE					bH245MessageType,
									CC_NONSTANDARDDATA		NonStandardData)
{
HRESULT					status;
PCALL					pCall;
PCONFERENCE				pConference;
H245_MESSAGE_TYPE_T		H245MessageType;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	switch (bH245MessageType) {
		case CC_H245_MESSAGE_REQUEST:
			H245MessageType = H245_MESSAGE_REQUEST;
			break;
		case CC_H245_MESSAGE_RESPONSE:
			H245MessageType = H245_MESSAGE_RESPONSE;
			break;
		case CC_H245_MESSAGE_COMMAND:
			H245MessageType = H245_MESSAGE_COMMAND;
			break;
		case CC_H245_MESSAGE_INDICATION:
			H245MessageType = H245_MESSAGE_INDICATION;
			break;
		default:
			LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = ValidateNonStandardData(&NonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockCallAndConference(hCall,
								   &pCall,
								   &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245NonStandardH221(pCall->H245Instance,
								 H245MessageType,
								 NonStandardData.sData.pOctetString,
								 NonStandardData.sData.wOctetStringLength,
								 NonStandardData.bCountryCode,
								 NonStandardData.bExtension,
								 NonStandardData.wManufacturerCode);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SendVendorID(			CC_HCALL				hCall,
									CC_NONSTANDARDDATA		NonStandardData,
									PCC_OCTETSTRING			pProductNumber,
									PCC_OCTETSTRING			pVersionNumber)
{
HRESULT					status;
PCALL					pCall;
PCONFERENCE				pConference;
BYTE					*pH245ProductNumber;
BYTE					bProductNumberLength;
BYTE					*pH245VersionNumber;
BYTE					bVersionNumberLength;
H245_NONSTANDID_T		H245Identifier;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateNonStandardData(&NonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateOctetString(pProductNumber);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pProductNumber != NULL)
		if (pProductNumber->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateOctetString(pVersionNumber);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pVersionNumber != NULL)
		if (pVersionNumber->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall,
								   &pCall,
								   &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	H245Identifier.choice = h221NonStandard_chosen;
	H245Identifier.u.h221NonStandard.t35CountryCode = NonStandardData.bCountryCode;
	H245Identifier.u.h221NonStandard.t35Extension = NonStandardData.bExtension;
	H245Identifier.u.h221NonStandard.manufacturerCode = NonStandardData.wManufacturerCode;

	if (pProductNumber == NULL) {
		pH245ProductNumber = NULL;
		bProductNumberLength = 0;
	} else {
		pH245ProductNumber = pProductNumber->pOctetString;
		bProductNumberLength = (BYTE)pProductNumber->wOctetStringLength;
	}

	if (pVersionNumber == NULL) {
		pH245VersionNumber = NULL;
		bVersionNumberLength = 0;
	} else {
		pH245VersionNumber = pVersionNumber->pOctetString;
		bVersionNumberLength = (BYTE)pVersionNumber->wOctetStringLength;
	}

	status = H245VendorIdentification(pCall->H245Instance,
									  &H245Identifier,
									  pH245ProductNumber,
									  bProductNumberLength,
									  pH245VersionNumber,
									  bVersionNumberLength);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SetCallControlTimeout(	WORD					wType,
									DWORD					dwDuration)
{
HRESULT	status;
DWORD	dwRequest;
DWORD	dwSaveDuration;

	EnterCallControlTop();

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	status = CC_OK;

	switch (wType) {
		case CC_Q931_ALERTING_TIMEOUT:
			status = Q931SetAlertingTimeout(dwDuration);
			break;
		case CC_H245_RETRY_COUNT:
			status = H245SystemControl(0, H245_SYSCON_SET_FSM_N100, &dwDuration);
			break;
		case CC_H245_TIMEOUT:
			dwRequest = H245_SYSCON_SET_FSM_T101;
			dwSaveDuration = dwDuration;
			while ((dwRequest <= H245_SYSCON_SET_FSM_T109) && (status == CC_OK)) {
				dwDuration = dwSaveDuration;
				// Note -- the following call resets dwDuration
				status = H245SystemControl(0, dwRequest, &dwDuration);
				dwRequest += (H245_SYSCON_SET_FSM_T102 - H245_SYSCON_SET_FSM_T101);
			}
			break;
		default :
			LeaveCallControlTop(CC_BAD_PARAM);
			break;
	}

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SetTerminalID(			CC_HCONFERENCE			hConference,
									PCC_OCTETSTRING			pTerminalID)
{
HRESULT		status;
PCONFERENCE	pConference;
CC_HCALL	hCall;
PCALL		pCall;

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	status = ValidateTerminalID(pTerminalID);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);
	
	if (pConference->LocalParticipantInfo.TerminalIDState == TERMINAL_ID_VALID) {
		pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_INVALID;
		MemFree(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString);
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
	}

	if ((pTerminalID == NULL) ||
		(pTerminalID->pOctetString == NULL) ||
		(pTerminalID->wOctetStringLength == 0)) {
		UnlockConference(pConference);
 		LeaveCallControlTop(CC_OK);
	}

	pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString =
		(BYTE *)MemAlloc(pTerminalID->wOctetStringLength);
	if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString == NULL) {
		UnlockConference(pConference);
 		LeaveCallControlTop(CC_NO_MEMORY);
	}

	memcpy(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
		   pTerminalID->pOctetString,
		   pTerminalID->wOctetStringLength);
	pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength =
		pTerminalID->wOctetStringLength;
	pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_VALID;

	while (DequeueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
						  &hCall) == CC_OK) {
		if (LockCall(hCall, &pCall) == CC_OK) {
   			H245ConferenceResponse(pCall->H245Instance,
								   H245_RSP_TERMINAL_ID,
								   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
								   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
								   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
								   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
								   NULL,					// terminal list
								   0);						// terminal list count
			UnlockCall(pCall);
		}
	}

	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_Shutdown()
{

	if (InitStatus != CC_OK)
		return InitStatus;
	if (CallControlState != OPERATIONAL_STATE)
		return CC_BAD_PARAM;
		
	// Don't allow any additional threads to enter this DLL
	CallControlState = SHUTDOWN_STATE;

	Q931DeInit();
	DeInitHangupManager();
	DeInitUserManager();
	DeInitQ931Manager();
	DeInitListenManager();
	DeInitH245Manager();
	DeInitChannelManager();
	DeInitCallManager();
	DeInitConferenceManager();
#ifdef    GATEKEEPER
	DeInitGkiManager();
#endif // GATEKEEPER
  	H225DeInit();
#ifdef FORCE_SERIALIZE_CALL_CONTROL	
    UnInitializeCCLock();
#endif
	return CC_OK;
}



CC_API
HRESULT CC_UnMute(					CC_HCHANNEL				hChannel)
{
HRESULT		status;
HRESULT		SaveStatus;
PCHANNEL	pChannel;
PCONFERENCE	pConference;
PCALL		pCall;
PDU_T		Pdu;
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pChannel->bChannelType != TX_CHANNEL) {
		// can only unmute transmit channels
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(status);
	}

	// Construct an H.245 PDU to hold a miscellaneous indication
	// of "logical channel active"
	Pdu.choice = indication_chosen;
	Pdu.u.indication.choice = miscellaneousIndication_chosen;
	Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
		pChannel->wLocalChannelNumber;
	Pdu.u.indication.u.miscellaneousIndication.type.choice = logicalChannelActive_chosen;

	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245SendPDU(pCall->H245Instance,	// H245 instance
								 &Pdu);
			// Note that this channel may not have been accepted on all of the calls,
			// so we could get an H245_ERROR_INVALID_CHANNEL error
			if ((status != H245_ERROR_OK) && (status != H245_ERROR_INVALID_CHANNEL))
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	UnlockConference(pConference);
	UnlockChannel(pChannel);
	LeaveCallControlTop(SaveStatus);
}


CC_API
HRESULT CC_UpdatePeerList(			CC_HCONFERENCE			hConference)
{
HRESULT						status;
PCONFERENCE					pConference;
PCALL						pCall;
WORD						wNumCalls;
WORD						i;
PCC_HCALL					CallList;
CC_PEER_ADD_CALLBACK_PARAMS	PeerAddCallbackParams;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
		(pConference->LocalEndpointAttached != ATTACHED)) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->tsMultipointController == TS_TRUE) {
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				if (pCall->pPeerParticipantInfo != NULL) {
					PeerAddCallbackParams.hCall = pCall->hCall;
					PeerAddCallbackParams.TerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
					if (pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)
						PeerAddCallbackParams.pPeerTerminalID =
							&pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
					else
						PeerAddCallbackParams.pPeerTerminalID = NULL;
					InvokeUserConferenceCallback(pConference,
												 CC_PEER_ADD_INDICATION,
												 CC_OK,
												 &PeerAddCallbackParams);
					if (ValidateCall(CallList[i]) == CC_OK)
						UnlockCall(pCall);
					if (ValidateConference(hConference) != CC_OK) {
						MemFree(CallList);
						LeaveCallControlTop(CC_OK);
					}
				} else // pCall->pPeerParticipantInfo == NULL
					UnlockCall(pCall);
			}
		}
		status = CC_OK;
	} else { // pConference->tsMultipointController != TS_TRUE
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				FreeCall(pCall);
			}
		}
		if (CallList != NULL)
			MemFree(CallList);
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		ASSERT((wNumCalls == 0) || (wNumCalls == 1));
		if (wNumCalls == 1) {
			if (LockCall(CallList[0], &pCall) == CC_OK) {
				// Send TerminalListRequest
				status = H245ConferenceRequest(pCall->H245Instance,
									  H245_REQ_TERMINAL_LIST,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);
				UnlockCall(pCall);
			}
		}
	}

	if (CallList != NULL)
		MemFree(CallList);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_UserInput(				CC_HCALL				hCall,
									PWSTR					pszUserInput)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pszUserInput == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (wcslen(pszUserInput) == 0)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245UserInput(pCall->H245Instance,
						   pszUserInput,
						   NULL);

	UnlockCall(pCall);
	UnlockConference(pConference);

	LeaveCallControlTop(status);
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\callman2.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callman2.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *	$Revision:   1.7  $
 *	$Date:   03 Jan 1997 16:28:04  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef GATEKEEPER

#ifndef CALLMAN2_H
#define CALLMAN2_H

#include "gkiman.h"

typedef HRESULT (*PGKICALLFUN)(PGKICALL pGkiCall, void *pConference);

// Additions to CALLMAN.C functionality
HRESULT LockGkiCallAndConference(	HANDLE					hGkiCall,
									PPGKICALL 				ppGkiCall,
									void * *				ppConference,
									PCC_HCALL				phCall,
									PCC_HCONFERENCE			phConference);
HRESULT UnlockGkiCallAndConference(	PGKICALL				pGkiCall,
									void *					pConference,
									CC_HCALL				hCall,
									CC_HCONFERENCE			hConference);
HRESULT LockGkiCall(HANDLE hGkiCall, PPGKICALL ppGkiCall);
HRESULT UnlockGkiCall(PGKICALL pGkiCall);

HRESULT ApplyToAllCalls(PGKICALLFUN pGkiCallFun);

// Complete CC_xxx Operations
HRESULT ListenReject        (CC_HLISTEN hListen, HRESULT Reason);
HRESULT PlaceCallConfirm    (void *pCallVoid, void *pConferenceVoid);
HRESULT PlaceCallReject     (void *pCallVoid, void *pConferenceVoid, HRESULT Reason);
HRESULT AcceptCallConfirm   (void *pCallVoid, void *pConferenceVoid);
HRESULT AcceptCallReject    (void *pCallVoid, void *pConferenceVoid, HRESULT Reason);

HRESULT OpenChannelConfirm  (CC_HCHANNEL hChannel);
HRESULT OpenChannelReject   (CC_HCHANNEL hChannel, HRESULT Reason);
HRESULT AcceptChannelConfirm(CC_HCHANNEL hChannel);
HRESULT AcceptChannelReject (CC_HCHANNEL hChannel, HRESULT Reason);

// Handle gratuitous messages from Gatekeeper
HRESULT Disengage           (void *pCallVoid);
HRESULT BandwidthShrunk     (void *pCallVoid,
                             void *pConferenceVoid,
                             unsigned uBandwidthAllocated,
                             long lBandwidthChange);

#endif // CALLMAN2_H

#endif // GATEKEEPER

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\callman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.69  $
 *	$Date:   24 Jan 1997 19:02:08  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "h245man.h"
#include "confman.h"
#include "callman.h"
#include "ccutils.h"
#include "callman2.h"


static BOOL		bCallInited = FALSE;

#define HASH_TABLE_SIZE	11

static struct {
	PCALL				pHead[HASH_TABLE_SIZE];
	LOCK				Lock;
} CallTable;

static struct {
	CC_HCALL			hCall;
	LOCK				Lock;
} CallHandle;

HRESULT _LockCallAndConferenceMarkedForDeletion(
									CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference);

HRESULT InitCallManager()
{
int		i;

	ASSERT(bCallInited == FALSE);

	for (i = 0; i < HASH_TABLE_SIZE; i++)
		CallTable.pHead[i] = NULL;
	InitializeLock(&CallTable.Lock);

	CallHandle.hCall = CC_INVALID_HANDLE + 1;
	InitializeLock(&CallHandle.Lock);

	bCallInited = TRUE;
	return CC_OK;
}



HRESULT DeInitCallManager()
{
HRESULT		status;
HRESULT		SaveStatus;
int			i;
PCALL		pCall;
PCALL		pNextCall;
H245_INST_T	H245Instance;

	if (bCallInited == FALSE)
		return CC_OK;

	SaveStatus = CC_OK;
	for (i = 0; i < HASH_TABLE_SIZE; i++) {
		pCall = CallTable.pHead[i];
		while (pCall != NULL) {
			AcquireLock(&pCall->Lock);
			pNextCall = pCall->pNextInTable;
			H245Instance = pCall->H245Instance;
			FreeCall(pCall);
#if(0)
The whole H.245 subsystem should be already be shut down and released
at this point.  Calling H245ShutDown() will attempt to lock a nonexistent H.245
instance struct via a critical section that has been deleted. It might also be a
good idea to fix InstanceLock to avoid the EnterCriticalSection if the instance is
obviously already nonexistent


			if (H245Instance != H245_INVALID_ID) {
				status = H245ShutDown(H245Instance);
				if (status != H245_ERROR_OK)
					SaveStatus = status;
			}
#endif
			pCall = pNextCall;
		}
	}

	DeleteLock(&CallHandle.Lock);
	DeleteLock(&CallTable.Lock);
	bCallInited = FALSE;
	return SaveStatus;
}



#define _Hash(hCall) ((DWORD)((hCall) % HASH_TABLE_SIZE))



HRESULT _AddCallToTable(			PCALL					pCall)
{
int	index;

	ASSERT(pCall != NULL);
	ASSERT(pCall->hCall != CC_INVALID_HANDLE);
	ASSERT(pCall->bInTable == FALSE);

	AcquireLock(&CallTable.Lock);

	index = _Hash(pCall->hCall);
	pCall->pNextInTable = CallTable.pHead[index];
	pCall->pPrevInTable = NULL;
	if (CallTable.pHead[index] != NULL)
		CallTable.pHead[index]->pPrevInTable = pCall;
	CallTable.pHead[index] = pCall;

	pCall->bInTable = TRUE;

	RelinquishLock(&CallTable.Lock);
	return CC_OK;
}



HRESULT _RemoveCallFromTable(		PCALL					pCall)
{
CC_HCALL	hCall;
int			index;
BOOL		bTimedOut;

	ASSERT(pCall != NULL);
	ASSERT(pCall->bInTable == TRUE);

	// Caller must have a lock on the call object;
	// in order to avoid deadlock, we must:
	//   1. unlock the Call object,
	//   2. lock the CallTable,
	//   3. locate the call object in the CallTable (note that
	//      after step 2, the call object may be deleted from the
	//      CallTable by another thread),
	//   4. lock the Call object (someone else may have the lock)
	//   5. remove the call object from the CallTable,
	//   6. unlock the CallTable
	//
	// The caller can now safely unlock and destroy the call object,
	// since no other thread will be able to find the object (its been
	// removed from the CallTable), and therefore no other thread will
	// be able to lock it.

	// Save the call handle; its the only way to look up
	// the call object in the CallTable. Note that we
	// can't use pCall to find the call object, since
	// pCall may be free'd up, and another call object
	// allocated at the same address
	hCall = pCall->hCall;

	// step 1
	RelinquishLock(&pCall->Lock);

step2:
	// step 2
	AcquireLock(&CallTable.Lock);

	index = _Hash(hCall);

	// step 3
	pCall = CallTable.pHead[index];
	while ((pCall != NULL) && (pCall->hCall != hCall))
		pCall = pCall->pNextInTable;

	if (pCall != NULL) {
		// step 4
		AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&CallTable.Lock);
			Sleep(0);
			goto step2;
		}

		// step 5
		if (pCall->pPrevInTable == NULL)
			CallTable.pHead[index] = pCall->pNextInTable;
		else
			pCall->pPrevInTable->pNextInTable = pCall->pNextInTable;

		if (pCall->pNextInTable != NULL)
			pCall->pNextInTable->pPrevInTable = pCall->pPrevInTable;

		pCall->pNextInTable = NULL;
		pCall->pPrevInTable = NULL;
		pCall->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&CallTable.Lock);

	if (pCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeCallHandle(			PCC_HCALL				phCall)
{
	AcquireLock(&CallHandle.Lock);
	*phCall = CallHandle.hCall++;
	RelinquishLock(&CallHandle.Lock);
	return CC_OK;
}



HRESULT AllocAndLockCall(			PCC_HCALL				phCall,
									CC_HCONFERENCE			hConference,
									HQ931CALL				hQ931Call,
									HQ931CALL				hQ931CallInvitor,
									PCC_ALIASNAMES			pLocalAliasNames,
									PCC_ALIASNAMES			pPeerAliasNames,
									PCC_ALIASNAMES			pPeerExtraAliasNames,
									PCC_ALIASITEM			pPeerExtension,
									PCC_NONSTANDARDDATA		pLocalNonStandardData,
									PCC_NONSTANDARDDATA		pPeerNonStandardData,
									PWSTR					pszLocalDisplay,
									PWSTR					pszPeerDisplay,
									PCC_VENDORINFO			pPeerVendorInfo,
									PCC_ADDR				pQ931LocalConnectAddr,
									PCC_ADDR				pQ931PeerConnectAddr,
									PCC_ADDR				pQ931DestinationAddr,
									PCC_ADDR                pSourceCallSignalAddress,
									CALLTYPE				CallType,
									BOOL					bCallerIsMC,
									DWORD_PTR				dwUserToken,
									CALLSTATE				InitialCallState,
									LPGUID                  pCallIdentifier,
									PCC_CONFERENCEID		pConferenceID,
									PPCALL					ppCall)
{
HRESULT		status;
	
	ASSERT(bCallInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phCall != NULL);
	ASSERT(ppCall != NULL);
	ASSERT(pConferenceID != NULL);

	// set phCall now, in case we encounter an error
	*phCall = CC_INVALID_HANDLE;

	*ppCall = (PCALL)MemAlloc(sizeof(CALL));
	if (*ppCall == NULL)
		return CC_NO_MEMORY;

   memset(*ppCall, 0, sizeof(CALL));
	(*ppCall)->bInTable = FALSE;
	(*ppCall)->hConference = hConference;
	(*ppCall)->hQ931Call = hQ931Call;
	(*ppCall)->hQ931CallInvitor = hQ931CallInvitor;
	(*ppCall)->pPeerParticipantInfo = NULL;
	(*ppCall)->bMarkedForDeletion = FALSE;
	(*ppCall)->H245Instance = H245_INVALID_ID;
	(*ppCall)->dwH245PhysicalID = 0;
	(*ppCall)->dwUserToken = dwUserToken;
	(*ppCall)->pLocalNonStandardData = NULL;
	(*ppCall)->pPeerNonStandardData = NULL;
	(*ppCall)->pQ931LocalConnectAddr = NULL;
	(*ppCall)->pQ931PeerConnectAddr = NULL;
	(*ppCall)->pQ931DestinationAddr = NULL;
	(*ppCall)->pSourceCallSignalAddress = NULL;
	(*ppCall)->pszLocalDisplay = NULL;
	(*ppCall)->pszPeerDisplay = NULL;
	(*ppCall)->pPeerVendorInfo = NULL;
	(*ppCall)->pLocalAliasNames = NULL;
	(*ppCall)->pPeerAliasNames = NULL;
	(*ppCall)->pPeerExtraAliasNames = NULL;
	(*ppCall)->pPeerExtension = NULL;
	(*ppCall)->OutgoingTermCapState = NEED_TO_SEND_TERMCAP;
	(*ppCall)->IncomingTermCapState = AWAITING_TERMCAP;
	(*ppCall)->MasterSlaveState = MASTER_SLAVE_NOT_STARTED;
	(*ppCall)->pPeerH245TermCapList = NULL;
	(*ppCall)->pPeerH245H2250MuxCapability = NULL;
	(*ppCall)->pPeerH245TermCapDescriptors = NULL;
	(*ppCall)->CallState = InitialCallState;
	(*ppCall)->ConferenceID = *pConferenceID;
	(*ppCall)->CallType = CallType;
	(*ppCall)->bCallerIsMC = bCallerIsMC;
	(*ppCall)->bLinkEstablished = FALSE;
	(*ppCall)->pNext = NULL;
	(*ppCall)->pPrev = NULL;
	(*ppCall)->pNextInTable = NULL;
	(*ppCall)->pPrevInTable = NULL;
	
    if(pCallIdentifier)
    {
        (*ppCall)->CallIdentifier = *pCallIdentifier;
    }

	InitializeLock(&(*ppCall)->Lock);
	AcquireLock(&(*ppCall)->Lock);

	status = _MakeCallHandle(&(*ppCall)->hCall);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}
	
	// make a local copy of the local non-standard data, if supplied
	status = CopyNonStandardData(&(*ppCall)->pLocalNonStandardData,
		                         pLocalNonStandardData);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}
	
	// make a local copy of the peer's non-standard data, if supplied
	status = CopyNonStandardData(&(*ppCall)->pPeerNonStandardData,
		                         pPeerNonStandardData);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}
	
	// make a copy of the local connect address, if supplied
	if (pQ931LocalConnectAddr != NULL) {
		(*ppCall)->pQ931LocalConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppCall)->pQ931LocalConnectAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pQ931LocalConnectAddr = *pQ931LocalConnectAddr;
	}

	// make a copy of the peer's connect address, if supplied
	if (pQ931PeerConnectAddr != NULL) {
		(*ppCall)->pQ931PeerConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppCall)->pQ931PeerConnectAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pQ931PeerConnectAddr = *pQ931PeerConnectAddr;
	}

	// make a copy of the destination address, if supplied
	if (pQ931DestinationAddr != NULL) {
		(*ppCall)->pQ931DestinationAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppCall)->pQ931DestinationAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pQ931DestinationAddr = *pQ931DestinationAddr;
	}

    // make a copy of the source call signal address, if supplied
	if (pSourceCallSignalAddress != NULL) {
		(*ppCall)->pSourceCallSignalAddress = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppCall)->pSourceCallSignalAddress == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pSourceCallSignalAddress = *pSourceCallSignalAddress;
	}

	// make a local copy of the local alias names
	status = Q931CopyAliasNames(&((*ppCall)->pLocalAliasNames), pLocalAliasNames);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	// make a local copy of the peer alias names
	status = Q931CopyAliasNames(&((*ppCall)->pPeerAliasNames), pPeerAliasNames);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	// make a local copy of the peer extra alias names
	status = Q931CopyAliasNames(&((*ppCall)->pPeerExtraAliasNames),
								pPeerExtraAliasNames);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	// make a local copy of the peer extension
	status = Q931CopyAliasItem(&((*ppCall)->pPeerExtension),
							   pPeerExtension);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	status = CopyDisplay(&(*ppCall)->pszLocalDisplay, pszLocalDisplay);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}

	status = CopyDisplay(&(*ppCall)->pszPeerDisplay, pszPeerDisplay);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}

	status = CopyVendorInfo(&(*ppCall)->pPeerVendorInfo, pPeerVendorInfo);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}

	*phCall = (*ppCall)->hCall;

	// add the Call to the Call table
	status = _AddCallToTable(*ppCall);
	if (status != CC_OK)
		FreeCall(*ppCall);
	
	return status;
}



// Caller must have a lock on the Call object
HRESULT FreeCall(					PCALL					pCall)
{
HRESULT		status;
CC_HCALL	hCall;
PCONFERENCE	pConference;

	ASSERT(pCall != NULL);

#ifdef    GATEKEEPER
    if(GKIExists())
    {
	    if (pCall->GkiCall.uGkiCallState != 0)
		    GkiCloseCall(&pCall->GkiCall);
    }
#endif // GATEKEEPER

	// caller must have a lock on the Call object,
	// so there's no need to re-lock it
	
	hCall = pCall->hCall;
	if (pCall->hConference != CC_INVALID_HANDLE) {
		UnlockCall(pCall);
		status = _LockCallAndConferenceMarkedForDeletion(hCall, &pCall, &pConference);
		if (status != CC_OK)
			return status;
	}

	if (pCall->bInTable == TRUE)
		if (_RemoveCallFromTable(pCall) == CC_BAD_PARAM)
			// the Call object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pCall->pPeerParticipantInfo != NULL) {
		if (pCall->CallType == VIRTUAL_CALL)
			FreePeerParticipantInfo(NULL, pCall->pPeerParticipantInfo);
		else
			FreePeerParticipantInfo(pConference, pCall->pPeerParticipantInfo);
	}

	// If the call object is associated with a conference object, deassociate it.
	if (pCall->hConference != CC_INVALID_HANDLE) {
		RemoveCallFromConference(pCall, pConference);
		UnlockConference(pConference);
	}

	if (pCall->pLocalNonStandardData != NULL)
		FreeNonStandardData(pCall->pLocalNonStandardData);

	if (pCall->pPeerNonStandardData != NULL)
		FreeNonStandardData(pCall->pPeerNonStandardData);

	if (pCall->pQ931LocalConnectAddr != NULL)
		MemFree(pCall->pQ931LocalConnectAddr);

	if (pCall->pQ931PeerConnectAddr != NULL)
		MemFree(pCall->pQ931PeerConnectAddr);

	if (pCall->pQ931DestinationAddr != NULL)
		MemFree(pCall->pQ931DestinationAddr);
		
	if (pCall->pSourceCallSignalAddress != NULL)
		MemFree(pCall->pSourceCallSignalAddress);

	if (pCall->pPeerH245TermCapList != NULL)
		DestroyH245TermCapList(&(pCall->pPeerH245TermCapList));

	if (pCall->pPeerH245H2250MuxCapability != NULL)
		DestroyH245TermCap(&(pCall->pPeerH245H2250MuxCapability));

	if (pCall->pPeerH245TermCapDescriptors != NULL)
		DestroyH245TermCapDescriptors(&(pCall->pPeerH245TermCapDescriptors));

	if (pCall->pLocalAliasNames != NULL)
		Q931FreeAliasNames(pCall->pLocalAliasNames);

	if (pCall->pPeerAliasNames != NULL)
		Q931FreeAliasNames(pCall->pPeerAliasNames);

	if (pCall->pPeerExtraAliasNames != NULL)
		Q931FreeAliasNames(pCall->pPeerExtraAliasNames);
	
	if (pCall->pPeerExtension != NULL)
		Q931FreeAliasItem(pCall->pPeerExtension);

	if (pCall->pszLocalDisplay != NULL)
		FreeDisplay(pCall->pszLocalDisplay);

	if (pCall->pszPeerDisplay != NULL)
		FreeDisplay(pCall->pszPeerDisplay);

	if (pCall->pPeerVendorInfo != NULL)
		FreeVendorInfo(pCall->pPeerVendorInfo);

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	if (pCall->GkiCall.uGkiCallState != 0)
	    	GkiFreeCall(&pCall->GkiCall);
	}
#endif // GATEKEEPER

	// Since the call object has been removed from the CallTable,
	// no other thread will be able to find the call object and obtain
	// a lock, so its safe to unlock the call object and delete it here
	RelinquishLock(&pCall->Lock);
	DeleteLock(&pCall->Lock);
	MemFree(pCall);
	return CC_OK;
}



HRESULT _LockQ931CallMarkedForDeletion(
									CC_HCALL				hCall,
									HQ931CALL				hQ931Call,
									PPCALL					ppCall)
{
int		index;
BOOL	bTimedOut;

	// If hCall != CC_INVALID_HANDLE, the search is based on hCall;
	// otherwise, the search is based on hQ931Call

	ASSERT(ppCall != NULL);

step1:
	AcquireLock(&CallTable.Lock);

	if (hCall != CC_INVALID_HANDLE) {
		index = _Hash(hCall);

		*ppCall = CallTable.pHead[index];
		while ((*ppCall != NULL) && ((*ppCall)->hCall != hCall))
			*ppCall = (*ppCall)->pNextInTable;
	} else {
		// Perform an exhaustive search based on hQ931Call
		for (index = 0; index < HASH_TABLE_SIZE; index++) {
			*ppCall = CallTable.pHead[index];
			while ((*ppCall != NULL) && ((*ppCall)->hQ931Call != hQ931Call))
				*ppCall = (*ppCall)->pNextInTable;
			if (*ppCall != NULL)
				break;
		}
	}

	if (*ppCall != NULL) {
		AcquireTimedLock(&(*ppCall)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&CallTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&CallTable.Lock);

	if (*ppCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockQ931Call(				CC_HCALL				hCall,
									HQ931CALL				hQ931Call,
									PPCALL					ppCall)
{
HRESULT	status;

	status = _LockQ931CallMarkedForDeletion(hCall, hQ931Call, ppCall);
	if (status != CC_OK)
		return status;
	if ((*ppCall)->bMarkedForDeletion) {
		UnlockCall(*ppCall);
		return CC_BAD_PARAM;
	}
	return CC_OK;
}



HRESULT LockCall(					CC_HCALL				hCall,
									PPCALL					ppCall)
{
	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);

	return LockQ931Call(hCall,	// Call Control call handle (used in this call)
		                0,		// Q931 call handle (ignored in this call)
						ppCall);
}



HRESULT _LockCallMarkedForDeletion(	CC_HCALL				hCall,
									PPCALL					ppCall)
{
	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);

	return _LockQ931CallMarkedForDeletion(hCall,	// Call Control call handle (used in this call)
										  0,		// Q931 call handle (ignored in this call)
										  ppCall);
}



HRESULT LockCallAndConference(		CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference)
{
HRESULT			status;
CC_HCONFERENCE	hConference;

	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);
	ASSERT(ppConference != NULL);

	status = LockCall(hCall, ppCall);
	if (status != CC_OK)
		return status;
	
	if ((*ppCall)->hConference == CC_INVALID_HANDLE) {
		UnlockCall(*ppCall);
		return CC_BAD_PARAM;
	}

	hConference = (*ppCall)->hConference;
	UnlockCall(*ppCall);

	status = LockConference(hConference, ppConference);
	if (status != CC_OK)
		return status;

	status = LockCall(hCall, ppCall);
	if (status != CC_OK) {
		UnlockConference(*ppConference);
		return status;
	}
	
	return CC_OK;
}



HRESULT _LockCallAndConferenceMarkedForDeletion(
									CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference)
{
HRESULT			status;
CC_HCONFERENCE	hConference;

	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);
	ASSERT(ppConference != NULL);

	status = _LockCallMarkedForDeletion(hCall, ppCall);
	if (status != CC_OK)
		return status;
	
	if ((*ppCall)->hConference == CC_INVALID_HANDLE) {
		UnlockCall(*ppCall);
		return CC_BAD_PARAM;
	}

	hConference = (*ppCall)->hConference;
	UnlockCall(*ppCall);

	status = LockConference(hConference, ppConference);
	if (status != CC_OK)
		return status;

	status = _LockCallMarkedForDeletion(hCall, ppCall);
	if (status != CC_OK) {
		UnlockConference(*ppConference);
		return status;
	}
	
	return CC_OK;
}



HRESULT MarkCallForDeletion(		PCALL					pCall)
{
	ASSERT(pCall != NULL);
	ASSERT(pCall->bMarkedForDeletion == FALSE);

	pCall->bMarkedForDeletion = TRUE;
	return CC_OK;
}



HRESULT ValidateCall(				CC_HCALL				hCall)
{
PCALL	pCall;
int		index;

	ASSERT(hCall != CC_INVALID_HANDLE);

	AcquireLock(&CallTable.Lock);

	index = _Hash(hCall);

	pCall = CallTable.pHead[index];
	while ((pCall != NULL) && (pCall->hCall != hCall))
		pCall = pCall->pNextInTable;

	if (pCall != NULL)
		if (pCall->bMarkedForDeletion == TRUE)
			pCall = NULL;

	RelinquishLock(&CallTable.Lock);

	if (pCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateCallMarkedForDeletion(
									CC_HCALL				hCall)
{
PCALL	pCall;
int		index;

	ASSERT(hCall != CC_INVALID_HANDLE);

	AcquireLock(&CallTable.Lock);

	index = _Hash(hCall);

	pCall = CallTable.pHead[index];
	while ((pCall != NULL) && (pCall->hCall != hCall))
		pCall = pCall->pNextInTable;

	RelinquishLock(&CallTable.Lock);

	if (pCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockCall(					PCALL					pCall)
{
	ASSERT(pCall != NULL);

	RelinquishLock(&pCall->Lock);
	return CC_OK;
}



HRESULT AddLocalNonStandardDataToCall(
									PCALL					pCall,
									PCC_NONSTANDARDDATA		pLocalNonStandardData)
{
HRESULT	status;

	ASSERT(pCall != NULL);

	if (pCall->pLocalNonStandardData != NULL)
		FreeNonStandardData(pCall->pLocalNonStandardData);
	status = CopyNonStandardData(&pCall->pLocalNonStandardData, pLocalNonStandardData);
	return status;
}



HRESULT AddLocalDisplayToCall(		PCALL					pCall,
									PWSTR					pszLocalDisplay)
{
HRESULT	status;

	ASSERT(pCall != NULL);

	if (pCall->pszLocalDisplay != NULL)
		FreeDisplay(pCall->pszLocalDisplay);
	status = CopyDisplay(&pCall->pszLocalDisplay, pszLocalDisplay);
	return status;
}



HRESULT AllocatePeerParticipantInfo(PCONFERENCE				pConference,
									PPARTICIPANTINFO		*ppPeerParticipantInfo)
{
HRESULT					status;
H245_TERMINAL_LABEL_T	H245TerminalLabel;

	ASSERT(ppPeerParticipantInfo != NULL);

	if (pConference == NULL) {
		H245TerminalLabel.mcuNumber = 0;
		H245TerminalLabel.terminalNumber = 0;
	} else {
		status = AllocateTerminalNumber(pConference, &H245TerminalLabel);
		if (status != CC_OK) {
			*ppPeerParticipantInfo = NULL;
			return status;
		}
	}

	*ppPeerParticipantInfo = (PPARTICIPANTINFO)MemAlloc(sizeof(PARTICIPANTINFO));
	if (*ppPeerParticipantInfo == NULL)
		return CC_NO_MEMORY;

	(*ppPeerParticipantInfo)->TerminalIDState = TERMINAL_ID_INVALID;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalLabel.bMCUNumber = (BYTE)H245TerminalLabel.mcuNumber;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalLabel.bTerminalNumber = (BYTE)H245TerminalLabel.terminalNumber;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalID.pOctetString = NULL;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalID.wOctetStringLength = 0;
	(*ppPeerParticipantInfo)->pEnqueuedRequestsForTerminalID = NULL;

	return CC_OK;
}



HRESULT FreePeerParticipantInfo(	PCONFERENCE				pConference,
									PPARTICIPANTINFO		pPeerParticipantInfo)
{
HRESULT				status = CC_OK;

	ASSERT(pPeerParticipantInfo != NULL);

	if (pConference != NULL)
		status = FreeTerminalNumber(pConference,
							        pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);

	while (DequeueRequest(&pPeerParticipantInfo->pEnqueuedRequestsForTerminalID, NULL) == CC_OK);

	if (pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString != NULL)
		MemFree(pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString);
	MemFree(pPeerParticipantInfo);
	return status;
}



#ifdef GATEKEEPER

HRESULT LockGkiCallAndConference(	HANDLE					hGkiCall,
									PGKICALL *				ppGkiCall,
									void * *				ppConference,
									DWORD_PTR * 			phCall,
									DWORD_PTR *				phConference)
{
unsigned int	uIndex;
PCALL			pCall;
PCONFERENCE		pConference;
CC_HCONFERENCE	hConference;
BOOL			bTimedOut;
				
	ASSERT(hGkiCall     != 0);
	ASSERT(ppGkiCall    != NULL);
	ASSERT(ppConference != NULL);
	ASSERT(phCall       != NULL);
	ASSERT(phConference != NULL);

step1:
	AcquireLock(&CallTable.Lock);

	// Perform an exhaustive search based on hGkiCall
	for (uIndex = 0; uIndex < HASH_TABLE_SIZE; ++uIndex)
	{
		pCall = CallTable.pHead[uIndex];
		while (pCall)
		{
			if (pCall->GkiCall.hGkiCall == hGkiCall)
			{
				AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
				if (bTimedOut) {
					RelinquishLock(&CallTable.Lock);
					Sleep(0);
					goto step1;
				}
				hConference = pCall->hConference;
				if (pCall->bMarkedForDeletion || hConference == CC_INVALID_HANDLE)
				{
					RelinquishLock(&pCall->Lock);
					RelinquishLock(&CallTable.Lock);
					return CC_BAD_PARAM;
				}
				RelinquishLock(&pCall->Lock);
				if (LockConference(hConference, &pConference) != CC_OK)
				{
					RelinquishLock(&CallTable.Lock);
					return CC_BAD_PARAM;
				}
				AcquireLock(&pCall->Lock);
				*ppGkiCall    = &pCall->GkiCall;
				*ppConference = (void *)pConference;
				*phCall		  = pCall->hCall;
				*phConference = pCall->hConference;
				RelinquishLock(&CallTable.Lock);
				return NOERROR;
			}
			pCall = pCall->pNextInTable;
		} // while
	}

	RelinquishLock(&CallTable.Lock);
	return CC_BAD_PARAM;
} // LockGkiCallAndConference()



HRESULT UnlockGkiCallAndConference(	PGKICALL				pGkiCall,
									void *					pConference,
									DWORD_PTR				hCall,
									DWORD_PTR				hConference)
{
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference((PCONFERENCE)pConference);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pGkiCall->pCall);
	return NOERROR;
} // UnlockGkiCallAndConference()



HRESULT LockGkiCall(HANDLE hGkiCall, PPGKICALL ppGkiCall)
{
unsigned int	uIndex;
PCALL			pCall;
BOOL			bTimedOut;

	ASSERT(hGkiCall != 0);
	ASSERT(ppGkiCall != NULL);

step1:
	AcquireLock(&CallTable.Lock);

	// Perform an exhaustive search based on hGkiCall
	for (uIndex = 0; uIndex < HASH_TABLE_SIZE; ++uIndex)
	{
		pCall = CallTable.pHead[uIndex];
		while (pCall)
		{
			if (pCall->GkiCall.hGkiCall == hGkiCall)
			{
				AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
				if (bTimedOut) {
					RelinquishLock(&CallTable.Lock);
					Sleep(0);
					goto step1;
				}
				if (pCall->bMarkedForDeletion)
				{
					RelinquishLock(&pCall->Lock);
					*ppGkiCall = NULL;
					RelinquishLock(&CallTable.Lock);
					return CC_BAD_PARAM;
				}
				*ppGkiCall = &pCall->GkiCall;
				RelinquishLock(&CallTable.Lock);
				return NOERROR;
			}
			pCall = pCall->pNextInTable;
		} // while
	}

	*ppGkiCall = NULL;
	RelinquishLock(&CallTable.Lock);
	return CC_BAD_PARAM;
} // LockGkiCall()



HRESULT UnlockGkiCall(PGKICALL pGkiCall)
{
	return UnlockCall(pGkiCall->pCall);
} // UnlockGkiCall()



HRESULT ApplyToAllCalls(PGKICALLFUN pGkiCallFun)
{
unsigned	uIndex;
PCALL		pCall;
DWORD_PTR	hCall;
PCONFERENCE	pConference;
DWORD_PTR	hConference;
HRESULT     status;
BOOL		bTimedOut;

step1:
	AcquireLock(&CallTable.Lock);

	// Apply pGkiCallFun to all calls in table
	for (uIndex = 0; uIndex < HASH_TABLE_SIZE; ++uIndex)
	{
		pCall = CallTable.pHead[uIndex];
		while (pCall)
		{
			AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
			if (bTimedOut) {
				RelinquishLock(&CallTable.Lock);
				Sleep(0);
				goto step1;
			}
			hConference = pCall->hConference;
			if (pCall->bMarkedForDeletion || hConference == CC_INVALID_HANDLE)
			{
				RelinquishLock(&pCall->Lock);
			}
			else
			{
				RelinquishLock(&pCall->Lock);
				if (LockConference(hConference, &pConference) == CC_OK)
				{
					AcquireLock(&pCall->Lock);
					hCall = pCall->hCall;
					status = pGkiCallFun(&pCall->GkiCall, pConference);
					if (ValidateConference(hConference) == NOERROR)
						UnlockConference(pConference);
					if (ValidateCall(hCall) != NOERROR)
					{
						// Call was deleted
						RelinquishLock(&CallTable.Lock);
						if (status != NOERROR)
							return status;
						// Start all over again
						goto step1;
					}
					RelinquishLock(&pCall->Lock);
					if (status != NOERROR)
					{
						RelinquishLock(&CallTable.Lock);
						return status;
					}
				}
			}
			pCall = pCall->pNextInTable;
		} // while
	}

	RelinquishLock(&CallTable.Lock);
	return NOERROR;
} // ApplyToAllCalls()

#endif // GATEKEEPER


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\callcont.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/callcont.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.102  $
 *      $Date:   13 Feb 1997 21:28:38  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CALLCONT_H
#define CALLCONT_H

#include "iras.h"

#if defined(CALL_CONTROL_EXPORT)
#define CC_API __declspec (dllexport)
#else // CALL_CONTROL_IMPORT
#define CC_API __declspec (dllimport)
#endif

#pragma pack(push,8)

#ifndef H245API_H
#include "h245api.h"
#endif H245API_H

#ifndef CCERROR_H
#include "ccerror.h"
#endif  CCERROR_H

#ifdef __cplusplus
extern "C" {
#endif

// Indication codes
#define CC_RINGING_INDICATION						1
#define CC_CONNECT_INDICATION						2
#define CC_TX_CHANNEL_OPEN_INDICATION				3
#define CC_RX_CHANNEL_REQUEST_INDICATION			4
#define CC_RX_CHANNEL_CLOSE_INDICATION				5
#define CC_MUTE_INDICATION							6
#define CC_UNMUTE_INDICATION						7
#define CC_PEER_ADD_INDICATION						8
#define CC_PEER_DROP_INDICATION						9
#define CC_PEER_CHANGE_CAP_INDICATION				10
#define CC_CONFERENCE_TERMINATION_INDICATION		11
#define CC_HANGUP_INDICATION						12
#define CC_RX_NONSTANDARD_MESSAGE_INDICATION		13
#define CC_MULTIPOINT_INDICATION					14
#define CC_PEER_UPDATE_INDICATION					15
#define CC_H245_MISCELLANEOUS_COMMAND_INDICATION	16
#define CC_H245_MISCELLANEOUS_INDICATION_INDICATION	17
#define CC_H245_CONFERENCE_REQUEST_INDICATION		18
#define CC_H245_CONFERENCE_RESPONSE_INDICATION		19
#define CC_H245_CONFERENCE_COMMAND_INDICATION		20
#define CC_H245_CONFERENCE_INDICATION_INDICATION	21
#define CC_FLOW_CONTROL_INDICATION					22
#define CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION		23
#define CC_REQUEST_MODE_INDICATION					24
#define CC_REQUEST_MODE_RESPONSE_INDICATION			25
#define CC_VENDOR_ID_INDICATION						26
#define CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION		27
#define CC_T120_CHANNEL_REQUEST_INDICATION			28
#define CC_T120_CHANNEL_OPEN_INDICATION				29
#define CC_BANDWIDTH_CHANGED_INDICATION             30
#define CC_ACCEPT_CHANNEL_INDICATION                31
#define CC_TERMINAL_ID_REQUEST_INDICATION           32
#define CC_PING_RESPONSE_INDICATION					33
#define CC_TERMINAL_NUMBER_INDICATION               34

// Conference configuration values; these are bit mask values
#define CC_CONFIGURE_MULTIPOINT_CAPABLE				0x0001
#define CC_CONFIGURE_FORCE_MC						0x0002

// Timeout type codes
#define CC_Q931_ALERTING_TIMEOUT					1
#define CC_H245_RETRY_COUNT							2
#define CC_H245_TIMEOUT								3

// Conference termination reasons
#define CC_PEER_HANGUP								0
#define CC_GATEKEEPER_HANGUP						1

typedef enum {
	CC_WILL_TRANSMIT_PREFERRED_MODE,
	CC_WILL_TRANSMIT_LESS_PREFERRED_MODE,
	CC_MODE_UNAVAILABLE,
	CC_MULTIPOINT_CONSTRAINT,
	CC_REQUEST_DENIED
} CC_REQUEST_MODE_RESPONSE;

typedef H245_TOTCAP_T   CC_TERMCAP, *PCC_TERMCAP, **PPCC_TERMCAP;

typedef struct {
	WORD					wLength;
	PPCC_TERMCAP			pTermCapArray;
} CC_TERMCAPLIST, *PCC_TERMCAPLIST;

typedef struct {
	WORD					wLength;
	H245_TOTCAPDESC_T		**pTermCapDescriptorArray;
} CC_TERMCAPDESCRIPTORS, *PCC_TERMCAPDESCRIPTORS;

typedef struct {
	BYTE					bMCUNumber;
	BYTE					bTerminalNumber;
} CC_TERMINAL_LABEL, *PCC_TERMINAL_LABEL;

typedef struct {
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_OCTETSTRING			TerminalID;
} CC_PARTICIPANTINFO, *PCC_PARTICIPANTINFO;

typedef struct {
	WORD					wLength;
	PCC_PARTICIPANTINFO		ParticipantInfoArray;
} CC_PARTICIPANTLIST, *PCC_PARTICIPANTLIST;

typedef struct
{
	BOOL					bMaster;
	BOOL					bMultipointController;
	BOOL					bMultipointConference;
	CC_CONFERENCEID			ConferenceID;
	CC_TERMINAL_LABEL		LocalTerminalLabel;
	WORD					wNumCalls;
	PCC_PARTICIPANTLIST		pParticipantList;
	DWORD_PTR				dwConferenceToken;
    DWORD                   dwBandwidthAllocated;
    DWORD                   dwBandwidthUsed;
} CC_CONFERENCEATTRIBUTES, *PCC_CONFERENCEATTRIBUTES;

typedef struct {
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	CC_OCTETSTRING			SessionDescription;
	PCC_TERMCAP				pTermCap;
	PCC_ADDR				pRTPAddr;
	PCC_ADDR				pRTCPAddr;
} CC_SESSIONINFO, *PCC_SESSIONINFO;

typedef struct {
	WORD					wLength;
	PCC_SESSIONINFO			SessionInfoArray;
} CC_SESSIONTABLE, *PCC_SESSIONTABLE;

typedef struct
{
	CC_HCALL				hCall;
	PCC_ALIASNAMES			pCallerAliasNames;
	PCC_ALIASNAMES			pCalleeAliasNames;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszDisplay;
	PCC_VENDORINFO			pVendorInfo;
	WORD					wGoal;
	CC_CONFERENCEID			ConferenceID;
	PCC_ADDR				pCallerAddr;
	PCC_ADDR				pCalleeAddr;
	DWORD_PTR				dwListenToken;
} CC_LISTEN_CALLBACK_PARAMS, *PCC_LISTEN_CALLBACK_PARAMS;

typedef void *  PCC_CONFERENCE_CALLBACK_PARAMS;


// CC_RINGING_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	DWORD_PTR				dwUserToken;
} CC_RINGING_CALLBACK_PARAMS, *PCC_RINGING_CALLBACK_PARAMS;

// CC_CONNECT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszPeerDisplay;
	BYTE					bRejectReason;
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
	PCC_ADDR				pLocalAddr;
	PCC_ADDR				pPeerAddr;
	PCC_VENDORINFO			pVendorInfo;
	BOOL					bMultipointConference;
	PCC_CONFERENCEID		pConferenceID;
	PCC_ADDR				pMCAddress;
	PCC_ADDR				pAlternateAddress;
	DWORD_PTR				dwUserToken;
} CC_CONNECT_CALLBACK_PARAMS, *PCC_CONNECT_CALLBACK_PARAMS;

// CC_TX_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
	PCC_ADDR				pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	DWORD					dwRejectReason;
	DWORD_PTR				dwUserToken;
} CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_RX_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
	PCC_TERMCAP				pChannelCapability;
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	PCC_ADDR	            pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	BYTE					bRTPPayloadType;
	BOOL					bSilenceSuppression;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS;

// CC_RX_CHANNEL_CLOSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
} CC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS, *PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS;

// CC_MUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
} CC_MUTE_CALLBACK_PARAMS, *PCC_MUTE_CALLBACK_PARAMS;

// CC_UNMUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
} CC_UNMUTE_CALLBACK_PARAMS, *PCC_UNMUTE_CALLBACK_PARAMS;

// CC_PEER_ADD_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_ADD_CALLBACK_PARAMS, *PCC_PEER_ADD_CALLBACK_PARAMS;

// CC_PEER_DROP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_DROP_CALLBACK_PARAMS, *PCC_PEER_DROP_CALLBACK_PARAMS;

// CC_PEER_CHANGE_CAP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
} CC_PEER_CHANGE_CAP_CALLBACK_PARAMS, *PCC_PEER_CHANGE_CAP_CALLBACK_PARAMS;

// CC_CONFERENCE_TERMINATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	DWORD					dwReason;
} CC_CONFERENCE_TERMINATION_CALLBACK_PARAMS, *PCC_CONFERENCE_TERMINATION_CALLBACK_PARAMS;

// CC_HANGUP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	DWORD_PTR				dwUserToken;
} CC_HANGUP_CALLBACK_PARAMS, *PCC_HANGUP_CALLBACK_PARAMS;

// CC_RX_NONSTANDARD_MESSAGE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	BYTE					bH245MessageType;
	CC_NONSTANDARDDATA		NonStandardData;
} CC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS, *PCC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS;

// CC_MULTIPOINT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	PCC_PARTICIPANTINFO		pTerminalInfo;
	PCC_SESSIONTABLE		pSessionTable;
} CC_MULTIPOINT_CALLBACK_PARAMS, *PCC_MULTIPOINT_CALLBACK_PARAMS;

// CC_PEER_UPDATE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_UPDATE_CALLBACK_PARAMS, *PCC_PEER_UPDATE_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	BOOL					bH323ActionRequired;
	MiscellaneousCommand	*pMiscellaneousCommand;
} CC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	MiscellaneousIndication	*pMiscellaneousIndication;
} CC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_REQ_ENUM_T	RequestType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_RSP_ENUM_T	ResponseType;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pOctetString;
	CC_TERMINAL_LABEL		*pTerminalList;
	WORD					wTerminalListCount;
} CC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	H245_CONFER_CMD_ENUM_T	CommandType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_IND_ENUM_T	IndicationType;
	BYTE					bSBENumber;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS;

// CC_FLOW_CONTROL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	DWORD					dwRate;
} CC_FLOW_CONTROL_CALLBACK_PARAMS, *PCC_FLOW_CONTROL_CALLBACK_PARAMS;

// CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
} CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS, *PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS;

// CC_REQUEST_MODE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	RequestedModesLink		pRequestedModes;
} CC_REQUEST_MODE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_CALLBACK_PARAMS;

// CC_REQUEST_MODE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_REQUEST_MODE_RESPONSE RequestModeResponse;
} CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS;

// CC_VENDOR_ID_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PCC_OCTETSTRING			pProductNumber;
	PCC_OCTETSTRING			pVersionNumber;
} CC_VENDOR_ID_CALLBACK_PARAMS, *PCC_VENDOR_ID_CALLBACK_PARAMS;

// CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel1;
	CC_HCHANNEL				hChannel2;
	WORD					wMaximumSkew;
} CC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS, *PCC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS;

// CC_T120_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	CC_HCALL				hCall;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	DWORD					dwRejectReason;
	DWORD_PTR				dwUserToken;
} CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_T120_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	BOOL					bMultipointController;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS;

typedef struct {
	CC_HCALL	            hCall;
	DWORD		            dwBandwidthTotal;
    long                    lBandwidthChange;
} CC_BANDWIDTH_CALLBACK_PARAMS, *PCC_BANDWIDTH_CALLBACK_PARAMS;

// CC_ACCEPT_CHANNEL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
} CC_ACCEPT_CHANNEL_CALLBACK_PARAMS, *PCC_ACCEPT_CHANNEL_CALLBACK_PARAMS;

// CC_PING_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	BOOL					bResponse;
} CC_PING_RESPONSE_CALLBACK_PARAMS, *PCC_PING_RESPONSE_CALLBACK_PARAMS;

#ifndef NO_APIS

typedef void (*CC_LISTEN_CALLBACK)(		HRESULT							hStatus,
										PCC_LISTEN_CALLBACK_PARAMS		ListenCallbackParams);

typedef HRESULT (*CC_CONFERENCE_CALLBACK)(
										BYTE							bIndication,
										HRESULT							hStatus,
										CC_HCONFERENCE					hConference,
										DWORD_PTR						dwConferenceToken,
										PCC_CONFERENCE_CALLBACK_PARAMS	pConferenceCallbackParams);

typedef HRESULT (*CC_SESSIONTABLE_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD_PTR						dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbSessionTableChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors[],
										PCC_SESSIONTABLE				*ppSessionTable);

typedef HRESULT (*CC_TERMCAP_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD_PTR						dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbTermCapsChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pInTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
										PCC_TERMCAPLIST					*ppOutTermCapList,
										PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors);

CC_API
HRESULT CC_AcceptCall(					CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
										DWORD                           dwBandwidth,
										DWORD_PTR						dwUserToken);

typedef HRESULT (*CC_ACCEPTCALL)(		CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
                                        DWORD                           dwBandwidth,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_AcceptChannel(				CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwChannelBitRate);
									
typedef HRESULT (*CC_ACCEPTCHANNEL) (	CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwChannelBitRate);

CC_API
HRESULT CC_AcceptT120Channel(			CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
typedef HRESULT (*CC_ACCEPTT120CHANNEL)(CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
CC_API
HRESULT CC_CallListen(					PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD_PTR						dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);

typedef HRESULT (*CC_CALLLISTEN)(		PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD_PTR						dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);


CC_API
HRESULT CC_CancelCall(					CC_HCALL						hCall);

typedef HRESULT (*CC_CANCELCALL)(		CC_HCALL						hCall);


CC_API
HRESULT CC_CancelListen(				CC_HLISTEN						hListen);

typedef HRESULT (*CC_CANCELLISTEN)(		CC_HLISTEN						hListen);

CC_API
HRESULT CC_ChangeConferenceCapabilities(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

typedef HRESULT (*CC_CHANGECONFERENCECAPABILITIES)(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

CC_API
HRESULT CC_CloseChannel(				CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_CLOSECHANNEL)(		CC_HCHANNEL						hChannel);


CC_API
HRESULT CC_CloseChannelResponse(		CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

typedef HRESULT (*CC_CLOSECHANNELRESPONSE)(
										CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

CC_API
HRESULT CC_CreateConference(			PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD_PTR						dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

typedef HRESULT	(*CC_CREATECONFERENCE) (PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD_PTR						dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

CC_API
HRESULT CC_DestroyConference(			CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

typedef HRESULT (*CC_DESTROYCONFERENCE)(CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

CC_API
HRESULT CC_EnumerateConferences(		PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

typedef HRESULT (*CC_ENUMERATECONFERENCES)(
										PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

CC_API
HRESULT CC_FlowControl(					CC_HCHANNEL						hChannel,
										DWORD							dwRate);

typedef HRESULT (*CC_FLOWCONTROL)(		CC_HCHANNEL						hChannel,
										DWORD							dwRate);

CC_API
HRESULT CC_GetCallControlVersion(		WORD							wArraySize,
										PWSTR							pszVersion);

typedef HRESULT (*CC_GETCALLCONTROLVERSION)
									   (WORD							wArraySize,
										PWSTR							pszVersion);

CC_API
HRESULT CC_GetConferenceAttributes(		CC_HCONFERENCE					hConference,
										PCC_CONFERENCEATTRIBUTES		pConferenceAttributes);

typedef HRESULT (*CC_GETCONFERENCEATTRIBUTES)
									   (CC_HCONFERENCE                  hConference,
									    PCC_CONFERENCEATTRIBUTES        pConferenceAttributes);

CC_API
HRESULT CC_H245ConferenceRequest(		CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEREQUEST)(
										CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceResponse(		CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

typedef HRESULT (*CC_H245CONFERENCERESPONSE)(
										CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

CC_API
HRESULT CC_H245ConferenceCommand(		CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCECOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceIndication(	CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEINDICATION)(
										CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245MiscellaneousCommand(	CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

typedef HRESULT (*CC_H245MISCELLANEOUSCOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

CC_API
HRESULT CC_H245MiscellaneousIndication(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

typedef HRESULT (*CC_H245MISCELLANEOUSINDICATION)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

CC_API
HRESULT CC_Hangup(						CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD_PTR   					dwUserToken);

typedef HRESULT (*CC_HANGUP)(			CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_MaximumAudioVideoSkew(		CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

typedef HRESULT (*CC_MAXIMUMAUDIOVIDEOSKEW)(
										CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

CC_API
HRESULT CC_Mute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_MUTE)(				CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_OpenChannel(					CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwChannelBitRate,
										DWORD_PTR						dwUserToken);

typedef HRESULT (*CC_OPENCHANNEL)(		CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwChannelBitRate,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_OpenT120Channel(				CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwChannelBitRate,
										DWORD_PTR						dwUserToken);

typedef HRESULT (*CC_OPENT120CHANNEL)(	CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwChannelBitRate,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_Ping(						CC_HCALL						hCall,
										DWORD							dwTimeout);

typedef HRESULT (*CC_PING)(				CC_HCALL						hCall,
										DWORD							dwTimeout);

CC_API
HRESULT CC_PlaceCall(					CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD_PTR						dwUserToken);

typedef HRESULT (*CC_PLACECALL)(		CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_RejectCall(					BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

typedef HRESULT (*CC_REJECTCALL)(		BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

CC_API
HRESULT CC_RejectChannel(				CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

typedef HRESULT (*CC_REJECTCHANNEL)(	CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

CC_API
HRESULT CC_RequestMode(					CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

typedef HRESULT (*CC_REQUESTMODE)(		CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

CC_API
HRESULT CC_RequestModeResponse(			CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

typedef HRESULT (*CC_REQUESTMODERESPONSE)(
										CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

CC_API
HRESULT CC_SendNonStandardMessage(		CC_HCALL						hCall,
										BYTE							bMessageType,
										CC_NONSTANDARDDATA				NonStandardData);

typedef HRESULT (*CC_SENDNONSTANDARDMESSAGE)(
										CC_HCALL						hCall,
										BYTE							bMessageType,
										CC_NONSTANDARDDATA				NonStandardData);

CC_API
HRESULT CC_SendVendorID(				CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);

typedef HRESULT (*CC_SENDVENDORID)(		CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);
CC_API
HRESULT CC_SetCallControlTimeout(		WORD							wType,
										DWORD							dwDuration);

typedef HRESULT (*CC_SETCALLCONTROLTIMEOUT)
									   (WORD							wType,
										DWORD							dwDuration);

CC_API
HRESULT CC_SetTerminalID(				CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

typedef HRESULT (*CC_SETTERMINALID)(	CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

CC_API
HRESULT CC_Shutdown();
CC_API
HRESULT CC_Initialize();

typedef HRESULT (*CC_SHUTDOWN)();
typedef HRESULT (*CC_INITIALIZE)();

CC_API
HRESULT CC_UnMute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_UNMUTE)(			CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_UpdatePeerList(				CC_HCONFERENCE					hConference);

typedef HRESULT (*CC_UPDATEPEERLIST)(	CC_HCONFERENCE					hConference);

CC_API
HRESULT CC_UserInput(					CC_HCALL						hCall,
										PWSTR							pszUserInput);

typedef HRESULT (*CC_USERINPUT)(		CC_HCALL						hCall,
										PWSTR							pszUserInput);

CC_API
HRESULT CC_EnableGKRegistration(
    BOOL fEnable,
    PSOCKADDR_IN pAddr,
    PCC_ALIASNAMES pLocalAliasNames,
    PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration,
    RASNOTIFYPROC pRasNotifyProc);


typedef HRESULT (*CC_ENABLEGKREGISTRATION)(
    BOOL fEnable,
    PCC_ALIASNAMES pLocalAliasNames,
    PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration,
    RASNOTIFYPROC pRasNotifyProc);


#endif


#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif CALLCONT_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\callman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.27  $
 *	$Date:   22 Jan 1997 17:25:38  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


HRESULT InitCallManager();

HRESULT DeInitCallManager();

HRESULT AllocAndLockCall(			PCC_HCALL				phCall,
									CC_HCONFERENCE			hConference,
									HQ931CALL				hQ931Call,
									HQ931CALL				hQ931CallInvitor,
									PCC_ALIASNAMES			pLocalAliasNames,
									PCC_ALIASNAMES			pPeerAliasNames,
									PCC_ALIASNAMES			pPeerExtraAliasNames,
									PCC_ALIASITEM			pPeerExtension,
									PCC_NONSTANDARDDATA		pLocalNonStandardData,
									PCC_NONSTANDARDDATA		pPeerNonStandardData,
									PWSTR					pszLocalDisplay,
									PWSTR					pszPeerDisplay,
									PCC_VENDORINFO			pPeerVendorInfo,
									PCC_ADDR				pQ931LocalConnectAddr,
									PCC_ADDR				pQ931PeerConnectAddr,
									PCC_ADDR				pQ931DestinationAddr,
									PCC_ADDR                pSourceCallSignalAddress,
									CALLTYPE				CallType,
									BOOL					bCallerIsMC,
									DWORD_PTR				dwUserToken,
									CALLSTATE				InitialCallState,
									LPGUID                  pCallIdentifier,
									PCC_CONFERENCEID		pConferenceID,
									PPCALL					ppCall);

HRESULT FreeCall(					PCALL					pCall);

HRESULT LockQ931Call(				CC_HCALL				hCall,
									HQ931CALL				hQ931Call,
									PPCALL					ppCall);

HRESULT LockCall(					CC_HCALL				hCall,
									PPCALL					ppCall);

HRESULT LockCallAndConference(		CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference);

HRESULT MarkCallForDeletion(		PCALL					pCall);

HRESULT ValidateCall(				CC_HCALL				hCall);

HRESULT ValidateCallMarkedForDeletion(
									CC_HCALL				hCall);

HRESULT UnlockCall(					PCALL					pCall);

HRESULT AddLocalNonStandardDataToCall(
									PCALL					pCall,
									PCC_NONSTANDARDDATA		pLocalNonStandardData);

HRESULT AddLocalDisplayToCall(		PCALL					pCall,
									PWSTR					pszLocalDisplay);

HRESULT AllocatePeerParticipantInfo(PCONFERENCE				pConference,
									PPARTICIPANTINFO		*ppPeerParticipantInfo);

HRESULT FreePeerParticipantInfo(	PCONFERENCE				pConference,
									PPARTICIPANTINFO		pPeerParticipantInfo);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\cclock.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/cclock.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.0  $
 *      $Date:   31 Jan 1997 12:36:14  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CCLOCK_H
#define CCLOCK_H

#ifdef __cplusplus
extern "C" {
#endif

VOID CCLOCK_AcquireLock();
VOID CCLOCK_RelinquishLock();

HRESULT InitializeCCLock(VOID);
VOID UnInitializeCCLock();

#ifdef __cplusplus
}
#endif


#endif CCLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\ccerror.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/ccerror.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.0  $
 *      $Date:   16 Dec 1996 18:59:34  $
 *      $Author:   EHOWARDX  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CCERROR_H
#define CCERROR_H

#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

// Status codes
#define CC_OK							NOERROR
#define CC_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_OUTOFMEMORY)
#define CC_PEER_REJECT					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 1)
#define CC_BAD_PARAM					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 2)
#define CC_BAD_SIZE						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 3)
#define CC_ACTIVE_CONNECTIONS			MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 4)
#define CC_INTERNAL_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 5)
#define CC_NOT_IMPLEMENTED				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 6)
#define CC_DUPLICATE_CONFERENCE_ID		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 7)
#define CC_ILLEGAL_IN_MULTIPOINT		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 8)
#define CC_NOT_MULTIPOINT_CAPABLE		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 9)
#define CC_PEER_CANCEL					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 10)
#define CC_GKI_STATE                    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 21)
#define CC_GKI_CALL_STATE               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 22)
#define CC_GKI_LISTEN_NOT_FOUND         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 23)
#define CC_GATEKEEPER_REFUSED           MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 24)
#define CC_INVALID_WITHOUT_GATEKEEPER   MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 25)
#define CC_GKI_IP_ADDRESS               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 26)
#define CC_GKI_LOAD                     MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 27)


#ifdef __cplusplus
}
#endif

#endif CCERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\callcont\api_util.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  AUTHOR:     cjutzi (Curt Jutzi)
 *
 *  $Workfile:   api_util.c  $
 *  $Revision:   1.35  $
 *  $Modtime:   25 Feb 1997 10:36:12  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/api_util.c_v  $
 *
 *    Rev 1.35   25 Feb 1997 11:18:44   MANDREWS
 *
 * Fixed dynamic term cap ID generation; dynamic term cap IDs now
 * start at 32K + 1 and increase from there. Static term cap IDs
 * (specified by the client) are now restricted to the range of 1..32K.
 *
 *    Rev 1.34   29 Jan 1997 16:25:06   EHOWARDX
 * Changed del_cap_descriptor() to match changes to set_cap_descriptor().
 *
 *    Rev 1.33   29 Jan 1997 14:44:36   MANDREWS
 * Fixed warning that occured in release mode build.
 *
 *    Rev 1.32   28 Jan 1997 14:46:58   EHOWARDX
 * Potential fix for capability descriptor problem.
 *
 *    Rev 1.31   14 Oct 1996 14:01:20   EHOWARDX
 * Unicode changes.
 *
 *    Rev 1.30   16 Sep 1996 19:46:18   EHOWARDX
 * Added del_mux_cap for local and remote multiplex capability
 * to api_deinit to (hopefully) fix memory leak.
 *
 *    Rev 1.29   11 Oct 1996 15:19:42   EHOWARDX
 * Fixed H245CopyCap() bug.
 *
 *    Rev 1.28   28 Aug 1996 11:37:22   EHOWARDX
 * const changes.
 *
 *    Rev 1.27   05 Aug 1996 15:31:42   EHOWARDX
 *
 * Fixed error in CopyH2250Cap.
 *
 *    Rev 1.26   02 Aug 1996 21:10:42   EHOWARDX
 *
 * H.225.0 Mux cap bug second pass - see if this works.
 *
 *    Rev 1.25   02 Aug 1996 20:34:20   EHOWARDX
 * First pass at H.225.0 Mux cap bug.
 *
 *    Rev 1.24   19 Jul 1996 12:16:30   EHOWARDX
 *
 * Rewrite of api_fsm_event() debug routine.
 *
 *    Rev 1.23   16 Jul 1996 11:47:18   EHOWARDX
 *
 * Eliminated H245_ERROR_MUX_CAPS_ALREADY_SET from debug error text function.
 *
 *    Rev 1.22   09 Jul 1996 17:10:24   EHOWARDX
 * Fixed pointer offset bug in processing DataType from received
 * OpenLogicalChannel.
 *
 *    Rev 1.21   01 Jul 1996 22:12:42   EHOWARDX
 *
 * Added Conference and CommunicationMode structures and functions.
 *
 *    Rev 1.20   24 Jun 1996 12:27:02   EHOWARDX
 *
 * Same as 1.17.1.0.
 *
 *    Rev 1.19   17 Jun 1996 18:10:06   EHOWARDX
 *
 * Changed first argument to build_totcap_cap_n_client_from_capability()
 * from VOID to struct capability *.
 *
 *    Rev 1.18   14 Jun 1996 18:57:56   EHOWARDX
 * Geneva update.
 *
 *    Rev 1.17   10 Jun 1996 16:56:56   EHOWARDX
 * Removed #include "h245init.x"
 *
 *    Rev 1.16   06 Jun 1996 18:48:36   EHOWARDX
 * Fine-tuning tracker functions.
 *
 *    Rev 1.15   04 Jun 1996 13:56:40   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.14   31 May 1996 18:21:08   EHOWARDX
 * Changed map_api_error to reflect updated error codes.
 *
 *    Rev 1.13   30 May 1996 23:39:02   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.12   29 May 1996 15:20:10   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.11   28 May 1996 14:25:28   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.10   20 May 1996 22:15:46   EHOWARDX
 * Completed NonStandard Message and H.225.0 Maximum Skew indication
 * implementation. Added ASN.1 validation to H245SetLocalCap and
 * H245SetCapDescriptor. Check-in from Microsoft drop on 17-May-96.
 *
 *    Rev 1.9   20 May 1996 14:35:16   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.8   16 May 1996 19:40:48   EHOWARDX
 * Fixed multiplex capability bug.
 *
 *    Rev 1.7   16 May 1996 16:53:58   EHOWARDX
 * Fixed bug in set_capability() - need to set capability entry number
 * AFTER doing load_cap().
 *
 *    Rev 1.6   16 May 1996 15:59:26   EHOWARDX
 * Fine-tuning H245SetLocalCap/H245DelLocalCap/H245SetCapDescriptor/
 * H245DelCapDescriptor behaviour.
 *
 *    Rev 1.5   15 May 1996 19:53:28   unknown
 * Fixed H245SetCapDescriptor.
 *
 *    Rev 1.4   14 May 1996 13:58:04   EHOWARDX
 * Fixed capability list order (made fifo).
 * Added support for NonStandard and H.222 mux capabilities to set_cap_descrip
 *
 *    Rev 1.3   14 May 1996 12:27:24   EHOWARDX
 * Check-in for integration.
 * Still need to fix non-standard and H.222 mux capabilities.
 *
 *    Rev 1.2   13 May 1996 23:16:46   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.1   11 May 1996 20:33:08   EHOWARDX
 * Checking in for the night...
 *
 *    Rev 1.0   09 May 1996 21:06:10   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.23.1.8   09 May 1996 19:30:56   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.23.1.7   27 Apr 1996 21:09:46   EHOWARDX
 * Changed Channel Numbers to words, added H.225.0 support.
 *
 *    Rev 1.23.1.6   26 Apr 1996 15:53:52   EHOWARDX
 * Added H.225.0 Capability support; Changed Capability indication
 * to only callback once with PDU.
 *
 *    Rev 1.23.1.5   24 Apr 1996 20:54:36   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 *
 *    Rev 1.23.1.4   23 Apr 1996 14:47:20   EHOWARDX
 * Disabled dump_pdu.
 *
 *    Rev 1.23.1.3   19 Apr 1996 12:54:18   EHOWARDX
 * Updated to 1.28.
 *
 *    Rev 1.23.1.2   15 Apr 1996 15:10:52   EHOWARDX
 * Updated to match Curt's current version.
 *
 *    Rev 1.23.1.1   03 Apr 1996 17:14:56   EHOWARDX
 * Integrated latest H.323 changes.
 *
 *    Rev 1.23.1.0   03 Apr 1996 15:54:26   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.22   01 Apr 1996 16:43:18   cjutzi
 *
 * - Completed ENdConnection, and made asynch.. rather
 *   than sync.. as before
 * - Changed H245ShutDown to be sync rather than async..
 *
 *    Rev 1.21   29 Mar 1996 09:35:16   cjutzi
 *
 * -
 * - fixed ring3 build error message for check_pdu
 *
 *    Rev 1.20   27 Mar 1996 08:37:28   cjutzi
 *
 * - removed error from routine .. was unreferenced variable..
 *
 *    Rev 1.19   19 Mar 1996 20:31:06   cjutzi
 *
 * - added bi-directional channel stuff
 *
 *    Rev 1.18   13 Mar 1996 14:12:52   cjutzi
 *
 * - clean up..
 *
 *    Rev 1.17   13 Mar 1996 09:25:34   cjutzi
 *
 * - removed LPCRITICIAL -> CRITICAL SECTION *
 *
 *    Rev 1.16   12 Mar 1996 16:40:50   cjutzi
 *
 * - removed deadlock..
 *
 *    Rev 1.15   12 Mar 1996 15:51:08   cjutzi
 *
 * - added locking
 * - implented End Session
 * - fixed callback bug for deleting caps on cleanup..
 *
 *    Rev 1.14   08 Mar 1996 14:04:48   cjutzi
 *
 * - added mux table entry code.
 * - parse all mux table entries.. (as much as needed at this point)
 *
 *    Rev 1.13   06 Mar 1996 12:35:02   cjutzi
 *
 * - typeo.. :-).. for ANS1 error ..
 *
 *    Rev 1.12   06 Mar 1996 08:49:42   cjutzi
 *
 * - added H245_ERROR_ASN1
 * - #ifdef'ed the call to check pdu.. in api_fsm
 *
 *    Rev 1.11   05 Mar 1996 17:37:14   cjutzi
 *
 * - implemented Send Local Mux Table..
 * - removed bzero/bcopy and changed free api
 *
 *
 *    Rev 1.10   01 Mar 1996 13:49:00   cjutzi
 *
 * - added hani's new fsm id's
 * - added debug print for events.
 *
 *    Rev 1.9   29 Feb 1996 08:38:14   cjutzi
 *
 * - added error messages ..
 *
 *    Rev 1.8   26 Feb 1996 16:33:28   cjutzi
 *
 * - fixed GP for tracker.  p_prev was not initialized to NULL
 *
 *
 *    Rev 1.7   26 Feb 1996 11:06:18   cjutzi
 *
 * - added simltanious caps.. and fixed bugs..
 *   lot's o-changes..
 *
 *    Rev 1.6   16 Feb 1996 13:02:34   cjutzi
 *
 *  - got open / close / request close working in both directions.
 *
 *    Rev 1.5   15 Feb 1996 10:53:10   cjutzi
 *
 * - termcaps working
 * - changed API interface for MUX_T
 * - modifed H223 stuff
 * - cleaned up open
 *
 *    Rev 1.4   09 Feb 1996 16:58:40   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *
 *****************************************************************************/


/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****                                                                   *****/
/****                   NOTES TO THE READER                             *****/
/****                                                                   *****/
/**** This program has been put together using a a screen which is      *****/
/**** wider than 80 characters.. It is best if a similar screen size is *****/
/**** used.. Of course emacs is my preference but 80 col screens will   *****/
/**** cause you much frustration..                                      *****/
/****                                                                   *****/
/**** Tabs are set to 8                                                 *****/
/****                                                                   *****/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

#undef UNICODE
#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"


/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"
#include "fsmexpor.h"
#include "api_util.x"
#include "api_debu.x"
#include "h245deb.x"



// This array is used to map user-specified Client Type into correct Data Type
BYTE DataTypeMap[] =
{
  H245_DATA_DONTCARE,           //  H245_CLIENT_DONTCARE,
  H245_DATA_NONSTD,             //  H245_CLIENT_NONSTD,

  H245_DATA_VIDEO,              //  H245_CLIENT_VID_NONSTD,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_H261,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_H262,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_H263,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_IS11172,

  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_NONSTD,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ALAW64,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ALAW56,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ULAW64,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ULAW56,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G722_64,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G722_56,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G722_48,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G723,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G728,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G729,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_GDSVD,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_IS11172,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_IS13818,

  H245_DATA_DATA,               //  H245_CLIENT_DAT_NONSTD,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_T120,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_DSMCC,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_USERDATA,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_T84,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_T434,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_H224,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_NLPID,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_DSVD,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_H222,

  H245_DATA_ENCRYPT_D,          //  H245_CLIENT_ENCRYPTION_TX,
  H245_DATA_ENCRYPT_D,          //  H245_CLIENT_ENCRYPTION_RX,
  H245_DATA_CONFERENCE,         //  H245_CLIENT_CONFERENCE,

  // Multiplex capabilities
  H245_DATA_MUX,                //  H245_CLIENT_MUX_NONSTD,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_H222,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_H223,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_VGMUX,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_H2250
};

unsigned ObjectIdLength (const NonStandardIdentifier *pIdentifier)
{
  register unsigned   uLength = 0;
  register POBJECTID  pObject = pIdentifier->u.object;
  ASSERT(pIdentifier->choice == object_chosen);
  while (pObject)
  {
    ++uLength;
    pObject = pObject->next;
  }
  return uLength;
} // ObjectIdLength()



void FreeNonStandardIdentifier(NonStandardIdentifier *pFree)
{
    register POBJECTID    pObject;

    if (pFree->choice == object_chosen)
    {
        // Free Object Identifier
        while (pFree->u.object)
        {
            pObject = pFree->u.object;
            pFree->u.object = pObject->next;
            MemFree(pObject);
        }
    }
} // FreeNonStandardIdentifier()



HRESULT CopyNonStandardIdentifier(NonStandardIdentifier *pNew, const NonStandardIdentifier *pOld)
{

  // Copy the base structure
  *pNew = *pOld;

  if (pOld->choice == object_chosen)
  {
    // Copy Object Identifier
    POBJECTID                pObjectList;
    POBJECTID                pObjectOld;
    POBJECTID                pObjectNew;

    pNew->u.object = NULL;
    pObjectList = NULL;
    pObjectOld = pOld->u.object;
    while (pObjectOld)
    {
      // Allocate new structure
      pObjectNew = MemAlloc(sizeof(*pObjectNew));
      if (pObjectNew == NULL)
      {
        H245TRACE(0,1,"API:CopyNonStandardIdentifier - malloc failed");
        FreeNonStandardIdentifier(pNew);
        return H245_ERROR_NOMEM;
      }

      // Copy old structure to new structure
      pObjectNew->value = pObjectOld->value;

      // Add new structure to list
      pObjectNew->next  = NULL;
      if (pNew->u.object == NULL)
      {
        pNew->u.object = pObjectNew;
      }
      else
      {
        pObjectList->next = pObjectNew;
      }
      pObjectList = pObjectNew;

      // Get next old structure to copy
      pObjectOld = pObjectOld->next;
    }
  }

  return H245_ERROR_OK;
} // CopyNonStandardIdentifier()



void FreeNonStandardParameter(NonStandardParameter *pFree)
{
    FreeNonStandardIdentifier(&pFree->nonStandardIdentifier);

    if (pFree->data.value)
    {
        MemFree(pFree->data.value);
        pFree->data.value = NULL;
    }
} // FreeNonStandardParameter()



HRESULT CopyNonStandardParameter(NonStandardParameter *pNew, const NonStandardParameter *pOld)
{
  // Copy the base structure
  *pNew = *pOld;

  if (pOld->nonStandardIdentifier.choice == object_chosen)
  {
    HRESULT lResult = CopyNonStandardIdentifier(&pNew->nonStandardIdentifier, &pOld->nonStandardIdentifier);
    if (lResult != H245_ERROR_OK)
    {
      pNew->data.value = NULL;
      return lResult;
    }
  }

  if (pOld->data.length && pOld->data.value)
  {
    // Copy value
    pNew->data.value = MemAlloc(pOld->data.length);
    if (pNew->data.value == NULL)
    {
      H245TRACE(0,1,"API:CopyNonStandardParameter - malloc failed");
      return H245_ERROR_NOMEM;
    }
    memcpy(pNew->data.value, pOld->data.value, pOld->data.length);
  }

  return H245_ERROR_OK;
} // CopyNonStandardParameter()



void FreeH222Cap(H222Capability *pFree)
{
  register VCCapabilityLink pVC;

  while (pFree->vcCapability)
  {
    pVC = pFree->vcCapability;
    pFree->vcCapability = pVC->next;
    MemFree(pVC);
  }
} // FreeH222Cap()



HRESULT CopyH222Cap(H222Capability *pNew, const H222Capability *pOld)
{
  VCCapabilityLink pVcNew;
  VCCapabilityLink pVcOld;
  VCCapabilityLink pVcList;

  pNew->numberOfVCs = pOld->numberOfVCs;
  pNew->vcCapability = NULL;
  pVcList = NULL;
  pVcOld = pOld->vcCapability;
  while (pVcOld)
  {
    // Allocate new structure
    pVcNew = MemAlloc(sizeof(*pVcNew));
    if (pVcNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH222Cap - malloc failed");
      FreeH222Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Copy old structure to new structure
    *pVcNew = *pVcOld;

    // Add new structure to list
    pVcNew->next = NULL;
    if (pNew->vcCapability == NULL)
    {
      pNew->vcCapability = pVcNew;
    }
    else
    {
      pVcList->next = pVcNew;
    }
    pVcList = pVcNew;

    // Get next old structure to copy
    pVcOld = pVcOld->next;
  }

  return H245_ERROR_OK;
} // CopyH222Cap()



void FreeMediaDistributionCap(MediaDistributionCapability *pFree)
{
  if (pFree->bit_mask & centralizedData_present)
  {
    register CentralizedDataLink  pLink;

    while (pFree->centralizedData)
    {
      pLink = pFree->centralizedData;
      pFree->centralizedData = pLink->next;
      switch (pLink->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          MemFree(pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLink->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      MemFree(pLink);
    }
  }

  if (pFree->bit_mask & distributedData_present)
  {
    register DistributedDataLink  pLink;

    while (pFree->distributedData)
    {
      pLink = pFree->distributedData;
      pFree->distributedData = pLink->next;
      switch (pLink->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          MemFree(pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLink->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      MemFree(pLink);
    }
  }
} // FreeMediaDistributionCap()



HRESULT CopyMediaDistributionCap(MediaDistributionCapability *pNew,
                           const MediaDistributionCapability *pOld)
{
  HRESULT lResult = H245_ERROR_OK;
  *pNew = *pOld;
  pNew->centralizedData = NULL;
  pNew->distributedData = NULL;

  if (pOld->bit_mask & centralizedData_present)
  {
    CentralizedDataLink pLinkList = NULL;
    CentralizedDataLink pLinkOld = pOld->centralizedData;
    CentralizedDataLink pLinkNew;

    while (pLinkOld)
    {
      // Allocate new structure
      pLinkNew = MemAlloc(sizeof(*pLinkNew));
      if (pLinkNew == NULL)
      {
        H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
        FreeMediaDistributionCap(pNew);
        return H245_ERROR_NOMEM;
      }

      // Copy old structure to new structure
      *pLinkNew = *pLinkOld;

      // Add new structure to list
      pLinkNew->next = NULL;
      if (pNew->centralizedData == NULL)
      {
        pNew->centralizedData = pLinkNew;
      }
      else
      {
        pLinkList->next = pLinkNew;
      }
      pLinkList = pLinkNew;

      // Allocate new memory for each pointer in new structure
      switch (pLinkOld->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_nnStndrd,
                                           &pLinkOld->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value =
            MemAlloc(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
          if (pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value == NULL)
          {
            H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
            FreeMediaDistributionCap(pNew);
            return H245_ERROR_NOMEM;
          }
          memcpy(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLinkOld->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                             &pLinkOld->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      if (lResult != H245_ERROR_OK)
      {
        FreeMediaDistributionCap(pNew);
        return lResult;
      }

      // Get next old structure to copy
      pLinkOld = pLinkOld->next;
    }
  }

  if (pOld->bit_mask & distributedData_present)
  {
    DistributedDataLink pLinkList = NULL;
    DistributedDataLink pLinkOld = pOld->distributedData;
    DistributedDataLink pLinkNew;

    while (pLinkOld)
    {
      // Allocate new structure
      pLinkNew = MemAlloc(sizeof(*pLinkNew));
      if (pLinkNew == NULL)
      {
        H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
        FreeMediaDistributionCap(pNew);
        return H245_ERROR_NOMEM;
      }

      // Copy old structure to new structure
      *pLinkNew = *pLinkOld;

      // Add new structure to list
      pLinkNew->next = NULL;
      if (pNew->distributedData == NULL)
      {
        pNew->distributedData = pLinkNew;
      }
      else
      {
        pLinkList->next = pLinkNew;
      }
      pLinkList = pLinkNew;

      // Allocate new memory for each pointer in new structure
      switch (pLinkOld->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_nnStndrd,
                                         &pLinkOld->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value =
            MemAlloc(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
          if (pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value == NULL)
          {
            H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
            FreeMediaDistributionCap(pNew);
            return H245_ERROR_NOMEM;
          }
          memcpy(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value,
               pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLinkOld->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                           &pLinkOld->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      if (lResult != H245_ERROR_OK)
      {
        FreeMediaDistributionCap(pNew);
        return lResult;
      }

      // Get next old structure to copy
      pLinkOld = pLinkOld->next;
    }
  }

  return H245_ERROR_OK;
} // CopyMediaDistributionCap()



void FreeH2250Cap(H2250Capability *pFree)
{
  register MediaDistributionCapabilityLink pLink;

  while (pFree->receiveMultipointCapability.mediaDistributionCapability)
  {
    pLink = pFree->receiveMultipointCapability.mediaDistributionCapability;
    pFree->receiveMultipointCapability.mediaDistributionCapability = pLink->next;
    FreeMediaDistributionCap(&pLink->value);
    MemFree(pLink);
  }

  while (pFree->transmitMultipointCapability.mediaDistributionCapability)
  {
    pLink = pFree->transmitMultipointCapability.mediaDistributionCapability;
    pFree->transmitMultipointCapability.mediaDistributionCapability = pLink->next;
    FreeMediaDistributionCap(&pLink->value);
    MemFree(pLink);
  }

  while (pFree->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability)
  {
    pLink = pFree->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability;
    pFree->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability = pLink->next;
    FreeMediaDistributionCap(&pLink->value);
    MemFree(pLink);
  }
} // FreeH2250Cap()



HRESULT CopyH2250Cap(H2250Capability *pNew, const H2250Capability *pOld)
{
  MediaDistributionCapabilityLink pLinkList;
  MediaDistributionCapabilityLink pLinkOld;
  MediaDistributionCapabilityLink pLinkNew;
  HRESULT lResult;

  // Copy base structure
  *pNew = *pOld;
  pNew->receiveMultipointCapability.mediaDistributionCapability  = NULL;
  pNew->transmitMultipointCapability.mediaDistributionCapability = NULL;
  pNew->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability     = NULL;

  pLinkList = NULL;
  pLinkOld = pOld->receiveMultipointCapability.mediaDistributionCapability;
  while (pLinkOld)
  {
    // Allocate new structure
    pLinkNew = MemAlloc(sizeof(*pLinkNew));
    if (pLinkNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH2250Cap - malloc failed");
      FreeH2250Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Add new structure to list
    pLinkNew->next = NULL;
    if (pNew->receiveMultipointCapability.mediaDistributionCapability == NULL)
    {
      pNew->receiveMultipointCapability.mediaDistributionCapability = pLinkNew;
    }
    else
    {
      pLinkList->next = pLinkNew;
    }
    pLinkList = pLinkNew;

    // Copy old structure to new
    lResult = CopyMediaDistributionCap(&pLinkNew->value, &pLinkOld->value);
    if (lResult != H245_ERROR_OK)
    {
      FreeH2250Cap(pNew);
      return lResult;
    }

    // Get next old structure to copy
    pLinkOld = pLinkOld->next;
  }

  pLinkList = NULL;
  pLinkOld = pOld->transmitMultipointCapability.mediaDistributionCapability;
  while (pLinkOld)
  {
    // Allocate new structure
    pLinkNew = MemAlloc(sizeof(*pLinkNew));
    if (pLinkNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH2250Cap - malloc failed");
      FreeH2250Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Add new structure to list
    pLinkNew->next = NULL;
    if (pNew->transmitMultipointCapability.mediaDistributionCapability == NULL)
    {
      pNew->transmitMultipointCapability.mediaDistributionCapability = pLinkNew;
    }
    else
    {
      pLinkList->next = pLinkNew;
    }
    pLinkList = pLinkNew;

    // Copy old structure to new
    lResult = CopyMediaDistributionCap(&pLinkNew->value, &pLinkOld->value);
    if (lResult != H245_ERROR_OK)
    {
      FreeH2250Cap(pNew);
      return lResult;
    }

    // Get next old structure to copy
    pLinkOld = pLinkOld->next;
  }

  pLinkList = NULL;
  pLinkOld = pOld->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability;
  while (pLinkOld)
  {
    // Allocate new structure
    pLinkNew = MemAlloc(sizeof(*pLinkNew));
    if (pLinkNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH2250Cap - malloc failed");
      FreeH2250Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Add new structure to list
    pLinkNew->next = NULL;
    if (pNew->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability == NULL)
    {
      pNew->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability = pLinkNew;
    }
    else
    {
      pLinkList->next = pLinkNew;
    }
    pLinkList = pLinkNew;

    // Copy old structure to new
    lResult = CopyMediaDistributionCap(&pLinkNew->value, &pLinkOld->value);
    if (lResult != H245_ERROR_OK)
    {
      FreeH2250Cap(pNew);
      return lResult;
    }

    // Get next old structure to copy
    pLinkOld = pLinkOld->next;
  }

  return H245_ERROR_OK;
} // CopyH2250Cap()



HRESULT set_cap_descriptor(
                        struct InstanceStruct         *pInstance,
                        H245_CAPDESC_T                *pCapDesc,
                        H245_CAPDESCID_T              *pCapDescId,
                        struct TerminalCapabilitySet  *pTermCapSet)
{
  CapabilityDescriptor         *p_cap_desc;
  unsigned int                  uId;
  BOOL                          bNewDescriptor;
  unsigned int                  sim_cap;
  SmltnsCpbltsLink              p_sim_cap;
  SmltnsCpbltsLink              p_sim_cap_lst = NULL;
  unsigned int                  alt_cap;

  H245TRACE(pInstance->dwInst,10,"API:set_cap_descriptor");
  ASSERT(*pCapDescId < 256);

  /* Check if capability descriptor already exists */
  p_cap_desc = NULL;
  for (uId = 0; uId < pTermCapSet->capabilityDescriptors.count; ++uId)
  {
    if (pTermCapSet->capabilityDescriptors.value[uId].capabilityDescriptorNumber == *pCapDescId)
    {
      p_cap_desc = &pTermCapSet->capabilityDescriptors.value[uId];
      break;
    }
  }
  if (p_cap_desc == NULL)
  {
    ASSERT(pTermCapSet->capabilityDescriptors.count < 256);
    p_cap_desc = &pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count];
    p_cap_desc->capabilityDescriptorNumber = (CapabilityDescriptorNumber) *pCapDescId;
    bNewDescriptor = TRUE;
  }
  else
  {
    bNewDescriptor = FALSE;
  }
  if (p_cap_desc->smltnsCpblts)
    dealloc_simultaneous_cap (p_cap_desc);

  /* for every entry in the altcap list */
  for (sim_cap = 0; sim_cap < pCapDesc->Length; ++sim_cap)
  {
    /* check for out of bounds error or memory allocation failure */
    if ((pCapDesc->SimCapArray[sim_cap].Length > 256) ||
        (!(p_sim_cap = (SmltnsCpbltsLink)alloc_link(sizeof(*p_sim_cap)))))
    {
      if (p_cap_desc->smltnsCpblts)
        dealloc_simultaneous_cap (p_cap_desc);
      H245TRACE(pInstance->dwInst,1,"API:set_cap_descriptor - no memory");
      return H245_ERROR_NOMEM;
    }

    if (!p_cap_desc->smltnsCpblts)
    {
      /* first time through */
      p_cap_desc->smltnsCpblts = p_sim_cap;
    }
    else
    {
      /* every other time through */
      ASSERT (p_sim_cap_lst);
      p_sim_cap_lst->next = p_sim_cap;
    }

    /* setup for next time through */
    p_sim_cap_lst = p_sim_cap;

    /* load up the new simultanoius cap */
    for (alt_cap = 0; alt_cap < pCapDesc->SimCapArray[sim_cap].Length; ++alt_cap)
    {
      if (!(find_capid_by_entrynumber (&pInstance->API.PDU_LocalTermCap.TERMCAPSET,
                                   pCapDesc->SimCapArray[sim_cap].AltCaps[alt_cap])))
      {
        if (p_cap_desc->smltnsCpblts)
          dealloc_simultaneous_cap (p_cap_desc);
        return H245_ERROR_INVALID_CAPID;
      }

      /* assign Altcap */
      p_sim_cap->value.value[alt_cap] = (unsigned short)pCapDesc->SimCapArray[sim_cap].AltCaps[alt_cap];
    } /* for C*/

    /* set count */
    p_sim_cap->value.count = (unsigned short)pCapDesc->SimCapArray[sim_cap].Length;

  } /* for */

  /* Success! */
  /* Set the simultaneous capabilities present bit */
  /* Increment the capability descriptor count */
  /* Set the descriptors present bit even though it may already be set */
  p_cap_desc->bit_mask |= smltnsCpblts_present;
  if (bNewDescriptor)
    pTermCapSet->capabilityDescriptors.count++;
  pTermCapSet->bit_mask |= capabilityDescriptors_present;

  return H245_ERROR_OK;
}

HRESULT del_cap_descriptor (struct InstanceStruct        *pInstance,
                            H245_CAPDESCID_T              CapDescId,
                            struct TerminalCapabilitySet *pTermCapSet)
{
  CapabilityDescriptor         *p_cap_desc;
  unsigned int                  uId;

  /* Check if capability descriptor already exists and if it is valid */
  p_cap_desc = NULL;
  for (uId = 0; uId < pTermCapSet->capabilityDescriptors.count; ++uId)
  {
    if (pTermCapSet->capabilityDescriptors.value[uId].capabilityDescriptorNumber == CapDescId)
    {
      p_cap_desc = &pTermCapSet->capabilityDescriptors.value[uId];
      break;
    }
  }
  if (p_cap_desc == NULL ||
      p_cap_desc->smltnsCpblts == NULL ||
      (p_cap_desc->bit_mask & smltnsCpblts_present) == 0)
    {
      H245TRACE(pInstance->dwInst,1,"API:del_cap_descriptor - invalid cap descriptor");
      return H245_ERROR_INVALID_CAPDESCID;
    }

  /* free up the list */
  dealloc_simultaneous_cap (p_cap_desc);

  pTermCapSet->capabilityDescriptors.count--;
  pTermCapSet->capabilityDescriptors.value[uId] =
    pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count];
  if (pTermCapSet->capabilityDescriptors.count == 0)
    pTermCapSet->bit_mask &= ~capabilityDescriptors_present;

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   free_object_id
 *
 * DESCRIPTION
 *
 * RETURN:      none
 *
 * ASSUMES:     none
 *
 *****************************************************************************/
void
free_object_id (POBJECTID p_obj_id)
{
  register POBJECTID p_obj_tmp;

  /* free all the objects */
  while (p_obj_id != NULL)
    {
      p_obj_tmp = p_obj_id;
      p_obj_id = p_obj_id->next;
      MemFree (p_obj_tmp);
    }
}

/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   free_mux_element
 *
 * DESCRIPTION
 *              free mux element desciptor list
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void free_mux_element (MultiplexElement *p_ASN_mux_el)
{
  int count = 0;

  if (p_ASN_mux_el->type.choice == subElementList_chosen)
    {
      if (p_ASN_mux_el->type.u.subElementList)
        {
          for (count = p_ASN_mux_el->type.u.subElementList->count;
               count;
               count--)
            {
              free_mux_element (&(p_ASN_mux_el->type.u.subElementList->value[count]));
            }
          MemFree (p_ASN_mux_el->type.u.subElementList);
        }
    }
}
/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   free_mux_desc_list
 *
 * DESCRIPTION
 *              free mux element desciptor list
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void
free_mux_desc_list (MultiplexEntryDescriptorLink p_ASN_med_link)
{
  MultiplexEntryDescriptorLink  p_ASN_med_link_tofree;

  /* free all entries on descriptor list */
  while (p_ASN_med_link)
    {
      int count = 0;

      for (count = p_ASN_med_link->value.elementList.count;
           count;
           count--)
        {
          free_mux_element (&(p_ASN_med_link->value.elementList.value[count]));
        }
      p_ASN_med_link_tofree = p_ASN_med_link;
      p_ASN_med_link = p_ASN_med_link->next;
      MemFree (p_ASN_med_link_tofree);
    }
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   alloc_link
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
H245_LINK_T  *
alloc_link (int size)
{
  H245_LINK_T *p_link = (H245_LINK_T *)MemAlloc (size);
  if (p_link)
    p_link->p_next = NULL;
  return p_link;
}


/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   alloc_new_capid -
 *
 * DESCRIPTION:
 *
 * ASSUMES:     Capability Table is locked before call
 *              Caller marks the bit_mask indicating when
 *                the table entry can be used.
 *
 * RETURN:              NULL     if not found
 *                      pCapLink if found
 *
 *****************************************************************************/
CapabilityTableLink
alloc_link_cap_entry ( struct TerminalCapabilitySet *pTermCapSet)
{
  register CapabilityTableLink  pCapLink;
  register CapabilityTableLink  pCapLinkSearch;

  ASSERT(pTermCapSet != NULL);

  pCapLink = (CapabilityTableLink)MemAlloc(sizeof(*pCapLink));
  if (pCapLink)
  {
    pCapLink->next = NULL;
    pCapLink->value.bit_mask = 0;
    pCapLinkSearch = pTermCapSet->capabilityTable;

    // Insert at END of linked list
    if (pCapLinkSearch)
    {
      while (pCapLinkSearch->next)
      {
        pCapLinkSearch = pCapLinkSearch->next;
      }
      pCapLinkSearch->next = pCapLink;
    }
    else
    {
      pTermCapSet->capabilityTable = pCapLink;
    }
  }

  return pCapLink;
} // alloc_link_cap_entry()


/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   dealloc_simultaneous_cap - deallocate alternative Cap Set
 *
 * DESCRIPTION
 *
 * RETURN:      N/A
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/

void dealloc_simultaneous_cap (CapabilityDescriptor *pCapdes)
{
  SmltnsCpbltsLink      p_sim_cap;
  SmltnsCpbltsLink      p_sim_cap_tmp;

  pCapdes->bit_mask &= ~smltnsCpblts_present;

  for (p_sim_cap = pCapdes->smltnsCpblts;
       p_sim_cap;
       )
    {
      p_sim_cap_tmp = p_sim_cap->next;
      MemFree (p_sim_cap);
      p_sim_cap = p_sim_cap_tmp;

    } /* for */

  pCapdes->smltnsCpblts = NULL;

} /* procedrue */

/*****************************************************************************
 *
 * TYPE:        local
 *
 * PROCEDURE:   find_capid_by_entrynumber -
 *
 * DESCRIPTION:
 *
 * RETURN:      NULL - if error
 *              capabiliytTableLink if ok
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
CapabilityTableLink
find_capid_by_entrynumber (
                           struct TerminalCapabilitySet *pTermCapSet,
                           H245_CAPID_T                  cap_id
                          )
{
  register CapabilityTableLink  pCapLink;

  ASSERT (pTermCapSet != NULL);

  for (pCapLink = pTermCapSet->capabilityTable;
       pCapLink;
       pCapLink = pCapLink->next)
  {
    if  (pCapLink->value.capabilityTableEntryNumber == cap_id &&
         pCapLink->value.bit_mask == capability_present)
    {
      return pCapLink;
    }
  }
  return NULL;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   load_cap
 *
 * DESCRIPTION: Takes a totcap and loads a capability structure
 *              i.e. Input is the total capability
 *                   Output is the *pCapability
 *              NOTE: Non Standard Capabilities.. allocate memory
 *                    which needs to be free'd later..
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
load_cap (struct Capability   *pCapability,  /* output */
          const H245_TOTCAP_T *pTotCap )     /* input  */
{
  HRESULT                       lError = H245_ERROR_OK;

  H245TRACE(0,10,"API:laod_cap <-");

  switch (pTotCap->ClientType)
    {
    /* General NON Standard Cap */
    case H245_CLIENT_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_NONSTD");
      lError = CopyNonStandardParameter(&pCapability->u.Capability_nonStandard,
                                        &pTotCap->Cap.H245_NonStd);
      break;

    /* VIDEO */
    case H245_CLIENT_VID_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_NONSTD");
      lError = CopyNonStandardParameter(&pCapability->u.receiveVideoCapability.u.VdCpblty_nonStandard,
                                        &pTotCap->Cap.H245Vid_NONSTD);
      pCapability->u.receiveVideoCapability.choice = VdCpblty_nonStandard_chosen;
      break;
    case H245_CLIENT_VID_H261:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_H261");
      pCapability->u.receiveVideoCapability.u.h261VideoCapability = pTotCap->Cap.H245Vid_H261;
      pCapability->u.receiveVideoCapability.choice = h261VideoCapability_chosen;
      break;
    case H245_CLIENT_VID_H262:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_H262");
      pCapability->u.receiveVideoCapability.u.h262VideoCapability = pTotCap->Cap.H245Vid_H262;
      pCapability->u.receiveVideoCapability.choice = h262VideoCapability_chosen;
      break;
    case H245_CLIENT_VID_H263:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_H263");
      pCapability->u.receiveVideoCapability.u.h263VideoCapability = pTotCap->Cap.H245Vid_H263;
      pCapability->u.receiveVideoCapability.choice = h263VideoCapability_chosen;
      break;
    case H245_CLIENT_VID_IS11172:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_IS11172");
      pCapability->u.receiveVideoCapability.u.is11172VideoCapability = pTotCap->Cap.H245Vid_IS11172;
      pCapability->u.receiveVideoCapability.choice = is11172VideoCapability_chosen;
      break;

    /* AUDIO */
    case H245_CLIENT_AUD_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_NONSTD");
      lError = CopyNonStandardParameter(&pCapability->u.receiveAudioCapability.u.AdCpblty_nonStandard,
                                        &pTotCap->Cap.H245Aud_NONSTD);
      pCapability->u.receiveAudioCapability.choice = AdCpblty_nonStandard_chosen;
      break;
    case H245_CLIENT_AUD_G711_ALAW64:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ALAW64");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw64k = pTotCap->Cap.H245Aud_G711_ALAW64;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Alaw64k_chosen;
      break;
    case H245_CLIENT_AUD_G711_ALAW56:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ALAW56");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw56k = pTotCap->Cap.H245Aud_G711_ALAW56;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Alaw56k_chosen;
      break;
    case H245_CLIENT_AUD_G711_ULAW64:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ULAW64");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw64k = pTotCap->Cap.H245Aud_G711_ULAW64;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Ulaw64k_chosen;
      break;
    case H245_CLIENT_AUD_G711_ULAW56:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ULAW56");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw56k = pTotCap->Cap.H245Aud_G711_ULAW56;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Ulaw56k_chosen;
      break;
    case H245_CLIENT_AUD_G722_64:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G722_64");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g722_64k = pTotCap->Cap.H245Aud_G722_64;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g722_64k_chosen;
      break;
    case H245_CLIENT_AUD_G722_56:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G722_56");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g722_56k = pTotCap->Cap.H245Aud_G722_56;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g722_56k_chosen;
      break;
    case H245_CLIENT_AUD_G722_48:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G722_48");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g722_48k = pTotCap->Cap.H245Aud_G722_48;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g722_48k_chosen;
      break;
    case H245_CLIENT_AUD_G723:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G723");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g7231 = pTotCap->Cap.H245Aud_G723;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g7231_chosen;
      break;
    case H245_CLIENT_AUD_G728:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G728");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g728 = pTotCap->Cap.H245Aud_G728;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g728_chosen;
      break;
    case H245_CLIENT_AUD_G729:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G729");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g729 = pTotCap->Cap.H245Aud_G729;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g729_chosen;
      break;
    case H245_CLIENT_AUD_GDSVD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_GDSVD");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g729AnnexA = pTotCap->Cap.H245Aud_GDSVD;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g729AnnexA_chosen;
      break;
    case H245_CLIENT_AUD_IS11172:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_IS11172");
      pCapability->u.receiveAudioCapability.u.is11172AudioCapability = pTotCap->Cap.H245Aud_IS11172;
      pCapability->u.receiveAudioCapability.choice = is11172AudioCapability_chosen;
      break;
    case H245_CLIENT_AUD_IS13818:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_IS13818");
      pCapability->u.receiveAudioCapability.u.is13818AudioCapability = pTotCap->Cap.H245Aud_IS13818;
      pCapability->u.receiveAudioCapability.choice = is13818AudioCapability_chosen;
      break;

    /* DATA */
    case H245_CLIENT_DAT_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_NONSTD");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_NONSTD;
      lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd,
                                              &pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd);
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_nnStndrd_chosen;
      break;
    case H245_CLIENT_DAT_T120:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_T120");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_T120;
      if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_t120_chosen;
      break;
    case H245_CLIENT_DAT_DSMCC:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_DSMCC");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_DSMCC;
      if (pTotCap->Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd,
                                                 &pTotCap->Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_dsm_cc_chosen;
      break;
    case H245_CLIENT_DAT_USERDATA:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_USERDATA");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_USERDATA;
      if (pTotCap->Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd,
                                              &pTotCap->Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_usrDt_chosen;
      break;
    case H245_CLIENT_DAT_T84:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_T84");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_T84;
      if (pTotCap->Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd,
                                                   &pTotCap->Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_t84_chosen;
      break;
    case H245_CLIENT_DAT_T434:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_T434");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_T434;
      if (pTotCap->Cap.H245Dat_T434.application.u.DACy_applctn_t434.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_T434.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_t434_chosen;
      break;
    case H245_CLIENT_DAT_H224:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_H224");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_H224;
      if (pTotCap->Cap.H245Dat_H224.application.u.DACy_applctn_h224.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_H224.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_h224_chosen;
      break;
    case H245_CLIENT_DAT_NLPID:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_NLPID");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_NLPID;
      if (pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd,
                                                 &pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd);
      }
      if (lError == H245_ERROR_OK && pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length != 0)
      {
        pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value =
          MemAlloc(pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
        if (pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value)
        {
          memcpy(pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
        }
        else
          lError = H245_ERROR_NOMEM;
      }
      else
        pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value = NULL;

      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_nlpd_chosen;
      break;
    case H245_CLIENT_DAT_DSVD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_DSVD");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_DSMCC;
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_dsvdCntrl_chosen;
      break;
    case H245_CLIENT_DAT_H222:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_H222");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_H222;
      if (pTotCap->Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_an_h222DtPrttnng_chosen ;
      break;
    default:
      H245TRACE(0,20,"API:load_cap - default");
      lError = H245_ERROR_NOSUP;
    } /* switch */

  if (lError != H245_ERROR_OK)
    H245TRACE(0,1,"API:load_cap -> %s",map_api_error(lError));
  else
    H245TRACE(0,10,"API:load_cap -> OK");
  return lError;
}


void
free_cap (struct Capability * pCapability,      // input, output
          const H245_TOTCAP_T *pTotCap)         // input
{
    ASSERT(!IsBadWritePtr(pCapability, sizeof(*pCapability)));

    switch (pTotCap->ClientType)
    {
        case H245_CLIENT_NONSTD:
            FreeNonStandardParameter(&pCapability->u.Capability_nonStandard);
            break;

        case H245_CLIENT_VID_NONSTD:
            FreeNonStandardParameter(&pCapability->u.receiveVideoCapability.u.VdCpblty_nonStandard);
            break;

        case H245_CLIENT_AUD_NONSTD:
            FreeNonStandardParameter(&pCapability->u.receiveAudioCapability.u.AdCpblty_nonStandard);
            break;

        case H245_CLIENT_DAT_NONSTD:
            FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd);
            break;

        case H245_CLIENT_DAT_T120:
            if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
            }
            else
            {
                if (pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value)
                {
                    WARNING_OUT(("H245_CLIENT_DAT_T120 no non-standard parameter to free"));
                }
            }
            break;

        case H245_CLIENT_DAT_DSMCC:
            if (pTotCap->Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_USERDATA:
            if (pTotCap->Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_T84:
            if (pTotCap->Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_T434:
            if (pTotCap->Cap.H245Dat_T434.application.u.DACy_applctn_t434.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_H224:
            if (pTotCap->Cap.H245Dat_H224.application.u.DACy_applctn_h224.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_NLPID:
            if (pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value)
            {
                MemFree(pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value);
            }

            if (pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_H222:
            if (pTotCap->Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd);
            }
            break;
    }
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   build_totcap_from_mux
 *
 * DESCRIPTION:
 *              called by both top down , and bottom up..
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/

HRESULT
build_totcap_from_mux(H245_TOTCAP_T *pTotCap, MultiplexCapability *pMuxCap, H245_CAPDIR_T Dir)
{
  H245TRACE(0,10,"API:build_totcap_from_mux <-");

  /* initialize TotCap */
  pTotCap->Dir        = Dir;
  pTotCap->DataType   = H245_DATA_MUX;
  pTotCap->ClientType = H245_CLIENT_DONTCARE;
  pTotCap->CapId      = 0;

  switch (pMuxCap->choice)
  {
  case MltplxCpblty_nonStandard_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - MltplxCpblty_nonStandard_chosen");
    pTotCap->Cap.H245Mux_NONSTD = pMuxCap->u.MltplxCpblty_nonStandard;
    pTotCap->ClientType = H245_CLIENT_MUX_NONSTD;
    // TBD - copy nonstandard parameter
    H245PANIC();
    break;

  case h222Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - h222Capability_chosen");
    pTotCap->Cap.H245Mux_H222 = pMuxCap->u.h222Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_H222;
    break;

  case h223Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - h223Capability_chosen");
    pTotCap->Cap.H245Mux_H223 = pMuxCap->u.h223Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_H223;
    break;

  case v76Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - v76Capability_chosen");
    pTotCap->Cap.H245Mux_VGMUX = pMuxCap->u.v76Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_VGMUX;
    break;

  case h2250Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - h2250Capability_chosen");
    pTotCap->Cap.H245Mux_H2250 = pMuxCap->u.h2250Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_H2250;
    break;

  default:
    H245TRACE(0,20,"API:build_totcap_from_mux - unrecogized choice %d", pMuxCap->choice);
    return H245_ERROR_NOSUP;
  }

  H245TRACE(0,10,"API:build_totcap_from_mux -> OK");
  return H245_ERROR_OK;
}


/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   build_totcap_from_captbl
 *
 * DESCRIPTION:
 *              called by both top down , and bottom up..
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
HRESULT
build_totcap_from_captbl (H245_TOTCAP_T        *pTotCap,
                          CapabilityTableLink   pCapLink,
                          int                   lcl_rmt)
{
  unsigned short choice;
  DWORD          error;

  H245TRACE(0,10,"API:build_totcap_from_captbl <-");

  /* initialize TotCap */
  pTotCap->Dir        = H245_CAPDIR_DONTCARE;
  pTotCap->DataType   = H245_DATA_DONTCARE;
  pTotCap->ClientType = H245_CLIENT_DONTCARE;
  pTotCap->CapId      = 0;

  /* note.. this has to come first if using for deleted caps */
  /* capability entry number will be present, however if     */
  /* the capability is not present that indicates that the   */
  /* capability should be deleted                            */

  pTotCap->CapId = pCapLink->value.capabilityTableEntryNumber;

  if (!(pCapLink->value.bit_mask & capability_present))
    return H245_ERROR_OK;

  switch (pCapLink->value.capability.choice)
    {
    case Capability_nonStandard_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - Capability_nonStandard_chosen");
      pTotCap->DataType = H245_DATA_NONSTD;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = Capability_nonStandard_chosen;
      break;
    case receiveVideoCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - receiveVideoCapability_chosen");
      pTotCap->DataType = H245_DATA_VIDEO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.receiveVideoCapability.choice;
      break;
    case transmitVideoCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - transmitVideoCapability_chosen");
      pTotCap->DataType = H245_DATA_VIDEO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLTX:H245_CAPDIR_RMTTX;
      choice            = pCapLink->value.capability.u.transmitVideoCapability.choice;
      break;
    case rcvAndTrnsmtVdCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rcvAndTrnsmtVdCpblty_chosen");
      pTotCap->DataType = H245_DATA_VIDEO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      choice            = pCapLink->value.capability.u.rcvAndTrnsmtVdCpblty.choice;
      break;
    case receiveAudioCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - receiveAudioCapability_chosen");
      pTotCap->DataType = H245_DATA_AUDIO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.receiveAudioCapability.choice;
      break;
    case transmitAudioCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - transmitAudioCapability_chosen");
      pTotCap->DataType = H245_DATA_AUDIO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLTX:H245_CAPDIR_RMTTX;
      choice            = pCapLink->value.capability.u.transmitAudioCapability.choice;
      break;
    case rcvAndTrnsmtAdCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rcvAndTrnsmtAdCpblty_chosen");
      pTotCap->DataType = H245_DATA_AUDIO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      choice            = pCapLink->value.capability.u.rcvAndTrnsmtAdCpblty.choice;
      break;
    case rcvDtApplctnCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rcvDtApplctnCpblty_chosen");
      pTotCap->DataType = H245_DATA_DATA;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.rcvDtApplctnCpblty.application.choice;
      break;
    case trnsmtDtApplctnCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - trnsmtDtApplctnCpblty_chosen");
      pTotCap->DataType = H245_DATA_DATA;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLTX:H245_CAPDIR_RMTTX;
      choice            = pCapLink->value.capability.u.trnsmtDtApplctnCpblty.application.choice;
      break;
    case rATDACy_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rATDACy_chosen");
      pTotCap->DataType = H245_DATA_DATA;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.rATDACy.application.choice;
      break;
    case h233EncryptnTrnsmtCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - h233EncryptnTrnsmtCpblty_chosen");
      pTotCap->DataType = H245_DATA_ENCRYPT_D;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      /* (TBC) */
      return H245_ERROR_NOSUP;
      break;
    case h233EncryptnRcvCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - h233EncryptnRcvCpblty_chosen");
      pTotCap->DataType = H245_DATA_ENCRYPT_D;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      /* (TBC) */
      return H245_ERROR_NOSUP;
      break;
    default:
      H245TRACE(0,20,"API:build_totcap_from_captbl - default");
      /* TBC .. */
      return H245_ERROR_NOSUP;
      break;
    }

  /* load the tot cap's capability and client from capability */
  if ((error = build_totcap_cap_n_client_from_capability (&pCapLink->value.capability,
                                                         pTotCap->DataType,
                                                         choice,
                                                         pTotCap)) != H245_ERROR_OK)
    {
      H245TRACE(0,1,"API:build_totcap_from_captbl -> %s",map_api_error(error));
      return error;
    }

  H245TRACE(0,10,"API:build_totcap_from_captbl -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   build_totcap_n_client_from_capbility
 *
 * DESCRIPTION:
 *              Take a capability structure (pCapability),
 *              data type (audio/video/data) choice...
 *              Which is found in the pdu . and the totcap;
 *              NOTE: does not handle H245_DATA_MUX_T
 *
 * RETURN:
 *
 * ASSUMES:
 *              ONLY HANDLES Terminal Caps.. Does not handle MUX Caps.
 *
 *              totcap.DataType is defined
 *              totcap.CapId    is defined
 *              totcap.Cap      is non NULL
 *
 *****************************************************************************/
HRESULT
build_totcap_cap_n_client_from_capability (struct Capability    *pCapability,
                                          H245_DATA_T            data_type,
                                          unsigned short         choice,
                                          H245_TOTCAP_T         *pTotCap)
{
  H245TRACE(0,10,"API:build_totcap_cap_n_client_from_capability <-");

  switch (data_type)
    {
    case H245_DATA_NONSTD:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_NONSTD");
      pTotCap->ClientType = H245_CLIENT_NONSTD;
      pTotCap->Cap.H245_NonStd = pCapability->u.Capability_nonStandard;
      break;

    case H245_DATA_AUDIO:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_AUDIO");
      switch (choice)
        {
        case AdCpblty_nonStandard_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_nonStandard_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_NONSTD;
          pTotCap->Cap.H245Aud_NONSTD      = pCapability->u.receiveAudioCapability.u.AdCpblty_nonStandard;
          break;
        case AdCpblty_g711Alaw64k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Alaw64k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ALAW64;
          pTotCap->Cap.H245Aud_G711_ALAW64 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw64k;
          break;
        case AdCpblty_g711Alaw56k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Alaw56k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ALAW56;
          pTotCap->Cap.H245Aud_G711_ALAW56 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw56k;
          break;
        case AdCpblty_g711Ulaw64k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Ulaw64k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ULAW64;
          pTotCap->Cap.H245Aud_G711_ULAW64 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw64k;
          break;
        case AdCpblty_g711Ulaw56k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Ulaw56k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ULAW56;
          pTotCap->Cap.H245Aud_G711_ULAW56 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw56k;
          break;
        case AudioCapability_g722_64k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g722_64k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G722_64;
          pTotCap->Cap.H245Aud_G722_64     = pCapability->u.receiveAudioCapability.u.AudioCapability_g722_64k;
          break;
        case AudioCapability_g722_56k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g722_56k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G722_56;
          pTotCap->Cap.H245Aud_G722_56     = pCapability->u.receiveAudioCapability.u.AudioCapability_g722_56k;
          break;
        case AudioCapability_g722_48k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g722_48k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G722_48;
          pTotCap->Cap.H245Aud_G722_48     = pCapability->u.receiveAudioCapability.u.AudioCapability_g722_48k;
          break;
        case AudioCapability_g7231_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g7231_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G723;
          pTotCap->Cap.H245Aud_G723        = pCapability->u.receiveAudioCapability.u.AudioCapability_g7231;
          break;
        case AudioCapability_g728_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g728_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G728;
          pTotCap->Cap.H245Aud_G728        = pCapability->u.receiveAudioCapability.u.AudioCapability_g728;
          break;
        case AudioCapability_g729_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g729_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G729;
          pTotCap->Cap.H245Aud_G729        = pCapability->u.receiveAudioCapability.u.AudioCapability_g729;
          break;
        case AdCpblty_g729AnnexA_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g729AnnexA_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_GDSVD;
          pTotCap->Cap.H245Aud_GDSVD       = pCapability->u.receiveAudioCapability.u.AdCpblty_g729AnnexA;
          break;
        case is11172AudioCapability_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - is11172AudioCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_IS11172;
          pTotCap->Cap.H245Aud_IS11172     = pCapability->u.receiveAudioCapability.u.is11172AudioCapability;
          break;
        case is13818AudioCapability_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - is13818AudioCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_IS13818;
          pTotCap->Cap.H245Aud_IS13818     = pCapability->u.receiveAudioCapability.u.is13818AudioCapability;
          break;
        default:
          pTotCap->ClientType = 0;
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - default");
          return H245_ERROR_NOSUP;
          break;
        }
      break;

    case H245_DATA_VIDEO:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_VIDEO");

      switch (choice)
        {
        case VdCpblty_nonStandard_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - VdCpblty_nonStandard_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_NONSTD;
          pTotCap->Cap.H245Vid_NONSTD    = pCapability->u.receiveVideoCapability.u.VdCpblty_nonStandard;
          break;
        case h261VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - h261VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_H261;
          pTotCap->Cap.H245Vid_H261      = pCapability->u.receiveVideoCapability.u.h261VideoCapability;
          break;
        case h262VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - h262VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_H262;
          pTotCap->Cap.H245Vid_H262      = pCapability->u.receiveVideoCapability.u.h262VideoCapability;
          break;
        case h263VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - h263VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_H263;
          pTotCap->Cap.H245Vid_H263      = pCapability->u.receiveVideoCapability.u.h263VideoCapability;
          break;
        case is11172VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - is11172VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_IS11172;
          pTotCap->Cap.H245Vid_IS11172   = pCapability->u.receiveVideoCapability.u.is11172VideoCapability;
          break;
        default:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - default");
          pTotCap->ClientType = 0;
          return H245_ERROR_NOSUP;
          break;
        }
      break;

    case H245_DATA_DATA:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_DATA");

      pTotCap->Cap.H245Dat_NONSTD = pCapability->u.rcvDtApplctnCpblty;
      switch (choice)
        {
        case DACy_applctn_nnStndrd_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_nnStndrd_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_NONSTD;
          break;
        case DACy_applctn_t120_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_t120_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_T120;
          break;
        case DACy_applctn_dsm_cc_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_dsm_cc_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_DSMCC;
          break;
        case DACy_applctn_usrDt_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_usrDt_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_USERDATA;
          break;
        case DACy_applctn_t84_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_t84_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_T84;
          break;
        case DACy_applctn_t434_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_t434_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_T434;
          break;
        case DACy_applctn_h224_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_h224_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_H224;
          break;
        case DACy_applctn_nlpd_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_nlpd_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_NLPID;
          break;
        case DACy_applctn_dsvdCntrl_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_dsvdCntrl_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_DSVD;
          break;
        case DACy_an_h222DtPrttnng_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_an_h222DtPrttnng_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_H222;
          break;
        default:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - default");
          pTotCap->ClientType = 0;
          return H245_ERROR_NOSUP;
          break;
        }
      break;
    case H245_DATA_ENCRYPT_D:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_ENCRYPT_D");
      pTotCap->ClientType = 0;
      H245PANIC();
      return H245_ERROR_NOSUP;
      break;
    case H245_DATA_MUX:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_MUX");
      pTotCap->ClientType = 0;
      H245PANIC();
      return H245_ERROR_NOSUP;
      break;
    default:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - default");
      pTotCap->ClientType = 0;
      H245PANIC();
      return H245_ERROR_NOSUP;
    }

  H245TRACE(0,10,"API:build_totcap_cap_n_client_from_capability -> OK");
  return H245_ERROR_OK;
}
/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   del_link
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
HRESULT
del_link (
          H245_LINK_T   **pp_link_start,
          H245_LINK_T   *p_link
          )
{
  struct H245_LINK_T    *p_link_look = NULL;
  struct H245_LINK_T    *p_link_lst = NULL;

  H245TRACE(0,10,"API:del_link <-");
  /* get current count on table */

  for (p_link_look = *pp_link_start;
       p_link_look && (p_link_look != p_link);
       p_link_lst = p_link_look,
         p_link_look = p_link_look->p_next
       );

  /* cap was not in list */

  if (!p_link_look)
  {
    H245TRACE(0,1,"API:del_link -> link not found!");
    return H245_ERROR_PARAM;
  }

  /* modify entry in table */
  if (!p_link_lst)
    *pp_link_start = p_link_look->p_next;

  else
    p_link_lst->p_next = p_link_look->p_next;

  MemFree (p_link_look);

  H245TRACE(0,10,"API:del_link -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   del_cap_link
 *
 * DESCRIPTION:
 *
 * ASSUMES:     Capability Table is locked before call
 *
 * RETURN:      None
 *
 * ASSUME:      List is Locked
 *
 *
 *****************************************************************************/
HRESULT
del_cap_link (
               struct TerminalCapabilitySet    *pTermCapSet,  /* capabilty set */
               CapabilityTableLink              pCapLink
             )
{
  CapabilityTableLink           pCapLink_look = NULL;
  CapabilityTableLink           pCapLink_lst = NULL;
  CapabilityTableEntry         *pCap_entry = NULL;
  unsigned char                *p_char_to_free = NULL;
  POBJECTID                     p_objid_to_free = NULL;

  H245TRACE(0,10,"API:del_cap_link <-");

  ASSERT (pTermCapSet);
  ASSERT (pCapLink);

  /************************************************/
  /* BEGIN :  Non Standard Capability Special Case */
  /************************************************/
  switch (pCapLink->value.capability.choice)
    {
    case Capability_nonStandard_chosen:

      /* free nonstandard data value */
      p_char_to_free = pCapLink->value.capability.u.Capability_nonStandard.data.value;

      /* free the object id */
      if (pCapLink->value.capability.u.Capability_nonStandard.nonStandardIdentifier.choice == object_chosen)
        p_objid_to_free = pCapLink->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.object;
      break;

    case receiveVideoCapability_chosen:
    case transmitVideoCapability_chosen:
    case rcvAndTrnsmtVdCpblty_chosen:

      /* free nonstandard data value */
      if (pCapLink->value.capability.u.receiveVideoCapability.choice == VdCpblty_nonStandard_chosen)
        {
          /* nonstd value */
          p_char_to_free = pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard.data.value;
          /* free the object id */
          if (pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard.nonStandardIdentifier.choice == object_chosen)
            p_objid_to_free = pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard.nonStandardIdentifier.u.object;
        }

      break;

    case receiveAudioCapability_chosen:
    case transmitAudioCapability_chosen:
    case rcvAndTrnsmtAdCpblty_chosen:

      /* free nonstandard data value */
      if (pCapLink->value.capability.u.receiveAudioCapability.choice == AdCpblty_nonStandard_chosen)
        {
          /* nonstd value */
          p_char_to_free = pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard.data.value;

          /* free the object id */
          if (pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard.nonStandardIdentifier.choice == object_chosen)
            p_objid_to_free = pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard.nonStandardIdentifier.u.object;
        }
      break;

    case rcvDtApplctnCpblty_chosen:
    case trnsmtDtApplctnCpblty_chosen:
    case rATDACy_chosen :

      if (pCapLink->value.capability.u.rcvDtApplctnCpblty.application.choice == DACy_applctn_nnStndrd_chosen)
        {
          /* free nonstandard data value */
          p_char_to_free = pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd.data.value;

          /* free the object id */
          if (pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.choice == object_chosen)
            p_objid_to_free = pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object;
        }
      break;

    case h233EncryptnTrnsmtCpblty_chosen:
    case h233EncryptnRcvCpblty_chosen:
    default:
      break;
    }

  /* free the value if there is one */
  if (p_char_to_free)
    {
      H245TRACE(0,0,"TMPMSG: Free NonStandard Value");
      MemFree(p_char_to_free);
    }

  /* free the objectid */
  if (p_objid_to_free)
    {
      H245TRACE(0,0,"TMPMSG: Free NonStandard ID");
      free_object_id (p_objid_to_free);
    }

  /************************************************/
  /* END :  Non Standard Capability Special Case  */
  /************************************************/

  H245TRACE(0,10,"API:del_cap_link -> OK");
  return del_link(&((H245_LINK_T *) pTermCapSet->capabilityTable),
           (H245_LINK_T *) pCapLink);
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   dealloc_link_cap_list
 *
 * DESCRIPTION: deallocs the entire list of capabilities from a capabiltiy
 *              set
 *
 * ASSUMES:     Capability Table is locked before call
 *              del_cap_link updates pTermCapSet->capabilityTable
 *                   correctly.
 *
 *****************************************************************************/
void
dealloc_link_cap_list ( struct TerminalCapabilitySet *pTermCapSet)
{
  while (pTermCapSet->capabilityTable)
    del_cap_link  (pTermCapSet, pTermCapSet->capabilityTable);
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   clean_cap_table - clean out all unused cap entries
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:     on entry.. table locked
 *
 *****************************************************************************/
void
clean_cap_table( struct TerminalCapabilitySet *pTermCapSet )
{
  CapabilityTableLink   pCapLink;
  CapabilityTableLink   pCap_nxt;

  H245TRACE(0,10,"API:clean_cap_table <-");
  /* traverse through the list.. delete all where capabilities are not set */

  for (pCapLink = pTermCapSet->capabilityTable;
       pCapLink;)
    {
      pCap_nxt = pCapLink->next;

      if (!(pCapLink->value.bit_mask & capability_present))
        {
          H245TRACE(0,20,"API:clean_cap_table - deleting CapId = %d",
                    pCapLink->value.capabilityTableEntryNumber);
          del_cap_link ( pTermCapSet, pCapLink );
        }
      pCapLink = pCap_nxt;
    }

  /* if no tercaps present unset flag */
  if (!pTermCapSet->capabilityTable)
    pTermCapSet->bit_mask &= ~capabilityTable_present;

  H245TRACE(0,10,"API:clean_cap_table -> OK");
}


/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   alloc_link_tracker
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
alloc_link_tracker (struct InstanceStruct *     pInstance,
                    API_TRACKER_T               TrackerType,
                    DWORD_PTR                   dwTransId,
                    API_TRACKER_STATE_T         State,
                    API_TRACKER_CH_ALLOC_T      ChannelAlloc,
                    API_TRACKER_CH_T            ChannelType,
                    H245_DATA_T                 DataType,
                    H245_CHANNEL_T              wTxChannel,
                    H245_CHANNEL_T              wRxChannel,
                    DWORD                       MuxEntryCount
                    )
{
  Tracker_T *p_tracker;

  H245TRACE(pInstance->dwInst,10,"API:alloc_link_tracker <-");
  /* allocate tracker object */

  if (!(p_tracker = (Tracker_T *)MemAlloc(sizeof(Tracker_T))))
  {
    H245TRACE(pInstance->dwInst,1,"API:alloc_link_trakcer -> No memory");
    return NULL;
  }

  p_tracker->TrackerType            = TrackerType;
  p_tracker->TransId                = dwTransId;
  p_tracker->State                  = State;
  switch (TrackerType)
  {
  case API_OPEN_CHANNEL_T:
  case API_CLOSE_CHANNEL_T:
    p_tracker->u.Channel.ChannelAlloc = ChannelAlloc;
    p_tracker->u.Channel.ChannelType  = ChannelType;
    p_tracker->u.Channel.DataType     = DataType;
    p_tracker->u.Channel.TxChannel    = wTxChannel;
    p_tracker->u.Channel.RxChannel    = wRxChannel;
    break;

  case API_SEND_MUX_T:
  case API_RECV_MUX_T:
    p_tracker->u.MuxEntryCount        = MuxEntryCount;
    break;

  default:
    break;
  } // switch

  p_tracker->p_next                 = pInstance->API.pTracker;
  if (p_tracker->p_next)
  {
    p_tracker->p_prev = p_tracker->p_next->p_prev;
    p_tracker->p_next->p_prev = p_tracker;
  }
  else
  {

    p_tracker->p_prev = NULL;
  }
  pInstance->API.pTracker = p_tracker;

  H245TRACE(pInstance->dwInst,10,"API:alloc_link_tracker -> %x", p_tracker);
  return p_tracker;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void
unlink_dealloc_tracker (struct InstanceStruct *pInstance,  Tracker_T *p_tracker)
{
  H245TRACE(pInstance->dwInst,4,"API:unlink_dealloc_tracker - type = %s",map_tracker_type (p_tracker->TrackerType));

  if (p_tracker->p_next)
    p_tracker->p_next->p_prev 