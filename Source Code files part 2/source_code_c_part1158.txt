ut;
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::Add
//
//  Synopsis:   Add element in a property based hash table
//
//  History:    12-Nov-98   TarunA      Created
//              24-Nov-98   JohnStra    Take out sort
//
//---------------------------------------------------------------------------
inline void CCtxPropHashTable::Add(CObjectContext *pContext)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CCtxPropHashTable::Add [IN] pContext:%p count:%d\n",
        pContext, pContext->GetPropertyList()->GetCount()));

    // Preconditions: caller must hold context lock and context must be frozen.
    ASSERT_LOCK_HELD(gContextLock);
    Win4Assert(pContext->IsFrozen());

    if(pContext->GetPropertyList()->GetCount())
    {
        DWORD dwHash = pContext->GetPropertyList()->GetHash() % NUM_HASH_BUCKETS;
        ComDebOut((DEB_OBJECTCONTEXT, "   dwHash:%d\n", dwHash));

        // Sanity check
        Win4Assert(dwHash == (CCtxTable::s_CtxPropHashTable.HashNode(
                          pContext->GetPropHashChain()) % NUM_HASH_BUCKETS));

        CHashTable::Add(dwHash, pContext->GetPropHashChain());

#if DBG==1
        ComDebOut((DEB_OBJECTCONTEXT,
            "   &CCtxTable::s_CtxPropBuckets[%d]:%p\n",
            dwHash, &CCtxTable::s_CtxPropBuckets[dwHash]));

        CObjectContext* pKey;
        SHashChain *pHead = &CCtxTable::s_CtxPropBuckets[dwHash];
        SHashChain *pNode = pHead->pNext;
        while (pNode != &CCtxTable::s_CtxPropBuckets[dwHash])
        {
            pKey = CObjectContext::HashPropChainToContext(pNode);
            ComDebOut((DEB_OBJECTCONTEXT,
                "      pNode:%p pNext:%p pPrev:%p pKey:%p\n",
                pNode, pNode->pNext, pNode->pPrev, pKey));
            pNode = pNode->pNext;
        }
#endif
    }

    // Postconditions: must still hold context lock.
    ASSERT_LOCK_HELD(gContextLock);
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::Remove
//
//  Synopsis:   Remove element in a property based hash table
//
//              NOTE: A context is removed in from the table only if
//              (1) The property list is sorted
//              (2) There are non-zero number of elements in the list
//
//  History:    12-Nov-98   TarunA      Created
//              24-Nov-98   JohnStra    Take out sort
//
//---------------------------------------------------------------------------
inline void CCtxPropHashTable::Remove(CObjectContext *pContext)
{
    ComDebOut((DEB_OBJECTCONTEXT, "CCtxPropHashTable::Remove [IN] pContext:%p\n", pContext));

    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    ComDebOut((DEB_OBJECTCONTEXT, "   pContext:%p\n", pContext));

    // Remove only if there are elements in the sorted list
    if (pContext->GetPropertyList()->GetCount())
    {
        CHashTable::Remove(pContext->GetPropHashChain());

#if DBG==1
        DWORD dwHash =
            pContext->GetPropertyList()->GetHash() % NUM_HASH_BUCKETS;

        ComDebOut((DEB_OBJECTCONTEXT, "   dwHash:%d\n", dwHash));
        ComDebOut((DEB_OBJECTCONTEXT,
            "   &CCtxTable::s_CtxPropBuckets[%d]:%p\n",
            dwHash, &CCtxTable::s_CtxPropBuckets[dwHash]));

        CObjectContext* pKey;
        SHashChain *pHead = &CCtxTable::s_CtxPropBuckets[dwHash];
        SHashChain *pNode = pHead->pNext;
        while (pNode != &CCtxTable::s_CtxPropBuckets[dwHash])
        {
            pKey = CObjectContext::HashPropChainToContext(pNode);
            ComDebOut((DEB_OBJECTCONTEXT,
                "      pNode:%p pNext:%p pPrev:%p pKey:%p\n",
                pNode, pNode->pNext, pNode->pPrev, pKey));
            pNode = pNode->pNext;
        }
#endif

        pContext->InPropTable(FALSE);
    }

    // Postconditions: Must still hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    ComDebOut((DEB_OBJECTCONTEXT, "CCtxPropHashTable::Remove [OUT] pContext:%p\n"));
}


//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given node
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline DWORD CCtxUUIDHashTable::HashNode(SHashChain *pNode)
{
    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

	Win4Assert(pNode && "Attempted to hash a NULL CObjectContext pointer");
	if (pNode == NULL)
		return 0;

    return (CObjectContext::HashUUIDChainToContext(pNode))->GetHashOfId();
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CCtxUUIDHashTable::Compare(
    const void *pv,
    SHashChain *pNode,
    DWORD       dwHash)
{
    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    CObjectContext *pContext = CObjectContext::HashUUIDChainToContext(pNode);
    ContextID *pID = (ContextID *) pv;

    Win4Assert(pContext && "Comparing null context in context hash table");
	if (pContext == NULL)
		return (FALSE);

    // If the contextIds match then return TRUE else FALSE
    if(InlineIsEqualGUID(*pID, pContext->GetContextId()))
        return(TRUE);
    else
        return(FALSE);
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::Lookup
//
//  Synopsis:   Lookup in a UUID based hash table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline CObjectContext *CCtxUUIDHashTable::Lookup(REFGUID rguid)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CCtxUUIDHashTable::Lookup for riid:%I\n", &rguid));

    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    DWORD dwHash = HashGuid(rguid);
    return(CObjectContext::HashUUIDChainToContext(CHashTable::Lookup(dwHash,
                                                  (const void *)&rguid)));
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::Add
//
//  Synopsis:   Add element in a UUID based hash table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline void CCtxUUIDHashTable::Add(CObjectContext *pContext)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CCtxUUIDHashTable::Add pContext:%p riid:%I\n",
        pContext, &pContext->GetContextId()));

    // Preconditions: caller must hold context lock.
    ASSERT_LOCK_HELD(gContextLock);

    DWORD dwHash = pContext->GetHashOfId();

    // Perform some sanity checks.

    // Verify that the hash value returned by the table when you hash the
    // node represented by this context and the cached hash value match.
    Win4Assert( dwHash == CCtxTable::s_CtxUUIDHashTable.HashNode(pContext->GetUUIDHashChain()) );

    // Verify that the cached hash value makes sense.
    Win4Assert( dwHash == HashGuid(pContext->GetContextId()) );

    // Verify that no other context having the same ContextId is in the list.
    Win4Assert( Lookup( pContext->GetContextId() ) == NULL );

    CHashTable::Add(dwHash, pContext->GetUUIDHashChain());

#if DBG == 1
    // Sanity check on the hash table list to which we added
    g_cCtxTableAdd++;
    SHashChain* pNode = &CCtxTable::s_CtxUUIDBuckets[dwHash];
    pNode = pNode->pNext;
    while(pNode !=  &CCtxTable::s_CtxUUIDBuckets[dwHash])
    {
        Win4Assert(pNode->pNext != pNode && pNode->pPrev != pNode);
        pNode = pNode->pNext;
    }
#endif

    // Postconditions: must still hold context lock.
    ASSERT_LOCK_HELD(gContextLock);
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxUUIDHashTable::Remove
//
//  Synopsis:   Remove element in a UUID based hash table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline void CCtxUUIDHashTable::Remove(CObjectContext *pContext)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CCtxUUIDHashTable::Remove pContext:%p riid:%I\n",
        pContext, &pContext->GetContextId()));

    // Preconditions: caller must hold the context lock.
    ASSERT_LOCK_HELD(gContextLock);

    CHashTable::Remove(pContext->GetUUIDHashChain());

#if DBG == 1
    g_cCtxTableRemove++;

    // Sanity check on the hash table list from which we removed
    DWORD iHash = (pContext->GetHashOfId());
    SHashChain* pNode = &CCtxTable::s_CtxUUIDBuckets[iHash];
    pNode = pNode->pNext;
    while(pNode !=  &CCtxTable::s_CtxUUIDBuckets[iHash])
    {
        Win4Assert((pNode->pNext != pNode) && (pNode->pPrev != pNode));
        pNode = pNode->pNext;
    }
#endif

    // Postconditions: should still be holding context lock.
    ASSERT_LOCK_HELD(gContextLock);
}


//---------------------------------------------------------------------------
//
//  Method:     CCtxTable::Initialize
//
//  Synopsis:   Initailizes the context table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
void CCtxTable::Initialize()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CCtxTable::Initialize\n"));
    ASSERT_LOCK_HELD(gContextLock);

    // Avoid double init
    if(!s_fInitialized)
    {
        // Initialize property based hash table
        s_CtxPropHashTable.Initialize(s_CtxPropBuckets, &gContextLock);

        // Initialize UUID based hash table
        s_CtxUUIDHashTable.Initialize(s_CtxUUIDBuckets, &gContextLock);

        // Mark the state as initialized
        s_fInitialized = TRUE;
    }

    ASSERT_LOCK_HELD(gContextLock);
    return;
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxTable::Cleanup
//
//  Synopsis:   Cleanup the context table
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
void CCtxTable::Cleanup()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CCtxTable::Cleanup\n"));
    ASSERT_LOCK_HELD(gContextLock);

    // Check if the table was initialized
    if(s_fInitialized)
    {
        // Cleanup property based hash table
        s_CtxPropHashTable.Cleanup(CleanupCtxTableEntry);

        // Cleanup UUID based hash table
        s_CtxUUIDHashTable.Cleanup(CleanupCtxTableEntry);

        // State is no longer initialized
        s_fInitialized = FALSE;
    }

    ASSERT_LOCK_HELD(gContextLock);
    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCtxTable::LookupExistingContext    public
//
//  Synopsis:   Lookup the property based hash table to find a matching
//              context
//
//  Notes:      This is called during the activation path to reuse
//              existing contexts.
//
//  History:    12-Nov-98   TarunA       Created
//              24-Nov-98   JohnStra     Take out sort
//
//----------------------------------------------------------------------------
CObjectContext* CCtxTable::LookupExistingContext(CObjectContext *pContext)
{
    // Preconditions: Caller must hold the context lock and the context
    // must be frozen.
    ASSERT_LOCK_HELD(gContextLock);
    Win4Assert(pContext->IsFrozen());

    // look in the property based hash table for a matching context
    CObjectContext *pMatchingContext = s_CtxPropHashTable.Lookup(pContext);
    if (pMatchingContext)
    {
        // Addref the context
        pMatchingContext->InternalAddRef();

#if DBG == 1
/*
    In debug builds, update some counters to keep track of how the
    cache is behaving.
*/

        // Found a matching context
        g_cCtxTableLookupSucceeded++;
    }

    // Number of lookups done
    g_cCtxTableLookup++;
#else
    }
#endif

    ASSERT_LOCK_HELD(gContextLock);
    return pMatchingContext;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCtxTable::LookupExistingContext    public
//
//  Synopsis:   Lookup the UUID based hash table to find a matching context
//
//  History:    12-Nov-98   TarunA       Created
//
//----------------------------------------------------------------------------
CObjectContext* CCtxTable::LookupExistingContext(REFGUID rguid)
{
    ASSERT_LOCK_HELD(gContextLock);

    // lookup the context in the uuid based hash table
    return s_CtxUUIDHashTable.Lookup(rguid);
}

//+--------------------------------------------------------------------------
//
//  Member:     CCtxTable::AddContext    public
//
//  Synopsis:   Adds a context to the hash table based on properties
//
//  History:    12-Nov-98   TarunA       Created
//              24-Nov-98   JohnStra     Take out sort
//
//----------------------------------------------------------------------------
HRESULT CCtxTable::AddContext(CObjectContext *pContext)
{
    // The context must be frozen
    Win4Assert(pContext->IsFrozen());

    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);

    // Add it to the table
    s_CtxPropHashTable.Add(pContext);
    pContext->InPropTable(TRUE);

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);
    return S_OK;
}

INTERNAL PrivGetObjectContext(REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_OBJECTCONTEXT, "PrivGetObjectContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Initialize

    *ppv = NULL;

    // Initalize channel

    hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        CObjectContext *pContext = GetCurrentContext();
        if (pContext)
            hr = pContext->InternalQueryInterface(riid, ppv);
        else
            hr = CO_E_NOTINITIALIZED;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_OBJECTCONTEXT,
                     "PrivGetObjectContext returning 0x%x\n", hr));
    return(hr);
}


INTERNAL PushServiceDomainContext (const ContextStackNode& csnCtxNode)
{
    HRESULT hr;
    
    COleTls tls (hr);
    if (SUCCEEDED(hr))
    {
        // Save the old context in a stack node
        ContextStackNode* pCtxNode = new ContextStackNode;
        if (!pCtxNode)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory (pCtxNode, &csnCtxNode, sizeof (ContextStackNode));

            pCtxNode->pNext = tls->pContextStack;    
            tls->pContextStack = pCtxNode;
        }
    }
    
    return hr;
}


INTERNAL PopServiceDomainContext (ContextStackNode* pcsnCtxNode)
{
    HRESULT hr;

    Win4Assert (pcsnCtxNode);
    ZeroMemory (pcsnCtxNode, sizeof (ContextStackNode));
    
    COleTls tls (hr);    
    if (SUCCEEDED(hr))
    {
        ContextStackNode* pOldNode = tls->pContextStack;
        if (!pOldNode)
        {
            hr = CONTEXT_E_NOCONTEXT;
        }
        else
        {
            tls->pContextStack = pOldNode->pNext;
            
            // Restore the new context
            CopyMemory (pcsnCtxNode, pOldNode, sizeof (ContextStackNode));
            
            delete pOldNode;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\ctxchnl.cxx ===
//+-------------------------------------------------------------------
//
//  File:       CtxChnl.cxx
//
//  Contents:   Support for context channels
//
//  Functions:  CCtxComChnl methods
//
//  History:    20-Dec-97   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <callctrl.hxx>
#include <ctxchnl.hxx>
#include <context.hxx>
#include <crossctx.hxx>

//+-------------------------------------------------------------------
//
// Class globals
//
//+-------------------------------------------------------------------
CPageAllocator     CCtxComChnl::s_allocator;    // Allocator for channel
COleStaticMutexSem CCtxComChnl::_mxsCtxChnlLock;// critical section
#if DBG==1
BOOL               CCtxComChnl::s_fInitialized; // Relied on being FALSE
size_t             CCtxComChnl::s_size;         // Relied on being ZERO
#endif

//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::QueryInterface     public
//
//  Synopsis:   QI behavior of CRpcCall object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::QueryInterface\n"));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_ICall))
    {
        *ppv = (ICall *) this;
    }
    else if(IsEqualIID(riid, IID_IRpcCall))
    {
        *ppv = (IRpcCall *) this;
    }
    else if(IsEqualIID(riid, IID_ICallInfo))
    {
        *ppv = (ICallInfo *) this;
    }
    else if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) (ICall *) this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // AddRef the interface before return
    if(*ppv)
        ((IUnknown *) (*ppv))->AddRef();

    ContextDebugOut((DEB_RPCCALL, "CRpcCall::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::AddRef     public
//
//  Synopsis:   AddRefs CRpcCall object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcCall::AddRef()
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::AddRef\n"));

    // Increment ref count
    // This object is not required to be thread safe
    return(++_cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::Release     public
//
//  Synopsis:   Release CRpcCall object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcCall::Release()
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::Release\n"));

    ULONG cRefs;

    // Decrement ref count
    // This object is not required to be thread safe
    cRefs = --_cRefs;
    // Check if this is the last release
    if(cRefs == 0)
    {
        // Delete call
        delete this;
    }

    ContextDebugOut((DEB_RPCCALL, "CRpcCall::Release returning 0x%x\n",
                     cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::GetCallInfo     public
//
//  Synopsis:   Implements IRpcCall::GetCallInfo
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::GetCallInfo(const void **ppIdentity, IID *pIID,
                                   DWORD *pdwMethod, HRESULT *phr)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetCallInfo\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    if(ppIdentity)
        *ppIdentity = _pIdentity;
    if(pIID)
        *pIID = _riid;
    if(pdwMethod)
        *pdwMethod = _pMessage->iMethod & ~RPC_FLAGS_VALID_BIT;
    if(phr)
        *phr = _hrRet;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::GetRpcOleMessage     public
//
//  Synopsis:   Implements IRpcCall::GetRpcOleMessage
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::GetRpcOleMessage(RPCOLEMESSAGE **ppMessage)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetCallInfo\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    *ppMessage = _pMessage;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::Nullify     public
//
//  Synopsis:   Implements IRpcCall::Nullify
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::Nullify(HRESULT hr)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetCallInfo\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (_hrRet == S_OK)
        _hrRet = hr;

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::GetServerHr     public
//
//  Synopsis:   Implements IRpcCall::GetServerHr
//
//  History:    2-Feb-99   Johnstra      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::GetServerHR(HRESULT *phr)
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetServerHr\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    if(phr)
        *phr = _ServerHR;
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CRpcCall::GetCallSource     public
//
//  Synopsis:   Implements ICallInfo::GetCallSource
//
//  History:    03-Feb-99   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CRpcCall::GetCallSource(CALLSOURCE* pCallSource)
                                   
{
    ContextDebugOut((DEB_RPCCALL, "CRpcCall::GetCallSource\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    *pCallSource = _callSource;

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Initialize     public
//
//  Synopsis:   Initializes allocator for channel object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxComChnl::Initialize(size_t size)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    LOCK(_mxsCtxChnlLock);

    // Assert that this initailization is not done twice
    Win4Assert(!s_fInitialized);
    Win4Assert(size == sizeof(CCtxComChnl));

    // Initialze the allocator
    s_allocator.Initialize(size, CHANNELS_PER_PAGE, &_mxsCtxChnlLock);

#if DBG==1
    s_fInitialized = TRUE;
    s_size = size;
#endif

    UNLOCK(_mxsCtxChnlLock);
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::operator new     public
//
//  Synopsis:   new operator of channel object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CCtxComChnl::operator new(size_t size)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::operator new\n"));
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);

    void *pv;

    // Assert that correct size is being requested
    Win4Assert(size == s_size &&
               "CCtxComChnl improperly initialized");

    // Allocate memory
    pv = (void *) s_allocator.AllocEntry();

    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::operator delete     public
//
//  Synopsis:   delete operator of channel object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxComChnl::operator delete(void *pv)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::operator delete\n"));
    ASSERT_LOCK_DONTCARE(_mxsCtxChnlLock);

    // Assert that allocator was initialized earlier
    Win4Assert(s_fInitialized);

#if DBG==1
    // Ensure that the pv was allocated by the allocator
    // CCtxComChnl can be inherited only by those objects
    // with overloaded new and delete operators
    LOCK(_mxsCtxChnlLock);
    LONG index = s_allocator.GetEntryIndex((PageEntry *) pv);
    UNLOCK(_mxsCtxChnlLock);
    Win4Assert(index != -1);
#endif

    // Release the pointer
    s_allocator.ReleaseEntry((PageEntry *) pv);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Cleanup     public
//
//  Synopsis:   Cleanup call objects and allocator for context channels
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxComChnl::Cleanup()
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    LOCK(_mxsCtxChnlLock);

    // Sanity check
    Win4Assert(s_fInitialized);

    // Cleanup context call object cache
    CCtxCall::Cleanup();

    // Cleanup allocator
    s_allocator.Cleanup();

    // Reset state
#if DBG==1
    s_fInitialized = FALSE;
#endif

    UNLOCK(_mxsCtxChnlLock);
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::CCtxComChnl     public
//
//  Synopsis:   Constructor of channel object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
CCtxComChnl::CCtxComChnl(CStdIdentity *pStdId, OXIDEntry *pOXIDEntry,
                         DWORD eState) :
    CAptRpcChnl(pStdId, pOXIDEntry, eState)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::CCtxComChnl\n"));
    ASSERT_LOCK_NOT_HELD(_mxsCtxChnlLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::~CCtxComChnl     public
//
//  Synopsis:   Destructor of channel object
//
//+-------------------------------------------------------------------
CCtxComChnl::~CCtxComChnl()
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::~CCtxComChnl\n"));
    ASSERT_LOCK_DONTCARE(_mxsCtxChnlLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::GetBuffer     public
//
//  Synopsis:   Implements IRpcChannelBuffer::GetBuffer
//
//              This method ensures that the interface has legally been
//              unmarshaled in the client context, identifies the right
//              policy set, asks it to resize the buffer requested by its
//              caller, saves the context call object in TLS, passes on
//              the request to CAptRpcChnl::GetBuffer, and finally returns
//              to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::GetBuffer(RPCOLEMESSAGE *pMessage, REFIID riid)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::GetBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(riid, iidName);
        char *side = Proxy() ? "ClientGetBuffer" : "ServerGetBuffer";

        ContextDebugOut((DEB_TRACECALLS,
                         "%s on interface %I (%ws) method 0x%x\n",
                         side, &riid, iidName, pMessage->iMethod));
    }
#endif

    // Initialize channel if necessary
    HRESULT hr = InitChannelIfNecessary();
    if(SUCCEEDED(hr))
    {
        HRESULT hrCall = S_OK;
        BOOL fClientSide = Proxy();
        CPolicySet *pPS;
        CCtxCall *pCtxCall = NULL;
        COleTls Tls;

        // Initialize
        pMessage->Buffer = NULL;

        // Check the current side
        if(fClientSide)
        {
#ifndef _WIN64
            // Sanity check
            Win4Assert(pMessage->reserved1 == NULL);
#endif	   
            // Obtain policy set
            CStdIdentity *pStdID = GetStdId();
            pPS = pStdID->GetClientPolicySet();

            // Ensure that the interface has legally been unmarshaled
            if((pPS == NULL) && pStdID->GetServerCtx() &&
               (GetCurrentContext() != GetEmptyContext()))
            {
                // Check for FTM proxies
                if(pStdID->IsFTM() || pStdID->IsFreeThreaded())
                {
                    BOOL fCreate = TRUE;
                    hr = ObtainPolicySet(GetCurrentContext(), NULL,
                                         PSFLAG_PROXYSIDE, &fCreate, &pPS);
                    if(SUCCEEDED(hr))
                    {
                        hr = pStdID->SetClientPolicySet(pPS);
                        pPS->Release();
                    }
                }
                else if(!pStdID->SystemObject())
                {
                    Win4Assert(!"Smuggled proxy");
                    hr = RPC_E_WRONG_THREAD;
                }
            }

            // Create a new context call object when policy set
            // is present
            if(pPS)
            {
                pCtxCall = new CCtxCall(CTXCALLFLAG_CLIENT,
                                        pMessage->dataRepresentation);
                if(pCtxCall == NULL)
                    hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            // On the server side, use the existing context call object
            // that was created inside ComInvoke
            pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetServerCtxCall();
            pPS = pCtxCall->_pPS;
            Win4Assert(pCtxCall);
            Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_SERVER);
            Win4Assert(pPS == GetStdId()->GetServerPolicySet());
        }

        if(SUCCEEDED(hr))
        {
            if(pPS)
            {
                // Create rpc call object on the stack
                CRpcCall rpcCall(GetStdId()->GetIdentity(),
                                 pMessage, riid, hrCall, CALLSOURCE_CROSSAPT);

                // Size the buffer as needed
                hr = pPS->GetSize(&rpcCall,
                                  fClientSide ? CALLTYPE_SYNCCALL : CALLTYPE_SYNCLEAVE,
                                  pCtxCall);

                // GetSize fails on the server side only if no policy
                // expressed interest in sending data to client side
                Win4Assert(SUCCEEDED(hr) || pCtxCall->_cbExtent==0);
            }

            // Check for the need to abort
            if(SUCCEEDED(hr))
            {
                // Store context call object in TLS
                CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

                // Delegate to CAptRpcChnl::GetBuffer
                hr = CAptRpcChnl::GetBuffer(pMessage, riid);
                Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);

                // Revoke context call object from TLS
                pCtxCall->RevokeFromTLS(Tls, pCurCall);
            }

            // Update state before returning to the proxy/stub
            if(SUCCEEDED(hr))
            {
                // On the clientside, save policy set inside context call
                // object for future reference
                if(fClientSide)
                {
                    // Save the context call object inside message call object
                    ((CMessageCall *) pMessage->reserved1)->SetClientCtxCall(pCtxCall);
                    if(pPS)
                    {
                        pPS->AddRef();
                        pCtxCall->_pPS = pPS;
                    }

                    // Increment per thread outstanding call count
                    if(!(pMessage->rpcFlags & RPC_BUFFER_ASYNC))
                        ++Tls->cCalls;
                }

                // Update state inside context call object
                if(pCtxCall)
                {
                    pCtxCall->_dwFlags |= CTXCALLFLAG_GBSUCCESS;
                    pCtxCall->_hr = hrCall;
                }
            }
            else
            {
                // Check side
                if(fClientSide)
                {
                    // delete context call object and
                    if(pCtxCall)
                        delete pCtxCall;
                }
                else
                {
                    // Reset state inside context call object
                    if(pCtxCall->_dwFlags & CTXCALLFLAG_FBDONE)
                        PrivMemFree(pCtxCall->_pvExtent);
                    CPolicySet::ResetState(pCtxCall);
                    pCtxCall->_dwFlags |= CTXCALLFLAG_GBFAILED;
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::GetBuffer is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::SendReceive     public
//
//  Synopsis:   Implements IRpcChannelBuffer::SendReceive
//
//              This method identifies the right policy set, asks it
//              to obtain client buffers from the policies, switches the
//              context, passes the request to CAptRpcChnl::SendReceive,
//              asks the policy set to deliver the buffers created by
//              the polices on the server side, and finally returns
//              to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::SendReceive(RPCOLEMESSAGE *pMessage, ULONG *pulStatus)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::SendReceive\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(GetIPIDEntry()->iid, iidName);

        ContextDebugOut((DEB_TRACECALLS,
                         "SendReceive on interface %I (%ws) method 0x%x\n",
                         &GetIPIDEntry()->iid, iidName,
                         (pMessage->iMethod & ~RPC_FLAGS_VALID_BIT)));
    }
#endif

    // Assert that this routine is called only on the client side
    Win4Assert(Proxy());

    // Obtain the context call object
    HRESULT hr = S_OK;
    COleTls Tls;
    CCtxCall *pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetClientCtxCall();

    // Store context call object in TLS
    CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

    // Check for context functionality
    if(pCtxCall)
    {
        // Ensure that GetBuffer succeeded
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS);

        // Create rpc call object on the stack
        CRpcCall rpcCall(GetStdId()->GetIdentity(),
                         pMessage, GetIPIDEntry()->iid, hr, CALLSOURCE_CROSSAPT);

        // Obtain the policy set that delivers events
        CPolicySet *pPS = pCtxCall->_pPS;
        Win4Assert(pPS);

        // Deliver client side call events
        hr = pPS->FillBuffer(&rpcCall, CALLTYPE_SYNCCALL, pCtxCall);

        // Reset state inside context call object
        CPolicySet::ResetState(pCtxCall);

        // Check for the need to abort
        BOOL fFreeBuffer = TRUE;
        if(SUCCEEDED(hr))
        {
            // Save current context inside context call object
            pCtxCall->_pContext = Tls->pCurrentCtx;

            // Delegate to CAptRpcChnl::SendReceive
            hr = CAptRpcChnl::SendReceive(pMessage, pulStatus);
            Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);

            // FreeBuffer need not be called for failure returns
            if(FAILED(hr))
            {
                // Do not touch any member variables here after as the
                // proxy manager might have deleted the channel due to
                // a nested release
                Win4Assert(pMessage->Buffer == NULL);
                fFreeBuffer = FALSE;
            }
        }
        else
        {
            // The call was failed during delivery of client-side call
            // events.  Free any marshaled interface ptrs in the marshal
            // buffer.
            ReleaseMarshalBuffer(pMessage, (IRpcProxyBuffer *)GetIPIDEntry()->pStub, FALSE);
        }

        // Deliver client side notification events
        hr = pPS->Notify(&rpcCall, CALLTYPE_SYNCRETURN, pCtxCall);

        // FreeBuffer if the call is being aborted
        if(FAILED(hr) && fFreeBuffer)
        {
            // The call was failed during the delivery of client-side
            // notify events.  Free any marshaled out-param interface
            // ptrs in the marshal buffer.
            ReleaseMarshalBuffer(pMessage, (IRpcProxyBuffer *)GetIPIDEntry()->pStub, TRUE);
            
            // Free the buffer obtained from CAptRpcChnl::GetBuffer
            CAptRpcChnl::FreeBuffer(pMessage);
            Win4Assert(pMessage->Buffer == NULL);

            *pulStatus = hr;
            hr = RPC_E_FAULT;
        }

        // Delete context call object for failure returns
        if(SUCCEEDED(hr))
            pCtxCall->_dwFlags |= CTXCALLFLAG_SRSUCCESS;
        else
            delete pCtxCall;
    }
    else
    {
        // Delegate to CAptRpcChnl::SendReceive
        hr = CAptRpcChnl::SendReceive(pMessage, pulStatus);
    }

    // Revoke context call object from TLS
    pCtxCall->RevokeFromTLS(Tls, pCurCall);

    // Check for failure returns
    if(FAILED(hr))
    {
        // Decrement per thread outstanding call count
        --Tls->cCalls;
        Win4Assert((LONG) Tls->cCalls >= 0);

        // Clear any pending uninit
        if((Tls->dwFlags & OLETLS_PENDINGUNINIT) && (Tls->cCalls == 0))
            CoUninitialize();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::SendReceive is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Send       public
//
//  Synopsis:   Implements IRpcChannelBuffer::Send
//
//              This method identifies the right policy set, asks it
//              to obtain buffers from the policies, passes the
//              request to CAptRpcChnl::Send, and returns to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::Send(RPCOLEMESSAGE *pMessage, ISynchronize *pSync,
                               ULONG *pulStatus)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Send\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    BOOL fClientSide = Proxy();
    REFIID riid = fClientSide ? GetIPIDEntry()->iid : *MSG_TO_IIDPTR(pMessage);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];
        char *side = Proxy() ? "ClientSend" : "ServerSend";

        iidName[0] = 0;
        GetInterfaceName(riid, iidName);

        ContextDebugOut((DEB_TRACECALLS,
                         "%s on interface %I (%ws) method 0x%x\n",
                         side, &riid, iidName,
                         (pMessage->iMethod & ~RPC_FLAGS_VALID_BIT)));
    }
#endif

    // Assert that this routine is called only for async call
    Win4Assert(pMessage->rpcFlags & RPC_BUFFER_ASYNC);

    // Obtain the context call object
    HRESULT hr = S_OK;
    COleTls Tls;
    CCtxCall *pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetClientCtxCall();

    // Check for context functionality
    if(pCtxCall)
    {
        EnumCallType eCallType;

        // Ensure that GetBuffer was called before
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS);
        if(fClientSide)
        {
            // Sanity check
            Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);

            // Init the call type
            eCallType = CALLTYPE_BEGINCALL;
        }
        else
        {
            // Ensure that GetBuffer was called before
            Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_SERVER);

            // Init the call type
            eCallType = CALLTYPE_FINISHLEAVE;
        }

        // Create rpc call object on the stack
        CRpcCall rpcCall(GetStdId()->GetIdentity(),
                         pMessage, riid, hr, CALLSOURCE_CROSSAPT);

        // Obtain the policy set that delivers events
        CPolicySet *pPS = pCtxCall->_pPS;
        Win4Assert(pPS);

        // Deliver client side call events
        hr = pPS->FillBuffer(&rpcCall, eCallType, pCtxCall);

        // Reset state inside context call object
        if(fClientSide)
            CPolicySet::ResetState(pCtxCall);

        // Check for the need to abort
        BOOL fFreeBuffer = TRUE;
        if(SUCCEEDED(hr))
        {
            // Save current context inside context call object
            pCtxCall->_pContext = Tls->pCurrentCtx;

            // As there is no need for modal loop,
            // delegate to CRpcChannelBuffer::Send directly
            hr = CRpcChannelBuffer::Send(pMessage, pSync, pulStatus);
            Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);
            if(FAILED(hr))
                fFreeBuffer = FALSE;
        }

        // Check for success return on the client side
        if(SUCCEEDED(hr) && fClientSide)
        {
            // Deliver BeginReturn events
            pPS->DeliverEvents(&rpcCall, CALLTYPE_BEGINRETURN, pCtxCall);

            // Ignore Nullify calls
            hr = S_OK;
        }

        if(FAILED(hr) && fFreeBuffer)
        {
            // Initialize return code
            *pulStatus = hr;
            hr = RPC_E_FAULT;

            // Cleanup
            if(fClientSide)
            {
                // Free the buffer obtained from CAptRpcChnl::GetBuffer
                CAptRpcChnl::FreeBuffer(pMessage);
                Win4Assert(pMessage->Buffer == NULL);
            }
            else
            {
                // Abort the call on the server side
		// NOTE: a) Currently, Abort is implemented in CMessageCall
		// so the cast is not really necessary.
		// The impl does nothing.
		// b) Async calls to/from contexts are unsupported
		// at present. If it is ever supported
		// this code needs to be revisited. Abort would need
		// to be overridden in CAsyncCall and the the RPC 
		// async abort API needs to be called.
		 
                ((CAsyncCall *) pMessage->reserved1)->Abort();
            }
        }

        // Delete context call object for failure returns on the client side
        if(SUCCEEDED(hr))
        {
            pCtxCall->_dwFlags |= CTXCALLFLAG_SSUCCESS;
        }
        else if(fClientSide)
        {
            delete pCtxCall;
        }
    }
    else
    {
        // As there is no need for modal loop,
        // delegate to CRpcChannelBuffer::Send directly
        hr = CRpcChannelBuffer::Send(pMessage, pSync, pulStatus);
        Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::Send is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Receive       public
//
//  Synopsis:   Implements IRpcChannelBuffer::Receive
//
//              This method delegates the request to CAptRpcChnl::Receive,
//              identifies the right policy set, asks it to deliver server
//              side buffers, and finally returns to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::Receive(RPCOLEMESSAGE *pMessage, ULONG *pulStatus)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Receive\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(GetIPIDEntry()->iid, iidName);

        ContextDebugOut((DEB_TRACECALLS,
                         "Receive on interface %I (%ws) method 0x%x\n",
                         &GetIPIDEntry()->iid, iidName,
                         (pMessage->iMethod & ~RPC_FLAGS_VALID_BIT)));
    }
#endif

    // In the absense of pipes this routine is called
    // only on the client side
    Win4Assert(Proxy());
    // Assert that this routine is called only for async call
    Win4Assert(pMessage->rpcFlags & RPC_BUFFER_ASYNC);

    // Obtain the context call object
    HRESULT hr = S_OK;
    COleTls Tls;
    CCtxCall *pCtxCall = pMessage->reserved1 ?
                         ((CMessageCall *) pMessage->reserved1)->GetClientCtxCall() :
                         NULL;

    // Store context call object in TLS
    CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

    // Check for context functionality
    if(pCtxCall)
    {
        // Sanity checks
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_SSUCCESS);

        // Create rpc call object on the stack
        CRpcCall rpcCall(GetStdId()->GetIdentity(),
                         pMessage, GetIPIDEntry()->iid, hr, CALLSOURCE_CROSSAPT);

        // Obtain the policy set that delivers events
        CPolicySet *pPS = pCtxCall->_pPS;
        Win4Assert(pPS);

        // Deliver client side call events
        hr = pPS->FillBuffer(&rpcCall, CALLTYPE_FINISHCALL, pCtxCall);

        // Ignore Nullify calls
        hr = S_OK;

        // Save current context inside context call object
        pCtxCall->_pContext = Tls->pCurrentCtx;

        // As there is no need for modal loop,
        // delegate to CRpcChannelBuffer::Receive directly
        BOOL fFreeBuffer = TRUE;
        hr = CRpcChannelBuffer::Receive(pMessage, pulStatus);
        Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);

        // FreeBuffer need not be called for failure returns
        if(FAILED(hr))
            fFreeBuffer = FALSE;

        // Deliver FinishReturn  events
        hr = pPS->DeliverEvents(&rpcCall, CALLTYPE_FINISHRETURN, pCtxCall);

        // Check for premature failure case
        if(FAILED(hr) && fFreeBuffer)
        {
            // Free the buffer obtained from CAptRpcChnl::Receive
            CAptRpcChnl::FreeBuffer(pMessage);
            Win4Assert(pMessage->Buffer == NULL);

            *pulStatus = hr;
            hr = RPC_E_FAULT;
        }

        // Delete context call object for failure returns
        if(SUCCEEDED(hr))
            pCtxCall->_dwFlags |= CTXCALLFLAG_RSUCCESS;
        else
            delete pCtxCall;
    }
    else
    {
        // As there is no need for modal loop,
        // delegate to CRpcChannelBuffer::Receive directly
        hr = CRpcChannelBuffer::Receive(pMessage, pulStatus);
        Win4Assert(SUCCEEDED(hr) || pMessage->Buffer==NULL);
    }

    // Revoke context call object from TLS
    pCtxCall->RevokeFromTLS(Tls, pCurCall);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::Receive is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::FreeBuffer     public
//
//  Synopsis:   Implements IRpcChannelBuffer::FreeBuffer
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::FreeBuffer(RPCOLEMESSAGE *pMessage)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::FreeBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    CCtxCall *pCtxCall;
    COleTls Tls;

    // This method is never called on the server side
    Win4Assert(Proxy());

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        IID *iidCalled;
        WCHAR iidName[256];

        iidCalled = &((RPC_CLIENT_INTERFACE *) pMessage->reserved2[1])->InterfaceId.SyntaxGUID;
        iidName[0] = 0;
        GetInterfaceName(*iidCalled, iidName);

        ContextDebugOut((DEB_TRACECALLS,
                         "FreeBuffer on interface %I (%ws) method 0x%x\n",
                         iidCalled, iidName,
                         (pMessage->iMethod & ~RPC_FLAGS_VALID_BIT)));
    }
#endif

    if(pMessage->Buffer)
    {
        // Obtain the context call object
        pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetClientCtxCall();

        // Sanity Checks
        Win4Assert(!pCtxCall || pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);
        Win4Assert(!pCtxCall || pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS);

        // Delete the context call object
        if(pCtxCall)
            delete pCtxCall;

        // Delegate to CAptRpcChnl::FreeBuffer
        hr = CAptRpcChnl::FreeBuffer(pMessage);
        Win4Assert(pMessage->Buffer == NULL);

        // Decrement per thread outstanding call count
        if(!(pMessage->rpcFlags & RPC_BUFFER_ASYNC))
        {
            --Tls->cCalls;
            Win4Assert((LONG) Tls->cCalls >= 0);

            // Clear any pending uninit
            if((Tls->dwFlags & OLETLS_PENDINGUNINIT) && (Tls->cCalls == 0))
                CoUninitialize();
        }
    }
	else
	{
		// No buffer to free, everything is just fine.
		hr = S_OK;
	}

    // Do not touch any member variables here after as the proxy manager
    // might have deleted the channel due to a nested release

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::FreeBuffer is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::ContextInvoke     public
//
//  Synopsis:   This method switches the context, identifies the right
//              policy set, asks the policy set to deliver the buffers
//              created by the polices on the client side, invokes the
//              call on the server object through StubInvoke, obtains
//              server side buffers through policy set and finally
//              returns to its caller
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxComChnl::ContextInvoke(RPCOLEMESSAGE *pMessage,
                                        IRpcStubBuffer *pStub,
                                        IPIDEntry *pIPIDEntry,
                                        DWORD *pdwFault)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::ContextInvoke\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        IID *iidCalled;
        WCHAR iidName[256];

        iidCalled = MSG_TO_IIDPTR(pMessage);
        iidName[0] = 0;
        GetInterfaceName(*iidCalled, iidName);
        ContextDebugOut((DEB_TRACECALLS,
                         "ContextInvoke on interface %I (%ws) method 0x%x\n",
                         iidCalled, iidName, pMessage->iMethod));
    }
#endif

    // This method is never called on the client side
    Win4Assert(Server());

    // Obtain context call object
    CCtxCall *pCtxCall = ((CMessageCall *) pMessage->reserved1)->GetServerCtxCall();

    // Obtain the policy set node
    CPolicySet *pPS = GetStdId()->GetServerPolicySet();
    CObjectContext *pSavedCtx, *pServerCtx;

    // Obtain server object context
    if(pPS)
    {
        // Object lives inside a non-empty context
        pServerCtx = pPS->GetServerContext();
    }
    else
    {
        // Object lives in empty context
        pServerCtx = GetEmptyContext();
    }

    // Assert that there is server empty context
    Win4Assert(pServerCtx);

    // if pServerCtx is NULL it means the MTA has been released out from under us
    // by another thread. This code doesn't fix the problem, but it's better than an AV.
    if(!pServerCtx)
        return CO_E_NOTINITIALIZED;

    // Save current context
    COleTls Tls;
    pSavedCtx = Tls->pCurrentCtx;

    // Switch to the server object context
    Tls->pCurrentCtx = pServerCtx;
    Tls->ContextId = pServerCtx->GetId();
    pServerCtx->InternalAddRef();
    ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x --> 0x%x\n",
                     pSavedCtx, pServerCtx));

    // Update context call object
    pCtxCall->_pPS = pPS;
    pCtxCall->_pContext = pServerCtx;

    // Create rpc call object on the stack
    HRESULT hrCall = S_OK;
    CRpcCall rpcCall(GetStdId()->GetIdentity(), pMessage,
                     *MSG_TO_IIDPTR(pMessage), hrCall, CALLSOURCE_CROSSAPT);

    // Deliver server side notification events
    if(pPS)
        hrCall = pPS->Notify(&rpcCall, CALLTYPE_SYNCENTER, pCtxCall);

    // Check for the need to dispatch call to server object
    BOOL fDoCleanup = TRUE;
    if(SUCCEEDED(hrCall))
    {
        // Delegate to StubInvoke
        hrCall = StubInvoke(pMessage, GetStdId(), pStub,
                            (IRpcChannelBuffer3 *)this,
                            pIPIDEntry, pdwFault);
        if (FAILED(hrCall))
        {
            // StubInvoke failed, therefore we don't want to try to
            // clean up the marshal buffer later if event delivery
            // fails.
            fDoCleanup = FALSE;
        }

        // Make sure we're back on the right context
        CheckContextAfterCall (Tls, pServerCtx);
    }
    else
    {
        // The call was aborted during delivery of server-side notify
        // events.  We need to release any marshaled in-param interface
        // ptrs in the marshal buffer.
        ReleaseMarshalBuffer(pMessage, pStub, FALSE);
	fDoCleanup = FALSE;
    }

    // Deliver server side leave events
    if(pPS && (hrCall != RPC_E_INVALID_HEADER))
    {
        // Check if GetBuffer was called by the stub
        if(pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS)
        {
            // Update call status to that saved in GetBuffer
            if(FAILED(pCtxCall->_hr))
                hrCall = pCtxCall->_hr;
        }
        else if(!(pCtxCall->_dwFlags & CTXCALLFLAG_GBFAILED))
        {
            // The call must have failed
            Win4Assert(FAILED(hrCall));

            // Initailize
            CPolicySet::ResetState(pCtxCall);
            pMessage->cbBuffer = 0;

            // Obtain the buffer size needed by the server side policies
            // GetSize will fail on the server side only if no policy
            // expressed interest in sending data to the client side
            pPS->GetSize(&rpcCall, CALLTYPE_SYNCLEAVE, pCtxCall);

	    // Store context call object in TLS
	    CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

	    // Delegate to CAptRpcChnl::GetBuffer
	    HRESULT hr = CAptRpcChnl::GetBuffer(pMessage, *MSG_TO_IIDPTR(pMessage));
	    if(FAILED(hr))
	       CPolicySet::ResetState(pCtxCall);
	    else
	       fDoCleanup = TRUE;
		   
	    // Revoke context call object from TLS
	    pCtxCall->RevokeFromTLS(Tls, pCurCall);
	    RPC_EXTENDED_ERROR_INFO ErrorInfo;	    
	    memset(&ErrorInfo, 0, sizeof(ErrorInfo));	
	    ErrorInfo.Version = RPC_EEINFO_VERSION;
	    ErrorInfo.NumberOfParameters = 1;
	    ErrorInfo.GeneratingComponent = EEInfoGCCOM;
	    ErrorInfo.Status = hrCall;
	    ErrorInfo.Parameters[0].u.BVal.Buffer = ((CMessageCall *) pMessage->reserved1)->_pHeader;
	    ErrorInfo.Parameters[0].u.BVal.Size =(short)((CMessageCall *) pMessage->reserved1)->_dwErrorBufSize;
	    ErrorInfo.Parameters[0].ParameterType = eeptBinary;
	    // If this fails, we do nothing. We are already in an error path
	    // and this API is a best-efforts deal.
	    RPC_STATUS status = RpcErrorAddRecord(&ErrorInfo);
#if DBG==1
	    if (RPC_S_OK != status ) 
	    {
	       ContextDebugOut((DEB_CTXCOMCHNL,
				"CCtxComChnl::ContextInvoke RpcErrorAddRecord failed 0x%x\n", status));
	    }
#endif	    
        }

        hrCall = pPS->FillBuffer(&rpcCall, CALLTYPE_SYNCLEAVE, pCtxCall);
        if (fDoCleanup && FAILED(hrCall))
        {
            // StubInvoke succeeded but the call was aborted during delivery
            // of server-side leave events.  We need to release any
            // marshaled out-param interface ptrs that are in the
            // marshal buffer.
            ReleaseMarshalBuffer(pMessage, pStub, TRUE);
        }
    }

    // Switch back to the saved context
    ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x <-- 0x%x\n",
                     pSavedCtx, pServerCtx));
    pServerCtx->InternalRelease();
    Tls->pCurrentCtx = pSavedCtx;
    Tls->ContextId = (pSavedCtx) ? pSavedCtx->GetId() : (ULONGLONG)-1;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::ContextInvoke is returning hr:0x%x\n", hrCall));
    return(hrCall);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxComChnl::Copy     public
//
//  Synopsis:   Used by CStdIdentity to create channel copies on the
//              client side
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
CCtxComChnl *CCtxComChnl::Copy(OXIDEntry *pOXIDEntry, REFIPID ripid,
                               REFIID riid)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CCtxComChnl::Copy\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // This routine is called only on client channels
    Win4Assert(IsClientChannel() || Proxy());

    // Make a new context channel
    CCtxComChnl *pChannel = new CCtxComChnl(GetStdId(), pOXIDEntry, GetState());
    if(pChannel)
        CAptRpcChnl::UpdateCopy(pChannel);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCOMCHNL,
                     "CCtxComChnl::Copy returning pChannel:0x%x\n", pChannel));
    return pChannel;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::QueryInterface     public
//
//  Synopsis:   QI behavior of CCtxHook object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxHook::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::QueryInterface\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IChannelHook))
    {
        *ppv = (IChannelHook *) this;
    }
    else if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // No need to AddRef the interface before returning
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ClientGetSize     public
//
//  Synopsis:   Returns the size of extent saved in the context call
//              object inside CPolicySet::GetSize
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ClientGetSize(REFGUID rguid, REFIID riid,
                                            ULONG *pcb)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ClientGetSize\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT));

    // Return extent size saved inside context call object
    // For rejected calls, return 0
    if(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_MFRETRY))
        *pcb = 0;
    else
        *pcb = pCtxCall->_cbExtent;

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ClientFillBuffer     public
//
//  Synopsis:   Saves the extent buffer pointer in the context call
//              object for use inside CPolicySet::FillBuffer
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ClientFillBuffer(REFGUID rguid, REFIID riid,
                                               ULONG *pcb, void *pv)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ClientFillBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Assert that the buffer pointer is 8-byte  aligned
    Win4Assert(!(((ULONG_PTR) pv & 7) && "Buffer not 8-byte aligned"));

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT));

    // Save the buffer pointer inside context call object
    // For rejected calls, return 0
    if(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_MFRETRY))
    {
        *pcb = 0;
    }
    else
    {
        *pcb = pCtxCall->_cbExtent;
         if(pCtxCall->_cbExtent)
             pCtxCall->_pvExtent = pv;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ServerNotify     public
//
//  Synopsis:   Saves the extent buffer pointer in the context call
//              object for use inside CPolicySet::Notify
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------                                  void *, DWORD);
STDMETHODIMP_(void) CCtxHook::ServerNotify(REFGUID rguid, REFIID riid,
                                           ULONG cb, void *pv,
                                           DWORD dwDataRep)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ServerNotify\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Assert that the buffer pointer is 8-byte  aligned
    Win4Assert(!(((ULONG_PTR) pv & 7) && "Buffer not 8-byte aligned"));

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(pCtxCall && (pCtxCall->_dwFlags & CTXCALLFLAG_SERVER));

    // Save the extent pointer inside context call object
    if(cb)
        pCtxCall->_pvExtent = pv;

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ServerGetSize     public
//
//  Synopsis:   Returns the size of extent saved in the context call
//              object inside CPolicySet::GetSize
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ServerGetSize(REFGUID rguid, REFIID riid,
                                            HRESULT hrRet, ULONG *pcb)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ServerGetSize\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(pCtxCall && (pCtxCall->_dwFlags & CTXCALLFLAG_SERVER));

    // Return extent size saved inside context call object
    *pcb = pCtxCall->_cbExtent;
    if(!(pCtxCall->_dwFlags & CTXCALLFLAG_FBDONE))
    {
        CPolicySet::ResetState(pCtxCall);

        // Sergei O. Ivanov (a-sergiv)  9/22/99  NTBUG #403726
        // We must clear this flag, since ResetState just cleared pvExtent in pCtxCall.
        // Leaving this flag set will instruct DeliverEvents to reuse the buffer and crash.

        pCtxCall->_dwFlags &= ~CTXCALLFLAG_GBINIT;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ServerFillBuffer     public
//
//  Synopsis:   Saves the extent buffer pointer in the context call
//              object for use inside CPolicySet::FillBuffer
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ServerFillBuffer(REFGUID rguid, REFIID riid,
                                               ULONG *pcb, void *pv,
                                               HRESULT hrRet)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ServerFillBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Assert that the buffer pointer is 8-byte  aligned
    Win4Assert(!(((ULONG_PTR) pv & 7) && "Buffer not 8-byte aligned"));

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    Win4Assert(pCtxCall && (pCtxCall->_dwFlags & CTXCALLFLAG_SERVER));

    // Save the buffer pointer inside context call object
    *pcb = pCtxCall->_cbExtent;
    if(pCtxCall->_cbExtent)
    {
        if(pCtxCall->_dwFlags & CTXCALLFLAG_FBDONE)
        {
            memcpy(pv, pCtxCall->_pvExtent, pCtxCall->_cbExtent);
            PrivMemFree(pCtxCall->_pvExtent);
        }
        pCtxCall->_pvExtent = pv;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::ClientNotify     public
//
//  Synopsis:   Saves the extent buffer pointer in the context call
//              object for use inside CPolicySet::Notify
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(void) CCtxHook::ClientNotify(REFGUID rguid, REFIID riid,
                                           ULONG cb, void *pv,
                                           DWORD dwDataRep, HRESULT hrRet)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ClientNotify\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CCtxCall *pCtxCall;
    COleTls Tls;

    // Assert that the buffer pointer is 8-byte  aligned
    Win4Assert(!(((ULONG_PTR) pv & 7) && "Buffer not 8-byte aligned"));

    // Obtain the context call object
    pCtxCall = Tls->pCtxCall;
    if(pCtxCall)
    {
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);
        Win4Assert(pCtxCall->_pvExtent == NULL);

        // Save the extent pointer inside context call object
        if(cb)
            pCtxCall->_pvExtent = pv;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxHook::PrepareForRetry     private
//
//  Synopsis:   Called from Apartment call control to inform that
//              Message Filter has decided to retry a rejected call
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxHook::PrepareForRetry(CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_CHNLHOOK, "CCtxHook::ClientNotify\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Obtain the context call object
    Win4Assert(!pCtxCall || (pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT));

    // Mark the call as being retried through Message Filter
    if(pCtxCall)
    {
        pCtxCall->_dwFlags |= CTXCALLFLAG_MFRETRY;
        pCtxCall->_pvExtent = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\giptbl.cxx ===
//+-------------------------------------------------------------------
//
//  File:       giptbl.cxx
//
//  Contents:   code for storing/retrieving interfaces from global ptrs
//
//  Functions:  RegisterInterfaceInGlobal
//              RevokeInterfaceFromGlobal
//              GetInterfaceFromGlobal
//
//  History:    18-Mar-97   Rickhi      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <giptbl.hxx>
#include <marshal.hxx>
#include <stdid.hxx>
#include <xmit.hxx>
#include <chancont.hxx> // Event cache

// global GIP table
CGIPTable          gGIPTbl;
DWORD              CGIPTable::_dwCurrSeqNo  = GIP_SEQNO_MIN;
BOOL               CGIPTable::_fInRevokeAll = FALSE;
GIPEntry           CGIPTable::_InUseHead    = { &_InUseHead, &_InUseHead };
CPageAllocator     CGIPTable::_palloc;   // allocator for GIPEntries
COleStaticMutexSem CGIPTable::_mxs;      // critical section for table

typedef struct
{
    HANDLE _hEvent;
    DWORD  _dwCookie;
} STwoBits;

// function prototypes
HRESULT __stdcall ReleaseCallback(void *prm);


//+-------------------------------------------------------------------
//
//  Function:   RevokeFromMTA
//
//  Synopsis:   helper function for CacheCreateThread
//
//+-------------------------------------------------------------------
DWORD _stdcall RevokeFromMTA(void *param)
{
    STwoBits *pParam = (STwoBits *) param;
    HRESULT   hr;
    COleTls   tls(hr);
    if (SUCCEEDED(hr))
    {
        hr = gGIPTbl.RevokeInterfaceFromGlobal(pParam->_dwCookie);

        // HACK ALERT
        // 
        // RevokeInterfaceFromGlobal can leave the pCurrentCtx state
        // in tls pointing to bogus memory (we are on a worker thread
        // here, this should not be the case).  I am NULL-ing itout  
        // as a quick fix.  long term we need to define what cleanup
        // actions a worker thread (or the things that it calls) should
        // do when going back into the idle state.
        tls->pCurrentCtx = NULL;
    }
    SetEvent(pParam->_hEvent);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::Initialize, public
//
//+-------------------------------------------------------------------
void CGIPTable::Initialize()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ComDebOut((DEB_MARSHAL, "CGIPTable::Initialize\n"));
    // allocations are single-threaded by the calling code, so the
    // allocator doesn't need to take the lock.
    _palloc.Initialize(sizeof(GIPEntry), GIPS_PER_PAGE, NULL);
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::Cleanup, public
//
//  Synopsis:   cleans up the page allocator.
//
//+-------------------------------------------------------------------
void CGIPTable::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ComDebOut((DEB_MARSHAL, "CIPIDTable::Cleanup\n"));
    _palloc.Cleanup();
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::ApartmentCleanup, public
//
//  Synopsis:   cleans up the left-over entries for the current
//              apartment.
//
//  CODEWORK: RICKHI - this method may be temporary
//
//+-------------------------------------------------------------------
#define MAX_GIPS_TO_RELEASE 50

void CGIPTable::ApartmentCleanup()
{
    ComDebOut((DEB_MARSHAL, "CIPIDTable::ApartmentCleanup\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);

    DWORD dwCurrentAptId = GetCurrentApartmentId();
    BOOL  fMore;

    do
    {
        fMore = FALSE;      // exit the while loop unless told otherwise
        int i = 0;          // count of cookies to release
        DWORD dwCookie[MAX_GIPS_TO_RELEASE]; // cache of cookies to release

        ASSERT_LOCK_NOT_HELD(_mxs);
        LOCK(_mxs);

        // loop over existing GIPEntries
        GIPEntry *pGIPEntry = _InUseHead.pNext;
        while (pGIPEntry != &_InUseHead)
        {
            if (pGIPEntry->dwAptId == dwCurrentAptId)
            {
                // the entry was registered by the current apartment.
                // remember the cookie and count one more entry to revoke.
                dwCookie[i] = _palloc.GetEntryIndex((PageEntry *)pGIPEntry);
                dwCookie[i] |= pGIPEntry->dwSeqNo;
                i++;
                if (i>=MAX_GIPS_TO_RELEASE)
                {
                    // we have exhausted our cache, after we go free the ones
                    // we currently have, come back again for another round.
                    fMore = TRUE;
                    break;
                }
            }

            // next entry
            pGIPEntry = pGIPEntry->pNext;
        }

        UNLOCK(_mxs);
        ASSERT_LOCK_NOT_HELD(_mxs);

        // if we found any leftover entries for the current apartment
        // revoke them.
        for (int j=0; j<i; j++)
        {
            RevokeInterfaceFromGlobal(dwCookie[j]);
        }

    } while (fMore);

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "CIPIDTable::ApartmentCleanup\n"));
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::RevokeAllEntries, public
//
//  Synopsis:   Walks the InUse list to cleanup any leftover
//              entries.
//
//+-------------------------------------------------------------------
void CGIPTable::RevokeAllEntries()
{
    ComDebOut((DEB_MARSHAL, "CGIPTable::RevokeAllEntries\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);

    // walk the InUse list and cleanup leftover entries
    _fInRevokeAll = TRUE;
    while (_InUseHead.pNext != &_InUseHead)
    {
        // get the cookie and release the entry
        DWORD dwCookie = _palloc.GetEntryIndex((PageEntry *)_InUseHead.pNext);
        dwCookie |= _InUseHead.pNext->dwSeqNo;
        RevokeInterfaceFromGlobal(dwCookie);
    }
    _fInRevokeAll = FALSE;

    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Methods:    CGIPTable::AllocEntry, private
//
//  Synopsis:   Allocates an entry in the table, assigns a cookie and
//              sequence number, and increments the sequence number.
//
//+-------------------------------------------------------------------
HRESULT CGIPTable::AllocEntry(GIPEntry **ppGIPEntry, DWORD *pdwCookie)
{
    HRESULT hr = E_OUTOFMEMORY;
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    // allocate an entry
    DWORD dwCookie = 0;
    GIPEntry *pGIPEntry = (GIPEntry *) _palloc.AllocEntry();
    if (pGIPEntry)
    {
        // chain it on the list of inuse entries
        pGIPEntry->pPrev        = &_InUseHead;
        _InUseHead.pNext->pPrev = pGIPEntry;
        pGIPEntry->pNext        = _InUseHead.pNext;
        _InUseHead.pNext        = pGIPEntry;

        // get and increment the sequence number
        DWORD dwSeqNo = pGIPEntry->dwSeqNo & GIP_SEQNO_MASK;
        if (dwSeqNo != 0)
        {
            // the entry has been used before so just increment
            // the existing sequence number for this entry.
            dwSeqNo += GIP_SEQNO_MIN;
            if (dwSeqNo > GIP_SEQNO_MAX)
                dwSeqNo = GIP_SEQNO_MIN;
        }
        else
        {
            // the entry has never been used before so initialize
            // it's sequence number to the current global sequence
            //  number and increment the global sequence number.
            dwSeqNo = _dwCurrSeqNo;
            _dwCurrSeqNo += GIP_SEQNO_MIN;
            if (_dwCurrSeqNo > GIP_SEQNO_MAX)
                _dwCurrSeqNo = GIP_SEQNO_MIN;
        }

        // store the seqno in the entry
        pGIPEntry->dwSeqNo = dwSeqNo;

        // compute the cookie for the entry
        dwCookie = _palloc.GetEntryIndex((PageEntry *)pGIPEntry);
        dwCookie |= pGIPEntry->dwSeqNo;

        pGIPEntry->dwType    = ORT_UNUSED;
        pGIPEntry->cUsage    = -1;   // gets set to 0 if Register succeeds
        pGIPEntry->dwAptId   = GetCurrentApartmentId();
        pGIPEntry->hWndApt   = NULL;
        pGIPEntry->pContext  = NULL;
        pGIPEntry->pUnk      = NULL;
        pGIPEntry->pUnkProxy = NULL;
        pGIPEntry->u.pIFD    = NULL;
        hr = S_OK;
    }

    *pdwCookie = dwCookie;
    *ppGIPEntry = pGIPEntry;

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Methods:    CGIPTable::FreeEntry, private
//
//  Synopsis:   Dechains the entry from the inuse list, marks it as
//              unused, and returns it to the table.
//
//+-------------------------------------------------------------------
void CGIPTable::FreeEntry(GIPEntry *pGIPEntry)
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    // ensure the usage count is -1
    Win4Assert(pGIPEntry->cUsage == -1);

    // unchain it from the list of InUse entries
    pGIPEntry->pPrev->pNext = pGIPEntry->pNext;
    pGIPEntry->pNext->pPrev = pGIPEntry->pPrev;

    // return it to the table
    pGIPEntry->dwType = ORT_UNUSED;
    _palloc.ReleaseEntry((PageEntry *)pGIPEntry);

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::ChangeUsageCount, private
//
//  Synopsis:   Thread-Safe increment or decrement of usage count
//
//  History:    09-Apr-98   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CGIPTable::ChangeUsageCount(GIPEntry *pGIPEntry, LONG lDelta)
{
    LONG cUsage = pGIPEntry->cUsage;
    while (cUsage != -1)
    {
        // try to atomically change the usage count
        if (InterlockedCompareExchange(&pGIPEntry->cUsage, cUsage + lDelta,
                                       cUsage) == cUsage)
        {
            // exchange occurred, we're done.
            return S_OK;
        }
        cUsage = pGIPEntry->cUsage;
    }

    return E_INVALIDARG;
}

//+-------------------------------------------------------------------
//
//  Methods:    CGIPTable::GetEntryPtr, private
//
//  Synopsis:   From a cookie, finds the entry pointer. Ensures the
//              cookie is a valid index and the entry has a matching
//              sequence number.
//
//  Returns:    S_OK - The GIPEntry ptr, with the cUsage incremented.
//                     ReleaseEntryPtr must be called to dec cUsage.
//              E_INVALIDARG - otherwise
//
//+-------------------------------------------------------------------
HRESULT CGIPTable::GetEntryPtr(DWORD dwCookie, GIPEntry **ppGIPEntry)
{
    HRESULT hr = E_INVALIDARG;
    DWORD dwSeqNo = dwCookie & GIP_SEQNO_MASK;
    dwCookie &= ~GIP_SEQNO_MASK;

    if (_palloc.IsValidIndex(dwCookie))
    {
        GIPEntry *pGIPEntry = (GIPEntry *)_palloc.GetEntryPtr(dwCookie);
        if (pGIPEntry &&
            pGIPEntry->dwSeqNo == dwSeqNo &&
            pGIPEntry->dwType != ORT_UNUSED)
        {
            // count one more user to ensure no races between GetInterface
            // and RevokeInterface.
            if (SUCCEEDED(ChangeUsageCount(pGIPEntry, 1)))
            {
                // ensure it was not released and re-used
                if (pGIPEntry->dwSeqNo == dwSeqNo)
                {
                    // OK.
                    *ppGIPEntry = pGIPEntry;
                    hr = S_OK;
                }
                else
                {
                    // re-used, release the count and return an error.
                    ChangeUsageCount(pGIPEntry, -1);
                }
            }
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::QueryInterface, public
//
//  History:    18-Mar-97   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CGIPTable::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IGlobalInterfaceTable))
    {
        *ppv = (IGlobalInterfaceTable *)this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::RegisterInterfaceInGlobal, public
//
//  Synopsis:   Registers an interface for storage in a global.
//
//  Arguments:  [pUnk] - interface to register
//              [riid] - iid of interface punk
//              [pdwCookie] - registration cookie returned
//
//  History:    18-Mar-97   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CGIPTable::RegisterInterfaceInGlobal(IUnknown *pUnk,
                                                  REFIID riid, DWORD *pdwCookie)
{
    // call helper function to do the work.
    return RegisterInterfaceInGlobalHlp(pUnk,
                                        riid,
                                        MSHLFLAGS_TABLESTRONG,
                                        pdwCookie);
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::RegisterInterfaceInGlobalHlp, public
//
//  Synopsis:   Registers an interface for storage in a global.
//
//  Arguments:  [pUnk] - interface to register
//              [riid] - iid of interface punk
//              [pdwCookie] - registration cookie returned
//
//  History:    18-Mar-97   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies
//
//--------------------------------------------------------------------
HRESULT CGIPTable::RegisterInterfaceInGlobalHlp(IUnknown *pUnk,
                                                REFIID riid,
                                                DWORD mshlflags,
                                                DWORD *pdwCookie)
{
    ComDebOut((DEB_MARSHAL,"RegisterInterfaceInGlobal pUnk:%x riid:%I pdwCookie:%x\n",
               pUnk, &riid, pdwCookie));
    ASSERT_LOCK_NOT_HELD(_mxs);


    // check the input parameters
    if (!IsValidInterface(pUnk) || pdwCookie == NULL)
    {
        return E_INVALIDARG;
    }

    // init in case of error
    *pdwCookie = 0;

    // ensure the channel is initialized.
    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    // get the window handle to place in the GIPEntry
    // to handle revoke from the wrong apartment.
    OXIDEntry *pOXIDEntry = NULL;
    hr = GetLocalOXIDEntry(&pOXIDEntry);
    if (FAILED(hr))
    {
        return hr;
    }
    HWND hwndApt = pOXIDEntry->GetServerHwnd();

    // allocate an entry in the GIPTable
    DWORD dwCookie = 0;
    GIPEntry *pGIPEntry = NULL;
    hr = AllocEntry(&pGIPEntry, &dwCookie);

    if (SUCCEEDED(hr))
    {
        IMarshal *pIM = NULL;
        CStdIdentity *pStdId = NULL;

        if (SUCCEEDED(pUnk->QueryInterface(IID_IStdIdentity,
                                           (void **)&pStdId)))
        {
            // Object is a proxy.
            if (pStdId->FTMObject())
            {
                // This is a proxy for an FTM object that has been marshaled
                // out of proc.  The proxy lives in the NA and it is agile,
                // so just store a pointer to it.
                pGIPEntry->dwType = ORT_FREETM;
                hr = S_OK;
            }
            else
            {
                // Marshal the proxy.
                pGIPEntry->dwType = ORT_OBJREF;
                hr = E_OUTOFMEMORY;
                pGIPEntry->u.pobjref = (OBJREF *)PrivMemAlloc(sizeof(OBJREF));
                if (pGIPEntry->u.pobjref)
                {
                    hr = pStdId->MarshalObjRef(*(pGIPEntry->u.pobjref), riid,  mshlflags,
                                                 MSHCTX_INPROC, NULL, 0);
                }
            }
            pStdId->Release();
        }
        else if (SUCCEEDED(pUnk->QueryInterface(IID_IMarshal, (void **)&pIM)))
        {
            // object supports IMarshal, check for FreeThreadedMarshaler
            CLSID clsid;
            hr = pIM->GetUnmarshalClass(riid, pUnk, MSHCTX_INPROC, 0,
                                        mshlflags, &clsid);

            if (SUCCEEDED(hr) && IsEqualCLSID(clsid, CLSID_InProcFreeMarshaler))
            {
                // supports FTM, just store it's pointer directly
                pGIPEntry->dwType = ORT_FREETM;
                hr = S_OK;
            }
            else
            {
                // object supports custom Marshalling, marshal it
                pGIPEntry->dwType = ORT_STREAM;
                CXmitRpcStream Stm;
                hr = CoMarshalInterface(&Stm, riid, pUnk,
                                        MSHCTX_INPROC, 0, mshlflags);
                if (SUCCEEDED(hr))
                {
                    Stm.AssignSerializedInterface(&pGIPEntry->u.pIFD);
                }
            }
            pIM->Release();
        }
        else
        {
            // use standard marshaling, but delay marshaling it until the first
            // caller requests to use it. This avoids doing a lot of work if
            // the cookie is never actually used, or if it is used only by the
            // current apartment.
            pGIPEntry->dwType = (mshlflags & MSHLFLAGS_AGILE) ?
                                 ORT_LAZY_AGILE : ORT_LAZY_OBJREF;
            pGIPEntry->mp.mshlflags = mshlflags;
            pGIPEntry->mp.iid       = riid;
        }

        if (SUCCEEDED(hr))
        {
            // Remember the apartment and context it was marshaled in
            pGIPEntry->cUsage   = 0;
            pGIPEntry->hWndApt  = hwndApt;
            pGIPEntry->pContext = GetCurrentContext();
            pGIPEntry->pContext->InternalAddRef();

            // addref and remember the pointer
            pGIPEntry->pUnk = pUnk;
            pUnk->AddRef();
        }
        else
        {
            // Failed. Cleanup and free the entry.
            PrivMemFree(pGIPEntry->u.pobjref);
            pGIPEntry->u.pobjref = NULL;
            pGIPEntry->dwType    = ORT_UNUSED;
            FreeEntry(pGIPEntry);
            dwCookie = 0;
        }
    }

    *pdwCookie = dwCookie;

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "RegisterInterfaceInGlobal: dwCookie:%x hr:%x\n",
               *pdwCookie, hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::RevokeInterfaceFromGlobal, public
//
//  Synopsis:   Revokes an interface registered for storage in a global.
//
//  Arguments:  [dwCookie] - registration cookie
//
//  History:    18-Mar-97   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies
//              29-Mar-98   Johnstra    NA support
//
//--------------------------------------------------------------------
STDMETHODIMP CGIPTable::RevokeInterfaceFromGlobal(DWORD dwCookie)
{
    ComDebOut((DEB_MARSHAL,"RevokeInterfaceFromGlobal dwCookie:%x\n",
               dwCookie));
    ASSERT_LOCK_NOT_HELD(_mxs);

    if (!IsApartmentInitialized()) return CO_E_NOTINITIALIZED;

    GIPEntry *pGIPEntry;
    HRESULT hr = GetEntryPtr(dwCookie, &pGIPEntry);
    if (SUCCEEDED(hr))
    {
        BOOL fSameApt = (pGIPEntry->dwAptId == GetCurrentApartmentId());
        if (!fSameApt && !_fInRevokeAll)
        {
            // can only revoke from the same apartment that registered
            // so go switch to that apartment now.
            hr = S_OK;

            // release the entry ptr we acquired since we want another
            // thread to do the revoke and we don't want to prevent that
            // from happening due to our own usage count.
            DWORD dwAptId = pGIPEntry->dwAptId;
            HWND  hWndApt = pGIPEntry->hWndApt;
            ReleaseEntryPtr(pGIPEntry);

            if (dwAptId == MTATID)
            {
                // the revoke needs to happen in the MTA so go do that
                STwoBits sParam;
                sParam._dwCookie = dwCookie;
                hr = gEventCache.Get(&sParam._hEvent);
                if (SUCCEEDED(hr))
                {
                    hr = CacheCreateThread(RevokeFromMTA, &sParam);
                    if (SUCCEEDED(hr))
                    {
                        // use CoWaitForMultipleHandles so we
                        // pump messages while we're waiting for
                        // the worker thread to get done.
                        DWORD dwIndex;
                        DWORD iLoop = 0;

                        do
                        {                           
                            hr = CoWaitForMultipleHandles(
                                                COWAIT_ALERTABLE,
                                                INFINITE,
                                                1,
                                                &(sParam._hEvent),
                                                &dwIndex);
                            iLoop++; // counter in case we get stuck here
                        } 
                        while ((hr == RPC_S_CALLPENDING));

                        if (SUCCEEDED(hr))
                        {
                            Win4Assert(dwIndex == WAIT_OBJECT_0);
                        }
                        else
                        {
                            // Broke out of the loop with a failure of some kind.  Not 
                            // good.  If the RevokeFromMTA thread finishes after this
                            // point, we might give a signalled event back to the cache.
                            // To avoid this, make sure the event is signalled before
                            // returning.
                            (void)WaitForSingleObject(sParam._hEvent, INFINITE);
                        }
                    }
                    gEventCache.Free(sParam._hEvent);
                }
            }
            else if (dwAptId == NTATID)
            {
                // Switch to NA to revoke.
                CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
                hr = gGIPTbl.RevokeInterfaceFromGlobal(dwCookie);
                pSavedCtx = LeaveNTA(pSavedCtx);
                Win4Assert(pSavedCtx == g_pNTAEmptyCtx);
            }
            else if (hWndApt)
            {
                // post a message to the real thread to revoke the entry
                if (!PostMessage(hWndApt, WM_OLE_GIP_REVOKE,
                                 WMSG_MAGIC_VALUE, dwCookie))
                    hr = RPC_E_SERVER_DIED;
            }

            return hr;
        }

        // OK to Revoke in this apartment. First, make sure no other threads
        // are using this entry. The current thread should be the only thread with
        // a reference on the entry right now.
        if (InterlockedCompareExchange(&pGIPEntry->cUsage, -1, 1) != 1)
        {
            // The entry is busy. Return an error and let the caller retry.
            // Note that this is a bug in the calling app, we just prevent
            // corruption of state, AVs, etc.
            ReleaseEntryPtr(pGIPEntry);
            hr = HRESULT_FROM_WIN32(ERROR_BUSY);
        }
        else
        {
            // The entry was not busy and is now marked with a usage count of -1
            // so no other threads will attempt to do a Get at this time. Go
            // ahead and do the cleanup.

            if (pGIPEntry->pUnkProxy)
            {
                // Release the agile proxy
                Win4Assert(pGIPEntry->dwType == ORT_AGILE);
                pGIPEntry->pUnkProxy->Release();
                pGIPEntry->pUnkProxy = NULL;
            }

            if (pGIPEntry->dwType == ORT_OBJREF      ||
                pGIPEntry->dwType == ORT_LAZY_OBJREF ||
                pGIPEntry->dwType == ORT_AGILE       ||
                pGIPEntry->dwType == ORT_LAZY_AGILE)
            {
                if (pGIPEntry->u.pobjref)
                {
                    // release the marshaled objref
                    hr = ReleaseMarshalObjRef(*(pGIPEntry->u.pobjref));
                    FreeObjRef(*(pGIPEntry->u.pobjref));
                    PrivMemFree(pGIPEntry->u.pobjref);
                    pGIPEntry->u.pobjref = NULL;
                }
            }
            else if (pGIPEntry->dwType == ORT_STREAM)
            {
                if (pGIPEntry->u.pIFD)
                {
                    // release the custom marshaled interface
                    CXmitRpcStream Stm(pGIPEntry->u.pIFD);
                    hr = CoReleaseMarshalData(&Stm);
                    CoTaskMemFree(pGIPEntry->u.pIFD);
                }
            }

            if (fSameApt && IsValidInterface(pGIPEntry->pUnk))
            {
                if (pGIPEntry->pContext)
                {
                    // was registered in a different context so go do the
                    // release in that context.
                    pGIPEntry->pContext->InternalContextCallback(ReleaseCallback, pGIPEntry->pUnk,
                                                         IID_IUnknown, 2 /* Release() */,
                                                         NULL);
                    pGIPEntry->pContext->InternalRelease();
                    pGIPEntry->pContext = NULL;
                }
                else
                {
                    // release the pUnk object
                    pGIPEntry->pUnk->Release();
                }

                pGIPEntry->pUnk = NULL;
            }

            // return the entry to the table
            FreeEntry(pGIPEntry);
            hr = S_OK;
        }
    }

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "RevokeInterfaceFromGlobal: hr:%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     LazyMarshalGIPEntry
//
//  Synopsis:   Does the marshaling for a lazy-marshaled OBJREF
//
//  History:    11-Nov-98   RickHi      Created
//
//--------------------------------------------------------------------
HRESULT CGIPTable::LazyMarshalGIPEntry(DWORD dwCookie)
{
    ComDebOut((DEB_MARSHAL,"LazyMarshalGIPEntry: dwCookie:%x\n", dwCookie));
    ASSERT_LOCK_NOT_HELD(_mxs);

    // get the GIPEntry from the cookie
    GIPEntry *pGIPEntry;
    HRESULT hr = GetEntryPtr(dwCookie, &pGIPEntry);
    if (FAILED(hr))
    {
        // cookie is bad
        return hr;
    }

    if (pGIPEntry->u.pobjref == NULL)
    {
        // allocate space for the OBJREF
        hr = E_OUTOFMEMORY;
        OBJREF *pObjRef = (OBJREF *)PrivMemAlloc(sizeof(OBJREF));

        if (pObjRef)
        {
            DWORD dwNewType;

            if (pGIPEntry->dwType == ORT_LAZY_AGILE)
            {
                // marshal an agile proxy
                hr = MarshalInternalObjRef(*pObjRef,
                                           pGIPEntry->mp.iid,
                                           pGIPEntry->pUnk,
                                           pGIPEntry->mp.mshlflags,
                                           NULL);
                dwNewType = ORT_AGILE;
            }
            else if (pGIPEntry->dwType == ORT_LAZY_OBJREF)
            {
                // the normal case
                hr = MarshalObjRef(*pObjRef,
                                    pGIPEntry->mp.iid,
                                    pGIPEntry->pUnk,
                                    pGIPEntry->mp.mshlflags,
                                    MSHCTX_INPROC, NULL);
                dwNewType = ORT_OBJREF;
            }
            else
            {
                // should never be anything else, unless a race is occuring,
                // in which case we skip the work below and by the time we
                // get back to the calling context everything should be set
                // up correctly and this error is ignored.
                hr = E_UNEXPECTED;
            }

            if (SUCCEEDED(hr))
            {
                if (InterlockedCompareExchangePointer((void **)&pGIPEntry->u.pobjref,
                                                      pObjRef, NULL) == NULL)
                {
                    // update the type (must be done after the interlocked exchange)
                    pGIPEntry->dwType = dwNewType;
                }
                else
                {
                    // some other thread beat us to it, so just release the
                    // objref we created and continue on using the objref
                    // that is present.
                    ReleaseMarshalObjRef(*pObjRef);
                    FreeObjRef(*pObjRef);
                    PrivMemFree(pObjRef);
                }
            }
            else
            {
                PrivMemFree(pObjRef);
            }
        }
    }
    else
    {
        // already marshalled
        hr = S_OK;
    }

    // release the reference acquired by Get
    ReleaseEntryPtr(pGIPEntry);

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "LazyMarshalGIPEntry: hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   LazyMarshalGIPEntryCallback
//
//  Synopsis:   tells the GIPEntry to marshal the OBJREF
//
//  History:    11-Nov-98   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT __stdcall LazyMarshalGIPEntryCallback(void *cookie)
{
    ComDebOut((DEB_MARSHAL,"LazyMarshalGIPEntryCallback cookie:%x\n", cookie));

    DWORD dwCookie = PtrToUlong(cookie);
    HRESULT hr = gGIPTbl.LazyMarshalGIPEntry(dwCookie);

    ComDebOut((DEB_MARSHAL,"LazyMarshalGIPEntryCallback dwCookie:%x\n",
              dwCookie));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ReleaseCallback
//
//  Synopsis:   calls release in the correct context
//
//  History:    11-Nov-98   MattSmit      Created
//
//--------------------------------------------------------------------
HRESULT __stdcall ReleaseCallback(void *prm)
{
    ((IUnknown *) prm)->Release();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::GetRequestedInterface  private
//
//  Synopsis:   returns the requested interface on the supplied object
//
//  History:    26-Mar-98   GopalK      Created
//
//--------------------------------------------------------------------
HRESULT CGIPTable::GetRequestedInterface(IUnknown *pUnk, REFIID riid, void **ppv)
{
    // Validate the server object
    HRESULT hr = CO_E_OBJNOTCONNECTED;
    if (IsValidInterface(pUnk))
    {
        // object is still valid, get the requested interface
        hr = pUnk->QueryInterface(riid, ppv);
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CGIPTable::GetInterfaceFromGlobal, public
//
//  Synopsis:   returns the marshaled interface associated with the cookie
//
//  Arguments:  [dwCookie] - registration cookie
//              [riid]     - interface iid requested
//              [ppv]      - where to return the interface
//
//  History:    18-Mar-97   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies
//
//--------------------------------------------------------------------
extern "C" IID IID_IEnterActivityWithNoLock;
BOOL GipBypassEnabled();

STDMETHODIMP CGIPTable::GetInterfaceFromGlobal(DWORD dwCookie,
                                               REFIID riid, void **ppv)
{
    ComDebOut((DEB_MARSHAL,"GetInterfaceFromGlobal dwCookie:%x riid:%I ppv:%x\n",
               dwCookie, &riid, ppv));
    ASSERT_LOCK_NOT_HELD(_mxs);

    *ppv = NULL;

    if (!IsApartmentInitialized()) return CO_E_NOTINITIALIZED;

    GIPEntry *pGIPEntry;
    HRESULT hr = GetEntryPtr(dwCookie, &pGIPEntry);
    if (SUCCEEDED(hr))
    {
        // look for fast-path cases first...

        if ((pGIPEntry->dwType == ORT_FREETM) ||
            (pGIPEntry->pContext == GetCurrentContext()))
        {
            // object is free-threaded or we are already in the
            // context in which it was registered. Just use the
            // interface pointer that is stored there directly.
            hr = GetRequestedInterface(pGIPEntry->pUnk, riid, ppv);
        }
        else if ((pGIPEntry->dwType == ORT_AGILE ||
                  pGIPEntry->dwType == ORT_LAZY_AGILE) &&
                 pGIPEntry->dwAptId == GetCurrentApartmentId())
        {
            // object is agile and we are already in the apartment in
            // which it was registered. Just use the interface pointer
            // that is stored there directly.
            hr = GetRequestedInterface(pGIPEntry->pUnk, riid, ppv);
        }
        else
        {
            // can't use a fast-path this case, we'll need to do
            // some unmarshaling and possibly some lazy marshaling...

            hr = E_UNEXPECTED;

            if (pGIPEntry->dwType == ORT_LAZY_AGILE ||
                pGIPEntry->dwType == ORT_LAZY_OBJREF)
            {
                // the server object has not yet been marshaled. call back to
                // the server apartment/context to really do the marshaling.

                if (GipBypassEnabled())
                {
                    pGIPEntry->pContext->InternalContextCallback(LazyMarshalGIPEntryCallback,
                                                        (void *)LongToPtr(dwCookie),
                                                        IID_IEnterActivityWithNoLock, 2 /*Release*/,
                                                        NULL);
                }
                else
                {
                    pGIPEntry->pContext->InternalContextCallback(LazyMarshalGIPEntryCallback,
                                                        (void *)LongToPtr(dwCookie),
                                                        IID_IUnknown, 2 /*Release*/,
                                                        NULL);
                }

                // ignore the return code, since it is possible to return an
                // error when a race happens. We will still unmarshal correctly
                // below if we are able to.
            }

            if (pGIPEntry->dwType == ORT_AGILE)
            {
                // it's an agile reference
                Win4Assert(pGIPEntry->dwAptId != GetCurrentApartmentId()); // handled above

                if (pGIPEntry->pUnkProxy == NULL)
                {
                    // an agile proxy has not yet been created, do it now
                    IUnknown *pUnkTemp = NULL;
                    hr = UnmarshalInternalObjRef(*(pGIPEntry->u.pobjref),
                                                (void **) &pUnkTemp);
                    if (SUCCEEDED(hr))
                    {
                        // someone else might have unmarshaled at the same time,
                        // check for duplicate
                        if (InterlockedCompareExchangePointer(
                                  (void **)&pGIPEntry->pUnkProxy,
                                   pUnkTemp, NULL) != NULL)
                        {
                            // duplicate, Release the ref we created
                            pUnkTemp->Release();
                        }
                    }
                }

                if (pGIPEntry->pUnkProxy != NULL)
                {
                    hr = GetRequestedInterface(pGIPEntry->pUnkProxy, riid, ppv);
                }
            }
            else if (pGIPEntry->dwType == ORT_OBJREF)
            {
                // entry is an OBJREF, just unmarshal it
                hr = UnmarshalObjRef(*(pGIPEntry->u.pobjref), ppv, GipBypassEnabled());
                if (SUCCEEDED(hr) && !InlineIsEqualGUID(riid, pGIPEntry->u.pobjref->iid))
                {
                    // caller is asking for a different interface than was marshaled.
                    // Query for it now.
                    IUnknown *pUnk = (IUnknown *) *ppv;
                    *ppv = NULL;
                    hr = pUnk->QueryInterface(riid, ppv);
                    pUnk->Release();
                }
            }
            else if (pGIPEntry->dwType == ORT_STREAM)
            {
                // entry is ptr to stream of custom marshal data, unmarshal it
                CXmitRpcStream Stm(pGIPEntry->u.pIFD);
                hr = CoUnmarshalInterface(&Stm, riid, ppv);
            }
        }

        // Release the reference acquired in Get above
        ReleaseEntryPtr(pGIPEntry);
    }

    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_MARSHAL, "GetInterfaceFromGlobal: hr:%x pv:%x\n", hr, *ppv));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CGIPTableCF_CreateInstance, public
//
//  History:    18-Mar-97   Rickhi      Created
//
//  Notes:      Class Factory CreateInstance function. Always returns
//              the one global instance of the GIP table.
//
//--------------------------------------------------------------------
HRESULT CGIPTableCF_CreateInstance(IUnknown *pUnkOuter,
                                   REFIID riid, void **ppv)
{
    Win4Assert(pUnkOuter == NULL);
    return gGIPTbl.QueryInterface(riid, ppv);
}

//+-------------------------------------------------------------------
//
//  Function:   CGIPTableApartmentUninitialize, public
//
//  History:    09-Oct-97   Rickhi      Created
//
//--------------------------------------------------------------------
void GIPTableApartmentUninitialize()
{
    gGIPTbl.ApartmentCleanup();
}

//+-------------------------------------------------------------------
//
//  Function:   CGIPTableProcessUninitialize, public
//
//  History:    09-Oct-97   Rickhi      Created
//
//--------------------------------------------------------------------
void GIPTableProcessUninitialize()
{
    gGIPTbl.RevokeAllEntries();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\excepn.cxx ===
//+-------------------------------------------------------------------
//
//  File:       excepn.cxx
//
//  Contents:   Exception handling routines
//
//  Classes:    
//
//  History:    11-Jan-99   TarunA      Created
//										
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <excepn.hxx>
#include <pstable.hxx>      // GetCurrentContext()

#if DBG==1
#include "stackwlk.hxx"
#endif

/***************************************************************************/
/* Globals. */

#if DBG==1
LPEXCEPTION_POINTERS g_pExcep = NULL;
#endif

// Should the debugger hooks be called?
BOOL gfCatchServerExceptions = TRUE;
BOOL gfBreakOnSilencedExceptions = TRUE;

//-------------------------------------------------------------------------
//
//  Function:   ServerExceptionFilter
//
//  synopsis:   Determines if DCOM should catch the server exception or not.
//
//  History:    25-Jan-97   Rickhi  Created
//
//-------------------------------------------------------------------------
LONG ServerExceptionFilter(LPEXCEPTION_POINTERS lpep)
{
    if (!gfCatchServerExceptions)
    {
        // the system admin does not want DCOM servers to catch
        // some exceptions (helps ISVs debug their servers).
        if (ServerExceptionOfInterest(lpep->ExceptionRecord->ExceptionCode))
        {
            return EXCEPTION_CONTINUE_SEARCH;
        }
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


#if DBG==1
BOOL RunningInSystemDesktop()
{
    WCHAR   wszWinsta[64];
    HWINSTA hWinsta;
    DWORD   Size;

    hWinsta = GetProcessWindowStation();
    Size = sizeof(wszWinsta);
    wszWinsta[0] = 0;

    if ( hWinsta )
    {
        (void) GetUserObjectInformation(
                                       hWinsta,
                                       UOI_NAME,
                                       wszWinsta,
                                       Size,
                                       &Size );
    }

    //
    // This makes popups from non-interactive servers/services (including
    // rpcss) visible.
    //
    if (wszWinsta[0] && (lstrcmpiW(wszWinsta,L"Winsta0") != 0))
    {
        return TRUE;
    }

    return FALSE;
}
#endif

BOOL IsKernelDebuggerPresent()
{
    return USER_SHARED_DATA->KdDebuggerEnabled;
}

void PrintFriendlyDebugMessage (LPEXCEPTION_POINTERS lpep)
{
    DbgPrint("\n"
            "The exception pointers are located at 0x%p\n"
            "To get the faulting stack do the following:\n"
            "\n"
            "1) Do a '.exr 0x%p' to display the exception record\n"
            "2) Do a '.cxr 0x%p' to display the context record\n"
            "3) Do a 'kb' to display the stack\n"
            "\n",
            lpep,
            lpep->ExceptionRecord,
            lpep->ContextRecord);
}

//+---------------------------------------------------------------------------
//
//  Function:   AppInvokeExceptionFilter
//
//  Synopsis:   Determine if the application as thrown an exception we want
//              to report. If it has, then print out enough information for
//              the 'user' to debug the problem
//
//  Arguments:  [lpep] -- Exception context records
//
//  History:    6-20-95   kevinro   Created
//              6-09-98   Gopalk    Modified to be useful for debugging
//              9-25-98   stevesw   provide stack information....
//
//----------------------------------------------------------------------------
LONG AppInvokeExceptionFilter(LPEXCEPTION_POINTERS lpep, REFIID riid,
                                     DWORD dwMethod)
{
    BOOL bUserNotified = FALSE;
    LONG ret = ServerExceptionFilter(lpep);
    DWORD dwFault = lpep->ExceptionRecord->ExceptionCode;
    if(ServerExceptionOfInterest(dwFault))
    {   
#if DBG==1

        // Save the exception info in a local since somebody will surely not read the msg
        // below and we'll end up debugging it anyway.
        LPEXCEPTION_POINTERS lpepLocal = lpep;
		
        // We also save the exception info in a global for super-easy access.  Note that
        // if we have two server exceptions in the same process, the second one will overwrite
        // the global contents set by the first exception.
        g_pExcep = lpep;

        UINT uiMBFlags;
        WCHAR iidName[256];
        WCHAR szProgname[256];
        WCHAR szPopupMsg[512];
        WCHAR szInterfaceGuid[50];

        // Initialize
        iidName[0] = 0;
        szProgname[0] = 0;
        GetModuleFileName(NULL, szProgname, sizeof(szProgname) / sizeof(WCHAR));
        GetInterfaceName(riid, iidName);
        StringFromGUID2(riid, szInterfaceGuid, 50);

        // Output to debugger
        DbgPrint("OLE has caught a fault 0x%08x on behalf of the server %ws\n",
                   dwFault, szProgname);
        DbgPrint("The fault occurred when OLE called the interface %ws (%ws) "
                   "method 0x%x\n", szInterfaceGuid, iidName, dwMethod);
        
        // Ask user if they want to debug this
        wsprintf(szPopupMsg, L"OLE has caught a fault 0x%08x on behalf of the server %ws. "
                             L"The fault occurred when OLE called method %0x on interface %ws (%ws)."
                             L"\r\n\r\n"
                             L"Press Cancel to debug.",
                             dwFault,
                             szProgname,
                             dwMethod,
                             szInterfaceGuid,
                             iidName);
        
        // Set message box flags
        uiMBFlags = MB_SETFOREGROUND | MB_TOPMOST | MB_OKCANCEL | MB_ICONHAND | MB_TASKMODAL;

        if (RunningInSystemDesktop())
        {
            // This makes popups from non-interactive servers/services (including
            // rpcss) visible.
            uiMBFlags |= MB_SERVICE_NOTIFICATION;
        }

        if (IDCANCEL == MessageBox(NULL, 
                                   szPopupMsg, 
                                   L"Unhandled exception", 
                                   uiMBFlags))
        {
            PrintFriendlyDebugMessage (lpep);
            DebugBreak();
        }

        bUserNotified = TRUE;
#endif

    }

    // Deliver exception notification to current context
    // COM+ 23780 - do this on all exceptions, not just those of interest
    GetCurrentContext()->NotifyServerException(lpep);

    // We have historically caught exceptions and silenced them.
    // This is a bad idea for exceptions of interest because valuable debugging
    // information is lost, particularly while developing a new OS.
    //
    // So, for now, if we were going to silence the exception and 
    // there's a debugger around to handle an int 3, use it.
    //
    // This will probably cause enough appcompat issues that we'll want to remove
    // it before Whistler RTM.  However, for now this is going in.
    if (gfBreakOnSilencedExceptions &&
        !bUserNotified &&
        ret == EXCEPTION_EXECUTE_HANDLER && 
        (IsDebuggerPresent() || IsKernelDebuggerPresent()))
    {
        DbgPrint("OLE has caught a fault 0x%08x on behalf of an OLE server\n", dwFault);
        PrintFriendlyDebugMessage (lpep);
        DebugBreak();
    }

    return ret;
}


#ifdef SOMEONE_FIXES_STACK_TRACES_ON_NT
//#else
#include <imagehlp.h>

#define SYM_HANDLE  GetCurrentProcess()

#if defined(_M_IX86)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_I386
#elif defined(_M_MRX000)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_R4000
#elif defined(_M_ALPHA)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_ALPHA
#elif defined(_M_PPC)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_POWERPC
#elif defined(_M_IA64)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_IA64
#else
#error( "unknown target machine" );
#endif

LONG
AppInvokeExceptionFilter(
    LPEXCEPTION_POINTERS lpep
    )
{
#if DBG == 1
    BOOL            rVal;
    STACKFRAME      StackFrame;
    CONTEXT         Context;


    SymSetOptions( SYMOPT_UNDNAME );
    SymInitialize( SYM_HANDLE, NULL, TRUE );
    ZeroMemory( &StackFrame, sizeof(StackFrame) );
    Context = *lpep->ContextRecord;

#if defined(_M_IX86)
    StackFrame.AddrPC.Offset       = Context.Eip;
    StackFrame.AddrPC.Mode         = AddrModeFlat;
    StackFrame.AddrFrame.Offset    = Context.Ebp;
    StackFrame.AddrFrame.Mode      = AddrModeFlat;
    StackFrame.AddrStack.Offset    = Context.Esp;
    StackFrame.AddrStack.Mode      = AddrModeFlat;
#endif


    ComDebOut((DEB_FORCE,"An Exception occurred while calling into app\n"));
    ComDebOut((DEB_FORCE,
                     "Exception address = 0x%x Exception number 0x%x\n",
                     lpep->ExceptionRecord->ExceptionAddress,
                     lpep->ExceptionRecord->ExceptionCode ));

    ComDebOut((DEB_FORCE,"The following stack trace is where the exception occured\n"));
    ComDebOut((DEB_FORCE,"Frame    RetAddr  mod!symbol\n"));
    do
    {
        rVal = StackWalk(MACHINE_TYPE,SYM_HANDLE,0,&StackFrame,&Context,ReadProcessMemory,
                         SymFunctionTableAccess,SymGetModuleBase,NULL);

        if (rVal)
        {
            DWORD              dump[200];
            ULONG              Displacement;
            PIMAGEHLP_SYMBOL   sym = (PIMAGEHLP_SYMBOL) &dump;
            IMAGEHLP_MODULE    ModuleInfo;
            LPSTR              pModuleName = "???";
            BOOL               fSuccess;

            sym->SizeOfStruct = sizeof(dump);

            fSuccess = SymGetSymFromAddr(SYM_HANDLE,StackFrame.AddrPC.Offset,
                                         &Displacement,sym);

            //
            // If there is module name information available, then grab it.
            //
            if(SymGetModuleInfo(SYM_HANDLE,StackFrame.AddrPC.Offset,&ModuleInfo))
            {
                pModuleName = ModuleInfo.ModuleName;
            }

            if (fSuccess)
            {
                ComDebOut((DEB_FORCE,
                                 "%08x %08x %s!%s + %x\n",
                                 StackFrame.AddrFrame.Offset,
                                 StackFrame.AddrReturn.Offset,
                                 pModuleName,
                                 sym->Name,
                                 Displacement));
            }
            else
            {
                ComDebOut((DEB_FORCE,
                                 "%08x %08x %s!%08x\n",
                                 StackFrame.AddrFrame.Offset,
                                 StackFrame.AddrReturn.Offset,
                                 pModuleName,
                                 StackFrame.AddrPC.Offset));
            }
        }
    } while( rVal );

    SymCleanup( SYM_HANDLE );

#endif

    return ServerExceptionFilter(lpep);
}
#endif  // _CHICAGO_

/***************************************************************************/
#if DBG==1
LONG ComInvokeExceptionFilter( DWORD lCode,
                               LPEXCEPTION_POINTERS lpep )
{
    ComDebOut((DEB_ERROR, "Exception 0x%x in ComInvoke at address 0x%x\n",
               lCode, lpep->ExceptionRecord->ExceptionAddress));
    LONG lfilter = ServerExceptionFilter(lpep);
    if (lfilter == EXCEPTION_EXECUTE_HANDLER)
    {
        DebugBreak();
    }
    return lfilter;
}
#endif

/***************************************************************************/
LONG ThreadInvokeExceptionFilter( DWORD lCode,
                                  LPEXCEPTION_POINTERS lpep )
{
    ComDebOut((DEB_ERROR, "Exception 0x%x in ThreadInvoke at address 0x%x\n",
               lCode, lpep->ExceptionRecord->ExceptionAddress));
    LONG lfilter = ServerExceptionFilter(lpep);
    if (lfilter == EXCEPTION_EXECUTE_HANDLER)
    {
        DebugBreak();
    }
    return lfilter;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\destobj.cxx ===
//+-------------------------------------------------------------------
//
//  File:       DestObj.cxx
//
//  Contents:   Object tracking destination context for marshaling
//
//  Classes:    CDestObject
//
//  History:    18-Mar-98   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <destobj.hxx>

//+-------------------------------------------------------------------
//
//  Method:     CDestObject::QueryInterface     public
//
//  Synopsis:   QI behavior of destination object
//
//  History:    18-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CDestObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if(IsEqualIID(riid, IID_IDestInfo) ||
       IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IDestInfo *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    // No need to addref
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\hash.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       hash.cxx
//
//  Contents:   class for maintaining a hash table.
//
//  Classes:    CUUIDHashTable
//
//---------------------------------------------------------------------------
#include <ole2int.h>
#include <hash.hxx>         // CUUIDHashTable
#include <locks.hxx>        // ASSERT_LOCK_HELD_IF_NECESSARY
#include <service.hxx>      // SASIZE


//+------------------------------------------------------------------------
// Type definitions

typedef struct
{
    const IPID      *pIpid;
    SECURITYBINDING *pName;
} SNameKey;

//+------------------------------------------------------------------------
//
//  Secure references hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain SRFBuckets[23] =
{
    {&SRFBuckets[0],  &SRFBuckets[0]},
    {&SRFBuckets[1],  &SRFBuckets[1]},
    {&SRFBuckets[2],  &SRFBuckets[2]},
    {&SRFBuckets[3],  &SRFBuckets[3]},
    {&SRFBuckets[4],  &SRFBuckets[4]},
    {&SRFBuckets[5],  &SRFBuckets[5]},
    {&SRFBuckets[6],  &SRFBuckets[6]},
    {&SRFBuckets[7],  &SRFBuckets[7]},
    {&SRFBuckets[8],  &SRFBuckets[8]},
    {&SRFBuckets[9],  &SRFBuckets[9]},
    {&SRFBuckets[10], &SRFBuckets[10]},
    {&SRFBuckets[11], &SRFBuckets[11]},
    {&SRFBuckets[12], &SRFBuckets[12]},
    {&SRFBuckets[13], &SRFBuckets[13]},
    {&SRFBuckets[14], &SRFBuckets[14]},
    {&SRFBuckets[15], &SRFBuckets[15]},
    {&SRFBuckets[16], &SRFBuckets[16]},
    {&SRFBuckets[17], &SRFBuckets[17]},
    {&SRFBuckets[18], &SRFBuckets[18]},
    {&SRFBuckets[19], &SRFBuckets[19]},
    {&SRFBuckets[20], &SRFBuckets[20]},
    {&SRFBuckets[21], &SRFBuckets[21]},
    {&SRFBuckets[22], &SRFBuckets[22]}
};

CNameHashTable gSRFTbl;


//---------------------------------------------------------------------------
//
//  Function:   DummyCleanup
//
//  Synopsis:   Callback for CHashTable::Cleanup that does nothing.
//
//---------------------------------------------------------------------------
void DummyCleanup( SHashChain *pIgnore )
{
}

//---------------------------------------------------------------------------
//
//  Method:     CHashTable::EnumAndRemove
//
//  Synopsis:   Enumerates the hash table and removes the elements identified
//              by the PFNREMOVE function.
//
//  History:    14-May-97   Gopalk      Created
//
//---------------------------------------------------------------------------
BOOL CHashTable::EnumAndRemove(PFNREMOVE *pfnRemove, void *pvData,
                               ULONG *pulSize, void **ppNodes)
{
    Win4Assert(pfnRemove);
    AssertHashLocked();

    SHashChain *pPrev, *pNext;
    ULONG ulCount = 0;
    BOOL fDone = TRUE;

    for (ULONG iHash=0; iHash < NUM_HASH_BUCKETS; iHash++)
    {
        // Obtain bucket head
        SHashChain *pNode  = _buckets[iHash].pNext;

        // Enumerate bucket
        while (pNode != &_buckets[iHash])
        {
            // Save the previous and next nodes
            pPrev = pNode->pPrev;
            pNext = pNode->pNext;

            // Invoke the supplied function
            if((pfnRemove)(pNode, pvData))
            {
                pPrev->pNext = pNext;
                pNext->pPrev = pPrev;
                if(ppNodes)
                {
                    ppNodes[ulCount] = pNode;
                    ++ulCount;
                    if(ulCount == *pulSize)
                    {
                        fDone = FALSE;
                        goto End;
                    }
                }
            }

            // Skip to next node
            pNode = pNext;
        }
    }

End:
    if(pulSize)
        *pulSize = ulCount;

    return(fDone);
}


//---------------------------------------------------------------------------
//
//  Method:     CHashTable::Cleanup
//
//  Synopsis:   Cleans up the hash table by deleteing leftover entries.
//
//---------------------------------------------------------------------------
void CHashTable::Cleanup(PFNCLEANUP *pfnCleanup)
{
    Win4Assert(pfnCleanup);
    AssertHashLocked();

    for (ULONG iHash=0; iHash < NUM_HASH_BUCKETS; iHash++)
    {
        // the ptrs could be NULL if the hash table was never initialized.

        while (_buckets[iHash].pNext != NULL &&
               _buckets[iHash].pNext != &_buckets[iHash])
        {
            // remove the entry from the list and call it's cleanup function
            SHashChain *pNode = _buckets[iHash].pNext;

            Remove(pNode);
            (pfnCleanup)(pNode);
        }
    }

#if DBG==1
    // Verify that the hash table is empty or uninitialized.
    for (iHash = 0; iHash < NUM_HASH_BUCKETS; iHash++)
    {
        Win4Assert( _buckets[iHash].pNext == &_buckets[iHash] ||
                    _buckets[iHash].pNext == NULL);
        Win4Assert( _buckets[iHash].pPrev == &_buckets[iHash] ||
                    _buckets[iHash].pPrev == NULL);
    }
#endif
}

//---------------------------------------------------------------------------
//
//  Method:     CHashTable::Lookup
//
//  Synopsis:   Searches for a given key in the hash table.
//
//  Note:       iHash is between 0 and -1, not 0 and NUM_HASH_BUCKETS
//
//---------------------------------------------------------------------------
SHashChain *CHashTable::Lookup(DWORD dwHash, const void *k)
{
    AssertHashLocked();

    // compute the index to the hash chain (it's the hash value of the key
    // mod the number of buckets in the hash table)

    DWORD iHash = dwHash % NUM_HASH_BUCKETS;

    SHashChain *pNode  = _buckets[iHash].pNext;

    // Search the destination bucket for the key.
    while (pNode != &_buckets[iHash])
    {
        if (Compare( k, pNode, dwHash ))
            return pNode;

        pNode = pNode->pNext;
    }

    return NULL;
}

//---------------------------------------------------------------------------
//
//  Method:     CHashTable::Add
//
//  Synopsis:   Adds an element to the hash table. The Cleanup method will
//              call a Cleanup function that can be used to delete the
//              element.
//
//  Note:       iHash is between 0 and -1, not 0 and NUM_HASH_BUCKETS
//
//---------------------------------------------------------------------------
void CHashTable::Add(DWORD dwHash, SHashChain *pNode)
{
    AssertHashLocked();

    // Add the node to the bucket chain.
    SHashChain *pHead   = &_buckets[dwHash % NUM_HASH_BUCKETS];
    SHashChain *pNew    = pNode;

    pNew->pPrev         = pHead;
    pHead->pNext->pPrev = pNew;
    pNew->pNext         = pHead->pNext;
    pHead->pNext        = pNew;

    // count one more entry
    _cCurEntries++;
    if (_cCurEntries > _cMaxEntries)
        _cMaxEntries = _cCurEntries;
}

//---------------------------------------------------------------------------
//
//  Method:     CHashTable::Remove
//
//  Synopsis:   Removes an element from the hash table.
//
//---------------------------------------------------------------------------
void CHashTable::Remove(SHashChain *pNode)
{
    AssertHashLocked();

    pNode->pPrev->pNext = pNode->pNext;
    pNode->pNext->pPrev = pNode->pPrev;

    // count one less entry
    _cCurEntries--;
}

#if LOCK_PERF==1
//---------------------------------------------------------------------------
//
//  Function:   OutputHashEntryData, public
//
//  Synopsis:   Dumps the statistics gathered by the various hash tables
//              in the system.
//
//---------------------------------------------------------------------------
void OutputHashEntryData(char *pszName, CHashTable &HashTbl)
{
    char szHashPerfBuf[256];
    wsprintfA(szHashPerfBuf,"\tHashTable:%s \tMaxEntryCount:%7u\n",
              pszName, HashTbl.GetMaxEntryCount());
    OutputDebugStringA(szHashPerfBuf);
}
#endif // LOCK_PERF

//---------------------------------------------------------------------------
//
//  Method:     CDWORDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CDWORDHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    return PtrToUlong(k) == ((SDWORDHashNode *)pNode)->key;
}

//---------------------------------------------------------------------------
//
//  Method:     CPointerHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CPointerHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    return k == ((SPointerHashNode *)pNode)->key;
}

//---------------------------------------------------------------------------
//
//  Method:     CUUIDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CUUIDHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    return InlineIsEqualGUID(*(const UUID *)k,
                            ((SUUIDHashNode *)pNode)->key);
}

//---------------------------------------------------------------------------
//
//  Method:     CMultiGUIDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//              k is a pointer to the key, SHashChain is the node to compare
//              against.
//
//---------------------------------------------------------------------------
BOOL CMultiGUIDHashTable::Compare(const void *k, SHashChain *pHashNode, DWORD dwHash)
{
    SMultiGUIDKey      *pKey = (SMultiGUIDKey *)k;
    SMultiGUIDHashNode *pNode = (SMultiGUIDHashNode *)pHashNode;

    if (pKey->cGUID != pNode->key.cGUID)
    {
        return FALSE;
    }
     
    for (int i = 0; i < pKey->cGUID; i++)
    {
        if (!InlineIsEqualGUID(pKey->aGUID[i], pNode->key.aGUID[i]))
            return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
//
//  Method:     CStringHashTable::Hash
//
//  Synopsis:   Computes the hash value for a given key.
//
//---------------------------------------------------------------------------
DWORD CStringHashTable::Hash(DUALSTRINGARRAY *psaKey)
{
    DWORD dwHash  = 0;
    DWORD *pdw    = (DWORD *) &psaKey->aStringArray[0];

    for (USHORT i=0; i< (psaKey->wNumEntries/2); i++)
    {
        dwHash = (dwHash << 8) ^ *pdw++;
    }

    return dwHash;
}

//---------------------------------------------------------------------------
//
//  Method:     CStringHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CStringHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    SStringHashNode       *pSNode = (SStringHashNode *) pNode;
    const DUALSTRINGARRAY *psaKey = (const DUALSTRINGARRAY *) k;

    if (dwHash == pSNode->dwHash)
    {
        // a quick compare of the hash values found a match, now do
        // a full compare of the key (Note: if the sizes of the two
        // Keys are different, we exit the memcmp on the first dword,
        // so we dont have to worry about walking off the endo of one
        // of the Keys during the memcmp).

        return !memcmp(psaKey, pSNode->psaKey, SASIZE(psaKey->wNumEntries));
    }
    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::Cleanup
//
//  Synopsis:   Call the base cleanup routine with a dummy callback function
//
//---------------------------------------------------------------------------
void CNameHashTable::Cleanup()
{
    LOCK(gIPIDLock);
    CHashTable::Cleanup( DummyCleanup );
    UNLOCK(gIPIDLock);
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::Hash
//
//  Synopsis:   Computes the hash value for a given key.
//
//---------------------------------------------------------------------------
DWORD CNameHashTable::Hash( REFIPID ipid, SECURITYBINDING *pName )
{
    DWORD  dwHash  = 0;
    DWORD *pdw     = (DWORD *) &ipid;
    DWORD  dwLen   = lstrlenW( (WCHAR *) pName ) >> 1;
    ULONG  i;

    // First hash the IPID.
    for (i=0; i < 4; i++)
    {
        dwHash = (dwHash << 8) ^ *pdw++;
    }

    // Then hash the name.
    pdw = (DWORD *) pName;
    for (i=0; i < dwLen; i++)
    {
        dwHash = (dwHash << 8) ^ *pdw++;
    }

    return dwHash;
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CNameHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    SNameHashNode  *pNNode = (SNameHashNode *) pNode;
    const SNameKey *pKey   = (const SNameKey *) k;

    if (dwHash == pNNode->dwHash)
    {
        // a quick compare of the hash values found a match, now do
        // a full compare of the key
        if (*pKey->pIpid == pNNode->ipid)
            return !lstrcmpW( (WCHAR *) pKey->pName, (WCHAR *) &pNNode->sName );
        else
            return FALSE;
    }

    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::IncRef
//
//  Synopsis:   Find or create an entry for the specified name.  Increment
//              its reference count.
//
//---------------------------------------------------------------------------
HRESULT CNameHashTable::IncRef( ULONG cRefs, REFIPID ipid,
                                SECURITYBINDING *pName )
{
    AssertHashLocked();

    HRESULT  hr  = S_OK;

    // See if there is already a node in the table.
    DWORD dwHash = Hash( ipid, pName );
    SNameKey  key;
    key.pIpid = &ipid;
    key.pName = pName;
    SNameHashNode *pNode = (SNameHashNode *) Lookup( dwHash, &key );

    // If not, create one.
    if (pNode == NULL)
    {
        ULONG lLen = lstrlenW( (WCHAR *) pName );
        pNode = (SNameHashNode *) PrivMemAlloc( sizeof(SNameHashNode) +
                                                lLen*sizeof(WCHAR) );
        if (pNode != NULL)
        {
            pNode->cRef   = 0;
            pNode->dwHash = dwHash;
            pNode->ipid   = ipid;
            memcpy( &pNode->sName, pName, (lLen + 1) * sizeof(WCHAR) );
            Add( dwHash, &pNode->chain );
        }
        else
            hr = E_OUTOFMEMORY;
    }

    // Increment the reference count on the node.
    if (pNode != NULL)
        pNode->cRef += cRefs;

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CNameHashTable::DecRef
//
//  Synopsis:   Decrement references for the specified name.  Do not decrement
//              more references then exist.  Return the actual decrement count.
//
//---------------------------------------------------------------------------
ULONG CNameHashTable::DecRef( ULONG cRefs, REFIPID ipid,
                              SECURITYBINDING *pName )
{
    AssertHashLocked();

    // Lookup the name.
    DWORD          dwHash = Hash( ipid, pName );
    SNameKey       key;
    key.pIpid = &ipid;
    key.pName = pName;
    SNameHashNode *pNode = (SNameHashNode *) Lookup( dwHash, &key );

    if (pNode != NULL)
    {
        if (pNode->cRef < cRefs)
            cRefs = pNode->cRef;

        pNode->cRef -= cRefs;
        if (pNode->cRef == 0)
        {
            Remove( &pNode->chain );
            PrivMemFree( pNode );
        }
    }
    else
        cRefs = 0;

    return cRefs;
}

//---------------------------------------------------------------------------
//
//  Method:     CExtHashTable::Hash
//
//  Synopsis:   Computes the hash value for a given key.
//
//---------------------------------------------------------------------------
DWORD CExtHashTable::Hash( LPCWSTR pwszExt )
{
    DWORD  dwHash  = 0;
    WORD   *pw     = (WORD *) pwszExt;
    DWORD  dwLen   = lstrlenW( pwszExt );
    ULONG  i;

    // Hash the name.
    for (i=0; i < dwLen; i++)
    {
        dwHash = (dwHash << 8) ^ *pw++;
    }

    return dwHash;
}

//---------------------------------------------------------------------------
//
//  Method:     CExtHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CExtHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    return !lstrcmpW((LPCWSTR)k, ((SExtHashNode *)pNode)->pwszExt);
}

//---------------------------------------------------------------------------
//
//  Method:     CMIPIDHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CMIPIDHashTable::Compare(const void *k, SHashChain *pNode, DWORD dwHash )
{
    MIPID *p1 = (MIPID *)k;
    MIPID *p2 = (MIPID *)&((SMIPIDHashNode *)pNode)->mipid;
    return (p1->mid == p2->mid && p1->ipid == p2->ipid && p1->dwApt == p2->dwApt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\events.cxx ===
//+-------------------------------------------------------------------
//
//  File:       events.cxx
//
//  Contents:   Vista events and related functions
//
//  History:    26-Sep-97  RongC  Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <scm.h>
#include <ipidtbl.hxx>
#include <marshal.hxx>
#include <events.hxx>
#include <vsevfire.h>

// TRICK:
// Under the treat as key, we have the forwarding CLSID and the switch
// to enable/disable event logging.
// When the apps create IEC (in-proc part of the event logging monitor),
// they use CLSID_VSA_IEC as class ID, and the
// IEC class factory uses CLSID_VSA_IEC, too.  We, ole32, intercept
// the CoCreateInstance() and give apps a wrapper object of IEC.
// As the real LEC (the event logging monitor of the local machine) starts
// up, it will signal a named event, created in dcomss\warpper\start.cxx.
// As soon as we see the signal, we are going to create the real IEC
// in the app process and forwarding all calls from the wrapper to IEC.
// To avoid dead loop on create IEC (as we use CoCreateInstance() to create
// IEC also), we use a different CLSID, namely CLSID_VSA_IEC_TREATAS.
//
extern const CLSID CLSID_VSA_IEC_TREATAS =
    {0x6C736DB0,0xBD94,0x11D0,{0x8A,0x23,0x00,0xAA,0x00,0xB5,0x8E,0x10}};


// Event IDs are just IDs, so we pick the ones we are familiar with.
// The advantages are (1) we can easily tell the messages are from us;
// (2) same some space when re-using the old GUIDs.
//
const GUID GUID_ComEventLogSession =
    {0x95734d90,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComClassRegistration =
    {0x95734d91,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComClassRevokation =
    {0x95734d92,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComClientCall =
    {0x95734d93,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComClientReturn =
    {0x95734d94,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComStubEnter =
    {0x95734d95,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComStubLeave =
    {0x95734d96,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComStubException =
    {0x95734d97,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComMarshal =
    {0x95734d98,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComDisconnectMarshal =
    {0x95734d99,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComUnmarshal =
    {0x95734d9a,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};

const GUID GUID_ComDisconnectUnmarshal =
    {0x95734d9b,0x57a9,0x11d1,{0xa4,0x9c,0x00,0xc0,0x4f,0xb9,0x98,0x0f}};


// Predefine some event Keys and Types to speed things up.
//
static DWORD ClsTypes[3] = {
    (DWORD) cVSAParameterValueGUID,
    (DWORD) cVSAParameterValueDWORD,
    (DWORD) cVSAParameterValueDWORD
};

static ULONG_PTR ClsKeys[3] = {
    (ULONG_PTR) cVSAStandardParameterSourceHandle,
    (ULONG_PTR) cVSAStandardParameterCorrelationID,
    (ULONG_PTR) cVSAStandardParameterReturnValue
};

static DWORD RpcTypes[6] = {
    (DWORD) cVSAParameterValueGUID,
    (DWORD) (cVSAParameterValueGUID | cVSAParameterKeyString),
    (DWORD) cVSAParameterValueDWORD,
    (DWORD) (cVSAParameterValueGUID | cVSAParameterKeyString),
    (DWORD) (cVSAParameterValueDWORD | cVSAParameterKeyString),
    (DWORD) cVSAParameterValueDWORD
};

static LPCOLESTR pApartmentID   = L"MOXID";
static LPCOLESTR pInterfaceID   = L"IID";
static LPCOLESTR pMethodNumber  = L"Method#";
static LPCOLESTR pBinding       = L"Binding";

// Used by LogEventClientCall(), LogEventClientReturn(),
// LogEventStubEnter(), LogEventStubLeave(), LogEventStubException()
//
static ULONG_PTR RpcKeys[6] = {
    (ULONG_PTR) cVSAStandardParameterTargetHandle,
    (ULONG_PTR) pApartmentID,
    (ULONG_PTR) cVSAStandardParameterCorrelationID,
    (ULONG_PTR) pInterfaceID,
    (ULONG_PTR) pMethodNumber,
    (ULONG_PTR) cVSAStandardParameterReturnValue
};

// Used by LogEventMarshal() and LogEventUnmarshal()
//
static ULONG_PTR MrsKeys[5] = {
    (ULONG_PTR) cVSAStandardParameterSourceHandle,
    (ULONG_PTR) pApartmentID,
    (ULONG_PTR) cVSAStandardParameterCorrelationID,
    (ULONG_PTR) pInterfaceID,
    (ULONG_PTR) pBinding
};

// Used by LogEventDisconnect()
//
static ULONG_PTR DisKeys[2] = {
    (ULONG_PTR) cVSAStandardParameterCorrelationID,
    (ULONG_PTR) pBinding
};


// Global vars
//
static HANDLE g_hEventLogger = NULL;    // Win32 NamedEvent to sync with logger
static ISystemDebugEventFire * g_pEventFire = NULL; // The instance for ole32



//+-------------------------------------------------------------------
//
//  Class:      CDebugEventFire
//
//  Synopsis:   The wrapper class for event logging object (IEC)
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
class CDebugEventFire : public ISystemDebugEventFire
{
public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppv);
    ULONG   STDMETHODCALLTYPE AddRef();
    ULONG   STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE BeginSession(
        /* [in] */ REFGUID guidSourceID,
        /* [in] */ LPCOLESTR strSessionName);

    HRESULT STDMETHODCALLTYPE EndSession( void);

    HRESULT STDMETHODCALLTYPE IsActive( void);

    HRESULT STDMETHODCALLTYPE FireEvent(
        /* [in] */ REFGUID guidEvent,
        /* [in] */ int nEntries,
        /* [size_is][in] */ PULONG_PTR rgKeys,
        /* [size_is][in] */ PULONG_PTR rgValues,
        /* [size_is][in] */ LPDWORD rgTypes,
        /* [in] */ DWORD dwTimeLow,
        /* [in] */ LONG dwTimeHigh,
        /* [in] */ VSAEventFlags dwFlags);

    HRESULT Initialize();
    void Cleanup();

    virtual void _CreateLogger();
    virtual void _DestroyLogger();

    HRESULT GetEventLogger(ISystemDebugEventFire **);

    void* operator new(size_t size)         { return(PrivMemAlloc(size)); }
    void  operator delete(void * pv)        { PrivMemFree(pv); }

protected:
    friend static void _CreateLoggerHelper(CDebugEventFire *);

    unsigned long _cRef;                    // ref count
    CRITICAL_SECTION _csEventFire;          // for thread safety
    BOOL _fLogDisabled;                     // disable the obj
    GUID _guidSession;                      // session id
    LPOLESTR _strSessionName;               // session name
    ISystemDebugEventFire * _pEventFire;    // the real IEC, if it's not NULL
    IUnknown * _punkFTM;
};


//+-------------------------------------------------------------------
//
//  Class:      COle32DebugEventFire
//
//  Synopsis:   The wrapper class of IEC that lives in OLE32.
//              There should be only one instance of this.
//              We could make it a global variable, I suppose.
//              The whole reason we need this is that we can't
//              CoCreateInstance on demand deep down in the channel
//              code as the IEC will use DCOM to create LEC.
//              That is, we must create/destroy IEC differently from
//              what we usually do in the app layer.
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
class COle32DebugEventFire : public CDebugEventFire
{
public:
    virtual void _CreateLogger();
    virtual void _DestroyLogger();
};


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::Initialize()
//
//  Synopsis:   Initialize the wrapper for IEC.  Didn't define it as
//              constructor because, it's possible that we will use
//              CDebugEventFire as global or static var sometimes.
//              We don't want to incur early init over head or
//              late init threading problems.
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT CDebugEventFire::Initialize()
{
    NTSTATUS status;

    _cRef = 0;
    _strSessionName = NULL;
    _pEventFire = NULL;
    _fLogDisabled = FALSE;
    _punkFTM = NULL;

    status = RtlInitializeCriticalSection(&_csEventFire);
    return NT_SUCCESS(status) ? S_OK : E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::Cleanup()
//
//  Synopsis:   The opposite of init.  Destruction are done differently for
//              app and OLE32 IEC, that is, one uses DCOM and one does not.
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void CDebugEventFire::Cleanup()
{
    EnterCriticalSection(&_csEventFire);

    if (_strSessionName != NULL)
    {
        PrivMemFree(_strSessionName);
        _strSessionName = NULL;
    }

    if (_punkFTM != NULL)
    {
        _punkFTM->Release();
    }

    _DestroyLogger();

    LeaveCriticalSection(&_csEventFire);
    DeleteCriticalSection(&_csEventFire);
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::_DestroyLogger()
//
//  Synopsis:   The normal version for applications
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void CDebugEventFire::_DestroyLogger()
{
    // holding the lock already

    if (_pEventFire != NULL)
    {
        _pEventFire->Release();
        _pEventFire = NULL;
    }
}


//+-------------------------------------------------------------------
//
//  Member:     COle32DebugEventFire::_DestroyLogger()
//
//  Synopsis:   The OLE32 version for DCOM
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void COle32DebugEventFire::_DestroyLogger()
{
    // holding the lock already

    if (_pEventFire != NULL)
    {
        ISystemDebugEventShutdown * pShutdown;
        HRESULT hr;
        hr = _pEventFire->QueryInterface(
                        IID_ISystemDebugEventShutdown, (void**)&pShutdown);
        if (SUCCEEDED(hr))
        {
            pShutdown->Shutdown();
            pShutdown->Release();
        }
        _pEventFire->Release();
        _pEventFire = NULL;
    }
}


//+-------------------------------------------------------------------
//
//  Function:   _CreateLoggerHelper (private)
//
//  Synopsis:   Create the real IEC and forward the begin session call
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
static void _CreateLoggerHelper(CDebugEventFire * pThis)
{
    // CoCreateInstance() and ISystemDebugEventFire::BeginSession() below
    // might make RPC calls, that is, recursions could happen.

    // Create event logging monitor if possible

    // We create a wrapper for Vista IEC object for everyone
    // CoCreateinstance() with CLSID_VSA_IEC whether Vista is
    // on the system or not.  When the Vista LEC is ready,
    // we must forward the calls by creating a real IEC.
    // CLSID_VSA_IEC_TREATAS is the class ID we use internally.
    //
    ISystemDebugEventFire * pEventFire;
    HRESULT hr = CoCreateInstance(CLSID_VSA_IEC_TREATAS, NULL,
                                  (CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD),
                                  IID_ISystemDebugEventFire,
                                  (void**) &pEventFire);
    if (SUCCEEDED(hr))
    {
        hr = pEventFire->BeginSession(
                            pThis->_guidSession, pThis->_strSessionName);
        if (SUCCEEDED(hr))
        {
            pThis->_pEventFire = pEventFire;    // Make it public
            pThis->_fLogDisabled = FALSE;       // Enable the event logging
        }
    }

    if (FAILED(hr))                             // Fail and we never come back
    {
        if (pEventFire != NULL)                 // BeginSession() failed
        {
            pEventFire->Release();
            pThis->_fLogDisabled = TRUE;        // Disable this logger
        }
        else                                    // CoCreateInstance failed
        {
            // Disable all subsequent even logging activities
            CloseHandle(g_hEventLogger);
            g_hEventLogger = NULL;
        }
    }
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::_CreateLogger()
//
//  Synopsis:   Create the real IEC the normal way
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void CDebugEventFire::_CreateLogger()
{
    HRESULT hr;
    COleTls tls(hr);    // Make sure TLS is initialized on this thread
    if (FAILED(hr))
        return;

    // App may try to create Vista LEC, so we must prevent OLE32.dll
    // from creating its LEC for now, or we might deadlock
    //
    tls->dwFlags |= OLETLS_DISABLE_EVENTLOGGER; // Prevent recursion

    // holding the lock already
    _CreateLoggerHelper(this);

    tls->dwFlags &= ~OLETLS_DISABLE_EVENTLOGGER;
}


//+-------------------------------------------------------------------
//
//  Function:   _CreateLoggerWorker (private)
//
//  Synopsis:   Worker thread routine to create the real IEC
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
static
DWORD WINAPI _CreateLoggerWorker(LPVOID pv)
{
    HRESULT hr;
    COleTls tls(hr);    // Make sure TLS is initialized on this thread
    if (FAILED(hr))
        return 0;

    // We set this per thread flag so we know not to enter here again.
    // The code will dead lock on trying to get the wrapper's critical
    // section without this flag.  We could use _fLogDisabled for
    // same reason, but somehow it was not reliable (mmm...).
    // As we need to test for 16 bit using Tls anyway, one more bit
    // does not cost much.  So do it at least for now.
    //
    tls->dwFlags |= OLETLS_DISABLE_EVENTLOGGER; // Prevent recursion

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (SUCCEEDED(hr))
    {
        _CreateLoggerHelper((CDebugEventFire *) pv);

        Win4Assert(tls->dwFlags & OLETLS_DISABLE_EVENTLOGGER);
        CoUninitialize();
    }

    tls->dwFlags &= ~OLETLS_DISABLE_EVENTLOGGER;
    return 0;
}


//+-------------------------------------------------------------------
//
//  Member:     COle32DebugEventFire::_CreateLogger()
//
//  Synopsis:   Create a thread to create the real IEC
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void COle32DebugEventFire::_CreateLogger()
{
    // holding the lock already
    _fLogDisabled = TRUE;           // Prevent new thread re-enter here

    DWORD dwThreadId;
    HANDLE hThread = CreateThread(
                        NULL, 0, _CreateLoggerWorker, this, 0, &dwThreadId);
    if (hThread)
    {
        // Wait for the worker thread to finish.
        // We might not want to wait in the future for efficiency.
        // In that case, we need to revisit the threading issues.
        // For now, this thread hangs, and the worker modifies the wrapper.
        //
        WaitForSingleObject(hThread, 7000);  // 7 seconds
        CloseHandle(hThread);
    }
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::GetEventLogger
//
//  Synopsis:   Create the real event logger on demand if LEC has signaled.
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT
CDebugEventFire::GetEventLogger(ISystemDebugEventFire ** ppEventFire)
{
    if (g_hEventLogger == NULL || WaitForSingleObject(g_hEventLogger, 0) != WAIT_OBJECT_0)
    {
        // Logger event is not signaled

        if (_pEventFire != NULL)
        {
            EnterCriticalSection(&_csEventFire);
            _DestroyLogger();                       // Free the old logger
            LeaveCriticalSection(&_csEventFire);
        }
        return E_FAIL;
    }

    // Check if either the whole process or this logger has been turned off
    if (_fLogDisabled || g_hEventLogger == NULL || _strSessionName == NULL)
    {
        return E_FAIL;
    }

    HRESULT hr = E_FAIL;
    EnterCriticalSection(&_csEventFire);

    if (! _fLogDisabled && g_hEventLogger != NULL)
    {
        // Logger event is signaled
        // The logger has been created and not being disabled

        if (_pEventFire == NULL)
        {
            // Starting event logger...
            // Only the first thread will make it here

            _CreateLogger();        // Will set _pEventFire if succeeded
        }

        if (_pEventFire != NULL)
        {
            _pEventFire->AddRef();
            *ppEventFire = _pEventFire;

            hr = NOERROR;
        }
    }

    LeaveCriticalSection(&_csEventFire);
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::QueryInterface
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_ISystemDebugEventFire))
    {
        *ppv = (ISystemDebugEventFire *) this;
        AddRef();
        hr = S_OK;
    }
    else if (IsEqualGUID(riid, IID_IMarshal) ||
             IsEqualGUID(riid, IID_IMarshal2))
    {
        if (_punkFTM == NULL)
        {
            hr = CoCreateFreeThreadedMarshaler((ISystemDebugEventFire *)this,
                                               (LPUNKNOWN *)&_punkFTM);
            if (FAILED(hr))
            {
                *ppv = NULL;
                return hr;
            }
        }

        hr = _punkFTM->QueryInterface(riid, ppv);
    }
    else {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::AddRef
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CDebugEventFire::AddRef()
{
    InterlockedIncrement((long *) &_cRef);
    return _cRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::Release
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CDebugEventFire::Release()
{
    ULONG count = InterlockedDecrement((long *) &_cRef);

    if (count == 0)
    {
        this->Cleanup();
        delete this;
    }

    return count;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::BeginSession
//
//  Synopsis:   Simulate IEC BeginSession
//              Wrapper class caches the info for later use
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::BeginSession(
        /* [in] */ REFGUID guidSourceID,
        /* [in] */ LPCOLESTR strSessionName)
{
    LogEventInitialize();

    EnterCriticalSection(&_csEventFire);

    if (_strSessionName != NULL)
        PrivMemFree(_strSessionName);

    DWORD cbSize = (lstrlenW(strSessionName) + 1) * sizeof(WCHAR);
    _strSessionName = (LPOLESTR) PrivMemAlloc(cbSize);
    if (_strSessionName == NULL)
        return E_OUTOFMEMORY;

    lstrcpyW(_strSessionName, strSessionName);
    _guidSession = guidSourceID;

    LeaveCriticalSection(&_csEventFire);
    return NOERROR;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::EndSession
//
//  Synopsis:   Forwarding IEC EndSession() if it is there
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::EndSession()
{
    ISystemDebugEventFire * pEventFire;
    HRESULT hr = GetEventLogger(&pEventFire);
    if (SUCCEEDED(hr))
    {
        hr = pEventFire->EndSession();
        pEventFire->Release();

        EnterCriticalSection(&_csEventFire);
        _DestroyLogger();                       // Free the old logger
        LeaveCriticalSection(&_csEventFire);
    }
    else if (hr == E_FAIL)
    {
        hr = NOERROR;       // ignore wrapper errors
    }
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::IsActive
//
//  Synopsis:   Forwarding IEC IsActive() if it is there
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::IsActive()
{
    // Check this first, so machines disabled/without event logging
    // would pay little overhead.
    //
    if (g_hEventLogger == NULL)
        return S_FALSE;

    ISystemDebugEventFire * pEventFire;
    HRESULT hr = GetEventLogger(&pEventFire);
    if (SUCCEEDED(hr))
    {
        hr = pEventFire->IsActive();
        pEventFire->Release();
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFire::FireEvent
//
//  Synopsis:   Forwarding IEC FireEvent() if it is there
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDebugEventFire::FireEvent(
        /* [in] */ REFGUID guidEvent,
        /* [in] */ int nEntries,
        /* [size_is][in] */ PULONG_PTR rgKeys,
        /* [size_is][in] */ PULONG_PTR rgValues,
        /* [size_is][in] */ LPDWORD rgTypes,
        /* [in] */ DWORD dwTimeLow,
        /* [in] */ LONG dwTimeHigh,
        /* [in] */ VSAEventFlags dwFlags)
{
    ISystemDebugEventFire * pEventFire;
    HRESULT hr = GetEventLogger(&pEventFire);
    if (SUCCEEDED(hr))
    {
        hr = pEventFire->FireEvent(
                            guidEvent, nEntries,
                            rgKeys, rgValues, rgTypes,
                            dwTimeLow, dwTimeHigh, dwFlags);
        pEventFire->Release();
    }
    else if (hr == E_FAIL)
    {
        hr = NOERROR;       // ignore wrapper errors
    }
    return hr;
}


//+-------------------------------------------------------------------
//
//  Class:      CDebugEventFireCF
//
//  Synopsis:   To create the IEC wrapper for apps
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
class CDebugEventFireCF : public IClassFactory
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown *punkOuter, REFIID riid, void **ppv);
    STDMETHOD(LockServer)(BOOL fLockServer);
};

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::QueryInterface
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT CDebugEventFireCF::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory*) this;
        return NOERROR;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::AddRef
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
ULONG CDebugEventFireCF::AddRef(void)
{
    return 1;       // there is only one instance in the global space
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::AddRef
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
ULONG CDebugEventFireCF::Release(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::CreateInstance
//
//  Synopsis:
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT CDebugEventFireCF::CreateInstance(IUnknown *punkOuter,
        REFIID riid, void **ppv)
{
    HRESULT hr;

	*ppv = NULL;

    if (punkOuter != NULL)
    {        
        return CLASS_E_NOAGGREGATION;
    }

    CDebugEventFire * pCEventFire;
    pCEventFire = (CDebugEventFire *) new CDebugEventFire;
    if (pCEventFire == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = pCEventFire->Initialize();
    if (FAILED(hr))
    {
        // don't need to call Cleanup here
        delete pCEventFire;
        return hr;
    }

    hr = pCEventFire->QueryInterface(riid, ppv);
    if (FAILED(hr))
    {
        pCEventFire->Cleanup();
        delete pCEventFire;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugEventFireCF::LockServer
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT CDebugEventFireCF::LockServer(BOOL fLockServer)
{
    return NOERROR;
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventGetClassObject
//
//  Synopsis:   Called from CoGetClassObject (as one of the internal classes)
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
HRESULT LogEventGetClassObject(REFIID riid, void **ppv)
{
    static CDebugEventFireCF g_EventFireCF;  // the only instance
    return g_EventFireCF.QueryInterface(riid, ppv);
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventInitialize
//
//  Synopsis:   Init Logger, Called by ChannelProcessInitialize(void)
//              This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventInitialize()
{
    if (g_hEventLogger != NULL)     // Has been initialized, do nothing
        return;

    // Check if we are inside VSA LEC process.
    // If so quit, since we can't launch LEC against ourselves.
    //
    char szA[40];
    DWORD procID = GetCurrentProcessId();
    wsprintfA(szA, "MSFT.VSA.COM.DISABLE.%d", procID);

    HANDLE hVSA = OpenEventA(EVENT_ALL_ACCESS, FALSE, szA);
    if (hVSA != NULL)
    {
        CloseHandle(hVSA);
        return;
    }

    // RPCSS creates this named event, and Visat will signal it.
    g_hEventLogger = OpenEventA(EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE,
                                "MSFT.VSA.IEC.STATUS.6c736db0");

    if (g_hEventLogger != NULL)
    {
        COle32DebugEventFire * pCEventFire = new COle32DebugEventFire;
        if (pCEventFire == NULL)       // out of memory?
        {
            CloseHandle(g_hEventLogger);
            g_hEventLogger = NULL;
            g_pEventFire = NULL;
            return;
        }

        pCEventFire->Initialize();
        pCEventFire->QueryInterface(
                     IID_ISystemDebugEventFire, (void**)&g_pEventFire);

        OLECHAR sz[32];
        wsprintf(sz, L"COM Runtime %d", procID);
        g_pEventFire->BeginSession(GUID_ComEventLogSession, sz);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventCleanup
//
//  Synopsis:   UnInit Logger, Called by ChannelProcessUninitialize(void)
//              This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventCleanup()
{
    if (g_hEventLogger == NULL)     // Not yet initialized, do nothing
        return;

    if (g_pEventFire != NULL)
    {
        g_pEventFire->Release();
        g_pEventFire = NULL;
    }

    CloseHandle(g_hEventLogger);
    g_hEventLogger = NULL;
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventIsActive
//
//  Synopsis:   Forward IEC IsActive if the logger is there.
//              Disable 16 bit apps as they don't init things correctly.
//              This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
BOOL LogEventIsActive()
{
    // Make sure we are not holding the lock, or we will deadlock
    // on creating the event logger.
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (g_hEventLogger == NULL)     // most machines don't have logging
        return FALSE;

    HRESULT hr;
    COleTls tls(hr);    // Make sure TLS is initialized on this thread
    if (FAILED(hr) ||
        (tls->dwFlags & (OLETLS_WOWTHREAD | OLETLS_DISABLE_EVENTLOGGER)) != 0)
    {
        // If we are in 16 bit thread or inside _CreateLogger(), do nothing
        return FALSE;
    }

    if (g_pEventFire != NULL)
    {
        return (g_pEventFire->IsActive()==S_OK);
    }
    return FALSE;
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventClassRegistration
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventClassRegistration(HRESULT hr, RegInput* pRegIn, RegOutput* pRegOut)
{
    if (g_pEventFire != NULL)
    {
        ULONG_PTR ClsValues[3];
        ClsValues[2] = (ULONG_PTR) hr;

        DWORD Entries = pRegIn->dwSize;
        RegInputEntry * pRegInEntry = pRegIn->rginent;
        DWORD * pRegOutEntry = pRegOut->RegKeys;

        for (DWORD i = 0; i < Entries; i++, pRegInEntry++, pRegOutEntry++)
        {
            ClsValues[0] = (ULONG_PTR) &pRegInEntry->clsid;
            ClsValues[1] = (ULONG_PTR) *pRegOutEntry;
            g_pEventFire->FireEvent(
                    GUID_ComClassRegistration, 3, ClsKeys, ClsValues, ClsTypes,
                    0, 0, cVSAEventDefaultSource);
        }
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventClassRevokation
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventClassRevokation(REFCLSID rclsid, DWORD dwReg)
{
    if (g_pEventFire != NULL)
    {
        ULONG_PTR ClsValues[2];
        ClsValues[0] = (ULONG_PTR) &rclsid;
        ClsValues[1] = (ULONG_PTR) dwReg;

        g_pEventFire->FireEvent(
                GUID_ComClassRevokation, 2, ClsKeys, ClsValues, ClsTypes,
                0, 0, cVSAEventDefaultSource);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventClientCall
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventClientCall(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComClientCall, 5, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultSource);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventClientReturn
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventClientReturn(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComClientReturn, 5, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultSource);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventStubEnter
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventStubEnter(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComStubEnter, 5, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultTarget);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventStubLeave
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventStubLeave(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComStubLeave, 5, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultTarget);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventStubException
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventStubException(ULONG_PTR * RpcValues)
{
    if (g_pEventFire != NULL)
    {
        g_pEventFire->FireEvent(
                GUID_ComStubException, 6, RpcKeys, RpcValues, RpcTypes,
                0, 0, cVSAEventDefaultTarget);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   LogEventMarshalHelper
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
static void LogEventMarshalHelper(
            OBJREF& objref, ULONG_PTR * MrsValues, DWORD * MrsTypes)
{
    OXIDEntry * pOXIDEntry = GetOXIDFromObjRef(objref);
    STDOBJREF * pStd = &ORSTD(objref).std;
    MOID moid;
    MOIDFromOIDAndMID(pStd->oid, pOXIDEntry->GetMid(), &moid);

    MIDEntry* pLocalMIDEntry = NULL;

    DUALSTRINGARRAY *psa = pOXIDEntry->Getpsa();
    if (psa == NULL)
    {
        gMIDTbl.GetLocalMIDEntry(&pLocalMIDEntry);
        psa = (pLocalMIDEntry ? pLocalMIDEntry->Getpsa() : NULL);          
    }

    MrsValues[0] = (ULONG_PTR) &pStd->ipid;
    MrsValues[1] = (ULONG_PTR) pOXIDEntry->GetMoxidPtr();
    MrsValues[2] = (ULONG_PTR) &moid;
    MrsValues[3] = (ULONG_PTR) &objref.iid;
    MrsValues[4] = (ULONG_PTR) (psa ? psa->aStringArray : NULL);

    MrsTypes[0] = (DWORD) cVSAParameterValueGUID,
    MrsTypes[1] = (DWORD) (cVSAParameterValueGUID|cVSAParameterKeyString),
    MrsTypes[2] = (DWORD) cVSAParameterValueGUID,
    MrsTypes[3] = (DWORD) (cVSAParameterValueGUID|cVSAParameterKeyString),
    MrsTypes[4] = (DWORD)
        (cVSAParameterValueBYTEArray | cVSAParameterKeyString) |
        ((psa ? (psa->wNumEntries * sizeof(short)) : 0) & cVSAParameterValueLengthMask);

    // Deref local mid entry if we had to use it
    if (pLocalMIDEntry) pLocalMIDEntry->DecRefCnt();
}

//+-------------------------------------------------------------------
//
//  Function:   LogEventMarshal
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventMarshal(OBJREF& objref)
{
    if (g_pEventFire != NULL)
    {
        ULONG_PTR MrsValues[5];
        DWORD MrsTypes[5];
        LogEventMarshalHelper(objref, MrsValues, MrsTypes);

        g_pEventFire->FireEvent(
            GUID_ComMarshal, 5, MrsKeys, MrsValues, MrsTypes,
            0, 0, cVSAEventDefaultTarget);
    }
}

//+-------------------------------------------------------------------
//
//  Function:   LogEventUnmarshal
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventUnmarshal(OBJREF& objref)
{
    if (g_pEventFire != NULL)
    {
        ULONG_PTR MrsValues[5];
        DWORD MrsTypes[5];
        LogEventMarshalHelper(objref, MrsValues, MrsTypes);

        g_pEventFire->FireEvent(
                GUID_ComUnmarshal, 5, MrsKeys, MrsValues, MrsTypes,
                0, 0, cVSAEventDefaultSource);
    }
}

//+-------------------------------------------------------------------
//
//  Function:   LogEventDisconnect
//
//  Synopsis:   This is internal to OLE32
//
//  History:    26-Sep-97   RongC      Created.
//
//--------------------------------------------------------------------
void LogEventDisconnect(const MOID * pMoid, MIDEntry * pMIDEntry,
                        BOOL fServerSide)
{
    Win4Assert(pMIDEntry);

    if (g_pEventFire == NULL)
        return;

    ULONG_PTR values[2];
    values[0] = (ULONG_PTR) pMoid;

    DUALSTRINGARRAY * psa;
    psa = pMIDEntry->Getpsa();
    values[1] = (ULONG_PTR) psa->aStringArray;

    DWORD types[2];
    types[0] = (DWORD) cVSAParameterValueGUID,
    types[1] = (DWORD)
        (cVSAParameterValueBYTEArray | cVSAParameterKeyString) |
        ((psa->wNumEntries * sizeof(short)) & cVSAParameterValueLengthMask);

    const GUID * pGuid;
    VSAEventFlags EventFlags;
    if (fServerSide)
    {
        pGuid = &GUID_ComDisconnectMarshal;
        EventFlags = cVSAEventDefaultTarget;
    }
    else
    {
        pGuid = &GUID_ComDisconnectUnmarshal;
        EventFlags = cVSAEventDefaultSource;
    }

    g_pEventFire->FireEvent(
            *pGuid, 2, DisKeys, values, types, 0, 0, EventFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\idobj.cxx ===
//+-------------------------------------------------------------------
//
//  File:       IDObj.cxx
//
//  Contents:   Data structures tracking object identity
//
//  Classes:    CIDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <idobj.hxx>
#include <comsrgt.hxx>
#include <stdid.hxx>
#include <crossctx.hxx>
#include <surract.hxx>

#define MAX_NODES_TO_REMOVE    100

//+-------------------------------------------------------------------
//
// Class globals
//
//+-------------------------------------------------------------------
CPageAllocator CIDObject::s_allocator;       // Allocator for IDObjects
DWORD          CIDObject::s_cIDs;            // Relied on being ZERO
BOOL           CIDObject::s_fInitialized;    // Relied on being FALSE

BOOL           CPIDTable::s_fInitialized;    // Relied on being FALSE
// Hash Buckets for pointer id table
SHashChain CPIDTable::s_PIDBuckets[NUM_HASH_BUCKETS] = {
    {&s_PIDBuckets[0],  &s_PIDBuckets[0]},
    {&s_PIDBuckets[1],  &s_PIDBuckets[1]},
    {&s_PIDBuckets[2],  &s_PIDBuckets[2]},
    {&s_PIDBuckets[3],  &s_PIDBuckets[3]},
    {&s_PIDBuckets[4],  &s_PIDBuckets[4]},
    {&s_PIDBuckets[5],  &s_PIDBuckets[5]},
    {&s_PIDBuckets[6],  &s_PIDBuckets[6]},
    {&s_PIDBuckets[7],  &s_PIDBuckets[7]},
    {&s_PIDBuckets[8],  &s_PIDBuckets[8]},
    {&s_PIDBuckets[9],  &s_PIDBuckets[9]},
    {&s_PIDBuckets[10], &s_PIDBuckets[10]},
    {&s_PIDBuckets[11], &s_PIDBuckets[11]},
    {&s_PIDBuckets[12], &s_PIDBuckets[12]},
    {&s_PIDBuckets[13], &s_PIDBuckets[13]},
    {&s_PIDBuckets[14], &s_PIDBuckets[14]},
    {&s_PIDBuckets[15], &s_PIDBuckets[15]},
    {&s_PIDBuckets[16], &s_PIDBuckets[16]},
    {&s_PIDBuckets[17], &s_PIDBuckets[17]},
    {&s_PIDBuckets[18], &s_PIDBuckets[18]},
    {&s_PIDBuckets[19], &s_PIDBuckets[19]},
    {&s_PIDBuckets[20], &s_PIDBuckets[20]},
    {&s_PIDBuckets[21], &s_PIDBuckets[21]},
    {&s_PIDBuckets[22], &s_PIDBuckets[22]}
};
CPIDHashTable CPIDTable::s_PIDHashTbl;      // Hash table for pointer id table
CPIDTable gPIDTable;                        // Global pointer id table

BOOL           COIDTable::s_fInitialized;    // Relied on being FALSE
// Hash Buckets for OIDtable
SHashChain COIDTable::s_OIDBuckets[NUM_HASH_BUCKETS] = {
    {&s_OIDBuckets[0],  &s_OIDBuckets[0]},
    {&s_OIDBuckets[1],  &s_OIDBuckets[1]},
    {&s_OIDBuckets[2],  &s_OIDBuckets[2]},
    {&s_OIDBuckets[3],  &s_OIDBuckets[3]},
    {&s_OIDBuckets[4],  &s_OIDBuckets[4]},
    {&s_OIDBuckets[5],  &s_OIDBuckets[5]},
    {&s_OIDBuckets[6],  &s_OIDBuckets[6]},
    {&s_OIDBuckets[7],  &s_OIDBuckets[7]},
    {&s_OIDBuckets[8],  &s_OIDBuckets[8]},
    {&s_OIDBuckets[9],  &s_OIDBuckets[9]},
    {&s_OIDBuckets[10], &s_OIDBuckets[10]},
    {&s_OIDBuckets[11], &s_OIDBuckets[11]},
    {&s_OIDBuckets[12], &s_OIDBuckets[12]},
    {&s_OIDBuckets[13], &s_OIDBuckets[13]},
    {&s_OIDBuckets[14], &s_OIDBuckets[14]},
    {&s_OIDBuckets[15], &s_OIDBuckets[15]},
    {&s_OIDBuckets[16], &s_OIDBuckets[16]},
    {&s_OIDBuckets[17], &s_OIDBuckets[17]},
    {&s_OIDBuckets[18], &s_OIDBuckets[18]},
    {&s_OIDBuckets[19], &s_OIDBuckets[19]},
    {&s_OIDBuckets[20], &s_OIDBuckets[20]},
    {&s_OIDBuckets[21], &s_OIDBuckets[21]},
    {&s_OIDBuckets[22], &s_OIDBuckets[22]}
};
COIDHashTable COIDTable::s_OIDHashTbl;      // Hash table for OIDtable
COIDTable gOIDTable;                        // Global OIDtable
ULONG COIDTable::s_UnpinReqsPending;        // # of oid unpin req's pending
SHashChain COIDTable::s_OIDUnpinRequests;   // oid unpin requests pending

long gServerOIDCount;                       // Count of server OIDs

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Initialize     public
//
//  Synopsis:   Initializes allocator for IDObjects
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CIDObject::Initialize()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::Initialize\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Check init status
    if(s_fInitialized == FALSE)
    {
        // Initialize the allocators only if needed
        if(s_cIDs == 0)
            s_allocator.Initialize(sizeof(CIDObject), IDS_PER_PAGE, &gComLock);

        // Mark the state as initialized
        s_fInitialized = TRUE;
    }

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::operator new     public
//
//  Synopsis:   new operator of IDObject
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CIDObject::operator new(size_t size)
{
    ASSERT_LOCK_HELD(gComLock);

    void *pv;
    Win4Assert(size == sizeof(CIDObject) &&
               "CIDObject improperly inherited");

    // Make sure allocator is initialized
    Win4Assert(s_fInitialized);

    // Allocate memory
    pv = (void *) s_allocator.AllocEntry();
    ++s_cIDs;

    ASSERT_LOCK_HELD(gComLock);
    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::operator delete     public
//
//  Synopsis:   delete operator of IDObject
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CIDObject::operator delete(void *pv)
{
#if DBG==1
    // Ensure that the pv was allocated by the allocator
    // CPolicySet can be inherited only by those objects
    // with overloaded new and delete operators
    LONG index = s_allocator.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1);
#endif

    // Aquire lock
    LOCK(gComLock);

    // Release the pointer
    s_allocator.ReleaseEntry((PageEntry *) pv);
    --s_cIDs;
    // Cleanup allocator if needed
    if(s_fInitialized==FALSE && s_cIDs==0)
        s_allocator.Cleanup();

    // Release lock
    UNLOCK(gComLock);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Cleanup     public
//
//  Synopsis:   Cleanup allocator of IDObjects
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CIDObject::Cleanup()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::Cleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Check if initialized
    if(s_fInitialized)
    {
        // Ensure that there are no Identities
        if(s_cIDs == 0)
            s_allocator.Cleanup();

        // Reset state
        s_fInitialized = FALSE;
    }

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::CIDObject     public
//
//  Synopsis:   Constructor of IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CIDObject::CIDObject(IUnknown *pServer, CObjectContext *pServerCtx,
                     APTID aptID, DWORD dwState)
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::CIDObject this:%x pServer:%x\n"
                    , this, pServer));
    ASSERT_LOCK_HELD(gComLock);
    Win4Assert(dwState == IDFLAG_SERVER || dwState == IDFLAG_CLIENT);

    _cRefs       = 1;
    _oid         = GUID_NULL;
    _cCalls      = 0;
    _cLocks      = 0;

    _pStdWrapper = NULL;
    _pStdID      = NULL;
    _dwState     = dwState | IDFLAG_NOWRAPPERREF | IDFLAG_NOSTDIDREF;
    _aptID       = aptID;
    _pServer     = pServer;     // _pServer is a non-AddRef'd pointer

    // Save server context
    _pServerCtx  = pServerCtx;
    if (pServerCtx)
        pServerCtx->InternalAddRef();

    if (IsServer())
    {
        Win4Assert(_pServerCtx == GetCurrentContext());
        _pServerCtx->CreateIdentity(this);
    }
    else
    {
        Win4Assert(_pServerCtx != GetCurrentContext());
    }

    _oidUnpinReqChain.pNext = &_oidUnpinReqChain;
    _oidUnpinReqChain.pPrev = &_oidUnpinReqChain;
    _dwOidUnpinReqState = OIDUPREQ_NO_STATE;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::~CIDObject     public
//
//  Synopsis:   Destructor of IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CIDObject::~CIDObject()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::~CIDObject\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Actually being in the oid unpin request list does not
    // take an extra reference on this object.  So, if we do
    // find ourselves in that list at this point, force
    // a removal.
    COIDTable::SpecialCleanup(this);

    Win4Assert(!InOIDTable());
    Win4Assert(!InPIDTable());
    Win4Assert(IsZombie());
    Win4Assert(_pStdID == NULL);
    Win4Assert(_pStdWrapper == NULL);
    Win4Assert(_pServer == NULL);
    Win4Assert(_pServerCtx == NULL);
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::QueryInterface     public
//
//  Synopsis:   QI behavior of IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CIDObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::QueryInterface\n"));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IComObjIdentity *) this;
    }
    else if(IsEqualIID(riid, IID_IComObjIdentity))
    {
        *ppv = (IComObjIdentity *) this;
    }
    else if(IsEqualIID(riid, IID_IStdIDObject))
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // AddRef the interface before return
    if(*ppv)
        ((IUnknown *) (*ppv))->AddRef();

    ContextDebugOut((DEB_IDOBJECT, "CIDObject::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::AddRef     public
//
//  Synopsis:   AddRefs IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CIDObject::AddRef()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::AddRef\n"));

    ULONG cRefs;

    // Increment ref count
    cRefs = InterlockedIncrement((LONG *) &_cRefs);

    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Release     public
//
//  Synopsis:   Release IDObject
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CIDObject::Release()
{
    ContextDebugOut((DEB_IDOBJECT, "CIDObject::Release\n"));

    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &_cRefs);
    // Check if this is the last release
    if(cRefs == 0)
    {
        ASSERT_LOCK_NOT_HELD(gComLock);

        // Release server context
        CObjectContext *pServerCtx = NULL;
        if(_pServerCtx)
        {
            if(IsServer())
            {
                Win4Assert(_pServer || IsDeactivated());
                Win4Assert(_pServerCtx == GetCurrentContext());
            }

            pServerCtx = _pServerCtx;
        }

        // Delete IDObject
        LOCK(gComLock);

        // Remove from PIDTable if still present.
        // This can happen only under stress when we fail to create
        // a StdID.
        if(InPIDTable())
        {
            Win4Assert(IsServer());
            gPIDTable.Remove(this);
        }

#if DBG==1
        _pServerCtx = NULL;
        _pServer = NULL; // _pServer is a non-AddRef'd pointer
#endif
        delete this;
        UNLOCK(gComLock);

        // Release server context if necessary
        if(pServerCtx)
            pServerCtx->InternalRelease();

    }

    ContextDebugOut((DEB_IDOBJECT, "CIDObject::Release returning 0x%x\n",
                     cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::GetIdentity     public
//
//  Synopsis:   Return the controlling unknown of the identified object.
//
//  History:    15-Apr-98   JimLyon     Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CIDObject::GetIdentity(IUnknown **ppUnk)
{
    if (ppUnk == NULL)
        return E_INVALIDARG;

    if (_pServer != NULL)
    {
        _pServer->AddRef();
        *ppUnk = _pServer;
        return S_OK;
    }
    else
    {
        *ppUnk = NULL;
        return CO_E_OBJNOTCONNECTED;
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CIDObject::SetZombie     private
//
//  Synopsis:   Set IDFLAG_NOWRAPPERREF or NOSTDIDREF, and if this
//              results in us becoming a zombie, deal with that.
//
//  History:    15-Apr-98   JimLyon     Created
//              03-May-98   GopalK      Rewritten
//
//+-------------------------------------------------------------------
void CIDObject::SetZombie(DWORD dwIDFlag)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    BOOL fRelease = FALSE;

    // Aquire lock
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    // Update state
    if(dwIDFlag == IDFLAG_NOWRAPPERREF)
    {
        if(_pStdWrapper == NULL)
            _dwState |= dwIDFlag;
    }
    else
    {
        Win4Assert(dwIDFlag == IDFLAG_NOSTDIDREF);
        if(_pStdID == NULL)
            _dwState |= dwIDFlag;
    }

    // Check if the object has become a zombie object
    if (((_dwState & (IDFLAG_NOWRAPPERREF | IDFLAG_NOSTDIDREF)) ==
        (IDFLAG_NOWRAPPERREF | IDFLAG_NOSTDIDREF)) &&
        (_cLocks == 0))
    {
        // Sanity check
        Win4Assert(!IsZombie());

        // Update state
        _dwState |= IDFLAG_ZOMBIE;
        fRelease = TRUE;
    }

    // Check for the need to release state
    if(!fRelease)
    {
        // Release lock
        UNLOCK(gComLock);
        ASSERT_LOCK_NOT_HELD(gComLock);
    }
    else
    {
        if(!IsServer())
        {
            // Release lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }
        else
        {   
            // Sanity check
            Win4Assert(_pServer || IsDeactivated());
            Win4Assert(_pServerCtx == GetCurrentContext());

            // Remove from PIDTable if still present.
            // This can happen only under stress when we fail to create
            // a StdID.
            // We need to hold the lock for this operation
            if(InPIDTable())
            {
                gPIDTable.Remove(this);
            }

            // Release lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            _pServerCtx->DestroyIdentity(this);
        }

        if(_pServerCtx)
            _pServerCtx->InternalRelease();
        _pServerCtx = NULL;
        _pServer = NULL;    // _pServer is a non-AddRef'd pointer
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Deactivate   public
//
//  Synopsis:   Deactivates an object for JIT by releasing all
//              references to the real server.
//
//  History:    30-Dec-98   Rickhi      Created from other pieces
//
//+-------------------------------------------------------------------
HRESULT CIDObject::Deactivate()
{
    ASSERT_LOCK_HELD(gComLock);
    Win4Assert(IsServer());
    Win4Assert(!IsDeactivated());

    HRESULT hr = E_FAIL;

    // ensure no calls pending and the object does not
    // support IExternalConnection.
    if (_cCalls == 0 && (!_pStdID || _pStdID->GetIEC() == NULL))
    {
        // OK to deactivate, mark state as deactivation started.
        _dwState |= IDFLAG_DEACTIVATIONSTARTED;

        // remove from the PID table
        gPIDTable.Remove(this);

        hr = S_OK;
    }

    // release the lock for the rest of the work.
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (SUCCEEDED(hr))
    {
        // Deactivate wrapper
        if (_pStdWrapper)
            _pStdWrapper->Deactivate();

        // Deactivate StdId
        if (_pStdID)
            _pStdID->Deactivate();

        // update the state to say we are done.
        _dwState &= ~IDFLAG_DEACTIVATIONSTARTED;
        _dwState |= IDFLAG_DEACTIVATED;
        _pServer = NULL;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::Reactivate   public
//
//  Synopsis:   Reactivates an object for JIT by re-establishing all
//              references to the real server.
//
//  History:    30-Dec-98   Rickhi      Created from other pieces
//
//+-------------------------------------------------------------------
HRESULT CIDObject::Reactivate(IUnknown *pServer)
{
    Win4Assert(IsServer());

    HRESULT hr = CO_E_OBJNOTCONNECTED;

    if (!IsZombie())
    {
        hr = E_FAIL;

        // The server can only be reactivated in its
        // original context
        if (GetServerCtx() == GetCurrentContext())
        {
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Ensure that the server has been deactivated
            if (IsDeactivated())
            {
                // Mark the ID as Reactivated
                _pServer  = pServer;
                _dwState &= ~IDFLAG_DEACTIVATED;

                // Add the ID to the PID Table
                hr = gPIDTable.Add(this);                
            }

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            if (SUCCEEDED(hr))
            {
                // Reactivate stub manager
                if (_pStdID)
                    _pStdID->Reactivate(pServer);

                // Reactivate wrapper
                if(_pStdWrapper)
                   _pStdWrapper->Reactivate(pServer);
            }
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::NotifyOIDIsPinned   public
//
//  Synopsis:   Turns on the oid pin bit, and attempts to deregister
//              an oid unpin request if one is outstanding.  The std
//              marshal object calls this right before returning a
//              ORS_OID_PINNED status to the resolver.
//
//  History:    13-Mar-01   jsimmons     Created
//
//+-------------------------------------------------------------------
void CIDObject::NotifyOIDIsPinned()
{   
    ASSERT_LOCK_DONTCARE(gComLock);

    LOCK(gComLock);
	
    Win4Assert(InOIDTable());
    _dwState |= IDFLAG_OID_IS_PINNED; 

    // This may or may not succeed, it is just an optimization...
    gOIDTable.RemoveOIDUnpinRequest(this);

    UNLOCK(gComLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CIDObject::NotifyOIDIsUnpinned   public
//
//  Synopsis:   Turns off the oid pin bit and requests an oid unpin 
//              request if this idobject was previously pinned.
//
//  History:    13-Mar-01   jsimmons     Created
//
//+-------------------------------------------------------------------
void CIDObject::NotifyOIDIsUnpinned()
{
    ASSERT_LOCK_DONTCARE(gComLock);

    LOCK(gComLock);
	
    if (IsOIDPinned())
    {
        // If we are a pinned oid, then we ought to be
        // in the oid table.   Assert this is true:
        Win4Assert(InOIDTable());

        gOIDTable.AddOIDUnpinRequest(this);
        _dwState &= ~IDFLAG_OID_IS_PINNED; 
    }

    UNLOCK(gComLock);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given object pointer id
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
DWORD CPIDHashTable::HashNode(SHashChain *pPIDChain)
{
    CIDObject *pID = CIDObject::PIDChainToIDObject(pPIDChain);

    Win4Assert (pID && "Attempting to hash NULL CIDObject!");
    return (pID ? Hash(pID->GetServer(), pID->GetServerCtx()) : 0);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDHashTable::Compare
//
//  Synopsis:   Compares a object pointer id and a key.
//
//---------------------------------------------------------------------------
BOOL CPIDHashTable::Compare(const void *pv, SHashChain *pPIDChain, DWORD dwHash)
{
    CIDObject *pID = CIDObject::PIDChainToIDObject(pPIDChain);
    PIDData *pPIDData = (PIDData *) pv;

    Win4Assert (pID && "Attempting to compare NULL CIDObject!");
    if(pID && (pID->GetServer() == pPIDData->pServer &&
               pID->GetServerCtx() == pPIDData->pServerCtx))
       return(TRUE);

    return(FALSE);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Initialize
//
//  Synopsis:   Initailizes the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPIDTable::Initialize()
{
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Initailize\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Assert that table is not initialized
    Win4Assert(!s_fInitialized);

    // Initialize hash table
    s_PIDHashTbl.Initialize(s_PIDBuckets, &gComLock);

    // Initialize IDObjects
    CIDObject::Initialize();

    // Mark the state as initialized
    s_fInitialized = TRUE;

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Function:   CleanupIdentity
//
//  Synopsis:   Used for cleaning up entries inside the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CleanupIdentity(SHashChain *pNode)
{
    Win4Assert(!"CleanupIdentity got called");
    return;
}


//---------------------------------------------------------------------------
//
//  Function:   RemovePID
//
//  Synopsis:   Removes the object identity from the pointer id table
//              if the object belongs to current apartment
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
BOOL RemovePID(SHashChain *pPIDChain, void *pvData)
{
    ASSERT_LOCK_HELD(gComLock);
    CIDObject *pID = CIDObject::PIDChainToIDObject(pPIDChain);
    C_ASSERT(sizeof(APTID) == sizeof(ULONG));
    DWORD aptID = PtrToUlong(pvData);
    BOOL fRemove = FALSE;

	Win4Assert(pID && "Trying to RemovePID on a NULL IDObject");
    if(pID && (pID->GetAptID() == aptID))
    {
        // Sanity check
        Win4Assert(!pID->GetStdID() || !"Leaking stub managers");

        // Update state
        CStdWrapper* pWrapper = pID->GetWrapper();
        if (pWrapper)
            pWrapper->InternalAddRef();

        pID->RemovedFromPIDTable();
        fRemove = TRUE;
    }

    ASSERT_LOCK_HELD(gComLock);
    return(fRemove);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::ThreadCleanup
//
//  Synopsis:   Cleanup the pointer id table for the current apartment
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPIDTable::ThreadCleanup()
{
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::ThreadCleanup\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    DWORD aptID;

    // Cleanup for the thread only if the pointer id table
    // was initialized
    if(s_fInitialized)
    {
        ULONG ulSize, i;
        SHashChain *pPIDsRemoved[MAX_NODES_TO_REMOVE];
        CIDObject *pID;
        CStdWrapper *pWrapper;
        BOOL fDone = FALSE;

        // Initialize
        aptID = GetCurrentApartmentId();

        while(!fDone)
        {
            ulSize = MAX_NODES_TO_REMOVE;

            // Aquire lock
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Remove object identities belonging to this apartment
            fDone = s_PIDHashTbl.EnumAndRemove(RemovePID, (void *) LongToPtr(aptID),
                                               &ulSize, (void **) pPIDsRemoved);

            // Release lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            // Cleanup the returned IDs
            for(i = 0;i < ulSize; i++)
            {
                // Obtain the IDObject to be removed
                pID = CIDObject::PIDChainToIDObject(pPIDsRemoved[i]);
                Win4Assert(pID && "Removed a NULL IDObject from the hash table!");
                if (pID)
                {
                    pWrapper = pID->GetWrapper();
                    Win4Assert(pID->GetStdID() == NULL);

                    // Disconnect wrapper
                    if(pWrapper)
                    {
                        ContextDebugOut((DEB_ERROR,
                                         "Object at 0x%p still has [%x] outstanding "
                                         "connections\n", pWrapper->GetServer(),
                                         pWrapper->GetRefCount()-1));

                        pWrapper->Disconnect(NULL);
                        while(pWrapper->InternalRelease(NULL))
                            ;
                    }
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Cleanup
//
//  Synopsis:   Cleanup the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPIDTable::Cleanup()
{
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Cleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Assert that table is initialized
    Win4Assert(s_fInitialized);

    // Cleanup IDObjects
    CIDObject::Cleanup();

    // Cleanup hash table
    s_PIDHashTbl.Cleanup(CleanupIdentity);

    // Mark the state as initialized
    s_fInitialized = FALSE;

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Add
//
//  Synopsis:   Adds object identity into the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT CPIDTable::Add(CIDObject *pAddID)
{
    HRESULT hr = S_OK;
    ContextDebugOut((DEB_IDTABLE,
                     "CPIDTable::Add(ID:0x%x, pUnk:0x%p, Ctx:0x%p)\n",
                     pAddID, pAddID->GetServer(), pAddID->GetServerCtx()));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(pAddID);

    // Create PIDData on the stack
    PIDData desiredPID;
    desiredPID.pServer = pAddID->GetServer();
    desiredPID.pServerCtx = pAddID->GetServerCtx();

    // Obtain Hash value
    DWORD dwHash = s_PIDHashTbl.Hash(desiredPID.pServer, desiredPID.pServerCtx);

    // Obatin the IDObject in the table
    CIDObject *pExistingID = s_PIDHashTbl.Lookup(dwHash, &desiredPID);

    // If the object already exists in the table then we are trying to 
    // reactivate an active object
    if(NULL != pExistingID)
    {
        hr = E_INVALIDARG;
        Win4Assert(!"ID object already present");
    }


    if(SUCCEEDED(hr))
    {    
        // Add object identity to the Hash table
        s_PIDHashTbl.Add(dwHash, pAddID);
        pAddID->AddedToPIDTable();
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Add returning\n"));
    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Remove
//
//  Synopsis:   Removes given object identity from the pointer id table
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPIDTable::Remove(CIDObject *pRemoveID)
{
    ContextDebugOut((DEB_IDTABLE,
                     "CPIDTable::Remove(ID:0x%x, pUnk:0x%p, Ctx:0x%p)\n",
                     pRemoveID, pRemoveID->GetServer(), pRemoveID->GetServerCtx()));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(pRemoveID);
#if DBG==1
    // Create PIDData on the stack
    PIDData desiredPID;
    desiredPID.pServer = pRemoveID->GetServer();
    desiredPID.pServerCtx = pRemoveID->GetServerCtx();

    // Obtain Hash value
    DWORD dwHash = s_PIDHashTbl.Hash(desiredPID.pServer, desiredPID.pServerCtx);

    // Obatin the IDObject in the table
    CIDObject *pExistingID = s_PIDHashTbl.Lookup(dwHash, &desiredPID);

    // Sanity check
    Win4Assert(pExistingID == pRemoveID);
#endif

    // Remove the given IDObject from the table
    s_PIDHashTbl.Remove(pRemoveID);
    pRemoveID->RemovedFromPIDTable();

#if DBG==1
    // Check for duplicate entries

    // Obatin the IDObject in the table
    pExistingID = s_PIDHashTbl.Lookup(dwHash, &desiredPID);

    // Sanity check
    Win4Assert((NULL == pExistingID) || !"Duplicate ID entries present");
#endif

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Remove returning\n"));
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::Lookup
//
//  Synopsis:   Obtains object identity representing for the given pointer id
//              and context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CIDObject *CPIDTable::Lookup(IUnknown *pServer, CObjectContext *pServerCtx,
                             BOOL fAddRef)
{
    ContextDebugOut((DEB_IDTABLE,
                     "CPIDTable::Lookup(pUnk:0x%x, pCtx:0x%x, fAddRef:%x)\n",
                     pServer, pServerCtx, fAddRef));
    ASSERT_LOCK_HELD(gComLock);
    Win4Assert(pServer && pServerCtx);

    // Initialize
    PIDData desiredPID;
    desiredPID.pServer = pServer;
    desiredPID.pServerCtx = pServerCtx;

    // Obtain Hash value
    DWORD dwHash = s_PIDHashTbl.Hash(pServer, pServerCtx);
    CIDObject *pID = s_PIDHashTbl.Lookup(dwHash, &desiredPID);

    // AddRef the node before returning
    if(pID && fAddRef)
        pID->AddRef();

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::Lookup returning IDObject:0x%x\n",
                     pID));
    return(pID);
}


//---------------------------------------------------------------------------
//
//  Method:     CPIDTable::FindOrCreateIDObject
//
//  Synopsis:   returns the IDObject for the passed in pUnkServer. Creates it
//              if it does not already exist and fCreate is TRUE.
//              Returned pointer is AddRef'd and already in the gPIDTable.
//
//  Parameters: [pUnkServer] - controlling IUnknown of the server object
//              [pServerCtx] - context in which the object lives
//              [fCreate]    - TRUE: create the IDObject if it does not exist
//              [dwAptId]    - ID of apartment
//              [ppID]       - where to return the CIDObject ptr, AddRef'd.
//
//  History:    06-Jan-99   Rickhi      Created from other pieces.
//
//---------------------------------------------------------------------------
HRESULT CPIDTable::FindOrCreateIDObject(IUnknown *pUnkServer,
                                        CObjectContext *pServerCtx,
                                        BOOL fCreate, APTID dwAptId,
                                        CIDObject **ppID)
{
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::FindOrCreateIDObject pUnkServer:%x\n",
                    pUnkServer));
    ASSERT_LOCK_HELD(gComLock);

    // Lookup IDObject for the server object
    HRESULT hr = S_OK;
    *ppID = gPIDTable.Lookup(pUnkServer, pServerCtx, TRUE /* fAddRef */);

    if (*ppID == NULL)
    {
        // Not found.
        hr = CO_E_OBJNOTREG;

        if (fCreate)
        {
            // create the object identity representing
            // the server object and add it to the table.
            hr = E_OUTOFMEMORY;  // assume OOM

            *ppID = new CIDObject(pUnkServer, pServerCtx, dwAptId,
                                  IDFLAG_SERVER);
            if (*ppID)
            {
                // created OK, add it to the table
                Add(*ppID);
                hr = S_OK;
            }
        }
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "CPIDTable::FindOrCreateIDObject hr:%x pIDObject:%x\n",
                    hr, *ppID));
    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     CIDObject::GetOrCreateWrapper
//
//  Synopsis:   returns the wrapper object for this CIDObject. Creates it if
//              it does not already exist. Returned pointer is
//              InternalAddRef'd.
//
//  Parameters: [fCreate] - TRUE: create the wrapper if it does not exist
//              [dwFlags] - creation flags (from IDLF_*).
//              [ppWrapper] - where to return the wrapper ptr.
//
//  History:    06-Jan-99   Rickhi      Created from various pieces
//
//---------------------------------------------------------------------------
HRESULT CIDObject::GetOrCreateWrapper(BOOL fCreate, DWORD dwFlags,
                                      CStdWrapper **ppWrapper)
{
    ContextDebugOut((DEB_IDTABLE,"CIDObject::GetOrCreateWrapper this:%x\n", this));
    ASSERT_LOCK_HELD(gComLock);

    HRESULT hr = S_OK;
    *ppWrapper = _pStdWrapper;

    if (*ppWrapper == NULL)
    {
        if (fCreate)
        {
            // Create a new wrapper for the server object
            // Fill in the wrapper flags
            DWORD dwState = 0;
            if ((dwFlags & IDLF_NOIEC)  || (_pStdID && !_pStdID->GetIEC()))
                dwState |= WRAPPERFLAG_NOIEC;
            if ((dwFlags & IDLF_NOPING) || (_pStdID && _pStdID->IsPinged() == FALSE))
                dwState |= WRAPPERFLAG_NOPING;
            
            hr = E_OUTOFMEMORY; // assume OOM
            _pStdWrapper = new CStdWrapper(_pServer, dwState, this);
            
            if (_pStdWrapper != NULL)
            {
                *ppWrapper = _pStdWrapper;
                hr = S_OK;
            }
        }
        else
        {
            // We don't have a wrapper and we're not allowed to create
            // one.  Return CO_E_OBJNOTCONNECTED.
            hr = CO_E_OBJNOTCONNECTED;
        }
    }
    else
    {
        hr = S_OK;
        (*ppWrapper)->InternalAddRef();
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE,"CIDObject::GetOrCreateWrapper hr:%x pWrapper:%x\n",
                    hr, *ppWrapper));
    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CIDObject::GetOrCreateStdID
//
//  Synopsis:   returns the StdID object for this CIDObject. Creates it if
//              it does not already exist. Returned pointer is either
//              AddRef'd or IncStrongCnt'd.
//
//  Parameters: [fCreate] - TRUE: create the stdid if it does not exist
//              [dwFlags] - creation flags (from IDLF_*).
//              [ppStdId] - where to return the StdId ptr.
//
//  History:    06-Jan-99   Rickhi      Created from various pieces
//
//---------------------------------------------------------------------------
HRESULT CIDObject::GetOrCreateStdID(BOOL fCreate, DWORD dwFlags,
                                    CStdIdentity **ppStdID)
{
    ContextDebugOut((DEB_IDTABLE,"CIDObject::GetOrCreateStdID this:%x\n", this));
    ASSERT_LOCK_HELD(gComLock);
    Win4Assert(_pServerCtx == GetCurrentContext());

    BOOL          fStdIdCreated = FALSE;
    CStdIdentity *pCleanupStdID = NULL;
    CPolicySet   *pPS           = NULL;

    // Before we release gComLock, lock this object so that it will
    // not get disconnected before we complete our business.
    IncLockCount();

    HRESULT hr = CO_E_OBJNOTCONNECTED;
    CStdIdentity *pStdID = _pStdID;

    if (pStdID == NULL && (dwFlags & IDLF_CREATE))
    {
        // no StdID exists yet for this object, so go create one now.

        // Release the lock while doing this as this will call into
        // app code and can take a long time.
        UNLOCK(gComLock);
        ASSERT_LOCK_NOT_HELD(gComLock);

        // Check for non empty context
        hr = S_OK;
        if (_pServerCtx != GetEmptyContext())
        {
            // Obtain the policy set between NULL client context and
            // current server context
            BOOL fCreate = TRUE;
            hr = ObtainPolicySet(NULL, _pServerCtx, PSFLAG_STUBSIDE,
                                 &fCreate, &pPS);
        }

        if (SUCCEEDED(hr))
        {
            // Set the creation flags based on what was passed in and
            // what has previously been used for the wrapper (if any).
            DWORD dwWrapFlags = GetWrapper() ? GetWrapper()->GetState() : 0;

            if (dwWrapFlags & WRAPPERFLAG_NOPING)
            {
                // the object does not use pinging.
                dwFlags |= IDLF_NOPING;
            }

            DWORD dwStdIdFlags = STDID_SERVER;
            if (dwFlags & IDLF_FTM)
            {
                // the object aggregates the FTM, set a flag in the StdId.
                dwStdIdFlags |= STDID_FTM;
            }

            if ((dwFlags & IDLF_NOIEC) || (dwWrapFlags & WRAPPERFLAG_NOIEC))
            {
                // the object should not use IExternalConnection, set a flag
                // in the StdId.
                dwStdIdFlags |= STDID_NOIEC;
            }

            // Create a StdID for the server. Assume OOM.
            hr = E_OUTOFMEMORY;
            IUnknown *pUnkID;
            BOOL fSuccess = FALSE;
            pStdID = new CStdIdentity(dwStdIdFlags, _aptID, NULL,
                                      _pServer, &pUnkID, &fSuccess);

            MOID moid;

            if (pStdID && fSuccess == FALSE)
            {
                delete pStdID;
                pStdID = NULL;
            }
            
            if (pStdID)
            {
                // Obtain OID for the object
                if (dwFlags & IDLF_NOPING)
                {
                    // object wont be pinged so dont bother using a
                    // pre-registered oid, just use a reserved one. Save
                    // the pre-registered ones for pinged objects
                    hr = gResolver.ServerGetReservedMOID(&moid);
                }
                else
                {
                    // object will be pinged, so get a pre-registered OID.
                    // Note this could yield if we have to pre-register
                    // more OIDs so do this before checking the table again.
                    hr = GetPreRegMOID(&moid);
                }
            }

            // Reacquire the lock
            LOCK(gComLock);
            ASSERT_LOCK_HELD(gComLock);

            if (SUCCEEDED(hr))
            {
                // while we released the lock, another thread could have
                // come along and created the StdId for this object so
                // we need to check again.
                if (_pStdID == NULL)
                {
                    // still NULL so use the StdID we created.
                    fStdIdCreated = TRUE;

                    // Set object identity inside StdID. This will
                    // AddRef the IDObject.
                    pStdID->SetIDObject(this);

                    // Set our _pStdID ptr
                    SetStdID(pStdID);

                    // Establish the OID for the object, this adds the OID
                    // to the gOIDTable.
                    pStdID->SetOID(moid);

                    // need to set the marshal time of the object to
                    // ensure that it does not run down before first
                    // marshal is complete
                    pStdID->SetMarshalTime();

                    // Save ping status for the object
                    if (dwFlags & IDLF_NOPING)
                    {
                        pStdID->SetNoPing();
                    }

                    // Set policy set inside the StdID
                    if (pPS)
                    {
                        pStdID->SetServerPolicySet(pPS);
                        pPS = NULL;
                    }
                }
                else
                {
                    // Release the newly created StdID and use the one obtained
                    // from the table.
                    pCleanupStdID = pStdID;
                    pStdID = _pStdID;

                    if (!(dwFlags & IDLF_NOPING))
                    {
                        // Also free the OID we allocated.
                        FreePreRegMOID(moid);
                    }
                }
            }
            else
            {
                // Could not allocate a StdID or an OID. Release the newly created
                // StdID (if any).
                pCleanupStdID = pStdID;
                pStdID = NULL;
            }
        }
        else
        {
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);
        }
    }

    if (pStdID)
    {
        // AddRef the StdID being returned based on the flags
        // passed in.
        hr = S_OK;

        if (dwFlags & IDLF_STRONG)
        {
            pStdID->IncStrongCnt();
            if (fStdIdCreated)
                pStdID->Release();
        }
        else if (!fStdIdCreated)
        {
            pStdID->AddRef();
        }
    }

    if (pCleanupStdID || pPS)
    {
        // need to release the StdID or PolicySet we created.
        // Release the lock to do this since it will call app code.
        UNLOCK(gComLock);
        ASSERT_LOCK_NOT_HELD(gComLock);

        if (pCleanupStdID)
            pCleanupStdID->Release();

        if (pPS)
            pPS->Release();

        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);
    }

    // allow disconnects back in
    DecLockCount();

    // Initialize return parameter
    *ppStdID = pStdID;

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE,"CIDObject::GetOrCreateStdID this:%x hr:%x pStdID:%x\n",
              this, hr, *ppStdID));
    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     COIDHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given object pointer id
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
DWORD COIDHashTable::HashNode(SHashChain *pOIDChain)
{
    CIDObject *pID = CIDObject::OIDChainToIDObject(pOIDChain);

	Win4Assert (pID && "Attempting to hash NULL CIDObject");
	return (pID ? Hash(pID->GetOID(), pID->GetAptID()) : 0);
}


//---------------------------------------------------------------------------
//
//  Method:     COIDHashTable::Compare
//
//  Synopsis:   Compares a object OIDand a key.
//
//---------------------------------------------------------------------------
BOOL COIDHashTable::Compare(const void *pv, SHashChain *pOIDChain, DWORD dwHash)
{
    CIDObject *pID = CIDObject::OIDChainToIDObject(pOIDChain);
    OIDData *pOIDData = (OIDData *) pv;

	Win4Assert(pID && "Attempting to compare NULL CIDObject");
    if(pID && IsEqualGUID(pID->GetOID(), *pOIDData->pmoid) &&
       pID->GetAptID() == pOIDData->aptID)
       return(TRUE);

    return(FALSE);
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Initialize
//
//  Synopsis:   Initailizes the OIDtable
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::Initialize()
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Initailize\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Assert that table is not initialized
    Win4Assert(!s_fInitialized);

    // Initialize hash table
    s_OIDHashTbl.Initialize(s_OIDBuckets, &gComLock);

    // Initialize IDObjects
    CIDObject::Initialize();

    // Initialize oid unpin request list head
    s_OIDUnpinRequests.pPrev = &s_OIDUnpinRequests;
    s_OIDUnpinRequests.pNext = &s_OIDUnpinRequests;

    // Mark the state as initialized
    s_fInitialized = TRUE;

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Function:   RemoveOID
//
//  Synopsis:   Removes the object identity from the OIDtable
//              if the object belongs to current apartment
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
BOOL RemoveOID(SHashChain *pOIDChain, void *pvData)
{
    ASSERT_LOCK_HELD(gComLock);
    CIDObject *pID = CIDObject::OIDChainToIDObject(pOIDChain);
    C_ASSERT(sizeof(APTID) == sizeof(ULONG));
    DWORD aptID = PtrToUlong( pvData);
    BOOL fRemove = FALSE;

    Win4Assert(pID && "RemoveOID: Trying to remove NULL CIDObject");
    if (pID && (pID->GetAptID() == aptID))
    {
        // Remove from oid unpin req list if necessary
        COIDTable::SpecialCleanup(pID);

        // Update state
        pID->GetStdID()->AddRef();
        pID->GetStdID()->IgnoreOID();
        pID->RemovedFromOIDTable();
        fRemove = TRUE;
    }

    ASSERT_LOCK_HELD(gComLock);
    return(fRemove);
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::ThreadCleanup
//
//  Synopsis:   Cleanup the OIDtable for the current apartment
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::ThreadCleanup()
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::ThreadCleanup\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    DWORD aptID;

    // Cleanup for the thread only if the OIDtable
    // was initialized
    if(s_fInitialized)
    {
        ULONG ulSize, i;
        SHashChain *pOIDsRemoved[MAX_NODES_TO_REMOVE];
        CIDObject *pID;
        CStdIdentity *pStdID;
        BOOL fDone = FALSE;

        // Initialize
        aptID = GetCurrentApartmentId();

        while(!fDone)
        {
            ulSize = MAX_NODES_TO_REMOVE;

            // Aquire lock
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Remove object identities belonging to this apartment
            fDone = s_OIDHashTbl.EnumAndRemove(RemoveOID, (void *) LongToPtr(aptID),
                                               &ulSize, (void **) pOIDsRemoved);

            // Release lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            // Cleanup the returned IDs
            for(i = 0;i < ulSize; i++)
            {
                // Obtain the IDObject to be removed
                pID = CIDObject::OIDChainToIDObject(pOIDsRemoved[i]);
                if (!pID) continue;

                pStdID = pID->GetStdID();

                // Disconnect StdID
                if(pStdID)
                {
                    // Dump StdID
                    ComDebOut((DEB_ERROR,
                        "Object [%s] at 0x%p still has [%x] connections\n",
                         pStdID->IsClient() ? "CLIENT" : "SERVER",
                         pStdID->GetServer(), pStdID->GetRC()));
                    pStdID->DbgDumpInterfaceList();

#if DBG==1
                    BOOL fAggregated = pStdID->IsAggregated();
                    ULONG cRefs = pStdID->GetRC();
#endif
                    // Disconnect
                    pStdID->DisconnectAndRelease(DISCTYPE_UNINIT);
#if DBG==1
                    if(fAggregated==FALSE && cRefs!=1)
                        ComDebOut((DEB_ERROR,
                                   "The above object also has "
                                   "outstanding references on it\n"
                                   "\t\t\tProbable cause: Not revoking "
                                   "it from GIP Table\n"));
#endif
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Cleanup
//
//  Synopsis:   Cleanup the OIDtable
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::Cleanup()
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Cleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Assert that table is initialized
    Win4Assert(s_fInitialized);

    // Cleanup IDObjects
    CIDObject::Cleanup();

    // Cleanup hash table
    s_OIDHashTbl.Cleanup(CleanupIdentity);

    // The oid unpin request table should be empty here (either normally or
    // cleaned up when the various apartments went away).
    Win4Assert((s_OIDUnpinRequests.pNext == &s_OIDUnpinRequests) && 
               (s_OIDUnpinRequests.pPrev == &s_OIDUnpinRequests) &&
               (s_UnpinReqsPending == 0));

    // Mark the state as initialized
    s_fInitialized = FALSE;

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Add
//
//  Synopsis:   Adds object identity into the OIDtable
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::Add(CIDObject *pAddID)
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Add\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(pAddID);
#if DBG==1
    // Create OIDData on the stack
    OIDData desiredOID;
    desiredOID.pmoid = &pAddID->GetOID();
    desiredOID.aptID = pAddID->GetAptID();

    // Obtain Hash value
    DWORD dwHash2 = s_OIDHashTbl.Hash(pAddID->GetOID(), pAddID->GetAptID());

    // Obatin the IDObject in the table
    CIDObject *pExistingID = s_OIDHashTbl.Lookup(dwHash2, &desiredOID);

    // Sanity check
    Win4Assert(pExistingID==NULL || !"ID already present in the OID Table");
#endif

    // Obtain Hash value
    DWORD dwHash = s_OIDHashTbl.Hash(pAddID->GetOID(), pAddID->GetAptID());

    // Add object identity to the Hash table
    s_OIDHashTbl.Add(dwHash, pAddID);
    pAddID->AddedToOIDTable();
    if(pAddID->IsServer())
    {
        // Increment count of exported server objects
        InterlockedIncrement(&gServerOIDCount);
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Add returning"));
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Remove
//
//  Synopsis:   Removes given object identity from the OIDtable
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
void COIDTable::Remove(CIDObject *pRemoveID)
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Remove\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(pRemoveID);
#if DBG==1
    // Create OIDData on the stack
    OIDData desiredOID;
    desiredOID.pmoid = &pRemoveID->GetOID();
    desiredOID.aptID = pRemoveID->GetAptID();

    // Obtain Hash value
    DWORD dwHash = s_OIDHashTbl.Hash(pRemoveID->GetOID(), pRemoveID->GetAptID());

    // Obatin the IDObject in the table
    CIDObject *pExistingID = s_OIDHashTbl.Lookup(dwHash, &desiredOID);

    // Sanity check
    Win4Assert(pExistingID == pRemoveID);
#endif

    // Remove the given IDObject from the table
    s_OIDHashTbl.Remove(pRemoveID);
    pRemoveID->RemovedFromOIDTable();
    if(pRemoveID->IsServer())
    {
        // Decrement count of exported server objects
        InterlockedDecrement(&gServerOIDCount);
    }

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Remove returning\n"));
    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::AddOIDUnpinRequest
//
//  Synopsis:   Adds the specified identity object to the list of oids that
//              need to be unpinned.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::AddOIDUnpinRequest(CIDObject *pIDObject)
{
    DWORD dwOUPState;

    ASSERT_LOCK_HELD(gComLock);
    
    // To avoid having to store a structure in the oid table (idobject ptr
    // + state bits), we borrow some state space from the id object.  The id
    // object itself does not depend on this state, and never looks at it.
    dwOUPState = pIDObject->GetOIDUnpinReqState();
    if (dwOUPState & OIDUPREQ_INOUPLIST)
    {
        // It's already in the unpin list.

        if (!(dwOUPState & OIDUPREQ_PENDING))
        {
            // If not pending, then should already be requested
            Win4Assert(dwOUPState & OIDUPREQ_UNPIN_REQUESTED);
        }

        // Turn on the requested flag
        dwOUPState |= OIDUPREQ_UNPIN_REQUESTED;

        // Remember new setting
        pIDObject->SetOIDUnpinReqState(dwOUPState);
    }
    else
    {
        DWORD dwNewOUPState;

        Win4Assert(dwOUPState == OIDUPREQ_NO_STATE); // if not in list should have no state

        // Add it to the end of the unpin list.   
        SHashChain* pNew = pIDObject->IDObjectToOIDUPReqChain();
        
        AddToOUPReqList(pNew);

        dwNewOUPState = (OIDUPREQ_INOUPLIST | OIDUPREQ_UNPIN_REQUESTED);
		
        pIDObject->SetOIDUnpinReqState(dwNewOUPState);

        s_UnpinReqsPending++;
    }

    ASSERT_LOCK_HELD(gComLock);
    
    // Notify the roid table that we have some work for it to
    // do on its worker thread. This is a perf thing to avoid
    // having our own worker thread.
    gROIDTbl.NotifyWorkWaiting();

    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::RemoveOIDUnpinRequest
//
//  Synopsis:   Removes the specified identity object from the list of oids that
//              need to be unpinned.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::RemoveOIDUnpinRequest(CIDObject *pIDObject)
{
    ASSERT_LOCK_HELD(gComLock);
    
    DWORD dwOUPState = pIDObject->GetOIDUnpinReqState();

    if (dwOUPState & OIDUPREQ_INOUPLIST)
    {
        // Okay, this id object has previously requested an unpin.  Find
        // out if we can remove it immediately, or if the worker thread
        // has picked it up in the meantime.
        if (!(dwOUPState & OIDUPREQ_PENDING))
        {
            // Not yet picked up by worker thread.  Just remove it.
            Win4Assert(dwOUPState & OIDUPREQ_UNPIN_REQUESTED);

            RemoveFromOUPReqList(pIDObject->IDObjectToOIDUPReqChain());

            // Reset oup state to nothing
            pIDObject->SetOIDUnpinReqState(OIDUPREQ_NO_STATE);

            s_UnpinReqsPending--;
        }
        else
        {
            // Since the worker thread got it, we're stuck.  Just leave it.  The
            // worst that can happen is extra rundown calls.
        }
    }

    ASSERT_LOCK_HELD(gComLock);        

    return;
}
	
//---------------------------------------------------------------------------
//
//  Method:     COIDTable::AddToOUPReqList, RemoveFromOUPReqList
//
//  Synopsis:   Adds\removes the specified list node to the oid unpin req list.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::AddToOUPReqList(SHashChain* pNewRequest)
{
    ASSERT_LOCK_HELD(gComLock);

    // Assert new request is chained to itself
    Win4Assert(pNewRequest == pNewRequest->pNext);
    Win4Assert(pNewRequest == pNewRequest->pPrev);
	
    // Add it to the end of the list
    pNewRequest->pPrev = &s_OIDUnpinRequests;
    s_OIDUnpinRequests.pNext->pPrev = pNewRequest;
    pNewRequest->pNext = s_OIDUnpinRequests.pNext;
    s_OIDUnpinRequests.pNext = pNewRequest;
}

void COIDTable::RemoveFromOUPReqList(SHashChain* pRequest)
{
    ASSERT_LOCK_HELD(gComLock);
	
    // Assert new request is not chained to itself
    Win4Assert(pRequest != pRequest->pNext);
    Win4Assert(pRequest != pRequest->pPrev);
    
    pRequest->pPrev->pNext = pRequest->pNext;
    pRequest->pNext->pPrev = pRequest->pPrev;
    pRequest->pPrev = pRequest;
    pRequest->pNext = pRequest;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::GetServerOidsToUnpin
//
//  Synopsis:   Fills in the supplied array with up to *pcSOidsToUnpin oids to
//              unpin.  Updates *pcSOidsToUnpin with the actual # filled in.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::GetServerOidsToUnpin(OID* pSOidsToUnpin, ULONG* pcSOidsToUnpin)
{
    Win4Assert(pSOidsToUnpin && pcSOidsToUnpin);

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    ULONG cSOidsAdded = 0;
    SHashChain* pNext = s_OIDUnpinRequests.pNext;
    while (pNext != &s_OIDUnpinRequests && (cSOidsAdded < *pcSOidsToUnpin))
    {
        CIDObject* pIDObject;
        DWORD dwOUPState;

        pIDObject = CIDObject::OIDUnpinReqChainToIDObject(pNext);
        Win4Assert(pIDObject);
        
        dwOUPState = pIDObject->GetOIDUnpinReqState();

        // Assert in list and unpin not already pending
        Win4Assert((dwOUPState & OIDUPREQ_INOUPLIST) && !(dwOUPState & OIDUPREQ_PENDING));

        // If unpin requested (almost always will be) add it to the [out] array
        if (dwOUPState & OIDUPREQ_UNPIN_REQUESTED)
        {
            OIDFromMOID(pIDObject->GetOID(), &(pSOidsToUnpin[cSOidsAdded]));

            // Turn off the requested bit, turn on the pending bit
            dwOUPState &= ~OIDUPREQ_UNPIN_REQUESTED;
            dwOUPState |= OIDUPREQ_PENDING;

            pIDObject->SetOIDUnpinReqState(dwOUPState);

            cSOidsAdded++;
        }
		
        pNext = pNext->pNext;
        Win4Assert(pNext);
    }
    
    *pcSOidsToUnpin = cSOidsAdded;

    ASSERT_LOCK_HELD(gComLock);
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
    
    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::NotifyUnpinOutcome
//
//  Synopsis:   This gets called from the worker thread after a set of oid
//              unpin requests has been sent to the SCM.   The outcome is 
//              considered successful if the call returned a success code.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::NotifyUnpinOutcome(BOOL fOutcome) 
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    // Walk the list of unpin requests looking for ones that are currently 
    // pending (ie, we gave them to the worker thread to be unpinned).
    SHashChain* pCurrent = s_OIDUnpinRequests.pNext;
    while (pCurrent != &s_OIDUnpinRequests)
    {
        SHashChain* pNext = pCurrent->pNext;
        CIDObject* pIDObject;
        DWORD dwOUPState;

        pIDObject = CIDObject::OIDUnpinReqChainToIDObject(pCurrent);
        Win4Assert(pIDObject);

        dwOUPState = pIDObject->GetOIDUnpinReqState();

        // Assert in list
        Win4Assert(dwOUPState & OIDUPREQ_INOUPLIST);
        if (dwOUPState & OIDUPREQ_PENDING)
        {
            // If outcome succeeded, and another unpin request was not
            // queued while the worker thread was doing its thing, then
            // remove the request.  Otherwise keep it.
            if (fOutcome && !(dwOUPState & OIDUPREQ_UNPIN_REQUESTED))
            {
                pIDObject->SetOIDUnpinReqState(OIDUPREQ_NO_STATE);

                RemoveFromOUPReqList(pIDObject->IDObjectToOIDUPReqChain());

                s_UnpinReqsPending--;
            }
            else
            {
                // Either outcome was unclear, or another unpin request was
                // sent while we were pending.   Leave it in the list.

                // Optimization: we could add a "cancellation" bit, that if requested
                // while the unpin was pending, would allow us to remove the
                // request here instead of keeping it.  Probably not worth it.
                dwOUPState &= ~OIDUPREQ_PENDING;
                dwOUPState |= OIDUPREQ_UNPIN_REQUESTED;
                pIDObject->SetOIDUnpinReqState(dwOUPState);
            }
        }
        else
        {
            // This is a new request, added after we gave the last batch
            // to the worker thread.  Just assert that an unpin has been
            // requested for this oid.
            Win4Assert(dwOUPState & OIDUPREQ_UNPIN_REQUESTED);
        }
        
        pCurrent = pNext;
    }

    ASSERT_LOCK_HELD(gComLock);
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::SpecialCleanup
//
//  Synopsis:   This is a special function called during thread\apt cleanup,
//              and when an idobject is destructed. It is used to cleanup 
//              oids\idobjects that are being orphaned in the oid unpin request 
//              at that time.
//
//  History:    13-Mar-01    JSimmons    Created
//
//---------------------------------------------------------------------------
void COIDTable::SpecialCleanup(CIDObject* pIDObject)
{
    ASSERT_LOCK_HELD(gComLock);

    DWORD dwOUPState = pIDObject->GetOIDUnpinReqState();
    if (dwOUPState & OIDUPREQ_INOUPLIST)
    {
        // Note that even if an unpin request is pending for this oid on
        // the worker thread, that's ok - the worker thread just won't
        // find this oid during its post-call cleanup work.
        SHashChain* pChain = pIDObject->IDObjectToOIDUPReqChain();
        RemoveFromOUPReqList(pChain);
        pIDObject->SetOIDUnpinReqState(OIDUPREQ_NO_STATE);
        
        s_UnpinReqsPending--;
    }
    return;
}

//---------------------------------------------------------------------------
//
//  Method:     COIDTable::Lookup
//
//  Synopsis:   Obtains object identity representing for the given pointer id
//              and context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CIDObject *COIDTable::Lookup(const MOID &roid, APTID aptID)
{
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Lookup\n"));
    ASSERT_LOCK_HELD(gComLock);

    CIDObject *pID;
    DWORD dwHash;

    // Initialize
    OIDData desiredOID;
    desiredOID.pmoid = &roid;
    desiredOID.aptID = aptID;

    // Obtain Hash value
    dwHash = s_OIDHashTbl.Hash(roid, aptID);
    pID = s_OIDHashTbl.Lookup(dwHash, &desiredOID);

    // AddRef the node before returning
    if(pID)
        pID->AddRef();

    ASSERT_LOCK_HELD(gComLock);
    ContextDebugOut((DEB_IDTABLE, "COIDTable::Lookup returning IDObject:0x%x\n",
                     pID));
    return(pID);
}

//---------------------------------------------------------------------------
//
//  Method:     FreeSurrogateIfNecessary
//
//  Synopsis:   Start shutdown process of surrogate if (1) this is a
//              surrogate process; (2) there is no more outside ref counts.
//              We can't do this in COIDTable::Remove() because there would
//              be race conditions with releasing last server obj ref, see
//              CStdMarshal::Disconnect() in marshal.cxx.
//
//  History:    16-Nov-98   RongC      Created
//
//---------------------------------------------------------------------------
INTERNAL_(void) FreeSurrogateIfNecessary(void)
{
    // Let's see if this is a surrogate process.  If not, get out
    CSurrogateActivator* pSurrAct = CSurrogateActivator::GetSurrogateActivator();

    if ((pSurrAct == NULL) &&
        !CoIsSurrogateProcess())
        return;

    // for surrogates, we need to detect when there are no clients
    // using servers in the surrogate process -- we rely on the
    // fact that the OIDTable must be empty when there are no clients
    if(gServerOIDCount == 0)
    {
        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);
        if(gServerOIDCount == 0)      // Double check just to be sure
        {
            (void)CCOMSurrogate::FreeSurrogate();
        }
        UNLOCK(gComLock);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\locks.cxx ===
//+-------------------------------------------------------------------
//
//  File:       locks.cxx
//
//  Contents:   functions used in DBG builds to validate the lock state.
//
//  History:    20-Feb-95   Rickhi      Created
//              20-Aug-96   Mattsmit    Functionality moved to 
//                                      OleStaticLock class
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <locks.hxx>

COleStaticMutexSem  gComLock(TRUE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\ipmrshl.cxx ===
//+-------------------------------------------------------------------
//
//  File:       ipmrshl.cpp
//
//  Contents:   Code the implements the standard free thread in process
//              marshaler.
//
//  Classes:    CFreeMarshaler
//              CFmCtrlUnknown
//
//  Functions:  CoCreateFreeThreadedMarshaler
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <stdid.hxx>

#include    "apcompat.hxx"

//+-------------------------------------------------------------------
//
//  Class:    CFreeMarshaler
//
//  Synopsis: Generic marshaling class
//
//  Methods:  IUnknown
//            IMarshal
//
//  History:  15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class CFreeMarshaler : public IMarshal, public CPrivAlloc
{
public:
                        CFreeMarshaler(IUnknown *punk);

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

                        // IMarshal Interface
    STDMETHODIMP        GetUnmarshalClass(
                            REFIID riid,
                            void *pv,
                            DWORD dwDestContext,
                            void *pvDestContext,
                            DWORD mshlflags,
                            CLSID *pCid);

    STDMETHODIMP        GetMarshalSizeMax(
                            REFIID riid,
                            void *pv,
                            DWORD dwDestContext,
                            void *pvDestContext,
                            DWORD mshlflags,
                            DWORD *pSize);

    STDMETHODIMP        MarshalInterface(
                            IStream __RPC_FAR *pStm,
                            REFIID riid,
                            void *pv,
                            DWORD dwDestContext,
                            void *pvDestContext,
                            DWORD mshlflags);

    STDMETHODIMP        UnmarshalInterface(
                            IStream *pStm,
                            REFIID riid,
                            void **ppv);

    STDMETHODIMP        ReleaseMarshalData(IStream *pStm);

    STDMETHODIMP        DisconnectObject(DWORD dwReserved);

private:
    STDMETHODIMP        InitSecret   (void);

    friend class CFmCtrlUnknown;
	
    IUnknown *_punkCtrl;                           // Server object
	
    static BYTE               _SecretBlock[16];    // A random secret block to keep people 
                                                   // from tricking us into unmarshalling 
                                                   // raw pointers out of process.
    static BOOL               _fSecretInit;        // Whether or not the secret has been 
                                                   // filled.
    static COleStaticMutexSem _SecretLock;         // Prevent races on block init
};

BOOL               CFreeMarshaler::_fSecretInit = FALSE;
BYTE               CFreeMarshaler::_SecretBlock[16];
COleStaticMutexSem CFreeMarshaler::_SecretLock;


//+-------------------------------------------------------------------
//
//  Class:    CFmCtrlUnknown
//
//  Synopsis: Controlling IUnknown for generic marshaling class.
//
//  Methods:  IUnknown
//            IMarshal
//
//  History:  15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class CFmCtrlUnknown : public IUnknown, public CPrivAlloc
{
                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void **ppv);

    STDMETHODIMP_(ULONG) AddRef(void);

    STDMETHODIMP_(ULONG) Release(void);

private:

    friend HRESULT      CFreeThreadedMarshalerCF_CreateInstance(
                                                IUnknown *punkOuter,
                                                REFIID riid,
                                                void** ppv);


    friend HRESULT      GetInProcFreeMarshaler(IMarshal **ppIM);

                        CFmCtrlUnknown(void);

                        ~CFmCtrlUnknown(void);

    CFreeMarshaler *    _pfm;

    ULONG               _cRefs;
};


//+-------------------------------------------------------------------
//
//  Function:   CFreeThreadedMarshalerCF_CreateInstance, private
//
//  Synopsis:   CreateInstance method used by the standard class factory for the
//              free threaded marshaler, i.e., for CLSID_InProcFreeMarshaler
//
//  Arguments:  [punkOuter] - controlling unknown
//              [riid] - IID asked for
//              [ppunkMarshal] - controlling unknown for marshaler.
//
//  Returns:    NOERROR
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              E_NOINTERFACE
//
//  History:    11-Mar-98  SatishT  Created
//
//--------------------------------------------------------------------

HRESULT CFreeThreadedMarshalerCF_CreateInstance(IUnknown *punkOuter, REFIID riid, void** ppv)
{
    HRESULT hr = E_INVALIDARG;

    IUnknown *pUnk;

    // Validate the parameters
    if (((punkOuter == NULL) || IsValidInterface(punkOuter))
        && IsValidPtrOut(ppv, sizeof(void *)))
    {
        // Assume failure
        pUnk = NULL;

        hr = E_OUTOFMEMORY;

        // Allocate new free marshal object
        CFmCtrlUnknown *pfmc = new CFmCtrlUnknown();

        if (pfmc != NULL)
        {
            if (punkOuter == NULL)
            {
                // Caller wants a non-aggreagated object
                punkOuter = pfmc;
            }

            // Initialize the pointer
            pfmc->_pfm = new CFreeMarshaler(punkOuter);

            if (pfmc->_pfm != NULL)
            {
                pUnk = pfmc;
                hr = S_OK;
            }
            else
            {
                delete pfmc;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pUnk->QueryInterface(riid,ppv);
        pUnk->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoCreateFreeThreadedMarshaler, public
//
//  Synopsis:   Create the controlling unknown for the marshaler
//
//  Arguments:  [punkOuter] - controlling unknown
//              [ppunkMarshal] - controlling unknown for marshaler.
//
//  Returns:    NOERROR
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
HRESULT CoCreateFreeThreadedMarshaler(
    IUnknown *punkOuter,
    IUnknown **ppunkMarshal)
{
    return CFreeThreadedMarshalerCF_CreateInstance(
                                            punkOuter,
                                            IID_IUnknown,
                                            (LPVOID*)ppunkMarshal);
}



//+-------------------------------------------------------------------
//
//  Function:   GetInProcFreeMarshaler, public
//
//  Synopsis:   Create the controlling unknown for the marshaler
//
//  Arguments:  [ppIM] - where to put inproc marshaler
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
HRESULT GetInProcFreeMarshaler(IMarshal **ppIM)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Allocate new free marshal object
    CFmCtrlUnknown *pfmc = new CFmCtrlUnknown();

    if (pfmc != NULL)
    {
        // Initialize the pointer
        pfmc->_pfm = new CFreeMarshaler(pfmc);

        if (pfmc->_pfm != NULL)
        {
            *ppIM = pfmc->_pfm;
            hr = S_OK;
        }
        else
        {
            delete pfmc;
        }
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::CFmCtrlUnknown
//
//  Synopsis:   The constructor for controling IUnknown of free marshaler
//
//  Arguments:  None
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
CFmCtrlUnknown::CFmCtrlUnknown(void) : _cRefs(1), _pfm(NULL)
{
    // Header does all the work.
}




//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::~CFmCtrlUnknown
//
//  Synopsis:   The destructor for controling IUnknown of free marshaler
//
//  Arguments:  None
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
CFmCtrlUnknown::~CFmCtrlUnknown(void)
{
    delete _pfm;
}




//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::QueryInterface
//
//  Returns:    S_OK
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFmCtrlUnknown::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;

    if (IsEqualGUID(iid, IID_IUnknown))
    {
        *ppv = this;
        AddRef();
        hr = S_OK;
    }
    else if (IsEqualGUID(iid, IID_IMarshal) || IsEqualGUID(iid, IID_IMarshal2))
    {
        *ppv = _pfm;
        _pfm->AddRef();
        hr = S_OK;
    }

    return hr;
}



//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::AddRef
//
//  Synopsis:   Standard stuff
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFmCtrlUnknown::AddRef(void)
{
    InterlockedIncrement((LONG *) &_cRefs);

    return _cRefs;
}




//+-------------------------------------------------------------------
//
//  Member:     CFmCtrlUnknown::Release
//
//  Synopsis:   Standard stuff
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFmCtrlUnknown::Release(void)
{
    ULONG cRefs = InterlockedDecrement((LONG *) &_cRefs);

    if (cRefs == 0)
    {
        delete this;
    }

    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::CFreeMarshaler()
//
//  Synopsis:   The constructor for CFreeMarshaler.
//
//  Arguments:  None
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
CFreeMarshaler::CFreeMarshaler(IUnknown *punkCtrl)
    : _punkCtrl(punkCtrl)
{
    // Header does all the work.
}



//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::QueryInterface
//
//  Synopsis:   Pass QI to our controlling IUnknown
//
//  Returns:    S_OK
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::QueryInterface(REFIID iid, void **ppv)
{
     // HACKALERT: Need a way to determine if an object aggregates the FTM
     // withough calling GetUnmarshalClass.
     if (IsEqualGUID(iid, IID_IStdFreeMarshal))
     {
         *ppv = (void*)LongToPtr(0xffffffff);
         return S_OK;
     }
     return _punkCtrl->QueryInterface(iid, ppv);
}




//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::AddRef
//
//  Synopsis:   Pass AddRef to our controlling IUnknown
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFreeMarshaler::AddRef(void)
{
    return _punkCtrl->AddRef();
}




//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::Release
//
//  Synopsis:   Pass release to our controlling IUnknown
//
//  History:    15-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFreeMarshaler::Release(void)
{
    return _punkCtrl->Release();
}


//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::GetUnmarshalClass
//
//  Synopsis:   Return the unmarshaling class
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::GetUnmarshalClass(
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    CLSID *pCid)
{
    // Inprocess context?
    if (dwDestContext==MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        // If this is an inproc marshal then we are the class
        // that can unmarshal.
        *pCid = CLSID_InProcFreeMarshaler;
        return S_OK;
    }

    // we can just use the static guy here and save a lot of work.
    IMarshal *pmrshlStd;
    HRESULT hr = GetStaticUnMarshaler(&pmrshlStd);

    if (pmrshlStd != NULL)
    {
        BOOL fUseCurrentApartment = UseFTMFromCurrentApartment();

        CObjectContext *pCurrentCtx;
        if (!fUseCurrentApartment)
            pCurrentCtx = EnterNTA(g_pNTAEmptyCtx);

        hr = pmrshlStd->GetUnmarshalClass(riid, pv, dwDestContext,
                                          pvDestContext,
                                          (fUseCurrentApartment ? mshlflags : (mshlflags| MSHLFLAGS_AGILE)),
                                          pCid);
        pmrshlStd->Release();

        if (!fUseCurrentApartment)
        {
            pCurrentCtx = LeaveNTA(pCurrentCtx);
            Win4Assert(pCurrentCtx == g_pNTAEmptyCtx);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::GetMarshalSizeMax
//
//  Synopsis:   Return maximum bytes need for marshaling
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::GetMarshalSizeMax(
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    DWORD *pSize)
{
    // Inprocess context?
    if (dwDestContext==MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        // If this is an inproc marshal then we know the size
        *pSize = sizeof(DWORD)         // Flags
			   + sizeof(__int64)       // Pointer rounded up to 64 bits
			   + sizeof(_SecretBlock); // Secret... shhhhh!!!
        return S_OK;
    }

    // we can just use the static guy here and save a lot of work.
    IMarshal *pmrshlStd;
    HRESULT hr = GetStaticUnMarshaler(&pmrshlStd);

    if (pmrshlStd != NULL)
    {
        BOOL fUseCurrentApartment = UseFTMFromCurrentApartment();

        CObjectContext *pCurrentCtx;
        if (!fUseCurrentApartment)
            pCurrentCtx = EnterNTA(g_pNTAEmptyCtx);

        hr = pmrshlStd->GetMarshalSizeMax(riid, pv, dwDestContext,
                                          pvDestContext,
                                          (fUseCurrentApartment ? mshlflags : (mshlflags| MSHLFLAGS_AGILE)),
                                          pSize);
        pmrshlStd->Release();

        if (!fUseCurrentApartment)
        {
            pCurrentCtx = LeaveNTA(pCurrentCtx);
            Win4Assert(pCurrentCtx == g_pNTAEmptyCtx);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::InitSecret
//
//  Synopsis:   Fill our secret block with crytographically random
//              data.
//
//  History:    05-Jan-2000  JohnDoty    Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::InitSecret ()
{
    HRESULT      hr = S_OK;

    COleStaticLock lock(_SecretLock);

    // Hey, somebody beat us to it.  Good for them!
    if (_fSecretInit) return S_OK;

    // The easy way to get mostly random bits
    // (Random for all but 3 bytes)
    hr = CoCreateGuid((GUID *)_SecretBlock);
    if (SUCCEEDED(hr))
    {
        _fSecretInit = TRUE;        
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::MarshalInterface
//
//  Synopsis:   Marshal the interface
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::MarshalInterface(
    IStream *pStm,
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags)
{
    HRESULT hr;

    // Inprocess context?
    if (dwDestContext==MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        void *pvNew=NULL;
        hr = ((IUnknown *) pv)->QueryInterface(riid, &pvNew);

        if (SUCCEEDED(hr))
        {
            Win4Assert(pvNew != NULL);

            // Write the marshal flags into the stream
            hr = pStm->Write(&mshlflags, sizeof(mshlflags), NULL);

            if (hr == NOERROR)
            {
                // Write the pointer into the stream
                // Cast it to an int64 so it always takes up the same amount of space
                __int64 tpv = (__int64)(pvNew);

                hr = pStm->Write(&tpv, sizeof(tpv), NULL);

                if (SUCCEEDED(hr))
                {
                    // Make sure we have filled in our random block of data
                    if (!_fSecretInit)
                        hr = InitSecret();

                    if (SUCCEEDED(hr))
                    {
                        // Write the random block into the stream
                        hr = pStm->Write(_SecretBlock, sizeof(_SecretBlock), NULL);
                    }
                }
            }

            // Bump reference count based on type of marshal
            if ((hr != NOERROR) || (mshlflags == MSHLFLAGS_TABLEWEAK))
            {
                ((IUnknown *) pvNew)->Release();
            }
        }

        return hr;
    }

    BOOL fUseCurrentApartment = UseFTMFromCurrentApartment();

    CObjectContext *pCurrentCtx;
    if (!fUseCurrentApartment)
        pCurrentCtx = EnterNTA(g_pNTAEmptyCtx);

    // make sure the channel is initialized
    hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        // Marshal the FTM object into a STDOBJREF.
        //
        hr = StdMarshalObject(pStm,
                              riid,
                              (IUnknown *) pv,
                              GetEmptyContext(),
                              dwDestContext,
                              pvDestContext,
                              (fUseCurrentApartment ? mshlflags : (mshlflags| MSHLFLAGS_AGILE)));
    }

    if (!fUseCurrentApartment)
    {
        pCurrentCtx = LeaveNTA(pCurrentCtx);
        Win4Assert(pCurrentCtx == g_pNTAEmptyCtx);
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::UnmarshalInterface
//
//  Synopsis:   Unmarshal the interface
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::UnmarshalInterface(
    IStream *pStm,
    REFIID riid,
    void **ppv)
{
    DWORD mshlflags;
    DWORD cbSize;
    BYTE  secret[sizeof(_SecretBlock)];

    // Initialize
    *ppv = NULL;

    // You can only unmarshal stuff you've marshaled!
    // If you marshaled something then fSecretInit is TRUE!
    if (!_fSecretInit)
        return E_UNEXPECTED;

    HRESULT hr = pStm->Read(&mshlflags, sizeof(mshlflags), &cbSize);
    if(cbSize == sizeof(mshlflags))
    {
        // Read the pointer out of the stream
        __int64 tpv;

        hr = pStm->Read(&tpv, sizeof(tpv), &cbSize);
        if(cbSize == sizeof(tpv))
        {
            // Read out the secret
            hr = pStm->Read(secret, sizeof(secret), &cbSize);
            if (cbSize == sizeof(secret))
            {
                // Make sure it's correct
                if (memcmp(_SecretBlock, secret, sizeof(_SecretBlock)) == 0)
                {
                    *ppv = (void *)(tpv);

                    // AddRef the pointer if table marshaled
                    if((mshlflags == MSHLFLAGS_TABLEWEAK) ||
                       (mshlflags == MSHLFLAGS_TABLESTRONG))
                        ((IUnknown *) *ppv)->AddRef();
                }
                else
                    hr = E_UNEXPECTED;
            }
            else
                hr = E_UNEXPECTED;
        }
        else
            hr = E_UNEXPECTED;
    }
    else
        hr = E_UNEXPECTED;

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::ReleaseMarshalData
//
//  Synopsis:   Release the marshaled data
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::ReleaseMarshalData(IStream *pStm)
{
    DWORD mshlflags;
    DWORD cbSize;

    HRESULT hr = pStm->Read(&mshlflags, sizeof(mshlflags), &cbSize);
    if(cbSize == sizeof(mshlflags))
    {
        IUnknown *punk;

        // Read the pointer out of the stream
        hr = pStm->Read(&punk, sizeof(punk), &cbSize);
        if (cbSize == sizeof(punk))
        {
            // Release the object if table marshaled
            if(mshlflags != MSHLFLAGS_TABLEWEAK)
                punk->Release();
        }
        else
            hr = E_UNEXPECTED;
    }
    else
        hr = E_UNEXPECTED;

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CFreeMarshaler::DisconnectObject
//
//  Synopsis:   Disconnect the object
//
//  History:    08-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CFreeMarshaler::DisconnectObject(DWORD dwReserved)
{
    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    BOOL fUseCurrentApartment = UseFTMFromCurrentApartment();
    
    CObjectContext *pCurrentCtx;
    if (!fUseCurrentApartment)
        pCurrentCtx = EnterNTA(g_pNTAEmptyCtx);

    CStdIdentity *pStdId;
    hr = ObtainStdIDFromUnk(_punkCtrl, GetCurrentApartmentId(),
                            GetCurrentContext(), 0, &pStdId);
    if (SUCCEEDED(hr))
    {
        hr = pStdId->DisconnectObject(dwReserved);
        pStdId->Release();
    }
    else
    {
        // already disconnected, report success
        hr = S_OK;
    }

    // Leave if we entered the NA.
    if (!fUseCurrentApartment)
    {
        pCurrentCtx = LeaveNTA(pCurrentCtx);
        Win4Assert(pCurrentCtx == g_pNTAEmptyCtx);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\ipaddr.cxx ===
//+-------------------------------------------------------------------
//
//  File:       ipaddr.cxx
//
//  Contents:   Implements classes\code for supporting the IP address
//              cache control functionality.
//
//  Classes:    CAddrControl, CAddrExclusionList
//
//  History:    07-Oct-00   jsimmons      Created
//--------------------------------------------------------------------

#include <ole2int.h>
#include <resolver.hxx>
#include "ipaddr.hxx"

// Single instance of this object
CAddrControl gAddrControl;

// IAddrTrackingControl implementation
STDMETHODIMP CAddrControl::EnableCOMDynamicAddrTracking()
{
	return gResolver.EnableDisableDynamicIPTracking(TRUE);
}

STDMETHODIMP CAddrControl::DisableCOMDynamicAddrTracking()
{
	return gResolver.EnableDisableDynamicIPTracking(FALSE);
}

// IAddrExclusionControl implementation
STDMETHODIMP CAddrControl::GetCurrentAddrExclusionList(REFIID riid, void** ppEnumerator)
{
	HRESULT hr = S_OK;
	DWORD dwNumStrings = 0;
	LPWSTR* ppszStrings = NULL;
	CAddrExclusionList* pAddrList;

	if (!ppEnumerator)
		return E_INVALIDARG;

	*ppEnumerator = NULL;
	
	pAddrList = new CAddrExclusionList();
	if (!pAddrList) 
		hr = E_OUTOFMEMORY;
	if (SUCCEEDED(hr))
	{		
		hr = gResolver.GetCurrentAddrExclusionList(&dwNumStrings, &ppszStrings);
		if (SUCCEEDED(hr))
		{
			hr = pAddrList->AddrExclListInitialize(dwNumStrings, ppszStrings);
			if (SUCCEEDED(hr))
			{
				hr = pAddrList->QueryInterface(riid, ppEnumerator);
			}
		}

		pAddrList->Release();
	}

	return hr;
}

STDMETHODIMP CAddrControl::UpdateAddrExclusionList(IUnknown* pEnumerator)
{
	HRESULT hr;
	IEnumString* pIEnumString;

	if (!pEnumerator)
		return E_INVALIDARG;

	// All we care about right now is IEnumString
	hr = pEnumerator->QueryInterface(IID_IEnumString, (void**)&pIEnumString);
	if (FAILED(hr))
		return hr;

	// create a CAddrExclusionList object
	hr = E_OUTOFMEMORY;
	CAddrExclusionList* pAddrList = new CAddrExclusionList();
	if (pAddrList)
	{
		hr = pAddrList->AddrExclListInitialize2(pIEnumString, 0);
		if (SUCCEEDED(hr))
		{
			// CAddrExclusionList composes the new list for us 
			// into a suitable format
			DWORD dwNumStrings;
			LPOLESTR* ppszStrings;

			hr = pAddrList->GetMarshallingData(&dwNumStrings, &ppszStrings);
			if (SUCCEEDED(hr))
			{
				hr = gResolver.SetAddrExclusionList(dwNumStrings, ppszStrings);
			}
		}
		pAddrList->Release();
	}

	pIEnumString->Release();

	return hr;
}


// IUnknown implementation for CIPAddControl
STDMETHODIMP CAddrControl::QueryInterface(REFIID riid, void** ppv)
{
	if (!ppv)
		return E_POINTER;
	
	*ppv = NULL;
	
	if (riid == IID_IUnknown || riid == IID_IAddrTrackingControl)
	{
		*ppv = static_cast<IAddrTrackingControl*>(this);
		AddRef();
		return S_OK;
	}
	else if (riid == IID_IAddrExclusionControl)
	{
		*ppv = static_cast<IAddrExclusionControl*>(this);
		AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CAddrControl::AddRef()
{
	return 1;  // global singleton
}

STDMETHODIMP_(ULONG) CAddrControl::Release()
{
	return 1;  // global singleton
}


// Function used for creating objects
HRESULT CAddrControlCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
	// just return reference on process-wide singleton
	return gAddrControl.QueryInterface(riid, ppv);
}



//
//  CAddrExclusionList implementation
// 

CAddrExclusionList::CAddrExclusionList() :
	_lRefs(1), // starts with refcount of 1!
	_dwCursor(0),
	_dwNumStrings(0),
	_ppszStrings(NULL)
{
}

CAddrExclusionList::~CAddrExclusionList()
{
	Win4Assert(_lRefs == 0);
	FreeCurrentBuffers();
}

HRESULT CAddrExclusionList::AddrExclListInitialize(
		DWORD dwNumStrings,
		LPWSTR* ppszStrings)
{
	FreeCurrentBuffers();
	
	// We now own the passed-in buffers
	_dwNumStrings = dwNumStrings;
	_ppszStrings = ppszStrings;

	return S_OK;
}

// Initialize this object from another 
HRESULT CAddrExclusionList::AddrExclListInitialize2(IEnumString* pIEnumString, DWORD dwNewCursor)
{
	HRESULT hr;
	DWORD i;
	DWORD dwNumStringsPass1;
	LPOLESTR pszString;
	LPOLESTR* ppszStrings;

	FreeCurrentBuffers();
	
	// Set new cursor position.  On success it will be correct, on
	// failure it won't matter.
	_dwCursor = dwNewCursor;

	// Make one pass to discover how many strings are in the enumerator; too
	// bad IEnum*** doesn't expose a method to retrieve this.
	hr = pIEnumString->Reset();
	if (FAILED(hr)) 
		return hr;

	dwNumStringsPass1 = 0;
	for (;;)
	{
		hr = pIEnumString->Next(1, &pszString, NULL);
		if (hr == S_OK)
		{
			dwNumStringsPass1++;
			CoTaskMemFree(pszString);
		}
		else if (hr == S_FALSE)
		{
			// no more, we're done
			break;
		}
		else
		{
			// unexpected error
			Win4Assert("Unexpected error from enumerator");
			return hr;
		}
	}

    // Check to see if user passed in an empty enumerator
    if (dwNumStringsPass1 == 0)
    {
        // yep.  nothing else to do
        return S_OK;
    }

    // Reset enumerator back to beginning
    hr = pIEnumString->Reset();
    if (FAILED(hr)) 
        return hr;

	// Allocate memory to store the caller's strings.  Use same allocator as
	// used in FreeCurrentBuffers.
	ppszStrings = (LPOLESTR*)MIDL_user_allocate(sizeof(LPOLESTR) * dwNumStringsPass1);
	if (!ppszStrings)
		return E_OUTOFMEMORY;

	ZeroMemory(ppszStrings, sizeof(LPOLESTR) * dwNumStringsPass1);

	// Make second pass, this time saving off a copy of each string
	for (i = 0; i < dwNumStringsPass1; i++)
	{
		hr = pIEnumString->Next(1, &pszString, NULL);
		switch (hr)
		{
		case S_OK:
			ppszStrings[i] = (LPOLESTR)MIDL_user_allocate(
							sizeof(WCHAR) * (lstrlen(pszString) + 1));
			if (!ppszStrings[i])
			{
				// Free buffers allocated so far
				for (i = 0; i < dwNumStringsPass1; i++)
					if (ppszStrings[i])  MIDL_user_free(ppszStrings[i]);

				MIDL_user_free(ppszStrings);

				CoTaskMemFree(pszString);

				return E_OUTOFMEMORY;
			}
			lstrcpy(ppszStrings[i], pszString);
			CoTaskMemFree(pszString);
			break;

		case S_FALSE:
			// unexpected error -- second pass had less than the first one
			Win4Assert("Weird behavior from enumerator");

			// ** Intentional fallthru here to cleanup code **
		default:
			
			// Free buffers allocated so far
			for (i = 0; i < dwNumStringsPass1; i++)
				if (ppszStrings[i])  MIDL_user_free(ppszStrings[i]);

			MIDL_user_free(ppszStrings);

			return (hr == S_FALSE ? E_UNEXPECTED : hr);
			break;
		}
	}
	
	// Done
	_dwNumStrings = dwNumStringsPass1;
	_ppszStrings = ppszStrings;

	return S_OK;
}

// 
// GetMarshallingData
// 
// Caller is responsible for making sure that this object is not in use while it's
// member data is being marshalled.
//
HRESULT CAddrExclusionList::GetMarshallingData(DWORD* pdwNumStrings, LPWSTR** pppszStrings)
{
	Win4Assert(_lRefs > 0);
	*pdwNumStrings = _dwNumStrings;
	*pppszStrings = _ppszStrings;
	return S_OK;
}

void CAddrExclusionList::FreeCurrentBuffers()
{
	Win4Assert((_dwNumStrings == 0 && _ppszStrings == 0) ||
		       (_dwNumStrings != 0 && _ppszStrings != 0));
		
	DWORD i;

	VDATEHEAP();

	for (i = 0; i < _dwNumStrings; i++)
	{
		// these strings came from rpc, so free them with m_u_f
		MIDL_user_free(_ppszStrings[i]);
	}

	if (_ppszStrings)
		MIDL_user_free(_ppszStrings);

	VDATEHEAP();
	
	_dwCursor = 0;  // reset cursor
	_dwNumStrings = 0;
	_ppszStrings = NULL;

	return;
}

// IEnumString implementation for CAddrExclusionList
STDMETHODIMP CAddrExclusionList::Next(
				ULONG ulcStrings, 
				LPOLESTR* ppszStrings, 
				ULONG* pulFetched)
{
	Win4Assert(_lRefs > 0);

	if (!ppszStrings)
		return E_INVALIDARG;

	ZeroMemory(ppszStrings, sizeof(WCHAR*) * ulcStrings);

	DWORD i;
	DWORD dwFetched = 0;

	for (i = _dwCursor; 
	     (i < _dwNumStrings) && (dwFetched < ulcStrings);
		 i++, dwFetched++)
	{
		ppszStrings[dwFetched] = (LPOLESTR)CoTaskMemAlloc(
			    sizeof(WCHAR) * (lstrlen(_ppszStrings[i]) + 1));
		if (!ppszStrings[dwFetched])
		{
			// if we get an out-of-mem error part-way thru, we free up the 
			// already allocated strings and return an error
			for (i = 0; i < ulcStrings; i++)
			{
				if (ppszStrings[i])
				{
					CoTaskMemFree(ppszStrings[i]);
					ppszStrings[i] = NULL;
				}
			}
			return E_OUTOFMEMORY;
		}

		// Copy the string
		lstrcpy(ppszStrings[dwFetched], _ppszStrings[i]);
	}
	
	// Advance the cursor
	_dwCursor += dwFetched;

	// Tell how many they got, if they care
	if (pulFetched) 
		*pulFetched = dwFetched;

	return (dwFetched == ulcStrings) ? S_OK : S_FALSE;
}


STDMETHODIMP CAddrExclusionList::Skip(ULONG celt)
{
	Win4Assert(_lRefs > 0);

	_dwCursor += celt;
	if (_dwCursor > _dwNumStrings)
	{
		_dwCursor = _dwNumStrings;
		return S_FALSE;
	}

	return S_OK;
}

STDMETHODIMP CAddrExclusionList::Reset()
{
	Win4Assert(_lRefs > 0);
	_dwCursor = 0;
	return S_OK;
}

STDMETHODIMP CAddrExclusionList::Clone(IEnumString** ppEnum)
{
	HRESULT hr;

	if (!ppEnum)
		return E_INVALIDARG;

	Win4Assert(_lRefs > 0);

	*ppEnum = NULL;

	CAddrExclusionList* pClonedList = new CAddrExclusionList();
	if (!pClonedList)
		return E_OUTOFMEMORY;

	hr = pClonedList->AddrExclListInitialize2(static_cast<IEnumString*>(this), _dwCursor);
	if (SUCCEEDED(hr))
	{
		hr = pClonedList->QueryInterface(IID_IEnumString, (void**)ppEnum);
	}
	pClonedList->Release();

	return hr;
}

// IUnknown implementation for CAddrExclusionList
STDMETHODIMP CAddrExclusionList::QueryInterface(REFIID riid, void** ppv)
{
	if (!ppv)
		return E_POINTER;
	
	Win4Assert(_lRefs > 0);

	*ppv = NULL;
	
	if (riid == IID_IUnknown || riid == IID_IEnumString)
	{
        *ppv = static_cast<IEnumString*>(this);
		AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CAddrExclusionList::AddRef()
{
	Win4Assert(_lRefs != 0);
	return InterlockedIncrement(&_lRefs);
}

STDMETHODIMP_(ULONG) CAddrExclusionList::Release()
{
	Win4Assert(_lRefs > 0);
	LONG lRefs = InterlockedDecrement(&_lRefs);
	if (lRefs == 0)
	{
		delete this;
	}
	return lRefs;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\ipidtbl.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       ipidtbl.cxx
//
//  Contents:   IPID (interface pointer identifier) table.
//
//  Classes:    CIPIDTable
//
//  History:    02-Feb-95   Rickhi      Created
//
//  Notes:      All synchronization is the responsibility of the caller.
//
//-------------------------------------------------------------------------
#include    <ole2int.h>
#include    <ipidtbl.hxx>       // CIPIDTable
#include    <resolver.hxx>      // CRpcResolver
#include    <service.hxx>       // SASIZE
#include    <remoteu.hxx>       // CRemoteUnknown
#include    <marshal.hxx>       // UnmarshalObjRef
#include    <callctrl.hxx>      // OleModalLoopBlockFn

extern void CancelPendingCalls(HWND hwnd);

// global tables
CMIDTable        gMIDTbl;       // machine ID table
COXIDTable       gOXIDTbl;      // object exported ID table
CIPIDTable       gIPIDTbl;      // interface pointer ID table

COleStaticMutexSem gOXIDLock;         // critical section for OXID and MID tables
COleStaticMutexSem gIPIDLock(TRUE);   // critical section for IPID tbl & CStdMarshal

OXIDEntry        COXIDTable::_InUseHead;
OXIDEntry        COXIDTable::_CleanupHead;
OXIDEntry        COXIDTable::_ExpireHead;
DWORD            COXIDTable::_cExpired  = 0;

CStringHashTable CMIDTable::_HashTbl;               // hash table for MIDEntries
CPageAllocator   CMIDTable::_palloc;                // allocator for MIDEntries
MIDEntry        *CMIDTable::_pLocalMIDEntry = NULL; // local machine MIDEntry

CPageAllocator   CIPIDTable::_palloc;               // allocator for IPIDEntries
IPIDEntry        CIPIDTable::_oidListHead;          // OIDs holding IPID entries
CPageAllocator   OXIDEntry::_palloc;                // allocator for OXIDEntries

//+------------------------------------------------------------------------
//
//  Machine Identifier hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain MIDBuckets[23] = {
    {&MIDBuckets[0],  &MIDBuckets[0]},
    {&MIDBuckets[1],  &MIDBuckets[1]},
    {&MIDBuckets[2],  &MIDBuckets[2]},
    {&MIDBuckets[3],  &MIDBuckets[3]},
    {&MIDBuckets[4],  &MIDBuckets[4]},
    {&MIDBuckets[5],  &MIDBuckets[5]},
    {&MIDBuckets[6],  &MIDBuckets[6]},
    {&MIDBuckets[7],  &MIDBuckets[7]},
    {&MIDBuckets[8],  &MIDBuckets[8]},
    {&MIDBuckets[9],  &MIDBuckets[9]},
    {&MIDBuckets[10], &MIDBuckets[10]},
    {&MIDBuckets[11], &MIDBuckets[11]},
    {&MIDBuckets[12], &MIDBuckets[12]},
    {&MIDBuckets[13], &MIDBuckets[13]},
    {&MIDBuckets[14], &MIDBuckets[14]},
    {&MIDBuckets[15], &MIDBuckets[15]},
    {&MIDBuckets[16], &MIDBuckets[16]},
    {&MIDBuckets[17], &MIDBuckets[17]},
    {&MIDBuckets[18], &MIDBuckets[18]},
    {&MIDBuckets[19], &MIDBuckets[19]},
    {&MIDBuckets[20], &MIDBuckets[20]},
    {&MIDBuckets[21], &MIDBuckets[21]},
    {&MIDBuckets[22], &MIDBuckets[22]}
};

//+------------------------------------------------------------------------
//
//  Member:     CIPIDTbl::Initialize, public
//
//  Synopsis:   Initializes the IPID table.
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CIPIDTable::Initialize()
{
    ComDebOut((DEB_OXID, "CIPIDTable::Initialize\n"));
    LOCK(gIPIDLock);
    _oidListHead.pOIDFLink = &_oidListHead;
    _oidListHead.pOIDBLink = &_oidListHead;
    _palloc.Initialize(sizeof(IPIDEntry), IPIDS_PER_PAGE, NULL);
    UNLOCK(gIPIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CIPIDTbl::Cleanup, public
//
//  Synopsis:   Cleanup the ipid table.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CIPIDTable::Cleanup()
{
    ComDebOut((DEB_OXID, "CIPIDTable::Cleanup\n"));
    LOCK(gIPIDLock);
    _palloc.AssertEmpty();
    _palloc.Cleanup();
    UNLOCK(gIPIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CIPIDTbl::LookupIPID, public
//
//  Synopsis:   Finds an entry in the IPID table with the given IPID.
//              This is used by the unmarshalling code, the dispatch
//              code, and CRemoteUnknown.
//
//  Notes:      This method should be called instead of GetEntryPtr
//              whenever you dont know if the IPID is valid or not (eg it
//              came in off the network), since this validates the IPID
//              index to ensure its within the table size, as well as
//              validating the rest of the IPID.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
IPIDEntry *CIPIDTable::LookupIPID(REFIPID ripid)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    // Validate the IPID index that is passed in, since this came in off
    // off the net it could be bogus and we dont want to fault on it.
    // first dword of the ipid is the index into the ipid table.

    if (_palloc.IsValidIndex(ripid.Data1))
    {
        IPIDEntry *pIPIDEntry = GetEntryPtr(ripid.Data1);

        // entry must be server side and not vacant
        if ((pIPIDEntry->dwFlags & (IPIDF_SERVERENTRY | IPIDF_VACANT)) ==
                                    IPIDF_SERVERENTRY)
        {
            // validate the rest of the guid
            if (InlineIsEqualGUID(pIPIDEntry->ipid, ripid))
                return pIPIDEntry;
        }
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   LookupFromIPIDTables, public
//
//  Synopsys:   Looks up the IPID in the IPIDtable, if found and valid,
//              returns the IPIDEntry pointer and the OXIDEntry pointer
//              with the OXIDEntry AddRef'd.
//
//  History:    28-Oct-96   t-KevinH    Created
//
//-------------------------------------------------------------------------
HRESULT CIPIDTable::LookupFromIPIDTables(REFIPID ripid, IPIDEntry **ppIPIDEntry,
                                         OXIDEntry **ppOXIDEntry)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    HRESULT hr = S_OK;

    IPIDEntry *pIPIDEntry = LookupIPID(ripid);
    if (pIPIDEntry != NULL && !(pIPIDEntry->dwFlags & IPIDF_DISCONNECTED) &&
        pIPIDEntry->pChnl != NULL && !(pIPIDEntry->pOXIDEntry->IsStopped()))
    {
        // OK to dispatch the call
        *ppIPIDEntry = pIPIDEntry;

        // Keep the OXID from going away till the call is dispatched.
        if (ppOXIDEntry)
        {
            *ppOXIDEntry = pIPIDEntry->pOXIDEntry;
            (*ppOXIDEntry)->IncRefCnt();
        }
    }
    else
    {
        // not OK to dispatch the call
        if (pIPIDEntry != NULL && pIPIDEntry->pStub == NULL)
            hr = E_NOINTERFACE;
        else
            hr = RPC_E_DISCONNECTED;

        *ppIPIDEntry = NULL;
        if (ppOXIDEntry)
            *ppOXIDEntry = NULL;
    }

    ComDebOut((DEB_CHANNEL,"LookupFromIPIDTables hr:%x pIPIDEntry:%x pOXIDEntry:%x\n",
              hr, *ppIPIDEntry, (ppOXIDEntry) ? *ppOXIDEntry : NULL));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CIPIDTable::ReleaseEntryList
//
//  Synopsis:   return a linked list of IPIDEntry to the table's free list
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CIPIDTable::ReleaseEntryList(IPIDEntry *pFirst, IPIDEntry *pLast)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(pLast->pNextIPID == NULL);

#if DBG==1
    // In debug, walk the list to ensure they are released, vacant,
    // disconnected etc.
    IPIDEntry *pEntry = pFirst;
    while (pEntry != NULL)
    {
        Win4Assert(pEntry->pOXIDEntry == NULL); // must already be released
        Win4Assert(pEntry->dwFlags & IPIDF_VACANT);
        Win4Assert(pEntry->dwFlags & IPIDF_DISCONNECTED);

        pEntry = pEntry->pNextIPID;
    }
#endif

    _palloc.ReleaseEntryList((PageEntry *)pFirst, (PageEntry *)pLast);
}

//+-------------------------------------------------------------------
//
//  Member:     CIPIDTable::ReleaseEntry
//
//  Synopsis:   return an IPIDEntry
//
//  History:    02-Sep-99   Johnstra  Created.
//
//--------------------------------------------------------------------
void CIPIDTable::ReleaseEntry(IPIDEntry *pEntry)
{
    ASSERT_LOCK_HELD(gIPIDLock);

#if DBG==1
    Win4Assert(pEntry->pOXIDEntry == NULL); // must already be released
    Win4Assert(pEntry->dwFlags & IPIDF_VACANT);
    Win4Assert(pEntry->dwFlags & IPIDF_DISCONNECTED);
#endif

    _palloc.ReleaseEntry((PageEntry *)pEntry);
}

#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     CIPIDTable::ValidateIPIDEntry
//
//  Synopsis:   Ensures the IPIDEntry is valid.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CIPIDTable::ValidateIPIDEntry(IPIDEntry *pEntry, BOOL fServerSide,
                                   CCtxComChnl *pChnl)
{
    // validate the IPID flags
    Win4Assert(!(pEntry->dwFlags & IPIDF_VACANT));
    if (fServerSide)
    {
        // server side must have SERVERENTRY ipids
        Win4Assert(pEntry->dwFlags & IPIDF_SERVERENTRY);
    }
    else
    {
        // client side must not have SERVERENTRY ipids
        Win4Assert(!(pEntry->dwFlags & IPIDF_SERVERENTRY));
    }


    // Validate the pStub interface
    if (IsEqualIID(pEntry->iid, IID_IUnknown))
    {
        // there is no proxy or stub for IUnknown interface
        Win4Assert(pEntry->pStub == NULL);
    }
    else
    {
        if ((pEntry->dwFlags & IPIDF_DISCONNECTED) &&
            (pEntry->dwFlags & IPIDF_SERVERENTRY))
        {
            // disconnected server side has NULL pStub
            Win4Assert(pEntry->pStub == NULL);
        }
        else
        {
            // both connected and disconnected client side has valid proxy
            Win4Assert(pEntry->pStub != NULL);
            Win4Assert(IsValidInterface(pEntry->pStub));
        }
    }


    // Validate the interface pointer (pv)
    if (!(pEntry->dwFlags & (IPIDF_DISCONNECTED | IPIDF_DEACTIVATED)))
    {
        Win4Assert(pEntry->pv != NULL);
        Win4Assert(IsValidInterface(pEntry->pv));
    }


    // Validate the channel ptr
    if (fServerSide)
    {
        // all stubs share the same channel on the server side
        Win4Assert(pEntry->pChnl == pChnl ||
                   (pEntry->dwFlags & IPIDF_DISCONNECTED));
    }
    else
    {
        // all proxies have their own different channel on client side
        Win4Assert(pEntry->pChnl != pChnl || pEntry->pChnl == NULL);
    }

    // Validate the RefCnts
    if (!(pEntry->dwFlags & IPIDF_DISCONNECTED) && !fServerSide)
    {
        // if connected, must be > 0 refcnt on client side.
        // potentially not > 0 if TABLE marshal on server side.
        ULONG cRefs = pEntry->cStrongRefs + pEntry->cWeakRefs;
        IRCEntry *pIRCEntry = pEntry->pIRCEntry;
        if (pIRCEntry)
            cRefs += pIRCEntry->cStrongRefs + pIRCEntry->cWeakRefs;

        Win4Assert(cRefs > 0);
    }

    // Validate the OXIDEntry
    if (pEntry->pOXIDEntry)
    {
        OXIDEntry *pOX = pEntry->pOXIDEntry;
        COMVERSION version = pOX->GetComVersion();
        Win4Assert(version.MajorVersion == COM_MAJOR_VERSION);
        Win4Assert(version.MinorVersion <= COM_MINOR_VERSION);

        if (fServerSide)
        {
            // check OXID tid and pid
            Win4Assert(pOX->GetPid() == GetCurrentProcessId());
            if (pOX->IsMTAServer())
                Win4Assert(pOX->GetTid() == MTATID);
            else if (pOX->IsNTAServer())
                Win4Assert(pOX->GetTid() == NTATID);
            else
                Win4Assert(pOX->GetTid() == GetCurrentThreadId());

            if (pChnl != NULL)
            {
                // CODEWORK: ensure OXID is same as the rest of the object
                // Win4Assert(IsEqualGUID(pOX->moxid, GetMOXID()));
            }
        }
    }


    // Validate the pNextIPID
    if (pEntry->pNextIPID != NULL)
    {
        // ensure it is within the bounds of the table
        Win4Assert(GetEntryIndex(pEntry) != -1);

        // cant point back to self or we have a circular list
        Win4Assert(pEntry->pNextIPID != pEntry);
    }

}
#endif

//+-------------------------------------------------------------------
//
//  Method:     OXIDEntry::operator new, private
//
//+-------------------------------------------------------------------
void *OXIDEntry::operator new(size_t size)
{
    ASSERT_LOCK_HELD(gOXIDLock);

    // Allocate memory from page allocator
    void *pv = (void *) _palloc.AllocEntry();

    ComDebOut((DEB_OXID, "OXIDEntry::operator new this:%x\n",pv));
    return(pv);
}

//+-------------------------------------------------------------------
//
//  Method:     OXIDEntry::operator delete, private
//
//+-------------------------------------------------------------------
void OXIDEntry::operator delete(void *pv)
{
    ComDebOut((DEB_OXID, "OXIDEntry::operator delete this:%x\n",pv));
    LOCK(gOXIDLock);

#if DBG==1
    // Ensure that the pv was allocated by the allocator
    LONG index = _palloc.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1);
#endif

    // Release the pointer
    _palloc.ReleaseEntry((PageEntry *) pv);
    UNLOCK(gOXIDLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     OXIDEntry::OXIDEntry, private
//
//  Synopsis:   ctor for OXIDEntry
//
//+--------------------------------------------------------------------
OXIDEntry::OXIDEntry(REFOXID roxid, MIDEntry *pMIDEntry,
                   OXID_INFO *poxidInfo, DWORD dwAuthSvc, HRESULT &hr)
{
    // the Resolver should have correctly negotiated the version by now
    Win4Assert(poxidInfo->version.MajorVersion == COM_MAJOR_VERSION);
    Win4Assert(poxidInfo->version.MinorVersion <= COM_MINOR_VERSION);

    // init the chain to itself
    ChainToSelf();

    // Copy oxidInfo into OXIDEntry.
    MOXIDFromOXIDAndMID(roxid, pMIDEntry->GetMid(), &_moxid);
    _cRefs        = 1;       // caller gets one reference
    _dwPid        = poxidInfo->dwPid;
    _dwTid        = poxidInfo->dwTid;
    _version      = poxidInfo->version;
    _dwFlags      = (poxidInfo->dwPid == 0) ? 0 : OXIDF_MACHINE_LOCAL;

    if(poxidInfo->dwPid)
    {
        if(poxidInfo->dwTid == NTATID)
            _dwFlags |= OXIDF_NTASERVER;
        else if(poxidInfo->dwTid == MTATID)
            _dwFlags |= OXIDF_MTASERVER;
        else
            _dwFlags |= OXIDF_STASERVER;
    }

    _pRUSTA       = NULL;
    _ipidRundown  = poxidInfo->ipidRemUnknown;
    _pRpc         = NULL;
    _pAuthId      = NULL;
    _pBinding     = NULL;
    _dwAuthnHint  = RPC_C_AUTHN_LEVEL_NONE;

    // Past behavior was to use RPC_C_AUTHN_DEFAULT by default, which in practice usually
    // meant snego.   See bug 406902.   Now, if we are constructing a OXIDEntry for a remote
    // server we use the specified authentication service.     
    if (IsOnLocalMachine())
      _dwAuthnSvc   = RPC_C_AUTHN_DEFAULT;
    else
      _dwAuthnSvc   = dwAuthSvc;

    _pMIDEntry    = pMIDEntry;
    _hComplete    = NULL;
    _cCalls       = 0;
    _cResolverRef = 0;
    _hServerSTA   = NULL;

    pMIDEntry->IncRefCnt();

    // Save a copy of the mid value.  This is so we can return it later
    // (via GetMID) w/o taking a lock.
    _mid = pMIDEntry->GetMid();

    hr = S_OK;

    if (poxidInfo->dwPid != GetCurrentProcessId())
    {
#ifdef _CHICAGO_
        if (!(IsOnLocalMachine()))
#endif
        {
            // Set security on this entry.
            hr = SetAuthnService(poxidInfo);
        }
    }
    else if (IsMTAServer() || IsNTAServer())
    {
        // Get a shutdown event for server side MTAs.  Don't use the event
        // cache because the event isn't always reset.
        _hComplete = CreateEventA( NULL, FALSE, FALSE, NULL );
        if (_hComplete == NULL)
            hr = RPC_E_OUT_OF_RESOURCES;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::DecRefCnt, public
//
//  Synopsis:   Decrement the refcnt and Release the entry if it went to 0.
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
ULONG OXIDEntry::DecRefCnt()
{
    ComDebOut((DEB_OXID, "OXIDEntry::DecRefCnt %x cRefs[%x]\n", this, _cRefs-1));

    ULONG cRefs = InterlockedDecrement((long *)&_cRefs);
    if (cRefs == 0)
    {
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        LOCK(gOXIDLock);

        // Assert that the MTA OXID for this process is stopped by the
        // time it gets released.
        const DWORD LOCAL_MTA = OXIDF_MTASERVER | OXIDF_MACHINE_LOCAL | OXIDF_REGISTERED;
        Win4Assert((_dwPid != GetCurrentProcessId())     ||
                   (_dwFlags & LOCAL_MTA) != LOCAL_MTA   ||
                   (_dwFlags & OXIDF_STOPPED) == OXIDF_STOPPED);

        // refcnt went to zero, see if OK to delete this
        // entry from the global table.
        if (_cRefs == 0)
        {
            // move the entry to the free list
            gOXIDTbl.ReleaseOXIDEntry(this);
        }

        UNLOCK(gOXIDLock);
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
    }

    return cRefs;
}

ULONG OXIDEntry::DecRefCntAndFreeProxiesIfNecessary(BOOL* pfFreedProxies)
{
    ComDebOut((DEB_OXID, "OXIDEntry::DecRefCntAndCleanupIfNecessary %x cRefs[%x]\n", this, _cRefs-1));

    *pfFreedProxies = FALSE;
    
    ULONG cRefs = InterlockedDecrement((long *)&_cRefs);
    if (cRefs == 0)
    {
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        LOCK(gOXIDLock);

        // Assert that the MTA OXID for this process is stopped by the
        // time it gets released.
        const DWORD LOCAL_MTA = OXIDF_MTASERVER | OXIDF_MACHINE_LOCAL;
        Win4Assert((_dwPid != GetCurrentProcessId())     ||
                   (_dwFlags & LOCAL_MTA) != LOCAL_MTA   ||
                   (_dwFlags & OXIDF_STOPPED) == OXIDF_STOPPED);

        // refcnt went to zero, see if OK to delete this
        // entry from the global table.
        if (_cRefs == 0)
        {
            // move the entry to the free list
            gOXIDTbl.ReleaseOXIDEntryAndFreeIPIDs(this);
            *pfFreedProxies = TRUE;
        }

        UNLOCK(gOXIDLock);
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
    }

    return cRefs;
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::DecCallCnt, public
//
//  Synopsis:
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
ULONG OXIDEntry::DecCallCnt()
{
    ComDebOut((DEB_OXID, "OXIDEntry::DecCallCnt %x cRefs[%x]\n", this, _cCalls-1));

    ULONG cCalls = InterlockedDecrement((long *)&_cCalls);
    if (cCalls == 0)
    {
        // The call count went to zero.  If the MTA or NTA is waiting to
        // uninitialize, wake up the uninitializing thread.
        if ((_dwFlags & OXIDF_MTASTOPPED) == OXIDF_MTASTOPPED ||
            (_dwFlags & OXIDF_NTASTOPPED) == OXIDF_NTASTOPPED)
        {
            if (_hComplete)
                SetEvent(_hComplete);
        }
    }

    return cCalls;
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::FillOXID_INFO, public
//
//  Synopsis:   fills out an OXID_INFO structure from an OXIDEntry
//
//  History:    02-Mar-97   Rickhi      Created
//
//-------------------------------------------------------------------------
void OXIDEntry::FillOXID_INFO(OXID_INFO *pOxidInfo)
{
    pOxidInfo->dwTid          = _dwTid;
    pOxidInfo->dwPid          = _dwPid;
    pOxidInfo->version        = _version;
    pOxidInfo->ipidRemUnknown = _ipidRundown;
    pOxidInfo->dwAuthnHint    = gAuthnLevel;
    pOxidInfo->dwFlags        = 0;
    pOxidInfo->psa            = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::GetRemUnk, public
//
//  Synopsis:   Find or create the proxy for the IRemUnknown for the
//              specified OXID
//
//  History:    27-Mar-95   AlexMit     Created
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::GetRemUnk(IRemUnknown **ppRemUnk)
{
    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnk pOXIDEntry:%x ppRemUnk:%x\n",
                    this, ppRemUnk));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    HRESULT hr = S_OK;

    if (_pRUSTA == NULL)
    {
        hr = MakeRemUnk();
    }
    *ppRemUnk = _pRUSTA;

    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnk pOXIDEntry:%x pRU:%x hr:%x\n",
                    this, *ppRemUnk, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::GetRemUnkNoCreate, public
//
//  Synopsis:   Find the proxy for the IRemUnknown for the OXID
//
//  History:    02-Sep-99   JohnStra     Created
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::GetRemUnkNoCreate( IRemUnknown **ppRemUnk )
{
    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnkNoCreate pOXIDEntry:%x ppRemUnk:%x\n",
                    this, ppRemUnk));
    
    ASSERT_LOCK_HELD(gOXIDLock);
    *ppRemUnk = _pRUSTA;

    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnkNoCreate pOXIDEntry:%x pRU:%x hr:%x\n",
                    this, *ppRemUnk, S_OK));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::MakeRemUnk, private
//
//  Synopsis:   Create the proxy for the IRemUnknown for the
//              specified OXID and current apartments threading model.
//
//  History:    27-Mar-95   AlexMit     Created
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::MakeRemUnk()
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // There is no remote unknown proxy for this entry, get one.
    // on the same machine, we ask for the IRundown interface since we may
    // need the RemChangeRef method. IRundown inherits from IRemUnknownN.

    REFIID riid = (IsOnLocalMachine()) ? IID_IRundown
                   : (_version.MinorVersion >= COM_MINOR_VERSION)
                     ? IID_IRemUnknown2
                     : IID_IRemUnknown;

    IRemUnknown *pRU = NULL;
    HRESULT hr = UnmarshalRemUnk(riid, (void **)&pRU);

    if (SUCCEEDED(hr))
    {
        if (InterlockedCompareExchangePointer((void**)&_pRUSTA, pRU, NULL) == NULL)
        {
            // need to adjust the internal refcnt on the OXIDEntry, since
            // the IRemUnknown has an IPID that holds a reference to it.
            // Dont use DecRefCnt since that would delete if it was 0.
            Win4Assert(_cRefs > 0);
            InterlockedDecrement((long *)&_cRefs);
        }
        else
        {
            // some other thread already created the proxy. Release
            // the one we made.
            pRU->Release();
        }
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "OXIDEntry::GetRemUnk pOXIDEntry:%x _pRUSTA:%x hr:%x\n",
               this, _pRUSTA, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::UnmarshalRemUnk, private
//
//  Synopsis:   Create a proxy for the requested IRemUnknown derivative
//              for the specified OXID.
//
//  History:    26-Nov-96        Rickhi Separated From MakeRemUnk
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::UnmarshalRemUnk(REFIID riid, void **ppv)
{
    ComDebOut((DEB_OXID,
        "OXIDEntry::UnmarshalRemUnk riid:%I pOXIDEntry:%x ppv:%x\n",
         &riid, this, ppv));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // Make up an objref, then unmarshal it to create a proxy to
    // the remunk object in the server.

    OBJREF objref;
    HRESULT hr = MakeFakeObjRef(objref, this, _ipidRundown, riid);

    if (SUCCEEDED(hr))
    {
        hr = UnmarshalInternalObjRef(objref, ppv);
        if(SUCCEEDED(hr))
        {
            CStdIdentity *pStdID;
            hr = ((IUnknown *) (*ppv))->QueryInterface(IID_IStdIdentity,
                                                       (void **) &pStdID);
            Win4Assert(SUCCEEDED(hr));
            // The check below is not needed given the assert above. However
            // this keeps some apps that worked on NT4 from AVing on NT5
            // See NT bugs 218523, 272390.

            if (SUCCEEDED(hr))
            {
                pStdID->UseClientPolicySet();
                pStdID->Release();
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "OXIDEntry::UnmarshalRemUnk ppv:%x hr:%x\n", *ppv, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     OXIDEntry::SetAuthnService, private
//
//  Synopsis:   Copy and save the security binding.
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::SetAuthnService(OXID_INFO *pOxidInfo)
{
    // Copy the string array.
    ASSERT_LOCK_HELD(gOXIDLock);
    _dwAuthnHint = pOxidInfo->dwAuthnHint;
    return CopyStringArray(pOxidInfo->psa, NULL, &_pBinding);
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::FindPidMatchingTid, public
//
//  Synopsis:   Walks the chained OXIDEntries looking for one whose
//              pid matches that of the caller.
//
//--------------------------------------------------------------------
DWORD OXIDEntry::FindPidMatchingTid(DWORD tidCaller)
{
    DWORD pidCallee = 0;
    OXIDEntry *pOXIDEntry = this;

    LOCK(gOXIDLock);

    do
    {
        if (pOXIDEntry->GetTid() == tidCaller)
        {
            pidCallee = pOXIDEntry->GetPid();
            break;
        }
        pOXIDEntry = pOXIDEntry->_pNext;
    }
    while (pOXIDEntry != this);

    UNLOCK(gOXIDLock);

    return pidCallee;
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::ExpireEntry, private
//
//  Synopsis:   deletes all state associated with an OXIDEntry that has
//              been expired.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void OXIDEntry::ExpireEntry()
{
    ComDebOut((DEB_OXID, "COXIDTable::ExpireEntry pEntry:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    if (_pRUSTA)
    {
        // release the IRemUnknown. Note that the IRemUnk is an object
        // proxy who's IPIDEntry holds a reference back to the very
        // OXIDEntry we are releasing.

        _pRUSTA->Release();
    }

    // Note that if hServerSTA is an HWND (apartment model, same process)
    // then it should have been cleaned up already in ThreadStop.
    Win4Assert(_hServerSTA == NULL);

    if (_pRpc != NULL)
    {
        // Release the channel handle and authentication information.
        _pRpc->Release();
    }
    if (_pAuthId)
    {
        PrivMemFree(_pAuthId);
    }
    PrivMemFree(_pBinding);

    // Release the call shutdown event.
    if (_hComplete != NULL)
        CloseHandle(_hComplete );

    // dec the refcnt on the MIDEntry
    _pMIDEntry->DecRefCnt();

    // CODEWORK: is this needed?
    // zero out the fields
    memset(this, 0, sizeof(OXIDEntry));

    // return it to the allocator
    delete this;

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"OXIDTable::ExpireEntry pEntry:%x\n", this));
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::InitRemoting, public
//
//  Synopsis:   Initialize the object for remoting.
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
HRESULT OXIDEntry::InitRemoting()
{
    ComDebOut((DEB_OXID, "OXIDEntry::InitRemoting this:%x.\n", this));

    // initially stopped
    _dwFlags |= OXIDF_STOPPED;

    HRESULT hr = S_OK;

    if (IsSTAServer())
    {
        // create the callctrl before calling StartServer, since the latter
        // tries to register with the call controller. We might already have
        // a callctrl if some DDE stuff has already run.

        COleTls tls;
        if (tls->pCallCtrl == NULL)
        {
            // assume OOM and try to create callctrl. ctor sets tls.
            hr = E_OUTOFMEMORY;
            CAptCallCtrl *pCallCtrl = new CAptCallCtrl();
        }

        if (tls->pCallCtrl)
        {
            // mark the channel as initialized.
            tls->dwFlags |= OLETLS_CHANNELTHREADINITIALZED;
            hr = S_OK;
        }
    }

    ComDebOut((DEB_OXID, "OXIDEntry::InitRemoting this:%x hr:%x.\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::InitRundown, public
//
//  Synopsis:   Initialize the ipid for the IRemUnknown object for remoting.
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
void OXIDEntry::InitRundown(IPID &ipidRundown)
{
    ComDebOut((DEB_OXID, "OXIDEntry::InitRundown this:%x IPID%I.\n",
              this, &ipidRundown));

    _ipidRundown = ipidRundown;
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::CleanupRemoting, public
//
//  Synopsis:   Release the window for the thread.
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
HRESULT OXIDEntry::CleanupRemoting()
{
    ComDebOut((DEB_OXID, "OXIDEntry::CleanupRemoting this:%x.\n", this));
    Win4Assert((_dwFlags & OXIDF_STOPPED));

    if (IsSTAServer())
    {
        // Destroy the window. This will unblock any pending SendMessages.
        HWND hwnd;

        if (_hServerSTA  != NULL)
        {
            hwnd  = _hServerSTA ;
            _hServerSTA = NULL;
        }
        else
        {
            hwnd = TLSGethwndSTA();
        }

        // Don't hold a lock across DestroyWindow because USER32 will
        // randomly pick another window to make active. This can
        // result in a call being dispatched on another thread for a
        // different window which will try to acquire the gOXIDLock. If
        // we hold gOXIDLock on this thread, a deadlock will result.
        ASSERT_LOCK_HELD(gOXIDLock);
        UNLOCK(gOXIDLock);

        if (gdwMainThreadId == GetCurrentThreadId())
        {
            // destroy the main window
            UninitMainThreadWnd();
        }
        else
        {
            // This may fail if threads get terminated.
            if (IsWindow(hwnd))
            {
                DestroyWindow(hwnd);
            }
        }

        TLSSethwndSTA(NULL); // wipe out from the TLS also

        // Free the apartment call control.
        COleTls tls;

        delete tls->pCallCtrl;
        tls->pCallCtrl = NULL;

        // Free any registered MessageFilter that has not been picked
        // up by the call ctrl.
        if (tls->pMsgFilter)
        {
            tls->pMsgFilter->Release();
            tls->pMsgFilter = NULL;
        }

        LOCK(gOXIDLock);
        ASSERT_LOCK_HELD(gOXIDLock);
    }

    ComDebOut((DEB_OXID, "OXIDEntry::CleanupRemoting this:%x done.\n",this));
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::StartServer, public
//
//  Synopsis:   Start the transport accepting incomming ORPC calls.
//
//  History:    02-Nov-98    Rickhi  Created, from various pieces
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
HRESULT OXIDEntry::StartServer(void)
{
    ComDebOut((DEB_OXID, "OXIDEntry::StartServer this:%x\n", this));
    Win4Assert((_dwFlags & OXIDF_STOPPED));

    HRESULT    hr = S_OK;

    if (IsSTAServer())
    {
        HWND hwnd = GetOrCreateSTAWindow();
        if (hwnd)
        {
            // remembeer the hwnd
            _hServerSTA = hwnd;

            // Override the window proc function
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)ThreadWndProc);

            // get the local call control object, and register the
            // the window with it. Note that it MUST exist cause we
            // created it in ChannelThreadInitialize.

            CAptCallCtrl *pCallCtrl = GetAptCallCtrl();
            pCallCtrl->Register(hwnd, WM_USER, 0x7fff );
        }
        else
        {
            hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        }
    }

    if (SUCCEEDED(hr))
    {
        _dwFlags &= ~OXIDF_STOPPED;
    }

    ComDebOut((DEB_OXID, "OXIDEntry::StartServer this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     OXIDEntry::StopServer, public
//
//  Synopsis:   Stop accepting incomming ORPC calls.
//
//  History:    ??-???-??  ?         Created
//              05-Jul-94  AlexT     Separated thread and process uninit
//              11-Feb-98  JohnStra  Made NTA aware
//              02-Jul-98  GopalK    Simplified
//              02-Nov-98  Rickhi    Made into method on OXIDEntry
//
//  Notes:      We are holding the single thread mutex during this call
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------------
HRESULT OXIDEntry::StopServer()
{
    ComDebOut((DEB_OXID, "OXIDEntry::StopServer this:%x\n", this));

    // Stop the transport from accepting any more incomming calls.
    LOCK(gOXIDLock);
    _dwFlags |= OXIDF_STOPPED;
    UNLOCK(gOXIDLock);

    // Drain currently executing calls in the apartment
    HWND hwnd = IsSTAThread() ? GetServerHwnd() : NULL;
    CancelPendingCalls(hwnd);

    // Wait for any pending calls to complete
    WaitForApartmentShutdown();

    Win4Assert(_dwFlags & OXIDF_STOPPED);
    ComDebOut((DEB_OXID, "OXIDEntry::StopServer this:%x\n", this));
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     OXIDEntry::WaitForApartmentShutdown, private
//
//  Synopsis:   deletes all state associated with an OXIDEntry that has
//              been expired.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
extern void PeekTillDone(HWND hwnd);

void OXIDEntry::WaitForApartmentShutdown()
{
    // Wait for the apartment to shutdown.
    if (IsNTAServer())
    {
        if (_cCalls != 0)
        {
            ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: NTA shutdown pending\n" ));
            ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
            Win4Assert( _hComplete != NULL );
            WaitForSingleObject( _hComplete, INFINITE );
            ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
            ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: NTA shutdown complete\n" ));
        }
    }
    else if (IsMTAServer())
    {
        if (_cCalls != 0)
        {
            ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: MTA shutdown pending\n" ));
            ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
            Win4Assert( _hComplete != NULL );
            WaitForSingleObject( _hComplete, INFINITE );
            ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
            ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: MTA shutdown complete\n" ));
        }
    }
    else
    {
        ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: STA shutdown pending\n" ));
        ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
        PeekTillDone(GetServerHwnd());
        ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
        ComDebOut(( DEB_CALLCONT, "WaitForApartmentShutdown: STA shutdown complete\n" ));
    }
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::UpdateMIDEntry, public
//
//  Synopsis:   replaces the cached mid entry with the supplied one;
//              returns the old one, which the caller must release 
//              outside of gOXIDLock.               
//
//  History:    27-Nov-00  JSimmons   Created
//
//--------------------------------------------------------------------
MIDEntry* OXIDEntry::UpdateMIDEntry(MIDEntry* pNewMIDEntry)
{
    MIDEntry* pOldMIDEntry;

    Win4Assert(pNewMIDEntry);

    ASSERT_LOCK_HELD(gOXIDLock);
    
    Win4Assert(_pMIDEntry);  // this may go away (?)

    pOldMIDEntry = _pMIDEntry;

    _pMIDEntry = pNewMIDEntry;
    _pMIDEntry->IncRefCnt();

    ASSERT_LOCK_HELD(gOXIDLock);

    return pOldMIDEntry;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::GetMIDEntry, public
//
//  Synopsis:   returns a ref-counted pointer to the current midentry
//              for this oxidentry.              
//
//  History:    27-Nov-00  JSimmons   Created
//
//--------------------------------------------------------------------
MIDEntry* OXIDEntry::GetMIDEntry()
{
    MIDEntry* pCurrentMIDEntry;

    ASSERT_LOCK_DONTCARE(gOXIDLock);
    LOCK(gOXIDLock);
    
    Win4Assert(_pMIDEntry);

    pCurrentMIDEntry = _pMIDEntry;
    if (_pMIDEntry)
    {
        _pMIDEntry->IncRefCnt();
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    UNLOCK(gOXIDLock);
    
    return pCurrentMIDEntry;
}


//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::RegisterOXIDAndOIDs, public
//
//  Synopsis:   allocate an OXID and Object IDs with the local ping server
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::RegisterOXIDAndOIDs(ULONG *pcOids, OID *pOids)
{
    ComDebOut((DEB_OXID, "OXIDEntry::RegisterOXID this%x TID:%x\n",
              this, GetCurrentThreadId()));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // OXID has not yet been registered with the resolver, do that
    // now along with pre-registering a bunch of OIDs.

    // init the oxidinfo structure from the OXIDEntry
    OXID_INFO oxidInfo;
    FillOXID_INFO(&oxidInfo);

    OXID oxid;
    HRESULT hr = gResolver.ServerRegisterOXID(oxidInfo, &oxid, pcOids, pOids);

    if (hr == S_OK)
    {
        // mark the OXID as registered with the resolver, and replace
        // the (temporarily zero) oxid with the real one the resolver
        // returned to us.

        _dwFlags |=  OXIDF_REGISTERED;
        MOXIDFromOXIDAndMID(oxid, gLocalMid, &_moxid);

#ifdef SHRMEM_OBJEX
        // at this point we can also start the timer for an STA server
        if (!IsMTAServer())
        {
            uiTimer = SetTimer(GetServerHwnd(),
                               IDT_DCOM_RUNDOWN,
                               RUNDOWN_TIMER_INTERVAL,
                               (TIMERPROC) RundownTimerProc);
        }
#endif // SHRMEM_OBJEX
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "ServerRegisterOXID this:%x hr:%x moxid:%I\n",
              this, hr, &_moxid));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::AllocOIDs, public
//
//  Synopsis:   allocates more pre-registered OIDs
//              with the local ping server
//
//  History:    20-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::AllocOIDs(ULONG *pcOidsAlloc, OID *pOidsAlloc,
                             ULONG cOidsReturn, OID *pOidsReturn)
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    HRESULT hr;

    if (!(IsRegistered()))
    {
        // have not yet registered the OXID, so go do that at the same time
        // we allocate OIDs.
        Win4Assert(cOidsReturn == 0);   // should not be any OIDs to return
        hr = RegisterOXIDAndOIDs(pcOidsAlloc, pOidsAlloc);
    }
    else
    {
        // just get more OIDs from the resolver
        OXID oxid;
        OXIDFromMOXID(_moxid, &oxid);
        hr = gResolver.ServerAllocOIDs(oxid, pcOidsAlloc, pOidsAlloc,
                                       cOidsReturn, pOidsReturn);
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::FreeOXIDAndOIDs, public
//
//  Synopsis:   frees an OXID and associated OIDs that were  pre-registered
//              with the local ping server
//
//  History:    20-Jan-96   Rickhi      Created.
//
//  Notes:      Access to this code is guarded through the apartment object.
//
//--------------------------------------------------------------------
HRESULT OXIDEntry::FreeOXIDAndOIDs(ULONG cOids, OID *pOids)
{
    ComDebOut((DEB_OXID, "OXIDEntry::FreeOXIDAndOIDs TID:%x\n", GetCurrentThreadId()));
    ASSERT_LOCK_HELD(gOXIDLock);

    if (!IsRegistered())
    {
        // OXID was never registered, just return
        return S_OK;
    }

    // mark the OXIDEntry as no longer registered
    _dwFlags &= ~OXIDF_REGISTERED;

    // extract the OXID and tell the resolver it is no longer in use
    UNLOCK(gOXIDLock);
    OXID oxid;
    OXIDFromMOXID(_moxid, &oxid);
    HRESULT hr = gResolver.ServerFreeOXIDAndOIDs(oxid, cOids, pOids);
    LOCK(gOXIDLock);

    return hr;
}

#if DBG==1
//----------------------------------------------------------------------------
//
//  Function:   PostCallToSTAExceptionFilter
//
//  Synopsis:   Filters exceptions from PostCallToSTA
//
//----------------------------------------------------------------------------
LONG PostCallToSTAExceptionFilter( DWORD lCode,
                                   LPEXCEPTION_POINTERS lpep )
{
    ComDebOut((DEB_ERROR, "Exception 0x%x in PostCallToSTA at address 0x%x\n",
               lCode, lpep->ExceptionRecord->ExceptionAddress));
    DebugBreak();
    return EXCEPTION_EXECUTE_HANDLER;
}
#endif // DBG

//----------------------------------------------------------------------------
//
//  Method:     OXIDEntry::PostCallToSTA
//
//  Synopsis:   Executed on client thread (in local case) and RPC thread
//              (in remote case). Posts a message to the server thread,
//              guarding against disconnected threads
//
//----------------------------------------------------------------------------
HRESULT OXIDEntry::PostCallToSTA(CMessageCall *pCall)
{
    
    // ensure we are not posting to ourself (except from NTA) and that the
    // target apartment is not an MTA apartment.
   
    
    // the original check was incorrect. When calling from the NA
    // to the STA, we leave the NA before we get here.
    // The new check is to handle the case where we call from an STA to
    // NA and then call back into the same STA - Sajia
    Win4Assert( (_dwTid != GetCurrentThreadId() || pCall->IsNAToSTAFlagSet()) && 
                (!IsMTAServer()));

    HRESULT hr = RPC_E_SERVER_DIED_DNE;
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    if (!IsStopped())
    {
#if DBG==1
        _try
        {
#endif
            // Pass the thread id to aid debugging.
            if (PostMessage(_hServerSTA, WM_OLE_ORPC_POST,
                            WMSG_MAGIC_VALUE, (LPARAM)pCall))
                hr = S_OK;
            else
                hr = RPC_E_SYS_CALL_FAILED;
#if DBG==1
        }
        _except( PostCallToSTAExceptionFilter(GetExceptionCode(),
                                              GetExceptionInformation()) )
        {
        }
#endif
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "OXIDEntry::PostCallToSTA this:%x pCall:%x hr:%x\n",
              this, pCall, hr));
    return hr;
}

//----------------------------------------------------------------------------
//
//  Method:     OXIDEntry::SendCallToSTA
//
//  Synopsis:   Executed on client thread (in local case) and RPC thread
//              (in remote case). Sends a message to the server thread,
//              guarding against disconnected apartments.
//
//----------------------------------------------------------------------------
HRESULT OXIDEntry::SendCallToSTA(CMessageCall *pCall)
{
    // make sure we are going someplace else
    Win4Assert(_dwTid != GetCurrentThreadId());

    HRESULT hr = RPC_E_SERVER_DIED_DNE;

    if (!IsStopped())
    {
        // On CoUninitialize this may fail when the window is destroyed.

        //02-05-2001 
        //Removed usage of SetLastError-GetLastError around the call to SendMessage; 
        //GetLastError is meaningful only if was called after an API that could set the last error
        //and that API failed
        //What we really care about here is if the message was successfully send to _hServerSTA
        //If SendMessage itself fails, it will return 0, otherwise it will return whatever ThreadWndProc
        //returns, after processing the message
        //So, in order to correctly interpret 0 as an error, ThreadWndProc will return a code different 
        //from 0 if it processed the message
        
        LRESULT lres = SendMessage(_hServerSTA, WM_OLE_ORPC_SEND,
                    WMSG_MAGIC_VALUE, (LPARAM) pCall);

		if(0 == lres) //lres 0 means that SendMessage itself had errors (ThreadWndProc returns a code different from 0 if it processes the message)
            hr = RPC_E_SERVER_DIED;
		else
			hr = S_OK;
    }

    ComDebOut((DEB_OXID, "OXIDEntry::SendCallToSTA this:%x pCall:%x hr:%x\n",
              this, pCall, hr));
    return hr;
}


#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     OXIDEntry::AssertValid, public
//
//  Synopsis:   ensures the state of the OXIDEntry is valid
//
//  History:    20-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
void OXIDEntry::AssertValid()
{
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::Initialize, public
//
//  Synopsis:
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::Initialize()
{
    ComDebOut((DEB_OXID, "COXIDTable::Initialize\n"));
    LOCK(gOXIDLock);

    // initialize the chains
    _InUseHead.ChainToSelf();
    _CleanupHead.ChainToSelf();
    _ExpireHead.ChainToSelf();

    // initialize the allocator
    OXIDEntry::_palloc.Initialize(sizeof(OXIDEntry), OXIDS_PER_PAGE, NULL);

    UNLOCK(gOXIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::Cleanup, public
//
//  Synopsis:   Cleanup the OXID table.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::Cleanup()
{
    ComDebOut((DEB_OXID, "COXIDTable::Cleanup\n"));
    LOCK(gOXIDLock);

    // the lists better be empty before we delete the entries
    AssertListsEmpty();
    OXIDEntry::_palloc.AssertEmpty();
    OXIDEntry::_palloc.Cleanup();

    UNLOCK(gOXIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::AddOXIDEntry, private
//
//  Synopsis:   Adds an entry to the OXID table. The entry is AddRef'd.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
HRESULT COXIDTable::AddOXIDEntry(REFOXID roxid, OXID_INFO *poxidInfo,
                                 MIDEntry *pMIDEntry, DWORD dwAuthSvc, OXIDEntry **ppEntry)
{
    Win4Assert(poxidInfo != NULL);
    Win4Assert(pMIDEntry != NULL);
    ASSERT_LOCK_HELD(gOXIDLock);
	
    *ppEntry = NULL;

    // find first free entry slot, grow table if necessary
    HRESULT hr = E_OUTOFMEMORY;
    OXIDEntry *pEntry = (OXIDEntry *) new OXIDEntry(roxid, pMIDEntry, poxidInfo, dwAuthSvc, hr);
    if (pEntry == NULL)
    {
        ComDebOut((DEB_ERROR,"Out Of Memory in COXIDTable::AddOXIDEntry\n"));
        return hr;
    }
    else if (FAILED(hr))
    {
        // Partially initialized oxidentries should never be cached; just
        // delete them immediately.
        UNLOCK(gOXIDLock);
        pEntry->ExpireEntry();
        LOCK(gOXIDLock);
        return hr;
    }

    // chain it on the list of inuse entries
    pEntry->AddToChain(&_InUseHead);

    *ppEntry = pEntry;

    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_OXID,"COXIDTable::AddOXIDEntry pEntry:%x moxid:%I\n",
                    pEntry, (pEntry) ? pEntry->GetMoxidPtr() : &GUID_NULL));
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::LookupOXID, private
//
//  Synopsis:   finds an entry in the OXID table with the given OXID.
//              This is used by the unmarshalling code. The returned
//              entry has been AddRef'd.
//
//  History:    02-Feb-95   Rickhi      Created
//
//  PERFWORK:   we could move the OXIDEntry to the head of the InUse list on
//              the assumption that it will be the most frequently used item
//              in the near future.
//
//-------------------------------------------------------------------------
OXIDEntry *COXIDTable::LookupOXID(REFOXID roxid, REFMID rmid)
{
    ASSERT_LOCK_HELD(gOXIDLock);

    MOXID moxid;
    MOXIDFromOXIDAndMID(roxid, rmid, &moxid);

    // first, search the InUse list.
    OXIDEntry *pEntry = SearchList(moxid, &_InUseHead);

    if (pEntry == NULL)
    {
        // not found on InUse list, search the Expire list.
        if ((pEntry = SearchList(moxid, &_ExpireHead)) != NULL)
        {
            // found it, unchain it from the list of Expire entries
            pEntry->RemoveFromChain();

            // Remove pending Release Flag
            pEntry->_dwFlags &= ~OXIDF_PENDINGRELEASE;
            pEntry->ResetExpiredTime();

            // chain it on the list of InUse entries
            pEntry->AddToChain(&_InUseHead);

            _cExpired--;
        }
    }

    ComDebOut((DEB_OXID,"COXIDTable::LookupOXID pEntry:%x moxid:%I\n",
                    pEntry, &moxid));
    gOXIDTbl.ValidateOXID();
    return pEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::SearchList, private
//
//  Synopsis:   Searches the specified list for a matching OXID entry.
//              This is a subroutine of LookupOXID.
//
//  History:    25-Aug-95   Rickhi      Created
//
//-------------------------------------------------------------------------
OXIDEntry *COXIDTable::SearchList(REFMOXID rmoxid, OXIDEntry *pStart)
{
    ASSERT_LOCK_HELD(gOXIDLock);

    OXIDEntry *pEntry = pStart->_pNext;
    while (pEntry != pStart)
    {
        if (InlineIsEqualGUID(rmoxid, pEntry->_moxid))
        {
            pEntry->IncRefCnt();
            return pEntry;      // found a match, return it
        }

        pEntry = pEntry->_pNext; // try next one in use
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::ReleaseOXIDEntry, public
//
//  Synopsis:   removes an entry from the OXID table InUse list and
//              places it on the Expire list. Entries on the Expire list
//              will be cleaned up by a worker thread at a later time, or
//              placed back on the InUse list by LookupOXID.
//              If called from an apartment thread, delete entries on the
//              cleanup list.  If called from a worker thread, don't release
//              the lock and skip the cleanup list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::ReleaseOXIDEntry(OXIDEntry *pOXIDEntry)
{
    Win4Assert(pOXIDEntry);
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_HELD(gOXIDLock);
    
    // if already being deleted, just ignore.
    if (!(pOXIDEntry->_dwFlags & OXIDF_PENDINGRELEASE))
    {
        pOXIDEntry->_dwFlags |= OXIDF_PENDINGRELEASE;

        // unchain it from the list of InUse entries
        pOXIDEntry->RemoveFromChain();

        // chain it on the *END* of the list of Expire entries, and
        // count one more expired entry.
        pOXIDEntry->AddToChain(&gOXIDTbl._ExpireHead);
        pOXIDEntry->SetExpiredTime();
        _cExpired++;

        // Free anything hanging around on the cleanup list.  This may release
        // the lock.
        FreeCleanupEntries();
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"COXIDTable::ReleaseOXIDEntry pEntry:%x\n", pOXIDEntry));
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::ReleaseOXIDEntryAndFreeIPIDs, public
//
//  Synopsis:   removes an entry from the OXID table InUse list and
//              places it on the Expire list. Entries on the Expire list
//              will be cleaned up by a worker thread at a later time, or
//              placed back on the InUse list by LookupOXID.
//              If called from an apartment thread, delete entries on the
//              cleanup list.  If called from a worker thread, don't release
//              the lock and skip the cleanup list.
//
//              Upon placing the OXID in the expire list, this routine
//              frees all the IPIDs associated with the OXID.  This prevents
//              runaway memory consumption in scenarios where clients create
//              lots of copies of the IUnknown proxy.
//
//  History:    07-Sep-99   JohnStra      Created
//
//-------------------------------------------------------------------------
void COXIDTable::ReleaseOXIDEntryAndFreeIPIDs(OXIDEntry* pOXIDEntry)
{
    Win4Assert(pOXIDEntry);
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_HELD(gOXIDLock);
    
    // if already being deleted, just ignore.
    if (!(pOXIDEntry->_dwFlags & OXIDF_PENDINGRELEASE))
    {
        pOXIDEntry->_dwFlags |= OXIDF_PENDINGRELEASE;

        // unchain it from the list of InUse entries
        pOXIDEntry->RemoveFromChain();

        // chain it on the *END* of the list of Expire entries, and
        // count one more expired entry.
        pOXIDEntry->AddToChain(&gOXIDTbl._ExpireHead);
        pOXIDEntry->SetExpiredTime();
        _cExpired++;

        // We want to free up all the IPID entries associated with this
        // OXIDEntry since we know that there are presently no references
        // on the OXIDEntry, thus the proxies are not being used.
        IRemUnknown* pRemUnk;
        HRESULT hr = pOXIDEntry->GetRemUnkNoCreate(&pRemUnk);
        if (SUCCEEDED(hr) && pRemUnk)
        {
            // Get the StdId for the remote unknown.
            CStdIdentity* pStdId;
            hr = pRemUnk->QueryInterface(IID_IStdIdentity, (void**)&pStdId);
            if (SUCCEEDED(hr))
            {
                // This releases the OXID lock.
                pStdId->ReleaseUnusedIPIDEntries();                    
                ASSERT_LOCK_NOT_HELD(gOXIDLock);
                
                pStdId->Release();
                
                // Reacquire the lock for FreeCleanupEntries.
                LOCK(gOXIDLock);
            }
        }        
        
        // Free anything hanging around on the cleanup list.  This may release
        // the lock and retake it.
        FreeCleanupEntries();    
    }

    ASSERT_LOCK_HELD(gOXIDLock);        
    ComDebOut((DEB_OXID,"COXIDTable::ReleaseOXIDEntryAndFreeIPIDs pEntry:%x\n", pOXIDEntry));
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::FreeExpiredEntries, public
//
//  Synopsis:   Walks the Expire list and deletes the OXIDEntries that
//              were placed on the expire list before the given time.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::FreeExpiredEntries(DWORD dwTime)
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);


    // Move all items from the expired list to the cleanup list
    while(_ExpireHead._pNext != &_ExpireHead)
    {
        // unchain it from the list of Expire entries and, count one less
        // expired entry.
        OXIDEntry *pEntry = _ExpireHead._pNext;
        _cExpired--;
        pEntry->RemoveFromChain();
        pEntry->AddToChain(&_CleanupHead);
    }

    // The bulk-update worker thread moves entries to the cleanup list while
    // holding the lock. Since the expire list is now empty no more OXIDs can be
    // added to the cleanup list. Now would be a good time to free items on the
    // cleanup list.
    FreeCleanupEntries();

    AssertListsEmpty();     // the lists better be empty now

    UNLOCK(gOXIDLock);

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "COXIDTable::FreeExpiredEntries dwTime:%x\n", dwTime));
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::FreeCleanupEntries, private
//
//  Synopsis:   Deletes all OXID entries on the Cleanup list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void COXIDTable::FreeCleanupEntries()
{
    ASSERT_LOCK_HELD(gOXIDLock);

    // release the entries in batches to reduce the number of locks/unlocks
    const int cCleanupSize = 25;
    OXIDEntry **ppCleanupList = (OXIDEntry **) _alloca(sizeof(OXIDEntry *)
                                                       * cCleanupSize);
    // _alloca never returns if it fails
    Win4Assert(ppCleanupList);

    // Cleanup the free list
    while (_CleanupHead._pNext != &_CleanupHead)
    {
        int iCleanupNum = 0;

        // Cleanup the free list
        while (_CleanupHead._pNext != &_CleanupHead)
        {
            // Unchain the entries and free all resources it holds.
            OXIDEntry *pEntry = _CleanupHead._pNext;
            pEntry->RemoveFromChain();
            ppCleanupList[iCleanupNum] = pEntry;
            ++iCleanupNum;
            if(iCleanupNum == cCleanupSize)
                break;
        }

        if(iCleanupNum)
        {
            UNLOCK(gOXIDLock);
            ASSERT_LOCK_NOT_HELD(gOXIDLock);

            // Cleanup entries
            for(int i=0;i<iCleanupNum;i++)
            {
                ComDebOut((DEB_OXID,
                           "Cleaning up OXID with PID:0x%x and TID:0x%x\n",
                           ppCleanupList[i]->GetPid(), ppCleanupList[i]->GetTid()));

                ppCleanupList[i]->ExpireEntry();
            }

            ASSERT_LOCK_NOT_HELD(gOXIDLock);
            LOCK(gOXIDLock);
        }
    }

    ComDebOut((DEB_OXID, "COXIDTable::FreeCleanupEntries\n"));
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTable::GetOxidsToRemove
//
//  Synopsis:   Builds a list of OXIDs old enough to be deleted.  Removes
//              them from the expired list and puts them on the cleanup list.
//              Moves machine local OXIDs directly to the cleanup list.
//
//  History:    03-Jun-42   AlexMit     Created
//
//-------------------------------------------------------------------------
void COXIDTable::GetOxidsToRemove(OXID_REF *pRef, DWORD *pcMaxRemoteToRemove)
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    // Expire entries until the expired list has been walked, or until
    // the passed in buffer has been filled up.
    DWORD dwLifeTime     = GetTickCount() - (BULK_UPDATE_RATE * 2);
    DWORD cRemoteRemoved = 0;

    OXIDEntry *pNextEntry = _ExpireHead._pNext;
    while (pNextEntry != &_ExpireHead)
    {
        // Get the entry and its next entry
        OXIDEntry *pEntry = pNextEntry;
        pNextEntry = pEntry->_pNext;

        // Ensure that the OXID entry stayed in the expired list for at least
        // one interation of bulk update loop
        if (pEntry->GetExpiredTime() > dwLifeTime)
            continue;

        // Only tell the resolver about machine remote OXIDs, since that
        // is all that it cares about.
        if (!(pEntry->IsOnLocalMachine()))
        {
            if (cRemoteRemoved >= *pcMaxRemoteToRemove)
            {
                // we have filled up the caller's buffer, so
                // leave the rest of the entries alone.
                break;
            }

            // Add the OXID to the list to deregister.
            MIDFromMOXID(pEntry->GetMoxid(), &pRef->mid);
            OXIDFromMOXID(pEntry->GetMoxid(), &pRef->oxid);
            pRef->refs = pEntry->_cResolverRef;
            pRef++;
            cRemoteRemoved++;
        }

        // Remove the OXID from the expired list and put it on a list
        // of OXIDs to be released by some apartment thread.
        _cExpired--;
        pEntry->RemoveFromChain();
        pEntry->AddToChain(&_CleanupHead);
    }

    // release any entries currently on the cleanup list
    FreeCleanupEntries();

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // update the caller's count of entries to remove
    *pcMaxRemoteToRemove = cRemoteRemoved;
}

//+------------------------------------------------------------------------
//
//  Member:     COXIDTbl::MakeServerEntry, public
//
//  Synopsis:   Creates a partially initialized entry in the OXID table for
//              the local apartment. The rest of the initialization is done
//              in Initialize.
//
//  History:    20-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
HRESULT COXIDTable::MakeServerEntry(OXIDEntry **ppOXIDEntry)
{
    ComDebOut((DEB_OXID, "COXIDTable::MakeServerEntry ppOXIDEntry:%x\n", ppOXIDEntry));
    ASSERT_LOCK_HELD(gOXIDLock);

    MIDEntry  *pMIDEntry;
    HRESULT hr = gMIDTbl.GetLocalMIDEntry(&pMIDEntry);

    if (SUCCEEDED(hr))
    {
        // NOTE: Chicken And Egg Problem.
        //
        // Marshaling needs the local OXIDEntry. The local OXIDEntry needs
        // the local OXID. To get the local OXID we have to call the resolver.
        // To call the resolver we need the IPID for IRemUnknown. To get the
        // IPID for IRemUnknown, we need to marshal CRemoteUnknown!
        //
        // To get around this problem, we create a local OXIDEntry (that has
        // a 0 OXID and NULL ipidRemUnknown) so that marshaling can find it.
        // Then we marshal the RemoteUnknown and extract its IPID value, stick
        // it in the local OXIDEntry. When we call the resolver (to get some
        // pre-registered OIDs) we get the real OXID value which we then stuff
        // in the local OXIDEntry.

        OXID_INFO oxidInfo;
        oxidInfo.dwTid          = GetCurrentApartmentId();
        oxidInfo.dwPid          = GetCurrentProcessId();
        oxidInfo.ipidRemUnknown = GUID_NULL;
        oxidInfo.version.MajorVersion = COM_MAJOR_VERSION;
        oxidInfo.version.MinorVersion = COM_MINOR_VERSION;
        oxidInfo.dwAuthnHint    = RPC_C_AUTHN_LEVEL_NONE;
        oxidInfo.dwFlags        = 0;
        oxidInfo.psa            = NULL;

        // NOTE: temp creation of OXID. We dont know the real OXID until
        // we call the resolver. So, we use 0 temporarily (it wont conflict
        // with any other MOXIDs we might be searching for because we already
        // have the real MID and our local resolver wont give out a 0 OXID).
        // The OXID will be replaced with the real one when we register
        // with the resolver in CRpcResolver::ServerRegisterOXID.

        OXID oxid;
        memset(&oxid, 0, sizeof(oxid));

        hr = AddOXIDEntry(oxid, &oxidInfo, pMIDEntry, RPC_C_AUTHN_DEFAULT, ppOXIDEntry);

        // Normally you do not want to hold gOXIDLock when dereferencing a
        // midentry; however, it is safe here since this will never be the last
        // release since we didn't release the lock after calling
        // GetLocalMIDEntry above.
        pMIDEntry->DecRefCnt();
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "COXIDTable::MakeServerEntry hr:%x pOXIDEntry:%x\n",
              hr, *ppOXIDEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     COXIDTable::MakeSCMEntry, public
//
//  Synopsis:   Makes and returns an OXIDEntry for the SCM process.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT COXIDTable::MakeSCMEntry(REFOXID roxid, OXID_INFO *poxidInfo,
                                 OXIDEntry **ppOXIDEntry)
{
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    // Get the local MIDEntry
    MIDEntry  *pMIDEntry;
    HRESULT hr = gMIDTbl.GetLocalMIDEntry(&pMIDEntry);
    if (SUCCEEDED(hr))
    {
        hr = AddOXIDEntry(roxid, poxidInfo, pMIDEntry, RPC_C_AUTHN_DEFAULT, ppOXIDEntry);

        // Normally you do not want to hold gOXIDLock when dereferencing a
        // midentry; however, it is safe here since this will never be the last
        // release since we didn't release the lock after calling
        // GetLocalMIDEntry above.
        pMIDEntry->DecRefCnt();
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     COXIDTable::ClientResolveOXID, public
//
//  Synopsis:   Resolve client-side OXID and returns the OXIDEntry, AddRef'd.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT COXIDTable::ClientResolveOXID(REFOXID roxid,
                                      DUALSTRINGARRAY *psaResolver,
                                      OXIDEntry **ppOXIDEntry)
{
    ComDebOut((DEB_OXID,"COXIDTable::ClientResolveOXID oxid:%08x %08x psa:%x\n",
               roxid, psaResolver));

    HRESULT hr = S_OK;
    *ppOXIDEntry = NULL;

    // Look for a MID entry for the resolver. if we cant find it
    // then we know we dont have an OXIDEntry for the oxid.

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    DWORD dwHash;
    MIDEntry *pMIDEntry = gMIDTbl.LookupMID(psaResolver, &dwHash);
    if (pMIDEntry)
    {
        // found the MID, now look for the OXID
        *ppOXIDEntry = LookupOXID(roxid, pMIDEntry->GetMid());
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    if (*ppOXIDEntry == NULL)
    {
        // didn't find the OXIDEntry in the table so we need to resolve it.
        MID       mid;
        OXID_INFO oxidInfo;
        USHORT    usAuthnSvc;  
        oxidInfo.psa = NULL;

        hr = gResolver.ClientResolveOXID(roxid, &oxidInfo, &mid, psaResolver, &usAuthnSvc);

        if (SUCCEEDED(hr))
        {
            // create an OXIDEntry.
            hr = FindOrCreateOXIDEntry(roxid, oxidInfo, FOCOXID_REF,
                                       psaResolver,
                                       mid, pMIDEntry, usAuthnSvc, ppOXIDEntry);

            // free the returned string bindings
            MIDL_user_free(oxidInfo.psa);
        }
    }

    if (pMIDEntry)
    {
        pMIDEntry->DecRefCnt();
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"COXIDTable::ClientResolveOXID hr:%x pOXIDEntry:%x\n",
        hr, *ppOXIDEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   FindOrCreateOXIDEntry
//
//  Synopsis:   finds or adds an OXIDEntry for the given OXID. May
//              also create a MIDEntry if one does not yet exist.
//
//  History:    22-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT COXIDTable::FindOrCreateOXIDEntry(REFOXID roxid,
                              OXID_INFO &oxidInfo,
                              FOCOXID   eResolverRef,
                              DUALSTRINGARRAY *psaResolver,
                              REFMID    rmid,
                              MIDEntry  *pMIDEntry,
                              DWORD     dwAuthSvcToUseIfOxidNotFound,
                              OXIDEntry **ppOXIDEntry)
{
    ComDebOut((DEB_OXID,"FindOrCreateOXIDEntry oxid:%08x %08x oxidInfo:%x psa:%ws pMIDEntry:%x\n",
               roxid, &oxidInfo, psaResolver, pMIDEntry));
    ValidateOXID();

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    HRESULT hr = S_OK;
    BOOL    fReleaseMIDEntry = FALSE;

    // check if the OXIDEntry was created while we were resolving it.
    *ppOXIDEntry = LookupOXID(roxid, rmid);

    if (*ppOXIDEntry == NULL)
    {
        if (pMIDEntry == NULL)
        {
            // dont yet have a MIDEntry for the machine so go add it
            hr = gMIDTbl.FindOrCreateMIDEntry(rmid, psaResolver, &pMIDEntry);
            fReleaseMIDEntry = TRUE;
        }

        if (pMIDEntry)
        {
            // add a new OXIDEntry
            hr = AddOXIDEntry(roxid, &oxidInfo, pMIDEntry, dwAuthSvcToUseIfOxidNotFound, ppOXIDEntry);
        }
    }

    if (SUCCEEDED(hr) && eResolverRef == FOCOXID_REF)
    {
        // Increment the count of references handed to us from the resolver.
        (*ppOXIDEntry)->IncResolverRef();
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    if (fReleaseMIDEntry && pMIDEntry)
    {
        // undo the reference added by FindOrCreateMIDEntry
        pMIDEntry->DecRefCnt();
    }

    ValidateOXID();
    ComDebOut((DEB_OXID,"FindOrCreateOXIDEntry pOXIDEntry:%x hr:%x\n",
        *ppOXIDEntry, hr));
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   UpdateCachedLocalMIDEntries, public
//
//  Synopsis:   Queries the mid table for the current local mid entry; then
//              walks all current oxids in the table; any that have cached
//              pointers to the (old) local mid entry are updated with 
//              the current one.
//
//  History:    27-Nov-00  JSimmons     Created
//
//-------------------------------------------------------------------------
HRESULT COXIDTable::UpdateCachedLocalMIDEntries()
{
    const DWORD INITIAL_MIDENTRY_ARRAY_SIZE = 100;
    const DWORD MIDENTRY_ARRAY_INCREMENT = 100;
    HRESULT hr;
    MIDEntry* pCurrentLocalMIDEntry;
    OXIDEntry* pNextEntry;
    MID localMID;
    DWORD dwcOldMIDEntries = INITIAL_MIDENTRY_ARRAY_SIZE;
    DWORD dwCurrentOldMIDEntry = 0;
    MIDEntry** ppOldMIDEntries;
    DWORD i;

    // No need to walk the cleanup list, those oxid entries
    // will be going away soon anyway
    OXIDEntry* pListHeads[] = { &_InUseHead, &_ExpireHead };

    // Allocate an array to hold the old mid entries returned
    // to us by the oxid entries.  This is because you're not
    // supposed to release mid entries inside of gOXIDLock....
    ppOldMIDEntries = new MIDEntry*[dwcOldMIDEntries];
    if (!ppOldMIDEntries)
        return E_OUTOFMEMORY;
    
    ZeroMemory(ppOldMIDEntries, dwcOldMIDEntries * sizeof(MIDEntry*));
    
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);
    
    // Get the current local mid entry
    hr = gMIDTbl.GetLocalMIDEntry(&pCurrentLocalMIDEntry);
    if (SUCCEEDED(hr))
    {    
        Win4Assert(pCurrentLocalMIDEntry);
    
        // Save the mid id
        localMID = pCurrentLocalMIDEntry->GetMid();
    
        for (i = 0; i < sizeof(pListHeads) / sizeof(OXIDEntry*); i++)
        {
            pNextEntry = pListHeads[i]->_pNext;
            while (pNextEntry != pListHeads[i])
            {
                if (pNextEntry->GetMid() == localMID)
                {
                    // Check if we need to grow our array
                    if (dwCurrentOldMIDEntry == dwcOldMIDEntries)
                    {
                        MIDEntry** ppNewArray;
                        DWORD dwcNewArraySize = dwcOldMIDEntries + MIDENTRY_ARRAY_INCREMENT;
                        ppNewArray = new MIDEntry*[dwcNewArraySize];
                        if (!ppNewArray)
                        {
                            // break out of the loop. no more work will be done, 
                            // but we will cleanup what we already have saved
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        
                        // Clear new memory
                        ZeroMemory(ppNewArray, dwcNewArraySize * sizeof(MIDEntry*));
                        // Copy entries from old array
                        CopyMemory(ppNewArray, ppOldMIDEntries, dwcOldMIDEntries * sizeof(MIDEntry*));
                        // Delete old memory
                        delete ppOldMIDEntries;
                        // Update state
                        ppOldMIDEntries = ppNewArray;
                        dwcOldMIDEntries = dwcNewArraySize;                 
                    }

                    // Update the oxidentry, and save its previous
                    // mid entry for later release outside the lock
                    ppOldMIDEntries[dwCurrentOldMIDEntry++] = 
                        pNextEntry->UpdateMIDEntry(pCurrentLocalMIDEntry);
                }
                pNextEntry = pNextEntry->_pNext;
            }

            // If we broke out of the while loop with a failure,
            // then break out of the for loop as well.
            if (FAILED(hr))
            {
                break;
            }
        }        
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    
    // Release mid entries outside of gOXIDLock
    if (pCurrentLocalMIDEntry)
        pCurrentLocalMIDEntry->DecRefCnt();

    for (i = 0; i < dwCurrentOldMIDEntry; i++)
    {
        Win4Assert(ppOldMIDEntries[i]);
        if (ppOldMIDEntries[i])
        {
            ppOldMIDEntries[i]->DecRefCnt();
        }
    }

    delete ppOldMIDEntries;

    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   GetLocalOXIDEntry, public
//
//  Synopsis:   Get either the global or the TLS OXIDEntry based on the
//              threading model of the current thread.
//
//  History:    05-May-95  AlexMit      Created
//              11-Feb-98  JohnStra     Made NTA aware
//
//-------------------------------------------------------------------------
INTERNAL GetLocalOXIDEntry(OXIDEntry **ppOXIDEntry)
{
    ComDebOut((DEB_OXID,"GetLocalOXIDEntry ppOXIDEntry:%x\n", ppOXIDEntry));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    *ppOXIDEntry = NULL;

    CComApartment *pComApt;
    HRESULT hr = GetCurrentComApartment(&pComApt);

    if (SUCCEEDED(hr))
    {
        hr = pComApt->GetOXIDEntry(ppOXIDEntry);
        pComApt->Release();
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"GetLocalOXIDEntry hr:%x pOXIDEntry:%x\n",
              *ppOXIDEntry, hr));
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     MIDEntry::DecRefCnt, public
//
//  Synopsis:   Decement the number of references and release if zero
//
//  History:    02-Feb-96   Rickhi      Created
//              14-Dec-98   GopalK      Interlock destruction
//
//-------------------------------------------------------------------------
DWORD MIDEntry::DecRefCnt()
{
    ComDebOut((DEB_OXID, "MIDEntry::DecRefCnt %x cRefs[%x]\n", this, _cRefs));

    // decrement the refcnt. if the refcnt went to zero it will be marked
    // as being in the dtor, and fTryToDelete will be true.
    ULONG cNewRefs;
    BOOL fTryToDelete = InterlockedDecRefCnt(&_cRefs, &cNewRefs);

    while (fTryToDelete)
    {
        // refcnt went to zero, try to delete this entry
        BOOL fActuallyDeleted = FALSE;

        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        LOCK(gOXIDLock);

        if (_cRefs == CINDESTRUCTOR)
        {
            // the refcnt did not change while we acquired the lock.
            // OK to delete. Move the entry to the free list
            gMIDTbl.ReleaseMIDEntry(this);
            fActuallyDeleted = TRUE;
        }

        UNLOCK(gOXIDLock);
        ASSERT_LOCK_NOT_HELD(gOXIDLock);

        if (fActuallyDeleted == TRUE)
            break;  // all done. the entry has been deleted.

        // the entry was not deleted because some other thread changed
        // the refcnt while we acquired the lock. Try to restore the refcnt
        // to turn off the CINDESTRUCTOR bit. Note that this may race with
        // another thread changing the refcnt, in which case we may decide to
        // try to loop around and delete the object once again.
        fTryToDelete = InterlockedRestoreRefCnt(&_cRefs, &cNewRefs);
    }

    return (cNewRefs & ~CINDESTRUCTOR);
}


//+------------------------------------------------------------------------
//
//  Function:   CleanupMIDEntry
//
//  Synopsis:   Called by the MID hash table when cleaning up any leftover
//              entries.
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CleanupMIDEntry(SHashChain *pNode)
{
    gMIDTbl.ReleaseMIDEntry((MIDEntry *)pNode);
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTbl::Initialize, public
//
//  Synopsis:   Initializes the MID table.
//
//  History:    02-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CMIDTable::Initialize()
{
    ComDebOut((DEB_OXID, "CMIDTable::Initialize\n"));
    LOCK(gOXIDLock);
    _HashTbl.Initialize(MIDBuckets, &gOXIDLock);
    _palloc.Initialize(sizeof(MIDEntry), MIDS_PER_PAGE, NULL);
    UNLOCK(gOXIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTbl::Cleanup, public
//
//  Synopsis:   Cleanup the MID table.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CMIDTable::Cleanup()
{
    ComDebOut((DEB_OXID, "CMIDTable::Cleanup\n"));

    if (_pLocalMIDEntry)
    {
        // release the local MIDEntry
        MIDEntry *pMIDEntry = _pLocalMIDEntry;
        _pLocalMIDEntry = NULL;
        pMIDEntry->DecRefCnt();
    }

    LOCK(gOXIDLock);
    _HashTbl.Cleanup(CleanupMIDEntry);
    _palloc.Cleanup();
    UNLOCK(gOXIDLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::LookupMID, public
//
//  Synopsis:   Looks for existing copy of the string array in the MID table.
//
//  History:    05-Jan-96   Rickhi      Created
//
//-------------------------------------------------------------------------
MIDEntry *CMIDTable::LookupMID(DUALSTRINGARRAY *psaResolver, DWORD *pdwHash)
{
    ComDebOut((DEB_OXID, "CMIDTable::LookupMID psa:%x\n", psaResolver));
    Win4Assert(psaResolver != NULL);
    ASSERT_LOCK_HELD(gOXIDLock);

    *pdwHash = _HashTbl.Hash(psaResolver);
    MIDEntry *pMIDEntry = (MIDEntry *) _HashTbl.Lookup(*pdwHash, psaResolver);

    if (pMIDEntry)
    {
        // found the node, AddRef it and return
        pMIDEntry->IncRefCnt();
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CMIDTable::LookupMID pMIDEntry:%x\n", pMIDEntry));
    return pMIDEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::FindOrCreateMIDEntry, public
//
//  Synopsis:   Looks for existing copy of the string array in the MID table,
//              creates one if not found
//
//  History:    05-Jan-96   Rickhi      Created
//
//-------------------------------------------------------------------------
HRESULT CMIDTable::FindOrCreateMIDEntry(REFMID rmid,
                                        DUALSTRINGARRAY *psaResolver,
                                        MIDEntry **ppMIDEntry)
{
    ComDebOut((DEB_OXID, "CMIDTable::FindOrCreateMIDEntry psa:%x\n", psaResolver));
    Win4Assert(psaResolver != NULL);
    ASSERT_LOCK_HELD(gOXIDLock);

    HRESULT hr = S_OK;
    DWORD   dwHash;

    *ppMIDEntry = LookupMID(psaResolver, &dwHash);

    if (*ppMIDEntry == NULL)
    {
        hr = AddMIDEntry(rmid, dwHash, psaResolver, ppMIDEntry);
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CMIDTable::FindOrCreateEntry pMIDEntry:%x hr:%x\n", *ppMIDEntry, hr));
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::AddMIDEntry, private
//
//  Synopsis:   Adds an entry to the MID table. The entry is AddRef'd.
//
//  History:    05-Jan-96   Rickhi      Created
//
//-------------------------------------------------------------------------
HRESULT CMIDTable::AddMIDEntry(REFMID rmid, DWORD dwHash,
                               DUALSTRINGARRAY *psaResolver,
                               MIDEntry **ppMIDEntry)
{
    ComDebOut((DEB_OXID, "CMIDTable::AddMIDEntry rmid:%08x %08x dwHash:%x psa:%x\n",
              rmid, dwHash, psaResolver));
    Win4Assert(psaResolver != NULL);
    ASSERT_LOCK_HELD(gOXIDLock);

    // We must make a copy of the psa to store in the table, since we are
    // using the one read in from ReadObjRef (or allocated by MIDL).

    DUALSTRINGARRAY *psaNew;
    HRESULT hr = CopyStringArray(psaResolver, NULL, &psaNew);
    if (FAILED(hr))
        return hr;

    MIDEntry *pMIDEntry = (MIDEntry *) _palloc.AllocEntry();

    if (pMIDEntry)
    {
        pMIDEntry->Init(rmid);

        // add the entry to the hash table
        _HashTbl.Add(dwHash, psaNew, pMIDEntry->GetHashNode());

        hr = S_OK;

        // set the maximum size of any resolver PSA we have seen. This is used
        // when computing the max marshal size during interface marshaling.

        DWORD dwpsaSize = SASIZE(psaNew->wNumEntries);
        if (dwpsaSize > gdwPsaMaxSize)
        {
            gdwPsaMaxSize = dwpsaSize;
        }
    }
    else
    {
        // cant create a MIDEntry, free the copy of the string array.
        PrivMemFree(psaNew);
        hr = E_OUTOFMEMORY;
    }

    *ppMIDEntry = pMIDEntry;

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CMIDTable::AddMIDEntry pMIDEntry:%x hr:%x\n", *ppMIDEntry, hr));
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::ReleaseMIDEntry, public
//
//  Synopsis:   remove the MIDEntry from the hash table and free the memory
//
//  History:    05-Jan-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CMIDTable::ReleaseMIDEntry(MIDEntry *pMIDEntry)
{
    ComDebOut((DEB_OXID, "CMIDTable::ReleaseMIDEntry pMIDEntry:%x\n", pMIDEntry));
    pMIDEntry->AssertInDestructor();
    ASSERT_LOCK_HELD(gOXIDLock);

    // delete the string array
    PrivMemFree(pMIDEntry->Getpsa());

    // remove from the hash chain and delete the node
    _HashTbl.Remove(&pMIDEntry->GetHashNode()->chain);

    _palloc.ReleaseEntry((PageEntry *)pMIDEntry);
}

//+------------------------------------------------------------------------
//
//  Method:     CMIDTable::GetLocalMIDEntry, public
//
//  Synopsis:   Get or create the MID (Machine ID) entry for the local
//              machine. _pLocalMIDEntry holds the network address for the
//              local OXID resolver.
//
//  History:    05-Jan-96  Rickhi       Created
//
//-------------------------------------------------------------------------
HRESULT CMIDTable::GetLocalMIDEntry(MIDEntry **ppMIDEntry)
{
    ASSERT_LOCK_HELD(gOXIDLock);
    HRESULT hr = S_OK;

    if (_pLocalMIDEntry == NULL)
    {
        // make sure we have the local resolver string bindings
        hr = gResolver.GetConnection();
        if (SUCCEEDED(hr))
        {
            CDualStringArray* pdsaLocalResolver;  // current bindings for resolver

            hr = gResolver.GetLocalResolverBindings(&pdsaLocalResolver);
            if (SUCCEEDED(hr))
            {
                // Create a MID entry for the Local Resolver
                hr = gMIDTbl.FindOrCreateMIDEntry(gLocalMid, pdsaLocalResolver->DSA(),
                                                  &_pLocalMIDEntry);

                pdsaLocalResolver->Release();
            }
        }
    }

    // Now we always return an addref'd midentry
    if (_pLocalMIDEntry)
        _pLocalMIDEntry->IncRefCnt();

    *ppMIDEntry = _pLocalMIDEntry;

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CMIDTable::ReplaceLocalEntry
//
//  Synopsis:   Replaces the current _LocalMidEntry member with a new one
//              created from the supplied bindings.
//
//  History:    10-Oct-00   JSimmons   Created
//
//-------------------------------------------------------------------------
HRESULT CMIDTable::ReplaceLocalEntry(DUALSTRINGARRAY* pdsaResolver)
{
    ComDebOut((DEB_OXID,"CMIDTable::ReplaceLocalEntry psa:%x\n",pdsaResolver));

    HRESULT hr = S_OK;
    MIDEntry* pMIDEntry;
    DWORD dwHash;
    BOOL bNeedToReplace = TRUE;
    MIDEntry* pOldLocalMIDEntry = NULL;
	
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);
    ASSERT_LOCK_HELD(gOXIDLock);
    
    // If we are doing this, then we should probably 
    // have an existing local mid entry
    Win4Assert(_pLocalMIDEntry);

    // Check to see if we already have the correct entry
    // cached.  Cannot use the resolver hash for this, due
    // to collisions.
    if (_pLocalMIDEntry)
    {       
        // Only replace if they are different
        bNeedToReplace = !DSACompare(
                              _pLocalMIDEntry->GetHashNode()->psaKey,
                              pdsaResolver);                                 
    }

    if (bNeedToReplace)
    {
        // Get hash for new bindings
        dwHash = _HashTbl.Hash(pdsaResolver);

        // First see if this entry is still hanging 
        // around in the table.
        pMIDEntry = LookupMID(pdsaResolver, &dwHash);
        if (!pMIDEntry)
        {
            // It's not, add it
            ASSERT_LOCK_HELD(gOXIDLock);
            hr = AddMIDEntry(gLocalMid,
                             dwHash,
                             pdsaResolver,
                             &pMIDEntry);
        }
            
        if (SUCCEEDED(hr))
        {
            // Replace local entry with the new one
            pOldLocalMIDEntry = _pLocalMIDEntry;
            _pLocalMIDEntry = pMIDEntry;
        }
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // Release the old local mid entry outside the lock
    if (pOldLocalMIDEntry)
        pOldLocalMIDEntry->DecRefCnt();

    ComDebOut((DEB_OXID, "CMIDTable::ReplaceLocalEntry _pLocalMIDEntry:%x hr:%x\n",
                          _pLocalMIDEntry, hr));
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDualStringArray methods
//

DWORD CDualStringArray::AddRef()
{
    DWORD cRef = InterlockedIncrement(&_cRef);
    return cRef;
}

DWORD CDualStringArray::Release()
{
    DWORD cRef = InterlockedDecrement(&_cRef);
    if (cRef == 0)
    {
        delete this;
    }
    return cRef;
}

CDualStringArray::~CDualStringArray()
{
    PrivMemFree(_pdsa);
}

// Helper function for allocating and copying dualstringarrays
HRESULT CopyDualStringArray(DUALSTRINGARRAY *psa, DUALSTRINGARRAY **ppsaNew)
{
    DWORD ulSize = sizeof(USHORT) + 
                   sizeof(USHORT) + 
                   (psa->wNumEntries * sizeof(WCHAR));
    
    *ppsaNew = (DUALSTRINGARRAY*)PrivMemAlloc(ulSize);
    if (*ppsaNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(*ppsaNew, psa, ulSize);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\crossctx.cxx ===
//+-------------------------------------------------------------------
//
//  File:       CrossCtx.cxx
//
//  Contents:   Cross context data structures
//
//  Classes:    CStdWrapper
//              CCtxChnl
//
//  History:    19-Jan-98   Gopalk      Created
//              30-Sep-98   TarunA      Lightweight p/s
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <crossctx.hxx>
#include <ctxchnl.hxx>
#include <riftbl.hxx>
#include <actprops.hxx>
#include <callobj.h>        // Callframe aka inteceptor routines
#include <excepn.hxx>       // Exception filter routines

#if DBG==1
#define INTERCEPT_NOINOUT 0x00000001
#define INTERCEPT_NOIDISP 0x00000002
#define INTERCEPT_ON      0x10000000
ULONG g_dwInterceptLevel = INTERCEPT_ON | INTERCEPT_NOINOUT;
#endif

// Forward declaration
EXTERN_C HRESULT ProxyDllGetClassObject(REFCLSID clsid, REFIID riid, void **ppv);

#define CROSSCTX_SIGNATURE     (0x4E535956)

extern INTERNAL ICoGetClassObject(
    REFCLSID rclsid,
    DWORD dwContext,
    COSERVERINFO * pvReserved,
    REFIID riid,
    DWORD dwActvFlags,
    void FAR* FAR* ppvClassObj,
    ActivationPropertiesIn *pActIn);

extern INTERNAL CleanupLeakedDomainStack (COleTls& Tls, CObjectContext* pCorrectCtx);

//+-------------------------------------------------------------------
//
// Class globals
//
//+-------------------------------------------------------------------
CPageAllocator CtxEntry::s_allocator;        // Allocator for CtxEntries
COleStaticMutexSem CtxEntry::s_allocLock(TRUE); // Lock for the CPageAllocator
BOOL           CtxEntry::s_fInitialized;     // Relied on being FALSE
ULONG          CtxEntry::s_cEntries;         // Relied on being 0

CPageAllocator CStdWrapper::s_allocator;     // Allocator for wrapper objects
CPageAllocator IFaceEntry::s_allocator;      // Allocator for IFaceEntries
BOOL           CStdWrapper::s_fInitialized;  // Relied on being FALSE
DWORD          CStdWrapper::s_cObjects;      // Relied on being 0

CPageAllocator CCtxChnl::s_allocator;        // Allocator for context channel
#if DBG==1
ULONG          CCtxChnl::s_cChannels;        // Relied on being 0
#endif
CStaticWrapper *gpStaticWrapper;            // Global static wrapper object

extern "C"
HRESULT __stdcall CoGetInterceptorForOle32(REFIID, 
										   IUnknown *, 
										   REFIID, 
										   void**);
   
//+-------------------------------------------------------------------
//
//  Method:     CtxEntry::DeleteCtxEntries     public
//
//  Synopsis:   Deletes all the context entries chained off the given
//              head
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CtxEntry::DeleteCtxEntries(CtxEntry *&pHead, DWORD dwFlags)
{
    if (!(dwFlags & CTXENTRYFLAG_PRIVLOCKED))
    {
        ASSERT_LOCK_HELD(gComLock);
    }

    CtxEntry *pEntry, *pNext;

    // Sanity check
    Win4Assert(pHead);

    // Loop through the list and delete each entry
    // after preparing it for destruction
    pEntry = pHead;
    do
    {
        pNext = pEntry->_pNext;
        delete pEntry;
        pEntry = pNext;
    } while(pEntry != NULL);

    if (!(dwFlags & CTXENTRYFLAG_PRIVLOCKED))
    {
        ASSERT_LOCK_HELD(gComLock);
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CtxEntry::PrepareCtxEntries     public
//
//  Synopsis:   Prepares all the context entries chained off the given
//              head for destruction
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CtxEntry::PrepareCtxEntries(CtxEntry *pHead, DWORD dwFlags)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    CtxEntry *pEntry, *pNext;

    // Sanity check
    Win4Assert(pHead);

    // Loop through the list and delete each entry
    // after preparing it for destruction
    pEntry = pHead;
    do
    {
        if(dwFlags & CTXENTRYFLAG_IDENTRY)
        {
            Win4Assert((pEntry->_cRefs == 0) || (dwFlags & CTXENTRYFLAG_DISCONNECTED));
            if(pEntry->_pPS)
                pEntry->_pPS->Release();
        }
        pEntry->_pPS = NULL;

        if (pEntry->_pLife)
        {
            pEntry->_pLife->Release();
            pEntry->_pLife = NULL;
        }

        pEntry = pEntry->_pNext;
    } while(pEntry != NULL);

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CtxEntry::LookupEntry     public
//
//  Synopsis:   Looks up the context entry with the given context as
//              the client context
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CtxEntry *CtxEntry::LookupEntry(CtxEntry *pHead, CObjectContext *pClientCtx, 
                                CtxEntry **ppFreeList, DWORD dwFlags)
{
    ASSERT_LOCK_DONTCARE(gComLock);
    Win4Assert(pHead);

    // Loop through the list till an entry with the given client
    // context is found
    CtxEntry *pFound = NULL, *pEntry = pHead;
    do
    {
        if((pEntry->_pPS != NULL) &&
           (pEntry->_pPS->GetClientContext() == pClientCtx) &&
           (!pEntry->_pPS->IsMarkedForDestruction()))
        {
            pFound = pEntry;
            break;
        }

        // If there is a lifetime object here, ping it....
        // This path is used by CStdMarshal.
        if (pEntry->_pLife && ppFreeList)
        {
            if (!pEntry->_pLife->IsAlive())
            {
                // Release our reference on the policy set.
                if (dwFlags & CTXENTRYFLAG_IDENTRY)
                    pEntry->_pPS->Release();
                pEntry->AddToFreeList(ppFreeList, dwFlags);
            }
        }

        pEntry = pEntry->_pNext;
    }
    while(pEntry != NULL);

    return(pFound);
}


//+-------------------------------------------------------------------
//
//  Method:     IFaceEntry::IFaceEntry     public
//
//  Synopsis:   Constructor
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
IFaceEntry::IFaceEntry(IFaceEntry *pNext,
                       void *pProxy, IRpcProxyBuffer *pRpcProxy,
                       void *pServer, IRpcStubBuffer *pRpcStub,
                       REFIID riid, CCtxChnl *pCtxChnl,
                       ICallInterceptor* pInterceptor,
                       IUnknown* pUnkInner)
{
    ASSERT_LOCK_HELD(gComLock);

    CStdWrapper *pWrapper;

    // Obtain the wrapper object
    pWrapper = pCtxChnl->GetWrapper();

    // Assert that the current context is the server context
    Win4Assert(pWrapper->GetServerContext() == GetCurrentContext());

    // Initialize
    _pNext = pNext;
    _iid = riid;
    _pHead = NULL;
    _pFreeList = NULL;

    // Save client side pointers
    _pProxy = pProxy;
    _pRpcProxy = pRpcProxy;

    // Save server side pointers
    _pServer = pServer;
    _pRpcStub = pRpcStub;

    // Save channel pointer
    _pCtxChnl = pCtxChnl;

    // Initialize lightweight p/s variables
    _pInterceptor = pInterceptor;
    _pUnkInner = pUnkInner;

    ASSERT_LOCK_HELD(gComLock);
}

//+-------------------------------------------------------------------
//
//  Method:     IFaceEntry::PrepareForDestruction     public
//
//  Synopsis:   Cleanup state associated with an IFaceEntry
//
//  History:    19-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void IFaceEntry::PrepareForDestruction()
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Obtain the wrapper object
    CStdWrapper *pWrapper = _pCtxChnl->GetWrapper();

    // Assert that the current context is the server context
    Win4Assert(pWrapper->IsDisconnected() ||
               pWrapper->GetServerContext()==GetCurrentContext());

    // Release client side pointers
    pWrapper->InternalAddRef();
    ((IUnknown *) _pProxy)->Release();

    // Release the interceptor and the associated inner object and
    // any sinks that are registered with it
    if(_pInterceptor)
    {
        // This will decrement the refcount on the sink which in
        // our case is the channel
        _pInterceptor->RegisterSink(NULL);
        pWrapper->InternalAddRef();
        ((IUnknown *) _pInterceptor)->Release();
    }

    if(_pUnkInner)
        _pUnkInner->Release();

    // Release proxy/stub pointers
    if(_pRpcProxy)
    {
        _pRpcProxy->Disconnect();
        _pRpcProxy->Release();
    }

    if(_pRpcStub)
    {
        // Release server side pointers
        _pRpcStub->Disconnect();
        _pRpcStub->Release();
    }

    // Prepare CtxEntries associated with this IFaceEntry for
    // destruction
    if(_pHead)
        CtxEntry::PrepareCtxEntries(_pHead, CTXENTRYFLAG_STDWRAPPER);

    if(_pServer)
        ((IUnknown *) _pServer)->Release();

    // Release channel
    _pCtxChnl->Release();

#if DBG==1
    _pProxy = NULL;
    _pRpcProxy = NULL;
    _pRpcStub = NULL;
    _pServer = NULL;
    _pCtxChnl = NULL;
    _pInterceptor = NULL;
    _pUnkInner = NULL;
#endif

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Initialize     public
//
//  Synopsis:   Initializes allocators for CtxEntries, IFaceEntries
//              and wrapper objects. Also initializes ID tables
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::Initialize()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Acquire lock
    LOCK(gComLock);

    // Sanity check
    Win4Assert(s_fInitialized == FALSE);

    // Initialize the allocators only if needed
    if(s_cObjects == 0)
    {
        // Initialize CtxEntries
        CtxEntry::Initialize();

        // Initialize IFaceEntry allocator
        IFaceEntry::s_allocator.Initialize(sizeof(IFaceEntry),
                                           IFACEENTRIES_PER_PAGE,
                                           &gComLock);
        // Initialize allocator for wrapper
        s_allocator.Initialize(sizeof(CStdWrapper), WRAPPERS_PER_PAGE,
                               &gComLock);

        // Initialize context channel
        CCtxChnl::Initialize();
    }

    // Initialize ID tables
    gPIDTable.Initialize();
    gOIDTable.Initialize();

    // Mark the state as initialized
    s_fInitialized = TRUE;

    // Release lock
    UNLOCK(gComLock);

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::operator new     public
//
//  Synopsis:   new operator of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CStdWrapper::operator new(size_t size)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::operator new\n"));
    
    ASSERT_LOCK_HELD(gComLock);

    void *pv;

    // CStdWrapper can be inherited only by those objects
    // with overloaded new and delete operators
    Win4Assert(size == sizeof(CStdWrapper) &&
               "CStdWrapper improperly inherited");

    // Ensure that wrappers have been initialized
    Win4Assert(s_fInitialized);

    // Allocate memory
    pv = (void *) s_allocator.AllocEntry();
    if(pv)
        ++s_cObjects;

    ASSERT_LOCK_HELD(gComLock);
    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::operator delete     public
//
//  Synopsis:   delete operator of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::operator delete(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::operator delete\n"));
    ASSERT_LOCK_HELD(gComLock);

#if DBG==1
    // Ensure that the pv was allocated by the allocator
    // CStdWrapper can be inherited only by those objects
    // with overloaded new and delete operators
    LONG index = s_allocator.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1);
#endif

    // Release the pointer
    s_allocator.ReleaseEntry((PageEntry *) pv);
    --s_cObjects;
    // Cleanup if needed
    if(s_fInitialized==FALSE && s_cObjects==0)
        PrivateCleanup();

    ASSERT_LOCK_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Cleanup     public
//
//  Synopsis:   Cleanup allocator of wrapper objects and
//              ID tables
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::Cleanup()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Acquire lock
    LOCK(gComLock);

    // Check if initialized
    if(s_fInitialized)
    {
        // Ensure that there are no wrapper objects
        if(s_cObjects == 0)
            PrivateCleanup();

        // Cleanup ID tables
        gPIDTable.Cleanup();
        gOIDTable.Cleanup();

        // Reset state
        s_fInitialized = FALSE;
    }

    // Release lock
    UNLOCK(gComLock);

    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::PrivateCleanup     private
//
//  Synopsis:   Cleanup allocator of wrapper objects and
//              ID tables
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::PrivateCleanup()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::PrivateCleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Delete static wrapper
    if(gpStaticWrapper)
    {
        delete gpStaticWrapper;
        gpStaticWrapper = NULL;
    }

    // Cleanup allocators
    IFaceEntry::s_allocator.Cleanup();
    s_allocator.Cleanup();

    // Cleanup CtxEntries
    CtxEntry::Cleanup();

    // Cleanup context channel
    CCtxChnl::Cleanup();

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::CStdWrapper     public
//
//  Synopsis:   Constructor of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CStdWrapper::CStdWrapper(IUnknown *pServer, DWORD dwState, CIDObject *pID)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::CStdWrapper this:%x\n",this));
    ASSERT_LOCK_HELD(gComLock);

    _dwState       = dwState;
    _cRefs         = 1;
    _cCalls        = 0;
    _cIFaces       = 0;
    _pIFaceHead    = NULL;
    _pCtxEntryHead = NULL;
    _pCtxFreeList  = NULL;

    _pServer       = pServer;
    if (_pServer)
        _pServer->AddRef();

    _pID = pID;
    _pID->SetWrapper(this);
    _pID->AddRef();

    ASSERT_LOCK_HELD(gComLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::~CStdWrapper     private
//
//  Synopsis:   Destructor of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CStdWrapper::~CStdWrapper()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::~CStdWrapper this:%x\n",this));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity checks
    Win4Assert(_pID == NULL);
    Win4Assert(_pServer == NULL);

    // Delete IFaceEntries
    IFaceEntry *pIFEntry = _pIFaceHead;
    while(pIFEntry)
    {
        // Save next entry
        IFaceEntry *pIFNext = pIFEntry->_pNext;
        delete pIFEntry;
        --_cIFaces;
        pIFEntry = pIFNext;
    }
    Win4Assert(_cIFaces == 0);

    // Delete context entries
    if(_pCtxEntryHead)
        CtxEntry::DeleteCtxEntries(_pCtxEntryHead);

    ASSERT_LOCK_HELD(gComLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::DecideDestruction     private
//
//  Synopsis:   Destroys the object after ensuring that the wrapper
//              table has not given out a reference to this object to
//              another thread
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
ULONG CStdWrapper::DecideDestruction(CPolicySet *pPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::DecideDestruction\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    ULONG cRefs;

    // Assert that double destruction has been prevented
    Win4Assert(!(_dwState & WRAPPERFLAG_INDESTRUCTOR));

    // Acquire lock
    LOCK(gComLock);

    // Ensure that the PID table has not given
    // out a reference to this object from a different
    // thread
    cRefs = _cRefs;
    if(cRefs == 0)
    {
		// Remove wrapper from ID object
		if(_pID && _pID->RemoveWrapper())
			_dwState |= WRAPPERFLAG_DESTROYID;
		
		// No other thread has a reference to this object
		// Mark as in destructor
		_dwState |= WRAPPERFLAG_INDESTRUCTOR;
		_cRefs = CINDESTRUCTOR;
		
		// Release lock
		UNLOCK(gComLock);
		ASSERT_LOCK_NOT_HELD(gComLock);
		
		// Cleanup state before final destruction
		PrepareForDestruction(pPS);
		
		// Acquire lock
		ASSERT_LOCK_NOT_HELD(gComLock);
		LOCK(gComLock);
		
		// Delete wrapper object
		delete this;
	}

    // Release lock
	UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::DecideDestruction returning 0x%x\n", cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Function:   PrepareWrapperForDestruction     private
//
//  Synopsis:   This function is called in the server context. It
//              prepares the specified wrapper for its destruction
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT PrepareWrapperForDestruction(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "PrepareWrapperForDestruction\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CStdWrapper *pWrapper = (CStdWrapper *) pv;

    // Prepare the specified wrapper for destruction
    pWrapper->PrepareForDestruction(NULL);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "PrepareWrapperForDestruction returning S_OK\n"));
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::PrepareForDestruction     private
//
//  Synopsis:   Destroys the object after ensuring that the wrapper
//              table has not given out a reference to this object to
//              another thread
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::PrepareForDestruction(CPolicySet *pPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::PrepareForDestruction\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Obtain current context
    CObjectContext *pCurrentCtx = GetCurrentContext();

    // Check current context
    if(!IsDisconnected() && _pID && (_pID->GetServerCtx() != GetCurrentContext()))
    {
        BOOL fRelease = FALSE;

        // Lookup policy set if not given
        if(pPS == NULL)
        {
            HRESULT hr;
            BOOL fCreate = TRUE;

            // Lookup policy set
            hr = ObtainPolicySet(pCurrentCtx, _pID->GetServerCtx(), PSFLAG_LOCAL,
                                 &fCreate, &pPS);
            fRelease = TRUE;
            if(FAILED(hr))
            {
                ContextDebugOut((DEB_ERROR,
                                 "CStdWrapper::PrepareForDestruction failed to "
                                 "obtain a policy set for contexts 0x%x-->0x%x "
                                 "with hr:0x%x\n", pCurrentCtx, _pID->GetServerCtx(),
                                 hr));
            }
        }

        // Check availability of policy set
        if(pPS)
        {
            // Switch to server context
            SwitchForCallback(pPS, PrepareWrapperForDestruction,
                              this, IID_IUnknown, 2, NULL);

            // Release policy set if not given
            if(fRelease)
                pPS->Release();
        }
    }
    else
    {
        // Currently in the server context
        // Prepare IFaceEntries for destruction
        IFaceEntry *pEntry = _pIFaceHead;
        while(pEntry)
        {
            pEntry->PrepareForDestruction();
            pEntry = pEntry->_pNext;
        }

        // Prepare object entries for destruction
        if(_pCtxEntryHead)
        {
            DWORD dwFlags = (CTXENTRYFLAG_IDENTRY | CTXENTRYFLAG_STDWRAPPER);
            dwFlags |= IsDisconnected() ? (CTXENTRYFLAG_DISCONNECTED) : 0;
            CtxEntry::PrepareCtxEntries(_pCtxEntryHead, dwFlags);
        }

        // Release IDObject
        if(_pID)
        {
            _pID->WrapperRelease();
            _pID->Release();
        }

        // Release server object, but not before calling WrapperRelease on
        // the IDObject because WrapperRelease will cause the SetZombie
        // sequence which requires a server reference to be held
        if(_pServer)
            _pServer->Release();

        _pServer = NULL;
        _pID = NULL;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::PrepareForDestruction returning\n"));
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::InternalAddRef     private
//
//  Synopsis:   Increments refcount on the wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
ULONG CStdWrapper::InternalAddRef()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::InternalAddRef\n"));

    ULONG cRefs;

    // Increment total ref count
    cRefs = InterlockedIncrement((LONG *)& _cRefs);
    // Always return 0 when inside the destructor
    if(_dwState & WRAPPERFLAG_INDESTRUCTOR)
    {
        // Nested AddRef will happen due to following
        // aggregation rules
        cRefs = 0;
    }

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::InternalAddRef returning 0x%x\n", cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::InternalRelease     private
//
//  Synopsis:   Decerement refcount on the wrapper object
//              and delete the object if it drops to zero
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
ULONG CStdWrapper::InternalRelease(CPolicySet *pPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::InternalRelease\n"));

    ULONG cRefs;

    // Decerement total ref count
    cRefs = InterlockedDecrement((LONG *)& _cRefs);
    // Check if this is the last release
    if(cRefs == 0)
    {
        // Avoid double destruction
        if(!(_dwState & WRAPPERFLAG_INDESTRUCTOR))
        {
            cRefs = DecideDestruction(pPS);
        }
    }

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::InternalRelease returning 0x%x\n", cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetPSFactory    private
//
//  Synopsis:   Obtains the PSFactory for the given interface
//
//  History:    18-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::GetPSFactory(REFIID riid, IPSFactoryBuffer **ppIPSF)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::GetPSFactory\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    RIFEntry *pRIFEntry;
    CLSID psClsid;
    HRESULT hr;

    DWORD actvflags = ACTVFLAGS_NONE;

    // Obatin the clsid of the PSFactory object
    hr = gRIFTbl.GetPSClsid(riid, &psClsid, &pRIFEntry);
    if(SUCCEEDED(hr))
    {
        // Check for COM interfaces
        if (IsEqualGUID(psClsid, CLSID_PSOlePrx32))
        {
            hr = ProxyDllGetClassObject(psClsid, IID_IPSFactoryBuffer,
                                        (void **)ppIPSF);
        }
        else
        {
#ifdef WX86OLE
            // If we are in a Wx86 process then we need to determine if the
            // PSFactory needs to be an x86 or native one.
            if (gcwx86.IsWx86Linked())
            {
                // Callout to wx86 to ask it to determine if an x86 PS factory
                // is required. Whole32 can tell if the stub needs to be x86
                // by determining if pUnkWow is a custom interface proxy or not.
                // Whole32 can determine if a x86 proxy is required by checking
                // if the riid is one for a custom interface that is expected
                // to be returned.

                if ( gcwx86.NeedX86PSFactory(NULL, riid) )
                {
                    actvflags |= ACTVFLAGS_WX86_CALLER;
                }
            }
#endif
            // Custom interface
            DWORD dwContext = ((actvflags & ACTVFLAGS_WX86_CALLER)
                               ? CLSCTX_INPROC_SERVERX86
                               : CLSCTX_INPROC_SERVER)
                              | CLSCTX_PS_DLL | CLSCTX_NO_CODE_DOWNLOAD;
            hr = ICoGetClassObject(psClsid, dwContext, NULL,
                                   IID_IPSFactoryBuffer, actvflags,
                                   (void **)ppIPSF, NULL);
#ifdef WX86OLE
            if ((actvflags & ACTVFLAGS_WX86_CALLER) && FAILED(hr))
            {
                // if we are looking for an x86 PSFactory and we didn't find
                // one on InprocServerX86 key then we need to check
                // InprocServer32 key as well.
                hr = ICoGetClassObject(psClsid,
                                       (CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL | CLSCTX_NO_CODE_DOWNLOAD),
                                       NULL, IID_IPSFactoryBuffer,
                                       actvflags, (void **)ppIPSF, NULL);

                if (SUCCEEDED(hr) && (!gcwx86.IsN2XProxy((IUnknown *)*ppIPSF)))
                {
                    ((IUnknown *)*ppIPSF)->Release();
                    hr = REGDB_E_CLASSNOTREG;
                }
            }
#endif

            AssertOutPtrIface(hr, *ppIPSF);
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::GetPSFactory returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetIFaceEntry    private
//
//  Synopsis:   Returns an existing IFaceEntry for the given IID
//
//  History:    18-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
IFaceEntry *CStdWrapper::GetIFaceEntry(REFIID riid)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::GetIFaceEntry\n"));

    // IFaceEntries are destroyed only when their wrapper
    // is destroyed
    ASSERT_LOCK_DONTCARE(gComLock);

    // Look for the desired interface among the
    // existing IFaceEntries
    IFaceEntry *pEntry = _pIFaceHead;
    while(pEntry)
    {
        if(IsEqualIID(pEntry->_iid, riid))
            break;
        pEntry = pEntry->_pNext;
    }

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::GetIFaceEntry returning 0x%x\n", pEntry));
    return(pEntry);
}

//---------------------------------------------------------------------------
//
//  Function:   CStdWrapper::GetOrCreateIFaceEntry   Private
//
//  Synopsis:   Finds or creates a wrapper for the given interface.
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT CStdWrapper::GetOrCreateIFaceEntry(REFIID riid, IUnknown *pUnk,
                                           CObjectContext *pClientCtx,
                                           CPolicySet *pPS, void **ppv)
{
    HRESULT hr = S_OK;

    // Check for interfaces implemented by wrapper
    *ppv = GetImplInterface(riid);

    if (*ppv == NULL)
    {
        // Check if IFaceEntry for the desired interface
        // already exists
        hr = S_OK;
        IFaceEntry *pEntry = GetIFaceEntry(riid);

        if (pEntry == NULL)
        {
            if (pUnk != NULL)
            {
                // Does not exist, try to create an IFaceEntry for
                // the new interface
                hr = CreateIFaceEntry(riid, pUnk, &pEntry);
                if (SUCCEEDED(hr))
                {
                    // we gave away the interface reference
                    Win4Assert(pEntry);
                    pUnk->AddRef();
                }
            }
            else
            {
                // We cannot create an interface entry without a
                // instance of the interface.  One solution might be to
                // do a cross context QI here....
                hr = CO_E_OBJNOTCONNECTED;
            }
        }

        if (SUCCEEDED(hr))
        {
            // make the IFaceEntry valid in the client context.

            // Acquire lock
            LOCK(gComLock);
            ASSERT_LOCK_HELD(gComLock);

            // Validate the interface for the client context
            if (pEntry->ValidateContext(pClientCtx, pPS))
            {
                *ppv = pEntry->_pProxy;
            }

            // Release the lock
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::CreateIFaceEntry    private
//
//  Synopsis:   Creates an IFaceEntry for a given IID
//
//  History:    18-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::CreateIFaceEntry(REFIID riid, void *pServer,
                                      IFaceEntry **ppEntry)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::CreateIFaceEntry this:%x riid:%I\n",
                    this, riid));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity checks
    Win4Assert(!GetImplInterface(riid));
    Win4Assert(!IsNotImplInterface(riid));
    Win4Assert(GetServerContext() == GetCurrentContext());

    HRESULT hr = E_FAIL;
    IFaceEntry *pEntry;
#if DBG==1
    if (g_dwInterceptLevel & INTERCEPT_ON)
#endif
        pEntry = CreateLightPS(riid, pServer, hr);

    // If we can't create a lightweight proxy-stub then we fall back to
    // creating it through the regular proxy-stub creation mechanism
    if(FAILED(hr))
    {
        // Obtain the proxy stub class factory
        IPSFactoryBuffer *pIPSF = NULL;
        hr = GetPSFactory(riid, &pIPSF);
        if(SUCCEEDED(hr))
        {
            IRpcProxyBuffer *pRpcProxy = NULL;
            void *pProxy = NULL;
            IRpcStubBuffer *pRpcStub = NULL;
            CCtxChnl *pCtxChnl = NULL;

            // Create proxy
            hr = pIPSF->CreateProxy(GetCtrlUnk(), riid, &pRpcProxy, &pProxy);
            if(SUCCEEDED(hr))
            {
                // Create stub
                hr = pIPSF->CreateStub(riid, (IUnknown *)pServer, &pRpcStub);
                if(SUCCEEDED(hr))
                {
                    // Cache proxy reference
                    // DEVNOTE: Violating aggregation rules
                    if(pProxy)
                        InternalRelease(NULL);

                    // Assume OOM
                    hr = E_OUTOFMEMORY;

                    // Create context channel
                    LOCK(gComLock);
                    pCtxChnl = new CCtxChnl(this);
                    UNLOCK(gComLock);
                    if(pCtxChnl)
                    {
                        hr = pRpcProxy->Connect(pCtxChnl);
                        if(SUCCEEDED(hr))
                        {
                            // OLE Automation proxies do not return a valid
                            // proxy pointer till the channel is connected
                            if(pProxy == NULL)
                            {
                                hr = pRpcProxy->QueryInterface(riid, &pProxy);
                                if(SUCCEEDED(hr))
                                {
                                    // Cache proxy reference
                                    // DEVNOTE: Violating aggregation rules
                                    InternalRelease(NULL);
                                }
                                else
                                    pProxy = NULL;
                            }

                            if(pProxy)
                            {
                                // Acquire lock
                                LOCK(gComLock);

                                // Ensure that some other thread has not created
                                // the IFaceEntry for the interface
                                pEntry = GetIFaceEntry(riid);
                                if(pEntry == NULL)
                                {
                                    pEntry = new IFaceEntry(_pIFaceHead, pProxy,
                                                            pRpcProxy, pServer,
                                                            pRpcStub, riid, pCtxChnl,
                                                            NULL, NULL);
                                    if(pEntry)
                                    {
                                        _pIFaceHead = pEntry;
                                        ++_cIFaces;
                                        pCtxChnl->SetIFaceEntry(pEntry);
                                    }
                                }
                                else
                                {
                                    // Force cleanup
                                    hr = E_FAIL;
                                }

                                // Release lock
                                UNLOCK(gComLock);
                            }
                        }
                    }
                }
            }

            // Cleanup in case of errors
            if(FAILED(hr))
            {
                // Release client side pointers
                if(pProxy)
                {
                    InternalAddRef();
                    ((IUnknown *) pProxy)->Release();
                }
                if(pRpcProxy)
                {
                    pRpcProxy->Disconnect();
                    pRpcProxy->Release();
                }

                // Release server side pointers
                if(pRpcStub)
                {
                    pRpcStub->Disconnect();
                    pRpcStub->Release();
                }

                // Release channel
                if(pCtxChnl)
                    pCtxChnl->Release();
            }
        }

        if(FAILED(hr) && pEntry==NULL)
        {
            // Another thread could have created the desired IFaceEntry
            pEntry = GetIFaceEntry(riid);
        }
    }

    *ppEntry = pEntry;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
              "CStdWrapper::CreateIFaceEntry hr:%x pEntry:%x\n", hr, pEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::CreateLightPS    private
//
//  Synopsis:   This function loads the interceptor dll if required.
//              Then, it constructs an interceptor for the given server
//              and creates a channel which is registered as the sink of
//              the interceptor
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
IFaceEntry* CStdWrapper::CreateLightPS(REFIID riid, void* pServer, HRESULT &hr)
{
    ContextDebugOut((DEB_WRAPPER, "CreateLightPS\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    ICallInterceptor* pInterceptor = NULL;
    IUnknown* pUnkOuter = NULL;
    IUnknown* pUnkInner = NULL;
    IFaceEntry* pEntry = NULL;
    CCtxChnl *pCtxChnl = NULL;
    HINSTANCE hCallFrameLib = NULL;
    BOOL fFree = FALSE;
    LPVOID pProxy = NULL;

#if DBG==1
    if((g_dwInterceptLevel & INTERCEPT_NOIDISP) && (riid == IID_IDispatch))
    {
        hr = E_FAIL;
        return NULL;
    }
#endif

	// Create an interceptor for the given interface
	pUnkOuter = GetCtrlUnk();
	hr = CoGetInterceptorForOle32(riid, pUnkOuter, IID_IUnknown, (void**)&pUnkInner);
	if(SUCCEEDED(hr))
	{
		// QI for the interceptor interface
		hr = pUnkInner->QueryInterface(IID_ICallInterceptor, (void**)&pInterceptor);
		if(SUCCEEDED(hr))
		{
			// Release the extra addref on the outer component, per aggregation rules
			// DEVNOTE: Violating aggregation rules
			InternalRelease(NULL);
			
			// Analyze the method signatures statically.
			// If there are any in,out interface ptrs,
			// we fail immediately
			hr = GetStaticInfo(pInterceptor);
			if(SUCCEEDED(hr))
			{
				
				// QI for the desired interface
				hr = pUnkInner->QueryInterface(riid,&pProxy);
				if(SUCCEEDED(hr))
				{
					// Cache proxy reference
					// DEVNOTE: Violating aggregation rules
					InternalRelease(NULL);
					
					// Assume OOM
					hr = E_OUTOFMEMORY;
					
					// Create context channel
					LOCK(gComLock);
					pCtxChnl = new CCtxChnl(this);
					UNLOCK(gComLock);
					if(pCtxChnl)
					{
						// Register the channel as the sink for the interceptor
						// When a method is called on the interface, the interceptor "intercepts"
						// the method call and turns around and calls CCtxChnl::OnCall
						hr = pInterceptor->RegisterSink(pCtxChnl);
						if(SUCCEEDED(hr))
						{
                            // Acquire lock
							LOCK(gComLock);
							
                            // Ensure that some other thread has not created
                            // the IFaceEntry for the interface
							pEntry = GetIFaceEntry(riid);
							if(pEntry == NULL)
							{
								// Create a new interface entry.
								pEntry = new IFaceEntry(
									                    _pIFaceHead,
														pProxy,
														NULL,
														pServer,
														NULL,
														riid,
														pCtxChnl,
														pInterceptor,
														pUnkInner
								                        );
								if(pEntry)
								{
									_pIFaceHead = pEntry;
									++_cIFaces;
									pCtxChnl->SetIFaceEntry(pEntry);
								}
							}
						}
						else
						{
							// Force cleanup
							hr = E_FAIL;
						}

						UNLOCK(gComLock);
					}
				}
			}
		}
	}

    if(FAILED(hr))
    {
        // Cleanup resources
        if(pInterceptor)
        {
            // Remove any sinks registered with the interceptor
            pInterceptor->RegisterSink(NULL);
            InternalAddRef();
            pInterceptor->Release();
        }

        if(pProxy)
        {
            InternalAddRef();
            ((IUnknown *) pProxy)->Release();
        }

        if(pUnkInner)
            pUnkInner->Release();

        if(pCtxChnl)
            ((IUnknown *) (IRpcChannelBuffer2 *)pCtxChnl)->Release();
    }

    if(FAILED(hr) && pEntry==NULL)
    {
        // Another thread could have created the desired IFaceEntry
        LOCK(gComLock);
        pEntry = GetIFaceEntry(riid);
        UNLOCK(gComLock);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,"CStdWrapper::CreateLightPS returning 0x%x\n", pEntry));
    return(pEntry);
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetStaticInfo    private
//
//  Synopsis:   Get static type information about the methods in the interface
//              If there are any methods with [in,out] parameters, we fail
//              and use RPC proxy/stub.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::GetStaticInfo(ICallInterceptor* pInterceptor)
{
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;
    ULONG cMethod = 0;
    CALLFRAMEINFO info = {0,};

    // Find out if the interface supports IDispatch
    hr = pInterceptor->GetIID(NULL,&info.fDerivesFromIDispatch,&cMethod,NULL);
    if(SUCCEEDED(hr))
    {
        ULONG cStart = 3;

        // The interface must have at least 3 methods
        // of the IUnknown interface
        Win4Assert(3 <= cMethod);

        // Sanity check
        Win4Assert(GetCurrentContext() == GetServerContext());

        if(info.fDerivesFromIDispatch)
        {
#if DBG==1
            if(g_dwInterceptLevel & INTERCEPT_NOIDISP)
            {
                return E_FAIL;
            }
#endif

            // Skip over the IDispatch methods because we know that
            // there are no [in,out] interface pointers in them
            cStart += 4;

            // Sanity check
            Win4Assert(7 <= cMethod);
        }

        // Start asking for information after the 3 methods of the IUnknown
        for(ULONG iMethod = cStart; iMethod < cMethod; iMethod++)
        {
            hr = pInterceptor->GetMethodInfo(iMethod,&info,NULL);
            if(SUCCEEDED(hr))
            {
                // Check for [in,out] interface ptrs
                if(0 != info.cInOutInterfacesMax)
                {
                    // We don't support [in,out] interface ptrs
                    // Fall back to the regular proxy stub code
                    hr = E_FAIL;
                    break;
                }
            }
        }
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CrossCtxQIFn                Internal
//
//  Synopsis:   QIs the specified object for the desired interface
//              If object supports the interface, builds IFaceEntry
//              for it and returns it in the out parameter
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagXCtxQIData
{
    const IID *pIID;
    CStdWrapper *pStdWrapper;
    IFaceEntry *pEntry;
} XCtxQIData;

HRESULT __stdcall CrossCtxQIFn(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CrossCtxQIFn\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    XCtxQIData *pXCtxQIData = (XCtxQIData *) pv;
    CStdWrapper *pWrapper;
    IUnknown *pUnk, *pServer;

    // QI the server for the desired interface
    pServer = pXCtxQIData->pStdWrapper->GetServer();
    pWrapper = pXCtxQIData->pStdWrapper;
    hr = pServer->QueryInterface(*pXCtxQIData->pIID, (void **) &pUnk);
    if(SUCCEEDED(hr))
    {
        // Create IFaceEntry for the new interface
        hr = pWrapper->CreateIFaceEntry(*pXCtxQIData->pIID, pUnk, &pXCtxQIData->pEntry);
        if(FAILED(hr))
            pUnk->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "CrossCtxQIFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   PerformCallback         Internal
//
//  Synopsis:   Switches out of client context for performing callback
//              specified
//
//  History:    29-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT PerformCallback(CObjectContext *pServerCtx, PFNCTXCALLBACK pfnCallback,
                        void *pv, REFIID riid, ULONG iMethod, IUnknown *pUnk)
{
    ContextDebugOut((DEB_WRAPPER, "PerformCallback\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    CObjectContext *pCurrentCtx;

    // Obtain current context
    pCurrentCtx = GetCurrentContext();

#if DBG==1

    if (!pfnCallback)
    {
        // Sanity checks for SWC
        // We're switching contexts, but always within the same apartment
        Win4Assert (pCurrentCtx != pServerCtx);
        Win4Assert (pCurrentCtx->GetComApartment() == pServerCtx->GetComApartment());
    }

#endif

    // Check for the need to switch context
    if(pCurrentCtx == pServerCtx)
    {
        // Call the callback function directly
        hr = pfnCallback(pv);
    }
    else
    {
        CPolicySet *pPS;
        BOOL fCreate = TRUE;

        // Obtain policy set between the current context and server context
        hr = ObtainPolicySet(pCurrentCtx, pServerCtx, PSFLAG_LOCAL,
                             &fCreate, &pPS);
        if(SUCCEEDED(hr))
        {
            // Delegate to SwitchForCallback function
            hr = SwitchForCallback(pPS, pfnCallback, pv, riid, iMethod, pUnk);

            // Release policy set
            pPS->Release();
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "PerformCallback returning 0x%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   SwitchForCallback            Internal
//
//  Synopsis:   Switches out of client context for performing callback
//              specified
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT SwitchForCallback(CPolicySet *pPS, PFNCTXCALLBACK pfnCallback,
                          void *pv, REFIID riid, ULONG iMethod,
                          IUnknown *pUnk)
{
    ContextDebugOut((DEB_WRAPPER, "SwitchForCallback\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;         // hresult for infrastructure calls
    HRESULT hrCallback = S_OK; // hresult from the actual callback
    HRESULT hrPolicy = S_OK;   // hresult set by any of the policies
    RPCOLEMESSAGE message;

    // Initialize the message
    memset(&message, 0, sizeof(RPCOLEMESSAGE));
    message.iMethod = iMethod;
    //message.Buffer = pv;

    // Create rpc call object on the stack
    CRpcCall rpcClient(pUnk, &message, riid, hrPolicy, CALLSOURCE_CROSSCTX);

    // Check if there is a client context
    if(pPS->GetClientContext())
    {
        CCtxCall* pclientCall = NULL, * pserverCall = NULL;
        BOOL bFreeClientCall = FALSE, bFreeServerCall = FALSE;
        
        // Create a client side context call object
        CCtxCall stackclientCall(CTXCALLFLAG_CLIENT, NDR_LOCAL_DATA_REPRESENTATION);
        void *pvExtent = NULL;

        if (pfnCallback)
            pclientCall = &stackclientCall;
        else
        {
            // Allocate on the heap because we need this object to last until the next
            // call to CoLeaveServiceDomain
            pclientCall = new CCtxCall (CTXCALLFLAG_CLIENT, NDR_LOCAL_DATA_REPRESENTATION);
            if (!pclientCall)
                hr = E_OUTOFMEMORY;
            else
                bFreeClientCall = TRUE;
        }

        if (SUCCEEDED (hr))
        {
            // Size the buffer as needed
            hr = pPS->GetSize(&rpcClient, CALLTYPE_SYNCCALL, pclientCall);
            if(SUCCEEDED(hr))
            {
                // Allocate memory for policies that wish to send data
                if(pclientCall->_cbExtent)
                {
                    pvExtent = PrivMemAlloc8(pclientCall->_cbExtent);
                    if (!pvExtent)
                        hr = E_OUTOFMEMORY;

                    pclientCall->_pvExtent = pvExtent;
                }

                if (SUCCEEDED (hr))
                {
                    // Deliver client side call events
                    hr = pPS->FillBuffer(&rpcClient, CALLTYPE_SYNCCALL, pclientCall);
                    // Reset state inside context call object
                    CPolicySet::ResetState(pclientCall);
                
                    if(SUCCEEDED(hr))
                    {
                        CObjectContext* pSavedCtx = NULL;
                        
                        // Create a server side context call object
                        CCtxCall stackserverCall(CTXCALLFLAG_SERVER, NDR_LOCAL_DATA_REPRESENTATION);

                        if (pfnCallback)
                            pserverCall = &stackserverCall;
                        else
                        {
                            // Allocate on the heap because we need this object to last until the next
                            // call to CoLeaveServiceDomain
                            pserverCall = new CCtxCall (CTXCALLFLAG_SERVER, NDR_LOCAL_DATA_REPRESENTATION);
                            if (!pserverCall)
                                hr = E_OUTOFMEMORY;
                            else
                                bFreeServerCall = TRUE;
                        }

                        if(SUCCEEDED(hr))
                        {
                            // Set the client extent pointer inside server context call object
                            pserverCall->_pvExtent = pvExtent;

                            // Update message
                            message.reserved1 = pserverCall;

                            // Enter server context
                            hrPolicy = EnterForCallback(&message, pPS, pfnCallback,
                                                        pv, riid, iMethod, NULL, &hrCallback, &pSavedCtx);
                        }

                        if (pfnCallback)
                        {
                            // Store the server object's hr
                            rpcClient.SetServerHR(hrCallback);
                        }
                        else if (SUCCEEDED (hr) && SUCCEEDED (hrPolicy))
                        {
                            // Push objects onto tls, so we can recover them
                            // on the next CoLeaveServiceDomain
                            ContextStackNode csnNode =
                            {
                                NULL,
                                pSavedCtx,
                                pPS->GetServerContext(),
                                pclientCall,
                                pserverCall,
                                pPS
                            };

                            // Balanced by callers of PopServiceDomainContext if Push succeeds
                            pPS->AddRef();

                            hr = PushServiceDomainContext (csnNode);
                            if (SUCCEEDED (hr))
                            {
                                // Don't free the objects right now
                                bFreeClientCall = bFreeServerCall = FALSE;
                            }
                            else
                            {
                                pPS->Release();
                            }
                        }
                    }

                    if (pfnCallback)
                        // Perform typical return actions after delivering a call
                        hr = SwitchAfterCallback (pPS, rpcClient, pclientCall, pserverCall);
                }
            }
        }
        
        // Clean up in case of errors in SWC path
        if (bFreeClientCall)
            delete pclientCall;
        if (bFreeServerCall)
            delete pserverCall;
    }
    else
    {
        CObjectContext* pSavedCtx = NULL;
        
        Win4Assert (pfnCallback && "Cannot switch apartments without a callback");
        
        // X-Apartment call
        Win4Assert(GetCurrentContext() == GetEmptyContext());

        // Update message
        COleTls Tls;
        message.reserved1 = Tls->pCallInfo->GetServerCtxCall();

        // Enter server context
        hr = EnterForCallback(&message, pPS, pfnCallback,
                              pv, riid, iMethod, NULL, &hrCallback, &pSavedCtx);
    }	

    // We return S_OK, or an error from one of the following three hresults;
    // policy-set hresults have first precedence, followed by the infrastructure 
    // errors, followed by the actual callback result
    HRESULT hrFinal;
    hrFinal = (FAILED(hrPolicy)) ? hrPolicy : 
                (FAILED(hr)) ? hr :
                  hrCallback;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "SwitchForCallback returning hr:0x%x\n", hrFinal));
    return (hrFinal);
}


//+-------------------------------------------------------------------
//
//  Function:   SwitchAfterCallback            Internal
//
//  Synopsis:   Cleans up after SwitchForCallback
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
HRESULT SwitchAfterCallback (CPolicySet *pPS, CRpcCall& rpcClient, CCtxCall* pClientCall, CCtxCall* pServerCall)
{
    HRESULT hr;

    void* pvExtent = pClientCall->_pvExtent;
    
    // Set the server extent pointer inside client context call object
    pClientCall->_pvExtent = pServerCall->_pvExtent;
                            
    // Deliver client side notification events
    hr = pPS->Notify(&rpcClient, CALLTYPE_SYNCRETURN, pClientCall);

    // Free client buffer
    if(pvExtent)
        PrivMemFree8(pvExtent);

    // Free server buffer
    if(pClientCall->_pvExtent)
        PrivMemFree8(pClientCall->_pvExtent);

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   EnterServiceDomain            Internal
//
//  Synopsis:   Enters an SWC service domain
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
HRESULT EnterServiceDomain (IObjContext* pObjContext)
{
    return pObjContext->DoCallback (NULL, NULL, IID_NULL, 0xffffffff);
}


//+-------------------------------------------------------------------
//
//  Function:   LeaveServiceDomain            Internal
//
//  Synopsis:   Leaves an SWC service domain
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
HRESULT LeaveServiceDomain (IObjContext** ppObjContext)
{
    HRESULT hr;

    Win4Assert (ppObjContext);
    *ppObjContext = NULL;

    ContextStackNode csnCtxNode = {0};

    CObjectContext* pServerCtx = GetCurrentContext();
    Win4Assert (pServerCtx);

    COleTls Tls (hr);
    if (FAILED (hr)) return hr;

    if (Tls->pContextStack && Tls->pContextStack->pServerContext != pServerCtx)
    {
        Win4Assert (!"Unbalanced call to CoLeaveServiceDomain");
        return CONTEXT_E_NOCONTEXT;
    }

    hr = PopServiceDomainContext (&csnCtxNode);
    if (SUCCEEDED (hr))
    {
        HRESULT hrCallback = S_OK, hrRet = S_OK;

        CPolicySet* pPS = csnCtxNode.pPS;
        CCtxCall* pClientCall = csnCtxNode.pClientCall;
        CCtxCall* pServerCall = csnCtxNode.pServerCall;
        CObjectContext* pSavedCtx = csnCtxNode.pSavedContext;

        // Initialize a 'fake' message
        RPCOLEMESSAGE rpcoleMessage;
        memset (&rpcoleMessage, 0, sizeof (RPCOLEMESSAGE));
        rpcoleMessage.iMethod = 0xffffffff;

        // Initialize a fake unknown
        IUnknown* pUnk = NULL;

        // Initialize a 'fake' rpccall
        CRpcCall rpcCall (pUnk, &rpcoleMessage, IID_NULL, hrRet, CALLSOURCE_CROSSCTX);

        // Unwind the stack from the callback
        hr = EnterAfterCallback (&rpcoleMessage, pPS, &hrCallback, S_OK, rpcCall, 
                            pServerCtx, pSavedCtx, pServerCall, FALSE, FALSE);

        if (SUCCEEDED (hr))
        {
            hr = SwitchAfterCallback (pPS, rpcCall, pClientCall, pServerCall);
            if (SUCCEEDED (hr))
            {
                // Addref the context for CoLeave
                pServerCtx->AddRef();
                *ppObjContext = pServerCtx;
            }
        }
        else
        {
            // Clean up extent data on failure
            if (pClientCall->_pvExtent)
            {
                PrivMemFree8 (pClientCall->_pvExtent);
            }

            if (pServerCall->_pvExtent && pServerCall->_pvExtent != pClientCall->_pvExtent)
            {
                PrivMemFree8 (pServerCall->_pvExtent);
            }

            pClientCall->_pvExtent = NULL;
            pServerCall->_pvExtent = NULL;
        }

        pPS->Release();

        delete pClientCall;
        delete pServerCall;
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CheckContextAfterCall            Internal
//
//  Synopsis:   Cleans up when a call is delivered and an SWC context is leaked
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
BOOL CheckContextAfterCall (COleTls& Tls, CObjectContext* pCorrectCtx)
{
    if (Tls->pCurrentCtx != pCorrectCtx)
    {
        // This should only happen when we return from a COM call
        // where the callee leaked an SWC context
        HRESULT hr = CleanupLeakedDomainStack (Tls, pCorrectCtx);
        Win4Assert (SUCCEEDED (hr));

        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:   EnterForCallback            Internal
//
//  Synopsis:   Enters server context for doing work specified
//              in the work function
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT EnterForCallback(RPCOLEMESSAGE *pMessage, CPolicySet *pPS,
                         PFNCTXCALLBACK pfnCallback, void *pv,
                         REFIID riid, ULONG iMethod, IUnknown *pUnk, HRESULT* phrCallback,
                         CObjectContext** ppSavedCtx)
{
    ContextDebugOut((DEB_WRAPPER, "EnterForCallback\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(riid, iidName);

        ContextDebugOut((DEB_TRACECALLS,
                         "EnterForCallback on interface %I (%ws) method 0x%x\n",
                         &riid, iidName, iMethod));
    }
#endif

    HRESULT hr = S_OK;         // hresult set by infrastructure calls
    HRESULT hrPolicy = S_OK;   // hresult set by server side policies
    CCtxCall *pCtxCall;
    COleTls Tls;
    CObjectContext *pServerCtx, *pSavedCtx;

    // Create rpc call object on the stack
    CRpcCall rpcServer(pUnk, pMessage, riid, hrPolicy, CALLSOURCE_CROSSCTX);

    // Obtain server side context call object
    pCtxCall = (CCtxCall *) pMessage->reserved1;
    Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_SERVER);

    // Initialize the data represenation field in the message
    pMessage->dataRepresentation = pCtxCall->_dataRep;

    // Obtain server object context
    pServerCtx = pPS->GetServerContext();

    // Save current context
    pSavedCtx = Tls->pCurrentCtx;

    // Switch to the server object context
    Tls->pCurrentCtx = pServerCtx;
    Tls->ContextId = pServerCtx->GetId();
    pServerCtx->InternalAddRef();
    ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x --> 0x%x\n",
                     pSavedCtx, pServerCtx));

    // Ensure that the thread is in the right apartment.
    BOOL fEnteredNA = FALSE;
    BOOL fExitedNA = FALSE;
    if (pServerCtx->GetComApartment() == gpNTAApartment)
    {
        // Server is in the NA.  If the thread is currently not in the
        // the NA, switch it into it now.
        
        if (!IsThreadInNTA())
        {
            Tls->dwFlags |= OLETLS_INNEUTRALAPT;
            fEnteredNA = TRUE;
        }
    }
    else if (IsThreadInNTA())
    {
        // Server is not in the NA.  Switch out of the NA now.
        
        Tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
        fExitedNA = TRUE;
    }
    Win4Assert(!IsThreadInNTA() || pServerCtx->GetComApartment() == gpNTAApartment);
    Win4Assert(IsThreadInNTA() || pServerCtx->GetComApartment() != gpNTAApartment);

    // Deliver server side notification events
    hr = pPS->Notify(&rpcServer, CALLTYPE_SYNCENTER, pCtxCall);
    Win4Assert(hr != RPC_E_INVALID_HEADER);

    // Delegate to callback if we have one
    // We won't have one when we're entering 
    // a context without components (SWC)
    if (pfnCallback)
    {
        if(SUCCEEDED(hr))
        {
            *phrCallback = pfnCallback(pv);
        }

        // Note - we clobber hr from Notify because that's what the original code did...
        hr = EnterAfterCallback (pMessage, pPS, phrCallback, 
            hrPolicy, rpcServer, pServerCtx, pSavedCtx, pCtxCall, fEnteredNA, fExitedNA);
    }

    *ppSavedCtx = pSavedCtx;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "EnterForCallback returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   EnterAfterCallback            Internal
//
//  Synopsis:   Cleans up after EnterForCallback
//
//  History:    16-Mar-01   mfeingol      Created
//
//+-------------------------------------------------------------------
HRESULT EnterAfterCallback(RPCOLEMESSAGE *pMessage, CPolicySet *pPS, HRESULT* phrCallback,
                         HRESULT hrPolicy, CRpcCall& rpcServer, CObjectContext* pServerCtx, CObjectContext* pSavedCtx,
                         CCtxCall* pCtxCall, BOOL fEnteredNA, BOOL fExitedNA)
{
    COleTls Tls;
    HRESULT hr;
    
    // Make the result of the call available to server-side policies
    rpcServer.SetServerHR(*phrCallback);

    // Initailize
    pMessage->cbBuffer = 0;
    CPolicySet::ResetState(pCtxCall);

    // Obtain the buffer size needed by the server side policies
    // GetSize will fail on the server side only if no policy
    // expressed interest in sending data to the client side
    pPS->GetSize(&rpcServer, CALLTYPE_SYNCLEAVE, pCtxCall);

    // Allocate buffer if server side
    // policies wish to send buffer to the client side
    if(pCtxCall->_cbExtent)
        pCtxCall->_pvExtent = PrivMemAlloc8(pCtxCall->_cbExtent);

    // Deliver server side call events
    hr = pPS->FillBuffer(&rpcServer, CALLTYPE_SYNCLEAVE, pCtxCall);

    // Switch back to the saved context
    ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x <-- 0x%x\n",
                     pSavedCtx, Tls->pCurrentCtx));

    // Make sure we're back on the right context
    CheckContextAfterCall (Tls, pServerCtx);

    pServerCtx->InternalRelease();

    Win4Assert(pSavedCtx);
    Tls->pCurrentCtx = pSavedCtx;
    Tls->ContextId = pSavedCtx->GetId();

    // We return either S_OK, or an error.  An error set by a policy has first
    // precedence, followed by an infrastructure error.
    HRESULT hrFinal;
    hrFinal = (FAILED(hrPolicy)) ? hrPolicy : hr;

    // If we switched the thread into or out of the NA, switch it
    // back now.
    if (fEnteredNA)
    {
        Tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
    }
    else if (fExitedNA)
    {
        Tls->dwFlags |= OLETLS_INNEUTRALAPT;
    }
    Win4Assert(!IsThreadInNTA() || Tls->pCurrentCtx->GetComApartment() == gpNTAApartment);
    Win4Assert(IsThreadInNTA() || Tls->pCurrentCtx->GetComApartment() != gpNTAApartment);

    return hrFinal;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetImplInterface      private
//
//  Synopsis:   Returns the implemented inteface
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CStdWrapper::GetImplInterface(REFIID riid)
{
    void *pv;

    if(IsEqualIID(riid, IID_IStdWrapper))
        pv = this;
    else if(IsEqualIID(riid, IID_IUnknown))
        pv = (IUnknown *) this;
    else if(IsEqualIID(riid, IID_IMarshal))
        pv = (IMarshal *) this;
    else if(IsEqualIID(riid, IID_IMarshal2))
        pv = (IMarshal2 *) this;
    else
        pv = NULL;

    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::IsNotImplInterface      private
//
//  Synopsis:   Returns TRUE if it is a system interface not implemented
//              by wrapper
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
BOOL CStdWrapper::IsNotImplInterface(REFIID riid)
{
    BOOL fNotImpl = FALSE;

    if(IsEqualIID(riid, IID_IStdIdentity))
        fNotImpl = TRUE;

    return(fNotImpl);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::InternalQI      private
//
//  Synopsis:   Internal QI behavior of wrapper object
//
//  History:    24-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::InternalQI(REFIID riid, void **ppv,
                                BOOL fQIServer, BOOL fValidate,
                                CtxEntry *pWrapperEntry)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::InternalQI\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    *ppv = GetImplInterface(riid);
    if(*ppv == NULL)
    {
        if(IsDisconnected())
        {
            hr = RPC_E_DISCONNECTED;
        }
        else
        {
            CPolicySet *pPS = pWrapperEntry ? pWrapperEntry->_pPS : NULL;
            CObjectContext *pCurrentCtx = GetCurrentContext();
            hr = E_NOINTERFACE;

            // Check for an existing existing IFaceEntry
            IFaceEntry *pEntry = GetIFaceEntry(riid);

            // Check if a matching IFaceEntry was found
            if(pEntry == NULL && fQIServer)
            {
                // Sanity checks
                Win4Assert(GetCurrentContext() != _pID->GetServerCtx());
                hr = CrossCtxQI(pPS, riid, &pEntry);
            }

            if(pEntry)
            {
                // Initialize
                *ppv = pEntry->_pProxy;

                // Validate current context for the interface
                if(fValidate)
                {
                    // Acquire lock
                    LOCK(gComLock);

                    if(!pEntry->ValidateContext(pCurrentCtx, pPS))
                    {
                        *ppv = NULL;
                        hr = E_OUTOFMEMORY;
                    }

                    // Release lock
                    UNLOCK(gComLock);
                }
            }
        }
    }

    // Check for success
    if(*ppv)
    {
        // DEVNOTE: violating aggregation rules
        if(fValidate && pWrapperEntry)
            pWrapperEntry->AddRef();
        InternalAddRef();
        hr = S_OK;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::InternalQI returning 0x%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::QueryInterface     public
//
//  Synopsis:   QI behavior of wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::QueryInterface(REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::QueryInterface\n"));

    HRESULT hr = RPC_E_WRONG_THREAD;
    BOOL fLegal = FALSE;
    CtxEntry *pWrapperEntry;

    // Check legality of caller context for this object
    CObjectContext *pCurrentCtx = GetCurrentContext();
    if(IsDisconnected())
    {
        pWrapperEntry = NULL;
        fLegal = TRUE;
    }
    // Check if the object has been exposed to any  client contexts
    else if(_pCtxEntryHead)
    {
        // Lookup wrapper entry for the current context
        pWrapperEntry = CtxEntry::LookupEntry(_pCtxEntryHead, pCurrentCtx);
        if(pWrapperEntry)
            fLegal = TRUE;
    }

    // Delegate to internalQI
    if(fLegal)
        hr = InternalQI(riid, ppv, TRUE, TRUE, pWrapperEntry);
    else
        ContextDebugOut((DEB_WARN, "Wrapper object was passed illegally to "
                                   "the client context 0x%x\n", pCurrentCtx));

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::QueryInterface returning 0x%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::AddRef     public
//
//  Synopsis:   AddRef behavior wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdWrapper::AddRef()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::AddRef\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    ULONG cRefs = 0;

    // Check legality of caller context for this object
    CObjectContext *pCurrentCtx = GetCurrentContext();
    if(IsDisconnected() || (_pID->GetServerCtx() == pCurrentCtx))
    {
        cRefs = InternalAddRef();
    }
    // Check if the object has been exposed to any client contexts
    else if(_pCtxEntryHead)
    {
        CtxEntry *pWrapperEntry;

        // Lookup wrapper entry for the current context
        pWrapperEntry = CtxEntry::LookupEntry(_pCtxEntryHead, pCurrentCtx);
        if(pWrapperEntry)
        {
            // Increment ref count for the current client context
            cRefs = pWrapperEntry->AddRef();
            InternalAddRef();
        }
    }

    if(cRefs == 0)
        ContextDebugOut((DEB_WARN, "Wrapper object was passed illegally to "
                                   "the client context 0x%x\n", pCurrentCtx));

    ASSERT_LOCK_NOT_HELD(gComLock);
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Release     public
//
//  Synopsis:   Decerement refcount on the wrapper object
//              and delete the object if it drops to zero
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdWrapper::Release()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Release\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    ULONG cRefs = 0;
    BOOL fLegal = FALSE;

    // Check legality of caller context for this object
    CObjectContext *pCurrentCtx = GetCurrentContext();
    if(IsDisconnected() || (_pID->GetServerCtx() == pCurrentCtx))
    {
        cRefs = InternalRelease(NULL);
        fLegal = TRUE;
    }
    // Check if the object has been exposed to any client contexts
    else if(_pCtxEntryHead)
    {
        CtxEntry *pWrapperEntry;

        // Lookup wrapper entry for the current context
        pWrapperEntry = CtxEntry::LookupEntry(_pCtxEntryHead, pCurrentCtx);
        if(pWrapperEntry)
        {
            // Decrement ref count for the current client context
            CPolicySet *pPS = ReleaseCtxEntry(pWrapperEntry);

            // Check if this is the last release for the
            // current client context
            if(pPS && _pIFaceHead)
            {
                IFaceEntry *pIFEntry = _pIFaceHead;

                // Inform IFaceEntries to invalidate current
                // context as a valid client context
                LOCK(gComLock);
                while(pIFEntry)
                {
                    pIFEntry->RemoveCtxEntry(pCurrentCtx);
                    pIFEntry = pIFEntry->_pNext;
                }
                UNLOCK(gComLock);
            }

            // The current context has a legal reference on the
            // wrapper object
            cRefs = InternalRelease(pPS);
            fLegal = TRUE;
            if(pPS)
                pPS->Release();
        }
    }

    if(!fLegal)
        ContextDebugOut((DEB_WARN, "Wrapper object was passed illegally to "
                                   "the client context 0x%x\n", pCurrentCtx));

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::Release returning 0x%x\n", cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetUnmarshalClass     public
//
//  Synopsis:   Returns the unmarshaler CLSID
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::GetUnmarshalClass(REFIID riid, LPVOID pv,
                                            DWORD dwDestCtx, LPVOID pvDestCtx,
                                            DWORD mshlflags, LPCLSID pClsid)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::GetUnmarshalClass\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Check destination context and marshal flags
	if (CanWrapperMarshal(dwDestCtx, mshlflags))
	{
        // Return wrapper unmarshaler classid
        *pClsid = CLSID_StdWrapper;
    }
    else
    {
        // Return standard unmarshaler classid
        *pClsid = CLSID_StdMarshal;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::GetUnmarshalClass returning 0x%x\n", S_OK));
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::GetMarshalSizeMax     public
//
//  Synopsis:   Returns the size of marshal data
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::GetMarshalSizeMax(REFIID riid, LPVOID pv,
                                            DWORD dwDestCtx, LPVOID pvDestCtx,
                                            DWORD mshlflags, LPDWORD pSize)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::GetMarshalSizeMax\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Check destination context and marshal flags
	if(CanWrapperMarshal(dwDestCtx, mshlflags))
    {
		*pSize = sizeof(XCtxMarshalData);
		hr = S_OK;
    }
    else
    {
        hr = MarshalSizeHelper(dwDestCtx, pvDestCtx, mshlflags,
                               _pID->GetServerCtx(), TRUE, pSize);
    }

    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::GetMarshalSizeMax returning 0x%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::MarshalServer           public
//
//  Synopsis:   Marshals the specified interface.
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::MarshalServer(CPolicySet *pPS, IStream *pStm, REFIID riid,
                                   DWORD dwDestCtx, void *pvDestCtx, DWORD mshlflags)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::MarshalServer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity checks
    Win4Assert(((dwDestCtx==MSHCTX_CROSSCTX) && !(mshlflags & MSHLFLAGS_TABLEWEAK)) || IsThreadInNTA());

    // Get Local OXID Entry
    OXIDEntry *pOXIDEntry;
    HRESULT hr = GetLocalOXIDEntry(&pOXIDEntry);

    if(pOXIDEntry)
    {
        IFaceEntry *pEntry = NULL;

        // Check for implemented interface
        void *pKnownIf = GetImplInterface(riid);
        if(pKnownIf)
        {
            pEntry = NULL;
        }
        // Check for an existing IFaceEntry
        else
        {
            pEntry = GetIFaceEntry(riid);
        }

        // Check if a matching IFaceEntry was not found
        if(pKnownIf==NULL && pEntry==NULL)
        {
            XCtxQIData xCtxQIData;

            // Initialize QIData
            xCtxQIData.pIID = &riid;
            xCtxQIData.pStdWrapper = this;
            xCtxQIData.pEntry = NULL;

            // Check for the need to switch to the server context
            if(pPS)
            {
                Win4Assert(GetCurrentContext() != GetServerContext());
                hr = SwitchForCallback(pPS, CrossCtxQIFn, &xCtxQIData,
                                       IID_IUnknown, 0, NULL);
            }
            else
            {
                Win4Assert(GetCurrentContext() == GetServerContext());
                hr = CrossCtxQIFn(&xCtxQIData);
            }

            pEntry = xCtxQIData.pEntry;
        }

        // Save the xCtxMarshalData to the stream
        if(pKnownIf || pEntry)
        {
            XCtxMarshalData xCtxMarshalData;

            xCtxMarshalData.dwSignature = CROSSCTX_SIGNATURE;
            xCtxMarshalData.iid = riid;
            xCtxMarshalData.moxid = pOXIDEntry->GetMoxid();
            xCtxMarshalData.pWrapper = this;
            xCtxMarshalData.pEntry = pEntry;
            xCtxMarshalData.pServer = _pServer;
            xCtxMarshalData.pServerCtx = _pID->GetServerCtx();
			xCtxMarshalData.dwMarshalFlags = mshlflags;
            hr = pStm->Write(&xCtxMarshalData, sizeof(xCtxMarshalData), NULL);
            if(SUCCEEDED(hr))
				InternalAddRef();
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::MarshalServer returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CrossCtxMarshalFn             private
//
//  Synopsis:   This is a callback function used for switching to server
//              context during marshaling
//
//  History:    21-Mar-98   Gopalk        Created
//
//--------------------------------------------------------------------
typedef struct tagStdMarshalData
{
    CIDObject *pID;
    IUnknown *pServer;
    const IID *pIID;
    DWORD dwDestCtx;
    void *pvDestCtx;
    DWORD mshlflags;
    OBJREF *pobjref;
} StdMarshalData;

HRESULT __stdcall CrossCtxMarshalFn(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CrossCtxMarshalFn\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    StdMarshalData *pStdMarshalData = (StdMarshalData *) pv;

    // Aquire lock
    LOCK(gComLock);

    // Check if StdID has already been created for the server
    CStdIdentity *pStdID = pStdMarshalData->pID->GetStdID();

    // AddRef StdID appropriately marshal flags
    if(pStdID)
    {
        if (!(pStdMarshalData->mshlflags & MSHLFLAGS_TABLEWEAK))
            pStdID->IncStrongCnt();
        else
            pStdID->AddRef();
    }

    // Release lock
    UNLOCK(gComLock);

    // Create StdID if neccessary
    if(pStdID == NULL)
    {
        DWORD dwFlags = IDLF_CREATE;
        if(!(pStdMarshalData->mshlflags & MSHLFLAGS_TABLEWEAK))
            dwFlags |= IDLF_STRONG;
        if (pStdMarshalData->mshlflags & MSHLFLAGS_NOPING)
            dwFlags |= IDLF_NOPING;
        if (pStdMarshalData->mshlflags & MSHLFLAGS_NO_IEC)
            dwFlags |= IDLF_NOIEC;

        hr = ObtainStdIDFromUnk(pStdMarshalData->pServer,
                                pStdMarshalData->pID->GetAptID(),
                                pStdMarshalData->pID->GetServerCtx(),
                                dwFlags, &pStdID);
    }

    // Obtain Objref from the StdID
    if(SUCCEEDED(hr))
    {
        hr = pStdID->MarshalObjRef(*pStdMarshalData->pobjref,
                                   *pStdMarshalData->pIID,
                                   pStdMarshalData->mshlflags,
                                   pStdMarshalData->dwDestCtx,
                                   pStdMarshalData->pvDestCtx,
                                   NULL);


        // Fixup the refcount on StdID
        if (!(pStdMarshalData->mshlflags & MSHLFLAGS_TABLEWEAK))
        {
            BOOL fKeepAlive = (SUCCEEDED(hr)) ? TRUE : FALSE;
            pStdID->DecStrongCnt(fKeepAlive);
        }
        else
        {
            pStdID->Release();
        }
    }
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "CrossCtxMarshalFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::MarshalInterface     public
//
//  Synopsis:   Marshals the specified interface
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::MarshalInterface(LPSTREAM pStm, REFIID riid,
                                           LPVOID pv, DWORD dwDestCtx,
                                           LPVOID pvDestCtx, DWORD mshlflags)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::MarshalInterface\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    CtxEntry *pWrapperEntry;
    IFaceEntry *pEntry;
    void *pKnownIf;
    CObjectContext *pCurrentCtx;

    // Obtain current context
    pCurrentCtx = GetCurrentContext();

    // Check for disconnected state
    if(IsDisconnected())
    {
        pWrapperEntry = NULL;
        hr = RPC_E_DISCONNECTED;
    }
    else
    {
        // Lookup wrapper entry for the current context
        pWrapperEntry = LookupCtxEntry(pCurrentCtx);
        if(!pWrapperEntry)
            hr = RPC_E_WRONG_THREAD;
    }

    if(pWrapperEntry)
    {
		if (CanWrapperMarshal(dwDestCtx, mshlflags))
		{
            CObjectContext *pSavedCtx;
            BOOL fEnteredNA = FALSE;

            if (IsNAWrapper() && !IsThreadInNTA())
            {
                pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
                fEnteredNA = TRUE;
            }

            hr = MarshalServer(pWrapperEntry->_pPS, pStm, riid, dwDestCtx, pvDestCtx, mshlflags);

            if (fEnteredNA)
            {
                pSavedCtx = LeaveNTA(pSavedCtx);
                Win4Assert(pSavedCtx == g_pNTAEmptyCtx);
            }			
		}
        else
        {
            // Create StdMarshalData on the stack
            StdMarshalData stdMarshalData;
            OBJREF objref;

            // Initialize
            stdMarshalData.pID = _pID;
            stdMarshalData.pServer = _pServer;
            stdMarshalData.pIID = &riid;
            stdMarshalData.dwDestCtx = dwDestCtx;
            stdMarshalData.pvDestCtx = pvDestCtx;
            if(_dwState & WRAPPERFLAG_NOIEC)
                mshlflags |= MSHLFLAGS_NO_IEC;
            if(_dwState & WRAPPERFLAG_NOPING)
                mshlflags |= MSHLFLAGS_NOPING;
            stdMarshalData.mshlflags = mshlflags | MSHLFLAGS_NO_IMARSHAL;
            stdMarshalData.pobjref = &objref;

            // Check for the need to switch to server context
            if(pCurrentCtx != _pID->GetServerCtx())
            {
                // Switch
                hr = SwitchForCallback(pWrapperEntry->_pPS,
                                       CrossCtxMarshalFn, &stdMarshalData,
                                       IID_IMarshal, 5, NULL);
            }
            else
            {
                hr = CrossCtxMarshalFn(&stdMarshalData);
            }

            // Check for success
            if(SUCCEEDED(hr))
            {
                // write the objref into the stream
                hr = WriteObjRef(pStm, objref, dwDestCtx);
                if (FAILED(hr))
                {
                    // undo whatever we just did, ignore error from here since
                    // the stream write error supercedes any error from here.
                    ReleaseMarshalObjRef(objref);
                }

                // free resources associated with the objref.
                FreeObjRef(objref);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::MarshalInterface returning 0x%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   ObtainPolicySet           private
//
//  Synopsis:   Obtains the policy set associated with the given contexts
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT ObtainPolicySet(CObjectContext *pClientCtx, CObjectContext *pServerCtx,
                        DWORD dwState, BOOL *pfCreate, CPolicySet **ppPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::ObtainPolicySet\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    // Sanity check
    Win4Assert(pClientCtx != pServerCtx);

    // Acquire reader lock
    gPSRWLock.AcquireReaderLock();

    // Lookup the policy set between the contexts
    CPolicySet *pPS;
    BOOL fFound = FALSE;
    HRESULT hr = gPSTable.Lookup(pClientCtx, pServerCtx, &pPS, *pfCreate);

    // Release reader lock
    WriterCookie cookie = gPSRWLock.GetWriterCookie();
    gPSRWLock.ReleaseReaderLock();

    // Check if an existing policy set was found
    if(SUCCEEDED(hr))
    {
        Win4Assert(pPS);
        fFound = TRUE;
    }
    else
    {
        if(*pfCreate)
        {
            // Compute the policy set between the contexts
            CPolicySet *pNewPS;
            hr = DeterminePolicySet(pClientCtx, pServerCtx, dwState, &pNewPS);
            if(SUCCEEDED(hr))
            {
                // Acquire writer lock and check for intermediate writes
                gPSRWLock.AcquireWriterLock();
                if(gPSRWLock.IntermediateWrites(cookie))
                {
                    gPSTable.Lookup(pClientCtx, pServerCtx, &pPS, TRUE);
                }

                // Check if other threads have created the desired policy set
                if(pPS == NULL)
                {
                    // Chain the policy set in the involved contexts
                    if(pClientCtx)
                        pNewPS->SetClientContext(pClientCtx);
                    if(pServerCtx)
                        pNewPS->SetServerContext(pServerCtx);

                    // Add the new policy set to the policy set table
                    gPSTable.Add(pNewPS);
                    pPS = pNewPS;
                }
                else
                {
                    fFound = TRUE;
                }

                // Release writer lock
                gPSRWLock.ReleaseWriterLock();

                // Check for the need to destroy the newly creted policy set
                if(fFound)
                {
                    pNewPS->DeliverReleasePolicyEvents();
                    pNewPS->PrepareForDirectDestruction();
                    delete pNewPS;
                }
            }
        }
    }

    // Check for the need to uncache
    if(pPS)
    {
        // Uncache the node if necessary
        if(fFound && pPS->IsCached())
            fFound = (pPS->UncacheIfNecessary() == FALSE);

        // Initialize return value
        *pfCreate = (fFound == FALSE);
    }

    // Initialize return value
    *ppPS = pPS;

    // Sanity check
    Win4Assert((SUCCEEDED(hr)) == (*ppPS!=NULL));

    gPSRWLock.AssertNotHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "ObtainPolicySet returning 0x%x, pPS=0x%x\n", hr, *ppPS));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::ValidateContext     public
//
//  Synopsis:   Validates the context for object and interface
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CtxEntry *CStdWrapper::ValidateContext(CObjectContext *pClientCtx,
                                       IFaceEntry *pIFaceEntry)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::ValidateContext\n"));

    CPolicySet *pPS = NULL;
    CtxEntry *pIFEntry = NULL;
    BOOL fCreated = FALSE;

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Lookup wrapper entry for the current context
    CtxEntry *pWrapperEntry = LookupCtxEntry(pClientCtx);
    if (pWrapperEntry == NULL)
    {
        // Release lock
        UNLOCK(gComLock);
        ASSERT_LOCK_NOT_HELD(gComLock);

        HRESULT hr;
        BOOL fCreate = TRUE;

        hr = ObtainPolicySet(pClientCtx, _pID->GetServerCtx(),
                             PSFLAG_LOCAL, &fCreate, &pPS);

        // Reacquire lock
        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);

        // Another thread could have created the
        // wrapper entry for the current client context
        if (SUCCEEDED(hr))
            pWrapperEntry = LookupCtxEntry(pClientCtx);
    }

    // Check for the need to create wrapper entry
    if (pWrapperEntry)
    {
        pWrapperEntry->AddRef();
    }
    else if (pPS)
    {
        pWrapperEntry = AddCtxEntry(pPS);
    }

    if (pWrapperEntry && pIFaceEntry)
    {
        // Validate client context for this interface
        pIFEntry = pIFaceEntry->ValidateContext(pClientCtx,
                                                pWrapperEntry->_pPS);
    }

    // Release lock
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Cleanup on failure
    if (pIFEntry == NULL && pWrapperEntry && pIFaceEntry)
    {
        CPolicySet *pEntryPS = ReleaseCtxEntry(pWrapperEntry);
        if (pEntryPS)
            pEntryPS->Release();
    }

    // Cleanup
    if (pPS)
        pPS->Release();

    ContextDebugOut((DEB_WRAPPER,
                     "ValidateContext returning 0x%x\n", pWrapperEntry));
    return(pWrapperEntry);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::UnMarshalInterface     public
//
//  Synopsis:   Unmarshals the specified interface
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::UnmarshalInterface(LPSTREAM pStm, REFIID riid,
                                             LPVOID *ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::UnmarshalInterface\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    IMarshal *pIM;

    // Delegate static wrapper
    HRESULT hr = GetStaticWrapper(&pIM);
    if(SUCCEEDED(hr))
        hr = pIM->UnmarshalInterface(pStm, riid, ppv);
    else
        *ppv = NULL;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::UnmarshalInterface returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::ReleaseMarshalData     public
//
//  Synopsis:   Releases the given marshaled data
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::ReleaseMarshalData(LPSTREAM pStm)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::ReleaseMarshalData\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    IMarshal *pIM;

    // Delegate static wrapper
    HRESULT hr = GetStaticWrapper(&pIM);
    if(SUCCEEDED(hr))
        hr = pIM->ReleaseMarshalData(pStm);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::ReleaseMarshalData returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::DisconnectObject     public
//
//  Synopsis:   Disconnects the server object from its clients
//
//  History:    23-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdWrapper::DisconnectObject(DWORD dwReserved)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::DisconnectObject\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // This method can only be called from inside server context
    if(IsDisconnected())
        hr = S_OK;
    else if(_pID->GetServerCtx() == GetCurrentContext())
        hr = Disconnect(NULL);
    else
        hr = RPC_E_WRONG_THREAD;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::DisconnectObject returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CrossCtxDisconnectFn             Internal
//
//  Synopsis:   Disconnects the server object
//
//  History:    23-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagIFaceSvrRefs {
    IRpcStubBuffer *pRpcStub;
    IRpcProxyBuffer *pRpcProxy;
    void *pServer;
    CCtxChnl *pCtxChnl;
} IFaceSvrRefs;

typedef struct tagXCtxDisconnectData
{
#if DBG==1
    CObjectContext *pServerCtx;
#endif
    IUnknown *pServer;
    CIDObject *pID;
    ULONG cIFaces;
    IFaceSvrRefs *pIFaceSvrRefs;
} XCtxDisconnectData;

HRESULT __stdcall CrossCtxDisconnectFn(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CrossCtxDisconnectFn\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    IFaceSvrRefs *pIFaceSvrRefs = ((XCtxDisconnectData *) pv)->pIFaceSvrRefs;
    ULONG cIFaces = ((XCtxDisconnectData *) pv)->cIFaces;
    IUnknown *pServer = ((XCtxDisconnectData *) pv)->pServer;
    CIDObject *pID = ((XCtxDisconnectData *) pv)->pID;

    // Sanity check
    Win4Assert(((XCtxDisconnectData *) pv)->pServerCtx == GetCurrentContext());

    // Release references held on the server by IFaceEntries
    for(ULONG i=0;i<cIFaces;i++)
    {
        // Check to make sure that we use the RPC p/s mechanism
        // in which case the RpcStub is not NULL. In the case of
        // lightweight p/s mechanism this is NULL and so no disconnect
        // is needed
        if(pIFaceSvrRefs[i].pRpcStub)
            pIFaceSvrRefs[i].pRpcStub->Disconnect();
        ((IUnknown *) pIFaceSvrRefs[i].pServer)->Release();
    }

    // Release IDObject
    if(pID)
    {
        pID->WrapperRelease();
        pID->Release();
    }

    // Release server object, but not before calling WrapperRelease on
    // the IDObject because WrapperRelease will cause the SetZombie
    // sequence which requires a server reference to be held
    if(pServer)
        pServer->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "CrossCtxDisconnectFn returning 0x0\n"));
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Disconnect        private
//
//  Synopsis:   Disconnects the server object from its clients
//              Called by DisconnectObject and process uninit code
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::Disconnect(CPolicySet *pPS)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Disconnect\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    ULONG cIFaces = 0;
    IFaceSvrRefs *pIFaceSvrRefs =
        (IFaceSvrRefs *) _alloca(_cIFaces*sizeof(IFaceSvrRefs));
    BOOL fDisconnect = FALSE, fRelease = FALSE;
    IUnknown *pServer;
    CIDObject *pID;

    // Obtain current and server context
    CObjectContext *pCurrentCtx = GetCurrentContext();
    CObjectContext *pServerCtx = _pID ? _pID->GetServerCtx() : pCurrentCtx;

    // Check for the need to create policy set
    if((pPS == NULL) && (pServerCtx != pCurrentCtx) && !IsDisconnected())
    {
        BOOL fCreate = TRUE;

        hr = ObtainPolicySet(pCurrentCtx, pServerCtx,
                             PSFLAG_LOCAL, &fCreate, &pPS);
        if(SUCCEEDED(hr))
            fRelease = TRUE;
    }

    // Check for failure in creating policy set
    if(SUCCEEDED(hr))
    {
        // Acquire lock
        LOCK(gComLock);

        // Check if disconnected already
        if(!IsDisconnected())
        {
            // Sanity check
            Win4Assert(_pID);

            // Remove wrapper from ID object
            if(_pID->RemoveWrapper())
                _dwState |= WRAPPERFLAG_DESTROYID;

            // Update state.
            // Do not move this line. GopalK
            _dwState |= WRAPPERFLAG_DISCONNECTED;

            // Disconnect only when there are no pending calls on the object
            if(_cCalls == 0)
            {
                // Save references held on the server by IFaceEntries
                cIFaces = _cIFaces;
                IFaceEntry *pEntry = _pIFaceHead;
                for(ULONG i=0;i<cIFaces;i++)
                {
                    // Sanity checks
                    // Assert that either the RPC p/s mechanism or lightweight p/s mechanism
                    // is being used
                    Win4Assert(pEntry->_pRpcStub || pEntry->_pUnkInner);
                    Win4Assert(pEntry->_pServer);

                    pIFaceSvrRefs[i].pRpcStub = pEntry->_pRpcStub;
                    pIFaceSvrRefs[i].pServer = pEntry->_pServer;
                    pEntry->_pServer = NULL;

                    pEntry = pEntry->_pNext;
                }

                // Save references held on the server by the wrapper
                pServer = _pServer;
                pID = _pID;
                _pServer = NULL;
                _pID = NULL;

                // Disconnect the object
                fDisconnect = TRUE;
            }
        }

        // Release lock
        UNLOCK(gComLock);
    }

    if(fDisconnect)
    {
        // Create XCtxDisconnectData on the stack
        XCtxDisconnectData xCtxDisconnectData;

        // Initialize
#if DBG==1
        xCtxDisconnectData.pServerCtx = pServerCtx;
#endif
        xCtxDisconnectData.pServer = pServer;
        xCtxDisconnectData.pID = pID;
        xCtxDisconnectData.cIFaces = cIFaces;
        xCtxDisconnectData.pIFaceSvrRefs = pIFaceSvrRefs;

        // Check for the need to switch to server context
        if(pServerCtx != pCurrentCtx)
        {
            // Switch
            hr = SwitchForCallback(pPS, CrossCtxDisconnectFn,
                                   &xCtxDisconnectData,
                                   IID_IMarshal, 6, NULL);
        }
        else
        {
            hr = CrossCtxDisconnectFn(&xCtxDisconnectData);
        }
    }

    // Release policy set if needed
    if(fRelease)
        pPS->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStdWrapper::Disconnect returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CStdWrapper::CrossCtxQI
//
//  Synopsis:   Perform a cross context QI.  Encapsulate CrossCtxQIFn.
//
//  History:    29-Sep-00   JohnDoty      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::CrossCtxQI(CPolicySet *pPS, REFIID riid, 
                                IFaceEntry **ppEntry)
{
    HRESULT hr;

    XCtxQIData xCtxQIData;

    // Initialize QIData
    xCtxQIData.pIID        = &riid;
    xCtxQIData.pStdWrapper = this;
    xCtxQIData.pEntry      = NULL;
    
    // Sanity checks
    Win4Assert(pPS);
    
    // Generate an IFaceEntry for the desired IID
    // Switch to the server context
    if (pPS != NULL)
    {
        hr = SwitchForCallback(pPS, CrossCtxQIFn,
                               &xCtxQIData, IID_IUnknown, 0, NULL);
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    *ppEntry = xCtxQIData.pEntry;

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdWrapper::WrapInterfaceForContext
//
//  Synopsis:   Finds or creates a valid wrapper for our server object
//              in the requested context.
//
//  Arguments:  pClientContext- The client context for the IFaceEntry
//              pUnk- Really an interface pointer of type riid.  This
//                    is an optimization for CreateWrapper, and may be
//                    NULL.
//              riid- The IID of the returned wrapper
//              ppv-  Pointer to the return location
//
//  History:    29-Sep-00   JohnDoty      Created
//
//+-------------------------------------------------------------------
HRESULT CStdWrapper::WrapInterfaceForContext(CObjectContext *pClientContext,
                                             IUnknown *pUnk,
                                             REFIID riid,
                                             void **ppv)
{
    HRESULT hr = S_OK;
    IUnknown *pItf = NULL;

    // If nobody has given us an interface pointer to use, get one
    // ourselves... this is an optimization for CreateWrapper()
    // so that it can return E_NOINTERFACE without searching for
    // us.
    if (pUnk == NULL)
    {
        IUnknown *pServer = GetServer();
        if (pServer)
        {
            hr = pServer->QueryInterface(riid, (void **)&pItf);
        }
        else
        {
            // At this point, pItf is still NULL.  This will
            // be passed into GetOrCreateIFaceEntry, and will
            // signify that we cannot create a new IFaceEntry.
        }
    }
    else
    {
        pItf = pUnk;
        pItf->AddRef();
    }

    if (SUCCEEDED(hr))
    {
        // Validate client context for the wrapper object
        hr = E_OUTOFMEMORY; // Assume OOM
        CtxEntry *pWrapperEntry = ValidateContext(pClientContext,
                                                  NULL);
        if (pWrapperEntry)
        {
            // find/create and interface wrapper
            hr = GetOrCreateIFaceEntry(riid, pItf, pClientContext, 
                                       pWrapperEntry->_pPS, ppv);
        }

        if (SUCCEEDED(hr))
        {
            // keep the wrapper we created
            hr = S_OK;
        }
        else
        {
            CPolicySet *pPS = ReleaseCtxEntry(pWrapperEntry);
            if (pPS)
                pPS->Release();
        }
    }

    if (pItf)
        pItf->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Deactivate    private
//
//  Synopsis:   Releases all the references on the server object as part
//              of deactivating the server
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::Deactivate()
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Deactivate this:%x\n", this));

    typedef struct tagServerRefs
    {
        IRpcStubBuffer *pRpcStub;
        void           *pServer;
    } ServerRefs;

     // Sanity checks
    Win4Assert(_pID->GetServerCtx() == GetCurrentContext());
    Win4Assert(!IsDeactivated());

    // Allocate space on the stack to save references on the server
    // alloca does not return if it could not grow the stack. Note that
    // _cIFaces cannot change for a deactivated object, so it is safe
    // to do this without holding the lock
    ULONG cIFaces = _cIFaces;
    ServerRefs *pServerRefs = (ServerRefs *)_alloca(cIFaces*sizeof(ServerRefs));
    Win4Assert(pServerRefs);

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Update state
    _dwState |= WRAPPERFLAG_DEACTIVATED;

    // Save the reference held on the server by the wrapper
    Win4Assert(_pServer);
    IUnknown *pServer = _pServer;
    _pServer = NULL;

    // Save references held on the server by IFaceEntries
    IFaceEntry *pEntry = _pIFaceHead;
    for (ULONG i=0; i<cIFaces; i++)
    {
        // Sanity checks
        // Assert that either the RPC p/s mechanism or lightweight p/s
        // mechanism is being used
        Win4Assert(pEntry->_pRpcStub || pEntry->_pUnkInner);
        Win4Assert(pEntry->_pServer);

        pServerRefs[i].pRpcStub = pEntry->_pRpcStub;
        pServerRefs[i].pServer  = pEntry->_pServer;
        pEntry->_pServer = NULL;

        pEntry = pEntry->_pNext;
    }

    // Release lock before calling app code
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Release reference held on the server by the wrapper
    pServer->Release();

    // Release references held on the server by IFaceEntries for
    // RPC p/s mechanism. In the lightweight p/s mechanism, there
    // is no notion of a stub
    for (i=0; i<cIFaces; i++)
    {
        if (pServerRefs[i].pRpcStub)
            pServerRefs[i].pRpcStub->Disconnect();

        ((IUnknown *) pServerRefs[i].pServer)->Release();
    }

    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Deactivate this:%x\n", this));
}

//+-------------------------------------------------------------------
//
//  Method:     CStdWrapper::Reactivate    private
//
//  Synopsis:   Acquires the the needed references on the server object
//              as part of reactivating the server
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdWrapper::Reactivate(IUnknown *pServer)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Reactivate this:%x\n", this));

    typedef struct tagServerRefs
    {
        IRpcStubBuffer *pRpcStub;
        void          **ppServer;
        IID            *pIID;
    } ServerRefs;

    // Sanity checks
    Win4Assert(_pID->GetServerCtx() == GetCurrentContext());
    Win4Assert(IsDeactivated());

    // Allocate space on the stack to save references on the server
    // alloca does not return if it could not grow the stack. Note that
    // _cIFaces cannot change for a deactivated object, so it is safe
    // to do this without holding the lock
    ULONG cIFaces = _cIFaces;
    ServerRefs *pServerRefs = (ServerRefs *)_alloca(cIFaces*sizeof(ServerRefs));
    Win4Assert(pServerRefs);

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Update state
    _dwState &= ~WRAPPERFLAG_DEACTIVATED;

    // Init the reference held on the server by the wrapper
    Win4Assert(_pServer == NULL);
    _pServer = pServer;

    // Obtain references held on the server by IFaceEntries
    IFaceEntry *pEntry = _pIFaceHead;
    for (ULONG i=0; i<cIFaces; i++)
    {
        // Sanity check
        Win4Assert(pEntry->_pServer == NULL);

        pServerRefs[i].pRpcStub = pEntry->_pRpcStub;
        pServerRefs[i].ppServer = &pEntry->_pServer;
        pServerRefs[i].pIID     = &pEntry->_iid;

        pEntry = pEntry->_pNext;
    }

    // Release lock before calling app code
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // AddRef server on behalf of wrapper
    pServer->AddRef();

    // Reconnect IFaceEntries to server
    for(i=0; i<cIFaces; i++)
    {
        pServer->QueryInterface(*pServerRefs[i].pIID, pServerRefs[i].ppServer);

        // We call Connect only when a RPC stub and server is
        // available
        if(*pServerRefs[i].ppServer && pServerRefs[i].pRpcStub)
            pServerRefs[i].pRpcStub->Connect((IUnknown *) (*pServerRefs[i].ppServer));
    }

    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Reactivate hr:%x\n", S_OK));
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::Initialize   public
//
//  Synopsis:   Initialize context channel
//
//  History:    13-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxChnl::Initialize()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::Initialize\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Initialize allocator
    s_allocator.Initialize(sizeof(CCtxChnl),
                           CTXCHANNELS_PER_PAGE,
                           &gComLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::Cleanup   public
//
//  Synopsis:   Cleanup context channel
//
//  History:    13-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxChnl::Cleanup()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::Cleanup\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Sanity check
    Win4Assert(s_cChannels == 0);

    // Cleanup alloctor
    s_allocator.Cleanup();

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::CCtxChnl     public
//
//  Synopsis:   Constructor for context channel
//
//  History:    13-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CCtxChnl::CCtxChnl(CStdWrapper *pStdWrapper)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::CCtxChnl\n"));
    ASSERT_LOCK_HELD(gComLock);

    // Initialize
    _dwState = 0;
    _cRefs = 1;
    _pIFaceEntry = NULL;
    _pStdWrapper = pStdWrapper;

    ASSERT_LOCK_HELD(gComLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::~CCtxChnl     public
//
//  Synopsis:   Destructor for context channel
//
//  History:    13-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CCtxChnl::~CCtxChnl()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::CCtxChnl\n"));
    ASSERT_LOCK_DONTCARE(gComLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::QueryInterface     public
//
//  Synopsis:   QI behavior of policy set
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::QueryInterface\n"));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)(IRpcChannelBuffer2 *)this;
    }
    else if(IsEqualIID(riid, IID_IStdCtxChnl))
    {
        *ppv = this;
    }
    else if(IsEqualIID(riid, IID_IRpcChannelBuffer) ||
            IsEqualIID(riid, IID_IRpcChannelBuffer2))
    {
        *ppv = (IRpcChannelBuffer2 *) this;
    }
    else if(IsEqualIID(riid, IID_ICallFrameEvents))
    {
        *ppv = (ICallFrameEvents *) this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // AddRef the interface before return
    if(*ppv)
        ((IUnknown *) (*ppv))->AddRef();

    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::AddRef     public
//
//  Synopsis:   AddRefs context channel
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CCtxChnl::AddRef()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::AddRef\n"));

    ULONG cRefs;

    // Increment ref count
    cRefs = InterlockedIncrement((LONG *)& _cRefs);

    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::Release     public
//
//  Synopsis:   Release context channel
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CCtxChnl::Release()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::Release\n"));

    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &_cRefs);
    // Check if this is the last release
    if(cRefs == 0)
    {
        // Delete call
        LOCK(gComLock);
        delete this;
        UNLOCK(gComLock);
    }

    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::Release returning 0x%x\n",
                     cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::GetBuffer     public
//
//  Synopsis:   Implements IRpcChannelBuffer::GetBuffer
//
//              This method ensures that the interface has legally been
//              unmarshaled in the client context, delivers GetSize events
//              using the policy set, and saves the context call object
//              in TLS
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::GetBuffer(RPCOLEMESSAGE *pMsg, REFIID riid)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::GetBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(riid, iidName);
        char *side = (pMsg->reserved1 == NULL) ?
                     "XCtxClientGetBuffer" :
                     "XCtxServerGetBuffer";

        ContextDebugOut((DEB_TRACECALLS,
                         "%s on interface %I (%ws) method 0x%x\n",
                         side, &riid, iidName, pMsg->iMethod));
    }
#endif

    HRESULT hr = S_OK, hrCall = S_OK;
    CPolicySet *pPS = NULL;
    CCtxCall *pCtxCall = NULL;

    // Obtain the current side
    BOOL fClientSide = (pMsg->reserved1 == NULL);

    // Call GetBuffer2 to do the remaining work
    // GetBuffer2 allocates the buffer on the heap
    hr = GetBuffer2(pMsg, riid, pCtxCall, fClientSide, TRUE, NULL);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCHNL,
                     "CCtxChnl::GetBuffer is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::SendReceive     public
//
//  Synopsis:   Implements IRpcChannelBuffer::SendReceive
//
//              This method identifies the right policy set, asks it
//              to obtain client buffers from the policies, switches to
//              the server context, asks the policy set to deliver the
//              buffers created by the polices on the client side,
//              invokes the call on the server object, obtains serveer
//              side buffers through policy set, switches back to the
//              client context, asks the policy set to deliver the
//              buffers created by the polices on the server side,
//              and finally returns to its caller
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::SendReceive(RPCOLEMESSAGE *pMsg,  ULONG *pulStatus)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::SendReceive\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(_pIFaceEntry->_iid, iidName);

        ContextDebugOut((DEB_TRACECALLS,
                         "XCtxSendReceive on interface %I (%ws) method 0x%x\n",
                         &_pIFaceEntry->_iid, iidName,
                         pMsg->iMethod));
    }
#endif

    HRESULT hr = S_OK;
    COleTls Tls;
    void *pvBuffer;

    // Obtain client side context call object
    CCtxCall *pClientCall = (CCtxCall *) pMsg->reserved1;

    // Ensure that GetBuffer was called before
    Win4Assert(pClientCall && (pClientCall->_dwFlags & CTXCALLFLAG_GBSUCCESS));

    // Save the dispatch buffer
    if(pClientCall->_pvExtent)
        pvBuffer = pClientCall->_pvExtent;
    else
        pvBuffer = pMsg->Buffer;

    // Create rpc call object on the stack
    const IUnknown *pIdentity = _pStdWrapper;
    CRpcCall rpcCall(pIdentity, pMsg, _pIFaceEntry->_iid,
                     hr, CALLSOURCE_CROSSCTX);

    // Obtain the policy set that delivers events
    CPolicySet *pPS = pClientCall->_pPS;
    Win4Assert(pPS);

    // Deliver client side call events
    hr = pPS->FillBuffer(&rpcCall, CALLTYPE_SYNCCALL, pClientCall);

    // Reset state inside context call object
    CPolicySet::ResetState(pClientCall);

    // Invoke on the server
    if(SUCCEEDED(hr))
    {
        // Create rpc call object on the stack
        CRpcCall rpcCall(_pStdWrapper->GetIdentity(),
                         pMsg, _pIFaceEntry->_iid, hr, CALLSOURCE_CROSSCTX);

        // Create server side context call object
        CCtxCall serverCall(CTXCALLFLAG_SERVER | CTXCALLFLAG_CROSSCTX,
                            pMsg->dataRepresentation);

        // Switch to the server context
        CObjectContext *pClientCtx = Tls->pCurrentCtx;
        CObjectContext *pServerCtx = pPS->GetServerContext();
        Tls->pCurrentCtx = pServerCtx;
        Tls->ContextId = pServerCtx->GetId();
        pServerCtx->InternalAddRef();
        ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x --> 0x%x\n",
                         pClientCtx, pServerCtx));

        // If the server is in the NA, make sure the thread is in the NA.
        BOOL fEnteredNA = FALSE;
        BOOL fExitedNA = FALSE;
        if (pServerCtx->GetComApartment() == gpNTAApartment)
        {
            if (!IsThreadInNTA())
            {
                Tls->dwFlags |= OLETLS_INNEUTRALAPT;
                fEnteredNA = TRUE;
            }
        }
        else
        {
            if (IsThreadInNTA())
            {
                Tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
                fExitedNA = TRUE;
            }
        }
        Win4Assert(!IsThreadInNTA() || pServerCtx->GetComApartment() == gpNTAApartment);
        Win4Assert(IsThreadInNTA() || pServerCtx->GetComApartment() != gpNTAApartment);

        // Update server side context call object
        serverCall._pPS = pPS;
        if(pClientCall->_cbExtent)
            serverCall._pvExtent = pvBuffer;
        serverCall._pContext = Tls->pCurrentCtx;


        // Update message
        pMsg->reserved1 = &serverCall;
        pMsg->reserved2[0] = NULL;
        pMsg->reserved2[1] = NULL;
        pMsg->reserved2[3] = NULL;
        pMsg->rpcFlags |= RPC_BUFFER_COMPLETE;

        // Deliver server side notification events
        hr = pPS->Notify(&rpcCall, CALLTYPE_SYNCENTER, &serverCall);

        // Check for the need to dispatch call to server object
        BOOL fDoCleanup = TRUE;
        if(SUCCEEDED(hr))
        {
            // Delegate to StubInvoke
            hr = SyncStubInvoke(pMsg, _pIFaceEntry->_iid,
                                _pStdWrapper->GetIDObject(),
                                (IRpcChannelBuffer3 *) this,
                                _pIFaceEntry->_pRpcStub, pulStatus);
            if (FAILED(hr))
            {
                // Failed to successfully deliver the call to the server
                // object.  Therefore, we don't want to try to cleanup
                // marshaled out param interface ptrs later if server-side
                // leave event deliver fails.
                fDoCleanup = TRUE;
            }

            // Make sure we're back on the right context
            CheckContextAfterCall (Tls, pServerCtx);
        }
        else
        {
            // The call was aborted during the delivery of server-side
            // notify events.  We need to release any marshaled in-param
            // interface ptrs in the marshal buffer.
            ReleaseMarshalBuffer(pMsg, _pIFaceEntry->_pRpcStub, FALSE);
        }

        // Deliver server side leave events
        if(hr != RPC_E_INVALID_HEADER)
        {
            // Check if GetBuffer was called by the stub
            if(serverCall._dwFlags & CTXCALLFLAG_GBSUCCESS)
            {
                // Update call status to that saved in GetBuffer
                if(FAILED(serverCall._hr))
                    hr = serverCall._hr;
            }
            else if(!(serverCall._dwFlags & CTXCALLFLAG_GBFAILED))
            {
                // The call must have failed
                Win4Assert(FAILED(hr));

                // Initailize
                CPolicySet::ResetState(&serverCall);
                pMsg->cbBuffer = 0;
                pMsg->Buffer = NULL;

                // Obtain the buffer size needed by the server side policies
                // GetSize will fail on the server side only if no policy
                // expressed interest in sending data to the client side
                pPS->GetSize(&rpcCall, CALLTYPE_SYNCLEAVE, &serverCall);

                // Allocate buffer if server side  policies wish to send
                // buffer to the client side
                if(serverCall._cbExtent)
                    serverCall._pvExtent = PrivMemAlloc8(serverCall._cbExtent);
            }

            hr = pPS->FillBuffer(&rpcCall, CALLTYPE_SYNCLEAVE, &serverCall);
            if (fDoCleanup && FAILED(hr))
            {
                // The call was successfully delivered to the server object
                // but it was failed during delivery of server-side leave
                // events.  We need to release any marshaled out-param
                // interface ptrs in the marshal buffer.
                ReleaseMarshalBuffer(pMsg, _pIFaceEntry->_pRpcStub, TRUE);
            }
        }

        // Save the return buffer
        if(serverCall._cbExtent)
            pClientCall->_pvExtent = serverCall._pvExtent;

        // Switch back to client context
        ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x <-- 0x%x\n",
                         pClientCtx, pServerCtx));
        pServerCtx->InternalRelease();
        Win4Assert(Tls->pCurrentCtx == pServerCtx);
        Tls->pCurrentCtx = pClientCtx;
        Win4Assert(pClientCtx);
        Tls->ContextId = pClientCtx->GetId();

        // If we switched the thread into the NA, switch it out.
        if (fEnteredNA)
        {
            Tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
        }
        else if (fExitedNA)
        {
            Tls->dwFlags |= OLETLS_INNEUTRALAPT;
        }
        Win4Assert(!IsThreadInNTA() || Tls->pCurrentCtx->GetComApartment() == gpNTAApartment);
        Win4Assert(IsThreadInNTA() || Tls->pCurrentCtx->GetComApartment() != gpNTAApartment);

        // Update message
        pMsg->reserved1 = pClientCall;
        pMsg->rpcFlags |= RPC_BUFFER_COMPLETE;
    }
    else
    {
        // The call was failed during delivery of client-side call events.
        // Free any marshaled interface pointers in the marshal buffer.
        ReleaseMarshalBuffer(pMsg, _pIFaceEntry->_pRpcProxy, FALSE);
    }

    // Free dispatch buffer
    PrivMemFree8(pvBuffer);

    // Deliver client side notification events
    hr = pPS->Notify(&rpcCall, CALLTYPE_SYNCRETURN, pClientCall);

    // Check for premature failure case
    if(FAILED(hr))
    {
        // The call was failed during delivery of client-side notify
        // events.  Free any marshaled interface pointers in the
        // marshal buffer.
        ReleaseMarshalBuffer(pMsg, _pIFaceEntry->_pRpcProxy, TRUE);

        // Free the buffer
        if(pClientCall->_pvExtent)
            PrivMemFree8(pClientCall->_pvExtent);
        else if(pMsg->Buffer)
            PrivMemFree8(pMsg->Buffer);

        // Update the return code
        if(hr != RPC_E_SERVERFAULT)
        {
            *pulStatus = hr;
            hr = RPC_E_FAULT;
        }

        // Unlock the wrapper
        _pStdWrapper->Unlock(pPS);

        // Do not touch any member variables here after as
        // the wrapper  might have deleted the channel
        // due to a nested release

        // Delete client side context call object
        delete pClientCall;

        // Reset
        pMsg->Buffer = NULL;
    }
    else
        pClientCall->_dwFlags |= CTXCALLFLAG_SRSUCCESS;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCHNL,
                     "CCtxChnl::SendReceive is returning hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::FreeBuffer     public
//
//  Synopsis:   Implements IRpcChannelBuffer::FreeBuffer
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::FreeBuffer(RPCOLEMESSAGE *pMsg)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::FreeBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        IID *iidCalled;
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(_pIFaceEntry->_iid, iidName);

        ContextDebugOut((DEB_TRACECALLS,
                         "FreeBuffer on interface %I (%ws) method 0x%x\n",
                         &_pIFaceEntry->_iid, iidName,
                         pMsg->iMethod));
    }
#endif

    if(pMsg->Buffer)
    {
        // This method is never called on the server side
        // Obtain the context call object
        CCtxCall *pCtxCall = (CCtxCall *) pMsg->reserved1;

        // Sanity Checks
        Win4Assert(pCtxCall);
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_CLIENT);
        Win4Assert(pCtxCall->_dwFlags & CTXCALLFLAG_GBSUCCESS);

        // Free buffer
        if(pCtxCall->_pvExtent)
            PrivMemFree8(pCtxCall->_pvExtent);
        else
            PrivMemFree8(pMsg->Buffer);

        // Unlock the wrapper
        _pStdWrapper->Unlock(pCtxCall->_pPS);

        // Do not touch any member variables here after as
        // the wrapper  might have deleted the channel
        // due to a nested release

        // Delete the context call object
        delete pCtxCall;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCHNL,
                     "CCtxChnl::FreeBuffer is returning hr:0x%x\n", S_OK));
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::GetDestCtx     public
//
//  Synopsis:   Implements IRpcChannelBuffer::GetDestCtx
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::GetDestCtx(DWORD *pdwDestCtx, void **ppvDestCtx)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::GetDestCtx\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Initialize return values
    *pdwDestCtx = MSHCTX_CROSSCTX;
    if(ppvDestCtx != NULL)
        *ppvDestCtx = NULL;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::IsConnected     public
//
//  Synopsis:   Implements IRpcChannelBuffer::IsConnected
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::IsConnected()
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::IsConnected\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;

    // Check if the wrapper is disconnected
    if(_pStdWrapper->IsDisconnected())
        hr = S_FALSE;

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::GetProtocolVersion     public
//
//  Synopsis:   Implements IRpcChannelBuffer::GetProtocolVersion
//
//  History:    16-Feb-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::GetProtocolVersion(DWORD *pdwVersion)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::IsConnected\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Return current COMVERSION
    *pdwVersion = MAKELONG(COM_MAJOR_VERSION, COM_MINOR_VERSION);

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::GetBuffer2     private
//
//  Synopsis:   (1) Gets the size of the buffer needed by the policy sets
//              (2) Allocates the buffer and context call object either on the
//                  heap or the stack.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::GetBuffer2(RPCOLEMESSAGE *pMsg, REFIID riid, CCtxCall *pCtxCall,
                                  BOOL fClientSide, BOOL fAllocOnHeap, ULONG* pcbBuffer)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::GetBuffer2\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

#if DBG==1
    if(ContextInfoLevel & DEB_TRACECALLS)
    {
        WCHAR iidName[256];

        iidName[0] = 0;
        GetInterfaceName(riid, iidName);
        char *side = fClientSide ?
                     "XCtxClientGetBuffer2" :
                     "XCtxServerGetBuffer2";

        ContextDebugOut((DEB_TRACECALLS,
                         "%s on interface %I (%ws) method 0x%x\n",
                         side, &riid, iidName, pMsg->iMethod));
    }
#endif

    HRESULT hr = S_OK, hrCall = S_OK;
    CPolicySet *pPS = NULL;

    // Set the out params
    if(pcbBuffer != NULL)
        *pcbBuffer = 0;

    // Ensure that the interface has legally been unmarshaled on the
    // client side
    if(fClientSide)
    {
        // Ensure that TLS is initialized
        COleTls Tls(hr);
        if(SUCCEEDED(hr))
        {
            // Obtain current context
            CObjectContext *pCurrentCtx = GetCurrentContext();

            // Lookup context entry for the current context
            CtxEntry *pEntry = _pIFaceEntry->LookupCtxEntry(pCurrentCtx);
            if(pEntry)
            {
                // Obtain the policy set between the client
                // and server contexts
                pPS = pEntry->_pPS;

                // Lock wrapper for the duration of the call
                hr = _pStdWrapper->Lock(pPS);
                if(SUCCEEDED(hr) && fAllocOnHeap)
                {
                    // Create a new context call object
                    pCtxCall = new CCtxCall(CTXCALLFLAG_CLIENT | CTXCALLFLAG_CROSSCTX,
                                            pMsg->dataRepresentation);
                    if(pCtxCall == NULL)
                        hr = E_OUTOFMEMORY;
                }
            }
            else
                hr = RPC_E_WRONG_THREAD;
        }
    }
    else
    {
        // On the server side, use the existing context call object
        if(fAllocOnHeap)
            pCtxCall = (CCtxCall *) pMsg->reserved1;
        Win4Assert(pCtxCall && (pCtxCall->_dwFlags & CTXCALLFLAG_CROSSCTX));
        CPolicySet::ResetState(pCtxCall);

        // Obtain the policy set between the client
        // and server contexts
        pPS = pCtxCall->_pPS;
    }

    if(SUCCEEDED(hr))
    {
        // Sanity check
        Win4Assert(pPS);

        // Create rpc call object on the stack
        const IUnknown *pIdentity = _pStdWrapper;
        CRpcCall rpcCall(fClientSide ? pIdentity : _pStdWrapper->GetIdentity(),
                         pMsg, riid, hrCall, CALLSOURCE_CROSSCTX);

        // Size the buffer as needed
        hr = pPS->GetSize(&rpcCall,
                          fClientSide ? CALLTYPE_SYNCCALL : CALLTYPE_SYNCLEAVE,
                          pCtxCall);

        // Allocate buffer
        if(SUCCEEDED(hr))
        {
            ULONG cbSize = pMsg->cbBuffer + pCtxCall->_cbExtent;
            if(pcbBuffer)
                *pcbBuffer = cbSize;

            if(fAllocOnHeap)
            {
                pMsg->Buffer = PrivMemAlloc8(cbSize);
                if(pMsg->Buffer)
                {
                    Win4Assert(!(((ULONG_PTR) pMsg->Buffer) & 7) &&
                               "Buffer is not 8-byte aligned");

                    // Save buffer pointer and update the message
                    if(pCtxCall->_cbExtent)
                    {
                        pCtxCall->_pvExtent = pMsg->Buffer;
                        pMsg->Buffer = (((BYTE *) pMsg->Buffer) + pCtxCall->_cbExtent);
                    }
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                // Turn off the GBINIT flag, so DeliverEvents will allocate a buffer
                // before calling LeaveFillBuffer.
                pCtxCall->_dwFlags &= ~CTXCALLFLAG_GBINIT;
            }
        }
        else
        {
            // GetSize fails on the server side only if no policy
            // expressed interest in sending data to client side
            Win4Assert(pCtxCall->_cbExtent == 0);
            pMsg->Buffer = NULL;
        }
    }

    // Update state before returning to the proxy/stub
    if(SUCCEEDED(hr))
    {
        // On the clientside, save policy set inside context call
        // object for future reference
        if(fClientSide)
        {
            // Stabilize reference to policy set
            pPS->AddRef();
            pCtxCall->_pPS = pPS;

            // Save context call object inside message
            pMsg->reserved1 = pCtxCall;
        }

        // Update state inside context call object
        pCtxCall->_dwFlags |= CTXCALLFLAG_GBSUCCESS;
        pCtxCall->_hr = hrCall;
    }
    else
    {
        // Check side
        if(fClientSide)
        {
            // Unlock wrapper
            if(pPS)
                _pStdWrapper->Unlock(pPS);

            // Delete context call object
            if(pCtxCall && fAllocOnHeap)
                delete pCtxCall;

            // Reset
            pMsg->Buffer = NULL;
        }
        else
        {
            // Reset state inside context call object
            CPolicySet::ResetState(pCtxCall);
            pCtxCall->_dwFlags |= CTXCALLFLAG_GBFAILED;
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_CTXCHNL,
                     "CCtxChnl::GetBuffer2 is returning hr:0x%x\n", hr));
    return(hr);

}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::SyncInvoke2     private
//
//  Synopsis:   (1) Unmarshal any [in] interface pointers.
//              (2) Invoke the method on the server object.
//              (3) Marshal the [out] interface pointers.
//              (4) Release the [in] interface pointers.
//              (5) Copy any data values back to the original frame
//              (6) If an error occurs in any of the above, cleanup properly.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::SyncInvoke2(RPCOLEMESSAGE* pMsg, DWORD* pcbBuffer,
                                   CCtxCall* pWalkerServer, CCtxCall* pWalkerClient,
                                   ICallFrame* pClientFrame, ICallFrame* pServerFrame,
                                   CALLFRAMEINFO* pInfo,
                                   HRESULT* phrCall
                                   )
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::SyncInvoke2\n"));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    BOOL fIsIDispatchInvoke = FALSE;
    ICallFrame* pInvokeFrame = (pServerFrame ? pServerFrame : pClientFrame);
    DWORD dwWalkWhat;

    // Walk the [in] interface pointers unmarshaling them
    if(0 != pInfo->cInInterfacesMax)
    {
        // Make sure that the walker used to marshal the interface ptr
        // is also used to unmarshal the interface ptr
        pWalkerClient->_dwStage = STAGE_UNMARSHAL;
        dwWalkWhat = CALLFRAME_WALK_IN;
        
        // The case of IDispatch::Invoke is special as it has some
        // [in,out] parameters
        if(pInfo->fDerivesFromIDispatch && (6 == pInfo->iMethod))
        {
            fIsIDispatchInvoke = TRUE;
            dwWalkWhat |= CALLFRAME_WALK_INOUT;
        }
        
        hr = pInvokeFrame->WalkFrame(dwWalkWhat, pWalkerClient);
    }

    if(SUCCEEDED(hr))
    {
        // Sanity check - Interceptors return error for any hr != S_OK
        Win4Assert(hr == S_OK);
        
        // Invoke the method and wrap it in a try-catch block to
        // catch user-level exceptions
        _try
        {
            hr = pInvokeFrame->Invoke(_pIFaceEntry->_pServer);
            if(FAILED(hr))
            {
                // This is unexpected as someting went wrong with
                // the callframe invocation mechansim.
                Win4Assert(FALSE && "Internal failure in ICallFrame::Invoke");
            }
            // Get the HRESULT of the method call on the server object
            *phrCall = pInvokeFrame->GetReturnValue();
        }
        _except(AppInvokeExceptionFilter(GetExceptionInformation(), pInfo->iid, pInfo->iMethod))
        {
        	*phrCall = RPC_E_SERVERFAULT;
            hr = RPC_E_SERVERFAULT;
        }

        // We need to free the server frame only if it has been copied
        // Note that we do free the server frame even if the call invoke
        // itself has failed in order to release the [in] interface pointers
        // and put in [out] values that the client might expect
        if(pServerFrame)
        {
            // Set the flag for the release of [in] interface ptrs during free
            // of frame.
            pWalkerClient->_dwStage = STAGE_FREE;
            
            // Set up the walkers for freeing/marshaling of interface ptrs
            ICallFrameWalker* pMarshalOut = NULL;
            ICallFrameWalker* pFreeIn = NULL;
            
            if(0 != pInfo->cOutInterfacesMax)
                pMarshalOut = (ICallFrameWalker *)pWalkerServer;
            
            if(0 != pInfo->cInInterfacesMax)
                pFreeIn = (ICallFrameWalker *)pWalkerClient;
            
            ULONG dwFreeWhat = CALLFRAME_FREE_IN | CALLFRAME_FREE_TOP_OUT;
            
			if (fIsIDispatchInvoke)
            {
				// This will free our dispparams.
                dwFreeWhat |= CALLFRAME_FREE_TOP_INOUT;
            }

            CNullWalker nullWalker;
            hr = pServerFrame->Free(pClientFrame,         // Frame to which return values are copied
                                    &nullWalker,          // Null out source [in,out] interfaces, since we'll 
                                                          // release them later.
                                    pMarshalOut,          // Walks the [out] interface ptrs
                                                          // of the source frame, marshaling them and
                                                          // releasing them
                                    dwFreeWhat,           // Free [in] and top [out] parameters of source frame
                                    pFreeIn,              // Releases the interface pointers of
                                                          // the source frame.
                                    CALLFRAME_NULL_NONE); // Do not null out params
            if(FAILED(hr))
            {
                // Free any memmory allocated during marshaling of [out]
                // interface ptrs and release the [out] interface ptrs
                pWalkerServer->_fError = TRUE;
                pInvokeFrame->WalkFrame(CALLFRAME_WALK_OUT, pWalkerServer);

                // Release the [in] interface ptrs that were not released
                // during the call to free above
                pWalkerClient->_fError = TRUE;
                pInvokeFrame->WalkFrame(CALLFRAME_WALK_IN, pWalkerClient);
            }
        }

        if(SUCCEEDED(hr))
        {
            // Get the size of the buffer that is needed by the policy sets
            hr = GetBuffer2(pMsg,_pIFaceEntry->_iid,pWalkerServer,FALSE,FALSE,pcbBuffer);
        }
    }
    else
    {
        // Unmarshaling of [in] interface pointers failed
        // Walk the frame again, releasing any memory allocated during the
        // marshaling of pointers and also releasing any extra references
        // on [in] interface ptrs
        pWalkerClient->_fError = TRUE;
        pInvokeFrame->WalkFrame(CALLFRAME_WALK_IN, pWalkerClient);

    }

    ContextDebugOut((DEB_CTXCHNL,"CCtxChnl::SyncInvoke2 is returning hr:0x%x\n", hr));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::SendReceive2     private
//
//  Synopsis:   (1) Allocate a buffer for client side call events on the stack
//              (2) Deliver the client call side call
//              (3) Switch to server context
//              (4) Deliver server side enter events
//              (5) Call SyncInvoke2
//              (6) Allocate buffer for server side leave events on the heap
//              (7) Deliver server side leave events
//              (8) Switch to client context
//              (9) Deliver client side return events
//              (10) If any of the above fails, then clean up properly.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::SendReceive2(RPCOLEMESSAGE *pMsg,  HRESULT *phrCall,
                                    DWORD cbBuffer, CCtxCall* pWalkerClient, CCtxCall* pWalkerServer,
                                    ICallFrame* pClientFrame, ICallFrame* pServerFrame,
                                    CALLFRAMEINFO* pInfo)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::SencReceive2\n"));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    HRESULT hrRet = S_OK;
    CObjectContext *pClientCtx = NULL;
    CObjectContext *pServerCtx = NULL;
    CPolicySet* pPS = NULL;
    LPVOID pvBuff = NULL;
    DWORD_PTR dwPtr = 0;

    // Ensure that GetBuffer was called before
    Win4Assert(pWalkerClient && (pWalkerClient->_dwFlags & CTXCALLFLAG_GBSUCCESS));

    // Get the tls
    COleTls tls(hr);

    if(SUCCEEDED(hr))
    {
        pClientCtx = tls->pCurrentCtx;

        // Allocate the buffer size requested on the stack
        pvBuff = _alloca(cbBuffer+7);
        if(NULL == pvBuff)
            hr = E_OUTOFMEMORY;
        else
        {
            // Align to eight-byte boundary
            dwPtr = (((DWORD_PTR)pvBuff) + 7) & ~0x7;
            pMsg->Buffer = (LPVOID)dwPtr;
            pMsg->cbBuffer = cbBuffer;
            Win4Assert(!(((ULONG_PTR) pMsg->Buffer) & 7) &&
                       "Buffer is not 8-byte aligned");

            if(pInfo->fDerivesFromIDispatch)
            {
                // If the method is IDispatch::Invoke then extract
                // the dispid from the stack and put it in the buffer
                if(6 == pInfo->iMethod)
                {
                    Win4Assert(sizeof(DISPID) <= pMsg->cbBuffer);
                    LPVOID pvStack = pClientFrame->GetStackLocation();
                    CALLFRAMEPARAMINFO param = {0,};
                    // DISPID is the first parameter to the call
                    hr = pClientFrame->GetParamInfo(0,&param);
                    if(SUCCEEDED(hr))
                    {
                        *(DISPID *)(pMsg->Buffer) =
                            *(DISPID *)(((LPBYTE)pvStack) + param.stackOffset);
                    }
                }
            }
            // Save buffer pointer and update the message
            if(pWalkerClient->_cbExtent)
            {
               pWalkerClient->_pvExtent = pMsg->Buffer;
               pMsg->Buffer = (((BYTE *) pMsg->Buffer) + pWalkerClient->_cbExtent);
            }
        }


        if(SUCCEEDED(hr))
        {
            // Save the dispatch buffer because CPolicySet::ResetState
            // clears it
            if(pWalkerClient->_pvExtent)
                pvBuff = pWalkerClient->_pvExtent;
            else
                pvBuff = pMsg->Buffer;

            // Get the Policy set node set during call to GetBuffer2
            pPS = pWalkerClient->_pPS;

            // Create rpc call object on the stack
            const IUnknown *pIdentity = _pStdWrapper;
            CRpcCall rpcClient(pIdentity, pMsg, _pIFaceEntry->_iid,
                               hrRet, CALLSOURCE_CROSSCTX);

            // Deliver client side call events
            hr = pPS->FillBuffer(&rpcClient, CALLTYPE_SYNCCALL, pWalkerClient);

            // Reset state inside context call object
            CPolicySet::ResetState(pWalkerClient);
            if(SUCCEEDED(hr))
            {
                // Create rpc call object on the stack
                CRpcCall rpcServer(_pStdWrapper->GetIdentity(),
                                    pMsg, _pIFaceEntry->_iid,
                                    hrRet, CALLSOURCE_CROSSCTX);

                // Switch to the server context
                pServerCtx = pPS->GetServerContext();
                tls->pCurrentCtx = pServerCtx;
                if(pServerCtx)
                {
                    pServerCtx->InternalAddRef();
                    tls->ContextId = pServerCtx->GetId();
                }
                else
                {
                    tls->ContextId = (ULONGLONG)-1;
                }

                 // If the server is in the NA, make sure the thread is in the NA.
                 BOOL fEnteredNA = FALSE;
                if (pServerCtx->GetComApartment() == gpNTAApartment)                
                {
                    if (!IsThreadInNTA())
                    {
                        tls->dwFlags |= OLETLS_INNEUTRALAPT;
                        fEnteredNA = TRUE;
                    }
                }
                Win4Assert(!IsThreadInNTA() || pServerCtx->GetComApartment() == gpNTAApartment);
                Win4Assert(IsThreadInNTA() || pServerCtx->GetComApartment() != gpNTAApartment);

                // Update server side context call object
                pWalkerServer->_pPS = pPS;
                // NOTE: This variable is set in GetBuffer2
                if(pWalkerClient->_cbExtent)
                    pWalkerServer->_pvExtent = pvBuff;
                pWalkerServer->_pContext = tls->pCurrentCtx;
                ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x --> 0x%x\n",
                             pClientCtx, tls->pCurrentCtx));


                // Update message
                pMsg->reserved1 = pWalkerServer;
                pMsg->reserved2[0] = NULL;
                pMsg->reserved2[1] = NULL;
                pMsg->reserved2[3] = NULL;
                pMsg->rpcFlags |= RPC_BUFFER_COMPLETE;

                // Deliver server side notification events
                hr = pPS->Notify(&rpcServer, CALLTYPE_SYNCENTER, pWalkerServer);

                if(SUCCEEDED(hr))
                {
                    // Unmarshal the interface ptrs, invoke the call and marshal the
                    // interface ptrs
                    hr = SyncInvoke2(pMsg, &cbBuffer, pWalkerServer, pWalkerClient,
                                    pClientFrame,pServerFrame, pInfo, phrCall);

                    // Make sure we're back on the right context
                    CheckContextAfterCall (tls, pServerCtx);
                }

                // Deliver server side leave events
                if(hr != RPC_E_INVALID_HEADER)
                {
                    // Check if GetBuffer was called by the stub
                    if(pWalkerServer->_dwFlags & CTXCALLFLAG_GBSUCCESS)
                    {
                        // Update call status to that saved in GetBuffer
                        if(FAILED(pWalkerServer->_hr))
                            hr = pWalkerServer->_hr;
                    }
                    else if(!(pWalkerServer->_dwFlags & CTXCALLFLAG_GBFAILED))
                    {
                        // The call must have failed
                        Win4Assert(FAILED(hr));

                        // Initialize
                        CPolicySet::ResetState(pWalkerServer);
                        pMsg->cbBuffer = 0;
                        pMsg->Buffer = NULL;

                        // Obtain the buffer size needed by the server side policies
                        // GetSize will fail on the server side only if no policy
                        // expressed interest in sending data to the client side
                        pPS->GetSize(&rpcServer, CALLTYPE_SYNCLEAVE, pWalkerServer);

                        // Allocate buffer if server side  policies wish to send
                        // buffer to the client side
                        if(pWalkerServer->_cbExtent)
                        {
                            pWalkerServer->_pvExtent = PrivMemAlloc8(pWalkerServer->_cbExtent);
                            if(NULL == pWalkerServer->_pvExtent)
                                hr = E_OUTOFMEMORY;
                        }
                    }

                    rpcServer.SetServerHR(*phrCall);

                    //
                    //  Deliver the (server-side) leave events.  Note that we are ignoring
                    //  the return result of this call.   This is because policies should
                    //  never fail the leave and return events;  however, the implementation
                    //  of CPolicySet::DeliverEvents ends up returning the hresult that the
                    //  the policies may have set via ICall::Nullify.    So we ignore the
                    //  return result here, and only pay attention to the server's hr and
                    //  the hr set by the policies.
                    //
                    hr = pPS->FillBuffer(&rpcServer, CALLTYPE_SYNCLEAVE, pWalkerServer);
                }

                // Save the return buffer
                if(pWalkerServer->_cbExtent)
                    pWalkerClient->_pvExtent = pWalkerServer->_pvExtent;

                // Switch back to the saved context
                ContextDebugOut((DEB_TRACECALLS, "Context switch:0x%x <-- 0x%x\n",
                    pClientCtx, tls->pCurrentCtx));

                if(pServerCtx)
                {
                    pServerCtx->InternalRelease();
                    pServerCtx = NULL;
                }

                tls->pCurrentCtx = pClientCtx;
                Win4Assert(pClientCtx);
                tls->ContextId = pClientCtx->GetId();

                // If we switched the thread into the NA, switch it out.
                if (fEnteredNA)
                {
                    tls->dwFlags &= ~OLETLS_INNEUTRALAPT;
                }
                Win4Assert(!IsThreadInNTA() || tls->pCurrentCtx->GetComApartment() == gpNTAApartment);
                Win4Assert(IsThreadInNTA() || tls->pCurrentCtx->GetComApartment() != gpNTAApartment);

                // Update message
                pMsg->reserved1 = pWalkerClient;
                pMsg->rpcFlags |= RPC_BUFFER_COMPLETE;
            }

            // Deliver client side notification events
            rpcClient.SetServerHR(*phrCall);

            //
            //  Here again we are ignoring the return code from delivering the
            //  return events.    See the comments above where we deliver
            //  the leave events for more information.
            //
            hr = pPS->Notify(&rpcClient, CALLTYPE_SYNCRETURN, pWalkerClient);

            //
            //  If the policies (if any) did not override the server's hr, then
            //  do normal unmarshalling.   Otherwise, we need to cleanup the
            //  server's out-params, since he might think everything is okay.
            //
            if(SUCCEEDED(hrRet))
            {
                // Unmarshal the [out] interface pointers
                if(0 != pInfo->cOutInterfacesMax)
                {
                    pWalkerServer->_dwStage = STAGE_UNMARSHAL;
                    DWORD dwWalkWhat = CALLFRAME_WALK_OUT;

                    // The case of IDispatch::Invoke is special as it has some
                    // [in,out] parameters.
                    if(pInfo->fDerivesFromIDispatch && (6 == pInfo->iMethod))
                        dwWalkWhat |= CALLFRAME_WALK_INOUT;

                    hr = pClientFrame->WalkFrame(
                                                dwWalkWhat,
                                                pWalkerServer   // Walker will unmarshal
                                                                // the out parameters
                                                );
                    if(FAILED(hr))
                    {
                        // Free any memory allocated during marshaling of [out]
                        // interface ptrs and release the [out] interface ptrs
                        pWalkerServer->_fError = TRUE;
                        pClientFrame->WalkFrame(dwWalkWhat, pWalkerServer);
                    }
                }

                // Release and free the storage for any [in,out] interfaces
                // we've found.
                if (pInfo->fDerivesFromIDispatch && (6 == pInfo->iMethod))
                {
                    if (pWalkerClient->_cItfs > 0)
                        pWalkerClient->FreeBuffer();
                }
            }
            else
            {
              // One or more policies decided to nullify the call.  This means we
              // must cleanup for the server.

              ICallFrameWalker* pWalkerTemp = NULL;

              // Use the walker to properly free/null interface parameters
              if(0 != pInfo->cOutInterfacesMax)
              {
                pWalkerServer->_fError = TRUE;
                pWalkerServer->_dwStage = STAGE_UNMARSHAL;
                pWalkerTemp = pWalkerServer;
              }

              hr = pClientFrame->Free(NULL,
                                      NULL,
                                      NULL,
                                      CALLFRAME_FREE_OUT | CALLFRAME_FREE_INOUT,
                                      pWalkerTemp,
                                      CALLFRAME_NULL_OUT | CALLFRAME_NULL_INOUT);

            }
        }
    }


    // Restore contexts in case a failure did not restore them
    if(pClientCtx)
    {
        tls->pCurrentCtx = pClientCtx;
        tls->ContextId = pClientCtx->GetId();
    }

    if(pServerCtx)
    {
        pServerCtx->InternalRelease();
        pServerCtx = NULL;
    }

    // Check for premature failure case
    if(FAILED(hrRet))
    {
        // Reset
        pMsg->Buffer = NULL;
    }
    else
        pWalkerClient->_dwFlags |= CTXCALLFLAG_SRSUCCESS;

    ContextDebugOut((DEB_CTXCHNL,"CCtxChnl::SendReceive2 is returning hr:0x%x\n", hr));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);
    return hrRet;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxChnl::OnCall     private
//
//  Synopsis:   Implements the ICallFrame::OnCall method
//              (1) Get the callframe info
//              (2) Allocate the client context and server context call objects
//              (3) Copy the frame if there are interface pointer parameters
//              (4) Call GetBuffer2 to get the buffer needed by policy sets
//              (5) Call SendReceive2
//              (6) If any of the above fails, clean up properly.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxChnl::OnCall(ICallFrame* pClientFrame)
{
    ContextDebugOut((DEB_CTXCHNL, "CCtxChnl::OnCall\n"));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);


    HRESULT hr = S_OK;
    CALLFRAMEINFO info = {0,};
    HRESULT hrCall = S_OK;
    ICallFrame* pServerFrame = NULL;
    CPolicySet* pPS = NULL;
    BOOL fLockedWrapper = FALSE;
    DWORD cbBuffer = 0;
    LPVOID pvBuff = NULL;
    DISPID dispID = 0;

    // Get the callframe information
    hr = pClientFrame->GetInfo(&info);

    if(SUCCEEDED(hr))
    {
        // Assert that there are no [in,out] interface parameters or the
        // interface derives from IDipatch or it is IDispatch itself
        Win4Assert(((0 == info.cInOutInterfacesMax)
                    || (info.fDerivesFromIDispatch)
                    || (IID_IDispatch == info.iid))
                    && "[in,out] interfaces present");


        // Create an RPCOLEMESSAGE data structure on the stack
        RPCOLEMESSAGE msg = {
                            NULL,                           // reserved1
                            NDR_LOCAL_DATA_REPRESENTATION,  // dataRepresentation
                            pvBuff,                         // Buffer
                            cbBuffer,                       // cbBuffer
                            info.iMethod,                   // iMethod
                            {0,},                           // reserved2[5]
                            0,                              // rpcFlags
                            };


        // Create a client context call object
        CCtxCall walkerClient(
                            CTXCALLFLAG_CLIENT | CTXCALLFLAG_CROSSCTX,
                            msg.dataRepresentation,
                            STAGE_MARSHAL          // Marshaling stage
                            );

        // Create a server context call object
        CCtxCall walkerServer(
                            CTXCALLFLAG_SERVER | CTXCALLFLAG_CROSSCTX,
                            msg.dataRepresentation,
                            STAGE_MARSHAL          // Unmarshaling stage
                            );

        // Get the size of the buffer that is needed by the policy sets
        hr = GetBuffer2(&msg,_pIFaceEntry->_iid,&walkerClient,TRUE,FALSE,&cbBuffer);

        // For IDispatch::Invoke we have to provide DISPID as the first
        // value in the RPCOLEMESSAGE buffer
        if(info.fDerivesFromIDispatch && 6 == info.iMethod)
            cbBuffer += sizeof(DISPID);

        if(SUCCEEDED(hr))
        {
            // A successful call to GetBuffer2 locks the wrapper object
            fLockedWrapper = TRUE;

            // A successful call to GetBuffer2 sets the Policy Set
            pPS = walkerClient._pPS;

            if (info.fDerivesFromIDispatch && (6 == info.iMethod))
            {
                // Count [in,out] interface pointers
                // Note that our IDispatch::Invoke counts all interface 
                // pointers as [in,out] if they're BYREF.
                walkerClient._cItfs   = 0;
                walkerClient._dwStage = STAGE_COUNT;
                pClientFrame->WalkFrame(CALLFRAME_WALK_INOUT, &walkerClient);
                
                // If there were any [in,out] interface pointers, collect them
                // prior to marshaling.
                if (walkerClient._cItfs > 0)
                {
                    if (walkerClient.AllocBuffer())
                    {                    
                        walkerClient._idx = 0;
                        walkerClient._dwStage = STAGE_MARSHAL | STAGE_COLLECT;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                } else {
                    walkerClient._dwStage = STAGE_MARSHAL;
                }
            }

            if (SUCCEEDED(hr))
            {
                // Get a copy of the client frame, in the process of copying the
                // [in] and [in,out] interface parameters get marshaled
                if(0 != info.cInInterfacesMax)
                {
                    walkerClient._dwStage |= STAGE_COPY;
                    hr = pClientFrame->Copy(CALLFRAME_COPY_NESTED, &walkerClient, &pServerFrame);
                    walkerClient._dwStage &= ~STAGE_COPY;
                }
                else if(0 != info.cOutInterfacesMax)
                    hr = pClientFrame->Copy(CALLFRAME_COPY_NESTED, NULL, &pServerFrame);
            }

            // Make sure that hr is S_OK as interceptors throw for any
            // hr != S_OK. Also make sure that the copy succeeded.
            if(S_OK == hr && S_OK == walkerClient._hr)
            {
                // This will invoke the method on the object
                hr = SendReceive2(&msg,&hrCall,cbBuffer, &walkerClient,
                                    &walkerServer, pClientFrame, pServerFrame, &info);
            }
            else
            {
                // The copy of the client frame has failed
                // Walk the frame and release any memory allocated
                // during marshaling of [in] interface ptrs
                walkerClient._fError = TRUE;
                if(pServerFrame)
                    pServerFrame->WalkFrame(CALLFRAME_WALK_IN, &walkerClient);

                // Set the appropriate failure value
                if(S_OK == hr && S_OK != walkerClient._hr)
                    hr = walkerClient._hr;
            }
        }
    }

    // Set the return value because the return value is propagated to
    // the client and not the hr. Additionally, force the hr to be S_OK
    if(S_OK != hrCall)
    {
        pClientFrame->SetReturnValue(hrCall);
    }
    else
    {
        pClientFrame->SetReturnValue(hr);
    }
    hr = S_OK;

    // Release the server frame
    if(pServerFrame)
        pServerFrame->Release();

    if(fLockedWrapper)
        // Unlock the wrapper
        _pStdWrapper->Unlock(pPS);

    ContextDebugOut((DEB_CTXCHNL,"CCtxChnl::OnCall is returning hr:0x%x\n", hr));
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   CoCreateObjectInContext   Public
//
//  Synopsis:   Creates a wrapper for the given object from the specified
//              context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
STDAPI CoCreateObjectInContext(IUnknown *pServer, IObjContext *pCtx,
                               REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CoCreateObjectInContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CObjectContext *pCurrentCtx;
    CObjectContext *pServerCtx;
    HRESULT hr;

    // Initialize
    *ppv = NULL;

    // Ensure that the object context is indeed CObjectContext
    hr = pCtx->QueryInterface(IID_IStdObjectContext, (void **) &pServerCtx);
    if(SUCCEEDED(hr))
    {
        // Internal code.  We want an internal ref count.
        pServerCtx->InternalAddRef();
        pServerCtx->Release();

        // Initialize channel
        hr = InitChannelIfNecessary();

        if(SUCCEEDED(hr))
        {
            // REVIEW: Ensure that there is no existing wrapper
            //         with the desired interface for perf
            ;

            // Obtain current context
            pCurrentCtx = GetCurrentContext();

            // Ensure that the contexts are different
            if(pCurrentCtx != pServerCtx)
            {
                 // Create XCtxWrapperData
                XCtxWrapperData wrapperData;

                // Initialize
                wrapperData.pIID       = &riid;
                wrapperData.pServer    = pServer;
                wrapperData.dwState    = 0;
                wrapperData.pServerCtx = pServerCtx;
                wrapperData.pClientCtx = pCurrentCtx;

                // Perform callback to create wrapper
                hr = PerformCallback(pServerCtx, CreateWrapper, &wrapperData,
                                     IID_IStdWrapper, 3, NULL);
                if(SUCCEEDED(hr))
                    *ppv = wrapperData.pv;
            }
            else
                hr = E_INVALIDARG;
        }

        // Release server context
        pServerCtx->InternalRelease();
    }
    else
        hr = E_INVALIDARG;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CoCreateObjectInContext returning hr:0x%x\n", hr));
    return(hr);
}


//---------------------------------------------------------------------------
//
//  Function:   MarshalObjectToContext   Public
//
//  Synopsis:   Creates a wrapper for the given object from the specified
//              context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT MarshalObjectToContext(CObjectContext *pClientCtx, IUnknown *pServer,
                               DWORD dwState, REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_WRAPPER, "MarshalObjectToContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity check
    Win4Assert(!CStdWrapper::IsNotImplInterface(riid));

    // Initialize
    XCtxWrapperData wrapperData;
    wrapperData.pIID       = &riid;
    wrapperData.pServer    = pServer;
    wrapperData.dwState    = dwState;
    wrapperData.pServerCtx = GetCurrentContext();
    wrapperData.pClientCtx = pClientCtx;

    // Delegate to CreateWrapper
    HRESULT hr = CreateWrapper(&wrapperData);
    *ppv = wrapperData.pv;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "MarshalObjectToContext returning hr:0x%x\n", hr));
    return(hr);
}

//---------------------------------------------------------------------------
//
//  Function:   FindOrCreateWrapper   Private
//
//  Synopsis:   Lookup/Create a wrapper for the given object
//
//  Parameters: [pUnkServer] - controlling IUnknown of the server object
//              [pServerCtx] - context in which the object lives
//              [fCreate]    - TRUE: create the IDObject if it does not exist
//              [dwFlags]    - IDLF_* flags (used only if wrapper created)
//              [ppWrapper]  - where to return the CStdWrapper ptr,
//                             InternalAddRef'd.
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT FindOrCreateWrapper(IUnknown *pUnkServer, CObjectContext *pServerCtx,
                            BOOL fCreate, DWORD dwFlags, CStdWrapper **ppWrapper)
{
    ContextDebugOut((DEB_WRAPPER, "FindOrCreateWrapper pUnkServer:%x\n", pUnkServer));

    *ppWrapper = NULL;

    // Find or create an IDObject and StdWrapper
    CIDObject *pID    = NULL;
    APTID     dwAptId = GetCurrentApartmentId();

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Lookup IDObject for the server object
    HRESULT hr = gPIDTable.FindOrCreateIDObject(pUnkServer, pServerCtx,
                                                fCreate, dwAptId, &pID);
    if (SUCCEEDED(hr))
    {
        // Sanity check
        Win4Assert(pID->GetServer() == pUnkServer);
        Win4Assert(pID->IsServer());

        // Obtain the wrapper
        hr = pID->GetOrCreateWrapper(fCreate, dwFlags, ppWrapper);
    }

    // Release lock
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (pID)
    {
        // release reference acquired above
        pID->Release();
    }

    ContextDebugOut((DEB_WRAPPER, "FindOrCreateWrapper hr:%x pWrapper:%x\n",
                    hr, *ppWrapper));
    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   CreateWrapper   Private
//
//  Synopsis:   Creates a wrapper for the given object
//
//  Parameters: [pv] - ptr to XCtxWrapperData structure
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT __stdcall CreateWrapper(void *pv)
{
    ContextDebugOut((DEB_WRAPPER, "CreateWrapper\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity check
    XCtxWrapperData *pWrapperData = (XCtxWrapperData *) pv;
    Win4Assert(pWrapperData->pServerCtx == GetCurrentContext());
    Win4Assert(!CStdWrapper::IsNotImplInterface(*pWrapperData->pIID));

    // Initialize
    pWrapperData->pv = NULL;

    // make sure the server supports the requested interface.
    IUnknown *pUnk = NULL;
    HRESULT hr = pWrapperData->pServer->QueryInterface(*pWrapperData->pIID,
                                                       (void **) &pUnk);
    if (SUCCEEDED(hr))
    {
        // object supports the interface. find or create the wrapper
        CStdWrapper *pStdWrapper = NULL;
        hr = FindOrCreateWrapper(pWrapperData->pServer,
                                 pWrapperData->pServerCtx,
                                 TRUE /*fCreate*/,
                                 pWrapperData->dwState,
                                 &pStdWrapper);
        if (SUCCEEDED(hr))
        {
            hr = pStdWrapper->WrapInterfaceForContext(
                                          pWrapperData->pClientCtx,
                                          pUnk,
                                         *pWrapperData->pIID,
                                         &pWrapperData->pv);

            // WrapInterfaceForContext does not give us a new reference,
            // so we'll recycle the one from FindOrCreateWrapper() if 
            // WrapInterfaceForContext fails.
            if (FAILED(hr))
            {
                pStdWrapper->InternalRelease(NULL);
            }
        }

        pUnk->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "CreateWrapper returning 0x%x\n", hr));
    return(hr);
}

//---------------------------------------------------------------------------
//
//  Function:   ObtainWrapper   Private
//
//  Synopsis:   Lookup/Create a wrapper for the given object
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CStdWrapper *ObtainWrapper(IUnknown *pServer, BOOL fCreate, DWORD mshlflags)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    CStdWrapper *pStdWrapper = NULL;

    // Get the IUnknown interface of the object.
    IUnknown *pUnkServer = NULL;
    HRESULT hr = pServer->QueryInterface(IID_IUnknown, (void **) &pUnkServer);
    if (SUCCEEDED(hr))
    {
        // Set up the creation flags based on the mshlflags passed in.
        DWORD dwFlags = 0;

        if (mshlflags & MSHLFLAGS_NO_IEC)
            dwFlags |= IDLF_NOIEC;

        if (mshlflags & MSHLFLAGS_NOPING)
            dwFlags |= IDLF_NOPING;

        hr = FindOrCreateWrapper(pUnkServer, GetCurrentContext(),
                                 fCreate, dwFlags, &pStdWrapper);

        pUnkServer->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return pStdWrapper;
}

//---------------------------------------------------------------------------
//
//  Function:   GetStaticWrapper   Private
//
//  Synopsis:   Returns the global wrapper used for unmarshaling
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT GetStaticWrapper(IMarshal **ppIM)
{
    if (gpStaticWrapper == NULL)
    {
        // not yet initialized, create a static wrapper
        CStaticWrapper *pStaticWrapper = new CStaticWrapper();
        if (!pStaticWrapper)
        {
            // could not create it, return an error
            return E_OUTOFMEMORY;
        }

        if (InterlockedCompareExchangePointer((void **)&gpStaticWrapper,
                                               pStaticWrapper,
                                               NULL) != NULL)
        {
            // another thread created it first, so just delete
            // the one we created.
            delete pStaticWrapper;
        }
    }

    *ppIM = (IMarshal *) gpStaticWrapper;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Function:   WrapperMarshalObject   Private
//
//  Synopsis:   Returns the global wrapper used for unmarshaling
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT WrapperMarshalObject(IStream *pStm, REFIID riid, IUnknown *pUnk,
                             DWORD dwDestCtx, void *pvDestCtx, DWORD mshlflags)
{
    ContextDebugOut((DEB_WRAPPER, "WrapperMarshalObject pUnk:%x\n", pUnk));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Obtain the wrapper for the server object
    CStdWrapper *pStdWrapper = ObtainWrapper(pUnk, TRUE, mshlflags);
    if (pStdWrapper)
    {
        // Marshal
        hr = pStdWrapper->MarshalServer(NULL, pStm, riid, dwDestCtx, pvDestCtx, mshlflags);
        // Fixup the refcount (ObtainWrapper increments the reference count, or returns 
		// a new CStdWrapper with a refcount of 1.  MarshalServer also bumps up the refcount,
		// so we need to compensate here).
        pStdWrapper->InternalRelease(NULL);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER, "WrapperMarshalObject hr:0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::QueryInterface     public
//
//  Synopsis:   QI behavior of static wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::QueryInterface(REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CStaticWrapper::QueryInterface\n"));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) this;
    }
    else if(IsEqualIID(riid, IID_IMarshal))
    {
        *ppv = (IMarshal *) this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // No need to AddRef the interface before returning
    ContextDebugOut((DEB_POLICYSET, "CStaticWrapper::QueryInterface returning 0x%x\n",
                     hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::AddRef     public
//
//  Synopsis:   AddRef behavior of static wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStaticWrapper::AddRef()
{
    return(1);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::Release     public
//
//  Synopsis:   Release behavior of static wrapper object
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStaticWrapper::Release()
{
    return(1);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::GetUnmarshalClass     public
//
//  Synopsis:   Should not get called
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::GetUnmarshalClass(REFIID riid, LPVOID pv,
                                               DWORD dwDestCtx, LPVOID pvDestCtx,
                                               DWORD mshlflags, LPCLSID pClsid)
{
    Win4Assert(!"CStaticWrapper::GetUnmarshalClass got called");
    return(E_UNEXPECTED);
}

//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::GetMarshalSizeMax     public
//
//  Synopsis:   Should not get called
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::GetMarshalSizeMax(REFIID riid, LPVOID pv,
                                               DWORD dwDestCtx, LPVOID pvDestCtx,
                                               DWORD mshlflags, LPDWORD pSize)
{
    Win4Assert(!"CStaticWrapper::GetMarshalSizeMax got called");
    return(E_UNEXPECTED);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::MarshalInterface     public
//
//  Synopsis:   Should not get called
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::MarshalInterface(LPSTREAM pStm, REFIID riid,
                                              LPVOID pv, DWORD dwDestCtx,
                                              LPVOID pvDestCtx, DWORD mshlflags)
{
    Win4Assert(!"CStaticWrapper::MarshalInterface got called");
    return(E_UNEXPECTED);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::UnMarshalInterface     public
//
//  Synopsis:   Unmarshals the specified interface on a wrapper
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::UnmarshalInterface(LPSTREAM pStm, REFIID riid,
                                                LPVOID *ppv)
{
    ContextDebugOut((DEB_WRAPPER, "CStaticWrapper::UnmarshalInterface\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Initialize
    *ppv = NULL;

    // Read xCtxMarshalData from the stream
    XCtxMarshalData xCtxMarshalData;
    HRESULT hr = StRead(pStm, &xCtxMarshalData, sizeof(xCtxMarshalData));
    if(SUCCEEDED(hr))
    {
        // Get Local OXID Entry
        OXIDEntry *pOXIDEntry;
        hr = GetLocalOXIDEntry(&pOXIDEntry);

        // Validate the signature

        if((xCtxMarshalData.dwSignature == CROSSCTX_SIGNATURE) /*&&
           (pOXIDEntry && (pOXIDEntry->GetMoxid() == xCtxMarshalData.moxid))*/)
        {
            REFIID miid = xCtxMarshalData.iid;
            IFaceEntry *pIFaceEntry    = xCtxMarshalData.pEntry;
            CStdWrapper *pWrapper      = xCtxMarshalData.pWrapper;
            CObjectContext *pClientCtx = GetCurrentContext();
            CObjectContext *pServerCtx = xCtxMarshalData.pServerCtx;

			if (pWrapper == NULL)
			{
				// What error do we return here?
				hr = RPC_E_INVALID_OBJREF;
			}
            // Compare marshaled and requested IIDs
            else if(IsEqualIID(miid, riid) || IsEqualIID(riid, GUID_NULL))
            {
                BOOL fRelease;

                // Sanity checks
                Win4Assert(pIFaceEntry || IsEqualIID(miid, IID_IUnknown));
                Win4Assert(!pIFaceEntry || IsEqualIID(miid, pIFaceEntry->_iid));
			   
				// If the object was table marshaled, then we're giving out new
				// references to the object.... in addition to the reference we
				// put into the stream in MarshalInterface().
				Win4Assert(!(xCtxMarshalData.dwMarshalFlags & MSHLFLAGS_TABLEWEAK));
				if (pWrapper && (xCtxMarshalData.dwMarshalFlags & MSHLFLAGS_TABLESTRONG))
					pWrapper->InternalAddRef();

                // Compare contexts
                if(pClientCtx == pServerCtx)
                {
                    // Return native pointer
                    if(pIFaceEntry)
                        *ppv = pIFaceEntry->_pServer;
                    else
                        *ppv = pWrapper->GetServer();

                    // Wrapper could have been disconnected between marshaling
                    // and unmarshaling
                    if(*ppv)
                        ((IUnknown *) (*ppv))->AddRef();

                    // Fixup reference count... we're handing out a reference
					// to the real object, not our own object, so release the
					// reference to the wrapper held in the stream.
                    fRelease = TRUE;
                }
                else
                {
                    // Validate the wrapper and interface for the current context
                    if(pWrapper->ValidateContext(pClientCtx, pIFaceEntry))
                    {
                        if(pIFaceEntry)
                            *ppv = pIFaceEntry->_pProxy;
                        else
                            *ppv = pWrapper->GetImplInterface(miid);
                        fRelease = FALSE;
                    }
                    else
                    {
                        // Fixup reference count... release the reference to the wrapper
						// held in the stream.
                        fRelease = TRUE;
                        hr = E_OUTOFMEMORY;
                    }
                }

                // Release wrapper if neccessary
                if(fRelease)
                    pWrapper->InternalRelease(NULL);
            }
            else
                hr = E_INVALIDARG;
        }
        else
            hr = E_INVALIDARG;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStaticWrapper::UnmarshalInterface returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::ReleaseMarshalData     public
//
//  Synopsis:   Releases the given marshaled data
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::ReleaseMarshalData(LPSTREAM pStm)
{
    ContextDebugOut((DEB_WRAPPER, "CStaticWrapper::ReleaseMarshalData\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    XCtxMarshalData xCtxMarshalData;

    // Read xCtxMarshalData from the stream
    hr = StRead(pStm, &xCtxMarshalData, sizeof(xCtxMarshalData));
    if(SUCCEEDED(hr))
    {
        CStdWrapper *pWrapper = xCtxMarshalData.pWrapper;

		if (pWrapper)
		{
			pWrapper->InternalRelease(NULL);

			xCtxMarshalData.pWrapper = NULL;
		}
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CStaticWrapper::ReleaseMarshalData returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticWrapper::DisconnectObject     public
//
//  Synopsis:   Should not get called
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStaticWrapper::DisconnectObject(DWORD dwReserved)
{
    Win4Assert(!"CStaticWrapper::DisconnectObject got called");
    return(E_UNEXPECTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\orpc_dbg.c ===
//--------------------------------------------------------------------------
// ORPC_DBG.C (tabs 4)
//
//  !!!!!!!!! !!!!!!!!! NOTE NOTE NOTE NOTE !!!!!!!!! !!!!!!!!!!
//
//          SEND MAIL TO SANJAYS  IF YOU MODIFY THIS FILE!
//            WE MUST KEEP OLE AND LANGUAGES IN SYNC!
//
//  !!!!!!!!! !!!!!!!!! NOTE NOTE NOTE NOTE !!!!!!!!! !!!!!!!!!!
//
// Created 08-Oct-1993 by Mike Morearty.  The master copy of this file
// is in the LANGAPI project owned by the Languages group.
//
// Helper functions for OLE RPC debugging.
//--------------------------------------------------------------------------

#include <windows.h>
#ifndef _CHICAGO_
#include <tchar.h>
#endif

#include "orpc_dbg.h"

static TCHAR tszAeDebugName[] = TEXT("AeDebug");
static TCHAR tszAutoName[] = TEXT("Auto");
static TCHAR tszOldAutoName[] = TEXT("OldAuto");
static TCHAR tszDebugObjectRpcEnabledName[] =
#ifdef _CHICAGO_
	"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DebugObjectRPCEnabled";
#else
	TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\DebugObjectRPCEnabled");
#endif

// Emit the ORPC signature into the bytestream of the function
#define ORPC_EMIT_SIGNATURE()	'M', 'A', 'R', 'B',

// Emit a LONG into the bytestream
#define ORPC_EMIT_LONG(l)	\
	((l >>  0) & 0xFF),		\
	((l >>  8) & 0xFF),		\
	((l >> 16) & 0xFF),		\
	((l >> 24) & 0xFF),

// Emit a WORD into the bytestream
#define ORPC_EMIT_WORD(w)	\
	((w >> 0) & 0xFF),		\
	((w >> 8) & 0xFF),

// Emit a BYTE into the bytestream
#define ORPC_EMIT_BYTE(b)	\
	b,

// Emit a GUID into the bytestream
#define ORPC_EMIT_GUID(l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)	\
	ORPC_EMIT_LONG(l)												\
	ORPC_EMIT_WORD(w1) ORPC_EMIT_WORD(w2)							\
	ORPC_EMIT_BYTE(b1) ORPC_EMIT_BYTE(b2)							\
	ORPC_EMIT_BYTE(b3) ORPC_EMIT_BYTE(b4)							\
	ORPC_EMIT_BYTE(b5) ORPC_EMIT_BYTE(b6)							\
	ORPC_EMIT_BYTE(b7) ORPC_EMIT_BYTE(b8)

BYTE rgbClientGetBufferSizeSignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x9ED14F80, 0x9673, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbClientFillBufferSignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0xDA45F3E0, 0x9673, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbClientNotifySignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x4F60E540, 0x9674, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbServerNotifySignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x1084FA00, 0x9674, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbServerGetBufferSizeSignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x22080240, 0x9674, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

BYTE rgbServerFillBufferSignature[] =
{
	ORPC_EMIT_SIGNATURE()
	ORPC_EMIT_GUID(0x2FC09500, 0x9674, 0x101A, 0xB0, 0x7B,
		0x00, 0xDD, 0x01, 0x11, 0x3F, 0x11)
	ORPC_EMIT_LONG(0)
};

// Macro to deal with assigning refiid for both C and C++.
#if defined(__cplusplus)
#define ASSIGN_REFIID(orpc_all, iid)	((orpc_all).refiid = &iid)
#else
#define ASSIGN_REFIID(orpc_all, iid)	((orpc_all).refiid = iid)
#endif

#pragma code_seg(".orpc")

//--------------------------------------------------------------------------
// SzSubStr()
//
// Find str2 in str2
//--------------------------------------------------------------------------

static LPTSTR SzSubStr(LPTSTR str1, LPTSTR str2)
{
	CharLower(str1);

#ifdef _CHICAGO_
	return strstr(str1, str2);
#else
	return _tcsstr(str1, str2);
#endif
}

//--------------------------------------------------------------------------
// DebugORPCSetAuto()
//
// Sets the "Auto" value in the "AeDebug" key to "1", and saves info
// necessary to restore the previous value later.
//--------------------------------------------------------------------------

BOOL WINAPI DebugORPCSetAuto(VOID)
{
	HKEY	hkey;
	TCHAR	rgtchDebugger[256];	// 256 is the length NT itself uses for this
	TCHAR	rgtchAuto[256];
	TCHAR	rgtchOldAuto[2];	// don't need to get the whole thing

	// If the "DebugObjectRPCEnabled" key does not exist, then do not
	// cause any notifications
	if (RegOpenKey(HKEY_LOCAL_MACHINE, tszDebugObjectRpcEnabledName, &hkey))
		return FALSE;
	RegCloseKey(hkey);

	// If the AeDebug debugger string does not exist, or if it contains
	// "drwtsn32" anywhere in it, then don't cause any notifications,
	// because Dr. Watson is not capable of fielding OLE notifications.
	if (!GetProfileString(tszAeDebugName, TEXT("Debugger"), TEXT(""),
			rgtchDebugger, sizeof(rgtchDebugger) / sizeof(TCHAR)) ||
		SzSubStr(rgtchDebugger, TEXT("drwtsn32")) != NULL)
	{
		return FALSE;
	}

	// Must ensure that the "Auto" value in the AeDebug registry key
	// is set to "1", so that the embedded INT 3 below will cause the
	// debugger to be automatically spawned if it doesn't already
	// exist.

	// Get old "Auto" value
	GetProfileString(tszAeDebugName, tszAutoName, TEXT(""),
		rgtchAuto, sizeof(rgtchAuto) / sizeof(TCHAR));

	// If "OldAuto" already existed, then it's probably left over from
	// a previous invocation of the debugger, so don't overwrite it.
	// Otherwise, copy "Auto" value to "OldAuto"
	if (!GetProfileString(tszAeDebugName, tszOldAutoName, TEXT(""),
		rgtchOldAuto, sizeof(rgtchOldAuto) / sizeof(TCHAR)))
	{
		if (!WriteProfileString(tszAeDebugName, tszOldAutoName, rgtchAuto))
			return FALSE;
	}

	// Change "Auto" value to "1"
	if (!WriteProfileString(tszAeDebugName, tszAutoName, TEXT("1")))
		return FALSE;

	return TRUE;
}

//--------------------------------------------------------------------------
// DebugORPCRestoreAuto()
//
// Restores the previous value of the "Auto" value in the AeDebug key.
//--------------------------------------------------------------------------

VOID WINAPI DebugORPCRestoreAuto(VOID)
{
	TCHAR	rgtchAuto[256] = TEXT("");

	// Restore old Auto value (or delete it if it didn't exist before).
	// Very minor bug here: if "Auto" was previously "", then we will
	// now delete it.  That's not a big deal though, as an empty "Auto"
	// and a nonexistent one have the same effect.
	//
	// If GetProfileString failed (for some reason) then we take the
	// default value for rgtchAuto (init above).
	GetProfileString(tszAeDebugName, tszOldAutoName, TEXT(""), 
					 rgtchAuto, sizeof(rgtchAuto) / sizeof(TCHAR));

	WriteProfileString(tszAeDebugName, tszAutoName,
					   rgtchAuto[0] ? rgtchAuto : NULL);

	// Delete OldAuto value
	WriteProfileString(tszAeDebugName, tszOldAutoName, NULL);
}

 // This pragma is necessary in case the compiler chooses not to inline these
// functions (e.g. in a debug build, when optimizations are off).

#pragma code_seg(".orpc")

__inline DWORD WINAPI OrpcBreakpointFilter(
	LPEXCEPTION_POINTERS lpExcptPtr,
	BOOL *lpAeDebugAttached )									\
{
	BOOL fAeDebugAttached = FALSE;
	DWORD dwRet;
																
	if ( lpExcptPtr->ExceptionRecord->ExceptionCode == EXCEPTION_ORPC_DEBUG )	
	{
		if  ( UnhandledExceptionFilter(lpExcptPtr) == EXCEPTION_CONTINUE_SEARCH )
		{
			// It is important that we don't return EXCEPTION_CONTINUE_SEARCH.
			// This is because there might an handler up the stack which could
			// handle this exception. Just set the flag indicating that a
			// debugger is now attached.
			
			fAeDebugAttached = TRUE;
		}
		dwRet = EXCEPTION_EXECUTE_HANDLER;
	}
	else
	{
		// Not one of our exceptions.
		dwRet = EXCEPTION_CONTINUE_SEARCH;
	}

	if ( lpAeDebugAttached != NULL )
		(*lpAeDebugAttached) = fAeDebugAttached;
	
	return dwRet;	
}
							
ULONG WINAPI DebugORPCClientGetBufferSize(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	void *				reserved,
	IUnknown *			pUnkProxyMgr,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)
{
	ULONG	cbBuffer = 0;
	ORPC_DBG_ALL	orpc_all = {0};
	ORPC_DBG_ALL *  lpOrpcAll = &orpc_all;

	if (!fHookEnabled)
		return 0; // We should be able to assert that this never happens.

	orpc_all.pSignature = rgbClientGetBufferSizeSignature;
	orpc_all.pMessage = pMessage;
	orpc_all.reserved = reserved;
	orpc_all.pUnkProxyMgr = pUnkProxyMgr;
	orpc_all.lpcbBuffer = &cbBuffer;
	ASSIGN_REFIID(orpc_all, iid);

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		// Do Orpc debug notification using an exception.
		__try
		{
			RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
		}
		__except(OrpcBreakpointFilter(GetExceptionInformation(), NULL))
		{
			// this just goes down to the  to the return.
		}
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ClientGetBufferSize(lpOrpcAll);
#else
		lpIntf->lpVtbl->ClientGetBufferSize(lpIntf, lpOrpcAll);
#endif
		
	}

	return cbBuffer;
}

//--------------------------------------------------------------------------

void WINAPI DebugORPCClientFillBuffer(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	void *				reserved,
	IUnknown *			pUnkProxyMgr,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)
{
	ORPC_DBG_ALL	orpc_all = {0};
	ORPC_DBG_ALL *  lpOrpcAll = &orpc_all;

	if (!fHookEnabled)
		return; // We should be able to assert that this never happens

	orpc_all.pSignature = rgbClientFillBufferSignature;

	orpc_all.pMessage = pMessage;
	orpc_all.reserved = reserved;
	orpc_all.pUnkProxyMgr = pUnkProxyMgr;
	ASSIGN_REFIID(orpc_all, iid);

	orpc_all.pvBuffer = pvBuffer;
	orpc_all.cbBuffer = cbBuffer;

	
	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		// Do Orpc debug notification using an exception.
		__try
		{
			RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
		}
		__except(OrpcBreakpointFilter(GetExceptionInformation(), NULL))
		{
			// this just returns.
		}
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ClientFillBuffer(lpOrpcAll);
#else
		lpIntf->lpVtbl->ClientFillBuffer(lpIntf, lpOrpcAll);
#endif	
	}
}

//--------------------------------------------------------------------------

// This special value is to ensure backward compatibility with VC 2.0.
// It is not exposed in the header files. The behavior if this is the value
// in the first four bytes of the debug packet, should be identical to
// ORPC_DEBUG_ALWAYS.

#define ORPC_COMPATIBILITY_CODE		(0x4252414DL)

void WINAPI DebugORPCClientNotify(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	void *				reserved,
	IUnknown *			pUnkProxyMgr,
	HRESULT				hresult,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)
{
	ORPC_DBG_ALL orpc_all = {0};
	ORPC_DBG_ALL * lpOrpcAll = &orpc_all;
	BOOL fRethrow = FALSE;

	// First check to see if the debugger on the other side
	// wants us to notify this side if the hook is not enabled.
	if (!fHookEnabled)
	{
		if (cbBuffer >= 4)
		{
			LONG orpcCode = *(LONG *)pvBuffer;
			if ( orpcCode == ORPC_DEBUG_IF_HOOK_ENABLED)
				return;		// No notification in this case.
		}
	}

	orpc_all.pSignature = rgbClientNotifySignature;

	orpc_all.pMessage = pMessage;
	orpc_all.reserved = reserved;
	orpc_all.pUnkProxyMgr = pUnkProxyMgr;
	orpc_all.hresult = hresult;
	ASSIGN_REFIID(orpc_all, iid);

	orpc_all.pvBuffer = pvBuffer;
	orpc_all.cbBuffer = cbBuffer;

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		if (DebugORPCSetAuto())
		{
			// Do Orpc debug notification using an exception.
			__try
			{
				RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
			}
			__except(OrpcBreakpointFilter(GetExceptionInformation(), &fRethrow))
			{
				// Fall through.
			}

			if (fRethrow)
			{
				// At this point we are sure that a debugger is attached
				// so we raise this exception outside of a __try block.
				RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
			}

			DebugORPCRestoreAuto();
		}
	
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ClientNotify(lpOrpcAll);
#else
		lpIntf->lpVtbl->ClientNotify(lpIntf, lpOrpcAll);
#endif
	}

}

//--------------------------------------------------------------------------

void WINAPI DebugORPCServerNotify(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)

{
	ORPC_DBG_ALL orpc_all = {0};
	ORPC_DBG_ALL * lpOrpcAll = &orpc_all;
	BOOL fRethrow = FALSE;

	// First check to see if the debugger on the other side
	// wants us to notify this side if the hook is not enabled.
	if (!fHookEnabled)
	{
		if (cbBuffer >= 4)
		{
			LONG orpcCode = *(LONG *)pvBuffer;
			if ( orpcCode == ORPC_DEBUG_IF_HOOK_ENABLED)
				return;		// No notification in this case.
		}
	}

	orpc_all.pSignature = rgbServerNotifySignature;

	orpc_all.pMessage = pMessage;
	orpc_all.pChannel = pChannel;
	orpc_all.pInterface = pInterface;
	orpc_all.pUnkObject = pUnkObject;
	ASSIGN_REFIID(orpc_all, iid);
	
	orpc_all.pvBuffer = pvBuffer;
	orpc_all.cbBuffer = cbBuffer;

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		if (DebugORPCSetAuto())
		{
			// Do Orpc debug notification using an exception.
			__try
			{
				RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
			}
			__except(OrpcBreakpointFilter(GetExceptionInformation(), &fRethrow))
			{
				// Fall through
			}

			if (fRethrow)
			{
				// At this point we are sure that a debugger is attached
				// so we raise this exception outside of a __try block.
				RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
			}

			DebugORPCRestoreAuto();
		}
	
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ServerNotify(lpOrpcAll);
#else
		lpIntf->lpVtbl->ServerNotify(lpIntf, lpOrpcAll);
#endif
	}

}

//--------------------------------------------------------------------------

ULONG WINAPI DebugORPCServerGetBufferSize(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)

{
	ULONG	cbBuffer = 0;
	ORPC_DBG_ALL orpc_all = {0};
	ORPC_DBG_ALL * lpOrpcAll = &orpc_all;

	if (!fHookEnabled)
		return 0; // We should be able to assert that this never happens.

	orpc_all.pSignature = rgbServerGetBufferSizeSignature;

	orpc_all.pMessage = pMessage;
	orpc_all.pChannel = pChannel;
	orpc_all.pInterface = pInterface;
	orpc_all.pUnkObject = pUnkObject;
	orpc_all.lpcbBuffer = &cbBuffer;
	ASSIGN_REFIID(orpc_all, iid);

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		// Do Orpc debug notification using an exception.
		__try
		{
			RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
		}
		__except(OrpcBreakpointFilter(GetExceptionInformation(), NULL))
		{
			// this just goes down to the return.
		}
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ServerGetBufferSize(lpOrpcAll);
#else
		lpIntf->lpVtbl->ServerGetBufferSize(lpIntf, lpOrpcAll);
#endif
	}

	return cbBuffer;
}

//--------------------------------------------------------------------------

void WINAPI DebugORPCServerFillBuffer(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)
{
	ORPC_DBG_ALL orpc_all = {0};
	ORPC_DBG_ALL * lpOrpcAll = &orpc_all;

	if (!fHookEnabled)
		return;	// We should be able to assert that this never happens.

	orpc_all.pSignature = rgbServerFillBufferSignature;

	orpc_all.pMessage = pMessage;
	orpc_all.pChannel = pChannel;
	orpc_all.pInterface = pInterface;
	orpc_all.pUnkObject = pUnkObject;
	ASSIGN_REFIID(orpc_all, iid);

	orpc_all.pvBuffer = pvBuffer;
	orpc_all.cbBuffer = cbBuffer;

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		// Do Orpc debug notification using an exception.
		__try
		{
			RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
		}
		__except(OrpcBreakpointFilter(GetExceptionInformation(), NULL))
		{
			// this just returns.
		}
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ServerFillBuffer(lpOrpcAll);
#else
		lpIntf->lpVtbl->ServerFillBuffer(lpIntf, lpOrpcAll);
#endif
	}
}

// WARNING: there is no way to "pop" to the previously active code_seg:
// this will revert to what the code seg was when compilation began.
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\marshal.cxx ===
//+-------------------------------------------------------------------
//
//  File:       marshal.cxx
//
//  Contents:   class implementing standard COM interface marshaling
//
//  Classes:    CStdMarshal
//
//  History:    20-Feb-95   Rickhi      Created
//
 //--------------------------------------------------------------------
#include    <ole2int.h>
#include    <marshal.hxx>   // CStdMarshal
#include    <ipidtbl.hxx>   // CIPIDTable, COXIDTable, CMIDTable
#include    <riftbl.hxx>    // CRIFTable
#include    <resolver.hxx>  // CRpcResolver
#include    <stdid.hxx>     // CStdIdentity
#include    <ctxchnl.hxx>   // CCtxComChnl
#include    <callctrl.hxx>  // CAptRpcChnl, CSrvCallCtrl
#include    <scm.h>         // CLSCTX_PS_DLL
#include    <service.hxx>   // SASIZE
#include    <locks.hxx>     // LOCK/UNLOCK etc
#include    <thunkapi.hxx>  // GetAppCompatabilityFlags
#include    <xmit.hxx>      // CRpcXmitStream
#include    <events.hxx>    // Event logging functions
#include    <context.hxx>   // CObjectContext
#include    <crossctx.hxx>  // ObtainPolicySet

// Marker signature
#define MARKER_SIGNATURE  (0x4E535956)

const GUID CLSID_AggStdMarshal =
    {0x00000027,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


#if DBG==1
// this flag and interface are used in debug to enable simpler testing
// of the esoteric NonNDR stub code feature.

BOOL gfFakeNonNDR    = FALSE;
const GUID IID_ICube =
    {0x00000139,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
#endif  // DBG

BOOL gEnableAgileProxies = FALSE;

extern INTERNAL ICoGetClassObject(
    REFCLSID rclsid,
    DWORD dwContext,
    COSERVERINFO * pvReserved,
    REFIID riid,
    DWORD dwActvFlags,
    void FAR* FAR* ppvClassObj,
    ActivationPropertiesIn *pActIn);

// CODEWORK: theorectically, this could be made a little more reliable. In
// practise it has never been a problem. Maybe best solution is to use
// CoGetCurrentProcessId plus sequence number.
LONG    gIPIDSeqNum = 0;

// mappings from MSHLFLAGS to STDOBJREF flags
static ULONG mapMFtoSORF[] =
{
    SORF_NULL,                  // MSHLFLAGS_NORMAL
    SORF_NULL,                  // MSHLFLAGS_TABLESTRONG
    SORF_P_TBLWEAK              // MSHLFLAGS_TABLEWEAK
};

// NULL resolver string array
DUALSTRINGARRAY saNULL = {0,0};

// out internal psclass factory implementation
EXTERN_C HRESULT ProxyDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);

extern HRESULT GetAsyncCallObject(IUnknown *pSyncObj, IUnknown *pControl, REFIID IID_async,
                                  REFIID IID_Return, IUnknown **ppInner, void **ppv);

// structure used to post a delayed remote release call to ourself.
typedef struct tagPOSTRELRIFREF
{
    OXIDEntry      *pOXIDEntry; // server OXIDEntry
    IRemUnknown    *pRemUnk;    // Remote unknown
    IUnknown       *pAsyncRelease; // Controlling unknown for Async
    USHORT          cRifRef;    // count of entries in arRifRef
    REMINTERFACEREF arRifRef;   // array of REMINTERFACEREFs
} POSTRELRIFREF;


//+-------------------------------------------------------------------
// function to determine if the marshal packet represents a TABLESTRONG
// or TABLEWEAK marshal reference (vs a NORMAL marshal reference)
//+-------------------------------------------------------------------
inline BOOL IsTableObjRef(STDOBJREF *pStd)
{
    return (pStd->cPublicRefs == 0)
        ? TRUE : FALSE;
}

//+-------------------------------------------------------------------
// function to determine if the marshal packet represents a TABLEWEAK
// marshal reference.
//+-------------------------------------------------------------------
inline BOOL IsTableWeakObjRef(STDOBJREF *pStd)
{
    return (pStd->cPublicRefs == 0 && (pStd->flags & SORF_P_TBLWEAK))
        ? TRUE : FALSE;
}

//+-------------------------------------------------------------------
// function to determine if the marshal packet represents a TABLESTRONG
// marshal reference.
//+-------------------------------------------------------------------
inline BOOL IsTableStrongObjRef(STDOBJREF *pStd)
{
    return (pStd->cPublicRefs == 0 && !(pStd->flags & SORF_P_TBLWEAK))
        ? TRUE : FALSE;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::CStdMarshal/Init, public
//
//  Synopsis:   constructor/initializer of a standard marshaler
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
CStdMarshal::CStdMarshal() : _dwFlags(0), _pChnl(NULL), _fCsInitialized(FALSE)
{
    // Caller must call Init before doing anything! This just makes it
    // easier for the identity object to figure out the init parameters
    // before initializing us.
}

BOOL CStdMarshal::Init(IUnknown *punkObj, CStdIdentity *pStdId,
                       REFCLSID rclsidHandler, DWORD dwFlags)
{
    // may be unlocked if def handler calls CreateIdHdlr
    ASSERT_LOCK_DONTCARE(gComLock);

    BOOL fRet = FALSE;
    NTSTATUS status;
    
    // server side - we need to do the FirstMarshal work.
    // client side - assume disconnected until we connect the first IPIDEntry
    // and assume NOPING until we see any interface that needs pinging

    _dwFlags  = dwFlags;
    _dwFlags |= (ServerSide()) ? SMFLAGS_FIRSTMARSHAL
                               : SMFLAGS_DISCONNECTED | SMFLAGS_NOPING;

    _pStdId        = pStdId;
    _clsidHandler  = rclsidHandler;
    _cIPIDs        = 0;
    _pFirstIPID    = NULL;
    _pChnl         = NULL;
    _cNestedCalls  = 0;
    _cTableRefs    = 0;
    _dwMarshalTime = 0;
    _pSecureRemUnk = NULL;
    _pAsyncRelease = NULL;
    _pCtxEntryHead = NULL;
    _pCtxFreeList  = NULL;
    _pPS           = NULL;
    _pID           = NULL;
    _pRefCache     = NULL;

    status = RtlInitializeCriticalSectionAndSpinCount(&_csCtxEntry, 500);
    if (NT_SUCCESS(status))
    {
    	_fCsInitialized = TRUE;
    	fRet = TRUE;
    }

#if DBG==1
    _fNoOtherThreadInDisconnect = TRUE;
#endif

    ComDebOut((DEB_MARSHAL,"CStdMarshal %s New this:%x pStdId:%x punkObj:%x\n",
        (ClientSide()) ? "CLIENT" : "SERVER", this, pStdId, punkObj));

return fRet;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::~CStdMarshal, public
//
//  Synopsis:   destructor of a standard marshaler
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
CStdMarshal::~CStdMarshal()
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal %s Deleted this:%x\n",
                    (ClientSide()) ? "CLIENT" : "SERVER", this));

    // Due to backward compatibility, we are not allowed to release
    // interface proxies in Disconnect since the client might try to
    // reconnect later and expects the same interface pointer values.
    // Since we are going away now, we go release the proxies.

    ReleaseAllIPIDEntries();

    if (ClientSide())
    {
        // Note: dont do this assertion check in the server side case since
        // in debug the StdId list header dtor may get called after the lock
        // dtor has already been called. The list header is server side.
        ASSERT_LOCK_NOT_HELD(gComLock);

        // If we own a secure remote unknown, clean it up now.
        if (NULL != _pSecureRemUnk)
        {
            CStdIdentity* pStdId;
            HRESULT hr = _pSecureRemUnk->QueryInterface(IID_IStdIdentity, (void**)&pStdId);
            if (SUCCEEDED(hr))
            {
                pStdId->ReleaseRemUnkCopy(_pSecureRemUnk);
                pStdId->Release();
            }
        }

        ASSERT_LOCK_NOT_HELD(gComLock);
    }

    if (_pChnl)
    {
        // release the channel
        _pChnl->Release();
        ASSERT_LOCK_NOT_HELD(gComLock);
    }

    if (_fCsInitialized == TRUE)
        DeleteCriticalSection(&_csCtxEntry);
    

    // Sanity checks
    Win4Assert(_pID == NULL);
    Win4Assert(_pPS == NULL);
    Win4Assert(_pRefCache == NULL);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::GetUnmarshalClass, public
//
//  Synopsis:   returns the clsid of the standard marshaller, or
//              aggregated standard marshaler.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::GetUnmarshalClass(REFIID riid, LPVOID pv,
        DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags, LPCLSID pClsid)
{
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if(ServerSide() && (dwDestCtx==MSHCTX_CROSSCTX) && !(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
        *pClsid = CLSID_StdWrapper;
    }
    else if (ServerSide() && (dwDestCtx == MSHCTX_INPROC) && IsThreadInNTA() 
			 && !(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
		//
		// If this assert fires, this means that you've got an inproc
		// reference to an old-style stub for an object living in the NA.
		// This should never happen-- you should have a StdWrapper instead.  
		// Look at the unmarshal path and find out what you missed, or why 
		// this can happen.
		// In any case, the right thing to do in this event is to do wrapper
		// marshalling, to get back on the right foot.
		//
		Win4Assert(!"Inproc Ref to NA StdID! Shouldn't happen!");
        *pClsid = CLSID_StdWrapper;
    }
    else
    {
        if (_dwFlags & SMFLAGS_USEAGGSTDMARSHAL)
        {
            *pClsid = CLSID_AggStdMarshal;
        }
        else
        {
            *pClsid = CLSID_StdMarshal;
        }
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     MarshalSizeHelper,      private
//
//  Synopsis:   Helper function used for sizing marshaling buffers
//
//  History:    21-Mar-98   Gopalk      Created.
//
//--------------------------------------------------------------------
INTERNAL MarshalSizeHelper(DWORD dwDestCtx, LPVOID pvDestCtx,
                           DWORD mshlflags, CObjectContext *pServerCtx,
                           BOOL fServerSide, LPDWORD pSize)
{
    HRESULT hr = S_OK;
    CDualStringArray* pdsaLocalResolver;

    // Sanity check
    Win4Assert(gdwPsaMaxSize != 0);
	
    // Check for cross context case
    if(fServerSide &&
       (dwDestCtx == MSHCTX_CROSSCTX) &&
       !(mshlflags & MSHLFLAGS_TABLE))
    {
        *pSize = sizeof(OBJREF) + sizeof(XCtxMarshalData);
    }
    else
    {
        hr = gResolver.GetLocalResolverBindings(&pdsaLocalResolver);
        if (SUCCEEDED(hr))
        {
            // Fixed portion of objref
            *pSize = sizeof(OBJREF) +
                (fServerSide ? SASIZE(pdsaLocalResolver->DSA()->wNumEntries) :
            gdwPsaMaxSize);
            
            // Check for the need to send envoy data
            if((dwDestCtx != MSHCTX_INPROC) &&
                //(dwDestCtx != MSHCTX_CROSSCTX) &&
                pServerCtx != NULL)
            {
                COMVERSION destCV;
                BOOL fDownLevel = TRUE;
                
                // Decide down level interop issues
                if(pvDestCtx)
                {
                    // Sanity check
                    Win4Assert(dwDestCtx == MSHCTX_DIFFERENTMACHINE);
                    
                    // Obtain com version of destination
                    hr = ((IDestInfo *) pvDestCtx)->GetComVersion(destCV);
                    if(SUCCEEDED(hr))
                    {
                        if(destCV.MajorVersion != COM_MAJOR_VERSION)
                            hr = RPC_E_VERSION_MISMATCH;
                        else if(destCV.MinorVersion < COM_MINOR_VERSION)
                            fDownLevel = TRUE;
                        else
                            fDownLevel = FALSE;
                    }
                }
                else if(dwDestCtx == MSHCTX_DIFFERENTMACHINE)
                {
                    fDownLevel = TRUE;
                }
                else
                {
                    fDownLevel = FALSE;
                }
                
                // Check for down level interop
                if(SUCCEEDED(hr) && fDownLevel==FALSE)
                {
                    ULONG cbSize;
                    
                    // Obtain the size of envoy data
                    hr = pServerCtx->GetEnvoySizeMax(dwDestCtx, &cbSize);
                    if(SUCCEEDED(hr))
                        *pSize += cbSize;
                }
            }
            pdsaLocalResolver->Release();
        }
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::GetMarshalSizeMax, public
//
//  Synopsis:   Returns an upper bound on the amount of data for
//              a standard interface marshal.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::GetMarshalSizeMax(REFIID riid, LPVOID pv,
        DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags, LPDWORD pSize)
{
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr = MarshalSizeHelper(dwDestCtx, pvDestCtx, mshlflags,
                                   GetServerCtx(), ServerSide(), pSize);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   MarshalObjRef, private
//
//  Synopsis:   Marshals interface into the objref.
//
//  Arguements: [objref]    - object reference
//              [riid]      - interface id to marshal
//              [pv]        - interface to marshal
//              [mshlflags] - marshal flags
//              [dwDestCtx] - destination context type
//              [pvDestCtx] - destination context ptr
//
//  Algorithm:  Get the correct standard identity and ask it to do
//              all the work.
//
//  History:    25-Mar-95   AlexMit     Created
//
//--------------------------------------------------------------------
INTERNAL MarshalObjRef(OBJREF &objref, REFIID riid, void *pv, DWORD mshlflags,
                       DWORD dwDestCtx, void *pvDestCtx)
{
    TRACECALL(TRACE_MARSHAL, "MarshalObjRef");
    ComDebOut((DEB_MARSHAL, "MarshalObjRef: riid:%I pv:%x flags:%x\n",
        &riid, pv, mshlflags));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        // Find or create the StdId for this object. We need to get a strong
        // reference to guard against an incoming last release on another
        // thread which would cause us to Disconnect this StdId.

        DWORD dwFlags = IDLF_CREATE | IDLF_STRONG;
        dwFlags |= (mshlflags & MSHLFLAGS_NOPING) ? IDLF_NOPING : 0;

        CStdIdentity *pStdID;
        hr = ObtainStdIDFromUnk((IUnknown *)pv, GetCurrentApartmentId(),
                                GetCurrentContext(), dwFlags, &pStdID);

        if (hr == NOERROR)
        {
            hr = pStdID->MarshalObjRef(objref, riid, mshlflags,
                                       dwDestCtx, pvDestCtx, 0);
            if (pStdID->IsClient())
                pStdID->Release();
            else
                pStdID->DecStrongCnt(TRUE); // fKeepAlive
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "MarshalObjRef: hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   MarshalInternalObjRef, private
//
//  Synopsis:   Marshals an internal interface into the objref.
//
//  Arguements: [objref]    - object reference
//              [riid]      - interface id to marshal
//              [pv]        - interface to marshal
//              [mshlflags] - marshal flags
//              [ppStdId]   - StdId to return (may be NULL)
//
//  Algorithm:  Create a StdIdentity and ask it to do the work.
//
//  Notes:      This differs from the normal MarshalObjRef in that it does
//              not look in the OID table for an already marshaled interface,
//              nor does it register the marshaled interface in the OID table.
//              This is used for internal interfaces such as the IObjServer
//              and IRemUnknown.
//
//  History:    25-Oct-95   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies and comments
//
//--------------------------------------------------------------------
INTERNAL MarshalInternalObjRef(OBJREF &objref, REFIID riid, void *pv,
                               DWORD mshlflags, void **ppStdId)
{
    TRACECALL(TRACE_MARSHAL, "MarshalInternalObjRef");
    ComDebOut((DEB_MARSHAL, "MarshalInternalObjRef: riid:%I pv:%x flags:%x\n",
        &riid, pv, mshlflags));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr))
        {
            // Find or create the StdId for this object. We need to get a strong
            // reference to guard against an incoming last release on another
            // thread which would cause us to Disconnect this StdId.

            IUnknown *pUnkId;   // ignored
            BOOL fSuccess = FALSE;
            DWORD StdIDFlags = (mshlflags & MSHLFLAGS_AGILE)
                               ? STDID_SERVER | STDID_SYSTEM | STDID_FREETHREADED
                               : STDID_SERVER | STDID_SYSTEM;
            CStdIdentity *pStdId = new CStdIdentity(StdIDFlags,
                                                    GetCurrentApartmentId(), NULL,
                                                    (IUnknown *)pv, &pUnkId, &fSuccess);

            if (pStdId && fSuccess == FALSE)
            {
            	delete pStdId;
            	pStdId = NULL;
            }
            
            if (pStdId)
            {
                
                hr = pStdId->MarshalObjRef(objref, riid, mshlflags,
                                           MSHCTX_INPROC, NULL, 0);

                if (SUCCEEDED(hr) && ppStdId)
                {
                    *ppStdId = (void *)pStdId;
                }
                else
                {
                    pStdId->Release();
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "MarshalInternalObjRef: hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::MarshalInterface, public
//
//  Synopsis:   marshals the interface into the stream.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::MarshalInterface(IStream *pStm, REFIID riid,
        LPVOID pv, DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::MarshalInterface this:%x pStm:%x riid:%I pv:%x dwCtx:%x pvCtx:%x flags:%x\n",
        this, pStm, &riid, pv, dwDestCtx, pvDestCtx, mshlflags));
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // validate the parameters.
    HRESULT hr = ValidateMarshalParams(pStm, (IUnknown *)pv,
                                       dwDestCtx, pvDestCtx, mshlflags);
    if (FAILED(hr))
        return hr;

    // Check the destination context
    if (ServerSide() &&
        (dwDestCtx==MSHCTX_CROSSCTX) && !(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
        hr = WrapperMarshalObject(pStm, riid, (IUnknown *) pv, dwDestCtx,
                                  pvDestCtx, mshlflags);
    }
    else if (ServerSide() && (dwDestCtx == MSHCTX_INPROC) && IsThreadInNTA()
             && !(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
        hr = WrapperMarshalObject(pStm, riid, (IUnknown *) pv, dwDestCtx,
                                  pvDestCtx, mshlflags);
    }
    else
    {
        // Marshal the interface into an objref, then write the objref
        // into the provided stream.
        OBJREF  objref;
        hr = MarshalObjRef(objref, riid, mshlflags, dwDestCtx, pvDestCtx, 0);
        if (SUCCEEDED(hr))
        {
            // write the objref into the stream
            hr = WriteObjRef(pStm, objref, dwDestCtx);

            if (FAILED(hr))
            {
                // undo whatever we just did, ignore error from here since
                // the stream write error supercedes any error from here.
                ReleaseMarshalObjRef(objref);
            }

            // free resources associated with the objref.
            FreeObjRef(objref);
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,"CStdMarshal::MarshalInterface this:%x hr:%x\n",
        this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::MarshalObjRef, public
//
//  Synopsis:   marshals the interface into the objref.
//
//  History:    25-Mar-95   AlexMit     Seperated from MarshalInterface
//              04-Mar-98   Gopalk      Context changes
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::MarshalObjRef(OBJREF &objref, REFIID riid,
                                   DWORD mshlflags, DWORD dwDestCtx,
                                   void *pvDestCtx, IUnknown *pUnkUseInner)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::MarsalObjRef this:%x riid:%I flags:%x\n",
        this, &riid, mshlflags));
#if DBG==1
    // ensure we are always in the proper context
    CObjectContext *pDestCtx = ServerObjectCallable();
    Win4Assert(pDestCtx == NULL);
#endif
    AssertValid();

    // count of Refs we are handing out. In the table cases we pass out
    // zero refs because we dont know how many times it will be unmarshaled
    // (and hence how many references to count). Zero refs will cause the
    // client to call back and ask for more references if it does not already
    // have any (which has the side effect of making sure the object still
    // exists, which is required by RunningObjectTable).

    ULONG cRefs = (mshlflags & MSHLFLAGS_TABLE) ? 0 :
                  (ClientSide()) ? 1 : REM_ADDREF_CNT;

    ENTER_NA_IF_NECESSARY()

    IPIDEntry *pIPIDEntry;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    HRESULT hr = PreventDisconnect();
    if (SUCCEEDED(hr))
    {
        // The first time through we have some extra work to do so go off
        // and do that now. Next time we can just bypass all that work.

        if (_dwFlags & SMFLAGS_FIRSTMARSHAL)
        {
            hr = FirstMarshal(0, mshlflags);
        }

        if (SUCCEEDED(hr))
        {
            // Create the IPID table entry. On the server side this may
            // cause the creation of an interface stub, on the client side
            // it may just take away one of our references or it may call
            // the server to get more references for the interface being
            // marshaled.

            hr = MarshalIPID(riid, cRefs, mshlflags, &pIPIDEntry, pUnkUseInner);
        }
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (SUCCEEDED(hr))
    {
        // fill in the objref.

        // First, compute the COM Version of the destination.
        COMVERSION destCV;
        if (pvDestCtx)
        {
            hr = ((IDestInfo *) pvDestCtx)->GetComVersion(destCV);
            Win4Assert(SUCCEEDED(hr));
            Win4Assert(dwDestCtx == MSHCTX_DIFFERENTMACHINE);
        }
        else if (dwDestCtx == MSHCTX_DIFFERENTMACHINE)
        {
            // don't know where it is going, use the lowest version.
            destCV.MajorVersion = COM_MAJOR_VERSION;
            destCV.MinorVersion = COM_MINOR_VERSION_1;
        }
        else
        {
            // it's for the local machine, use the current version.
            destCV.MajorVersion = COM_MAJOR_VERSION;
            destCV.MinorVersion = COM_MINOR_VERSION;
        }

        // fill in the rest of the OBJREF
        FillObjRef(objref, cRefs, mshlflags, destCV, pIPIDEntry);
    }

    // it is now OK to allow real disconnects in.
    HRESULT hr2 = HandlePendingDisconnect(hr);
    if (FAILED(hr2) && SUCCEEDED(hr))
    {
        // a disconnect came in while marshaling. The ObjRef has a
        // reference to the OXIDEntry so go free that now.
        FreeObjRef(objref);
    }

    LEAVE_NA_IF_NECESSARY()

    if (SUCCEEDED(hr2) && LogEventIsActive())
    {
        LogEventMarshal(objref);
    }

    ComDebOut((DEB_MARSHAL, "CStdMarshal::MarshalObjRef this:%x hr:%x\n",
        this, hr2));
    return hr2;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::FillObjRef, private
//
//  Synopsis:   Fill in the fields of an OBJREF
//
//  History:    21-Sep-95   Rickhi      Created
//
//+-------------------------------------------------------------------
void CStdMarshal::FillObjRef(OBJREF &objref, ULONG cRefs, DWORD mshlflags,
                             COMVERSION &destCV, IPIDEntry *pIPIDEntry)
{
    ComDebOut((DEB_MARSHAL, "FillObjRef pObjRef:%x\n", &objref));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    Win4Assert(pIPIDEntry);
    OXIDEntry **ppOXIDEntry;

    // first, fill in the STDOBJREF section
    STDOBJREF *pStd = &ORSTD(objref).std;
    FillSTD(pStd, cRefs, mshlflags, pIPIDEntry);

    // next fill in the rest of the OBJREF
    objref.signature = OBJREF_SIGNATURE;    // 'MEOW'
    objref.iid = pIPIDEntry->iid;           // interface iid

    if (_dwFlags & SMFLAGS_HANDLER)
    {
        // handler form, copy in the clsid
        objref.flags = OBJREF_HANDLER;
        ORHDL(objref).clsid = _clsidHandler;
        ppOXIDEntry  = (OXIDEntry **) &ORHDL(objref).saResAddr;
    }
    else
    {
        CObjectContext *pServerCtx = GetServerCtx();
        if (pServerCtx && !pServerCtx->IsDefault() && (destCV.MinorVersion >= COM_MINOR_VERSION))
        {
            // write an extended OBJREF with the server context ptr.
            // make sure we are not in the empty context, in which
            // case we should be writing a standard OBJREF.
            Win4Assert(pServerCtx != GetEmptyContext());

            objref.flags = OBJREF_EXTENDED;
            pServerCtx->InternalAddRef();
            OREXT(objref).pORData = (OBJREFDATA *) pServerCtx;
            ppOXIDEntry = (OXIDEntry **) &OREXT(objref).saResAddr;
        }
        else
        {
            // write a standard OBJREF
            objref.flags = OBJREF_STANDARD;
            ppOXIDEntry  = (OXIDEntry **) &ORSTD(objref).saResAddr;
        }
    }

    // TRICK: in order to keep the objref a fixed size internally,
    // we use the saResAddr.size field as a ptr to the OXIDEntry. We
    // pay attention to this in ReadObjRef, WriteObjRef, and FreeObjRef.

    *ppOXIDEntry = pIPIDEntry->pOXIDEntry;
    Win4Assert(*ppOXIDEntry != NULL);
    (*ppOXIDEntry)->IncRefCnt();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::FillSTD, public
//
//  Synopsis:   Fill in the STDOBJREF fields of an OBJREF
//
//  History:    21-Sep-95   Rickhi      Created
//              26-Mar-98   GopalK      Agile proxies
//              29-Mar-98   Johnstra    Agile FTM proxies
//
//+-------------------------------------------------------------------
void CStdMarshal::FillSTD(STDOBJREF *pStd, ULONG cRefs, DWORD mshlflags,
                          IPIDEntry *pIPIDEntry)
{
    // we don't care if the lock is held, only that disconnect is prevented
    AssertDisconnectPrevented();
    ASSERT_LOCK_DONTCARE(gIPIDLock);

    // fill in the STDOBJREF to return to the caller.
    pStd->flags  = mapMFtoSORF[mshlflags & MSHLFLAGS_TABLE];
    pStd->flags |= (pIPIDEntry->dwFlags & IPIDF_NOPING) ? SORF_NOPING : 0;
    pStd->flags |= (pIPIDEntry->dwFlags & IPIDF_NONNDRSTUB) ? SORF_P_NONNDR : 0;
    pStd->flags |= (_pStdId->IsFreeThreaded() || gEnableAgileProxies) ?
        SORF_FREETHREADED : 0;

    pStd->cPublicRefs = cRefs;
    pStd->ipid   = pIPIDEntry->ipid;
    OIDFromMOID(_pStdId->GetOID(), &pStd->oid);

    OXIDFromMOXID(pIPIDEntry->pOXIDEntry->GetMoxid(), &pStd->oxid);

    pStd->flags |= (_pStdId->IsFTM()) ? (SORF_FTM | SORF_FREETHREADED): 0;

    ValidateSTD(pStd);
    DbgDumpSTD(pStd);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::FirstMarshal, private
//
//  Synopsis:   Does some first-time server side marshal stuff
//
//  Parameters: [pUnk] - interface being marshalled
//              [mshlflags] - flags for marshaling
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::FirstMarshal(IUnknown *pUnk, DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::FirstMarshal this:%x pUnk:%x\n", this, pUnk));
    Win4Assert(ServerSide());
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    if (mshlflags & MSHLFLAGS_NOPING)
    {
        // if the first interface is marked as NOPING, then all interfaces
        // for the object are treated as NOPING, otherwise, all interfaces
        // are marked as PING. MakeSrvIPIDEntry will look at _dwFlags to
        // determine whether to mark each IPIDEntry as NOPING or not.

        _dwFlags |= SMFLAGS_NOPING;
    }

    HRESULT hr = S_OK;

    // Another thread could have created the channel. Check before
    // actually creating the channel
    if (NULL == _pChnl)
    {
        // create a channel for this object. Note that this will release
        // the lock, so guard against that by not turning off the first
        // marshal bit until after this call returns.
        CCtxComChnl *pChnl;
        hr = CreateChannel(NULL, 0, GUID_NULL, GUID_NULL, &pChnl);
    }

    if (SUCCEEDED(hr))
    {
        // The channel should have been created by now
        Win4Assert(NULL != _pChnl);
        _dwFlags &= ~(SMFLAGS_FIRSTMARSHAL | SMFLAGS_DISCONNECTED | SMFLAGS_CLEANEDUP);
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::FirstMarshal this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::MarshalIPID, private
//
//  Synopsis:   finds or creates an interface stub and IPID entry
//              for the given object interface.
//
//  Arguments:  [riid]   - interface to look for
//              [cRefs]  - count of references wanted
//              [mshlflags] - marshal flags
//              [ppIPIDEntry] - place to return IPIDEntry ptr
//              [pUnkUseInner] - ?
//
//  Returns:    S_OK if succeeded
//
//  History:    20-Feb-95   Rickhi        Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::MarshalIPID(REFIID riid, ULONG cRefs, DWORD mshlflags,
                                 IPIDEntry **ppIPIDEntry, IUnknown *pUnkUseInner)
{
    TRACECALL(TRACE_MARSHAL, "CStdMarshal::MarshalIPID");
    ComDebOut((DEB_MARSHAL,
            "CStdMarshal::MarshalIPID this:%x riid:%I cRefs:%x mshlflags:%x ppEntry:%x\n",
            this, &riid, cRefs, mshlflags, ppIPIDEntry));
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    // look for an existing IPIDEntry for the requested interface
    IPIDEntry *pEntry = NULL;
    HRESULT hr = FindIPIDEntryByIID(riid, &pEntry);

    if (FAILED(hr))
    {
        // no IPID entry currently exists for the interface.
        if (ServerSide())
        {
            // on the server side. try to create one. This can fail if we
            // are disconnected during a yield.
            hr = MakeSrvIPIDEntry(riid, &pEntry);
        }
        else
        {
            // on the client side we do a remote QI for the requested
            // interface.
            hr = RemQIAndUnmarshal(1, (GUID *)&riid, NULL);
            if (SUCCEEDED(hr))
            {
                hr = FindIPIDEntryByIID(riid, &pEntry);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // REFCOUNTING:
        if (ServerSide())
        {
            if (pEntry->dwFlags & IPIDF_DISCONNECTED)
            {
                // connect the IPIDEntry
                hr = ConnectSrvIPIDEntry(pEntry, pUnkUseInner);
            }

            if (SUCCEEDED(hr))
            {
                // remember the latest marshal time so we can
                // tell if the ping server has run us down too
                // early. This can happen when an existing client
                // dies and we remarshal the interface just
                // moments before the pingserver tells us the
                // first guy is gone and before the new client
                // has had time to unmarshal and ping.
                _dwMarshalTime = GetCurrentTime();

                // inc the refcnt for the IPIDEntry and optionaly
                // the stdid. Note that for TABLE marshals cRefs
                // is 0 (that's the number that gets placed in the
                // packet) but we do want a reference so we ask for
                // 1 here. ReleaseMarshalData will undo the 1.
                ULONG cRefs2 = (mshlflags & MSHLFLAGS_TABLE) ? 1 : cRefs;
                IncSrvIPIDCnt(pEntry, cRefs2, 0, NULL, mshlflags);
            }
        }
        else  // client side,
        {
            // we dont support marshaling weak refs on the client
            // side, though we do support marshaling strong from
            // a weak client by going to the server and getting
            // a strong reference.
            Win4Assert(!(mshlflags & MSHLFLAGS_WEAK));

            if (mshlflags & MSHLFLAGS_TABLESTRONG)
            {
                // TABLESTRONG marshaling of a client. Need to tell
                // the refcache to keep pinging the object.
                Win4Assert(cRefs == 0);
                // For no-ping OIDs, _pRefCache is NULL
                if(_pRefCache)
		   _pRefCache->IncTableStrongCnt();
            }
            else if (cRefs >= pEntry->cStrongRefs)
            {
                // need to get some references either from the reference
                // cache or from the remote server so we can give them to
                // the STDOBJREF.
                hr = RemoteAddRef(pEntry, pEntry->pOXIDEntry, cRefs, 0, TRUE);
            }
            else
            {
                // we have enough references to satisfy this request
                // (and still keep some for ourselves), just subtract
                // from the IPIDEntry
                pEntry->cStrongRefs -= cRefs;
            }

            // mark this object as having been client-side marshaled so
            // that we can tell the resolver whether or not it needs to
            // ping this object if we release it before the OID is registered.
            _dwFlags |= SMFLAGS_CLIENTMARSHALED;
        }

        // do some debug stuff
        ValidateIPIDEntry(pEntry);
        ComDebOut((DEB_MARSHAL, "pEntry:%x cRefs:%x cStdId:%x\n", pEntry,
                   pEntry->cStrongRefs, _pStdId->GetRC()));
    }

    *ppIPIDEntry = pEntry;

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL, "CStdMarshal::MarshalIPID hr:%x pIPIDEntry\n", hr, *ppIPIDEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::UnmarshalInterface, public
//
//  Synopsis:   Unmarshals an Interface from a stream.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::UnmarshalInterface(LPSTREAM pStm,
                                             REFIID riid, VOID **ppv)
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::UnmarsalInterface this:%x pStm:%x riid:%I\n",
                    this, pStm, &riid));
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // read the objref from the stream and find or create an instance
    // of CStdMarshal for its OID. Then ask that guy to do the rest of
    // the unmarshal (create the interface proxy)

    OBJREF  objref;
    HRESULT hr = ReadObjRef(pStm, objref);

    if (SUCCEEDED(hr))
    {
        // pass objref to subroutine to unmarshal the objref
        hr = ::UnmarshalObjRef(objref, ppv);

        // release the objref we read
        FreeObjRef(objref);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
        "UnmarsalInterface this:%x pv:%x hr:%x\n", this, *ppv, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   UnmarshalSwitch           private
//
//  Synopsis:   This is a callback function used for switching to server
//              context during unmarshaling
//
//  Parameters: [pv] - void ptr to StdUnmarshalData structure
//
//  History:    03-Mar-98   Gopalk        Created
//
//--------------------------------------------------------------------
typedef struct tagStdUnmarshalData
{
    CStdIdentity   *pStdID;
    OBJREF         *pobjref;
    CObjectContext *pClientCtx;
    BOOL            fCreateWrapper;
    void          **ppv;
    BOOL            fLightNA;
} StdUnmarshalData;

HRESULT __stdcall UnmarshalSwitch(void *pv)
{
    TRACECALL(TRACE_MARSHAL, "UnmarshalSwitch");
    ComDebOut((DEB_MARSHAL, "UnmarshalSwitch pv:%x\n", pv));
    ASSERT_LOCK_NOT_HELD(gComLock);

    StdUnmarshalData *pStdData = (StdUnmarshalData *) pv;
    void **ppv = pStdData->fCreateWrapper ? NULL : pStdData->ppv;

    // Unmarshal objref
    HRESULT hr = pStdData->pStdID->UnmarshalObjRef(*pStdData->pobjref, ppv);
    if (pStdData->fCreateWrapper)
    {
        // Initialize
        *(pStdData->ppv) = NULL;
        if (SUCCEEDED(hr))
        {
            // Ask the CStdIdentity to get the wrapper.
            hr = pStdData->pStdID->GetWrapperForContext(pStdData->pClientCtx,
                                                        pStdData->pobjref->iid,
                                                        pStdData->ppv);
        }
    }

    // Fix up the refcount
    pStdData->pStdID->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "UnmarshalSwitch hr:%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CrossAptRefToNA, private
//
//  Synopsis:   Indicates if a cross-apartment reference to an object 
//              in the NA is being unmarshaled.
//
//  Arguements: [objref]    - object reference
//
//  Algorithm:  The following conditions must be true: the server must
//              live in the NA, the current thread must not be in the 
//              NA, the OBJREF must not represent an FTM object and have
//              been marshaled by this process.
//
//  History:    23-Feb-00   JohnStra     Created
//
//--------------------------------------------------------------------
BOOL CrossAptRefToNA(OBJREF &objref)
{
    if (objref.flags & OBJREF_STANDARD) 
    {
        ULONG *pipid = (ULONG*)(&ORSTD(objref).std.ipid);
        
        if (pipid[2] == NTATID &&
            pipid[2] != GetCurrentApartmentId() &&
            pipid[1] == GetCurrentProcessId() &&
            !(ORSTD(objref).std.flags & SORF_FTM))
        {
            ComDebOut((DEB_MARSHAL, "UnmarshalObjRef: server lives in NA\n"));
            return TRUE;
        }
    }

    return FALSE;
}



//+-------------------------------------------------------------------
//
//  Function:   UnmarshalObjRef, private
//
//  Synopsis:   UnMarshals interface from objref.
//
//  Arguements: [objref]    - object reference
//              [ppv]       - proxy
//
//  Algorithm:  Get the correct standard identity and ask it to do
//              all the work.
//
//  History:    25-Mar-95   AlexMit     Created
//              21-May-98   GopalK      Context changes
//
//--------------------------------------------------------------------
EXTERN_C IID IID_IEnterActivityWithNoLock;

INTERNAL UnmarshalObjRef(OBJREF &objref, void **ppv, BOOL fBypassActLock)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

	//
	// Find out if we've got a cross apartment reference to an object
	// in the NA.  If we do, then we want to create or find the wrapper
	// object later.  This also means that we are not necessarily searching
	// for a StdID in this apartment.
	//
	BOOL fLightNAProxy = CrossAptRefToNA(objref);

	CStdMarshal *pStdMshl;
	HRESULT hr = FindStdMarshal(objref, FALSE, &pStdMshl, fLightNAProxy);
	
	if (SUCCEEDED(hr))
	{
		// Create StdMarshalData object on the stack
		StdUnmarshalData StdData;
		
		// Initialize
		StdData.pStdID     = pStdMshl->GetStdID();
		StdData.pobjref    = &objref;
		StdData.ppv        = ppv;
		StdData.pClientCtx = GetCurrentContext();
		
		// Check for the need to switch to server context
		CObjectContext *pDestCtx = pStdMshl->ServerObjectCallable();
		if (pDestCtx)
		{
			// Switch
			StdData.fCreateWrapper = ppv ? TRUE : FALSE;

			if (fBypassActLock)
			{
				hr = PerformCallback(pDestCtx, UnmarshalSwitch, &StdData,
					IID_IEnterActivityWithNoLock, 2, NULL);
			}
			else
			{
				hr = PerformCallback(pDestCtx, UnmarshalSwitch, &StdData,
					IID_IMarshal, 6, NULL);
			}
		}
		else
		{
			// Call the callback function directly
			StdData.fCreateWrapper = fLightNAProxy;
			hr = UnmarshalSwitch(&StdData);
		}
	}
	else if (!IsTableObjRef(&ORSTD(objref).std))
	{
		// we could not create the indentity or handler, release the
		// marshaled objref, but only if it was not TABLESTRONG or
		// TABLEWEAK.
		ReleaseMarshalObjRef(objref);
	}

	ASSERT_LOCK_NOT_HELD(gComLock);
	return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ChkIfLocalOID, private
//
//  Synopsis:   Helper function for UnmarshalInternalObjRef & FindStdMarshal
//
//  Arguements: [objref] - object reference
//              [ppStdMshl] - CStdMarshal returned
//
//  Algorithm:  If the OXIDEntry in the objref is the same as the current one,
//              lookup the IPID and obtain the StdID from it. Note that the
//              OID is not looked up.
//
//  History:    21-May-95   MurthyS     Created.
//              26-Mar-98   Gopalk      Context changes
//              29-Mar-98   Johnstra    Agile FTM proxies
//
//--------------------------------------------------------------------
INTERNAL_(BOOL) ChkIfLocalOID(OBJREF &objref, CStdIdentity **ppStdId, BOOL fLightNA)
{
    STDOBJREF *pStd = &ORSTD(objref).std;
    BOOL flocal = FALSE;

    ComDebOut((DEB_MARSHAL, "ChkIfLocalOID (IN) poid: %x\n", &pStd->oid));
    Win4Assert((*ppStdId == NULL) && "ChkIfLocalOID: pStdId != NULL");

    // Get OXID to which the objref belongs
    OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
    OXIDEntry *pLocalEntry;
    GetLocalOXIDEntry(&pLocalEntry);

    // Is the OXID in the current apartment, or does the objref
    // represent an FTM object in the NA.
    if (pOXIDEntry == pLocalEntry ||
        (((pStd->flags & SORF_FTM) || fLightNA)   &&
          pOXIDEntry->IsNTAServer() &&
          pOXIDEntry->IsInLocalProcess()))
    {
        // The object is local, or its an FTM object in the NA,
        // lookup IPID which is faster than looking up OID. Further,
        // system objects may not have an OID

        flocal = TRUE;

        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);

        IPIDEntry *pEntry = gIPIDTbl.LookupIPID(pStd->ipid);
        if (pEntry && !(pEntry->dwFlags & IPIDF_DISCONNECTED) && pEntry->pChnl)
        {
            // get the Identity
            *ppStdId = pEntry->pChnl->GetStdId();
            if (fLightNA)
                (*ppStdId)->SetLightNA();
            (*ppStdId)->AddRef();
        }

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    ComDebOut((DEB_MARSHAL, "ChkIfLocalOID (OUT) fLocal:%x\n", flocal));
    return flocal;
}

//+-------------------------------------------------------------------
//
//  Function:   UnmarshalInternalObjRef, private
//
//  Synopsis:   UnMarshals an internally-used interface from objref.
//
//  Arguements: [objref]    - object reference
//              [ppv]       - proxy
//
//  Algorithm:  Create a StdId and ask it to do the work.
//
//  Notes:      This differs from UnmarshalObjRef in that it does not lookup
//              or register the OID. This saves a fair amount of work and
//              avoids initializing the OID table.
//
//  History:    25-Oct-95   Rickhi      Created
//
//--------------------------------------------------------------------
INTERNAL UnmarshalInternalObjRef(OBJREF &objref, void **ppv)
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    CStdIdentity *pStdId = NULL;
    HRESULT hr = S_OK;

    // Assert that the objref is a standard one
    Win4Assert(objref.flags & OBJREF_STANDARD);

    if (ChkIfLocalOID(objref, &pStdId, FALSE))
    {
        if (pStdId)
        {
            // set OID in objref to match that in returned std identity
            // CODEWORK: Why are we doing this? I do not see a scenario where
            //         system objects get unmarshaled in the server apartment
            //         let alone the case where system objects acquiring OID
            //         after they have been marshaled. GopalK
            OIDFromMOID(pStdId->GetOID(), &ORSTD(objref).std.oid);
        }
        else
        {
            hr = CO_E_OBJNOTCONNECTED;
        }
    }
    else
    {
        DWORD StdIdFlags = ((ORSTD(objref).std.flags & SORF_FREETHREADED) || gEnableAgileProxies)
                           ? STDID_CLIENT | STDID_SYSTEM | STDID_FREETHREADED
                           : STDID_CLIENT | STDID_SYSTEM;

        hr = CreateIdentityHandler(NULL, StdIdFlags, NULL, GetCurrentApartmentId(),
                                   IID_IStdIdentity, (void **)&pStdId);
    }

    if (SUCCEEDED(hr))
    {
        // pass objref to subroutine to unmarshal the objref. tell StdId not
        // to register the OID in the OID table.

        pStdId->IgnoreOID();
        hr = pStdId->UnmarshalObjRef(objref, ppv);
        CALLHOOKOBJECTCREATE(S_OK,ORHDL(objref).clsid,objref.iid,(IUnknown **)ppv);
        pStdId->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::UnmarshalObjRef, private
//
//  Synopsis:   unmarshals the objref. Called by CoUnmarshalInterface,
//              UnmarshalObjRef APIs, and UnmarshalInterface method.
//
//  History:    20-Feb-95   Rickhi      Created.
//              04-Mar-98   Gopalk      Context changes
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::UnmarshalObjRef(OBJREF &objref, void **ppv)
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::UnmarsalObjRef this:%x objref:%x riid:%I\n",
        this, &objref, &objref.iid));
    AssertValid();
    Win4Assert(ServerObjectCallable() == NULL);

    ENTER_NA_IF_NECESSARY()

    STDOBJREF   *pStd = &ORSTD(objref).std;
    OXIDEntry   *pOXIDEntry = GetOXIDFromObjRef(objref);
    DbgDumpSTD(pStd);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Prevent a disconnect from occuring while unmarshaling the
    // interface since we may have to yield the lock.

    HRESULT hr = PreventPendingDisconnect();

    if (SUCCEEDED(hr))
    {
        if (objref.flags & OBJREF_HANDLER)
        {
            // handler form, extract the handler clsid and set our flags
            _dwFlags |= SMFLAGS_HANDLER;
            _clsidHandler = ORHDL(objref).clsid;
        }

        if (!_pStdId->HaveOID())
        {
            // no OID registered yet, do that now. only possible on client side
            // during reconnect.

            MOID moid;
            MOIDFromOIDAndMID(pStd->oid, pOXIDEntry->GetMid(), &moid);

            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);
            hr = _pStdId->SetOID(moid);
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }

        if (SUCCEEDED(hr))
        {
            // find or create the IPID entry for the interface. On the client
            // side this may cause the creation of an interface proxy. It will
            // also manipulate the reference counts.

            hr = UnmarshalIPID(objref.iid, pStd, pOXIDEntry, ppv);
        }
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (ClientSide() && !(_dwFlags & SMFLAGS_LIGHTNA))
    {
        if (SUCCEEDED(hr))
        {
            if (_pStdId->IsAggregated() && ppv)
            {
                // we are currently holding a proxy pointer. If aggregated,
                // the controlling unknown may want to override this pointer
                // with his own version, so issue a QI to give it that chance.
                IUnknown *pUnk = (IUnknown *)*ppv;

#ifdef WX86OLE
                if (gcwx86.IsN2XProxy(pUnk))
                {
                    // Tell wx86 thunk layer to thunk as IUnknown
                    gcwx86.SetStubInvokeFlag((BOOL)1);
                }
#endif

                hr = pUnk->QueryInterface(objref.iid, ppv);
                pUnk->Release();
            }
        }
        else if (!IsTableObjRef(&ORSTD(objref).std))
        {
            // cleanup the marshal packet on failure (only meaningful on client
            // side, since if the unmarshal failed on the server side, the
            // interface is already cleaned up). Also, only do this for NORMAL
            // packets not TABLESTRONG or TABLEWEAK packets.
            ReleaseMarshalObjRef(objref);
        }
    }

    // now let pending disconnect through. on server-side, ignore any
    // error from HPD and pay attention only to the unmarshal result, since
    // a successful unmarshal on the server side may result in a disconnect
    // if that was the last external reference to the object.


    HRESULT hr2 = HandlePendingDisconnect(hr);

    if (FAILED(hr2) && ClientSide() && !(_dwFlags & SMFLAGS_LIGHTNA))
    {
        if (SUCCEEDED(hr) && ppv)
        {
            // a disconnect came in while unmarshaling. ppv contains an
            // AddRef'd interface pointer so go Release that now.
            ((IUnknown *)*ppv)->Release();
        }
        hr = hr2;
    }

    if (SUCCEEDED(hr2) && LogEventIsActive())
    {
        LogEventUnmarshal(objref);
    }

    LEAVE_NA_IF_NECESSARY()

    ComDebOut((DEB_MARSHAL, "CStdMarshal::UnmarsalObjRef this:%x hr:%x\n",
        this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::UnmarshalIPID, private
//
//  Synopsis:   finds or creates an interface proxy for the given
//              interface. may also do a remote query interface.
//
//  Arguements: [riid] - the interface to return
//              [std]  - standard objref to unmarshal from
//              [pOXIDEntry] - ptr to OXIDEntry of the server
//              [ppv]  - interface ptr of type riid returned, AddRef'd
//
//  Returns:    S_OK if succeeded
//
//  History:    20-Feb-95   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::UnmarshalIPID(REFIID riid, STDOBJREF *pStd,
                                   OXIDEntry *pOXIDEntry, void **ppv)
{
    TRACECALL(TRACE_MARSHAL, "CStdMarshal::UnmarshalIPID");
    ComDebOut((DEB_MARSHAL,
            "CStdMarshal::UnmarshalIPID this:%x riid:%I pStd:%x pOXIDEntry:%x\n",
            this, &riid, pStd, pOXIDEntry));
    DbgDumpSTD(pStd);
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    // validate input params.
    Win4Assert(!(IsEqualIID(riid, IID_NULL) || IsEqualIID(riid, IID_IMarshal)));
    Win4Assert(pStd != NULL);
    ValidateSTD(pStd, TRUE /*locked*/);
    Win4Assert(pOXIDEntry);

    // look for an existing IPIDEntry for the requested interface.
    IPIDEntry *pEntry;
    HRESULT hr = FindIPIDEntryByIID(riid, &pEntry);

#ifdef WX86OLE
    BOOL fSameApt = SUCCEEDED(hr);
    PVOID pvPSThunk = NULL;
#endif

    // REFCOUNTING:
    if (ClientSide() && !(_dwFlags & SMFLAGS_LIGHTNA))
    {
        if (FAILED(hr))
        {
            // no IPID Entry exists yet for the requested interface. We do
            // have a STDOBJREF.  Create the interface proxy and IPIDEntry
            // now, and connect it up. If successful, the proxy will be
            // fully connected upon return and the references taken.
            if (ppv)
                *ppv = NULL;

            hr = MakeCliIPIDEntry(riid, pStd, pOXIDEntry, &pEntry);
        }
        else if (pEntry->dwFlags & IPIDF_DISCONNECTED)
        {
            // reconnect the IPID entry to the server. this will take
            // any references present in pStd. Even though we could
            // yield, the IPIDEntry is guarenteed connected on return
            // (cause we are holding the lock on return).
            hr = ConnectCliIPIDEntry(pStd, pOXIDEntry, pEntry);
        }
        else
        {
            // IPIDEntry exists and is alread connected, just add
            // the references supplied in the packet to the
            // references in the IPIDEntry or RefCache.
            AddSuppliedRefs(pStd, pEntry);
        }
    }
    else if (SUCCEEDED(hr))
    {
        // unmarshaling in the server apartment. If the cRefs is zero,
        // then the interface was TABLE marshalled and we dont do
        // anything to the IPID RefCnts since the object must live until
        // ReleaseMarshalData is called on it.

#ifdef WX86OLE
        pvPSThunk = gcwx86.UnmarshalledInSameApt(pEntry->pv, riid);
#endif
        if (!IsTableObjRef(pStd))
        {
            // normal case, dec the ref counts from the IPID entry,
            // OLE always passed fLastReleaseCloses = FALSE on
            // Unmarshal and RMD so do the same here.

            DWORD mshlflags = (pStd->flags & SORF_P_WEAKREF)
                            ? (MSHLFLAGS_WEAK   | MSHLFLAGS_KEEPALIVE)
                            : (MSHLFLAGS_NORMAL | MSHLFLAGS_KEEPALIVE);
            DecSrvIPIDCnt(pEntry, pStd->cPublicRefs, 0, NULL, mshlflags);
        }
    }

    if (SUCCEEDED(hr) && ppv)
    {
        ValidateIPIDEntry(pEntry);

        // If the pointer to the server object is NULL then we are
        // disconnected.
        if(NULL == pEntry->pv)
        {
            hr = CO_E_OBJNOTCONNECTED;
        }
        else
        {
            // extract and AddRef the pointer to return to the caller.
            // Do this before releasing the lock (which we might do below
            // on the server-side in DecSrvIPIDCnt.

            // NOTE: we are calling App code while holding the lock,
            // but there is no way to avoid this.
            Win4Assert(IsValidInterface(pEntry->pv));
            *ppv = pEntry->pv;
            ((IUnknown *)*ppv)->AddRef();
            AssertOutPtrIface(hr, *ppv);

            if (_dwFlags & SMFLAGS_WEAKCLIENT && !(pStd->flags & SORF_P_WEAKREF))
            {
                // make the client interface weak, ignore errors.
                UNLOCK(gIPIDLock);
                ASSERT_LOCK_NOT_HELD(gIPIDLock);
                RemoteChangeRef(0,0);
                ASSERT_LOCK_NOT_HELD(gIPIDLock);
                LOCK(gIPIDLock);
            }
#ifdef WX86OLE
            // If we unmarshalled in the same apartment as the object and Wx86
            // recognized the interface then change the returned proxy to the
            // proxy created for the Wx86 PSThunk.
            if (pvPSThunk == (PVOID)-1)
            {
                // Wx86 recognized the interface, but could not establish a
                // PSThunk for it. Force an error return.
                *ppv = NULL;
                hr = E_NOINTERFACE;
            }
            else if (pvPSThunk != NULL)
            {
                // Wx86 recognized the interface and did establish a PSThunk
                // for it. Force a successful return with Wx86 proxy interface.
                *ppv = pvPSThunk;
            }
#endif
        }
    }

    ComDebOut((DEB_MARSHAL, "pEntry:%x cRefs:%x cStdId:%x\n", pEntry,
        (SUCCEEDED(hr)) ? pEntry->cStrongRefs : 0, _pStdId->GetRC()));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL, "CStdMarshal::UnmarshalIPID hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::PrivateCopyProxy, internal
//
//  Synopsis:   Creates a copy of a proxy and IPID entry.
//
//  Arguements: [pv]   - Proxy to copy
//              [ppv]  - return copy here.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::PrivateCopyProxy( IUnknown *pv, IUnknown **ppv )
{
    TRACECALL(TRACE_MARSHAL, "CStdMarshal::PrivateCopyProxy");
    ComDebOut((DEB_MARSHAL, "CStdMarshal::PrivateCopyProxy this:%x pv:%x\n",
            this, pv));

    // Don't copy stubs.
    if (ServerSide() || pv == NULL || ppv == NULL)
        return E_INVALIDARG;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Prevent a disconnect from occuring while unmarshaling the
    // interface since we may have to yield the ORPC lock.
    HRESULT hr = PreventPendingDisconnect();

    // Initialize
    *ppv = NULL;

    if (SUCCEEDED(hr))
    {
        // Find the proxy to copy.
        IPIDEntry *pEntry;
        hr = FindIPIDEntryByInterface(pv, &pEntry);
        if (SUCCEEDED(hr))
        {
            if (pEntry->dwFlags & IPIDF_DISCONNECTED)
            {
                // Don't copy disconnected proxies.
                hr = RPC_E_DISCONNECTED;
            }
            else if (IsEqualGUID(pEntry->iid, IID_IUnknown))
            {
                // IUnknown can't be copied.
                hr = E_INVALIDARG;
            }
            else
            {
                // make a copy of the proxy
                BOOL fNonNDRProxy;
                IRpcProxyBuffer *pProxy;
                void *pVoid;

                hr = CreateProxy(pEntry->iid, &pProxy, &pVoid, &fNonNDRProxy);
                if (SUCCEEDED(hr))
                {
                    IPIDEntry *pIpidCopy;

                    // add a disconnected IPID entry to the table.
                    hr = AddIPIDEntry(NULL, &pEntry->ipid, pEntry->iid, NULL,
                                      pProxy, pVoid, &pIpidCopy);

                    if (SUCCEEDED(hr))
                    {
                        if (pVoid)
                        {
                            // Follow the aggregation rules to cache interface
                            // pointer on the proxy by releasing the outer object
                            (_pStdId->GetCtrlUnk())->Release();
                        }

                        // mark this IPID as a copy so we dont free it during
                        // ReleaseIPIDs.
                        pIpidCopy->dwFlags |= IPIDF_COPY;

                        // connect the IPIDEntry before adding it to the table so
                        // that we dont have to worry about races between Unmarshal,
                        // Disconnect, and ReconnectProxies.

                        // Make up an objref. Mark it as NOPING since we dont
                        // really have any references and we dont really need
                        // any because if we ever try to marshal it we will
                        // find the original IPIDEntry and use that. NOPING
                        // also lets us skip this IPID in DisconnectCliIPIDs.

                        STDOBJREF std;
                        OXIDFromMOXID(pEntry->pOXIDEntry->GetMoxid(), &std.oxid);
                        std.ipid        = pEntry->ipid;
                        std.cPublicRefs = 1;
                        std.flags       = SORF_NOPING;

                        hr = ConnectCliIPIDEntry(&std, pEntry->pOXIDEntry, pIpidCopy);

                        // Add this IPID entry after the original.
                        pIpidCopy->pNextIPID = pEntry->pNextIPID;
                        pEntry->pNextIPID    = pIpidCopy;
                        _cIPIDs++;

                        // Return the interface to the client
                        if (SUCCEEDED(hr))
                        {
                            Win4Assert(pIpidCopy->pv);
                            *ppv = (IUnknown *) pIpidCopy->pv;
                            (*ppv)->AddRef();
                        }
                    }
                    else
                    {
                        // could not get an IPIDEntry, release the proxy, need to
                        // release the lock to do this.

                        UNLOCK(gIPIDLock);
                        ASSERT_LOCK_NOT_HELD(gIPIDLock);

                        // Release the interface before releasing proxy
                        if (pVoid)
                            ((IUnknown *) pVoid)->Release();
                        pProxy->Release();

                        ASSERT_LOCK_NOT_HELD(gIPIDLock);
                        LOCK(gIPIDLock);
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            ValidateIPIDEntry(pEntry);
            AssertOutPtrIface(hr, *ppv);
        }
        AssertDisconnectPrevented();
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Now let pending disconnect through.
    HRESULT hr2 = HandlePendingDisconnect(hr);
    if (FAILED(hr2) && SUCCEEDED(hr))
    {
        // a disconnect came in while creating the proxy. ppv contains
        // an AddRef'd interface pointer so go Release that now.
        (*ppv)->Release();
        *ppv = NULL;
    }

    ComDebOut((DEB_MARSHAL, "CStdMarshal::PrivateCopyProxy hr:%x\n", hr2));
    return hr2;
}

//+-------------------------------------------------------------------
//
//  Member:     MakeSrvIPIDEntry, private
//
//  Synopsis:   creates a server side IPID table entry.
//
//  Arguements: [riid] - the interface to return
//              [ppEntry] - IPIDEntry returned
//
//  History:    20-Feb-95   Rickhi       Created
//
//  Notes:      The stub is not created until connect time. The stub is
//              destroyed at disconnect, but the IPIDEntry remains around
//              until the stdmarshal object is destroyed.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::MakeSrvIPIDEntry(REFIID riid, IPIDEntry **ppEntry)
{
    Win4Assert(ServerSide());
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    IPID ipidDummy;
    IPIDEntry *pNewEntry;
    HRESULT hr = AddIPIDEntry(NULL, &ipidDummy, riid, NULL, NULL, NULL,
                              &pNewEntry);
    if (SUCCEEDED(hr))
    {
        // add IPIDEntry to chain for this object
        ChainIPIDEntry(pNewEntry);
    }

    // Initialize the return value
    *ppEntry = pNewEntry;

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     ConnectSrvIPIDEntry, private
//
//  Synopsis:   connects a server-side IPIDEntry
//
//  Arguements: [pEntry] - IPIDEntry to connect
//              [pUnkUseInner] - ??
//
//  History:    20-Feb-95   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::ConnectSrvIPIDEntry(IPIDEntry *pEntry, IUnknown *pUnkUseInner)
{
    ComDebOut((DEB_MARSHAL,
        "ConnectSrvIPIDEntry this:%x pEntry:%x\n", this, pEntry));
    Win4Assert(ServerSide());
    AssertValid();
    AssertDisconnectPrevented();
    ASSERT_LOCK_HELD(gIPIDLock);

    BOOL fNonNDRStub;
    void *pv;
    IRpcStubBuffer *pStub;
    HRESULT hr = CreateStub(pEntry->iid, &pStub, &pv, &fNonNDRStub, pUnkUseInner);

    if (SUCCEEDED(hr) && (pEntry->dwFlags & IPIDF_DISCONNECTED))
    {
        Win4Assert(pEntry->pv == NULL);
        pEntry->pStub = pStub;
        pEntry->pv    = pv;
        pEntry->pChnl = _pChnl;

        // entry is now connected
        pEntry->dwFlags &= ~IPIDF_DISCONNECTED;

        if (_dwFlags & SMFLAGS_NOPING)
        {
            // object does not need pinging, turn on NOPING
            pEntry->dwFlags |= IPIDF_NOPING;
        }

        if (fNonNDRStub)
        {
            // the stub was a custom 16bit one requested by WOW, mark the
            // IPIDEntry as holding a non-NDR stub so we know to set the
            // SORF_P_NONNDR flag in the StdObjRef when marshaling. This
            // tells local clients whether to create a MIDL generated
            // proxy or custom proxy. Functionality to support OLE
            // Automation on DCOM.

            pEntry->dwFlags |= IPIDF_NONNDRSTUB;
        }

        // increment the OXIDEntry ref count so that it stays
        // around as long as the IPIDEntry points to it. It gets
        // decremented when we disconnect the IPIDEntry.

        pEntry->pOXIDEntry = _pChnl->GetOXIDEntry();
        Win4Assert(pEntry->pOXIDEntry->GetTid() == GetCurrentApartmentId());
        pEntry->pOXIDEntry->IncRefCnt();
    }
    else if (SUCCEEDED(hr))
    {
        // while we released the lock to create the stub, some other thread
        // also created the stub, throw our stub away and use the already
        // created one.

        Win4Assert(pEntry->pv != NULL);
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        ((IUnknown *) pv)->Release();
        ((IRpcStubBuffer*)pStub)->Disconnect();
        pStub->Release();

        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL, "ConnectSrvIPIDEntry pEntry:%x pStub:%x hr:%x\n",
        pEntry, pStub, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     MakeCliIPIDEntry, private
//
//  Synopsis:   creates a client side IPID table entry
//
//  Arguements: [riid] - the interface to return
//              [pStd]  - standard objref
//              [pOXIDEntry] - OXIDEntry of the server
//              [ppEntry] - IPIDEntry returned
//
//  History:    20-Feb-95   Rickhi       Created
//              20-Nov-96   Gopalk       Release outer unknowm for
//                                       caching interface on proxy
//--------------------------------------------------------------------
HRESULT CStdMarshal::MakeCliIPIDEntry(REFIID riid, STDOBJREF *pStd,
                                      OXIDEntry *pOXIDEntry,
                                      IPIDEntry **ppEntry)
{
    Win4Assert(ClientSide());
    AssertValid();
    AssertDisconnectPrevented();
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_HELD(gIPIDLock);

    BOOL fNonNDRProxy;
    void *pv;
    IRpcProxyBuffer *pProxy;
    HRESULT hr = CreateProxy(riid, &pProxy, &pv, &fNonNDRProxy);

    if (SUCCEEDED(hr))
    {
        // add a disconnected IPID entry to the table.
        hr = AddIPIDEntry(NULL, &pStd->ipid, riid, NULL, pProxy, pv, ppEntry);

        if (SUCCEEDED(hr))
        {
            if (pv)
            {
                // Follow the aggregation rules to cache interface pointer
                // on the proxy by releasing the outer object
                (_pStdId->GetCtrlUnk())->Release();
            }

            if (fNonNDRProxy)
            {
                // the proxy is a custom 16bit one requested by WOW, mark the
                // IPIDEntry as holding a non-NDR proxy so we know to set the
                // LOCALF_NOTNDR flag in the local header when we call on it
                // (see CRpcChannelBuffer::ClientGetBuffer). Functionality to
                // support OLE Automation on DCOM.

                (*ppEntry)->dwFlags |= IPIDF_NONNDRPROXY;
            }

            if (pStd->flags & SORF_P_NONNDR)
            {
                // need to remember this flag so we can tell other
                // unmarshalers if we remarshal it.

                (*ppEntry)->dwFlags |= IPIDF_NONNDRSTUB;
            }

            // connect the IPIDEntry before adding it to the table so
            // that we dont have to worry about races between Unmarshal,
            // Disconnect, and ReconnectProxies.

            hr = ConnectCliIPIDEntry(pStd, pOXIDEntry, *ppEntry);

            // chain the IPIDEntries for this OID together. On client side
            // always add the entry to the list regardless of whether connect
            // succeeded.
            ChainIPIDEntry(*ppEntry);
        }
        else
        {
            // could not get an IPIDEntry, release the proxy, need to
            // release the lock to do this.

            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            // Release the interface before releasing proxy
            if(pv)
                ((IUnknown *) pv)->Release();

            // CreateProxy will set pProxy to NULL if iid was IUnknown
            if (pProxy)
                pProxy->Release();

            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     ConnectCliIPIDEntry, private
//
//  Synopsis:   connects a client side IPID table entry to the server
//
//  Arguments:  [pStd] - standard objref
//              [pOXIDEntry] - OXIDEntry for the server
//              [pEntry] - IPIDEntry to connect, already has a proxy
//                         and the IID filled in.
//
//  Notes:      This routine is re-entrant, it may be called multiple
//              times for the same IPIDEntry, with part of the work done
//              in one call and part in another. Only if the entry is
//              fully set up will it return S_OK and mark the entry as
//              connected. DisconnectCliIPIDs handles cleanup of partial
//              connections.
//
//  History:    20-Feb-95   Rickhi       Created
//              20-Nov-96   Gopalk       Release outer unknowm for
//                                       caching interface on proxy
//--------------------------------------------------------------------
HRESULT CStdMarshal::ConnectCliIPIDEntry(STDOBJREF *pStd,
                                         OXIDEntry *pOXIDEntry,
                                         IPIDEntry *pEntry)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::ConnectCliIPIDEntry this:%x ipid:%I pOXIDEntry:%x pIPIDEntry:%x\n",
         this, &pStd->ipid, pOXIDEntry, pEntry));
    Win4Assert(ClientSide());
    AssertDisconnectPrevented();
    AssertValid();
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_HELD(gIPIDLock);
    HRESULT hr = S_OK;

    // mark the object as having attempted to connect an IPIDEntry so that
    // if we fail somewhere in this routine and dont mark the whole object
    // as connected, Disconnect will still try to clean things up.

    _dwFlags |= SMFLAGS_TRIEDTOCONNECT;

    if (!(pStd->flags & SORF_NOPING))
    {
        // this interface requires pinging, turn off NOPING for this object
        // and this IPIDEntry.
        _dwFlags        &= ~SMFLAGS_NOPING;
        pEntry->dwFlags &= ~IPIDF_NOPING;
    }

    if (!(_dwFlags & (SMFLAGS_REGISTEREDOID | SMFLAGS_NOPING)))
    {
        // register the OID with the ping server so it will get pinged
        Win4Assert(_pRefCache == NULL);
        OXID oxid;
        OXIDFromMOXID(pOXIDEntry->GetMoxid(), &oxid);
        hr = gROIDTbl.ClientRegisterOIDWithPingServer(_pStdId->GetOID(),
                                                      oxid,
                                                      pOXIDEntry->GetMid(),
                                                      &_pRefCache);
        if (FAILED(hr))
        {
            Win4Assert(_pRefCache == NULL);
            return hr;
        }

        Win4Assert(_pRefCache);
        _dwFlags |= SMFLAGS_REGISTEREDOID;
    }

    // Go get any references we need that are not already included in the
    // STDOBJREF. These references will have been added to the counts in
    // the IPIDEntry upon return. Any references in the STDOBJREF will be
    // added to the IPIDEntry count only if the connect succeeds, otherwise
    // ReleaseMarshalObjRef (which will clean up STDOBJREF references) will
    // get called by higher level code.
    if (!(pEntry->dwFlags & IPIDF_NOPING) && !(pStd->flags & SORF_P_WEAKREF))
    {
        // register this entry with the reference cache
        _pRefCache->TrackIPIDEntry(pEntry);
    }

    hr = GetNeededRefs(pStd, pOXIDEntry, pEntry);
    if (FAILED(hr))
    {
        return hr;
    }

    if (pEntry->pChnl == NULL)
    {
        // create a channel for this oxid/ipid pair. On the client side we
        // create one channel per proxy (and hence per IPID). Note that
        // this will release the lock so we need to guard against two threads
        // doing this at the same time.

        CCtxComChnl *pChnl = NULL;
        hr = CreateChannel(pOXIDEntry, pStd->flags, pStd->ipid,
                           pEntry->iid, &pChnl);

        if (SUCCEEDED(hr))
        {
            if (pEntry->pChnl == NULL)
            {
                // update this IPID table entry. must update ipid too since
                // on reconnect it differs from the old value.

                pOXIDEntry->IncRefCnt();
                pEntry->pOXIDEntry  = pOXIDEntry;
                pEntry->ipid        = pStd->ipid;
                if (pEntry->pIRCEntry)
                {
                    pEntry->pIRCEntry->ipid = pStd->ipid;
                }
                pEntry->pChnl = pChnl;
                pEntry->pChnl->SetIPIDEntry(pEntry);
            }
            else
            {
                // another thread already did the update, just release
                // the channel we created.
                pChnl->Release();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // Release the lock while we connect the proxy. We have to do
        // this because the IDispatch proxy makes an Rpc call during
        // Connect (Yuk!), which causes the channel to assert that the
        // lock is released. The proxy MUST be able to handle multiple
        // simultaneous or nested connects to the same channel ptr, since
        // it is possible when we yield the lock for another thread to
        // come in here and try a connect.

        void *pv = NULL;
        IRpcProxyBuffer * pProxy = (IRpcProxyBuffer *)(pEntry->pStub);

        if (pProxy)
        {
            // HACKALERT: OleAutomation returns NULL pv in CreateProxy
            // in cases where they dont know whether to return an NDR
            // proxy or a custom-format proxy. So we have to go connect
            // the proxy first then Query for the real interface once that
            // is done.

            BOOL fGetpv = (pEntry->pv) ? FALSE : TRUE;

            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            hr = pProxy->Connect((IRpcChannelBuffer3 *) pEntry->pChnl);
            if (fGetpv && SUCCEEDED(hr))
            {
#ifdef WX86OLE
                if (gcwx86.IsN2XProxy(pProxy))
                {
                    // If we are creating a proxy for an object that is
                    // living on the x86 side then we need to set the
                    // StubInvoke flag to allow QI to thunk the
                    // custom interface QI.
                    gcwx86.SetStubInvokeFlag((BOOL)2);
                }
#endif
                hr = pProxy->QueryInterface(pEntry->iid, &pv);
                AssertOutPtrIface(hr, pv);

                if(SUCCEEDED(hr))
                {
#ifdef WX86OLE
                    // Call whole32 thunk layer to play with the ref count
                    // and aggregate the proxy to the controlling unknown.
                    gcwx86.AggregateProxy(_pStdId->GetCtrlUnk(),
                                          (IUnknown *)pv);
#endif
                    // Follow the aggregation rules to cache interface pointer
                    // on the proxy by releasing the outer object
                    (_pStdId->GetCtrlUnk())->Release();
                }
            }

            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
        }

        // Regardless of errors from Connect and QI we wont try to cleanup
        // any of the work we have done so far in this routine. The routine
        // is reentrant (by the same thread or by different threads) and
        // those calls could be using some of resources we have already
        // allocated. Instead, we rely on DisconnectCliIPIDs to cleanup
        // the partial allocation of resources.

        if (pEntry->dwFlags & IPIDF_DISCONNECTED)
        {
            // Mark the IPIDEntry as connected so we dont try to connect
            // again. Also, as long as there is one IPID connected, the
            // whole object is considered connected. This allows disconnect
            // to find the newly connected IPID and disconnect it later.
            // Infact, DisconnectCliIPIDs relies on there being at least
            // one IPID with a non-NULL OXIDEntry. It is safe to set this
            // now because Disconnects have been temporarily turned off.

            if (SUCCEEDED(hr))
            {
                if (pv)
                {
                    // assign the interface pointer
                    pEntry->pv = pv;
                }

                AssertDisconnectPrevented();
                pEntry->dwFlags &= ~IPIDF_DISCONNECTED;
                _dwFlags &= ~SMFLAGS_DISCONNECTED;
            }
        }
        else
        {
            // while the lock was released, the IPIDEntry got connected
            // by another thread (or by a nested call on this thread).
            // Ignore any errors from Connect or QI since apparently
            // things are connected now.
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            // give the supplied references to the IPIDEntry or
            // to the refcache.
            AddSuppliedRefs(pStd, pEntry);
        }

        // in debug build, ensure that we did not mess up
        ValidateIPIDEntry(pEntry);
    }

    ASSERT_LOCK_HELD(gIPIDLock);

    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::ConnectCliIPIDEntry this:%x pOXIDEntry:%x pChnl:%x hr:%x\n",
         this, pEntry->pOXIDEntry, pEntry->pChnl, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     AddSuppliedRefs, private
//
//  Synopsis:   Takes the references from STDOBJREF and gives them
//              to the IPIDEntry or RefCache.
//
//  Arguments:  [pStd] - standard objref
//              [pEntry] - IPIDEntry
//
//  History:    20-Jan-99   Rickhi       Created
//
//--------------------------------------------------------------------
void CStdMarshal::AddSuppliedRefs(STDOBJREF *pStd, IPIDEntry *pEntry)
{
    // Add in any references we were given. If we were given 0 refs
    // and the interface is NOPING, then pretend like we got 1 ref.
    ULONG cRefs = ((pStd->cPublicRefs == 0) && (pStd->flags & SORF_NOPING))
                  ? 1 : pStd->cPublicRefs;

    // figure out if we have weak or strong references. To be weak
    // they must be local to this machine and the SORF flag set.
    BOOL fWeak = ((pStd->flags & SORF_P_WEAKREF) &&
                 (pEntry->pOXIDEntry->IsOnLocalMachine()));

    BOOL bWeakIPID = FALSE;
    
    if (fWeak)
        pEntry->cWeakRefs += cRefs;
    else
    {
        if (pEntry->cWeakRefs)
            bWeakIPID = TRUE;   
        pEntry->cStrongRefs += cRefs;
    }   
    if (!(pEntry->dwFlags & IPIDF_NOPING) && !(pStd->flags & SORF_P_WEAKREF) && !bWeakIPID)
    {
        // give extra references to the cache so they can be
        // shared by other apartments in this process.
        _pRefCache->GiveUpRefs(pEntry);
    }
}

//+-------------------------------------------------------------------
//
//  Member:     GetNeededRefs, private
//
//  Synopsis:   Figures out if any references are needed and goes and gets
//              them from the server.
//
//  Arguments:  [pStd] - standard objref
//              [pOXIDEntry] - OXIDEntry for the server
//              [pEntry] - IPIDEntry to connect, already has a proxy
//                         and the IID filled in.
//
//  History:    20-Feb-95   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::GetNeededRefs(STDOBJREF *pStd, OXIDEntry *pOXIDEntry,
                                   IPIDEntry *pEntry)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    HRESULT hr  = S_OK;

    if ((pStd->flags & (SORF_NOPING | SORF_P_WEAKREF)) == 0)
    {
        // object does reference counting, go get the references we need...

        // if we dont have any and weren't given any strong refs, go get some.
        ULONG cNeedStrong = ((pEntry->cStrongRefs + pStd->cPublicRefs) == 0)
                            ? 1 : 0;

        // if we are using secure refs and we dont have any, go get some.
        ULONG cNeedSecure = ((gCapabilities & EOAC_SECURE_REFS) &&
                            (pEntry->cPrivateRefs == 0)) ? 1 : 0;

        if (cNeedStrong || cNeedSecure)
        {
            // Need to go get some references from the remote server or reference
            // cache. Note that we might yield here but we dont have to worry about
            // it because the IPIDEntry is still marked as disconnected.
            hr = RemoteAddRef(pEntry, pOXIDEntry, cNeedStrong, cNeedSecure, FALSE);
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return hr;
 }

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReconnectProxies
//
//  Synopsis:   Reconnects the proxies to a new server (functionality
//              used by the OLE default handler).
//
//  History:    20-Feb-95   Rickhi  Created.
//
//  CODEWORK:   CreateServer should just ask for all these interfaces
//              during the create.
//
//--------------------------------------------------------------------
void CStdMarshal::ReconnectProxies()
{
    ComDebOut((DEB_MARSHAL,"CStdMarshal::ReconnectProxies this:%x pFirst:%x\n",
            this, _pFirstIPID));
    AssertValid();
    Win4Assert(ClientSide());
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // must be at least 1 proxy already connected in order to be able
    // to reconnect the other proxies. We cant just ASSERT that's true
    // because we were not holding the lock on entry.

    HRESULT hr = PreventDisconnect();

    if (SUCCEEDED(hr))
    {
        // allocate a stack buffer to hold the IPIDs
        IID *pIIDsAlloc = (IID *) _alloca(_cIPIDs * sizeof(IID));
        IID    *pIIDs = pIIDsAlloc;
        USHORT  cIIDs = 0;

        IPIDEntry *pNextIPID = _pFirstIPID;
        while (pNextIPID)
        {
            if (pNextIPID->dwFlags & IPIDF_COPY)
            {
                // Don't allow reconnection for servers with
                // secure proxies (copied IPIDEntries).
                hr = E_FAIL;
                break;
            }

            if ((pNextIPID->dwFlags & IPIDF_DISCONNECTED))
            {
                // not connected, add it to the list to be connected.
                *pIIDs = pNextIPID->iid;
                pIIDs++;
                cIIDs++;
            }

            pNextIPID = pNextIPID->pNextIPID;
        }

        if (cIIDs != 0 && SUCCEEDED(hr))
        {
             // we have looped filling in the IID list, and there are
             // entries int he list. go call QI on server now and
             // unmarshal the results.

             hr = RemQIAndUnmarshal(cIIDs, pIIDsAlloc, NULL);
        }
    }

    DbgWalkIPIDs();
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // this will handle any Disconnect that came in while we were busy.
    hr = HandlePendingDisconnect(hr);

    ComDebOut((DEB_MARSHAL,"CStdMarshal::ReconnectProxies [OUT] this:%x\n", this));
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReleaseMarshalData, public
//
//  Synopsis:   Releases the references added by MarshalInterface
//
//  Arguements: [pStm] - stream containing marsheld interface
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::ReleaseMarshalData(LPSTREAM pStm)
{
    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::ReleaseMarshalData this:%x pStm:%x\n", this, pStm));
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gComLock);

    OBJREF  objref;
    HRESULT hr = ReadObjRef(pStm, objref);

    if (SUCCEEDED(hr))
    {
        // call worker API to do the rest of the work
        hr = ::ReleaseMarshalObjRef(objref);

        // deallocate the objref we read
        FreeObjRef(objref);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::ReleaseMarshalData this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     ReleaseObjRefSwitch       private
//
//  Synopsis:   This is a callback function used for switching to server
//              context during releasing objref
//
//  Arguements: [pv] - void ptr to StdReleaseData structure
//
//  History:    03-Mar-98   Gopalk        Created
//
//--------------------------------------------------------------------
typedef struct tagStdReleaseData
{
    CStdMarshal *pStdMshl;
    OBJREF      *pObjRef;
} StdReleaseData;

HRESULT __stdcall ReleaseObjRefSwitch(void *pv)
{
    ComDebOut((DEB_MARSHAL, "ReleaseObjRefSwitch pv:%x\n", pv));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    OBJREF      *pObjRef  = ((StdReleaseData *) pv)->pObjRef;
    CStdMarshal *pStdMshl = ((StdReleaseData *) pv)->pStdMshl;

    // pass objref to subroutine to Release the marshaled data
    HRESULT hr = pStdMshl->ReleaseMarshalObjRef(*pObjRef);

    // Fix up the refcount
    pStdMshl->Release();

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "ReleaseObjRefSwitch hr:%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   ReleaseMarshalObjRef, private
//
//  Synopsis:   Releases the references added by MarshalObjRef
//
//  Arguements: [objref] - object reference
//
//  Algorithm:  Get the correct standard identity and ask it to do
//              a ReleaseMarshalData.
//
//  History:    19-Jun-95   Rickhi      Created
//              09-Jul-97   GopalK      Context related changes
//                                      and race fix
//
//--------------------------------------------------------------------
INTERNAL ReleaseMarshalObjRef(OBJREF &objref)
{
    ComDebOut((DEB_MARSHAL, "ReleaseMarshalObjRef objref:%x\n", &objref));
    ASSERT_LOCK_NOT_HELD(gComLock);
    Win4Assert(objref.flags != OBJREF_CUSTOM);

    HRESULT hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        // Lookup the identity or handler.

        // If the packet contains references, or it is a TABLESTRONG packet,
        // then create the StdMarshal if it does not already exist.
        STDOBJREF *pStd = &ORSTD(objref).std;
        BOOL fLocal = ((pStd->cPublicRefs != 0) || IsTableStrongObjRef(pStd))
                     ? FALSE : TRUE;

        BOOL fLightNAProxy = CrossAptRefToNA(objref);

        CStdMarshal *pStdMshl;
        hr = FindStdMarshal(objref, fLocal, &pStdMshl, fLightNAProxy);
        if (SUCCEEDED(hr))
        {
            // Create StdMarshalData object on the stack
            StdReleaseData StdData;

            // Initialize
            StdData.pStdMshl = pStdMshl;
            StdData.pObjRef  = &objref;

            // Check for the need to switch
            CObjectContext *pDestCtx = pStdMshl->ServerObjectCallable();
            if (pDestCtx)
            {
                // Switch
                hr = PerformCallback(pDestCtx, ReleaseObjRefSwitch, &StdData,
                                     IID_IMarshal, 7, NULL);
            }
            else
            {
                // Call the callback function directly
                hr = ReleaseObjRefSwitch(&StdData);
            }
        }
        else if (hr != CO_E_OBJNOTCONNECTED)
        {
            // Do nothing if the objref has no references.
            if (pStd->cPublicRefs != 0)
            {
                // we could not find or create an identity and the server is
                // outside this apartment, try to issue a remote release on
                // the interface
                RemoteReleaseObjRef(objref);
            }
        }
        else
        {
            // Return success if the server object has already been
            // disconnected for legacy support
            hr = S_OK;
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "ReleaseMarshalObjRef hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReleaseMarshalObjRef, public
//
//  Synopsis:   Releases the references added by MarshalObjRef
//
//  Arguements: [objref] - object reference
//
//  History:    20-Feb-95   Rickhi      Created.
//              04-Mar-98   Gopalk      Context changes
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::ReleaseMarshalObjRef(OBJREF &objref)
{
    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::ReleaseMarshalObjRef this:%x objref:%x\n", this, &objref));
    AssertValid();
    Win4Assert(ServerObjectCallable() == NULL);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    STDOBJREF *pStd = &ORSTD(objref).std;
    ValidateSTD(pStd);

    ENTER_NA_IF_NECESSARY()

    // REFCOUNTING:
    if (ServerSide())
    {
        LOCK(gIPIDLock);

        // look for an existing IPIDEntry for the given IPID
        IPIDEntry *pEntry;
        hr = FindIPIDEntryByIPID(pStd->ipid, &pEntry);

        if (SUCCEEDED(hr) && !(pEntry->dwFlags & IPIDF_DISCONNECTED))
        {
            // subtract the ref count from the IPIDEntry, may Release the
            // StdId if this was the last reference for this IPIDEntry.

            // we need to figure out how it was marshalled, strong/weak etc
            // in order to set the flags and cRefs correctly to pass to
            // DecSrvIPIDCnt.

            if (IsTableObjRef(pStd))
            {
                // table case
                DWORD mshlflags = (pStd->flags & SORF_P_TBLWEAK)
                             ? MSHLFLAGS_TABLEWEAK : MSHLFLAGS_TABLESTRONG;
                DecSrvIPIDCnt(pEntry, 1, 0, NULL, mshlflags);
            }
            else
            {
                // normal or weak case
                DWORD mshlflags = (pStd->flags & SORF_P_WEAKREF)
                             ? MSHLFLAGS_WEAK : MSHLFLAGS_NORMAL;
                DecSrvIPIDCnt(pEntry, pStd->cPublicRefs, 0, NULL, mshlflags);
            }
        }

        UNLOCK(gIPIDLock);
    }
    else  // client side
    {
        if ((pStd->flags & SORF_NOPING) || IsTableWeakObjRef(pStd))
        {
            // this interface does not need pinging, or this packet
            // represents a TABLEWEAK reference, there is nothing to do.
            hr = S_OK;
        }
        else
        {
            // the packet owns some references, try to give them to
            // the reference cache or to the IPIDEntry.

            if (IsTableStrongObjRef(pStd))
            {
                // client-side table-strong packet, release a reference
                // on the refcache if it was marshaled by us.
                OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
                hr = ReleaseClientTableStrong(pOXIDEntry);
            }
            else
            {
                // normal, non-zero reference. look for an existing IPIDEntry
                // for the given IPID and try to give the refs to it.
                LOCK(gIPIDLock);

                IPIDEntry *pEntry;
                hr = FindIPIDEntryByIPID(pStd->ipid, &pEntry);
                if (SUCCEEDED(hr) && !(pEntry->dwFlags & IPIDF_DISCONNECTED))
                {
                    // add these to the cRefs of this entry, they will get freed
                    // when we do the remote release.  Saves an Rpc call now.
                    AddSuppliedRefs(pStd, pEntry);
                    UNLOCK(gIPIDLock);
                }
                else
                {
                    // client side, no matching IPIDEntry so just contact the remote
                    // server to remove the reference. ignore errors since there is
                    // nothing we can do about them anyway.
                    UNLOCK(gIPIDLock);
                    RemoteReleaseObjRef(objref);
                    hr = S_OK;
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    LEAVE_NA_IF_NECESSARY()

    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::ReleaseMarshalObjRef this:%x hr:%x\n", this, hr));
    return hr;
}
//--------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReleaseClientTableStong, private
//
//  Synposys:   release a client-side table-strong packet reference
//              on the refcache if it was marshaled by us.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::ReleaseClientTableStrong(OXIDEntry *pOXIDEntry)
{
    ComDebOut((DEB_MARSHAL,
              "CStdMarshal::ReleaseClientTableStrong this:%x\n"));

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    BOOL fFromCache = FALSE;
    CRefCache *pRefCache = _pRefCache;
    if (pRefCache == NULL)
    {
        // find the refcache, if none, then we are no longer
        // pinging this interface and there is nothing to do.
        pRefCache = gROIDTbl.LookupRefCache(_pStdId->GetOID());
        fFromCache = TRUE;
    }

    if (pRefCache)
    {
        // release the TABLESTRONG reference from the refcache.

        // The refcache might ask us to go release all remote
        // references so give it a place to put the data.
        USHORT cRifRef = 0;
        REMINTERFACEREF *pRifRefAlloc = (REMINTERFACEREF *)
            _alloca(pRefCache->NumIRCs() * 2 * sizeof(REMINTERFACEREF));
        REMINTERFACEREF *pRifRef = pRifRefAlloc;

        pRefCache->DecTableStrongCnt(_dwFlags &
                                     SMFLAGS_CLIENTMARSHALED,
                                     &pRifRef, &cRifRef);
        
        // If we got the CRefCache from the cache, we need to release the
        // reference it took on our behalf.
        if (fFromCache)
        {
            pRefCache->DecRefCnt();
        }
        
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        if (cRifRef != 0)
        {
            // need to go release the remote references
            RemoteReleaseRifRef(this, pOXIDEntry, cRifRef, pRifRefAlloc);
        }        
    }
    else
    {
        UNLOCK(gIPIDLock);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return S_OK;
}

//--------------------------------------------------------------------
//
//  Member:     CStdMarshal::PreventDisconnect, public
//
//  Synopsis:   Prevents a Disconnect from occurring until a matching
//              HandlePendingDisconnect is called.
//
//  History:    21-Sep-95   Rickhi      Created
//              15-Jun-98   GopalK      Context related changes
//
//  The ORPC LOCK is yielded at many places in order to make calls on
//  application interfaces (server-side objects, stubs, proxies,
//  handlers, remote objects, resolver, etc). In order to keep the
//  code (reasonably?) simple, disconnects are prevented from occuring
//  while in the middle of (potentially) complex operations, and while
//  there are outstanding calls on interfaces to this object.
//
//  To accomplish this, a counter (_cNestedCalls) is atomically incremented.
//  When _cNestedCalls != 0 and a Disconnect arrives, the object is flagged
//  as PendingDisconnect. When HandlePendingDisconnect is called, it
//  decrements the _cNestedCalls. If the _cNestedCalls == 0 and there is
//  a pending disconnect, the real Disconnect is done.
//
//  See also LockServer / UnlockServer and LockClient / UnlockClient.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::PreventDisconnect()
{
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(ClientSide() || (ServerObjectCallable() == NULL));

    // treat this as a nested call so that if we yield, a real
    // disconnect wont come through, instead it will be treated
    // as pending. That allows us to avoid checking our state
    // for Disconnected every time we yield the ORPC LOCK.

    InterlockedIncrement(&_cNestedCalls);
    if (_dwFlags & (SMFLAGS_DISCONNECTED | SMFLAGS_PENDINGDISCONNECT))
    {
        return CO_E_OBJNOTCONNECTED;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::PreventPendingDisconnect, public
//
//  Synopsis:   similar to PreventDisconnect but special case for use
//              in UnmarshalObjRef (since the client side starts out
//              in the Disconnected state until the first unmarshal is done).
//
//  History:    21-Sep-95   Rickhi      Created
//              15-Jun-98   GopalK      Context related changes
//
//+-------------------------------------------------------------------
HRESULT CStdMarshal::PreventPendingDisconnect()
{
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(ClientSide() || (ServerObjectCallable() == NULL));

    InterlockedIncrement(&_cNestedCalls);
    if (_dwFlags &
       (ClientSide() ? SMFLAGS_PENDINGDISCONNECT
                     : SMFLAGS_PENDINGDISCONNECT | SMFLAGS_DISCONNECTED))
     return CO_E_OBJNOTCONNECTED;

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::HandlePendingDisconnect, public
//
//  Synopsis:   Reverses a call to PreventDisconnect and lets a
//              pending disconnect through.
//
//  Arguements: [hr] - return code from previous operations
//
//  History:    21-Sep-95   Rickhi      Created
//              15-Jun-98   GopalK      Context related changes
//
//+-------------------------------------------------------------------
HRESULT CStdMarshal::HandlePendingDisconnect(HRESULT hr)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    Win4Assert(ClientSide() || (ServerObjectCallable() == NULL));

    // Disconnect if needed
    if (InterlockedDecrement(&_cNestedCalls) == 0 &&
       (_dwFlags & SMFLAGS_PENDINGDISCONNECT))
    {
        DWORD dwType = GetPendingDisconnectType();

        Disconnect(dwType);
        hr = FAILED(hr) ? hr : CO_E_OBJNOTCONNECTED;
    }

    Win4Assert(_cNestedCalls != -1);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     DisconnectSwitch             private
//
//  Synopsis:   This is a callback function used for switching to server
//              context during disconnect
//
//  Arguements: [pv] - void ptr to StdDiscData structure
//
//  History:    03-Mar-98   Gopalk        Created
//
//--------------------------------------------------------------------
typedef struct tagStdDiscData
{
    CStdMarshal *pStdMshl;
    DWORD        dwType;
    BOOL         fRelease;
} StdDiscData;

HRESULT __stdcall DisconnectSwitch(void *pv)
{
    ComDebOut((DEB_MARSHAL, "DisconnectSwitch pv:%x\n", pv));
    ASSERT_LOCK_NOT_HELD(gComLock);

    CStdMarshal *pStdMshl = ((StdDiscData *) pv)->pStdMshl;

    // Disconnect
    pStdMshl->Disconnect(((StdDiscData *) pv)->dwType);

    // Fixup the refcount
    if(((StdDiscData *) pv)->fRelease)
        pStdMshl->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "DisconnectSwitch hr:%x\n", S_OK));
    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DisconnectAndRelease   public
//
//  Synopsis:   This is utility function that disconnects and release
//              the ID in the right context
//
//  Arguements: [dwType] - disconnect type (see DISCTYPE_*)
//
//  History:    15-Jun-98   Gopalk        Created
//
//--------------------------------------------------------------------
void CStdMarshal::DisconnectAndRelease(DWORD dwType)
{
    ComDebOut((DEB_MARSHAL, "IN CStdMarshal::DisconnectAndRelease\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Create StdDiscData object on the stack
    StdDiscData StdData;

    // Initialize
    StdData.dwType   = dwType;
    StdData.fRelease = TRUE;
    StdData.pStdMshl = this;

    CObjectContext *pDestCtx = ServerObjectCallable();
    if (pDestCtx)
    {
        // Switch
        PerformCallback(pDestCtx, DisconnectSwitch, &StdData,
                        IID_IMarshal, 8, NULL);
    }
    else
    {
        // Call the callback function directly
        DisconnectSwitch(&StdData);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_MARSHAL, "OUT CStdMarshal::DisconnectAndRelease\n"));
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DisconnectObject, public
//
//  Synopsis:   part of IMarshal interface, this is legal only on the
//              server side.
//
//  History:    20-Feb-95   Rickhi      Created.
//              27-Mar-98   Johnstra    Switch to NA if FTM object
//
//--------------------------------------------------------------------
STDMETHODIMP CStdMarshal::DisconnectObject(DWORD dwReserved)
{
    ComDebOut((DEB_MARSHAL,
     "CStdMarshal::DisconnectObject this:%x dwRes:%x\n", this, dwReserved));
    AssertValid();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // this operation is not legal from the client side (although
    // IProxyManager::Disconnect is), but we still have to return S_OK
    // in either case for backward compatibility.
    if (ServerSide())
    {
        Win4Assert(!SystemObject());

        // Disconnect the object
        Disconnect(DISCTYPE_APPLICATION);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::Disconnect, public
//
//  Synopsis:   client side - disconnects proxies from the channel.
//              server side - disconnects stubs from the server object.
//
//  Arguements: [dwType] - disconnect type (see DISCTYPE_*)
//
//  History:    20-Feb-95   Rickhi      Created.
//              04-Mar-98   Gopalk      Context changes
//              25-Nov-98   GopalK      Rewrite.
//
//--------------------------------------------------------------------
void CStdMarshal::Disconnect(DWORD dwType)
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::Disconnect this:%x type:%d\n",
               this, dwType));
    AssertValid();

    // Mustn't call LogEventIsActive() inside LOCK
    BOOL fLogEventIsActive = (LogEventIsActive() && _pChnl != NULL);
    BOOL fDisconnectedNow  = FALSE;
    MIDEntry    *pMIDEntry = NULL;
    CCtxComChnl *pChnl     = NULL;

    // Acquire the lock
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Sanity checks
    Win4Assert(!SystemObject() ||
               (dwType & (DISCTYPE_SYSTEM | DISCTYPE_RELEASE | DISCTYPE_NORMAL)));
    Win4Assert((dwType != DISCTYPE_RELEASE) || ServerSide() || (_pID == NULL) ||
               (_pID->GetStdID() == NULL));

    // Check the disconnect state
    BOOL fFullyDisconnected = ((_dwFlags & SMFLAGS_DISCONNECTED) &&
                               ((_dwFlags & SMFLAGS_TRIEDTOCONNECT) == 0));

    // Avoid unneccessary work
    if (fFullyDisconnected == FALSE)
    {
        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);

        BOOL fOkToDisconnect = (_pID) ? _pID->IsOkToDisconnect() : TRUE;

        if ((_pStdId->GetStrongCnt() || !fOkToDisconnect) && ServerSide() && dwType == DISCTYPE_NORMAL )
        {
            // This is a NORMAL disconnect (i.e. due to a RemRelease), however,
            // there are still strong references to the server, which means that
            // RemRelease is racing with Marshal, so leave the object connected
            // so that Marshal can continue.
            ComDebOut((DEB_WARN,"CStdMarshal::Disconnect [not done]:%x\n",this));

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }
        else
        {
            // Revoke the OID from the OID table. This prevents other
            // marshals/unmarshals from finding this identity that is about to
            // be disconnected. This is the ONLY state that should change when
            // work is in progress on other threads or on calls higher up
            // the stack
            BOOL fRevokeOID = (((_dwFlags & SMFLAGS_PENDINGDISCONNECT) == 0) &&
                               (ClientSide()
                                ? (dwType != DISCTYPE_RELEASE)
                                : (_pStdId->IsAggregated()
                                   ? (dwType & (DISCTYPE_UNINIT | DISCTYPE_RELEASE))
                                   : TRUE)));
            if (fRevokeOID)
            {
                _pStdId->RevokeOID();

                // Detach from IDObject
                if (_pID && (ClientSide() ? (dwType != DISCTYPE_APPLICATION) : TRUE))
                    _pID->RemoveStdID();
            }

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            if (_cNestedCalls != 0)
            {
#if DBG==1
                // There is a bug saying.  In case of MTA clients to
                // invoking MTA server, sometimes the server won't shut down.
                // There might be a race condition between here and
                // CStdMarshal::UnlockServer, but I can't think of how this
                // could happen in real world.  So, adding an assert (rongc)

                _fNoOtherThreadInDisconnect = FALSE;
#endif

                // We dont allow disconnect to occur inside a nested call since we
                // dont want state to vanish in the middle of a call, but we do
                // remember that we want to disconnect and will do it when the
                // stack unwinds (or other threads complete).

                Win4Assert(dwType != DISCTYPE_UNINIT);

                if (!(_dwFlags & SMFLAGS_PENDINGDISCONNECT))
                {
                    SetPendingDisconnectType(dwType);
                }

                ComDebOut((DEB_MARSHAL,"CStdMarshal::Disconnect [pending]:%x\n",this));
#if DBG==1
                _fNoOtherThreadInDisconnect = TRUE;
#endif
            }
            else
            {
                // No calls in progress and not fully disconnected, OK to really
                // disconnect now. First mark ourself as disconnected
                _dwFlags &= ~(SMFLAGS_PENDINGDISCONNECT |
                              SMFLAGS_APPDISCONNECT     |
                              SMFLAGS_SYSDISCONNECT     |
                              SMFLAGS_RUNDOWNDISCONNECT |
                              SMFLAGS_TRIEDTOCONNECT);
                _dwFlags |= SMFLAGS_DISCONNECTED;
                fDisconnectedNow = TRUE;

                // Sanity check
                Win4Assert(ServerObjectCallable() == NULL);

                if (fLogEventIsActive)
                {
                    // save the MIDEntry for logging later.
                    pMIDEntry = _pChnl->GetOXIDEntry()->GetMIDEntry();
                }

                if (ServerSide())
                {
                    // turn on the FirstMarshal flag so we execute the FirstMarshal
                    // method if we are asked to marshal again.
                    _dwFlags |= SMFLAGS_FIRSTMARSHAL;

                    if (_pStdId->IsAggregated())
                    {
                        // aggregated server side, mark as not disconnected
                        // so we are back in the original state
                        _dwFlags &= ~SMFLAGS_DISCONNECTED;
                    }

                    // Remember the channel pointer for release after we've
                    // released the lock. NULL the member variable.
                    pChnl  = _pChnl;
                    _pChnl = NULL;
                }
            }
        }

        ASSERT_LOCK_NOT_HELD(gComLock);

        if (fDisconnectedNow)
        {
            // Disconnect all IPIDs.
            // Don't hold gComLock over these calls, but do hold gIPIDLock.
            if (ServerSide())
            {
                DisconnectSrvIPIDs(dwType);
            }
            else
            {
                DisconnectCliIPIDs();
            }
        }
    }
    else
    {
        // Already fully disconnected.
        ComDebOut((DEB_MARSHAL,"CStdMarshal::Disconnect [already done]:%x\n",this));
    }

    // Cleanup rest of the state
    CtxEntry    *pCtxEntryHead = NULL;
    CPolicySet  *pPS           = NULL;
    CIDObject   *pID           = NULL;

    if (((_dwFlags & SMFLAGS_CLEANEDUP) == 0) &&
        ((dwType & (DISCTYPE_UNINIT | DISCTYPE_RELEASE)) ||
        (ServerSide() && !_pStdId->IsAggregated() &&
         (_dwFlags & SMFLAGS_DISCONNECTED))))
    {
        // Save IDObject for later release
        pID = _pID;
        _pID = NULL;

        // Sanity checks
        Win4Assert(ClientSide() || (_pCtxEntryHead == NULL));
        Win4Assert(ServerSide() || (_pPS == NULL));

        // Save policy set for later release
        pPS  = _pPS;
        _pPS = NULL;

        // Save context entries for later release
        pCtxEntryHead = _pCtxEntryHead;

        _dwFlags |= SMFLAGS_CLEANEDUP;
    }

    // Release the lock
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Release the channel if needed
    if (pChnl)
        pChnl->Release();

    // Release policy set if needed
    if (pPS)
        pPS->Release();

    // Release context entries if needed
    if (pCtxEntryHead)
        CtxEntry::PrepareCtxEntries(pCtxEntryHead, (CTXENTRYFLAG_IDENTRY | CTXENTRYFLAG_STDID));

    // Release IDObject if needed
    if (pID)
    {
        ReleaseIDObject(pID);
    }

        // dont release the real object's m_pUnkControl if the server side
        // marshaler has been aggregated into the real object
    if (fDisconnectedNow && ServerSide() && !_pStdId->IsAggregated())
    {
       // HACK - 16 and 32 bit Word 6.0 crash if you release all the objects
       // it left lying around at CoUninitialize.  Leak them.
       
       // If we are not uninitializing, then call the release.
       // If we are in WOW and the app is not word, then call the release.
       // If the app is not 32 bit word, then call the release.
       if((dwType != DISCTYPE_UNINIT) ||
	  (IsWOWThread() && (g_pOleThunkWOW->GetAppCompatibilityFlags() & OACF_NO_UNINIT_CLEANUP) == 0) ||
	  !IsTaskName(L"winword.exe"))
       {
	  // on the server side, we have to tell the stdid to release his
	  // controlling unknown of the real object.
	  _pStdId->ReleaseCtrlUnk();
       }
    }
    
    // if there are no external clients, this process should terminate
    // if its a surrogate process
    if (fDisconnectedNow && ServerSide() && !_pStdId->IsIgnoringOID())
    {
       FreeSurrogateIfNecessary();
    }

    if (fLogEventIsActive && fDisconnectedNow)
    {
        REFMOID rmoid = _pStdId->GetOID();
        LogEventDisconnect(&rmoid, pMIDEntry, ServerSide());
    }
	
    if (pMIDEntry)
    {
        pMIDEntry->DecRefCnt();
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,"CStdMarshal::Disconnect [complete]:%x\n",this));
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ReleaseIDObject, private
//
//  Synopsis:   If we still have an IDObject, release it.
//
//  Arguements: [pID] - IDObject to release.
//
//  History:    30-Apr-98   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::ReleaseIDObject(CIDObject *pID)
{
    // Deliver the DestoryIdentity events since we have not
    // already done so, and Release the IDObject.
    ENTER_NA_IF_NECESSARY();

    if (ServerSide())
    {
        if (!(_dwFlags & SMFLAGS_NOPING))
        {
            // return the OID to the resolver.
            FreePreRegMOID(_pStdId->GetOID());
        }
    }

    pID->StdIDRelease();
    pID->Release();
    LEAVE_NA_IF_NECESSARY();
}

//+-------------------------------------------------------------------
//
//  Method:     CStdMarshal::Deactivate    private
//
//  Synopsis:   Releases all the references on the server object as part
//              of deactivating the server
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdMarshal::Deactivate()
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::Deactivate this:%x\n", this));

    typedef struct tagServerRefs
    {
        IRpcStubBuffer *pRpcStub;
        void           *pServer;
    } ServerRefs;

    // Sanity checks
    Win4Assert(_pID->GetServerCtx() == GetCurrentContext());
    Win4Assert(!Deactivated());

    // Allocate space on the stack to save references on the server
    // alloca does not return if it could not grow the stack. Note that
    // _cIPIDs cannot change for a deactivated object, so it is safe
    // to do this without holding the lock
    ServerRefs *pServerRefs = (ServerRefs *) _alloca(_cIPIDs*sizeof(ServerRefs));
    Win4Assert(pServerRefs);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // mark object as deactivated.
    _dwFlags |= SMFLAGS_DEACTIVATED;

    // Save the reference held on the server by the StdId
    IUnknown *pServer = _pStdId->ResetServer();
    Win4Assert(pServer);

    // Save references held on the server by IPID entires
    ULONG cIPIDs = 0; 

    IPIDEntry *pNextIPID = _pFirstIPID;
    while (pNextIPID)
    {
        if (!(pNextIPID->dwFlags & IPIDF_DISCONNECTED))
        {
            // Sanity check
            Win4Assert(pNextIPID->pv);
            if (pNextIPID->pStub)
            {
                pServerRefs[cIPIDs].pRpcStub = (IRpcStubBuffer *) pNextIPID->pStub;
                pServerRefs[cIPIDs].pServer  = pNextIPID->pv;
                cIPIDs++;
            }
            else
            {
                Win4Assert(IsEqualIID(pNextIPID->iid, IID_IUnknown));
            }
        }

        // Reset interface pointer on the server object held by the IPID
        pNextIPID->pv = NULL;

        // Mark the IPID as deactivated
        pNextIPID->dwFlags |= IPIDF_DEACTIVATED;
        pNextIPID = pNextIPID->pNextIPID;
    }

    // Release lock before calling app code
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Release reference held on the server by the StdID
    pServer->Release();

    // Release references held on the server by IPID entries
    for (ULONG i=0; i<cIPIDs; i++)
    {
        if (pServerRefs[i].pRpcStub)
            pServerRefs[i].pRpcStub->Disconnect();

        if (pServerRefs[i].pServer)
            ((IUnknown *) pServerRefs[i].pServer)->Release();
    }

    ComDebOut((DEB_MARSHAL,"CStdMarshal::Deactivate this:%x hr:%x\n",
               this, S_OK));
}

//+-------------------------------------------------------------------
//
//  Method:     CStdMarshal::Reactivate    private
//
//  Synopsis:   Acquires the needed references on the server object
//              as part of reactivating the server
//
//  Arguements: [pServer] - ptr to server object to connect to.
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CStdMarshal::Reactivate(IUnknown *pServer)
{
    ContextDebugOut((DEB_WRAPPER, "CStdWrapper::Reactivate this:%x\n", this));

    typedef struct tagServerRefs
    {
        IRpcStubBuffer *pRpcStub;
        void          **ppServer;
        IID            *pIID;
    } ServerRefs;

    // Sanity checks
    Win4Assert(_pID->GetServerCtx() == GetCurrentContext());
    Win4Assert(Deactivated());

    // Allocate space on the stack to save references on the server
    // alloca does not return if it could not grow the stack. Note that
    // _cIPIDs cannot change for a deactivated object, so it is safe
    // to do this without holding the lock
    ServerRefs *pServerRefs = (ServerRefs *) _alloca(_cIPIDs*sizeof(ServerRefs));
    Win4Assert(pServerRefs);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Update state to indicate no longer deactivated.
    _dwFlags &= ~SMFLAGS_DEACTIVATED;

    // Init the reference held on the server by the StdID
    _pStdId->SetServer(pServer);

    // Obtain references held on the server by IFaceEntries
    ULONG cIPIDs = 0;
    IPIDEntry *pNextIPID = _pFirstIPID;
    while (pNextIPID)
    {
        // Sanity checks
        Win4Assert(pNextIPID->pv == NULL);
        if (!(pNextIPID->dwFlags & IPIDF_DISCONNECTED))
        {
            if (pNextIPID->pStub)
            {
                pServerRefs[cIPIDs].pRpcStub = (IRpcStubBuffer *) pNextIPID->pStub;
                pServerRefs[cIPIDs].ppServer = &pNextIPID->pv;
                pServerRefs[cIPIDs].pIID     = &pNextIPID->iid;
                cIPIDs++;
            }
            else
            {
                Win4Assert(IsEqualIID(pNextIPID->iid, IID_IUnknown));
                pNextIPID->pv = pServer;
            }
        }

        // Mark the IPID as reactivated
        pNextIPID->dwFlags &= ~IPIDF_DEACTIVATED;
        pNextIPID = pNextIPID->pNextIPID;
    }

    // Release lock before calling app code
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // AddRef server on behalf of StdID
    pServer->AddRef();

    // Reconnect IPID entries to server
    for (ULONG i=0; i<cIPIDs; i++)
    {
        pServer->QueryInterface(*pServerRefs[i].pIID, pServerRefs[i].ppServer);

        if (*pServerRefs[i].ppServer)
            pServerRefs[i].pRpcStub->Connect((IUnknown *) (*pServerRefs[i].ppServer));
    }

    ComDebOut((DEB_MARSHAL,"CStdMarshal::Reactivate this:%x hr:%x\n",
               this, S_OK));
}

#define IPID_RELEASE_SET_SIZE 1000

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DisconnectCliIPIDs
//
//  Synopsis:   disconnects client side IPIDs for this object.
//
//  History:    20-Feb-95   Rickhi  Created.
//              24-Jan-97   Gopalk  Follow aggregation rules for releasing
//                                  interface pointers on proxies
//                                  Also reset the connection status
//                                  maintained by StdId
//
//--------------------------------------------------------------------
void CStdMarshal::DisconnectCliIPIDs()
{
    ComDebOut((DEB_MARSHAL,"CStdMarshal::DisconnectCliIPIDs this:%x pFirst:%x\n",
               this, _pFirstIPID));
    Win4Assert(ClientSide());
    Win4Assert(_dwFlags & SMFLAGS_DISCONNECTED);

    // YIELD WARNING: Do not yield between here and the matching comment
    // below, since we are mucking with internal state that could get
    // messed up if a reconnect (or unmarshal) is done.

    ASSERT_LOCK_HELD(gIPIDLock);

    if (_dwFlags & SMFLAGS_REGISTEREDOID)
    {
        // Tell the resolver to stop pinging the OID. The OID is only
        // registered on the client side.

        Win4Assert(ClientSide());
        gROIDTbl.ClientDeRegisterOIDFromPingServer(_pRefCache,
                                                   _dwFlags & SMFLAGS_CLIENTMARSHALED);
    }

    // turn these flags off so re-connect (with new OID) will behave properly.
    _dwFlags &= ~(SMFLAGS_CLIENTMARSHALED | SMFLAGS_REGISTEREDOID |
                  SMFLAGS_NOPING);


    // on client side, we cant actually release the proxies until the
    // object goes away (backward compatibility), so we just release
    // our references to the remote guy, disconnect the proxies, and
    // delete the channels, but hold on to the IPIDEntries.

    // We must break this up into chunks because if we do it all at once,
    // we may have to make a huge allocation which could fail. Or the
    // huge alloc might succeed but blow up the stack in the server because
    // the same huge number of REMINTERFACEREFs have to get allocated on the
    // servers stack for the call to RemRelease.

    typedef struct _IPIDReleaseSet
    {
        USHORT           cRifRef;
        REMINTERFACEREF *pRifRef;
    } IPIDReleaseSet;

    // Calculate the number of IPIDs we have to disconnect and the number
    // of sets we need to break the operation up into.
    ULONG cIPIDs = (_cIPIDs + (_pRefCache ? _pRefCache->NumIRCs() : 0)) * 2;
    ULONG cSets  = cIPIDs / IPID_RELEASE_SET_SIZE + 1;

    USHORT       cOxidRefs  = 0;
    USHORT       cChnlRefs  = 0;
    OXIDEntry   *pOXIDEntry = NULL;
    CCtxComChnl *pChnl      = NULL;
    IPIDEntry   *pIPIDEntry = _pFirstIPID;
    USHORT       cRifRef    = 0;
    ULONG        cValidSets = 0;

    // Allocate an array of pointers to IPIDReleaseSets.
    IPIDReleaseSet* pSets = (IPIDReleaseSet*)PrivMemAlloc(cSets * sizeof(IPIDReleaseSet));

    // Allocate the entire array of pointers to channel objects.  This may
    // be a large allocation, but we may as well do it up front since there
    // are no inherent problems with a large array of these, and the fewer
    // times we have to go to the heap the better.
    CCtxComChnl** arChnl = (CCtxComChnl**)PrivMemAlloc(cIPIDs * sizeof(CCtxComChnl*));

    // Iterate through the sets, disconnecting IPIDs and saving necessary
    // state to do RemRelease later.
    for( ULONG SetIdx = 0; SetIdx < cSets && pIPIDEntry; SetIdx++ )
    {
        // Specify how many IPIDs in this set.
        ULONG cCurSet = (cIPIDs < IPID_RELEASE_SET_SIZE) ? cIPIDs : IPID_RELEASE_SET_SIZE;

        // Update the number of IPIDs remaining.
        cIPIDs -= cCurSet;

        // Init the pointer to the first RifRef and pointer to the
        // number of RifRefs.
        REMINTERFACEREF* pRifRef  = NULL;
        USHORT*          pcRifRef = &cRifRef;

        // If array of pointers was allocated ok, allocate a block of
        // REMINTERFACEREFs and initialize a pointer to the first one
        // in the block.
        if( pSets )
        {
            pSets[SetIdx].pRifRef = (REMINTERFACEREF*) PrivMemAlloc( cCurSet * sizeof(REMINTERFACEREF) );
            pSets[SetIdx].cRifRef = 0;

            pRifRef  =  pSets[SetIdx].pRifRef;
            pcRifRef = &pSets[SetIdx].cRifRef;

            // Increment the number of valid sets.
            ++cValidSets;
        }

        while (cCurSet-- > 0 && pIPIDEntry)
        {
            // we have to handle the case where ConnectCliIPIDEntry partially (but
            // not completely) set up the IPIDEntry, hence we cant just check
            // for the IPIDF_DISCONNECTED flag.

            ValidateIPIDEntry(pIPIDEntry);


            // NOTE: we are calling Proxy code here while holding the ORPC LOCK.
            // There is no way to get around this without introducing race
            // conditions.  We cant just disconnect the channel and leave the
            // proxy connected cause some proxies (like IDispatch) do weird stuff,
            // like keeping separate pointers to the server.

            if (pIPIDEntry->pStub)      // NULL for IUnknown IPID
            {
                ComDebOut((DEB_MARSHAL, "Disconnect pProxy:%x\n", pIPIDEntry->pStub));

                if (pIPIDEntry->pv != NULL)
                {
                    // AddRef the controling unknown and release the interface
                    // pointer of the proxy
                    _pStdId->GetCtrlUnk()->AddRef();
                    ((IUnknown *) pIPIDEntry->pv)->Release();
                    pIPIDEntry->pv = NULL;
                }

                // Disconnect the proxy from channel
                ((IRpcProxyBuffer *)pIPIDEntry->pStub)->Disconnect();
            }

            if (!(pIPIDEntry->dwFlags & IPIDF_NOPING))
            {
                // release remote references to the reference cache. If this is
                // the last reference for the cache, we may be asked to do the
                // remote release, and pRifRef will be updated to reflect that.
                if (_pRefCache)
                {
                    _pRefCache->ReleaseIPIDEntry(pIPIDEntry, &pRifRef, pcRifRef);
                }
            }

            pIPIDEntry->dwFlags |= IPIDF_DISCONNECTED | IPIDF_NOPING;

            if (pIPIDEntry->pChnl)
            {
                // Release the channel for this IPID. We dont want to release the
                // RefCnt on the channel yet cause we are holding the lock, so just
                // remember the pointer and release it below.
                if( arChnl )
                {
                    arChnl[cChnlRefs] = pIPIDEntry->pChnl;
                    cChnlRefs++;
                }
                pIPIDEntry->pChnl = NULL;
            }

            if (pIPIDEntry->pOXIDEntry)
            {
                // If we ever go to a model where different IPIDEntries on the
                // same object can point to different OXIDEntires, then we need
                // to re-write this code to batch the releases by OXID.
                Win4Assert(!pOXIDEntry || (pOXIDEntry == pIPIDEntry->pOXIDEntry));

                // we can't release the RefCnt on the OXIDEntry cause we are
                // holding the lock, so just remember we need to release one
                // more reference.
                cOxidRefs++;
                pOXIDEntry = pIPIDEntry->pOXIDEntry;
                pIPIDEntry->pOXIDEntry = NULL;
            }

            // get next IPID in chain for this object
            pIPIDEntry = pIPIDEntry->pNextIPID;
        }
    }

    // Remember the channel for release later (after we release the lock)
    // and NULL the member variable.
    pChnl = _pChnl;
    _pChnl = NULL;

    // As we could be reconnected to a different server,
    // reset connection status maintained by StdId
    _pStdId->SetConnectionStatus(S_OK);

    if (_pRefCache)
    {
        // release the RefCache entry
        _pRefCache->DecRefCnt();
        _pRefCache = NULL;
    }

    // YIELD WARNING: Up this this point we have been mucking with our
    // internal state. We cant yield before this point or a reconnect
    // proxies could get all messed up. It is OK to yield after this point
    // because all internal state changes are now complete.

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (NULL != pSets)
    {
        for (ULONG SetIdx = 0; SetIdx < cValidSets; SetIdx++)
        {
            if (pSets[SetIdx].cRifRef != 0)
            {
                // we have looped filling in the RifRef and entries exist in the
                // array. go call the server now to release the IPIDs.

                Win4Assert(pOXIDEntry);  // must have been at least one
                Win4Assert(pSets[SetIdx].pRifRef);
                RemoteReleaseRifRef(this,
                                    pOXIDEntry,
                                    pSets[SetIdx].cRifRef,
                                    pSets[SetIdx].pRifRef);
            }
        }
    }

    while (cOxidRefs > 0)
    {
        // Now release the OXIDEntry refcnts (if any) from above
        pOXIDEntry->DecRefCnt();
        cOxidRefs--;
    }

    while (cChnlRefs > 0)
    {
        // Now release the Channel refcnts (if any) from above
        cChnlRefs--;
        arChnl[cChnlRefs]->Release();
    }

    if (pChnl)
        // release the last client side channel
        pChnl->Release();

    // Release memory we allocated.
    if ( NULL != pSets )
    {
        for( ULONG SetIdx = 0; SetIdx < cValidSets; SetIdx++ )
        {
            if( pSets[SetIdx].pRifRef )
            {
                PrivMemFree( pSets[SetIdx].pRifRef );
            }
        }
        PrivMemFree( pSets );
    }
    if ( arChnl )
        PrivMemFree( arChnl );

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    DbgWalkIPIDs();
    ComDebOut((DEB_MARSHAL, "CStdMarshal::DisconnectCliIPIDs this:%x\n",this));
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DisconnectSrvIPIDs
//
//  Synopsis:   disconnects the server side IPIDs for this object.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::DisconnectSrvIPIDs(DWORD dwType)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::DisconnectSrvIPIDs this:%x pFirst:%x\n",this, _pFirstIPID));
    Win4Assert(ServerSide());

    // there should be no other threads looking at these IPIDs at this time,
    // since Marshal, Unmarshal, and Dispatch all call PreventDisconnect,
    // Disconnect checks the disconnected flag directly, RMD holds the
    // lock over it's whole execution, RemAddRef and RemRelease hold the
    // lock and check the disconnected flag of the IPIDEntry, and
    // RemQueryInterface calls PreventDisconnect.

    Win4Assert((_dwFlags & SMFLAGS_DISCONNECTED) || _pStdId->IsAggregated());
    Win4Assert(_cNestedCalls == 0);
    ASSERT_LOCK_HELD(gIPIDLock);

    if (_pFirstIPID == NULL)
    {
        // nothing to do
        return;
    }

    // allocate memory on stack to hold the stub and interface ptrs
    IPIDTmp *pTmpAlloc = (IPIDTmp *)_alloca(_cIPIDs * sizeof(IPIDTmp));
    IPIDTmp *pTmp = pTmpAlloc;
    ULONG    cTmp = 0;

    // while holding the lock, flag each IPID as disconnected so that no
    // more incoming calls are dispatched to this object. We also unchain
    // the IPIDs to ensure that no other threads are pointing at them, and
    // we save off the important fields so we can cleanup while not holding
    // the lock.

    IPIDEntry *pNextIPID = _pFirstIPID;
    while (pNextIPID)
    {
        if (!(pNextIPID->dwFlags & IPIDF_DISCONNECTED))
        {
            // copy fields to temp structure and zero them out in the IPIDEntry
            memcpy(pTmp, (void *)&pNextIPID->dwFlags, sizeof(IPIDTmp));
            memset((void *)&pNextIPID->dwFlags, 0, sizeof(IPIDTmp));

            pNextIPID->dwFlags |= IPIDF_DISCONNECTED | IPIDF_SERVERENTRY;
            pNextIPID->pChnl    = NULL;

            pTmp++;
            cTmp++;
        }

        // move ahead to next IPIDEntry
        pNextIPID = pNextIPID->pNextIPID;
    }


    // now release the LOCK since we will be calling into app code to
    // disconnect the stubs, and to release the external connection counts.
    // There should be no other pointers to these IPIDEntries now, so it
    // is safe to muck with their fields (except the dwFlags which is looked
    // at by Dispatch and was already set above).

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    pTmp = pTmpAlloc;
    while (cTmp > 0)
    {
        if (pTmp->dwFlags & IPIDF_NOTIFYACT)
        {
            // the activation code asked to be notified when the refcnt
            // on this interface reaches zero.
            NotifyActivation(FALSE, (IUnknown *)(pTmp->pv));
        }

        if (pTmp->pStub)           // pStub is NULL for IUnknown IPID
        {
            // disconnect the stub
            ComDebOut((DEB_MARSHAL, "Disconnect pStub:%x\n", pTmp->pStub));
            if (pTmp->pv)
            {
                ((IUnknown *)pTmp->pv)->Release();
                ((IRpcStubBuffer *)pTmp->pStub)->Disconnect();
            }
            else
            {
                Win4Assert(pTmp->dwFlags & IPIDF_DEACTIVATED);
            }
            pTmp->pStub->Release();
        }

        if (pTmp->cWeakRefs > 0)
        {
            // Release weak references on the StdId.
            _pStdId->DecWeakCnt(TRUE);      // fKeepAlive
        }

        if (pTmp->cStrongRefs > 0)
        {
            // Release strong references on the StdId.
            // 16bit OLE always passed fLastReleaseCloses = FALSE in DisconnectObject. We
            // do the same here. For Rundowns, we pass fLastReleaseCloses = TRUE because we
            // want the object to go away.

            _pStdId->DecStrongCnt(dwType != DISCTYPE_RUNDOWN);    // fKeepAlive
        }

        if (pTmp->cPrivateRefs > 0)
        {
            // Release private references on the StdId.
            // 16bit OLE always passed fLastReleaseCloses = FALSE in DisconnectObject. We
            // do the same here. For Rundowns, we pass fLastReleaseCloses = TRUE because we
            // want the object to go away.

            _pStdId->DecStrongCnt(dwType != DISCTYPE_RUNDOWN);    // fKeepAlive
        }

        if (pTmp->pOXIDEntry)
        {
            // release the refcnt on the OXIDEntry and NULL it
            // This could be NULL here on a failure during the first
            // marshal so we checked that first.
            pTmp->pOXIDEntry->DecRefCnt();
        }

        // move ahead to next temp entry
        pTmp++;
        cTmp--;
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    DbgWalkIPIDs();
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::DisconnectSrvIPIDs [OUT] this:%x\n",this));
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::InstantiatedProxy, public
//
//  Synopsis:   return requested interfaces to the caller if instantiated
//
//  Arguements: [riid]  - interface IID we are looking for
//              [ppv]   - where to return the proxy if found
//              [phr]   - return code
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
BOOL CStdMarshal::InstantiatedProxy(REFIID riid, void **ppv, HRESULT *phr)
{
    ComDebOut((DEB_MARSHAL,
           "CStdMarshal::InstantiatedProxy this:%x riid:%I ppv:%x\n",
            this, &riid, ppv));
    AssertValid();
    Win4Assert(ClientSide());
    Win4Assert(*ppv == NULL);
    Win4Assert(*phr == S_OK);

    BOOL fRet = FALSE;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // look for an existing IPIDEntry for the requested interface
    IPIDEntry *pEntry;
    HRESULT hr = FindIPIDEntryByIID(riid, &pEntry);

    if (SUCCEEDED(hr) && pEntry->pv)
    {
        // found the ipid entry, now extract the interface
        // pointer to return to the caller.

        Win4Assert(IsValidInterface(pEntry->pv));
        *ppv = pEntry->pv;
        fRet = TRUE;
    }
    else if (_cIPIDs == 0)
    {
        // no IPIDEntry for the requested interface, and we have never
        // been connected to the server. Return E_NOINTERFACE in this
        // case. This is different from having been connected then
        // disconnected, where we return CO_E_OBJNOTCONNECTED.

        *phr = E_NOINTERFACE;
        Win4Assert(fRet == FALSE);
    }
    else if (_dwFlags & SMFLAGS_PENDINGDISCONNECT)
    {
        // no IPIDEntry for the requested interface and disconnect is
        // pending, so return an error.

        *phr = CO_E_OBJNOTCONNECTED;
        Win4Assert(fRet == FALSE);
    }
    else
    {
        // no IPIDEntry, we are not disconnected, and we do have other
        // instantiated proxies. QueryMultipleInterfaces expects
        // *phr == S_OK and FALSE returned.

        Win4Assert(*phr == S_OK);
        Win4Assert(fRet == FALSE);
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
      "CStdMarshal::InstantiatedProxy hr:%x pv:%x fRet:%x\n", *phr, *ppv, fRet));
    return fRet;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::QueryRemoteInterfaces, public
//
//  Synopsis:   return requested interfaces to the caller if supported
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::QueryRemoteInterfaces(USHORT cIIDs, IID *pIIDs, SQIResult *pQIRes)
{
    ComDebOut((DEB_CHANNEL, "CStdMarshal::QueryRemoteInterfaces IN "
               "cIIDs:%d, pIIDs:%I, pQIRes:0x%x\n", cIIDs, pIIDs, pQIRes));

    QICONTEXT *pQIC = (QICONTEXT *) _alloca(QICONTEXT::SIZE(this, cIIDs));
    pQIC->Init(cIIDs);

    Begin_QueryRemoteInterfaces(cIIDs, pIIDs, pQIC);
    HRESULT hr =  Finish_QueryRemoteInterfaces(pQIRes, pQIC);

    ComDebOut((DEB_CHANNEL, "CStdMarshal::QueryRemoteInterfaces OUT hr:0x%x\n", hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Begin_QueryRemoteInterfaces
//
//  Synopsis:      Set up for an async remote QI.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
void CStdMarshal::Begin_QueryRemoteInterfaces(USHORT cIIDs, IID *pIIDs, QICONTEXT *pQIC)
{
    ComDebOut((DEB_MARSHAL,
           "CStdMarshal::QueryRemoteInterfaces this:%x pIIDs:%x pQIC:%x\n",
            this, pIIDs, pQIC));
    AssertValid();
    Win4Assert(ClientSide());
    Win4Assert(cIIDs > 0);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    HRESULT hr = PreventDisconnect();

    if (SUCCEEDED(hr))
    {
        // call QI on the remote guy and unmarshal the results
        // NOTE: this will return with the lock released
        ASSERT_LOCK_HELD(gIPIDLock);
        Begin_RemQIAndUnmarshal(cIIDs, pIIDs, pQIC);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }
    else
    {
        // already disconnected
        ASSERT_LOCK_HELD(gIPIDLock);
        UNLOCK(gIPIDLock);
        pQIC->dwFlags |= QIC_DISCONNECTED;
        pQIC->hr = hr;
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
 }

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Finish_QueryRemoteInterfaces
//
//  Synopsis:      Complete async remote qi.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CStdMarshal::Finish_QueryRemoteInterfaces(SQIResult *pQIRes, QICONTEXT *pQIC)
{
    HRESULT hr = S_OK;
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (pQIC->dwFlags & QIC_DISCONNECTED)
    {
        // cant call out because we're disconnected so return error for
        // each requested interface.
        for (USHORT i=0; i<pQIC->cIIDs; i++, pQIRes++)
        {
            pQIRes->hr = pQIC->hr;
        }
    }
    else
    {
        // NOTE: this rotine should be entered without a lock and will
        // leave with the lock taken.
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        hr = Finish_RemQIAndUnmarshal(pQIRes, pQIC);
        ASSERT_LOCK_HELD(gIPIDLock);
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // if the object was disconnected while in the middle of the call,
    // then we still return SUCCESS for any interfaces we acquired. The
    // reason is that we do have the proxies, and this matches the
    // behaviour of a QI for an instantiated proxy on a disconnected
    // object.

    hr = HandlePendingDisconnect(hr);

    ComDebOut((DEB_MARSHAL,
       "CStdMarshal::QueryRemoteInterfaces this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::RemQIAndUnmarshal, private
//
//  Synopsis:   call QI on remote guy, then unmarshal the STDOBJREF
//              to create the IPID, and return the interface ptr.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//  Notes:      Caller must guarantee at least one IPIDEntry is connected.
//              This function does a sparse fill of the result array.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::RemQIAndUnmarshal(USHORT cIIDs, IID *pIIDs, SQIResult *pQIRes)
{
    ComDebOut((DEB_CHANNEL, "CStdMarshal::RemQIAndUnmarshal IN cIIDs:%d, pIIDs:%I, pQIRes:0x%x\n",
                cIIDs, pIIDs, pQIRes));

    QICONTEXT *pQIC = (QICONTEXT *) PrivMemAlloc(QICONTEXT::SIZE(this, cIIDs));
    pQIC->Init(cIIDs);

    ASSERT_LOCK_HELD(gIPIDLock);
    Begin_RemQIAndUnmarshal(cIIDs, pIIDs, pQIC);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    HRESULT hr = Finish_RemQIAndUnmarshal(pQIRes, pQIC);
    ASSERT_LOCK_HELD(gIPIDLock);

    PrivMemFree(pQIC);

    ComDebOut((DEB_CHANNEL, "CStdMarshal::RemQIAndUnmarshal OUT hr:0x%x\n", hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Begin_RemQIAndUnmarshal
//
//  Synopsis:      Dispatch to correct fuction based on aggregation
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
void CStdMarshal::Begin_RemQIAndUnmarshal(USHORT cIIDs, IID *pIIDs, QICONTEXT *pQIC)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    if (_dwFlags & SMFLAGS_USEAGGSTDMARSHAL)
    {
        // remote object uses IRemUnknown2.
        Begin_RemQIAndUnmarshal2(cIIDs, pIIDs, pQIC);
    }
    else
    {
        // remote object uses IRemUnknown
        Begin_RemQIAndUnmarshal1(cIIDs, pIIDs, pQIC);
    }
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Finish_RemQIAndUnmarshal
//
//  Synopsis:      Dispatch to correct fuction based on aggregation
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CStdMarshal::Finish_RemQIAndUnmarshal(SQIResult *pQIRes, QICONTEXT *pQIC)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    if (_dwFlags & SMFLAGS_USEAGGSTDMARSHAL)
    {
        // remote object uses IRemUnknown2.
        hr =  Finish_RemQIAndUnmarshal2(pQIRes, pQIC);
    }
    else
    {
        // remote object uses IRemUnknown.
        hr =  Finish_RemQIAndUnmarshal1(pQIRes, pQIC);
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::Begin_RemQIAndUnmarshal1, private
//
//  Synopsis:   call QI on remote guy
//
//  History:    20-Feb-95   Rickhi      Created.
//
//  Notes:      Caller must guarantee at least one IPIDEntry is connected.
//              This function does a sparse fill of the result array.
//
//              This routine leaves the lock released as a side effect
//
//--------------------------------------------------------------------
void CStdMarshal::Begin_RemQIAndUnmarshal1(USHORT cIIDs, IID *pIIDs, QICONTEXT* pQIC)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::RemQIAndUnmarshal1 this:%x cIIDs:%x pIIDs:%x pQIC:%x\n",
            this, cIIDs, pIIDs, pQIC));
    AssertDisconnectPrevented();
    AssertValid();
    Win4Assert(_pFirstIPID);    // must be at least 1 IPIDEntry
    ASSERT_LOCK_HELD(gIPIDLock);

    // we need an IPID to call RemoteQueryInterface with, any one will
    // do so long as it is connected (in the reconnect case there may be
    // only one connected IPID) so we pick the first one in the chain that
    // is connected.

    IPIDEntry *pIPIDEntry = GetConnectedIPID();
    IPID ipid = pIPIDEntry->ipid;

    // remember what type of reference to get since we yield the lock
    // and cant rely on _dwFlags later.
    BOOL fWeakClient = (_dwFlags & SMFLAGS_WEAKCLIENT);

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // set the IPID according to whether we want strong or weak
    // references. It will only be weak if we are an OLE container
    // and are talking to an embedding running on the same machine.

    if (fWeakClient)
    {
        ipid.Data1    |= IPIDFLAG_WEAKREF;
        pQIC->dwFlags |= QIC_WEAKCLIENT;
    }

    pQIC->pIIDs = pIIDs;
    pQIC->pIPIDEntry = pIPIDEntry;

    // call the remote guy

    IRemUnknown *pRemUnk;
    HRESULT hr = GetSecureRemUnk( &pRemUnk, pIPIDEntry->pOXIDEntry );
    if (SUCCEEDED(hr))
    {
        Win4Assert(pIPIDEntry->pOXIDEntry);     // must have a resolved oxid

        if (pQIC->dwFlags & QIC_ASYNC)
        {
            // call is to be made asyncrounously
            // make the async call out
            hr = pQIC->pARU->Begin_RemQueryInterface(ipid, REM_ADDREF_CNT, cIIDs, pIIDs);
            pQIC->dwFlags |= QIC_BEGINCALLED;
        }
        else
        {
            // call is synchronous
            hr = pRemUnk->RemQueryInterface(ipid, REM_ADDREF_CNT,cIIDs, pIIDs, &(pQIC->pRemQiRes));
        }
    }

    pQIC->hr = hr;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_CHANNEL, "CStdMarshal::Begin_RemQIAndUnmarshal1 OUT hr:0x%x\n", hr));
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Finish_RemQIAndUnmarshal1
//
//  Synopsis:      unmarshal the STDOBJREF to create the IPID, and return
//                 the interface ptr.
//
//  History:       23-Jan-98  MattSmit  Created
//
//  Notes:         This routine leaves the lock taken as a side effect
//
//-----------------------------------------------------------------------------
HRESULT CStdMarshal::Finish_RemQIAndUnmarshal1(SQIResult *pQIRes, QICONTEXT *pQIC)
{
    ComDebOut((DEB_CHANNEL, "CStdMarshal::Finish_RemQIAndUnmarshal1 IN "
               "pQIRes:0x%x, pQIC:0x%x\n", pQIRes, pQIC));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    USHORT cIIDs = pQIC->cIIDs;
    if (pQIC->dwFlags & QIC_STATICMARSHAL)
    {
        if (pQIRes)
        {
            for (USHORT i=0; i<cIIDs; i++)
            {
                pQIRes[i].pv = NULL;
                pQIRes[i].hr = E_PENDING;   // Not E_NOINTERFACE
            }
        }

        LOCK(gIPIDLock);
        return E_PENDING;
    }

    HRESULT hr;

    if ((pQIC->dwFlags & QIC_ASYNC) && (pQIC->dwFlags & QIC_BEGINCALLED))
    {
        // complete async call
        hr = pQIC->pARU->Finish_RemQueryInterface(&(pQIC->pRemQiRes));
        pQIC->pARU = NULL;
    }
    else
    {
        // get results of sync call
        hr = pQIC->hr;
    }


    // need to remember the result ptr so we can free it.
    REMQIRESULT *pRemQiResNext = pQIC->pRemQiRes;

    // unmarshal each STDOBJREF returned. Note that while we did the
    // RemoteQI we could have yielded (or nested) and did another
    // RemoteQI for the same interfaces, so we have to call UnmarshalIPID
    // which will find any existing IPIDEntry and bump its refcnt.

    HRESULT   hr2 = hr;
    HRESULT  *phr = &hr2;
    void     *pv  = NULL;
    void     **ppv = &pv;
    IID      *pIIDs = pQIC->pIIDs;

    for (USHORT i=0; i<cIIDs; i++)
    {
        if (pQIRes)
        {
            // caller wants the pointers returned, set ppv and phr.
            ppv = &pQIRes->pv;
            phr = &pQIRes->hr;
            pQIRes++;
        }

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(pRemQiResNext->hResult))
            {
                if (pQIC->dwFlags & QIC_WEAKCLIENT)
                {
                    // mark the std objref with the weak reference flag so
                    // that UnmarshalIPID adds the references to the correct
                    // count.
                    pRemQiResNext->std.flags |= SORF_P_WEAKREF;
                }

                *ppv = NULL;

                LOCK(gIPIDLock);
                ASSERT_LOCK_HELD(gIPIDLock);

                *phr = UnmarshalIPID(*pIIDs, &pRemQiResNext->std,
                                     pQIC->pIPIDEntry->pOXIDEntry,
                                     (pQIRes) ? ppv : NULL);

                UNLOCK(gIPIDLock);
                ASSERT_LOCK_NOT_HELD(gIPIDLock);

                if (FAILED(*phr))
                {
                    // could not unmarshal, release the resources with the
                    // server.
                    RemoteReleaseStdObjRef(&pRemQiResNext->std,
                                           pQIC->pIPIDEntry->pOXIDEntry);
                }
            }
            else
            {
                // the requested interface was not returned so set the
                // return code and interface ptr.
                *phr = pRemQiResNext->hResult;
                *ppv = NULL;
            }

            pIIDs++;
            pRemQiResNext++;
        }
        else
        {
            // the whole call failed so return the error for each
            // requested interface.
            *phr = hr;
            *ppv = NULL;
        }

        // make sure the ptr value is NULL on failure. It may be NULL or
        // non-NULL on success. (ReconnectProxies wants NULL).
        Win4Assert(SUCCEEDED(*phr) || *ppv == NULL);
    }

    // free the result buffer
    CoTaskMemFree(pQIC->pRemQiRes);

    LOCK(gIPIDLock);
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL,
               "CStdMarshal::Finish_RemQIAndUnmarshal1 this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::Begin_RemQIAndUnmarshal2, private
//
//  Synopsis:   call QI on remote guy
//
//  History:    20-Feb-95   Rickhi      Created.
//
//  Notes:      Caller must guarantee at least one IPIDEntry is connected.
//              This function does a sparse fill of the result array.
//
//              This routine leaves the lock released as a side effect
//
//--------------------------------------------------------------------
void CStdMarshal::Begin_RemQIAndUnmarshal2(USHORT cIIDs, IID *pIIDs, QICONTEXT *pQIC)
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::RemQIAndUnmarshal2 this:%x cIIDs:%x pIIDs:%x pQIC:%x\n",
            this, cIIDs, pIIDs, pQIC));
    AssertValid();
    AssertDisconnectPrevented();
    Win4Assert(_pFirstIPID);    // must be at least 1 IPIDEntry
    ASSERT_LOCK_HELD(gIPIDLock);

    // we need an IPID to call RemoteQueryInterface with, any one will
    // do so long as it is connected (in the reconnect case there may be
    // only one connected IPID) so we pick the first one in the chain that
    // is connected.

    IPIDEntry *pIPIDEntry = GetConnectedIPID();
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // CODEWORK: we should just replace the IRemUnknown proxy in the
    // OXIDEntry with an IRemUnknown2 proxy, instead of getting a new
    // one for each client object.
    IRemUnknown2 *pRemUnk2;
    HRESULT  hr = GetSecureRemUnk((IRemUnknown **)&pRemUnk2,
                                   pIPIDEntry->pOXIDEntry);

    // we need an IMarshal interface to call UnmarshalInterface on. This
    // must be the outer object's (ie handler's) IMarshal interface.
    IMarshal *pIM = NULL;
    if (SUCCEEDED(hr))
    {
        hr = _pStdId->GetCtrlUnk()->QueryInterface(IID_IMarshal,
                                                   (void **)&(pQIC->pIM));
    }

    // call the remote guy. Note that we do not worry about or'ing on the
    // weak client bit if we are weak. This would be hard to do for this
    // interface, and it will be taken care of automatically by the calls
    // to UnmarshalInterface, though it will be somewhat less efficient. This
    // should not be a problem though since weakclient is local-only and rare.

    if (SUCCEEDED(hr))
    {
        Win4Assert(pIPIDEntry->pOXIDEntry);     // must have a resolved oxid
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        pQIC->pIIDs = pIIDs;
        pQIC->pIPIDEntry = pIPIDEntry;

        IPID ipid = pIPIDEntry->ipid;
        if (pQIC->dwFlags & QIC_ASYNC)
        {
            // the call is to be made async, so create an async
            // call object for IRemUnkown2
            hr = pQIC->pARU->Begin_RemQueryInterface2(ipid, cIIDs, pIIDs);
            pQIC->dwFlags |= QIC_BEGINCALLED;
        }
        else
        {
            // call is syncrounous
            memset(pQIC->phr, 0, (pQIC->cIIDs * sizeof(HRESULT)));
            memset(pQIC->ppMIFs, 0, (pQIC->cIIDs * sizeof(MInterfacePointer *)));

            hr = pRemUnk2->RemQueryInterface2(ipid, cIIDs, pIIDs, pQIC->phr, pQIC->ppMIFs);
        }
    }

    ComDebOut((DEB_CHANNEL, "CStdMarshal::Begin_RemQIAndUnmarshal2 OUT hr:0x%x\n", hr));
    pQIC->hr = hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::Finish_RemQIAndUnmarshal2
//
//  Synopsis:      unmarshal the marshaled interface pointer to create the
//                 IPID, and return the interface ptr.
//
//  History:       23-Jan-98  MattSmit  Created
//
//  Notes:         This routine leaves the lock taken as a side effect
//
//-----------------------------------------------------------------------------
HRESULT CStdMarshal::Finish_RemQIAndUnmarshal2(SQIResult *pQIRes, QICONTEXT *pQIC)
{
    ComDebOut((DEB_CHANNEL, "CStdMarshal::Finish_RemQIAndUnmarshal2 IN "
                "pQIRes:0x%x, pQIC:0x%x\n", pQIRes, pQIC));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    if (pQIC->dwFlags & QIC_ASYNC)
    {
        // complete async call
        memset(pQIC->phr, 0, (pQIC->cIIDs * sizeof(HRESULT)));
        memset(pQIC->ppMIFs, 0, (pQIC->cIIDs * sizeof(MInterfacePointer *)));
        hr = pQIC->pARU->Finish_RemQueryInterface2(pQIC->phr, pQIC->ppMIFs);
        pQIC->pARU = NULL;
    }
    else
    {
        // retreive results of sync call
        hr = pQIC->hr;
    }

    // unmarshal each interface returned. Note that while we did the
    // RemoteQI we could have yielded (or nested) and did another
    // RemoteQI for the same interfaces, so UnmarshalInterface has to
    // deal with duplicates.

    HRESULT   hr2;
    HRESULT  *phr = &hr2;
    void     *pv;
    void     **ppv = &pv;

    for (USHORT i=0; i<pQIC->cIIDs; i++)
    {
        if (pQIRes)
        {
            // caller wants the pointers returned, set ppv and phr.
            ppv = &pQIRes->pv;
            phr = &pQIRes->hr;
            pQIRes++;
        }

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(pQIC->phr[i]))
            {
                // make a stream over the marshaled interface data
                CXmitRpcStream Stm((InterfaceData *)pQIC->ppMIFs[i]);

                // Unmarshal the marshaled interface data.
                *phr = pQIC->pIM->UnmarshalInterface(&Stm, pQIC->pIIDs[i], ppv);

                // free the marshaled interface data
                CoTaskMemFree(pQIC->ppMIFs[i]);

                if (_pStdId->IsAggregated() && SUCCEEDED(*phr))
                {
                    // aggregated by a handler. We need to get the inner interface
                    // (the proxy) since UnmarshalInterface always returns the outer
                    // interface implemented by the handler.
                    void *pv = NULL;
                    InstantiatedProxy(pQIC->pIIDs[i], &pv, phr);
                    Win4Assert(SUCCEEDED(*phr));
                    if (pv != *ppv)
                    {
                        // keep the proxy and release the handler interface
                        ((IUnknown *)pv)->AddRef();
                        ((IUnknown *)*ppv)->Release();
                        *ppv = pv;
                    }
                }
            }
            else if (pQIRes)
            {
                // the requested interface was not returned so set the
                // return code and interface ptr.
                *phr = pQIC->phr[i];
                *ppv = NULL;
            }
        }
        else
        {
            // the whole call failed so return the error for each
            // requested interface.
            *phr = hr;
            *ppv = NULL;
        }

        // make sure the ptr value is NULL on failure. It may be NULL or
        // non-NULL on success. (ReconnectProxies wants NULL).
        Win4Assert(SUCCEEDED(*phr) || *ppv == NULL);
    }

    if (pQIC->pIM)
    {
        // release the IMarshal interface used for unmarshaling
        pQIC->pIM->Release();
    }

    LOCK(gIPIDLock);
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertDisconnectPrevented();
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::Finish_RemQIAndUnmarshal2 this:%x hr:%x\n", this, hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CStdMarshal::GetAsyncRemUnknown
//
//  Synopsis:      Creates an async RemUnkonwn object for this proxy
//
//  History:       23-Mar-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT  CStdMarshal::GetAsyncRemUnknown(IUnknown *pUnkCtl, AsyncIRemUnknown2 **ppARU,
                                         IUnknown **ppUnkInternal)
{
    ComDebOut((DEB_CHANNEL, "CStdMarhsl::GetAsyncRemUnknown IN pUnk:0x%x, ppARU:0x%x, ppUnkInternal:0x%x\n",
               pUnkCtl, ppARU, ppUnkInternal));

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
    IPIDEntry *pIPIDEntry = GetConnectedIPID();
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    IRemUnknown2 *pRemUnk2;
    HRESULT hr = GetSecureRemUnk((IRemUnknown **)&pRemUnk2,
                                 pIPIDEntry->pOXIDEntry);

    if (SUCCEEDED(hr))
    {
        REFIID riid = (_dwFlags & SMFLAGS_USEAGGSTDMARSHAL) ?
                          IID_AsyncIRemUnknown2 :
                          IID_AsyncIRemUnknown;

        hr = GetAsyncCallObject(pRemUnk2, pUnkCtl,
                                riid, riid,
                                ppUnkInternal, (void **)ppARU);
    }

    ComDebOut((DEB_CHANNEL, "GetAsyncRemUnknown OUT hr:0x%x\n", hr));
    return  hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::RemIsConnected, private
//
//  Synopsis:   Returns TRUE if most likely connected, FALSE if definitely
//              not connected or pending disconnect.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
BOOL CStdMarshal::RemIsConnected(void)
{
    AssertValid();
    Assert(ClientSide());

    // the default link depends on us returning FALSE if we are either
    // disconnected or just pending disconnect, in order that they avoid
    // running their cleanup code twice.

    BOOL fRes = (_dwFlags & (SMFLAGS_DISCONNECTED | SMFLAGS_PENDINGDISCONNECT))
                ? FALSE : TRUE;

    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::RemIsConnected this:%x fResult:%x\n", this, fRes));
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Member:     CreateChannel, private
//
//  Synopsis:   Creates an instance of the Rpc Channel.
//
//  History:    20-Feb-95   Rickhi        Created
//              26-Mar-98   GopalK      Agile proxies
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::CreateChannel(OXIDEntry *pOXIDEntry, DWORD dwFlags,
                REFIPID ripid, REFIID riid, CCtxComChnl **ppChnl)
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::CreateChannel this:%x\n",this));

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr = S_OK;

    if (pOXIDEntry == NULL)
    {
        // No OXIDEntry supplied, get our local OXID.
        hr = GetLocalOXIDEntry(&pOXIDEntry);
    }

    if (_pChnl == NULL && SUCCEEDED(hr))
    {
        // channel is still NULL, make one...
        DWORD cState = ServerSide() ? server_cs : client_cs;
        cState |= (_pStdId->IsFreeThreaded() || gEnableAgileProxies)
                  ? freethreaded_cs : 0;

        CCtxComChnl *pChnl = new CCtxComChnl(_pStdId, pOXIDEntry, cState);

        if (pChnl)
        {
            if (InterlockedCompareExchangePointer((void**)&_pChnl, pChnl, NULL) != NULL)
            {
                // another thread already did this, just release the channel
                // we created and continue onwards...
                pChnl->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr) && ClientSide())
    {
        *ppChnl = _pChnl->Copy(pOXIDEntry, ripid, riid);
        if (*ppChnl == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppChnl = _pChnl;
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "CStdMarshal::CreateChannel this:%x hr:%x\n",this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     GetPSFactory, private
//
//  Synopsis:   loads the proxy/stub factory for given IID
//
//  History:    20-Feb-95   Rickhi        Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//
//--------------------------------------------------------------------
#ifdef _WIN64
HRESULT CStdMarshal::GetPSFactory(REFIID riid, IUnknown *pUnkWow,RIFEntry **ppRIFEntry, 
				  IPSFactoryBuffer **ppIPSF, BOOL *pfNonNDR)
#else
HRESULT CStdMarshal::GetPSFactory(REFIID riid, IUnknown *pUnkWow, BOOL fServer,
                                  IPSFactoryBuffer **ppIPSF, BOOL *pfNonNDR)
#endif
{
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::GetPSFactory this:%x riid:%I pUnkWow:%x\n",
         this, &riid, pUnkWow));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // map iid to classid
    CLSID clsid;
#ifdef _WIN64
    HRESULT hr = gRIFTbl.GetPSClsid(riid, &clsid, ppRIFEntry);
#else
    HRESULT hr = gRIFTbl.RegisterInterface(riid, fServer, &clsid);
#endif
    DWORD actvflags = ACTVFLAGS_NONE;

    if (SUCCEEDED(hr))
    {
        BOOL fWow = FALSE;

        if (IsWOWThread())
        {
            // figure out if this is a custom interface from a 16bit
            // app, since we have to load the 16bit proxy code if so.

            IThunkManager *pThkMgr;
            g_pOleThunkWOW->GetThunkManager(&pThkMgr);
            Win4Assert(pThkMgr && "pUnk in WOW does not support IThunkManager.");

            if (pUnkWow)
                fWow = pThkMgr->IsCustom3216Proxy(pUnkWow, riid);
            else
                fWow = pThkMgr->IsIIDRequested(riid);

            pThkMgr->Release();
        }

#ifdef WX86OLE
        // If we are in a Wx86 process then we need to determine if the
        // PSFactory needs to be an x86 or native one.
        else if (gcwx86.IsWx86Linked())
        {
            // Callout to wx86 to ask it to determine if an x86 PS factory
            // is required. Whole32 can tell if the stub needs to be x86
            // by determining if pUnkWow is a custom interface proxy or not.
            // Whole32 can determine if a x86 proxy is required by checking
            // if the riid is one for a custom interface that is expected
            // to be returned.
            if ( gcwx86.NeedX86PSFactory(pUnkWow, riid) )
            {
                actvflags |= ACTVFLAGS_WX86_CALLER;
            }
        }
#endif

        // if we are loading a 16bit custom proxy then mark it as non NDR
        *pfNonNDR = (fWow) ? TRUE : FALSE;

        if (IsEqualGUID(clsid, CLSID_PSOlePrx32))
        {
            // its our internal CLSID so go straight to our class factory.
            hr = ProxyDllGetClassObject(clsid, IID_IPSFactoryBuffer,
                                        (void **)ppIPSF);
        }
        else
        {
            DWORD dwContext = fWow ? CLSCTX_INPROC_SERVER16
                                   : ((actvflags & ACTVFLAGS_WX86_CALLER) ? CLSCTX_INPROC_SERVERX86 :
                                                                        CLSCTX_INPROC_SERVER)
                                   | CLSCTX_PS_DLL;

            // load the dll and get the PS class object
            hr = ICoGetClassObject(clsid,
                                   dwContext | CLSCTX_NO_CODE_DOWNLOAD,
                                   NULL, IID_IPSFactoryBuffer, actvflags,
                                   (void **)ppIPSF, NULL);
#ifdef WX86OLE
            if ((actvflags & ACTVFLAGS_WX86_CALLER) && FAILED(hr))
            {
                // if we are looking for an x86 PSFactory and we didn't find
                // one on InprocServerX86 key then we need to check
                // InprocServer32 key as well.
                hr = ICoGetClassObject(clsid,
                                      (CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL | CLSCTX_NO_CODE_DOWNLOAD),
                                       NULL, IID_IPSFactoryBuffer, actvflags,
                                      (void **)ppIPSF, NULL);

                if (SUCCEEDED(hr) && (! gcwx86.IsN2XProxy((IUnknown *)*ppIPSF)))
                {
                    ((IUnknown *)*ppIPSF)->Release();
                    hr = REGDB_E_CLASSNOTREG;
                }
            }
#endif
            AssertOutPtrIface(hr, *ppIPSF);
        }
    }

#if DBG==1
    // if the fake NonNDR flag is set and its the test interface, then
    // trick the code into thinking this is a nonNDR proxy. This is to
    // enable simpler testing of an esoteric feature.

    if (gfFakeNonNDR && IsEqualIID(riid, IID_ICube))
    {
        *pfNonNDR = TRUE;
    }
#endif

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::GetPSFactory this:%x pIPSF:%x fNonNDR:%x hr:%x\n",
         this, *ppIPSF, *pfNonNDR, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CreateProxy, private
//
//  Synopsis:   creates an interface proxy for the given interface
//
//  Returns:    [ppv] - interface of type riid, AddRef'd
//
//  History:    20-Feb-95   Rickhi        Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::CreateProxy(REFIID riid, IRpcProxyBuffer **ppProxy,
                                 void **ppv, BOOL *pfNonNDR)
{
    TRACECALL(TRACE_MARSHAL, "CreateProxy");
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::CreateProxy this:%x riid:%I\n", this, &riid));
    AssertValid();
    Win4Assert(ClientSide());
    Win4Assert(ppProxy != NULL);
    ASSERT_LOCK_HELD(gIPIDLock);

    // get the controlling IUnknown of this object
    IUnknown *punkCtrl = _pStdId->GetCtrlUnk();
    Win4Assert(punkCtrl != NULL);


    if (InlineIsEqualGUID(riid, IID_IUnknown))
    {
        // there is no proxy for IUnknown so we handle that case here
        punkCtrl->AddRef();
        *ppv      = (void **)punkCtrl;
        *ppProxy  = NULL;
        *pfNonNDR = FALSE;
        return S_OK;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // now construct the proxy for the interface
    IPSFactoryBuffer *pIPSF = NULL;
#ifdef _WIN64
    RIFEntry *pRIFEntry;
    HRESULT hr = GetPSFactory(riid, NULL, &pRIFEntry, &pIPSF, pfNonNDR);
#else
    HRESULT hr = GetPSFactory(riid, NULL, FALSE, &pIPSF, pfNonNDR);
#endif
    if (SUCCEEDED(hr))
    {
#ifdef _WIN64
        // For proxies, we may as well register the interface now-Sajia
	hr = gRIFTbl.RegisterInterface(riid, FALSE, NULL, pRIFEntry);
	// got the class factory, now create an instance
	if (SUCCEEDED(hr))
	{
#endif
	   hr = pIPSF->CreateProxy(punkCtrl, riid, ppProxy, ppv);
	   AssertOutPtrIface(hr, *ppProxy);
#ifdef _WIN64
	}
#endif
	pIPSF->Release();
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::CreateProxy this:%x pProxy:%x pv:%x fNonNDR:%x hr:%x\n",
         this, *ppProxy, *ppv, *pfNonNDR, hr));
    return  hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CreateStub, private
//
//  Synopsis:   creates an interface stub and adds it to the IPID table
//
//  History:    20-Feb-95   Rickhi      Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::CreateStub(REFIID riid, IRpcStubBuffer **ppStub,
                                void **ppv, BOOL *pfNonNDR,
                                IUnknown *pUnkUseInner)
{
    TRACECALL(TRACE_MARSHAL, "CreateStub");
    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::CreateStub this:%x riid:%I\n", this, &riid));
    AssertValid();
    Win4Assert(ServerSide());
    Win4Assert(ppStub != NULL);
    ASSERT_LOCK_HELD(gIPIDLock);

    // get the IUnknown of the object
    IUnknown *punkObj;
    if (pUnkUseInner)
    {
        // The static marshaller passes its inner unknown if
        // the interface is IMultiQI.  This eliminates the need
        // for the aggregating object expose it.
        punkObj = pUnkUseInner;
    }
    else
    {
        punkObj = _pStdId->GetServer();
    }

    Win4Assert(punkObj != NULL);

    if (InlineIsEqualGUID(riid, IID_IUnknown))
    {
        // there is no stub for IUnknown so we handle that here
        *ppv      = (void *)punkObj;
        *ppStub   = NULL;
        *pfNonNDR = FALSE;
        return S_OK;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // make sure the object supports the given interface, so we dont
    // waste a bunch of effort creating a stub if the interface is
    // not supported.

#ifdef WX86OLE
    if (gcwx86.IsN2XProxy(punkObj))
    {
        // If we are creating a stub for an object that is living on the
        // x86 side then we need to set the StubInvoke flag to allow QI
        // to thunk the custom interface QI.
        gcwx86.SetStubInvokeFlag((BOOL)1);
    }
#endif
    IUnknown *pUnkIf = NULL;
    HRESULT hr = punkObj->QueryInterface(riid, (void **)&pUnkIf);
    AssertOutPtrIface(hr, pUnkIf);

    if (SUCCEEDED(hr))
    {
        // now construct the stub for the interface
        IPSFactoryBuffer *pIPSF = NULL;
#ifdef _WIN64
	RIFEntry *pRIFEntry;
        hr = GetPSFactory(riid, pUnkIf, &pRIFEntry, &pIPSF, pfNonNDR);
#else
        hr = GetPSFactory(riid, pUnkIf, TRUE, &pIPSF, pfNonNDR);
#endif
        if (SUCCEEDED(hr))
        {
	        // For stubs, create the stub and then register it - Sajia
	        // got the class factory, now create an instance
            hr = pIPSF->CreateStub(riid, punkObj, ppStub);
            AssertOutPtrIface(hr, *ppStub);
            pIPSF->Release();
            
#ifdef _WIN64
            if (SUCCEEDED (hr))
            {
	            hr = gRIFTbl.RegisterInterface(riid, TRUE, *ppStub, pRIFEntry);
            }
#endif
        }

        if (SUCCEEDED(hr))
        {
            // remember the interface pointer
            *ppv = (void *)pUnkIf;
        }
        else
        {
            // error, release the interface and return NULL
            pUnkIf->Release();
            *ppv = NULL;
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    ComDebOut((DEB_MARSHAL,
        "CStdMarshal::CreateStub this:%x pStub:%x pv:%x fNonNDR:%x hr:%x\n",
         this, *ppStub, *ppv, *pfNonNDR, hr));
    return  hr;
}

//+-------------------------------------------------------------------
//
//  Member:     FindIPIDEntryByIID, private
//
//  Synopsis:   Finds an IPIDEntry, chained off this object, with the
//              given riid.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::FindIPIDEntryByIID(REFIID riid, IPIDEntry **ppEntry)
{
    ComDebOut((DEB_OXID,"CStdMarshal::FindIPIDEntryByIID ppEntry:%x riid:%I\n",
        ppEntry, &riid));
    ASSERT_LOCK_HELD(gIPIDLock);

    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        if (InlineIsEqualGUID(riid, pEntry->iid))
        {
            *ppEntry = pEntry;
            return S_OK;
        }

        pEntry = pEntry->pNextIPID;      // get next entry in object chain
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     FindIPIDEntryByIPID, private
//
//  Synopsis:   returns the IPIDEntry ptr for the given IPID
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::FindIPIDEntryByIPID(REFIPID ripid, IPIDEntry **ppEntry)
{
    ComDebOut((DEB_OXID,"CStdMarshal::FindIPIDEntryByIPID ppEntry:%x ripid:%I\n",
        ppEntry, &ripid));
    ASSERT_LOCK_HELD(gIPIDLock);

    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        if (InlineIsEqualGUID(pEntry->ipid, ripid))
        {
            *ppEntry = pEntry;
            return S_OK;
        }

        pEntry = pEntry->pNextIPID;      // get next entry in object chain
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     FindIPIDEntryByInterface, internal
//
//  Synopsis:   returns the IPIDEntry ptr for the given proxy
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::FindIPIDEntryByInterface(void *pProxy, IPIDEntry **ppEntry)
{
    ComDebOut((DEB_OXID,"CStdMarshal::FindIPIDEntryByInterface ppEntry:%x pProxy:%x\n",
              ppEntry, pProxy));
    ASSERT_LOCK_HELD(gIPIDLock);

    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        if (pEntry->pv == pProxy)
        {
            *ppEntry = pEntry;
            return S_OK;
        }

        pEntry = pEntry->pNextIPID;     // get next entry in object chain
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     IncSrvIPIDCnt, protected
//
//  Synopsis:   increments the refcnt on the IPID entry, and optionally
//              AddRefs the StdId.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::IncSrvIPIDCnt(IPIDEntry *pEntry, ULONG cRefs,
                                   ULONG cPrivateRefs, SECURITYBINDING *pName,
                                   DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL, "IncSrvIPIDCnt this:%x pIPID:%x cRefs:%x cPrivateRefs:%x\n",
        this, pEntry, cRefs, cPrivateRefs));
    Win4Assert(ServerSide());
    Win4Assert(pEntry);
    Win4Assert(cRefs > 0 || cPrivateRefs > 0);
    ASSERT_LOCK_HELD(gIPIDLock);

    HRESULT hr = S_OK;

    if (cPrivateRefs != 0)
    {
        // Add a reference.
        hr = gSRFTbl.IncRef( cPrivateRefs, pEntry->ipid, pName );

        if (SUCCEEDED(hr))
        {
            BOOL fNotify = (pEntry->cPrivateRefs == 0) ? TRUE : FALSE;
            pEntry->cPrivateRefs += cPrivateRefs;
            if (fNotify)
            {
                // this inc causes the count to go from zero to non-zero, so we
                // inc the strong count on the stdid to hold it alive until this
                // IPID is released.
                IncStrongAndNotifyAct(pEntry, mshlflags);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (mshlflags & MSHLFLAGS_TABLE)
        {
            // Table Marshal Case: inc the number of table marshals.
            IncTableCnt();
        }

        if (mshlflags & (MSHLFLAGS_WEAK | MSHLFLAGS_TABLEWEAK))
        {
            if (pEntry->cWeakRefs == 0)
            {
                // this inc causes the count to go from zero to non-zero, so we
                // AddRef the stdid to hold it alive until this IPID is released.
                _pStdId->IncWeakCnt();
            }
            pEntry->cWeakRefs += cRefs;
        }
        else
        {
            BOOL fNotify = (pEntry->cStrongRefs == 0) ? TRUE : FALSE;
            pEntry->cStrongRefs += cRefs;
            if (fNotify)
            {
                // this inc causes the count to go from zero to non-zero, so we
                // inc the strong count on the stdid to hold it alive until this
                // IPID is released.
                IncStrongAndNotifyAct(pEntry, mshlflags);
            }
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     IncTableCnt, public
//
//  Synopsis:   increments the count of table marshals
//
//  History:    9-Oct-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::IncTableCnt(void)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    // If something was marshaled for a table, we have to ignore
    // rundowns until a subsequent RMD is called for it, at which
    // time we start paying attention to rundowns again. Since there
    // can be any number of table marshals, we have to refcnt them.

    _cTableRefs++;
    _dwFlags |= SMFLAGS_IGNORERUNDOWN;
}

//+-------------------------------------------------------------------
//
//  Member:     IncStrongAndNotifyAct, private
//
//  Synopsis:   notifies the activation code when this interface refcnt
//              goes from 0 to non-zero and the activation code asked to be
//              notified, and also increments the strong refcnt.
//
//  History:    21-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::IncStrongAndNotifyAct(IPIDEntry *pEntry, DWORD mshlflags)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    // inc the strong count on the stdid to hold it alive until this
    // IPIDEntry is released.

    _pStdId->IncStrongCnt();
    if (mshlflags & MSHLFLAGS_NOTIFYACTIVATION &&
        !(pEntry->dwFlags & IPIDF_NOTIFYACT))
    {
        // the activation code asked to be notified when the refcnt
        // on this interface goes positive, and when it reaches
        // zero again. Set a flag so we remember to notify
        // activation when the strong reference reference count
        // goes back down to zero.
        pEntry->dwFlags |= IPIDF_NOTIFYACT;

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        BOOL fOK = NotifyActivation(TRUE, (IUnknown *)(pEntry->pv));
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);

        if (!fOK)
        {
            // call failed, so dont bother notifying
            pEntry->dwFlags &= ~IPIDF_NOTIFYACT;
        }
    }
}

//+-------------------------------------------------------------------
//
//  Member:     DecSrvIPIDCnt, protected
//
//  Synopsis:   decrements the refcnt on the IPID entry, and optionally
//              Releases the StdId.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::DecSrvIPIDCnt(IPIDEntry *pEntry, ULONG cRefs,
                                ULONG cPrivateRefs, SECURITYBINDING *pName,
                                DWORD mshlflags)
{
    ComDebOut((DEB_MARSHAL, "DecSrvIPIDCnt this:%x pIPID:%x cRefs:%x cPrivateRefs:%x\n",
        this, pEntry, cRefs, cPrivateRefs));
    Win4Assert(ServerSide());
    Win4Assert(pEntry);
    Win4Assert(cRefs > 0 || cPrivateRefs > 0);
    ASSERT_LOCK_HELD(gIPIDLock);

    // Note: we dont care about holding the LOCK over the Release call since
    // the guy who called us is holding a ref to the StdId, so this Release
    // wont cause us to go away.

    if (mshlflags & MSHLFLAGS_TABLE)
    {
        // Table Marshal Case: dec the number of table marshals.
        DecTableCnt();
    }

    if (mshlflags & (MSHLFLAGS_WEAK | MSHLFLAGS_TABLEWEAK))
    {
        Win4Assert(pEntry->cWeakRefs >= cRefs);
        pEntry->cWeakRefs -= cRefs;

        if (pEntry->cWeakRefs == 0)
        {
            // this dec caused the count to go from non-zero to zero, so we
            // Release the stdid since this IPID is no longer holding it alive.
            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            _pStdId->DecWeakCnt(TRUE);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
        }
    }
    else
    {
        // Adjust the strong reference count.  Don't let the caller release
        // too many times.

        if (pEntry->cStrongRefs < cRefs)
        {
            ComDebOut((DEB_WARN,"DecSrvIPIDCnt too many releases. IPID entry: 0x%x   Extra releases: 0x%x",
                       pEntry, cRefs-pEntry->cStrongRefs));
            cRefs = pEntry->cStrongRefs;
        }
        pEntry->cStrongRefs -= cRefs;

        if (pEntry->cStrongRefs == 0 && cRefs != 0)
        {
            // this dec caused the count to go from non-zero to zero, so we
            // dec the strong count on the stdid since the public references
            // on this IPID is no longer hold it alive.

            DecStrongAndNotifyAct(pEntry, mshlflags);
        }

        // Adjust the secure reference count.  Don't let the caller release
        // too many times.

        if (pName != NULL)
        {
            cPrivateRefs = gSRFTbl.DecRef(cPrivateRefs, pEntry->ipid, pName);
        }
        else
        {
            cPrivateRefs = 0;
        }

        Win4Assert( pEntry->cPrivateRefs >= cPrivateRefs );
        pEntry->cPrivateRefs -= cPrivateRefs;

        if (pEntry->cPrivateRefs == 0 && cPrivateRefs != 0)
        {
            // this dec caused the count to go from non-zero to zero, so we
            // dec the strong count on the stdid since the private references
            // on this IPID is no longer hold it alive.

            DecStrongAndNotifyAct(pEntry, mshlflags);
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     DecTableCnt, public
//
//  Synopsis:   decrements the count of table marshals
//
//  History:    9-Oct-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::DecTableCnt(void)
{
    ASSERT_LOCK_HELD(gIPIDLock);

    // If something was marshaled for a table, we have to ignore
    // rundowns until a subsequent RMD is called for it, at which
    // time we start paying attention to rundowns again. Since there
    // can be any number of table marshals, we have to refcnt them.
    // This is also used by CoLockObjectExternal.

    if (--_cTableRefs == 0)
    {
        // this was the last table marshal, so now we have to pay
        // attention to rundown from normal clients, so that if all
        // clients go away we cleanup.
        _dwFlags &= ~SMFLAGS_IGNORERUNDOWN;
        
        // Notify the identity object that we are now unpinned
        if (ServerSide())
        {
            CIDObject* pID = GetIDObject();
            
            // Sometimes we do not have an identity object (eg, when
            // we are an internal apt activator).  So don't assume
            // that there is one.
            if (pID)
                pID->NotifyOIDIsUnpinned();
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CStdMarshal::CanRunDown
//
//  Synopsis:   determines if it is OK to rundown this object, based on
//              the current time and the marshaled state of the object.
//
//  Returns:    A value from the OID_RUNDOWN_STATUS enumeration.
//
//  History:    24-Aug-95   Rickhi     Created
//              19-Mar-01   Jsimmons   Modified to return an OID_RUNDOWN_STATUS
//                                     value instead of True\False.
//
//-------------------------------------------------------------------------

// time period of one ping, used to determine if OK to rundown OID
extern DWORD giPingPeriod;

BYTE CStdMarshal::CanRunDown(DWORD iNow)
{
    ASSERT_LOCK_HELD(gComLock);

    if (_dwFlags & SMFLAGS_IGNORERUNDOWN)
    {
        // Stub is currently locked.  Return status code to inform
        // resolver of that.  Notify ID object that we are now pinned.
        Win4Assert(GetIDObject());
        GetIDObject()->NotifyOIDIsPinned();

        return ORS_OID_PINNED;
    }

    // Make sure the interface hasn't been marshalled since it
    // was last pinged. This calculation handles the wrap case.

    // REVIEW:  is it really possible for the resolver to be trying to
    //   run us down while the SMFLAGS_NOPING flag is set?  Should we
    //   assert in that case?
    if (!(_dwFlags & SMFLAGS_NOPING) &&
         (iNow - _dwMarshalTime >= giPingPeriod))
    {
        Win4Assert(_cTableRefs == 0);
        ComDebOut((DEB_MARSHAL, "Running Down Object this:%x\n", this));
        return ORS_OK_TO_RUNDOWN;
    }

    return ORS_DONTRUNDOWN;
}


//+-------------------------------------------------------------------
//
//  Member:     DecStrongAndNotifyAct, private
//
//  Synopsis:   notifies the activation code if this interface has
//              been released and the activation code asked to be
//              notified, and also decrements the strong refcnt.
//
//  History:    21-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::DecStrongAndNotifyAct(IPIDEntry *pEntry, DWORD mshlflags)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    BOOL fNotifyAct = FALSE;

    if ((pEntry->dwFlags & IPIDF_NOTIFYACT) &&
         pEntry->cStrongRefs == 0  &&
         pEntry->cPrivateRefs == 0)
    {
        // the activation code asked to be notified when the refcnt
        // on this interface reaches zero. Turn the flag off so we
        // don't call twice.
        pEntry->dwFlags &= ~IPIDF_NOTIFYACT;
        fNotifyAct = TRUE;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (fNotifyAct)
    {
        NotifyActivation(FALSE, (IUnknown *)(pEntry->pv));
    }

    _pStdId->DecStrongCnt(mshlflags & MSHLFLAGS_KEEPALIVE);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     AddIPIDEntry, private
//
//  Synopsis:   Allocates and fills in an entry in the IPID table.
//              The returned entry is not yet in the IPID chain.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::AddIPIDEntry(OXIDEntry *pOXIDEntry, IPID *pipid,
               REFIID riid, CCtxComChnl *pChnl, IUnknown *pUnkStub,
               void *pv, IPIDEntry **ppEntry)
{
    ComDebOut((DEB_MARSHAL,"AddIPIDEntry this:%x pOXID:%x iid:%I pStub:%x pv:%x\n",
        this, pOXIDEntry, &riid, pUnkStub, pv));
    ASSERT_LOCK_HELD(gIPIDLock);

    // CODEWORK: while we released the lock to create the proxy or stub,
    // the same interface could have been marshaled/unmarshaled. We should
    // go check for duplicates now. This is just an optimization, not a
    // requirement.

    // get a new entry in the IPID table.
    IPIDEntry *pEntryNew = gIPIDTbl.FirstFree();

    if (pEntryNew == NULL)
    {
        // no free slots and could not allocate more memory to grow
        return E_OUTOFMEMORY;
    }

    if (ServerSide())
    {
        // create an IPID for this entry
        DWORD *pdw = &pipid->Data1;
        *pdw     = gIPIDTbl.GetEntryIndex(pEntryNew);   // IPID table index
        *(pdw+1) = GetCurrentProcessId();               // current PID
        *(pdw+2) = GetCurrentApartmentId();             // current APTID
        *(pdw+3) = gIPIDSeqNum++;                       // process sequence #
    }

    *ppEntry = pEntryNew;

    pEntryNew->ipid     = *pipid;
    pEntryNew->iid      = riid;
    pEntryNew->pChnl    = pChnl;
    pEntryNew->pStub    = pUnkStub;
    pEntryNew->pv       = pv;
    pEntryNew->dwFlags  = ServerSide() ? IPIDF_DISCONNECTED | IPIDF_SERVERENTRY
                                       : IPIDF_DISCONNECTED | IPIDF_NOPING;
    pEntryNew->cStrongRefs  = 0;
    pEntryNew->cWeakRefs    = 0;
    pEntryNew->cPrivateRefs = 0;
    pEntryNew->pOXIDEntry   = pOXIDEntry;
    pEntryNew->pIRCEntry    = 0;

    ASSERT_LOCK_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,"AddIPIDEntry this:%x pIPIDEntry:%x ipid:%I\n",
        this, pEntryNew, &pEntryNew->ipid));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     ReleaseAllIPIDEntries, private
//
//  Synopsis:   walks the IPIDEntry list releasing the proxy/stub entries
//              and returning the IPIDEntries to the available pool.
//
//  History:    20-Feb-95   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdMarshal::ReleaseAllIPIDEntries(void)
{
    // Note: we dont need a LOCK around this cause we're in the destructor
    // of this object anyway. There should not be any other pointers to any
    // of these IPIDs, so it is OK to muck with their state.

    // Walk the chain of IPID Entries releasing the proxy/stub pointers.
    // Then, return the chain of IPIDs to the IPIDTable and release all
    // the context entries.

    IPIDEntry *pLastIPID;
    IPIDEntry *pEntry = _pFirstIPID;

    while (pEntry)
    {
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        // mark the entry as vacant and disconnected. Note we dont put
        // it back in the FreeList yet. We leave it chained to the other
        // IPIDs in the list, and add the whole chain to the FreeList at
        // the end.

        pEntry->dwFlags |= IPIDF_VACANT | IPIDF_DISCONNECTED;

        if (pEntry->pStub)
        {
            // if there is some pStub, then we should be client side, since
            // all the server side stubs are released in DisconnectSrvIPIDs.
            Win4Assert(ClientSide());

            ComDebOut((DEB_MARSHAL,"ReleaseProxy pProxy:%x\n", pEntry->pStub));
            pEntry->pStub->Release();
            pEntry->pStub = NULL;
        }

        pLastIPID = pEntry;
        pEntry = pEntry->pNextIPID;
    }

    if (_pFirstIPID)
    {
        // now take the LOCK and release all the IPIDEntries back into
        // the IPIDTable in one fell swoop.

        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);

        UnchainIPIDEntries(pLastIPID);

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    if (_pCtxEntryHead)
    {
        // release the CtxEntries
        //LOCK(gComLock);
        EnterCriticalSection(&_csCtxEntry);
        CtxEntry::DeleteCtxEntries(_pCtxEntryHead, CTXENTRYFLAG_PRIVLOCKED);
        //UNLOCK(gComLock);
        LeaveCriticalSection(&_csCtxEntry);
        	
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     ReleaseUnusedIPIDEntries, private
//
//  Synopsis:   This routine is called when an OXIDEntry is placed on
//              the expired list.  We release all of the IPIDs except
//              the one representing the primary remote unknown.
//
//  History:    02-Sep-99   Johnstra  Created
//
//--------------------------------------------------------------------
void CStdMarshal::ReleaseUnusedIPIDEntries(void)
{
    ComDebOut((DEB_MARSHAL,"ReleaseCopiedIPIDEntries this:%p\n", this));
    ASSERT_LOCK_HELD(gOXIDLock);

    IPIDEntry* pNextEntry;
    IPIDEntry* pPrevEntry  = NULL;
    IPIDEntry* pEntry      = _pFirstIPID;
    ULONG      cIPIDs      = _cIPIDs;
    ULONG      cReleased   = 0;
    ULONG      cChannels   = 0;

    // Allocate memory to hold arrays of interface pointers so we can Release
    // them after we have released the IPID lock.
    IUnknown** ppEntries = (IUnknown**)PrivMemAlloc(cIPIDs * sizeof(IUnknown*));
    if (NULL == ppEntries)
    {
    	UNLOCK(gOXIDLock);
    	ASSERT_LOCK_NOT_HELD(gOXIDLock);
        return;
    }

    CCtxComChnl** ppChnls = (CCtxComChnl**)PrivMemAlloc(cIPIDs * sizeof(CCtxComChnl*));
    if (NULL == ppChnls)
    {
    	UNLOCK(gOXIDLock);
    	ASSERT_LOCK_NOT_HELD(gOXIDLock);
        PrivMemFree(ppEntries);
        return;
    }


    ComDebOut((DEB_MARSHAL, "   cIPIDs:%x\n", cIPIDs));

    while (pEntry)
    {
        ComDebOut((DEB_MARSHAL,"   pEntry:%p pEntry->iid.Data1:%08X\n", pEntry, pEntry->iid.Data1));

        // Get pointer to the next IPID before we unlink this one.
        pNextEntry = pEntry->pNextIPID;

        if ( !(pEntry->dwFlags & IPIDF_COPY) &&
              (pEntry->iid == IID_IRundown     ||
               pEntry->iid == IID_IRemUnknown  ||
               pEntry->iid == IID_IRemUnknown2 ||
               pEntry->iid == IID_IRemUnknownN))
        {
            // This is the primary remote unknown.  Don't remove it.
            ComDebOut((DEB_MARSHAL,"   Not Releasing pEntry:%p\n", pEntry));
            pPrevEntry = pEntry;
        }
        else
        {
            // Safe to remove this proxy; it's not the primary remote unknown.
            ComDebOut((DEB_MARSHAL,"   Releasing pEntry:%p\n", pEntry));

            // mark the entry as vacant and disconnected.
            pEntry->dwFlags |= IPIDF_VACANT | IPIDF_DISCONNECTED;

            if (pEntry->pStub)
            {
                // if there is a pStub, then we should be client side, since
                // all the server side stubs are released in DisconnectSrvIPIDs.
                Win4Assert(ClientSide());

                if (NULL != pEntry->pv)
                {
                    // AddRef the controlling unknown and release the interface
                    // pointer of the proxy
                    _pStdId->GetCtrlUnk()->AddRef();
                    ((IUnknown *) pEntry->pv)->Release();
                    pEntry->pv = NULL;
                }

                // Disconnect the proxy from channel
                ((IRpcProxyBuffer *)pEntry->pStub)->Disconnect();

                // Save the pointer to the proxy so we can release it after we
                // release the lock.
                ppEntries[cReleased++] = pEntry->pStub;
                pEntry->pStub = NULL;
            }

            if (pEntry->pChnl)
            {
                ppChnls[cChannels++] = pEntry->pChnl;
                pEntry->pChnl = NULL;
            }

            // Unlink the IPIDEntry from the chain.
            if (NULL == pPrevEntry)
                _pFirstIPID = pNextEntry;
            else
                pPrevEntry->pNextIPID = pNextEntry;

            // These IPIDs do not hold a reference to the OXID.  Just
            // NULL the field.
            pEntry->pOXIDEntry = NULL;

            // Release the IPIDEntry back to the IPID table.
            // We should not be releasing the first IPID.
            Win4Assert(pEntry != _pFirstIPID);

            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
            gIPIDTbl.ReleaseEntry(pEntry);
            UNLOCK(gIPIDLock);
        }

        // Advance to the next IPIDEntry.
        pEntry = pNextEntry;
    }

    // Adjust the number of IPIDs remaining.
    _cIPIDs -= cReleased;

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // Call Release on all the proxies and channels.
    ULONG i;
    for (i = 0; i < cReleased; i++)
        ppEntries[i]->Release();

    for (i = 0; i < cChannels; i++)
        ppChnls[i]->Release();

    // Delete the memory we allocated.
    PrivMemFree(ppEntries);
    PrivMemFree(ppChnls);
}


void CStdMarshal::ReleaseRemUnkCopy(IRemUnknown* pSecureRemUnk)
{
    ComDebOut((DEB_MARSHAL,"ReleaseRemUnkCopy this:%p pSecureRemUnk:%p\n", this, pSecureRemUnk));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    IPIDEntry*   pEntry      = _pFirstIPID;
    IPIDEntry*   pPrevEntry  = NULL;
    IUnknown*    pProxy      = NULL;
    CCtxComChnl* pChnl       = NULL;

    // Scan list for the IPIDEntry for the supplied remote unknown copy.
    while (pEntry && pEntry->pv != pSecureRemUnk)
    {
        pPrevEntry = pEntry;
        pEntry = pEntry->pNextIPID;
    }

    // If we found the IPIDEntry, release it.
    if (pEntry)
    {
        ComDebOut((DEB_MARSHAL,"   found pSecureRemUnk:%p... removing it\n", pSecureRemUnk));
        Win4Assert((pEntry->dwFlags & IPIDF_COPY) == IPIDF_COPY);

        // mark the entry as vacant and disconnected.
        pEntry->dwFlags |= IPIDF_VACANT | IPIDF_DISCONNECTED;

        if (pEntry->pStub)
        {
            if (NULL != pEntry->pv)
            {
                ((IUnknown *) pEntry->pv)->Release();
                pEntry->pv = NULL;
            }

            // Disconnect the proxy from channel
            ((IRpcProxyBuffer *)pEntry->pStub)->Disconnect();

            // Save the proxy so we can release it after we release
            // the lock.
            pProxy = pEntry->pStub;
            pEntry->pStub = NULL;
        }

        // Save the channel so we can release it after we release
        // the lock.
        if (pEntry->pChnl)
        {
            pChnl = pEntry->pChnl;
            pEntry->pChnl = NULL;
        }

        // Unlink the IPIDEntry from the chain.
        if (NULL == pPrevEntry)
            _pFirstIPID = pEntry->pNextIPID;
        else
            pPrevEntry->pNextIPID = pEntry->pNextIPID;

        // This IPID does not hold a reference to the OXID.  Just
        // NULL the field.
        pEntry->pOXIDEntry = NULL;

        // Remove this IPID from the table.
        gIPIDTbl.ReleaseEntry(pEntry);

        // Adjust the number of IPIDs remaining.
        _cIPIDs--;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Call Release on all the proxy and channel.
    if (NULL != pProxy)
        pProxy->Release();

    if (NULL != pChnl)
        pChnl->Release();
}


//+------------------------------------------------------------------------
//
//  Member:     CStdMarshal::LockClient/UnLockClient
//
//  Synopsis:   Locks the client side object during outgoing calls in order
//              to prevent the object going away in a nested disconnect.
//
//  Notes:      UnLockClient is not safe in the freethreaded model.
//              Fortunately pending disconnect can only be set in the
//              apartment model on the client side.
//
//              See als PreventDisconnect / HandlePendingDisconnect.
//
//  History:    12-Jun-95   Rickhi  Created
//
//-------------------------------------------------------------------------
ULONG CStdMarshal::LockClient(void)
{
    Win4Assert(ClientSide());
    InterlockedIncrement(&_cNestedCalls);
    return (_pStdId->GetCtrlUnk())->AddRef();
}

ULONG CStdMarshal::UnlockClient(void)
{
    Win4Assert(ClientSide());
    if ((InterlockedDecrement(&_cNestedCalls) == 0) &&
        (_dwFlags & SMFLAGS_PENDINGDISCONNECT))
    {
        // Decide the type of disconnect
        DWORD dwType = GetPendingDisconnectType();

        // Disconnect from the server object
        Disconnect(dwType);
    }
    Win4Assert(_cNestedCalls != -1);
    return (_pStdId->GetCtrlUnk())->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::GetSecureRemUnk, public
//
//  Synopsis:   If the marshaller has its own remote unknown, use it.
//              Otherwise use the OXID's remote unknown.
//
//  History:    2-Apr-96   AlexMit     Created
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::GetSecureRemUnk( IRemUnknown **ppSecureRemUnk,
                                      OXIDEntry *pOXIDEntry )
{
    ComDebOut((DEB_OXID, "CStdMarshal::GetSecureRemUnk ppRemUnk:%x\n",
               ppSecureRemUnk));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    HRESULT hr = S_OK;

    if (_pSecureRemUnk != NULL)
    {
        // use existing private RemUnknown
        *ppSecureRemUnk = _pSecureRemUnk;
    }
    else
    {
        // go get one from the oxidentry
        hr = pOXIDEntry->GetRemUnk(ppSecureRemUnk);
    }

    return hr;
}

#if DBG==1

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DbgWalkIPIDs
//
//  Synopsis:   Validates that the state of all the IPIDs is consistent.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::DbgWalkIPIDs(void)
{
    LONG       cIPIDs = 0;
    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        ValidateIPIDEntry(pEntry);
        pEntry = pEntry->pNextIPID;
        cIPIDs++;
    }

    Win4Assert( cIPIDs == _cIPIDs );
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::AssertValid
//
//  Synopsis:   Validates that the state of the object is consistent.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::AssertValid()
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gIPIDLock);

    Win4Assert((_dwFlags & ~SMFLAGS_ALL) == 0);
    Win4Assert(_pStdId  != NULL);
    Win4Assert(IsValidInterface(_pStdId));

    if (_pChnl != NULL)
    {
        Win4Assert(IsValidInterface(_pChnl));
        _pChnl->AssertValid(FALSE, FALSE);
    }

    DbgWalkIPIDs();

    UNLOCK(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::AssertDisconnectPrevented, private
//
//  Synopsis:   Just ensures that no disconnects can/have arrived.
//
//  History:    21-Sep-95   Rickhi      Created
//
//+-------------------------------------------------------------------
void CStdMarshal::AssertDisconnectPrevented()
{
    ASSERT_LOCK_DONTCARE(gIPIDLock);
    if (ServerSide())
        Win4Assert(!(_dwFlags & SMFLAGS_DISCONNECTED));
    Win4Assert(_cNestedCalls > 0);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ValidateSTD
//
//  Synopsis:   Ensures that the STDOBJREF is valid
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::ValidateSTD(STDOBJREF *pStd, BOOL fLockHeld)
{
    if (fLockHeld)
        ASSERT_LOCK_HELD(gIPIDLock);
    else
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // validate the flags field
    Win4Assert((pStd->flags & SORF_RSRVD_MBZ) == 0);

    // validate the OID
    OID oid;
    OIDFromMOID(_pStdId->GetOID(), &oid);
    Win4Assert(pStd->oid == oid);

    if (!FTMObject())
    {
        OXIDEntry *pOXIDEntry = NULL;
        if (ServerSide())
        {
            if (fLockHeld)
                UNLOCK(gIPIDLock);

            GetLocalOXIDEntry(&pOXIDEntry);

            if (fLockHeld)
                LOCK(gIPIDLock);
        }
        else if (_pChnl)
        {
            pOXIDEntry = _pChnl->GetOXIDEntry();
        }

        if (pOXIDEntry)
        {
            // validate the OXID
            OXID oxid;
            OXIDFromMOXID(pOXIDEntry->GetMoxid(), &oxid);
            Win4Assert(pStd->oxid == oxid);
        }
    }
}

//+-------------------------------------------------------------------
//
//  Function:   DbgDumpSTD
//
//  Synopsis:   dumps a formated STDOBJREF to the debugger
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void DbgDumpSTD(STDOBJREF *pStd)
{
    ULARGE_INTEGER *puintOxid = (ULARGE_INTEGER *)&pStd->oxid;
    ULARGE_INTEGER *puintOid  = (ULARGE_INTEGER *)&pStd->oid;

    ComDebOut((DEB_MARSHAL,
        "\n\tpStd:%x   flags:%08x   cPublicRefs:%08x\n\toxid: %08x %08x\n\t oid: %08x %08x\n\tipid:%I\n",
        pStd, pStd->flags, pStd->cPublicRefs, puintOxid->HighPart, puintOxid->LowPart,
        puintOid->HighPart, puintOid->LowPart, &pStd->ipid));
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::ValidateIPIDEntry
//
//  Synopsis:   Ensures that the IPIDEntry is valid
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::ValidateIPIDEntry(IPIDEntry *pEntry)
{
    // ask the table to validate the IPID entry
    gIPIDTbl.ValidateIPIDEntry(pEntry, ServerSide(), _pChnl);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdMarshal::DbgDumpInterfaceList
//
//  Synopsis:   Prints the list of Interfaces on the object.
//
//  History:    20-Feb-95   Rickhi  Created.
//
//--------------------------------------------------------------------
void CStdMarshal::DbgDumpInterfaceList(void)
{
    ComDebOut((DEB_ERROR, "\tInterfaces left on object (0x%x) are:\n", this));
    LOCK(gIPIDLock);

    // walk the IPID list printing the friendly name of each interface
    IPIDEntry *pEntry = _pFirstIPID;
    while (pEntry)
    {
        WCHAR wszName[MAX_PATH];
        GetInterfaceName(pEntry->iid, wszName);
        ComDebOut((DEB_ERROR,"\t\t %ws\t ipid:%I, cStrongRefs:%x, cWeakRefs:%x\n ",
              wszName, &pEntry->ipid, pEntry->cStrongRefs, pEntry->cWeakRefs));
        pEntry = pEntry->pNextIPID;
    }

    UNLOCK(gIPIDLock);
}
#endif // DBG == 1


//+-------------------------------------------------------------------
//
//  Function:   CStdMarshal::RemoteAddRef, private
//
//  Synopsis:   gets needed references either from the global reference
//              cache or by calling the remote server to AddRef one of
//              its interfaces
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::RemoteAddRef(IPIDEntry *pIPIDEntry, OXIDEntry *pOXIDEntry,
                                  ULONG cStrongNeed, ULONG cSecureNeed,
                                  BOOL fGiveToCaller)
{
    ComDebOut((DEB_MARSHAL,  "RemoteAddRef this:%x cRefs:%x cSecure:%x ipid:%I\n",
        this, cStrongNeed, cSecureNeed, &pIPIDEntry->ipid));
    ASSERT_LOCK_HELD(gIPIDLock);

    ULONG cStrongRequest = cStrongNeed;
    HRESULT hr = S_OK;

    // if the object does not require pinging, it is also ignoring
    // reference counts, so there is no need to go get more, just
    // pretend like we did.
    if (!(pIPIDEntry->dwFlags & IPIDF_NOPING))
    {
        hr = E_FAIL;
        if (cSecureNeed == 0 && _pRefCache)
        {
            // The caller doesn't want any secure references (which we don't cache)
            // so go ask the Reference cache if it can fullfill our request.
            if (fGiveToCaller)
            {
                // ask for one more ref, we'll give this back below. This ensures
                // that we never give away all of our cached references.
                cStrongRequest += 1;
            }

            hr = _pRefCache->GetSharedRefs(pIPIDEntry, cStrongRequest);
        }

        if (FAILED(hr))
        {
            // could not get the references from the refcache so go ask
            // the remote server.
            cStrongRequest = cStrongNeed;
            if ((cStrongNeed == 1) && !(_dwFlags & SMFLAGS_WEAKCLIENT))
            {
                // may as well get a few extra references than we actually
                // need so we can share them and save some round-trips. Don't
                // do this for weak clients since we don't want a weak client
                // to have any strong references.
                cStrongRequest = REM_ADDREF_CNT;
            }

            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            // get the IRemUnknown for the remote server
            IRemUnknown *pRemUnk;
            hr = GetRemUnk(&pRemUnk, pOXIDEntry);

            if (SUCCEEDED(hr))
            {
                // call RemAddRef on the interface
                REMINTERFACEREF rifRef;
                rifRef.ipid         = pIPIDEntry->ipid;
                rifRef.cPublicRefs  = cStrongRequest;
                rifRef.cPrivateRefs = cSecureNeed;

                HRESULT ignore;
                hr = pRemUnk->RemAddRef(1, &rifRef, &ignore);
            }

            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            LOCK(gIPIDLock);
        }
    }

    if (SUCCEEDED(hr))
    {
        // store the references in the IPIDEntry
        pIPIDEntry->cPrivateRefs += cSecureNeed;

        if (fGiveToCaller)
            pIPIDEntry->cStrongRefs  += cStrongRequest - cStrongNeed;
        else
            pIPIDEntry->cStrongRefs  += cStrongRequest;

        if (_pRefCache)
        {
            // give any extra references we acquired to the reference
            // cache so they can be used by other apartments in this process.
            _pRefCache->GiveUpRefs(pIPIDEntry);
        }
    }

    ComDebOut((DEB_MARSHAL, "RemoteAddRef hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   RemoteReleaseRifRef
//
//  Synopsis:   Uses the remote unknown with the correct security
//              blanket and handles release inside async calls.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT RemoteReleaseRifRef(CStdMarshal *pMarshal, OXIDEntry *pOXIDEntry,
                            USHORT cRifRef, REMINTERFACEREF *pRifRef)
{
    Win4Assert(pRifRef);
    ComDebOut((DEB_MARSHAL,
        "RemoteReleaseRifRef pOXID:%x cRifRef:%x pRifRef:%x cRefs:%x ipid:%I\n",
         pOXIDEntry, cRifRef, pRifRef, pRifRef->cPublicRefs, &pRifRef->ipid));
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // ensure TLS is intialized on this thread.
    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
    {
        // get the IRemUnknown for the remote server
        IRemUnknown *pRemUnk;
        if (pMarshal == NULL || (gCapabilities & EOAC_SECURE_REFS))
        {
            hr = pOXIDEntry->GetRemUnk(&pRemUnk);
        }
        else
        {
            hr = pMarshal->GetRemUnk(&pRemUnk, pOXIDEntry);
        }

        if (SUCCEEDED(hr))
        {
            IUnknown *pAsyncRelease = pMarshal ? pMarshal->GetAsyncRelease() : NULL;
            hr = RemoteReleaseRifRefHelper(pRemUnk, pOXIDEntry, cRifRef,
                                           pRifRef, pAsyncRelease);
            if (SUCCEEDED(hr) && pAsyncRelease)
            {
                // zap the object to let the async call object
                // know it doesn't need to call Signal
                pMarshal->SetAsyncRelease(NULL);
            }
        }
    }

    ComDebOut((DEB_MARSHAL, "RemoteReleaseRifRef hr:%x\n", hr));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   RemoteReleaseRifRefHelper
//
//  Synopsis:   calls the remote server to release some IPIDs
//
//  History:    10-Jul-97    AlexArm      Broke out of RemoteReleaseRifRef.
//
//--------------------------------------------------------------------
HRESULT RemoteReleaseRifRefHelper(IRemUnknown *pRemUnk, OXIDEntry *pOXIDEntry,
                                  USHORT cRifRef, REMINTERFACEREF *pRifRef,
                                  IUnknown *pAsyncRelease)
{
    Win4Assert(pRifRef);
    ComDebOut((DEB_MARSHAL,
        "RemoteReleaseRifRefHelper pRemUnk:%x cRifRef:%x pRifRef:%x cRefs:%x ipid:%I\n",
         pRemUnk, cRifRef, pRifRef, pRifRef->cPublicRefs, &pRifRef->ipid));
    Win4Assert(pRemUnk);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    HRESULT hr;

#if DBG==1
    // Each interface ref should have some references to release.
    for (DWORD i = 0; i < cRifRef; i++)
        Win4Assert( pRifRef[i].cPublicRefs+pRifRef[i].cPrivateRefs > 0 );
#endif

    if (IsSTAThread() &&
        FAILED(CanMakeOutCall(CALLCAT_SYNCHRONOUS, IID_IRundown, NULL)))
    {
        // the call control will not let this apartment model thread make
        // the outgoing release call (cause we're inside an InputSync call)
        // so we post ourselves a message to do it later.

        hr = PostReleaseRifRef(pRemUnk, pOXIDEntry, cRifRef, pRifRef, pAsyncRelease);
    }
    else
    {
        if (pAsyncRelease)
        {
            // this call is to be made async, so create an async call object
            AsyncIRemUnknown *pARU;

            hr = pAsyncRelease->QueryInterface(IID_AsyncIRemUnknown, (void **) &pARU);

            if (SUCCEEDED(hr))
            {
                pARU->Begin_RemRelease(cRifRef, pRifRef);
                pARU->Release();
            }
        }
        else
        {
            // call is sync
            hr = pRemUnk->RemRelease(cRifRef, pRifRef);
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "RemoteReleaseRifRefHelper hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   PostReleaseRifRef
//
//  Synopsis:   Post a message to ourself to call RemoteReleaseRifRef later.
//              This is used to make a synchronous remote Release call when
//              a Release is done inside of an InputSync call. The call is
//              delayed until we are out of the InputSync call, since the
//              call control wont allow a synch call inside an inputsync call.
//
//  History:    05-Apr-96   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL PostReleaseRifRef(IRemUnknown *pRemUnk, OXIDEntry *pOXIDEntry,
                           USHORT cRifRef, REMINTERFACEREF *pRifRef,
                           IUnknown *pAsyncRelease)
{
    Win4Assert(pRifRef);
    ComDebOut((DEB_MARSHAL,
        "PostReleaseRifRef pOXID:%x cRifRef:%x pRifRef:%x cRefs:%x ipid:%I\n",
         pOXIDEntry, cRifRef, pRifRef, pRifRef->cPublicRefs, &pRifRef->ipid));
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    OXIDEntry *pLocalOXIDEntry = NULL;
    HRESULT hr = GetLocalOXIDEntry(&pLocalOXIDEntry);

    if (SUCCEEDED(hr))
    {
        // allocate a structure to hold the data and copy in the RifRef
        // list, OXIDEntry, and count of entries. Inc the OXID RefCnt to
        // ensure it stays alive until the posted message is processed.

        hr = E_OUTOFMEMORY;
        ULONG cbRifRef = cRifRef * sizeof(REMINTERFACEREF);
        ULONG cbAlloc  = sizeof(POSTRELRIFREF) + (cbRifRef-1);
        POSTRELRIFREF *pRelRifRef = (POSTRELRIFREF *) PrivMemAlloc(cbAlloc);

        if (pRelRifRef)
        {
            hr = S_OK;
            pRemUnk->AddRef();
            if (pAsyncRelease)
            {
                pAsyncRelease->AddRef();
            }
            pOXIDEntry->IncRefCnt();    // keep alive
            pRelRifRef->pOXIDEntry      = pOXIDEntry;
            pRelRifRef->cRifRef         = cRifRef;
            pRelRifRef->pRemUnk         = pRemUnk;
            pRelRifRef->pAsyncRelease   = pAsyncRelease;
            memcpy(&pRelRifRef->arRifRef, pRifRef, cbRifRef);

            if (!PostMessage(pLocalOXIDEntry->GetServerHwnd(),
                             WM_OLE_ORPC_RELRIFREF,
                             WMSG_MAGIC_VALUE,
                             (LPARAM)pRelRifRef))
            {
                // Post failed, free the structure and report an error.
                pRemUnk->Release();
                if (pAsyncRelease)
                {
                    pAsyncRelease->Release();
                }

                pOXIDEntry->DecRefCnt();
                PrivMemFree(pRelRifRef);
                hr = RPC_E_SYS_CALL_FAILED;
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "PostReleaseRifRef hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   HandlePostReleaseRifRef
//
//  Synopsis:   Handles the ReleaseRifRef message that was posted to the
//              current thread (by the current thread) in order to do a
//              delayed remote release call. See PostReleaseRifRef above.
//
//  History:    05-Apr-96   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL HandlePostReleaseRifRef(LPARAM param)
{
    Win4Assert(param);
    ComDebOut((DEB_MARSHAL, "HandlePostReleaseRifRef pRifRef:%x\n", param));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    POSTRELRIFREF *pRelRifRef = (POSTRELRIFREF *)param;

    // simply make the real remote release call now, then release the
    // reference we have on the OXIDEntry, and free the message buffer.
    // If this call fails, dont try again, otherwise we could spin busy
    // waiting. Instead, just let Rundown clean up the server.

    RemoteReleaseRifRefHelper(pRelRifRef->pRemUnk,
                              pRelRifRef->pOXIDEntry,
                              pRelRifRef->cRifRef,
                              &pRelRifRef->arRifRef,
                              pRelRifRef->pAsyncRelease);

    pRelRifRef->pRemUnk->Release();
    if (pRelRifRef->pAsyncRelease)
    {
        pRelRifRef->pAsyncRelease->Release();
    }
    pRelRifRef->pOXIDEntry->DecRefCnt();

    PrivMemFree(pRelRifRef);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "HandlePostReleaseRifRef hr:%x\n", S_OK));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     RemoteChangeRef
//
//  Synopsis:   calls the remote server to convert interface refereces
//              from strong to weak or vise versa. This behaviour is
//              required to support silent updates in the OLE container /
//              link / embedding scenarios.
//
//  Notes:      This functionality is not exposed in FreeThreaded apps
//              or in remote apps. The implication being that the container
//              must be on the same machine as the embedding.
//
//  History:    20-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::RemoteChangeRef(BOOL fLock, BOOL fLastUnlockReleases)
{
    ComDebOut((DEB_MARSHAL, "RemoteChangeRef \n"));
    Win4Assert(ClientSide());
    Win4Assert(IsSTAThread()); // not allowed in MTA Apartment

    // must be at least 1 proxy already connected in order to be able
    // to do this. We cant just ASSERT that's true because we were not
    // holding the lock on entry.

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
    HRESULT hr = PreventDisconnect();

    // A previous version of OLE set the object to weak even it it was
    // currently disconnected, and it remembered that it was weak and set
    // any new interfaces that it later accquired to weak. I emulate that
    // behaviour here.

    if (fLock)
        _dwFlags &= ~SMFLAGS_WEAKCLIENT;
    else
        _dwFlags |= SMFLAGS_WEAKCLIENT;

    if (SUCCEEDED(hr))
    {
        // allocate space to track references to convert
        REMINTERFACEREF *pRifRefAlloc = (REMINTERFACEREF *)
                _alloca(_cIPIDs * sizeof(REMINTERFACEREF) * 2);
        REMINTERFACEREF *pRifRef = pRifRefAlloc;

        // allocate space to track references to release
        USHORT cRelRifRef = 0;
        REMINTERFACEREF *pRelRifRefAlloc = (REMINTERFACEREF *)
                _alloca(_pRefCache->NumIRCs() * 2 * sizeof(REMINTERFACEREF));
        REMINTERFACEREF *pRelRifRef = pRelRifRefAlloc;


        USHORT     cIIDs      = 0;
        DWORD      cSecure    = gCapabilities & EOAC_SECURE_REFS ? 1 : 0;
        OXIDEntry *pOXIDEntry = NULL;
        IPIDEntry *pNextIPID  = _pFirstIPID;

        while (pNextIPID)
        {
            if (!(pNextIPID->dwFlags & IPIDF_DISCONNECTED))
            {
                if (pOXIDEntry == NULL)
                {
                    // This is the first connected IPID we encountered.
                    // Get its OXID entry and make sure it is for a server
                    // process on the current machine.
                    if (!(pNextIPID->pOXIDEntry->IsOnLocalMachine()))
                    {
                        // OXID is for a remote process. Abandon this call.
                        Win4Assert(cIIDs == 0);         // skip call below
                        Win4Assert(pOXIDEntry == NULL); // dont dec below
                        Win4Assert(hr == S_OK);         // report success
                        break;                          // exit while loop
                    }

                    // Remember the OXID and AddRef it to keep it alive
                    // over the duration of the call.
                    pOXIDEntry = pNextIPID->pOXIDEntry;
                    pOXIDEntry->IncRefCnt();
                }

                // save off the data...
                pRifRef->ipid = pNextIPID->ipid;

                if (!fLock)
                {
                    // convert strong refs to weak refs
                    if ((pNextIPID->cStrongRefs == 0) &&
                        (pNextIPID->dwFlags & IPIDF_STRONGREFCACHE))
                    {
                        // we gave all our strong references to the refcache, go
                        // get one of those back now so we can use it to convert
                        // it to weak.
                        if (SUCCEEDED(_pRefCache->GetSharedRefs(pNextIPID, 1)))
                            pNextIPID->cStrongRefs += 1;
                    }

                    if (pNextIPID->cStrongRefs > 0)
                    {
                        pRifRef->cPublicRefs    = pNextIPID->cStrongRefs;
                        pRifRef->cPrivateRefs   = pNextIPID->cPrivateRefs;
                        pNextIPID->cWeakRefs   += pNextIPID->cStrongRefs;
                        pNextIPID->cStrongRefs  = 0;
                        pNextIPID->cPrivateRefs = 0;

                        pRifRef++;
                        cIIDs++;
                    }
                }
                else
                {
                    // convert weak refs to strong refs
                    if (pNextIPID->cStrongRefs == 0)
                    {
                        pRifRef->cPublicRefs    = pNextIPID->cWeakRefs;
                        pRifRef->cPrivateRefs   = cSecure;
                        pNextIPID->cStrongRefs += pNextIPID->cWeakRefs;
                        pNextIPID->cWeakRefs    = 0;
                        pNextIPID->cPrivateRefs = cSecure;

                        pRifRef++;
                        cIIDs++;
                    }
                }

                if (_pRefCache)
                {
                    // get any cached references so we can Release them too
                    _pRefCache->ChangeRef(pNextIPID, fLock, &pRifRef, &cIIDs,
                                          &pRelRifRef, &cRelRifRef);
                }
            }

            // get next IPIDentry for this object
            pNextIPID = pNextIPID->pNextIPID;
        }

        DbgWalkIPIDs();

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        if (cIIDs != 0)
        {
            // we have looped filling in the IPID list, and there are
            // entries in the list. go call the server now.

            if (cRelRifRef)
            {
                // release references the cache was holding on this object
                // that are not being changed
                RemoteReleaseRifRef(this, pOXIDEntry, cRelRifRef, pRelRifRefAlloc);
            }

            // determine the calling flags
            DWORD dwFlags = (fLock) ? IRUF_CONVERTTOSTRONG : IRUF_CONVERTTOWEAK;
            if (fLastUnlockReleases)
                dwFlags |= IRUF_DISCONNECTIFLASTSTRONG;

            // change the references that this client owned
            hr = RemoteChangeRifRef(pOXIDEntry, dwFlags, cIIDs, pRifRefAlloc);
        }

        if (pOXIDEntry)
        {
            // release the OXIDEntry
            pOXIDEntry->DecRefCnt();
        }
    }
    else
    {
        // A previous implementation of OLE returned S_OK if the object was
        // disconnected. I emulate that behaviour here.

        hr = S_OK;
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    // this will handle any Disconnect that came in while we were busy.
    hr = HandlePendingDisconnect(hr);

    ComDebOut((DEB_MARSHAL, "RemoteChangeRef hr:%x\n", hr));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CStdMarshal::RemoteChangeRifRef
//
//  Synopsis:   calls the remote server to release some IPIDs
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CStdMarshal::RemoteChangeRifRef(OXIDEntry *pOXIDEntry, DWORD dwFlags,
                                        USHORT cRifRef, REMINTERFACEREF *pRifRef)
{
    Win4Assert(pRifRef);
    ComDebOut((DEB_MARSHAL,
        "RemoteChangeRifRef pOXID:%x cRifRef:%x pRifRef:%x cRefs:%x ipid:%I\n",
         pOXIDEntry, cRifRef, pRifRef, pRifRef->cPublicRefs, &(pRifRef->ipid)));
    Win4Assert(pOXIDEntry);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // get the IRemUnknown for the remote server
    IRemUnknown *pRemUnk;
    HRESULT hr = GetRemUnk(&pRemUnk, pOXIDEntry);

    if (SUCCEEDED(hr))
    {
        hr = ((IRemUnknownN *)pRemUnk)->RemChangeRef(dwFlags, cRifRef, pRifRef);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "RemoteChangeRifRef hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   RemoteReleaseStdObjRef
//
//  Synopsis:   calls the remote server to release an ObjRef
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL RemoteReleaseStdObjRef(STDOBJREF *pStd, OXIDEntry *pOXIDEntry)
{
    ComDebOut((DEB_MARSHAL, "RemoteReleaseStdObjRef pStd:%x\n pOXIDEntry:%x",
              pStd, pOXIDEntry));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    REMINTERFACEREF rifRef;
    rifRef.ipid         = pStd->ipid;
    rifRef.cPublicRefs  = pStd->cPublicRefs;
    rifRef.cPrivateRefs = 0;

    // incase we get disconnected while in the RemRelease call
    // we need to extract the OXIDEntry and AddRef it.

    pOXIDEntry->IncRefCnt();
    RemoteReleaseRifRef(NULL, pOXIDEntry, 1, &rifRef);
    pOXIDEntry->DecRefCnt();

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "RemoteReleaseStdObjRef hr:%x\n", S_OK));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   RemoteReleaseObjRef
//
//  Synopsis:   calls the remote server to release an ObjRef
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL RemoteReleaseObjRef(OBJREF &objref)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return RemoteReleaseStdObjRef(&ORSTD(objref).std, GetOXIDFromObjRef(objref));
}

//+-------------------------------------------------------------------
//
//  Function:   GetOXIDFromObjRef, private
//
//  Synopsis:   extracts the OXID from the OBJREF.
//
//  History:    09-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
OXIDEntry *GetOXIDFromObjRef(OBJREF &objref)
{
    // TRICK: Internally we use the saResAddr.size field as the ptr
    // to the OXIDEntry. See ReadObjRef and FillObjRef.

    OXIDEntry *pOXIDEntry = (objref.flags & OBJREF_STANDARD)
                          ? *(OXIDEntry **)&ORSTD(objref).saResAddr
                          : (objref.flags & OBJREF_HANDLER)
                            ? *(OXIDEntry **)&ORHDL(objref).saResAddr
                            : *(OXIDEntry **)&OREXT(objref).saResAddr;

    Win4Assert(pOXIDEntry);
    return pOXIDEntry;
}

//+-------------------------------------------------------------------
//
//  Function:   IsValidObjRefHeader, private
//
//  Synopsis:   Ensures the OBJREF is at least semi-valid
//
//  History:    20-Apr-98  Rickhi       Created.
//
//--------------------------------------------------------------------
INTERNAL IsValidObjRefHeader(OBJREF &objref)
{
    if ((objref.signature != OBJREF_SIGNATURE) ||
        (objref.flags & OBJREF_RSRVD_MBZ)      ||
        (objref.flags == 0))
    {
        // the objref signature is bad, or one of the reserved
        // bits in the flags is set, or none of the required bits
        // in the flags is set. the objref cant be interpreted so
        // fail the call.

        return RPC_E_INVALID_OBJREF;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   WriteObjRef, private
//
//  Synopsis:   Writes the objref into the stream
//
//  History:    20-Feb-95  Rickhi       Created.
//
//--------------------------------------------------------------------
INTERNAL WriteObjRef(IStream *pStm, OBJREF &objref, DWORD dwDestCtx)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // The objref types are exclusive.
    // Make sure we detect anybody passing in a bad set of flags.

    DWORD dwTestFlags = objref.flags & (OBJREF_STANDARD | OBJREF_HANDLER | OBJREF_CUSTOM | OBJREF_EXTENDED);
    if (((dwTestFlags & OBJREF_STANDARD) && (dwTestFlags & ~OBJREF_STANDARD)) ||
        ((dwTestFlags & OBJREF_HANDLER)  && (dwTestFlags & ~OBJREF_HANDLER))  ||
        ((dwTestFlags & OBJREF_CUSTOM)   && (dwTestFlags & ~OBJREF_CUSTOM))   ||
        ((dwTestFlags & OBJREF_EXTENDED) && (dwTestFlags & ~OBJREF_EXTENDED)))
    {
        Win4Assert(!"WriteObjRef called with invalid objref flags!");
        return RPC_E_INVALID_OBJREF;
    }

    CObjectContext *pServerCtx = NULL;
    ULONG cbToWrite = (2*sizeof(ULONG)) + sizeof(IID) + sizeof(STDOBJREF);
    if(objref.flags & OBJREF_HANDLER)
    {
        cbToWrite += sizeof(CLSID);
    }

#ifndef _WIN64

    // We're a 32 bit process, so sizeof (DWORD) == sizeof (PVOID)
    // Use the same code we've always used
    else if(objref.flags & OBJREF_EXTENDED)
    {
        cbToWrite += sizeof(DWORD);
        pServerCtx = (CObjectContext *) OREXT(objref).pORData;
        Win4Assert(pServerCtx);
        if((dwDestCtx != MSHCTX_INPROC))// || (dwDestCtx != MSHCTX_CROSSCTX))
            OREXT(objref).pORData = (OBJREFDATA *) MARKER_SIGNATURE;
    }
#endif

    // write the fixed-sized part of the OBJREF into the stream
    HRESULT hr = pStm->Write(&objref, cbToWrite, NULL);

#ifdef _WIN64

    if(SUCCEEDED (hr) && (objref.flags & OBJREF_EXTENDED))
    {
        // We're a 64-bit process, so we have 8 byte pointers.
        // We're going to have a problem with the way the pORData
        // member is treated alternatively as a DWORD signature for
        // out-of-proc and a pointer for in-proc, because
        // on the receiving end we'll never be sure exactly how big
        // the incoming data actually is.
        //
        // We need to maintain compatibility with 32 bit W2K RTM, so
        // we can't break the wire format, which expects a 32 bit signature.
        // We can cheat, however, by changing the data in the stream
        // for the in-proc Win64 case.
        //
        // For the out-of-proc case, we'll write a DWORD with the
        // marker signature to the stream and both 32 and 64 bit recipients
        // will be happy.
        // If we're in proc, first we'll write out the high order DWORD of the
        // CObjectContext pointer, which will never be equal to the
        // 0x4E535956 signature. Then we'll write out the low-order DWORD.
        // The receiving end can then reconstruct the pointer if it doesn't
        // detect the signature.
        //
        // -mfeingol 8/20/1999

        pServerCtx = (CObjectContext *) OREXT(objref).pORData;
        Win4Assert(pServerCtx);

        if (dwDestCtx != MSHCTX_INPROC)
        {
            // Write the signature
            DWORD dwSignature = MARKER_SIGNATURE;
            hr = pStm->Write(&dwSignature, sizeof (DWORD), NULL);
        }
        else
        {
            // Write the two halves of the pointer
            DWORD* pdwPointer = (DWORD*) &pServerCtx;
            Win4Assert(*(pdwPointer + 1) != MARKER_SIGNATURE);
            hr = pStm->Write(pdwPointer + 1, sizeof (DWORD), NULL);
            if (SUCCEEDED(hr))
                hr = pStm->Write(pdwPointer, sizeof (DWORD), NULL);
        }
    }

#endif

    if (SUCCEEDED(hr))
    {

        // write the resolver address into the stream.
        // TRICK: Internally we use the saResAddr.size field as the ptr
        // to the OXIDEntry. See ReadObjRef and FillObjRef.

        DUALSTRINGARRAY *psa;
        OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);

        if (!(pOXIDEntry->IsOnLocalMachine()) ||
            dwDestCtx == MSHCTX_DIFFERENTMACHINE)
        {
            // the interface is for a remote server, or it is going to a
            // remote client, therefore, marshal the resolver strings.
            psa = pOXIDEntry->Getpsa();
			Win4Assert(psa);

			// PREFix Bug: 
			if (psa == NULL)
				psa = &saNULL;
			else
				Win4Assert(psa->wNumEntries != 0);
        }
        else
        {
            // the interface is for an OXID local to this machine and
            // the interface is not going to a remote client, marshal an
            // empty string (we pay attention to this in ReadObjRef)
            psa = &saNULL;
        }

        // These string bindings always come from the object exporter
        // who has already padded the size to 8 bytes.
        hr = pStm->Write(psa, SASIZE(psa->wNumEntries), NULL);

        ComDebOut((DEB_MARSHAL,"WriteObjRef psa:%x\n", psa));
    }

    if(objref.flags & OBJREF_EXTENDED)
    {
        if(SUCCEEDED(hr))
        {
            if((dwDestCtx == MSHCTX_INPROC))// || (dwDestCtx == MSHCTX_CROSSCTX))
            {
                // Addref the server context
                if(OREXT(objref).std.cPublicRefs)
                    pServerCtx->InternalAddRef();
            }
            else
            {
                DATAELEMENT *pCtxData = NULL;
                DWORD buffer[2];

                // Obtain context data from server context
                hr = pServerCtx->GetEnvoyData(&pCtxData);

                // Initialize
                buffer[0] = 1;
                if(pCtxData)
                    buffer[1] = MARKER_SIGNATURE;
                else
                    buffer[1] = NULL;

                // Write objref data
                hr = pStm->Write(buffer, 2*sizeof(DWORD), NULL);

                // Write data elements
                if(SUCCEEDED(hr))
                {
                    const ULONG ulHdrSize = sizeof(GUID) + 2*sizeof(ULONG);
                    if(pCtxData)
                    {
                        // Write element header
                        hr = pStm->Write(pCtxData, ulHdrSize, NULL);
                        if(SUCCEEDED(hr))
                        {
                            // Write element data
                            hr = pStm->Write(pCtxData->Data, pCtxData->cbSize,
                                             NULL);
                        }
                    }
                }
            }
        }

#ifndef _WIN64
        // Save back server context to objref
        OREXT(objref).pORData = (OBJREFDATA *) pServerCtx;
#endif
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ReadObjRefExtension, private
//
//  Synopsis:   Reads the extended objref extension from the stream
//
//  History:    18-Jan-99  Rickhi       Pulled from ReadObjRef.
//
//--------------------------------------------------------------------
INTERNAL ReadObjRefExtension(IStream *pStm, OBJREF &objref)
{
    HRESULT hr = S_OK;

    if (OREXT(objref).pORData == (OBJREFDATA *) MARKER_SIGNATURE)
    {
        // objref has extra data, go get it
        DATAELEMENT dataHdr, *pCtxData;
        ULONG nElms;
        CObjectContext *pServerCtx = NULL;

        // Read number of data elements
        hr = StRead(pStm, &nElms, sizeof(DWORD));
        if(SUCCEEDED(hr) && nElms>0)
        {
            // Allocate space for buffer on the stack
            DWORD *buffer = (DWORD *) _alloca(nElms*sizeof(DWORD));
            Win4Assert(buffer);

            // Read markers
            hr = StRead(pStm, buffer, nElms*sizeof(DWORD));
            if (SUCCEEDED(hr))
            {
                ULONG actualElms = 0;
                for (ULONG i=0; i<nElms; i++)
                {
                    if (buffer[i] == (DWORD) MARKER_SIGNATURE)
                        ++actualElms;
                }

                // Initialize
                Win4Assert(actualElms < 2);
                nElms = actualElms;

                // Allocate buffer to hold element header
                const ULONG ulHdrSize = sizeof(GUID) + 2*sizeof(ULONG);

                // Read data elements
                for (i=0; i<nElms; i++)
                {
                    // Read element header
                    hr = StRead(pStm, &dataHdr, ulHdrSize);
                    if(SUCCEEDED(hr))
                    {
                        // Allocate context data
                        pCtxData = (DATAELEMENT *) PrivMemAlloc(sizeof(DWORD) +
                                                                ulHdrSize +
                                                                dataHdr.cbRounded);
                        if(pCtxData)
                        {
                            // Initialize element header
                            pCtxData = (DATAELEMENT *) (((DWORD *) pCtxData) + 1);
                            pCtxData->dataID = dataHdr.dataID;
                            pCtxData->cbSize = dataHdr.cbSize;
                            pCtxData->cbRounded = dataHdr.cbRounded;

                            // Read element data
                            hr = StRead(pStm, pCtxData->Data, pCtxData->cbSize);
                            if (SUCCEEDED(hr))
                            {
                                // Ignore failures to create server context
                                pServerCtx = CObjectContext::CreateObjectContext(pCtxData,
                                                                                 CONTEXTFLAGS_ENVOYCONTEXT);
                                if (pServerCtx == NULL)
                                    hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }

                    if (FAILED(hr))
                        break;
                }
            }
        }

        // Initialize objref
        OREXT(objref).pORData = (OBJREFDATA *) pServerCtx;
    }
    else if (OREXT(objref).std.cPublicRefs == 0)
    {
        // objref has pointer to a context
        ((CObjectContext *) OREXT(objref).pORData)->InternalAddRef();
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ReadObjRef, private
//
//  Synopsis:   Reads the objref from the stream
//
//  History:    20-Feb-95  Rickhi       Created.
//
//--------------------------------------------------------------------
INTERNAL ReadObjRef(IStream *pStm, OBJREF &objref)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // read the signature, flags, and iid fields of the objref so we know
    // what kind of objref we are dealing with and how big it is.

    HRESULT hr = StRead(pStm, &objref, 2*sizeof(ULONG) + sizeof(IID));

    if (SUCCEEDED(hr))
    {
        hr = IsValidObjRefHeader(objref);
        if (FAILED(hr))
        {
            // the OBJREF signature or flags is invalid.
            Win4Assert(!"Invalid ObjRef");
            return hr;
        }

        // compute the size of the remainder of the objref and
        // include the size fields for the resolver string array

        STDOBJREF       *pStd = &ORSTD(objref).std;
        DUALSTRINGARRAY *psa;
        ULONG           cbToRead;

        if (objref.flags & OBJREF_STANDARD)
        {
            cbToRead = sizeof(STDOBJREF) + sizeof(ULONG);
            psa = &ORSTD(objref).saResAddr;
        }
        else if (objref.flags & OBJREF_HANDLER)
        {
            cbToRead = sizeof(STDOBJREF) + sizeof(CLSID) + sizeof(ULONG);
            psa = &ORHDL(objref).saResAddr;
        }
        else if (objref.flags & OBJREF_CUSTOM)
        {
            cbToRead = sizeof(CLSID) + 2*sizeof(DWORD);  // clsid + cbExtension + size
            psa = NULL;
        }
        else if (objref.flags & OBJREF_EXTENDED)
        {
#ifdef _WIN64
            // We don't want to read the pORData member directly into the struct,
            // because it could either be a 4 byte signature or the first 4 bytes of
            // an 8 byte CObjectContext pointer. So we leave it for custom handling later on
            // after which we'll read the two USHORT members of the saResAddr struct too.
            cbToRead = sizeof(STDOBJREF);
#else
            cbToRead = sizeof(STDOBJREF) + 2*sizeof(DWORD);
#endif
            psa = &OREXT(objref).saResAddr;
        }
        else
        {
            Win4Assert(!"Invalid Objref");
            return RPC_E_INVALID_OBJREF;
        }

        // read the rest of the (fixed sized) objref from the stream
        hr = StRead(pStm, pStd, cbToRead);

#ifdef _WIN64

        // If we're dealing with an extended OBJREF, we need to handle
        // the special case Win64 logic applied in WriteObjRef in order to
        // maintain wire format compatibility

        if (objref.flags & OBJREF_EXTENDED)
        {
            // Read the flag into a DWORD
            DWORD dwSignature;
            hr = StRead(pStm, &dwSignature, sizeof (DWORD));
            if (SUCCEEDED(hr))
            {
                if (dwSignature == MARKER_SIGNATURE)
                {
                    // Out-of-proc case: turn the pointer into a signature
                    OREXT(objref).pORData = (OBJREFDATA*) MARKER_SIGNATURE;
                }
                else
                {
                    // In-proc case: the DWORD we read is one half of the pointer
                    DWORD* pdwPointer = (DWORD*) &OREXT(objref).pORData;
                    pdwPointer[1] = dwSignature;

                    // Rebuilt the pointer with the other half
                    hr = StRead(pStm, pdwPointer, sizeof (DWORD));
                }

                if (SUCCEEDED(hr))
                {
                    // Read in the two USHORT's from the saResAddr that the 32 bit case
                    // has already read into the right place in the struct
                    hr = StRead(pStm, &OREXT(objref).saResAddr, 2*sizeof (USHORT));
                }
            }
        }
#endif

        if (SUCCEEDED(hr))
        {
            if (psa != NULL)
            {
                // Non custom interface. Make sure the resolver string array
                // has some sensible values.
                if (psa->wNumEntries != 0 &&
                    psa->wSecurityOffset >= psa->wNumEntries)
                {
                    hr = RPC_E_INVALID_OBJREF;
                }
            }
            else
            {
                // custom marshaled interface
                if (ORCST(objref).cbExtension != 0)
                {
                    // skip past the extensions since we currently dont
                    // know about any extension types.
                    LARGE_INTEGER dlibMove;
                    dlibMove.LowPart  = ORCST(objref).cbExtension;
                    dlibMove.HighPart = 0;
                    hr = pStm->Seek(dlibMove, STREAM_SEEK_CUR, NULL);
                }
            }
        }

        if (SUCCEEDED(hr) && psa)
        {
            // Non custom interface. The data that follows is a variable
            // sized string array. Allocate memory for it and then read it.

            DbgDumpSTD(pStd);
            DUALSTRINGARRAY *psaNew;
            CDualStringArray* pdsaLocalResolver = NULL;

            cbToRead = psa->wNumEntries * sizeof(WCHAR);
            if (cbToRead == 0)
            {
                // server must be local to this machine, just get the local
                // resolver strings and use them to resolve the OXID
                hr = gResolver.GetLocalResolverBindings(&pdsaLocalResolver);
                if (SUCCEEDED(hr))
                    psaNew = pdsaLocalResolver->DSA();
            }
            else
            {
                // allocate space to read the strings
                psaNew = (DUALSTRINGARRAY *) _alloca(cbToRead + sizeof(ULONG));
                if (psaNew != NULL)
                {
                    // update the size fields and read in the rest of the data
                    psaNew->wSecurityOffset = psa->wSecurityOffset;
                    psaNew->wNumEntries = psa->wNumEntries;

                    hr = StRead(pStm, psaNew->aStringArray, cbToRead);
                }
                else
                {
                    psa->wNumEntries     = 0;
                    psa->wSecurityOffset = 0;
                    hr = E_OUTOFMEMORY;

                    // seek the stream past what we should have read, ignore
                    // seek errors, since the OOM takes precedence.

                    LARGE_INTEGER libMove;
                    libMove.LowPart  = cbToRead;
                    libMove.HighPart = 0;
                    pStm->Seek(libMove, STREAM_SEEK_CUR, 0);
                }
            }

            // TRICK: internally we want to keep the ObjRef a fixed size
            // structure, even though we have variable sized data. To do
            // this i use the saResAddr.size field of the ObjRef as a ptr
            // to the OXIDEntry. We pay attention to this in FillObjRef,
            // WriteObjRef and FreeObjRef.

            if (SUCCEEDED(hr))
            {
                // resolve the OXID.
                OXIDEntry *pOXIDEntry = NULL;
                hr = gOXIDTbl.ClientResolveOXID(pStd->oxid,
                                                psaNew, &pOXIDEntry);
                *((void **) psa) = pOXIDEntry;
            }
            else
            {
                *((void **) psa) = NULL;
            }

            if (pdsaLocalResolver) pdsaLocalResolver->Release();
        }

        if (SUCCEEDED(hr) && (objref.flags & OBJREF_EXTENDED))
        {
            // Read extended objref data
            hr = ReadObjRefExtension(pStm, objref);
            if (FAILED(hr))
            {
                // release the resources already placed in the OBJREF
                // ie the RefCnt on the OXIDEntry.
                FreeObjRef(objref);
            }
        }
    }

    ComDebOut((DEB_MARSHAL,"ReadObjRef hr:%x objref:%x\n", hr, &objref));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   FreeObjRef, private
//
//  Synopsis:   Releases an objref that was read in from a stream via
//              ReadObjRef.
//
//  History:    20-Feb-95  Rickhi       Created.
//
//  Notes:      Anybody who calls ReadObjRef should call this guy to
//              free the objref. This decrements the refcnt on the
//              embedded pointer to the OXIDEntry.
//
//--------------------------------------------------------------------
INTERNAL_(void) FreeObjRef(OBJREF &objref)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (objref.flags & (OBJREF_STANDARD | OBJREF_HANDLER | OBJREF_EXTENDED))
    {
        // TRICK: Internally we use the saResAddr.size field as the ptr to
        // the OXIDEntry. See ReadObjRef, WriteObjRef and FillObjRef.

        OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
        Win4Assert(pOXIDEntry);
        pOXIDEntry->DecRefCnt();

        if (objref.flags & OBJREF_EXTENDED)
        {
            // Obtain the server context from objref
            CObjectContext *pServerCtx;
            pServerCtx = (CObjectContext *) OREXT(objref).pORData;
            if (pServerCtx)
                pServerCtx->InternalRelease();
        }
    }
}

//+-------------------------------------------------------------------
//
//  Function:   MakeFakeObjRef, private
//
//  Synopsis:   Invents an OBJREF that can be unmarshaled in this process.
//              The objref is partially fact (the OXIDEntry) and partially
//              fiction (the OID).
//
//  History:    16-Jan-96   Rickhi      Created.
//
//  Notes:      This is used by MakeSCMProxy and GetRemUnk. Note that
//              the pOXIDEntry is not AddRef'd here because the OBJREF
//              created is only short-lived the callers guarantee it's
//              lifetime, so FreeObjRef need not be called.
//
//--------------------------------------------------------------------
INTERNAL MakeFakeObjRef(OBJREF &objref, OXIDEntry *pOXIDEntry,
                        REFIPID ripid, REFIID riid)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // first, invent an OID since this could fail.
    STDOBJREF *pStd = &ORSTD(objref).std;
    HRESULT hr = gResolver.ServerGetReservedID(&pStd->oid);

    if (SUCCEEDED(hr))
    {
        pStd->flags           = SORF_NOPING | SORF_FREETHREADED ;
        pStd->cPublicRefs     = 1;
        pStd->ipid            = ripid;
        OXIDFromMOXID(pOXIDEntry->GetMoxid(), &pStd->oxid);

        // TRICK: Internally we use the saResAddr.size field as the ptr to
        // the OXIDEntry. See ReadObjRef, WriteObjRef and FillObjRef.

        OXIDEntry **ppOXIDEntry = (OXIDEntry **) &ORSTD(objref).saResAddr;
        *ppOXIDEntry = pOXIDEntry;

        objref.signature = OBJREF_SIGNATURE;
        objref.flags     = OBJREF_STANDARD;
        objref.iid       = riid;
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   CompleteObjRef, public
//
//  Synopsis:   Fills in the missing fields of an OBJREF from a STDOBJREF
//              and resolves the OXID. Also sets fLocal to TRUE if the
//              object was marshaled in this apartment.
//
//  History:    22-Jan-96   Rickhi  Created
//
//-------------------------------------------------------------------------
HRESULT CompleteObjRef(OBJREF &objref, OXID_INFO &oxidInfo, REFIID riid, BOOL *pfLocal)
{
    ComDebOut((DEB_MARSHAL, "CompleteObjRef objref:%x oxidInfo:%x\n", &objref, &oxidInfo));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    // tweak the objref so we can call ReleaseMarshalObjRef or UnmarshalObjRef
    objref.signature = OBJREF_SIGNATURE;
    objref.flags     = OBJREF_STANDARD;
    objref.iid       = riid;

    CDualStringArray* pdsaLocalResolver;
    OXIDEntry *pLocalOXIDEntry;
    GetLocalOXIDEntry(&pLocalOXIDEntry);
    MIDEntry *pMIDEntry = pLocalOXIDEntry->GetMIDEntry();
    Win4Assert(pMIDEntry);
    
    hr = gResolver.GetLocalResolverBindings(&pdsaLocalResolver);
    if (SUCCEEDED(hr))
    {
        OXIDEntry *pOXIDEntry = NULL;
        hr = gOXIDTbl.FindOrCreateOXIDEntry(ORSTD(objref).std.oxid,
                                   oxidInfo,
                                   FOCOXID_NOREF,
                                   pdsaLocalResolver->DSA(),
                                   gLocalMid,
                                   pMIDEntry,
                                   RPC_C_AUTHN_DEFAULT,  // default is okay since this is a server-side objref
                                   &pOXIDEntry);
        if (SUCCEEDED(hr))
        {
            OXIDEntry **ppOXIDEntry = (OXIDEntry **) &ORSTD(objref).saResAddr;
            *ppOXIDEntry = pOXIDEntry;
            *pfLocal = (pOXIDEntry == pLocalOXIDEntry);
        }
        pdsaLocalResolver->Release();
    }
	
    pMIDEntry->DecRefCnt();

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   FindAggStdMarshal, private
//
//  Synopsis:   Finds the CStdMarshal for the OID read from the stream
//
//  Arguements: [objref] - object reference
//              [ppStdMshl] - CStdMarshal returned, AddRef'd
//
//  Algorithm:  Read the objref, get the OID. If we already have an identity
//              for this OID, use that, otherwise either create an identity
//              object, or create a handler (which in turn will create the
//              identity).  The identity inherits CStdMarshal.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
INTERNAL FindAggStdMarshal(IStream *pStm, IMarshal **ppIM)
{
    ComDebOut((DEB_MARSHAL,
        "FindAggStdMarshal pStm:%x ppIM:%x\n", pStm, ppIM));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    *ppIM = NULL;       // NULL in case of error

    // remember the current stream seek ptr
    ULARGE_INTEGER lSeekCurr;
    LARGE_INTEGER  lSeekStart;
    lSeekStart.LowPart  = 0;
    lSeekStart.HighPart = 0;

    HRESULT hr = pStm->Seek(lSeekStart, STREAM_SEEK_CUR, &lSeekCurr);

    if (SUCCEEDED(hr))
    {
        // read the std objref for the handler
        OBJREF objref;
        hr = ReadObjRef(pStm, objref);

        if (SUCCEEDED(hr))
        {
            // find or create the handler aggregated with the std marshal
            CStdMarshal *pStdMarshal;
            hr = FindStdMarshal(objref, FALSE, &pStdMarshal, FALSE);

            if (SUCCEEDED(hr))
            {
                // tell the std marshaler that it is really an instance of
                // CLSID_AggStdMarshal
                pStdMarshal->SetAggStdMarshal();

                // find the outer object's IMarshal
                hr = pStdMarshal->QueryInterface(IID_IMarshal, (void **)ppIM);
                pStdMarshal->Release();
            }

            // release the objref we read
            FreeObjRef(objref);
        }

        // restore the stream seek ptr
        lSeekStart.LowPart = lSeekCurr.LowPart;
        pStm->Seek(lSeekStart, STREAM_SEEK_SET, NULL);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
        "FindAggStdMarshal hr:%x *ppIM:%x\n", hr, *ppIM));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   FindStdMarshal, private
//
//  Synopsis:   Finds the CStdMarshal for the OID read from the stream
//
//  Arguements: [objref] - object reference
//              [fLocal] - TRUE -> should be a local OID so if you don't
//                         find it, then don't bother creating the StdId.
//              [ppStdMshl] - CStdMarshal returned, AddRef'd
//
//  Algorithm:  Read the objref, get the OID. If we already have an identity
//              for this OID, use that, otherwise either create an identity
//              object, or create a handler (which in turn will create the
//              identity).  The identity inherits CStdMarshal.
//
//  History:    20-Feb-95   Rickhi      Created.
//              12-Nov-98   GopalK      Contexts related changes
//
//--------------------------------------------------------------------
INTERNAL FindStdMarshal(OBJREF &objref, BOOL fLocal, CStdMarshal **ppStdMshl, BOOL fLightNA)
{
    ComDebOut((DEB_MARSHAL,
        "FindStdMarshal objref:%x fLocal:%x ppStdMshl:%x\n", &objref, fLocal, ppStdMshl));

    HRESULT hr = IsValidObjRefHeader(objref);
    if (FAILED(hr))
    {
        // OBJREF is garbage
        *ppStdMshl = NULL;
        return hr;
    }

    // Assume not found
    CStdIdentity *pStdId = NULL;
    if (ChkIfLocalOID(objref, &pStdId, fLightNA))
    {
        // Server is in the current apartment
        if (pStdId)
        {
            hr = S_OK;
        }
        else
        {
            hr = CO_E_OBJNOTCONNECTED;
        }
    }
    else if (fLocal == FALSE)
    {
        // Server is in some other apartment.
        STDOBJREF *pStd = &ORSTD(objref).std;
        ComDebOut((DEB_MARSHAL, "poid: %x\n", &pStd->oid));

        OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
        MOID moid;
        MOIDFromOIDAndMID(pStd->oid, pOXIDEntry->GetMid(), &moid);

        CObjectContext *pCurrentCtx = GetCurrentContext();
        CObjectContext *pClientCtx  = NULL;
        CObjectContext *pServerCtx  = NULL;
        CPolicySet     *pPS         = NULL;

        // Eliminate the handler case
        hr = S_OK;
        if(!(objref.flags & OBJREF_HANDLER))
        {
            // Obtain client and server contexts
            if(objref.flags & OBJREF_EXTENDED)
            {
                // Cannot be an FTM aggregated server
                Win4Assert((pStd->flags & SORF_FTM) == 0);

                // Obtain server context from objref
                pServerCtx = (CObjectContext *) OREXT(objref).pORData;
                Win4Assert(pServerCtx);
                pClientCtx = pCurrentCtx;
            }
            else if(pCurrentCtx != GetEmptyContext())
            {
                // Current context is not the empty context
                pClientCtx = pCurrentCtx;
            }

            // Check for non empty client and server contexts
            if(pClientCtx || pServerCtx)
            {
                BOOL fCreate = TRUE;

                // Obtain the policy set between the client context
                // and server context
                hr = ObtainPolicySet(GetCurrentContext(), pServerCtx,
                                     PSFLAG_PROXYSIDE, &fCreate, &pPS);
            }
        }
        else
        {
            // Cannot be an FTM aggregated server
            Win4Assert((pStd->flags & SORF_FTM) == 0);
        }

        // Lookup the identity table for an existing proxy
        if(SUCCEEDED(hr))
        {
            DWORD dwAptId = (pStd->flags & SORF_FTM) ? NTATID : GetCurrentApartmentId();

            // Acquire the lock
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            hr = ObtainStdIDFromOID(moid, dwAptId, TRUE, &pStdId);

            UNLOCK(gComLock);
            if(FAILED(hr))
            {
				if (objref.flags & (OBJREF_STANDARD | OBJREF_EXTENDED))
				{
                    // Create an instance of the identity for this OID. We want
                    // to be holding the lock while we do this since it wont
                    // exercise any app code.
                    DWORD StdIdFlags = ((pStd->flags & SORF_FREETHREADED) || gEnableAgileProxies)
                                     ? STDID_CLIENT | STDID_FREETHREADED
                                     : STDID_CLIENT;

                    StdIdFlags |= (pStd->flags & SORF_FTM) ? STDID_FTM : 0;

                    hr = CreateIdentityHandler(NULL, StdIdFlags, pServerCtx, dwAptId,
                                               IID_IStdIdentity, (void **)&pStdId);
                    AssertOutPtrIface(hr, pStdId);

					if(SUCCEEDED(hr))
					{
						// Now that we've created it, get the lock and either set our new 
						// CStdIdentity in the OID table, or if another thread beat us to it, then
						// use theirs.
						
		                LOCK(gComLock);
		                CStdIdentity *pTempId = NULL;
		                HRESULT hrTemp = ObtainStdIDFromOID(moid, dwAptId, TRUE, &pTempId);
		                if(FAILED(hrTemp))
		                {
							// We are going to use ours, go ahead and set it, and then we are
							// done with the lock.
		                	hr = pStdId->SetOID(moid);
		                	UNLOCK(gComLock);
		                }
		                else
		                {
							// Be sure to release the lock before invoking the CStdIdentity destructor
		                	UNLOCK(gComLock);
		                	pStdId->Release();
		                	pStdId = pTempId;
		                }
					}
                }
                else
                {
                    Win4Assert(objref.flags & OBJREF_HANDLER);
                    Win4Assert(!(ORHDL(objref).std.flags & SORF_FREETHREADED));

                    // create an instance of the handler. the handler will
                    // aggregate in the identity.

                    hr = CreateClientHandler(ORHDL(objref).clsid, moid, dwAptId, &pStdId);
                }

            }

            ASSERT_LOCK_NOT_HELD(gComLock);
        }

        if(SUCCEEDED(hr))
        {
            // Sanity check
            Win4Assert(pServerCtx == pStdId->GetServerCtx());

            // Set the policy set
            if (pPS)
                hr = pStdId->SetClientPolicySet(pPS);
        }

        // Cleanup
        if (FAILED(hr))
        {
            if (pStdId)
                pStdId->Release();
            pStdId = NULL;
        }
        if (pPS)
            pPS->Release();
    }
    else
        hr = CO_E_OBJNOTCONNECTED;

    *ppStdMshl = (CStdMarshal *)pStdId;
    AssertOutPtrIface(hr, *ppStdMshl);

    ComDebOut((DEB_MARSHAL,
        "FindStdMarshal pStdMshl:%x hr:%x\n", *ppStdMshl, hr));
    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   StdMarshalObject   Private
//
//  Synopsis:   Standard marshals the specified interface on the given object
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
INTERNAL StdMarshalObject(IStream *pStm, REFIID riid, IUnknown *pUnk,
                          CObjectContext *pServerCtx, DWORD dwDestCtx,
                          void *pvDestCtx, DWORD mshlflags)
{
    TRACECALL(TRACE_MARSHAL, "StdMarshalObject");
    ComDebOut((DEB_MARSHAL,
               "StdMarshalObject pStm:%x riid:%I pUnk:%x dwDest:%x "
               "pvDest:%x flags:%x\n",
               pStm, &riid, pUnk, dwDestCtx, pvDestCtx, mshlflags));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Figure out what flags to pass.
    DWORD dwFlags = IDLF_CREATE;
    if (!(mshlflags & MSHLFLAGS_TABLEWEAK))
    {
        // HACKALERT:
        // If marshaling TABLEWEAK, don't add-then-remove a strong
        // connection, since many objects have a bogus implementation
        // of IExternalConnection that shuts down the object when the
        // last strong count goes to zero regardless of the value of
        // fLastReleaseCloses flag passed in.
        dwFlags |= IDLF_STRONG;
    }

    if (mshlflags & MSHLFLAGS_NOPING)
    {
        // turn off pinging to prevent rundown.
        dwFlags |= IDLF_NOPING;
    }

    if (mshlflags & MSHLFLAGS_AGILE)
    {
        // object is agile
        dwFlags |= IDLF_FTM;
    }

    if (mshlflags & MSHLFLAGS_NO_IEC)
    {
        // don't ask for IExternalConnection
        dwFlags |= IDLF_NOIEC;
    }

    CStdIdentity *pStdId;
    HRESULT hr = ObtainStdIDFromUnk(pUnk, GetCurrentApartmentId(),
                                    pServerCtx, dwFlags, &pStdId);

    if (SUCCEEDED(hr))
    {
        hr = pStdId->MarshalInterface(pStm, riid, pUnk, dwDestCtx,
                                      pvDestCtx, mshlflags);

        if (!(mshlflags & MSHLFLAGS_TABLEWEAK))
        {
            // If marshaling succeeded, removing the last strong connection
            // should keep the object alive. If marshaling failed,
            // removing the last strong connection should shut it down.

            BOOL fKeepAlive = (SUCCEEDED(hr)) ? TRUE : FALSE;
            pStdId->DecStrongCnt(fKeepAlive);
        }
        else
        {
            pStdId->Release();
        }
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL, "StdMarshalObject hr:%x\n", hr));
    return(hr);
}

//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::ServerObjectCallable   Private
//
//  Synopsis:   Computes the need to switch the context to call server object
//              Returns NULL if the object can be called in the current
//              context, otherwise it returns the context of the server.
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CObjectContext *CStdMarshal::ServerObjectCallable()
{
    ComDebOut((DEB_MARSHAL, "CStdMarshal::ServerObjectCallable this:%x\n", this));

    // Compute the need to switch
    CObjectContext *pDestCtx = NULL;
    if (ServerSide() && !SystemObject() && !FTMObject() && _pID)
    {
        CObjectContext *pCurrentCtx = GetCurrentContext();
        CObjectContext *pServerCtx  = _pID->GetServerCtx();

        // Compare contexts
        if (pServerCtx != pCurrentCtx)
            pDestCtx = pServerCtx;
    }

    ComDebOut((DEB_MARSHAL, "CStdMarshal::ServerObjectCallable returning 0x%x\n",
               pDestCtx));
    return(pDestCtx);
}

//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::SetClientPolicySet   Private
//
//  Synopsis:   Sets the client side policy set.  Basically, add the policy
//              set to our private list of policy sets that can be accessed
//              without taking a global lock.
//
//  History:    24-Feb-98   Gopalk      Created
//              17-Oct-00   JohnDoty    Made bounded, locked
//
//---------------------------------------------------------------------------
HRESULT CStdMarshal::SetClientPolicySet(CPolicySet *pPS)
{
    Win4Assert(ClientSide());
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Enter lock...
    EnterCriticalSection(&_csCtxEntry);

    // Lookup an existing context entry...
    CtxEntry *pEntry = NULL;
    if (_pCtxEntryHead)
    {
        // This will also garbage collect the list and remove dead entries.
        pEntry = CtxEntry::LookupEntry(_pCtxEntryHead, 
                                       pPS->GetClientContext(),
                                       &_pCtxFreeList, 
                                       CTXENTRYFLAG_IDENTRY | CTXENTRYFLAG_PRIVLOCKED);
    }

    // Create a context entry if not found
    if (pEntry == NULL)
    {
        // No entry, add a new one...
        pEntry = CtxEntry::GetFreeEntry(&_pCtxFreeList, CTXENTRYFLAG_PRIVLOCKED);
        if (pEntry == NULL)
        {
            pEntry = new CtxEntry();
            
            if (pEntry)
            {
                pEntry->_pNext = _pCtxEntryHead;
                _pCtxEntryHead = pEntry;
            }
        }
        
        if (pEntry)
        {
            pEntry->_pFree     = NULL;
            pEntry->_cRefs     = 0;
            pEntry->_pPS       = pPS;
            pPS->AddRef();
            
            pEntry->_pLife     = pPS->GetClientContext()->GetLife();
        }
    }

    // Leave lock...
    LeaveCriticalSection(&_csCtxEntry);

    return(pEntry ? S_OK : E_OUTOFMEMORY);
}

//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::GetClientPolicySet   Private
//
//  Synopsis:   Gets the client side policy set for the current context
//
//  History:    24-Feb-98   Gopalk      Created
//
//---------------------------------------------------------------------------
CPolicySet *CStdMarshal::GetClientPolicySet()
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    CPolicySet *pPS = NULL;

    if (_dwFlags & SMFLAGS_CLIENTPOLICYSET)
    {
        COleTls Tls;
        pPS = Tls->pPS;
    }
    else if (_pCtxEntryHead)
    {
        // Try to find the entry in our list... protected by our lock...
        EnterCriticalSection(&_csCtxEntry);
        
        CtxEntry *pEntry = CtxEntry::LookupEntry(_pCtxEntryHead, GetCurrentContext());

        LeaveCriticalSection(&_csCtxEntry);

        // Found it, return it...
        if (pEntry)
            pPS = pEntry->_pPS;
    }

    return(pPS);
}



//---------------------------------------------------------------------------
//
//  Function:   CStdMarshal::AllowForegroundTransfer Public
//
//  Synopsis:   Calls AllowSetForegroundWindow for the server PID
//              if it is on the local machine.
//
//  History:    02-Feb-99   MPrabhu     Created
//
//---------------------------------------------------------------------------
HRESULT CStdMarshal::AllowForegroundTransfer(void *lpvReserved)
{
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr=S_OK;

    if (ClientSide())
    {
        LOCK(gIPIDLock);
        IPIDEntry *pIPID = GetConnectedIPID();
        UNLOCK(gIPIDLock);
        if (pIPID)
        {
            if (pIPID->pOXIDEntry->IsOnLocalMachine())
            {
                if (!AllowSetForegroundWindow(pIPID->pOXIDEntry->GetPid()))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = CO_E_OBJNOTCONNECTED;
        }

    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\notify.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       notify.cxx
//
//  Contents:   Implements the notification window for starting RPC lazily
//              on Win95
//
//  History:    3-24-95   JohannP (Johann Posch)   Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <service.hxx>
#include    <locks.hxx>
#include    <chancont.hxx>

#ifdef _CHICAGO_
// Everything in this file is for W95 Only.


//+---------------------------------------------------------------------------
//
//  Function:   GetOleNotificationWnd
//
//  Synopsis:   returns the notification window where the process
//              can receive message to initialize e.g rpc
//
//  Effects:    The OleRpcNotification window is used to delay the initialize
//              of RPC. Each time an interface is marshalled, we return it
//              this pointer.
//
//  Returns:    NULL if the window cannot be created.
//
//  Arguments:  (none)
//
//  History:    3-23-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG GetOleNotificationWnd()
{
    if (IsMTAThread())
    {
        return(0); // MTA doesn't get a window
    }

    return((ULONG) GetOrCreateSTAWindow());
}

//+---------------------------------------------------------------------------
//
//  Method:     OleNotificationProc
//
//  Synopsis:   the ole notification windows proc receives
//              messages send by other apps initialize e.g rpc
//
//  Arguments:  [wMsg] --
//              [wParam] -- notification enum type
//              [lParam] --
//
//  Returns:
//
//  History:    3-23-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(LRESULT) OleNotificationProc(UINT wMsg, WPARAM wParam, LPARAM lParam)
{
#if 0
    LRESULT lr;

    CairoleDebugOut((DEB_ENDPNT, "OleNotificationProc: %x %lx\n", wParam, lParam));
    // On Win95 we lazily finish registering the server class object here
    lr = LazyFinishCoRegisterClassObject();
    CairoleDebugOut((DEB_ENDPNT, "OleNotificationProc done, returning: %x\n, lr"));
    return lr;
#else
    return (LRESULT) NOERROR;
#endif
}


//+---------------------------------------------------------------------------
//
//  Method:     NotifyToInitializeRpc
//
//  Synopsis:   Sends a notification message to server app to complete initialization
//              and get ready to receive RPC messages
//
//  Arguments:  [hwnd] --
//
//  Returns:
//
//  History:    3-23-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT NotifyToInitializeRpc(HWND hwnd)
{
    LRESULT lr;

    Win4Assert(hwnd);

    CairoleDebugOut((DEB_ENDPNT, "NotifyToInitializeRpc() hwnd:%d\n", hwnd));
    lr = SSSendMessage(hwnd, WM_OLE_ORPC_NOTIFY, WMSG_MAGIC_VALUE, 0);
    CairoleDebugOut((DEB_ENDPNT, "NotifyToInitializeRpc() done, lresult:%d\n", lr));

    return lr;
}

#endif // _CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\pgalloc.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       pagealloc.cxx
//
//  Contents:   Special fast allocator to allocate fixed-sized entities.
//
//  Classes:    CPageAllocator
//
//  History:    02-Feb-96   Rickhi      Created
//
//  Notes:      All synchronization is the responsibility of the caller.
//
//  CODEWORK:   faster list managment
//              free empty pages
//
//-------------------------------------------------------------------------
#include    <ole2int.h>
#include    <pgalloc.hxx>       // class def'n
#include    <locks.hxx>         // LOCK/UNLOCK


// Page Table constants for Index manipulation.
// The high 16bits of the PageEntry index provides the index to the page
// where the PageEntry is located. The lower 16bits provides the index
// within the page where the PageEntry is located.

#define PAGETBL_PAGESHIFT   16
#define PAGETBL_PAGEMASK    0x0000ffff


#define FREE_PAGE_ENTRY  (0xF1EEF1EE) // FreeEntry
#define ALLOC_PAGE_ENTRY (0xa110cced) // AllocatedEntry


// critical section to guard memory allocation
COleStaticMutexSem gPgAllocSListMutex;
BOOL               gfInterlocked64 = FALSE;

//+------------------------------------------------------------------------
//
//  Macro:      LOCK/UNLOCK_IF_NECESSARY
//
//  Synopsis:   Standin for LOCK/UNLOCK.
//
//  Notes:      This macro allows us to use the assert only when performing
//              on behalf of COM tables, and avoid it when used for shared
//              memory in the resolver which are protected by a different
//              locking mechanism.
//
//  History:    01-Nov-96   SatishT Created
//
//-------------------------------------------------------------------------
#define LOCK_IF_NECESSARY(lock);                 \
    if (lock != NULL)                           \
    {                                           \
        LOCK((*lock));                           \
    }

#define UNLOCK_IF_NECESSARY(lock);               \
    if (lock != NULL)                           \
    {                                           \
        UNLOCK((*lock));                         \
    }


//-------------------------------------------------------------------------
//
//  Function:   PushSList, public
//
//  Synopsis:   atomically pushes an entry onto a stack list
//
//  Notes:      Uses the InterlockedCompareExchange64 funcion if available
//              otherwise, uses critical section to guard state transitions.
//
//  History:    02-Oct-98   Rickhi      Created
//
//-------------------------------------------------------------------------
void PushSList(PageEntry *pListHead, PageEntry *pEntry, COleStaticMutexSem *pLock)
{
    if (gfInterlocked64)
    {
        // CODEWORK: Interlocked SList not implemented
        Win4Assert(!"This code not implemented yet");
    }
    else
    {
        LOCK_IF_NECESSARY(pLock);
        pEntry->pNext     = pListHead->pNext;
        pListHead->pNext  = pEntry;
        UNLOCK_IF_NECESSARY(pLock);
    }
}

//-------------------------------------------------------------------------
//
//  Function:   PopSList, public
//
//  Synopsis:   atomically pops an entry off a stack list
//
//  Notes:      Uses the InterlockedCompareExchange64 funcion if available
//              otherwise, uses critical section to guard state transitions.
//
//  History:    02-Oct-98   Rickhi      Created
//
//-------------------------------------------------------------------------
PageEntry *PopSList(PageEntry *pListHead, COleStaticMutexSem *pLock)
{
    PageEntry *pEntry;

    if (gfInterlocked64)
    {
        // CODEWORK: Interlocked SList not implemented
        Win4Assert(!"This code not implemented yet");
		pEntry = NULL;
    }
    else
    {
        LOCK_IF_NECESSARY(pLock);
        pEntry = pListHead->pNext;
        if (pEntry)
        {
            pListHead->pNext = pEntry->pNext;
        }
        UNLOCK_IF_NECESSARY(pLock);
    }

    return pEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::Initialize, public
//
//  Synopsis:   Initializes the page allocator.
//
//  Notes:      Instances of this class must be static since this
//              function does not init all members to 0.
//
//  History:    02-Feb-95   Rickhi      Created
//              25-Feb-97   SatishT     Added mem alloc/free function
//                                      parameters
//
//-------------------------------------------------------------------------
void CPageAllocator::Initialize(
                            LONG cbPerEntry,
                            LONG cEntriesPerPage,
                            COleStaticMutexSem *pLock,
                            DWORD dwFlags,
                            MEM_ALLOC_FN pfnAlloc,
                            MEM_FREE_FN  pfnFree
                            )
{
    ComDebOut((DEB_PAGE,
        "CPageAllocator::Initialize cbPerEntry:%x cEntriesPerPage:%x\n",
         cbPerEntry, cEntriesPerPage));

    Win4Assert(cbPerEntry >= sizeof(PageEntry));
    Win4Assert(cEntriesPerPage > 0);

    _cbPerEntry      = cbPerEntry;
    _cEntriesPerPage = cEntriesPerPage;

    _cPages          = 0;
    _cEntries        = 0;
    _dwFlags         = dwFlags;
    _pPageListStart  = NULL;
    _pPageListEnd    = NULL;

    _ListHead.pNext  = NULL;
    _ListHead.dwFlag = 0;

    _pLock           = pLock;
    _pfnMyAlloc      = pfnAlloc;
    _pfnMyFree       = pfnFree;
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::Cleanup, public
//
//  Synopsis:   Cleanup the page allocator.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CPageAllocator::Cleanup()
{
    ComDebOut((DEB_PAGE, "CPageAllocator::Cleanup _dwFlags = 0x%x\n", _dwFlags));
    LOCK_IF_NECESSARY(_pLock);

    if (_pPageListStart)
    {
        PageEntry **pPagePtr = _pPageListStart;
        while (pPagePtr < _pPageListEnd)
        {
            // release each page of the table
            _pfnMyFree(*pPagePtr);
            pPagePtr++;
        }

        // release the page list
        _pfnMyFree(_pPageListStart);

        // reset the pointers so re-initialization is not needed
        _cPages          = 0;
        _pPageListStart  = NULL;
        _pPageListEnd    = NULL;

        _ListHead.pNext  = NULL;
        _ListHead.dwFlag = 0;
    }

    UNLOCK_IF_NECESSARY(_pLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::AllocEntry, public
//
//  Synopsis:   Finds the first available entry in the table and returns
//              a ptr to it. Returns NULL if no space is available and it
//              cant grow the list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
PageEntry *CPageAllocator::AllocEntry(BOOL fGrow)
{
    ComDebOut((DEB_PAGE, "CPageAllocator::AllocEntry fGrow:%x\n", fGrow));

    // try to pop the first free one off the stack list head
    PageEntry *pEntry = PopSList(&_ListHead, _pLock);

    if (pEntry == NULL)
    {
        // no free entries
        if (fGrow)
        {
            // OK to try to grow the list
            pEntry = Grow();
        }

        if (pEntry == NULL)
        {
            // still unable to allocate more, return NULL
            return NULL;
        }
    }

    // count one more allocation
    InterlockedIncrement(&_cEntries);

#if DBG==1
    // In debug builds, try to detect two allocations of the
    // same entry. This is not 100% fool proof, but will mostly
    // assert correctly.
    Win4Assert(pEntry->dwFlag == FREE_PAGE_ENTRY);
    pEntry->dwFlag = ALLOC_PAGE_ENTRY;
#endif

    ComDebOut((DEB_PAGE, "CPageAllocator::AllocEntry _cEntries:%x pEntry:%x \n",
               _cEntries, pEntry));
    return pEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::ReleaseEntry, private
//
//  Synopsis:   returns an entry on the free list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CPageAllocator::ReleaseEntry(PageEntry *pEntry)
{
    ComDebOut((DEB_PAGE, "CPageAllocator::ReleaseEntry _cEntries:%x pEntry:%x\n",
               _cEntries, pEntry));
    Win4Assert(pEntry);

#if DBG==1
    // In Debug builds, try to detect second release
    // This is not 100% fool proof, but will mostly assert correctly
    Win4Assert(pEntry->dwFlag != FREE_PAGE_ENTRY);
    pEntry->dwFlag = FREE_PAGE_ENTRY;
#endif

    // count 1 less allocation
    InterlockedDecrement(&_cEntries);

    // push it on the free stack list
    PushSList(&_ListHead, pEntry, _pLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::ReleaseEntryList, private
//
//  Synopsis:   returns a list of entries to the free list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CPageAllocator::ReleaseEntryList(PageEntry *pFirst, PageEntry *pLast)
{
    ComDebOut((DEB_PAGE, "CPageAllocator::ReleaseEntryList pFirst:%x pLast:%x\n",
         pFirst, pLast));
    Win4Assert(pFirst);
    Win4Assert(pLast);

#if DBG==1
    // In Debug builds, try to detect second released of an entry.
    // This is not 100% fool proof, but will mostly assert correctly
    pLast->pNext    = NULL;
    PageEntry *pCur = pFirst;
    while (pCur)
    {
        Win4Assert(pCur->dwFlag != FREE_PAGE_ENTRY);
        pCur->dwFlag = FREE_PAGE_ENTRY;
        pCur = pCur->pNext;
    }
#endif

    LOCK_IF_NECESSARY(_pLock);

    // update the free list
    pLast->pNext    = _ListHead.pNext;
    _ListHead.pNext = pFirst;

    UNLOCK_IF_NECESSARY(_pLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::Grow, private
//
//  Synopsis:   Grows the table to allow for more Entries.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
PageEntry *CPageAllocator::Grow()
{
    // allocate a new page
    LONG cbPerPage = _cbPerEntry * _cEntriesPerPage;
    PageEntry *pNewPage = (PageEntry *) _pfnMyAlloc(cbPerPage);

    if (pNewPage == NULL)
    {
        return NULL;
    }

#if DBG==1
    // clear the page (only needed in debug)
    memset(pNewPage, 0xbaadbeef, cbPerPage);
#endif

    // link all the new entries together in a linked list and mark
    // them as currently free.
    PageEntry *pNextFreeEntry = pNewPage;
    PageEntry *pLastFreeEntry = (PageEntry *)(((BYTE *)pNewPage) + cbPerPage - _cbPerEntry);

    while (pNextFreeEntry < pLastFreeEntry)
    {
        pNextFreeEntry->pNext  = (PageEntry *)((BYTE *)pNextFreeEntry + _cbPerEntry);
        pNextFreeEntry->dwFlag = FREE_PAGE_ENTRY;
        pNextFreeEntry         = pNextFreeEntry->pNext;
    }

    // last entry has an pNext of NULL (end of list)
    pLastFreeEntry->pNext  = NULL;
    pLastFreeEntry->dwFlag = FREE_PAGE_ENTRY;


    // we may have to free these later if a failure happens below
    PageEntry * pPageToFree     = pNewPage;
    PageEntry **pPageListToFree = NULL;
    PageEntry * pEntryToReturn  = NULL;


    // CODEWORK: we face the potential of several threads growing the same
    // list at the same time. We may want to check the free list again after taking
    // the lock to decide whether to continue growing or not.
    LOCK_IF_NECESSARY(_pLock);

    // compute size of current page list
    LONG cbCurListSize = _cPages * sizeof(PageEntry *);

    // allocate a new page list to hold the new page ptr.
    PageEntry **pNewList = (PageEntry **) _pfnMyAlloc(cbCurListSize +
                                                       sizeof(PageEntry *));
    if (pNewList)
    {
        // copy old page list into the new page list
        memcpy(pNewList, _pPageListStart, cbCurListSize);

        // set the new page ptr entry
        *(pNewList + _cPages) = pNewPage;
        _cPages ++;

        // replace old page list with the new page list
        pPageListToFree = _pPageListStart;
        _pPageListStart = pNewList;
        _pPageListEnd   = pNewList + _cPages;

        // Since some entries may have been freed while we were growing,
        // chain the current free list to the end of the newly allocated chain.
        pLastFreeEntry->pNext  = _ListHead.pNext;

        // update the list head to point to the start of the newly allocated
        // entries (except we take the first entry to return to the caller).
        pEntryToReturn         = pNewPage;
        _ListHead.pNext        = pEntryToReturn->pNext;

        // don't free the allocated page
        pPageToFree            = NULL;
    }

    UNLOCK_IF_NECESSARY(_pLock);

    // free the allocated pages if needed.
    if (pPageToFree)
        _pfnMyFree(pPageToFree);

    if (pPageListToFree)
        _pfnMyFree(pPageListToFree);

    ComDebOut((DEB_PAGE, "CPageAllocator::Grow _pPageListStart:%x _pPageListEnd:%x pEntryToReturn:%x\n",
        _pPageListStart, _pPageListEnd, pEntryToReturn));

    return pEntryToReturn;
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::GetEntryIndex, public
//
//  Synopsis:   Converts a PageEntry ptr into an index.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
LONG CPageAllocator::GetEntryIndex(PageEntry *pEntry)
{
    for (LONG index=0; index<_cPages; index++)
    {
        PageEntry *pPage = *(_pPageListStart + index);  // get page ptr
        if (pEntry >= pPage)
        {
            if (pEntry < (PageEntry *) ((BYTE *)pPage + (_cEntriesPerPage * _cbPerEntry)))
            {
                // found the page that the entry lives on, compute the index of
                // the page and the index of the entry within the page.
                return (index << PAGETBL_PAGESHIFT) +
                       (ULONG) ((BYTE *)pEntry - (BYTE *)pPage) / _cbPerEntry;
            }
        }
    }

    // not found
    return -1;
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::IsValidIndex, private
//
//  Synopsis:   determines if the given DWORD provides a legal index
//              into the PageTable.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
BOOL CPageAllocator::IsValidIndex(LONG index)
{
    // make sure the index is not negative, otherwise the shift will do
    // sign extension. check for valid page and valid offset within page
    if ( (index >= 0) &&
         ((index >> PAGETBL_PAGESHIFT) < _cPages) &&
         ((index &  PAGETBL_PAGEMASK)  < _cEntriesPerPage) )
         return TRUE;

    // Don't print errors during shutdown.
    if (_cPages != 0)
        ComDebOut((DEB_ERROR, "IsValidIndex: Invalid PageTable Index:%x\n", index));
    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::GetEntryPtr, public
//
//  Synopsis:   Converts an entry index into an entry pointer
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
PageEntry *CPageAllocator::GetEntryPtr(LONG index)
{
    Win4Assert(index >= 0);
    Win4Assert(_cPages != 0);
    Win4Assert(IsValidIndex(index));

    PageEntry *pEntry = _pPageListStart[index >> PAGETBL_PAGESHIFT];
    pEntry = (PageEntry *) ((BYTE *)pEntry +
                            ((index & PAGETBL_PAGEMASK) * _cbPerEntry));
    return pEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     CPageAllocator::ValidateEntry, debug
//
//  Synopsis:   Verifies that the specified entry is in the range of
//              memory for this table.
//
//  Note:       The caller must lock the page allocator if necessary.
//
//  History:    15 Apr 98   AlexArm      Created
//
//-------------------------------------------------------------------------
#if DBG==1
void CPageAllocator::ValidateEntry( void *pEntry )
{
    Win4Assert( GetEntryIndex( (PageEntry *) pEntry ) != -1 );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\pstable.cxx ===
//+-------------------------------------------------------------------
//
//  File:       PSTable.cxx
//
//  Contents:   Support for Policy Sets
//
//  Functions:  CPolicySet methods
//              CPSTable methods
//
//  History:    20-Dec-97   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <chock.hxx>
#include <locks.hxx>
#include <stdid.hxx>
#include <context.hxx>
#include <pstable.hxx>
#include <ctxchnl.hxx>
#include <crossctx.hxx>
#include <rwlock.hxx>

//+-------------------------------------------------------------------
//
// Class globals
//
//+-------------------------------------------------------------------
CPageAllocator CPolicySet::s_PSallocator;   // Allocator for policy sets
CPageAllocator CPolicySet::s_PEallocator;   // Allocator for policy entries
BOOL           CPolicySet::s_fInitialized;  // Relied on being FALSE
DWORD          CPolicySet::s_cObjects;      // Relied on being ZERO

BOOL           CPSTable::s_fInitialized;    // Relied on being FALSE

// Hash Buckets for policy sets
SHashChain CPSTable::s_PSBuckets[NUM_HASH_BUCKETS] = {
    {&s_PSBuckets[0],  &s_PSBuckets[0]},
    {&s_PSBuckets[1],  &s_PSBuckets[1]},
    {&s_PSBuckets[2],  &s_PSBuckets[2]},
    {&s_PSBuckets[3],  &s_PSBuckets[3]},
    {&s_PSBuckets[4],  &s_PSBuckets[4]},
    {&s_PSBuckets[5],  &s_PSBuckets[5]},
    {&s_PSBuckets[6],  &s_PSBuckets[6]},
    {&s_PSBuckets[7],  &s_PSBuckets[7]},
    {&s_PSBuckets[8],  &s_PSBuckets[8]},
    {&s_PSBuckets[9],  &s_PSBuckets[9]},
    {&s_PSBuckets[10], &s_PSBuckets[10]},
    {&s_PSBuckets[11], &s_PSBuckets[11]},
    {&s_PSBuckets[12], &s_PSBuckets[12]},
    {&s_PSBuckets[13], &s_PSBuckets[13]},
    {&s_PSBuckets[14], &s_PSBuckets[14]},
    {&s_PSBuckets[15], &s_PSBuckets[15]},
    {&s_PSBuckets[16], &s_PSBuckets[16]},
    {&s_PSBuckets[17], &s_PSBuckets[17]},
    {&s_PSBuckets[18], &s_PSBuckets[18]},
    {&s_PSBuckets[19], &s_PSBuckets[19]},
    {&s_PSBuckets[20], &s_PSBuckets[20]},
    {&s_PSBuckets[21], &s_PSBuckets[21]},
    {&s_PSBuckets[22], &s_PSBuckets[22]}
};
CPSHashTable CPSTable::s_PSHashTbl;         // Hash table for policy sets
CPSTable gPSTable;                          // Global policy set table
CStaticRWLock gPSRWLock;                    // Reader-Writer lock protecting
                                            // policy sets
COleStaticMutexSem gPSLock;                 // Lock protecting allocators

// Externs used
extern CObjectContext *g_pMTAEmptyCtx;
extern CObjectContext *g_pNTAEmptyCtx;

#define CONTEXT_MAJOR_VERSION    0x00010000
#define CONTEXT_MINOR_VERSION    0x00000000
#define CONTEXT_VERSION          CONTEXT_MAJOR_VERSION | CONTEXT_MINOR_VERSION

// NOTE: Align the following structs on a 8-byte boundary
#define MAINHDRSIG     0x414E554B
typedef struct tagMainHeader
{
    unsigned long Signature;
    unsigned long Version;
    unsigned long cPolicies;
    unsigned long cbBuffer;
    unsigned long cbSize;
    long          hr;
    long          hrServer;
    long         reserved;
} MainHeader;

#define ENTRYHDRSIG   0x494E414E
typedef struct tagEntryHeader
{
    unsigned long Signature;
    unsigned long cbBuffer;
    unsigned long cbSize;
    long reserved;
    GUID policyID;
} EntryHeader;

void *CCtxCall::s_pAllocList[CTXCALL_CACHE_SIZE] = { NULL, NULL, NULL,
                                                     NULL, NULL, NULL,
                                                     NULL, NULL, NULL,
                                                     NULL };
int CCtxCall::s_iAvailable;   // Relied on being zero
COleStaticMutexSem CCtxCall::_mxsCtxCallLock;   // critical section

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::operator new     public
//
//  Synopsis:   new operator of context call object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CCtxCall::operator new(size_t size)
{
    void *pv = NULL;

    // Acquire lock
    LOCK(_mxsCtxCallLock);

    // Assert that cache cannot be more than full
    Win4Assert(s_iAvailable <= CTXCALL_CACHE_SIZE);

    // Check for previous process uninit
    if(s_iAvailable < 0)
        s_iAvailable = 0;

    // Check for availability in cache
    if(s_iAvailable > 0)
    {
        --s_iAvailable;
        pv = s_pAllocList[s_iAvailable];
        s_pAllocList[s_iAvailable] = NULL;
    }

    // Release lock
    UNLOCK(_mxsCtxCallLock);

    // Check if context call object was not allocated from the cache
    if(pv == NULL)
        pv = PrivMemAlloc(size);

    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::operator delete     public
//
//  Synopsis:   delete operator of context call object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxCall::operator delete(void *pv)
{
    // Acquire lock
    LOCK(_mxsCtxCallLock);

    // Assert that cache cannot be more than full
    Win4Assert(s_iAvailable <= CTXCALL_CACHE_SIZE);

#if DBG==1
    // Detect double deletion in debug builds
    for(int i = 0;i < s_iAvailable;i++)
        if(s_pAllocList[i] == pv)
            Win4Assert(!"CCtxCall being deleted twice");
#endif

    // Check if the cache is full
    if(s_iAvailable >= 0 && s_iAvailable < CTXCALL_CACHE_SIZE)
    {
        s_pAllocList[s_iAvailable++] = pv;
        pv = NULL;
    }

    // Release lock
    UNLOCK(_mxsCtxCallLock);

    // Check if context call object was not returned to cache
    if(pv)
        PrivMemFree(pv);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::Cleanup     public
//
//  Synopsis:   Cleanup allocator of context call objects
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxCall::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxsCtxCallLock);
    LOCK(_mxsCtxCallLock);

    // Free cached context call objects
    while(s_iAvailable > 0)
    {
        PrivMemFree(s_pAllocList[--s_iAvailable]);
        s_pAllocList[s_iAvailable] = NULL;
    }

    // Ensure that context call objects of canceled calls
    // are not cached for future use
    s_iAvailable = -1;

    UNLOCK(_mxsCtxCallLock);
    ASSERT_LOCK_NOT_HELD(_mxsCtxCallLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::QueryInterface
//
//  Synopsis:   ICallFrame::QueryInterface
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::QueryInterface(REFIID iid, LPVOID* ppv)
{
    if (iid == IID_IUnknown || iid == IID_ICallFrameWalker)
        *ppv = (ICallFrameWalker*)this;
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::AddRef
//
//  Synopsis:   ICallFrame::AddRef
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CCtxCall::AddRef()
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::Release
//
//  Synopsis:   ICallFrame::Release
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CCtxCall::Release()
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::OnWalkInterface
//
//  Synopsis:   ICallFrame::OnWalkInterface
//              This function implements the frame walker functionality
//              There are three types of frame walkers.
//              (1) Error frame walker which cleans up after any errors
//                  during walking of the frame
//              (2) Free frame walker which releases interface pointers
//              (3) Marshaling frame walker which marshals/unmarshals
//                  interface pointers
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::OnWalkInterface(REFIID riid, PVOID *ppvInterface,
                                       BOOL fIn, BOOL fOut)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    
    // The following section of code is used to keep track of [in, out]
    // interface pointers embedded in the DISPPARAMS argument of 
    // IDispatch::Invoke invoke calls.  In a nutshell, params packaged in
    // DISPPARAMS are implicitly [in, out], so they fall through our
    // check at interceptor creation time.  Therefore, we have to be
    // prepared to handle cases where the invoked method changes one of
    // the interface pointers somewhere in the DISPPARAMS.  The way we
    // do that is: 1) count the [in,out] interface pointers in the frame 
    // 2) allocate space for and copy all of the interface pointers into a 
    // vector 3) following Invoke, walk the frame again to Release any 
    // interface pointers that were changed.
    
    if(STAGE_COUNT & _dwStage)
    {
        // Walk initiator is responsible for resetting _cItfs before
        // counting interface pointers.
        // Count only [in,out] pointers.
        if (fIn && fOut)
        {
            ++_cItfs;
        }
        return hr;
    }
    else if (STAGE_COLLECT & _dwStage)
    {
        // Walk initiator is responsible for resetting _idx before
        // collecting interface pointers.  This stage will only get
        // executed when the _cItfs is non zero.
        // Collect only [in,out] pointers.
        if (fIn && fOut)
        {
            Win4Assert(_cItfs && _ppItfs);
            Win4Assert(_idx < _cItfs);
            _ppItfs[_idx] = *ppvInterface;
            _idx++;
        }
    }
        
    if(NULL == *ppvInterface)
        return hr;

    // If an error has occurred, any memory allocated upto this point
    // has to be released and any extra references have to be released
    if(_fError)
    {
        // Call an error handling function
        hr = ErrorHandler(riid, ppvInterface, fIn, fOut);
        return hr;
    }

    if(STAGE_FREE & _dwStage)
    {
        // This is called during the freeing of the frame and hence
        // the interface parameters need to be released
        ((IUnknown *)*ppvInterface)->Release();
        _cFree++;
    }
    else if ((STAGE_COPY & _dwStage) && FAILED(_hr))
    {
        // The copy process failed midway. We continue anyways,
        // and clean up at the end.
        *ppvInterface = NULL;
    }
    // Marshal
    else if(STAGE_MARSHAL & _dwStage)
        hr = MarshalItfPtrs(riid, ppvInterface, fIn, fOut);
    // Unmarshal
    else if(STAGE_UNMARSHAL & _dwStage)
        hr = UnmarshalItfPtrs(riid, ppvInterface, fIn, fOut);    
    else
    {
        hr = E_UNEXPECTED;
        Win4Assert(FALSE);
    }

    if((STAGE_COPY & _dwStage) && S_OK != hr)
    {
        // Set the failed hr during the copy stage so that
        // we can recover gracefully at the end of the copy stage
        if(SUCCEEDED(_hr))
        {
            // Only the first failure is stored
            _hr = hr;
        }
        // Return a successful hr so that the copy stage continues 
        // and we can free the copied frame entirely at the end of
        // the copy. If we return a failed hr here then the half copied
        // frame is thrown away without giving us a chance to cleanup
        hr = S_OK;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::ErrorHandler
//
//  Synopsis:   Recovers from errors which occurred during walking of frame
//              (1) STAGE_MARSHAL: Error occurred during marshaling
//                  [in] and [out] interface ptrs which are  marshaled
//                  are released. Extra references obtained during marshaling
//                  are released. Memory allocated for the interface data is
//                  released.
//              (2) STAGE_UNMARSHAL: Error occurred during unmarshaling
//                  [in] and [out] interface ptrs which are marshaled
//                  are released. Extra references obtained during
//                  unmarshaling are released.Memory allocated for the
//                  interface data is released.
//              (3) STAGE_FREE [in] interface pointers are released.
//                  There is no free stage for [out] interface pointers
//
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::ErrorHandler(REFIID riid, PVOID *ppvInterface, BOOL fIn,
                                    BOOL fOut)
{
    HRESULT hr = S_OK;

    // The error handling is done based on the stage
    switch(_dwStage)
    {
        case STAGE_MARSHAL:
        if(_cError < _cMarshalItfs)
        {
            InterfaceData* pData = (InterfaceData *)*ppvInterface;
            CXmitRpcStream stream(pData);

            // Release the reference  added while marshaling
            CoReleaseMarshalData(&stream);

            // Release the serialized buffer
            PrivMemFree(pData);
        }

        // NULL the [out] params
        if(fOut)
            *ppvInterface = NULL;

        // Increment the number of interface pointers handled
        _cError++;
        break;

    case STAGE_UNMARSHAL:
        // Sanity check
        Win4Assert(_cError <= _cMarshalItfs);
        Win4Assert(_cUnmarshalItfs <= _cMarshalItfs);

        // For all the interface ptrs that have been successfully
        // unmarshaled we should call a release
        if(_cError < _cUnmarshalItfs)
        {
            ((IUnknown *)*ppvInterface)->Release();
        }
        // For all interface ptrs yet to be unmarshaled
        // release any memory associated with them
        else
        {
            InterfaceData* pData = (InterfaceData *)*ppvInterface;
            CXmitRpcStream stream(pData);

            // Release the reference  added while marshaling
            CoReleaseMarshalData(&stream);

            // Release the serialized buffer
            PrivMemFree(pData);
        }

        // NULL the [out] params
        if(fOut)
            *ppvInterface = NULL;

        // Increment the number of interface pointers handled
        _cError++;
        break;

    case STAGE_FREE:
        if(fIn)
        {
            // For all the interface pointers that have not yet
            // been released, release them.
            if(_cError >= _cFree)
            {
                // Simply release the [in] pointer
                ((IUnknown *)*ppvInterface)->Release();
            }
            _cError++;
        }
        else
        {
            // There is no free stage for [out] pointers
            Win4Assert(FALSE && "Illegal free of [out] interface pointer\n");
        }
        break;

    default:
        hr = E_UNEXPECTED;
        Win4Assert(FALSE);
    }
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::MarshalItfPtrs
//
//  Synopsis:   Marshals Interface Pointers.
//              Determine the max size of the marshaled buffer and
//              call CoMarshalInterface.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::MarshalItfPtrs(REFIID riid, PVOID *ppvInterface, BOOL fIn,
                                       BOOL fOut)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    DWORD dwDestCtx = MSHCTX_CROSSCTX;
    void *pvDestCtx = NULL;
    DWORD mshlFlags = MSHLFLAGS_NORMAL;

    // Determine the maximum size of the marshaled buffer
    hr = CoGetMarshalSizeMax(&dwSize, riid, (IUnknown *)*ppvInterface,
                             dwDestCtx, pvDestCtx, mshlFlags);
    if(SUCCEEDED(hr))
    {
        CXmitRpcStream stream(dwSize);

        // Marshal the interface pointer
        hr = CoMarshalInterface(
                                &stream,
                                riid,
                                (IUnknown *)*ppvInterface,
                                dwDestCtx,
                                pvDestCtx,
                                mshlFlags
                                );

        if(SUCCEEDED(hr))
        {
            // Extract the buffer out of the stream
            InterfaceData* pData = NULL;
            stream.AssignSerializedInterface(&pData);

            // Point the interface pointer to the
            // marshaled buffer
            *ppvInterface = (LPVOID)pData;
            _cMarshalItfs++;
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::UnmarshalItfPtrs
//
//  Synopsis:   Unmarshals Interface Pointers.
//              Create a stream out of the buffer passed in and call
//              CoUnmarshalInterface on it.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::UnmarshalItfPtrs(REFIID riid, PVOID *ppvInterface, BOOL fIn,
                                       BOOL fOut)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity check
    Win4Assert(_cUnmarshalItfs <= _cMarshalItfs && 0 < _cMarshalItfs);

    HRESULT hr = S_OK;
    InterfaceData *pData = (InterfaceData *)*ppvInterface;

    CXmitRpcStream *pStm = new CXmitRpcStream(pData);
    if(NULL != pStm)
    {
        IUnknown *pUnk = NULL;
        // Unmarshal the interface pointer
        hr = CoUnmarshalInterface(pStm, riid, (void**)&pUnk);
        if(SUCCEEDED(hr))
        {
            // Point to the unmarshaled interface
            *ppvInterface= pUnk;

            // Release the serialized data buffer
            PrivMemFree(pData);

            // Increment the count of ptrs unmarshaled
            _cUnmarshalItfs++;
        }

        // Delete the stream object
        delete pStm;
    }
    else
        hr = E_OUTOFMEMORY;

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::Initialize     public
//
//  Synopsis:   Initializes allocators for policy sets
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::Initialize()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(gPSLock);

    // Acquire lock
    LOCK(gPSLock);

    // Initialize the allocators only if needed
    if(s_cObjects == 0 && !s_fInitialized)
    {
        s_PSallocator.Initialize(sizeof(CPolicySet), PS_PER_PAGE, NULL);
        s_PEallocator.Initialize(sizeof(PolicyEntry), PE_PER_PAGE, NULL);
    }

    // Mark the state as initialized
    s_fInitialized = TRUE;

    // Release lock
    UNLOCK(gPSLock);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::operator new     public
//
//  Synopsis:   new operator of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CPolicySet::operator new(size_t size)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::operator new\n"));

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gPSLock);
    LOCK(gPSLock);

    void *pv;

    // CPolicySet can be inherited only by those objects
    // with overloaded new and delete operators
    Win4Assert(size == sizeof(CPolicySet) &&
               "CPolicySet improperly inherited");

    // Make sure allocator is initialized
    Win4Assert(s_fInitialized);

    // Allocate memory
    pv = (void *) s_PSallocator.AllocEntry();
    if(pv)
        ++s_cObjects;

    // Release lock
    UNLOCK(gPSLock);

    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::operator delete     public
//
//  Synopsis:   delete operator of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::operator delete(void *pv)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::operator delete  pv:%x\n", pv));

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gPSLock);
    LOCK(gPSLock);

#if DBG==1
    // Ensure that the pv was allocated by the allocator
    // CPolicySet can be inherited only by those objects
    // with overloaded new and delete operators
    LONG index = s_PSallocator.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1);
#endif

    // Release policy entries
    CPolicySet *pPS = (CPolicySet *) pv;
    if(pPS->_cPolicies > 1)
        s_PEallocator.ReleaseEntryList((PageEntry *) pPS->_pFirstEntry,
                                       (PageEntry *) pPS->_pLastEntry);
    else if(pPS->_cPolicies == 1)
        s_PEallocator.ReleaseEntry((PageEntry *) pPS->_pFirstEntry);

    // Release the pointer
    s_PSallocator.ReleaseEntry((PageEntry *) pv);
    --s_cObjects;
    // Cleanup allocators if needed
    if(s_fInitialized==FALSE && s_cObjects==0)
    {
        s_PSallocator.Cleanup();
        s_PEallocator.Cleanup();
    }

    // Release writer lock
    UNLOCK(gPSLock);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::Cleanup     public
//
//  Synopsis:   Cleanup allocator of policy sets
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::Cleanup()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gPSLock);

    // Acquire lock
    LOCK(gPSLock);

    // Check if initialized
    if(s_fInitialized)
    {
        // Ensure that there are no policy sets
        if(s_cObjects == 0)
        {
            // Cleanup allocators
            s_PSallocator.Cleanup();
            s_PEallocator.Cleanup();
        }

        // State is no longer initialized
        s_fInitialized = FALSE;
    }

    // Release lock
    UNLOCK(gPSLock);

    ASSERT_LOCK_NOT_HELD(gPSLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::CPolicySet     public
//
//  Synopsis:   Constructor of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
CPolicySet::CPolicySet(DWORD dwFlags)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::CPolicySet this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    _dwFlags = dwFlags | PSFLAG_CACHED;
#ifdef ASYNC_SUPPORT
    _dwFlags |= PSFLAG_ASYNCSUPPORT;
#endif
    _cRefs = 1;
    _cPolicies = 0;
    _dwAptID = -2;
    _pClientCtx = NULL;
    _pServerCtx = NULL;
    _pFirstEntry = NULL;
    _pLastEntry = NULL;
    _PSCache.clientPSChain.pNext = NULL;
    _PSCache.clientPSChain.pPrev = NULL;
    _PSCache.serverPSChain.pNext = NULL;
    _PSCache.serverPSChain.pPrev = NULL;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::~CPolicySet     private
//
//  Synopsis:   Destructor of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
CPolicySet::~CPolicySet()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::~CPolicySet this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    // Sanity checks
    Win4Assert(_cRefs == 0);
    Win4Assert(IsCached());
    Win4Assert(IsMarkedForDestruction());
    Win4Assert(IsSafeToDestroy());
    Win4Assert(_pClientCtx==NULL);
    Win4Assert((_cPolicies != 0) == (_pFirstEntry != NULL));
    Win4Assert(_PSCache.clientPSChain.pNext == NULL);
    Win4Assert(_PSCache.clientPSChain.pPrev == NULL);
    Win4Assert(_PSCache.serverPSChain.pNext == NULL);
    Win4Assert(_PSCache.serverPSChain.pPrev == NULL);

    // Release any policy entries that might be present
    PolicyEntry *pEntry = _pFirstEntry;
    while(pEntry)
    {
        pEntry->pPolicy->Release();
#ifdef ASYNC_SUPPORT
        if(pEntry->pPolicyAsync)
            pEntry->pPolicyAsync->Release();
#endif
        pEntry = pEntry->pNext;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::QueryInterface     public
//
//  Synopsis:   QI behavior of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CPolicySet::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::QueryInterface this:%x riid:%I\n",
                    this, &riid));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) this;
    }
    else if(IsEqualIID(riid, IID_IPolicySet))
    {
        *ppv = (IPolicySet *) this;
    }
    else if(IsEqualIID(riid, IID_IStdPolicySet))
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // AddRef the interface before return
    if(*ppv)
        ((IUnknown *) (*ppv))->AddRef();

    ContextDebugOut((DEB_POLICYSET, "CPolicySet::QueryInterface this:%x hr:0x%x\n",
                     this, hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::AddRef     public
//
//  Synopsis:   AddRefs policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPolicySet::AddRef()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::AddRef this:%x cRefs:%x\n",
                    this, _cRefs+1));

    ULONG cRefs;

    // Increment ref count
    cRefs = InterlockedIncrement((LONG *)& _cRefs);

    // Always return 0 when inside the destructor
    if(_dwFlags & PSFLAG_INDESTRUCTOR)
    {
        // Nested AddRef
        cRefs = 0;
    }

    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::Release     public
//
//  Synopsis:   Release policy set. Gaurds against
//              double destruction that can happen if it aggregates
//              another object and gets nested AddRef and Release on
//              the thread invoking the destructor
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPolicySet::Release()
{
    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &_cRefs);

    // Check if this is the last release
    if(cRefs == 0)
        cRefs = DecideDestruction();
        
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Release this:%x cRefs:%x\n",
                     this, cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::AddPolicy     public
//
//  Synopsis:   Implements IPolicySet::AddPolicy method
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CPolicySet::AddPolicy(ContextEvent ctxEvent, REFGUID rguid,
                                   IPolicy *pUnk)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::AddPolicy this:%x pUnk:%x rguid:%I\n",
                    this, pUnk, &rguid));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = E_INVALIDARG;
    PolicyEntry *pEntry, *pNewEntry;
    IPolicy *pPolicy = NULL;
    BOOL fAdded = FALSE;

    // Validate arguments
    do
    {
        if((_dwFlags & PSFLAG_CLIENTSIDE) || (_dwFlags & PSFLAG_PROXYSIDE))
        {
            if(ctxEvent & SERVER_CTXEVENTS)
                break;
        }
        if((_dwFlags & PSFLAG_SERVERSIDE) && (_dwFlags & PSFLAG_STUBSIDE))
        {
            if(ctxEvent & CLIENT_CTXEVENTS)
                break;
        }

        if(ctxEvent & SERVER_ENTER_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_ENTER) ==
               !!(ctxEvent & CONTEXTEVENT_ENTERWITHBUFFER))
                break;
        }
        if(ctxEvent & SERVER_LEAVE_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_LEAVE) ==
               !!(ctxEvent & CONTEXTEVENT_LEAVEFILLBUFFER))
                break;
            if(ctxEvent & SERVER_EXCEPTION_CTXEVENTS)
                break;
        }
        else if(ctxEvent & SERVER_EXCEPTION_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_LEAVEEXCEPTION) ==
               !!(ctxEvent & CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER))
                break;
        }

        if(ctxEvent & CLIENT_CALL_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_CALL) ==
               !!(ctxEvent & CONTEXTEVENT_CALLFILLBUFFER))
                break;
        }
        if(ctxEvent & CLIENT_RETURN_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_RETURN) ==
               !!(ctxEvent & CONTEXTEVENT_RETURNWITHBUFFER))
                break;
            if(ctxEvent & CLIENT_EXCEPTION_CTXEVENTS)
                break;
        }
        else if(ctxEvent & CLIENT_EXCEPTION_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_RETURNEXCEPTION) ==
               !!(ctxEvent & CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER))
                break;
        }

        if(FAILED(pUnk->QueryInterface(IID_IPolicy, (void **) &pPolicy)))
            break;

        hr = S_OK;
    } while(FALSE);

    if(SUCCEEDED(hr))
    {
        // Check if the operation is allowed
        if(_dwFlags & PSFLAG_FROZEN)
        {
            hr = E_FAIL;
        }
        else
        {
            // Do not allow duplicate entries
            pEntry = _pFirstEntry;
            while(pEntry)
            {
                if((pEntry->policyID == rguid) && (pEntry->ctxEvent & ctxEvent))
                {
                    hr = E_INVALIDARG;
                    break;
                }

                pEntry = pEntry->pNext;
            }

            if(SUCCEEDED(hr))
            {
                // Allocte a new policy entry
                LOCK(gPSLock);
                pNewEntry = (PolicyEntry *) s_PEallocator.AllocEntry();
                UNLOCK(gPSLock);
                if(pNewEntry)
                {
                    pNewEntry->policyID = rguid;
                    pNewEntry->pPolicy = pPolicy;
#ifdef ASYNC_SUPPORT
                    pNewEntry->pPolicyAsync = NULL;
#endif
                    pNewEntry->ctxEvent = ctxEvent;
                    pNewEntry->pPrev = _pLastEntry;
                    pNewEntry->pNext = NULL;
                    if(_pFirstEntry)
                    {
                        Win4Assert(_pLastEntry);
                        _pLastEntry->pNext = pNewEntry;
                    }
                    else
                    {
                        Win4Assert(!_pLastEntry);
                        _pFirstEntry = pNewEntry;
                    }
                    _pLastEntry = pNewEntry;

                    if(ctxEvent & CLIENT_BUFFERCREATION_CTXEVENTS)
                        _dwFlags |= PSFLAG_CALLBUFFERS;
                    if(ctxEvent & CLIENT_CALL_CTXEVENTS)
                        _dwFlags |= PSFLAG_CALLEVENTS;
                    if(ctxEvent & (CLIENT_RETURN_CTXEVENTS | CLIENT_EXCEPTION_CTXEVENTS))
                        _dwFlags |= PSFLAG_RETURNEVENTS;
                    if(ctxEvent & SERVER_BUFFERCREATION_CTXEVENTS)
                        _dwFlags |= PSFLAG_LEAVEBUFFERS;
                    if(ctxEvent & SERVER_ENTER_CTXEVENTS)
                        _dwFlags |= PSFLAG_ENTEREVENTS;
                    if(ctxEvent & (SERVER_LEAVE_CTXEVENTS | SERVER_EXCEPTION_CTXEVENTS))
                        _dwFlags |= PSFLAG_LEAVEEVENTS;
                    ++_cPolicies;
                    fAdded = TRUE;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }
    }

    if(fAdded)
    {
        // Check if the policy object implements IPolicyAsync interface
#ifdef ASYNC_SUPPORT
        void *pv;
        HRESULT hr1 = pPolicy->QueryInterface(IID_IPolicyAsync, &pv);
        if(SUCCEEDED(hr1) && pv)
            pNewEntry->pPolicyAsync = (IPolicyAsync *) pv;
        else
            ResetAsyncSupport();
#endif
    }
    else if(pPolicy)
        pPolicy->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::AddPolicy this:%x hr: 0x%x\n",
                     this, hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::DeliverReleasePolicyEvents  public
//
//  Synopsis:   Called when the policy set is being marked as cached
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::DeliverReleasePolicyEvents()
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::DeliverReleasePolicyEvents this:%x\n",
                     this));

    // Sanity checks
    gPSRWLock.AssertNotHeld();
    Win4Assert(!IsSafeToDestroy());

#if DBG==1
    ULONG cPolicies = 0;
#endif
    // Deliver ReleasePolicy events if needed
    PolicyEntry *pEntry = _pFirstEntry;
    while(pEntry)
    {
        pEntry->pPolicy->ReleasePolicy();
        pEntry = pEntry->pNext;
#if DBG==1
        cPolicies++;
#endif
    }
    Win4Assert(_cPolicies == cPolicies);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::PrepareForDestruction     public
//
//  Synopsis:   Called when the policy set is about to be destroyed
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::Cache()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Cache this:%x\n", this));

    // Sanity checks
    gPSRWLock.AssertNotHeld();
    Win4Assert(!IsSafeToDestroy());

    // Acquire writer lock
    gPSRWLock.AcquireWriterLock();

    // Another thread could have uncached the policy set
    // while this thread was delivering release policy set
    // events
    CObjectContext *pServerCtx = NULL;
    BOOL fDelete = FALSE;
    if (IsCached())
    {
        // Save the server context in a local variable
        // NOTE: Do not NULL the context ptrs as they will be
        //       AddRef'd when the policyset gets uncached.
        pServerCtx = _pServerCtx;

        // Now it is safe to destroy this object
        SafeToDestroy();

        // Check for the need to delete this policy set
        fDelete = (_cRefs == 0) && IsMarkedForDestruction();
    }

    // Release writer lock
    gPSRWLock.ReleaseWriterLock();

    // Release the server context
    if(pServerCtx)
        pServerCtx->InternalRelease();

    // Delete this policy set if necessary
    if(fDelete)
        delete this;

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::DeliverAddrefPolicyEvents     public
//
//  Synopsis:   Called when the policy set is being removed from the
//              cache
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::DeliverAddRefPolicyEvents()
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::DeliverAddRefPolicyEvents this:%x\n", this));

    // Sanity check
    gPSRWLock.AssertNotHeld();

#if DBG==1
    ULONG cPolicies = 0;
#endif
    PolicyEntry *pEntry = _pFirstEntry;
    while(pEntry)
    {
        pEntry->pPolicy->AddRefPolicy();
        pEntry = pEntry->pNext;
#if DBG==1
        cPolicies++;
#endif
    }
    Win4Assert(_cPolicies == cPolicies);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::Uncache     public
//
//  Synopsis:   Called when the policy set is being removed from the
//              cache
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CPolicySet::Uncache()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Uncache this:%x\n", this));

    // Sanity check
    gPSRWLock.AssertNotHeld();

    // Addref the server context
    if (_pServerCtx)
        _pServerCtx->InternalAddRef();

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::GetSize    private
//
//  Synopsis:   This method is called from inside GetBuffer method
//              before calling CXXXRpcChnl::GetBuffer method
//
//              This method obtains the size of buffer that needs to be
//              allocated for polices that exchange buffers with their
//              counterparts. It updates the cbBuffer field inside
//              RPCOLEMESSAGE to reflect the new size
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CPolicySet::GetSize(CRpcCall *pCall, EnumCallType eCallType,
                            CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::GetSize this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hrRet, hrCall;
    PolicyEntry *pEntry;
    ContextEvent ctxEvent;
    ULONG cPolicies, cbHeader, cbTotal, cb;
    BOOL fClientSide = TRUE;
    BOOL fBuffers;

    // Assert that the policy set is frozen
    Win4Assert(_dwFlags & PSFLAG_FROZEN);

    // Check COM version for downlevel interop
    hrRet = S_OK;

    // Ensure that this is the first invocation for this call
    if(!(pCtxCall->_dwFlags & CTXCALLFLAG_GBINIT))
    {
        // Main header will always be present
        cbHeader = sizeof(MainHeader);
        cPolicies = 0;
        cbTotal = 0;
        fBuffers = FALSE;

        // Check for any policies
        if(_cPolicies || (pCtxCall->_hrServer != S_OK))
        {
            // Initialize
            Win4Assert((_cPolicies) ? TRUE : _pFirstEntry == NULL);
            pEntry = _pFirstEntry;
            switch(eCallType)
            {
#ifdef CONTEXT_ASYNCSUPPORT
            case CALLTYPE_BEGINCALL:
                if(_dwFlags & PSFLAG_CLIENTBUFFERS)
                {
                    fBuffers = TRUE;
                    ctxEvent = CONTEXTEVENT_BEGINCALLFILLBUFFER;
                }
                fClientSide = TRUE;
                break;

            case CALLTYPE_FINISHLEAVE:
                if(_dwFlags & PSFLAG_SERVERBUFFERS)
                {
                    fBuffers = TRUE;
                    ctxEvent = CONTEXTEVENT_FINISHLEAVEFILLBUFFER;
                    if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                        ctxEvent |= CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER;
                }
                fClientSide = FALSE;
                break;
#endif
            case CALLTYPE_SYNCCALL:
                if(_dwFlags & PSFLAG_CALLBUFFERS)
                {
                    fBuffers = TRUE;
                    ctxEvent = CONTEXTEVENT_CALLFILLBUFFER;
                }
                fClientSide = TRUE;
                break;

            case CALLTYPE_SYNCLEAVE:
                if(_dwFlags & PSFLAG_LEAVEBUFFERS)
                {
                    fBuffers = TRUE;
                    ctxEvent = CONTEXTEVENT_LEAVEFILLBUFFER;
                    if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                        ctxEvent |= CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER;
                }
                fClientSide = FALSE;
                break;

            default:
                Win4Assert(FALSE);
				return E_UNEXPECTED;
            }
            // Assert that current side matches the policy set
            Win4Assert(!(_dwFlags & PSFLAG_PROXYSIDE) || fClientSide || IsThreadInNTA());
            Win4Assert(!(_dwFlags & PSFLAG_STUBSIDE) || !fClientSide || IsThreadInNTA());

            while(pEntry && fBuffers)
            {
                // Check if the policy wishes to participate in
                // buffer creation events
                if(pEntry->ctxEvent & ctxEvent)
                {
                    // Get buffer size from the policy
                    switch(eCallType)
                    {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_BEGINCALL:
                        hrCall = pEntry->pPolicyAsync->BeginCallGetSize(pCall, &cb);
                        break;

                    case CALLTYPE_FINISHLEAVE:
                        hrCall = pEntry->pPolicyAsync->FinishLeaveGetSize(pCall, &cb);
                        break;
#endif
                    case CALLTYPE_SYNCCALL:
                        hrCall = pEntry->pPolicy->CallGetSize(pCall, &cb);
                        break;

                    case CALLTYPE_SYNCLEAVE:
                        hrCall = pEntry->pPolicy->LeaveGetSize(pCall, &cb);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                    }

                    if(SUCCEEDED(hrCall))
                    {
                        if(cb > 0)
                        {
                            // Round up the size to a 8-byte boundary
                            cb = (cb + 7) & ~7;

                            // Add to the total
                            cbTotal += cb;
                            ++cPolicies;
                        }
                    }
                    else
                    {
                        ContextDebugOut((DEB_WARN,
                                        "GetSize for policyID:%I returned hr:0x%x\n",
                                        &pEntry->policyID, hrCall));
                        pCall->Nullify(hrCall);
                    }
                }

                // Get the next policy
                pEntry = pEntry->pNext;
            }

            // Allocate space for entry headers
            if(cPolicies)
                cbHeader += cPolicies*sizeof(EntryHeader);
        }

        // Obtain latest call status
        hrCall = pCall->GetHResult();

        // Compute the return status
        // REVIEW: If a serverside policy decides to send buffer 
	// (ie cbTotal!=0) *and* fail the call, then downlevel (NT4 etc)
	// clients will choke. Fortunately, we don't have any such
	// policies yet. But beware.
	
	if(fClientSide || cbTotal==0) 
            hrRet = hrCall;

        // Check for the need to send data.  Since the server's true
        // HRESULT is required by COM+ services, we must always send
        // back at least the main header.
        if(((cbTotal > 0) || (pCtxCall->_hrServer != S_OK)) && SUCCEEDED(hrRet))
        {
            // Assert that cbExtent is 8-byte aligned
            Win4Assert(!(cbHeader & 7) && "Extent size not a multiple of 8");
            // Assert that cbTotal is 8-byte aligned
            Win4Assert(!(cbTotal & 7) && "Request size not a multiple of 8");

            // Update context call object
            pCtxCall->_cPolicies = cPolicies;
            pCtxCall->_cbExtent = cbHeader + cbTotal;
        }

        // Update flags of context call object
        pCtxCall->_dwFlags |= CTXCALLFLAG_GBINIT;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::GetSize this:%x hr:0x%x\n",
                     this, hrRet));
    return(hrRet);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::FillBuffer    private
//
//  Synopsis:   This method is called from inside SendReceive on the
//              client side before calling CXXXRpcChnl::SendReceive
//              and AppInvoke on the server side after the call
//              returns from the stub
//
//              This method puts the policy headers and obtains buffers
//              from the policies which are delivered to their
//              counterparts on the other side.
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CPolicySet::FillBuffer(CRpcCall *pCall, EnumCallType eCallType,
                               CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::FillBuffer this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hrRet, hr1;
    RPCOLEMESSAGE *pMessage;
    PolicyEntry *pEntry;
    ContextEvent ctxEvent, ctxBufEvent;
    ULONG cPolicies, cbHeader, cbData, cbTotal, cb;
    MainHeader *pMainHeader;
    EntryHeader *pEntryHeader;
    void *pvBuffer;
    BOOL fClientSide;

    // Assert that the policy set is frozen
    Win4Assert(_dwFlags & PSFLAG_FROZEN);

    // Initialize
    hrRet = S_OK;

    // Check for downlevel interop
    if(pCtxCall->_pvExtent && !(pCtxCall->_dwFlags & CTXCALLFLAG_FBDONE))
    {
        // Get the message
        pMessage = pCall->GetMessage();

        // Compute cbHeader and cbData
        cbHeader = sizeof(MainHeader) +
                   pCtxCall->_cPolicies*sizeof(EntryHeader);
        cbData = pCtxCall->_cbExtent - cbHeader;

        // Initialize Main header
        pMainHeader = (MainHeader *) pCtxCall->_pvExtent;
        pMainHeader->Signature = MAINHDRSIG;
        pMainHeader->Version = CONTEXT_VERSION;
        pMainHeader->cbBuffer = pMessage->cbBuffer;
        pMainHeader->cbSize = cbHeader;
        pMainHeader->hrServer = pCtxCall->_hrServer;
        pMainHeader->reserved = NULL;

        // Initialize entry header
        pEntryHeader = (EntryHeader *) (pMainHeader + 1);

        // Seek past proxy/stub data
        pvBuffer = (BYTE *) pMainHeader + cbHeader;
        Win4Assert(!(((ULONG_PTR) pvBuffer) & 7) &&
                   "Buffer is not 8-byte aligned");

        // Loop through policy entries
        cbTotal = 0;
        cPolicies = 0;
        switch(eCallType)
        {
#ifdef CONTEXT_ASYNCSUPPORT
        case CALLTYPE_BEGINCALL:
            ctxEvent = CONTEXTEVENT_BEGINCALL;
            ctxBufEvent = CONTEXTEVENT_BEGINCALLFILLBUFFER;
            fClientSide = TRUE;
            break;

        case CALLTYPE_FINISHLEAVE:
            ctxEvent = CONTEXTEVENT_FINISHLEAVE;
            ctxBufEvent = CONTEXTEVENT_FINISHLEAVEFILLBUFFER;
            fClientSide = FALSE;
            break;
#endif
        case CALLTYPE_SYNCCALL:
            Win4Assert(_dwFlags & PSFLAG_CALLEVENTS || pCtxCall->_hrServer);
            ctxEvent = CONTEXTEVENT_CALL;
            ctxBufEvent = CONTEXTEVENT_CALLFILLBUFFER;
            fClientSide = TRUE;
            break;

        case CALLTYPE_SYNCLEAVE:
            Win4Assert(_dwFlags & PSFLAG_LEAVEEVENTS || pCtxCall->_hrServer);
            ctxEvent = CONTEXTEVENT_LEAVE;
            ctxBufEvent = CONTEXTEVENT_LEAVEFILLBUFFER;
            if(pCall->GetHResult() == RPC_E_SERVERFAULT)
            {
                ctxEvent |= CONTEXTEVENT_LEAVEEXCEPTION;
                ctxBufEvent |= CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER;
            }
            fClientSide = FALSE;
            break;
#if DBG==1
        default:
            Win4Assert(FALSE);
#endif
        }
        if(fClientSide)
        {
            pEntry = _pFirstEntry;
        }
        else
        {
            pEntry = _pLastEntry;
            pCall->SetServerHR(pCtxCall->_hrServer);
        }

        // Assert that current side matches the policy set
        Win4Assert(!(_dwFlags & PSFLAG_PROXYSIDE) || fClientSide || IsThreadInNTA());
        Win4Assert(!(_dwFlags & PSFLAG_STUBSIDE) || !fClientSide || IsThreadInNTA());

        while(pEntry)
        {
            // Check if the policy wishes to participate in
            // buffer creation events
            if(pEntry->ctxEvent & ctxBufEvent)
            {
                // Sanity check
                Win4Assert( pvBuffer != NULL );
                Win4Assert(!(pEntry->ctxEvent & ctxEvent));

                // Get buffer from the policy
                switch(eCallType)
                {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_BEGINCALL:
                        hr1 = pEntry->pPolicyAsync->BeginCallFillBuffer(pCall,
                                                                        pvBuffer,
                                                                        &cb);
                        break;

                    case CALLTYPE_FINISHLEAVE:
                        hr1 = pEntry->pPolicyAsync->FinishLeaveFillBuffer(pCall,
                                                                          pvBuffer,
                                                                          &cb);
                        break;
#endif
                    case CALLTYPE_SYNCCALL:
                        hr1 = pEntry->pPolicy->CallFillBuffer(pCall,
                                                              pvBuffer,
                                                              &cb);
                        break;

                    case CALLTYPE_SYNCLEAVE:
                        hr1 = pEntry->pPolicy->LeaveFillBuffer(pCall,
                                                               pvBuffer,
                                                               &cb);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                }

                if(SUCCEEDED(hr1))
                {
                    if(cb > 0)
                    {
                        if(cPolicies < pCtxCall->_cPolicies &&
                           cbTotal+((cb + 7) & ~7) <= cbData)
                        {
                            // Update entry header
                            pEntryHeader->Signature = ENTRYHDRSIG;
                            pEntryHeader->cbBuffer = cb;
                            pEntryHeader->cbSize = (ULONG) ((BYTE *) pvBuffer -
                                                   (BYTE *) pMainHeader);
                            pEntryHeader->reserved = NULL;
                            pEntryHeader->policyID = pEntry->policyID;

                            // Sanity check
                            Win4Assert(!(pEntryHeader->cbSize & 7) &&
                                       "cbSize not a multiple of 8");

                            // Round up the size to a 8-byte boundary
                            cb = (cb + 7) & ~7;

                            // Skip to next entry header
                            ++pEntryHeader;

                            // Update Buffer pointer for next policy
                            pvBuffer = (BYTE *) pvBuffer + cb;
                            Win4Assert(!(((ULONG_PTR) pvBuffer) & 7) &&
                                       "Buffer is not 8-byte aligned");

                            // Add to the total
                            cbTotal += cb;
                            ++cPolicies;
                        }
                        else
                        {
                            Win4Assert(!"FillBuffer events > GetSize events");
                            ContextDebugOut((DEB_WARN,
                                             "Either more Policies "
                                             "participated in FillBuffer "
                                             "events than GetSize events "
                                             "\nOR\n Buffer length requested "
                                             "in GetSize was exceeded\n"));
                            hr1 = pCall->Nullify(E_FAIL);
                            Win4Assert(hr1 == S_OK);
                            break;
                        }
                    }
                }
            }
            else if(pEntry->ctxEvent & ctxEvent)
            {
                switch(eCallType)
                {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_BEGINCALL:
                        hr1 = pEntry->pPolicyAsync->BeginCall(pCall);
                        break;

                    case CALLTYPE_FINISHLEAVE:
                        hr1 = pEntry->pPolicyAsync->FinishLeave(pCall);
                        break;
#endif
                    case CALLTYPE_SYNCCALL:
                        hr1 = pEntry->pPolicy->Call(pCall);
                        break;

                    case CALLTYPE_SYNCLEAVE:
                        hr1 = pEntry->pPolicy->Leave(pCall);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                }
            }
            else
                hr1 = S_OK;

            if(FAILED(hr1))
            {
                ContextDebugOut((DEB_WARN,
                                 "FillBuffer for policyID:%I returned hr:0x%x\n",
                                 &pEntry->policyID, hr1));
                hr1 = pCall->Nullify(hr1);
                Win4Assert(hr1 == S_OK);
            }

            // Get the next policy
            if(fClientSide)
                pEntry = pEntry->pNext;
            else
                pEntry = pEntry->pPrev;
        }
        Win4Assert(cPolicies <= pCtxCall->_cPolicies);
        if(cPolicies < pCtxCall->_cPolicies)
            ContextDebugOut((DEB_WARN,
                             "%2d policies participated in FillBuffer events "
                             "as opposed to %2d policies that participated "
                             "in GetSize events\n",
                             cPolicies, pCtxCall->_cPolicies));
        Win4Assert(cbTotal <= cbData);
        if(cbTotal < cbData)
            ContextDebugOut((DEB_WARN,
                             "%3d bytes supplied in FillBuffer events as "
                             "opposed to %3d bytes requested in GetSize events\n",
                             cbTotal, cbData));

        // Update main header
        pMainHeader->cPolicies = cPolicies;
        if(fClientSide)
        {
            pMainHeader->hr = S_OK;
            hrRet = pCall->GetHResult();
        }
        else
        {
            pMainHeader->hr = pCall->GetHResult();
	    
	    // REVIEW: If a serverside policy decides to send buffer 
	    // (ie cbTotal!=0) *and* fail the call, then downlevel (NT4 etc)
	    // clients will choke. Fortunately, we don't have any such
	    // policies yet. But beware.
	    
	    if(cbTotal == 0) 
                hrRet = pMainHeader->hr;
        }

        // Update context call object
        pCtxCall->_dwFlags |= CTXCALLFLAG_FBDONE;

        // Assert that buffer is 8-byte aligned
        Win4Assert(!(((ULONG_PTR) pMessage->Buffer) & 7) &&
                   "Buffer not 8-byte aligned");
    }
    else
    {
        // Downlevel interop or Failed call
        hrRet = DeliverEvents(pCall, eCallType, pCtxCall);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::FillBuffer this:%x hr:0x%x\n",
                     this, hrRet));
    return(hrRet);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::Notify    private
//
//  Synopsis:   This method is called from inside SendReceive on the
//              client side after the call returns and StubInvoke on the
//              server side before the call is dispatched to the stub
//
//              This method delivers buffers created by polcies on the
//              other side to the polcies on this side
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CPolicySet::Notify(CRpcCall *pCall, EnumCallType eCallType,
                           CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Notify this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hrRet, hr1;
    RPCOLEMESSAGE *pMessage;
    BOOL fDataRep, fClientSide, fDeliver;
    ContextEvent ctxEvent, ctxBufEvent;
    PolicyEntry *pEntry;
    MainHeader *pMainHeader;
    EntryHeader *pEntryHeader;
    void *pvBuffer;
    unsigned long cbBuffer;
    unsigned long i;

    // Assert that the policy set is frozen
    Win4Assert(_dwFlags & PSFLAG_FROZEN);

    // Check COM version for downlevel interop
    pMainHeader = NULL;
    hrRet = S_OK;

    // Check for the presence of buffers created by the policies
    // on the other side
    if(pCtxCall->_pvExtent)
    {
        // Initialize
        fDeliver = FALSE;

        // Get the message
        pMessage = pCall->GetMessage();

        // Obtain Main Header pointer
        pMainHeader = (MainHeader *) pCtxCall->_pvExtent;

        if(!(pCtxCall->_dwFlags & CTXCALLFLAG_NBINIT))
        {
            // Check data representation of the incoming buffer
            // NT supports only Little Endianess
            if((pMessage->dataRepresentation & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
                fDataRep = TRUE;
            else
                fDataRep = FALSE;

            // Catch exceptions raised while examining headers
            _try
            {
                // Check the need to change to local data representation
                if(fDataRep)
                {
                    ByteSwapLong(pMainHeader->Signature);
                    ByteSwapLong(pMainHeader->Version);
                    ByteSwapLong(pMainHeader->cPolicies);
                    ByteSwapLong(pMainHeader->cbBuffer);
                    ByteSwapLong(pMainHeader->cbSize);
                    ByteSwapLong(*((DWORD *) &pMainHeader->hr));
                    ByteSwapLong(*((DWORD *) &pMainHeader->hrServer));
                }

                // Validate the header
                if(pMainHeader->Signature != MAINHDRSIG)
                {
                    ContextDebugOut((DEB_WARN, "Invalid Signature inside "
                                     "Main Header\n"));
                    hrRet = RPC_E_INVALID_HEADER;
                }
                else if((pMainHeader->Version & 0xFFFF0000) != CONTEXT_MAJOR_VERSION ||
                        (pMainHeader->Version & 0x0000FFFF) > CONTEXT_MINOR_VERSION)
                {
                    ContextDebugOut((DEB_WARN, "Invalid version inside "
                                     "Main Header\n"));
                    hrRet = RPC_E_INVALID_HEADER;
                }
                else
                {
                    // Initialize entry header
                    pEntryHeader = (EntryHeader *) (pMainHeader + 1);

                    // Check for existance of buffers created by policies
                    for(i = 0; i < pMainHeader->cPolicies;i++)
                    {
                        // Check the need to change to local data representation
                        if(fDataRep)
                        {
                            ByteSwapLong(pEntryHeader->Signature);
                            ByteSwapLong(pEntryHeader->cbBuffer);
                            ByteSwapLong(pEntryHeader->cbSize);
                            ByteSwapLong(pEntryHeader->policyID.Data1 );
                            ByteSwapShort(pEntryHeader->policyID.Data2 );
                            ByteSwapShort(pEntryHeader->policyID.Data3 );
                        }

                        // Validate the header
                        if(pEntryHeader->Signature != ENTRYHDRSIG)
                        {
                            ContextDebugOut((DEB_WARN, "Invalid Signature "
                                             "inside Entry Header\n"));
                            hrRet = RPC_E_INVALID_HEADER;
                            break;
                        }

                        // Skip to next entry header
                        ++pEntryHeader;
                    }
                }
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
                Win4Assert(!"Improper Header Data");
                hrRet = RPC_E_INVALID_HEADER;
            }
        }

        // Check if header data has been successfuly unmarshaled
        if(SUCCEEDED(hrRet))
        {
            // Header has been converted to local representation
            pCtxCall->_dwFlags |= CTXCALLFLAG_NBINIT;

            // Determine appropriate ctxEvents
            switch(eCallType)
            {
#ifdef CONTEXT_ASYNCSUPPORT
            case CALLTYPE_FINISHRETURN:
                ctxEvent = CONTEXTEVENT_FINISHRETURN;
                ctxBufEvent = CONTEXTEVENT_FINISHRETURNWITHBUFFER;
                fClientSide = TRUE;
                break;

            case CALLTYPE_BEGINENTER:
                ctxEvent = CONTEXTEVENT_BEGINENTER;
                ctxBufEvent = CONTEXTEVENT_BEGINENTERWITHBUFFER;
                fClientSide = FALSE;
                break;
#endif
            case CALLTYPE_SYNCRETURN:
                if(_dwFlags & PSFLAG_RETURNEVENTS)
                {
                    fDeliver = TRUE;
                    ctxEvent = CONTEXTEVENT_RETURN;
                    ctxBufEvent = CONTEXTEVENT_RETURNWITHBUFFER;
                    if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                    {
                        ctxEvent |= CONTEXTEVENT_RETURNEXCEPTION;
                        ctxBufEvent |= CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER;
                    }
                }
                fClientSide = TRUE;
                break;

            case CALLTYPE_SYNCENTER:
                if(_dwFlags & PSFLAG_ENTEREVENTS)
                {
                    fDeliver = TRUE;
                    ctxEvent = CONTEXTEVENT_ENTER;
                    ctxBufEvent = CONTEXTEVENT_ENTERWITHBUFFER;
                }
                fClientSide = FALSE;
                break;
#if DBG==1
            default:
                Win4Assert(FALSE);
#endif
            }

            // Assert that current side matches the policy set
            Win4Assert(!(_dwFlags & PSFLAG_PROXYSIDE) || fClientSide);
            Win4Assert(!(_dwFlags & PSFLAG_STUBSIDE) || !fClientSide);

            if (fClientSide)
            {
                // On the client side, nullify the call for failed HRESULT
                // inside the main header
                if (FAILED(pMainHeader->hr))
                    pCall->Nullify(pMainHeader->hr);
                    
                // Set the server's HRESULT in the call object
                pCall->SetServerHR(pMainHeader->hrServer);
                
                // On client side, start with the last entry.
                pEntry = _pLastEntry;
            }
            else
            {
                pEntry = _pFirstEntry;
            }

            while(pEntry && fDeliver)
            {
                if(pEntry->ctxEvent & ctxBufEvent)
                {
                    // Sanity check
                    Win4Assert(!(pEntry->ctxEvent & ctxEvent));

                    // Initialize
                    pvBuffer = NULL;
                    cbBuffer = 0;

                    // Initialize entry header
                    pEntryHeader = (EntryHeader *) (pMainHeader + 1);

                    // Check if a buffer is available for the policy
                    for(i = 0; i < pMainHeader->cPolicies;i++)
                    {
                        // Compare GUIDS
                        if(pEntry->policyID == pEntryHeader->policyID)
                        {
                            // Obtain policy buffer
                            cbBuffer = pEntryHeader->cbBuffer;
                            pvBuffer = (BYTE *) pMainHeader + pEntryHeader->cbSize;
                            break;
                        }

                        // Skip to next entry header
                        ++pEntryHeader;
                    }

                    // Deliver event to the policy
                    switch(eCallType)
                    {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_FINISHRETURN:
                        hr1 = pEntry->pPolicyAsync->FinishReturnWithBuffer(pCall,
                                                                           pvBuffer,
                                                                           cbBuffer);
                        break;

                    case CALLTYPE_BEGINENTER:
                        hr1 = pEntry->pPolicyAsync->BeginEnterWithBuffer(pCall,
                                                                         pvBuffer,
                                                                         cbBuffer);
                        break;
#endif
                    case CALLTYPE_SYNCRETURN:
                        hr1 = pEntry->pPolicy->ReturnWithBuffer(pCall,
                                                                pvBuffer,
                                                                cbBuffer);
                        break;

                    case CALLTYPE_SYNCENTER:
                        hr1 = pEntry->pPolicy->EnterWithBuffer(pCall,
                                                               pvBuffer,
                                                               cbBuffer);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                    }
                }
                else if(pEntry->ctxEvent & ctxEvent)
                {
                    switch(eCallType)
                    {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_FINISHRETURN:
                        hr1 = pEntry->pPolicyAsync->FinishReturn(pCall);
                        break;

                    case CALLTYPE_BEGINENTER:
                        hr1 = pEntry->pPolicyAsync->BeginEnter(pCall);
                        break;
#endif
                    case CALLTYPE_SYNCRETURN:
                        hr1 = pEntry->pPolicy->Return(pCall);
                        break;

                    case CALLTYPE_SYNCENTER:
                        hr1 = pEntry->pPolicy->Enter(pCall);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                    }
                }
                else
                    hr1 = S_OK;

                if(FAILED(hr1))
                {
                    ContextDebugOut((DEB_WARN,
                                     "Notify for policyID:%I failed with hr:0x%x\n",
                                     &pEntry->policyID, hr1));
                    hr1 = pCall->Nullify(hr1);
                    Win4Assert(hr1 == S_OK);
                }

                // Get the next policy
                if(fClientSide)
                    pEntry = pEntry->pPrev;
                else
                    pEntry = pEntry->pNext;
            }

            // Return latest call status
            hrRet = pCall->GetHResult();
        }
    }
    else
    {
        // Downlevel interop or Failed call
        hrRet = DeliverEvents(pCall, eCallType, pCtxCall);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Notify returning hr:0x%x\n",
                     hrRet));
    return(hrRet);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::DeliverEvents    private
//
//  Synopsis:   This method is called from inside SendReceive on the
//              client side and StubInvoke on the server side
//
//              This method delivers events to polcies. It is called when
//              there is not any buffer to deliver, and any buffer that
//              we create cannot be delivered. (We still have to honor
//              our contract with the policies to call GetSize first.)
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CPolicySet::DeliverEvents(CRpcCall *pCall, EnumCallType eCallType, CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::DeliverEvents this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hrRet, hr1;
    ContextEvent ctxEvent, ctxBufEvent, ctxCurrent;
    BOOL fForward, fDeliver;
    PolicyEntry *pEntry;
    BOOL fClientSide;
    void *pvBuf = NULL;
    ULONG cbBuf = 0;
    ULONG cbNeeded = 0;

    // Assert that the policy set is frozen
    Win4Assert(_dwFlags & PSFLAG_FROZEN);

    // Check for any policies
    if(_cPolicies)
    {
        // Initialize
        fDeliver = FALSE;

        // Determine appropriate ctxEvents
        switch(eCallType)
        {
        case CALLTYPE_SYNCCALL:
            if(_dwFlags & PSFLAG_CALLEVENTS)
            {
                fDeliver = TRUE;
                ctxBufEvent = CONTEXTEVENT_CALLFILLBUFFER;
                ctxEvent = CONTEXTEVENT_CALL;
            }
            fForward = TRUE;
            fClientSide = TRUE;
            break;

        case CALLTYPE_SYNCENTER:
            if(_dwFlags & PSFLAG_ENTEREVENTS)
            {
                fDeliver = TRUE;
                ctxBufEvent = CONTEXTEVENT_ENTERWITHBUFFER;
                ctxEvent = CONTEXTEVENT_ENTER;
            }
            fForward = TRUE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_SYNCLEAVE:
            if(_dwFlags & PSFLAG_LEAVEEVENTS)
            {
                fDeliver = TRUE;
                ctxBufEvent = CONTEXTEVENT_LEAVEFILLBUFFER;
                ctxEvent = CONTEXTEVENT_LEAVE;
                if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                {
                    ctxBufEvent |= CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER;
                    ctxEvent |= CONTEXTEVENT_LEAVEEXCEPTION;
                }
            }
            fForward = FALSE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_SYNCRETURN:
            if(_dwFlags & PSFLAG_RETURNEVENTS)
            {
                fDeliver = TRUE;
                ctxBufEvent = CONTEXTEVENT_RETURNWITHBUFFER;
                ctxEvent = CONTEXTEVENT_RETURN;
                if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                {
                    ctxBufEvent |= CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER;
                    ctxEvent |= CONTEXTEVENT_RETURNEXCEPTION;
                }
            }
            fForward = FALSE;
            fClientSide = TRUE;
            break;

#ifdef CONTEXT_ASYNCSUPPORT
        case CALLTYPE_BEGINCALL:
            ctxBufEvent = CONTEXTEVENT_BEGINCALLFILLBUFFER;
            ctxEvent = CONTEXTEVENT_BEGINCALL;
            fForward = TRUE;
            fClientSide = TRUE;
            break;

        case CALLTYPE_BEGINENTER:
            ctxBufEvent = CONTEXTEVENT_BEGINENTERWITHBUFFER;
            ctxEvent = CONTEXTEVENT_BEGINENTER;
            fForward = TRUE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_BEGINLEAVE:
            ctxBufEvent = CONTEXTEVENT_NONE;
            ctxEvent = CONTEXTEVENT_BEGINLEAVE;
            fForward = FALSE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_BEGINRETURN:
            ctxBufEvent = CONTEXTEVENT_NONE;
            ctxEvent = CONTEXTEVENT_BEGINRETURN;
            fForward = FALSE;
            fClientSide = TRUE;
            break;

        case CALLTYPE_FINISHCALL:
            ctxBufEvent = CONTEXTEVENT_NONE;
            ctxEvent = CONTEXTEVENT_FINISHCALL;
            fForward = TRUE;
            fClientSide = TRUE;
            break;

        case CALLTYPE_FINISHENTER:
            ctxBufEvent = CONTEXTEVENT_NONE;
            ctxEvent = CONTEXTEVENT_FINISHENTER;
            fForward = TRUE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_FINISHLEAVE:
            ctxBufEvent = CONTEXTEVENT_FINISHLEAVEFILLBUFFER;
            ctxEvent = CONTEXTEVENT_FINISHLEAVE;
            fForward = FALSE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_FINISHRETURN:
            ctxBufEvent = CONTEXTEVENT_FINISHRETURNWITHBUFFER;
            ctxEvent = CONTEXTEVENT_FINISHRETURN;
            fForward = FALSE;
            fClientSide = TRUE;
            break;
#endif
        default:
            Win4Assert(FALSE);
			return E_UNEXPECTED;
        }

        // Assert that current side matches the policy set
        Win4Assert(!(_dwFlags & PSFLAG_PROXYSIDE) || fClientSide);
        Win4Assert(!(_dwFlags & PSFLAG_STUBSIDE) || !fClientSide);

        // Loop through policy entries
        if(fForward)
            pEntry = _pFirstEntry;
        else
            pEntry = _pLastEntry;

        BOOL fCallGetSize;
        if (pCtxCall)
        {
            fCallGetSize = !(pCtxCall->_dwFlags & CTXCALLFLAG_GBINIT);
        }
        else
        {
            fCallGetSize = TRUE;
        }

        while(pEntry && fDeliver)
        {
            // Check if the policy wishes to participate in the event
            if(pEntry->ctxEvent & ctxBufEvent)
                ctxCurrent = pEntry->ctxEvent & ctxBufEvent;
            else if(pEntry->ctxEvent & ctxEvent)
                ctxCurrent = pEntry->ctxEvent & ctxEvent;
            else
                ctxCurrent = CONTEXTEVENT_NONE;

            // Deliver event to policy
            switch(ctxCurrent)
            {
            case CONTEXTEVENT_CALL:
                hr1 = pEntry->pPolicy->Call(pCall);
                break;

            case CONTEXTEVENT_CALLFILLBUFFER:
                if (fCallGetSize)
                {
                    hr1 = pEntry->pPolicy->CallGetSize(pCall, &cbNeeded);
                    if(hr1 != S_OK)
                        break;
                }
                else
                {
                    cbNeeded = 0;
                }
                if(cbNeeded > cbBuf)
                {
                    pvBuf = _alloca(cbNeeded);
                    cbBuf = cbNeeded;
                }
                hr1 = pEntry->pPolicy->CallFillBuffer(pCall, pvBuf, &cbNeeded);
                break;

            case CONTEXTEVENT_ENTER:
                hr1 = pEntry->pPolicy->Enter(pCall);
                break;

            case CONTEXTEVENT_ENTERWITHBUFFER:
                hr1 = pEntry->pPolicy->EnterWithBuffer(pCall, NULL, 0);
                break;

            case CONTEXTEVENT_LEAVE:
            case CONTEXTEVENT_LEAVEEXCEPTION:
                hr1 = pEntry->pPolicy->Leave(pCall);
                break;

            case CONTEXTEVENT_LEAVEFILLBUFFER:
            case CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER:
                if (fCallGetSize)
                {
                    hr1 = pEntry->pPolicy->LeaveGetSize(pCall, &cbNeeded);
                    if(hr1 != S_OK)
                        break;
                }
                else
                {
                    cbNeeded = 0;
                }
                if(cbNeeded > cbBuf)
                {
                    pvBuf = _alloca(cbNeeded);
                    cbBuf = cbNeeded;
                }
                hr1 = pEntry->pPolicy->LeaveFillBuffer(pCall, pvBuf, &cbNeeded);
                break;

            case CONTEXTEVENT_RETURN:
            case CONTEXTEVENT_RETURNEXCEPTION:
                hr1 = pEntry->pPolicy->Return(pCall);
                break;

            case CONTEXTEVENT_RETURNWITHBUFFER:
            case CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER:
                hr1 = pEntry->pPolicy->ReturnWithBuffer(pCall, NULL, 0);
                break;

#ifdef CONTEXT_ASYNCSUPPORT
            case CONTEXTEVENT_BEGINCALL:
                hr1 = pEntry->pPolicyAsync->BeginCall(pCall);
                break;

            case CONTEXTEVENT_BEGINCALLFILLBUFFER:
                hr1 = pEntry->pPolicyAsync->BeginCallGetSize(pCall, &cbNeeded);
                if(hr1 != S_OK)
                    break;
                if(cbNeeded > cbBuf)
                {
                    pvBuf = _alloca(cbNeeded);
                    cbBuf = cbNeeded;
                }
                hr1 = pEntry->pPolicyAsync->BeginCallFillBuffer(pCall, pvBuf, &cbNeeded);
                break;

            case CONTEXTEVENT_BEGINENTER:
                hr1 = pEntry->pPolicyAsync->BeginEnter(pCall);
                break;

            case CONTEXTEVENT_BEGINENTERWITHBUFFER:
                hr1 = pEntry->pPolicyAsync->BeginEnterWithBuffer(pCall, NULL, 0);
                break;

            case CONTEXTEVENT_BEGINLEAVE:
                hr1 = pEntry->pPolicyAsync->BeginLeave(pCall);
                break;

            case CONTEXTEVENT_BEGINRETURN:
                hr1 = pEntry->pPolicyAsync->BeginReturn(pCall);
                break;

            case CONTEXTEVENT_FINISHCALL:
                hr1 = pEntry->pPolicyAsync->FinishCall(pCall);
                break;

            case CONTEXTEVENT_FINISHENTER:
                hr1 = pEntry->pPolicyAsync->FinishEnter(pCall);
                break;

            case CONTEXTEVENT_FINISHLEAVE:
                hr1 = pEntry->pPolicyAsync->FinishLeave(pCall);
                break;

            case CONTEXTEVENT_FINISHLEAVEFILLBUFFER:
                hr1 = pEntry->pPolicyAsync->FinishLeaveGetSize(pCall, &cbNeeded);
                if(hr1 != S_OK)
                    break;
                if(cbNeeded > cbBuf)
                {
                    pvBuf = _alloca(cbNeeded);
                    cbBuf = cbNeeded;
                }
                hr1 = pEntry->pPolicyAsync->FinishLeaveFillBuffer(pCall, pvBuf, &cbNeeded);
                break;

            case CONTEXTEVENT_FINISHRETURN:
                hr1 = pEntry->pPolicyAsync->FinishReturn(pCall);
                break;

            case CONTEXTEVENT_FINISHRETURNWITHBUFFER:
                hr1 = pEntry->pPolicyAsync->FinishReturnWithBuffer(pCall, NULL, 0);
                break;
#endif
            case CONTEXTEVENT_NONE:
                hr1 = S_OK;
                break;

            default:
                Win4Assert(!"Improper CtxEvent being delivered");
                hr1 = E_FAIL;
            }

            // Check the return code
            if(FAILED(hr1))
            {
                ContextDebugOut((DEB_WARN,
                                 "Delivery of event %d for policyID:%I "
                                 "failed with hr:0x%x\n",
                                 ctxCurrent, &pEntry->policyID, hr1));
                hr1 = pCall->Nullify(hr1);
                Win4Assert(hr1 == S_OK);
            }

            // Get the next policy
            if(fForward)
                pEntry = pEntry->pNext;
            else
                pEntry = pEntry->pPrev;
        }
    }

    // Obtain the call status
    hrRet = pCall->GetHResult();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::DeliverEvents this:%x hr:0x%x\n",
                     this, hrRet));
    return(hrRet);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::DecideDestruction     private
//
//  Synopsis:   Destroys the policy set after ensuring that the PSTable
//              table has not given out a reference to it on another
//              thread
//
//  History:    29-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
ULONG CPolicySet::DecideDestruction()
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    ULONG cRet;
    BOOL fCache = FALSE;
    BOOL fDestroy;

    // Acquire writer lock
    gPSRWLock.AcquireWriterLock();

    // Ensure that the PSTable has not given out a reference to
    // this policy set from a different thread
    cRet = _cRefs;
    if(_cRefs == 0)
    {
        if(!IsCached())
        {
            fCache = TRUE;
            MarkCached();
        }
        else
        {
            fDestroy = IsMarkedForDestruction();
        }
    }

    // Release writer lock
    gPSRWLock.ReleaseWriterLock();

    // Cache the policy set no other thread has a reference to it
    if(cRet == 0)
    {
        if(fCache)
        {
            // The following order is important
            DeliverReleasePolicyEvents();
            Cache();

            // This object might have been deleted by now
        }
        else if(fDestroy)
        {
            delete this;
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::DecideDestruction this:%x cRet:%x\n",
                     this, cRet));
    return(cRet);
}


//---------------------------------------------------------------------------
//
//  Method:     CPSHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given node
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
DWORD CPSHashTable::HashNode(SHashChain *pNode)
{
    CPolicySet *pPS = CPolicySet::HashChainToPolicySet(pNode);

	Win4Assert(pPS && "Attempting to hash NULL PolicySet!");
	if (pPS)
	{
		return Hash(((CPolicySet *) pPS)->GetClientContext(),
					((CPolicySet *) pPS)->GetServerContext());
	}

	return 0;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CPSHashTable::Compare(const void *pv, SHashChain *pNode, DWORD dwHash)
{
    CPolicySet *pPS = CPolicySet::HashChainToPolicySet(pNode);
    Contexts *pContexts = (Contexts *) pv;

	Win4Assert (pPS && "Comparing NULL PolicySet!");
	if (pPS)
	{
		if((pPS->GetClientContext() == pContexts->pClientCtx) &&
		   (pPS->GetServerContext() == pContexts->pServerCtx))
			return(TRUE);
	}

    return(FALSE);
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Initialize
//
//  Synopsis:   Initailizes the policy set table
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::Initialize()
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    // Avoid double init
    if(!s_fInitialized)
    {
        // Initialize Policy Sets
        CPolicySet::Initialize();
        
        // Acquire writer lock
        gPSRWLock.AcquireWriterLock();

        // Initialize hash table
        if(!s_fInitialized)
        {
            s_PSHashTbl.Initialize(s_PSBuckets, &gPSRWLock);
            s_fInitialized = TRUE;
        }

        // Release hash table
        gPSRWLock.ReleaseWriterLock();
    }

    gPSRWLock.AssertNotHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Function:   CleanupPolicySets
//
//  Synopsis:   Should never get called
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CleanupPolicySets(SHashChain *pNode)
{
    Win4Assert(!"Leaking contexts");
    return;
}


//---------------------------------------------------------------------------
//
//  Function:   RemovePolicySets
//
//  Synopsis:   Removes the PolicySet if it belongs to current apartment
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
BOOL RemovePolicySets(SHashChain *pNode, void *pvData)
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertWriterLockHeld();

    CPolicySet *pPS = CPolicySet::HashChainToPolicySet(pNode);
    DWORD dwAptID = PtrToUlong(pvData);
    BOOL fRemove = FALSE;

	Win4Assert(pPS && "Removing NULL Policy Set!");
    if(pPS && (pPS->GetApartmentID() == dwAptID))
    {
        Win4Assert(!"Leaking contexts");
        ContextDebugOut((DEB_ERROR, "Leaking contexts\n"));
    }

    return(fRemove);
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::ThreadCleanup
//
//  Synopsis:   Cleanup the policy set table for the current apartment
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::ThreadCleanup(BOOL fApartmentUninit)
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::ThreadCleanup\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    COleTls Tls;

    Win4Assert(Tls->pCtxCall == NULL);
    Win4Assert(Tls->pCurrentCtx == Tls->pNativeCtx);

    // Destory the policy sets associated with the native context
//    CPolicySet::DestroyPSCache(Tls->pNativeCtx);
    
    // Release the native context of this thread
    Tls->pNativeCtx->InternalRelease();
    Tls->pNativeCtx = NULL;
    Tls->pCurrentCtx = NULL;
    Tls->ContextId = (ULONGLONG)-1;

    gPSRWLock.AssertNotHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Cleanup
//
//  Synopsis:   Cleanup the policy set table
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::Cleanup()
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Cleanup\n"));
    gPSRWLock.AssertNotHeld();

    // Check if the table was initialized
    if(s_fInitialized)
    {
        // Acquire writer lock
        gPSRWLock.AcquireWriterLock();

        // Cleanup hash table
        s_PSHashTbl.Cleanup(CleanupPolicySets);

        // State is no longer initialized
        s_fInitialized = FALSE;

        // Release writer lock
        gPSRWLock.ReleaseWriterLock();

        // Cleanup Policy sets
        CPolicySet::Cleanup();
    }

    gPSRWLock.AssertNotHeld();
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Add
//
//  Synopsis:   Addes a given policy set into the table
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::Add(CPolicySet *pPS)
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Add pPolicySet:%x\n", pPS));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertWriterLockHeld();

    // Sanity check
    Win4Assert(pPS);

    // Mark the policy set as belonging to the current apartment
    pPS->SetApartmentID(GetCurrentApartmentId());

    // Obtain contexts
    CObjectContext *pClientCtx = pPS->GetClientContext();
    CObjectContext *pServerCtx = pPS->GetServerContext();
    Win4Assert(pClientCtx || pServerCtx);

    // Obtain Hash value
    DWORD dwHash = s_PSHashTbl.Hash(pClientCtx, pServerCtx);

    // Add Policy Set to the Hash table
    s_PSHashTbl.Add(dwHash, pPS);

    gPSRWLock.AssertWriterLockHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Add returning 0x%x\n", pPS));
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Remove
//
//  Synopsis:   Removes the policy set from the policy set table
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::Remove(CPolicySet *pPS)
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Remove pPolicySet:%x\n", pPS));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertWriterLockHeld();

    // Sanity check
    Win4Assert(pPS);

#if DBG==1
    // In debug builds, ensure that the node is present in the table
    CPolicySet *pExistingPS;
    DWORD dwHash;

    // Obtain Hash value
    dwHash = s_PSHashTbl.Hash(pPS->GetClientContext(),
                              pPS->GetServerContext());
    pExistingPS = s_PSHashTbl.Lookup(dwHash,
                                     pPS->GetClientContext(),
                                     pPS->GetServerContext());
    Win4Assert(pExistingPS == pPS);
#endif

    s_PSHashTbl.Remove(pPS);

    gPSRWLock.AssertWriterLockHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Remove returning\n"));
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Lookup
//
//  Synopsis:   Looksup the policy set for the given contexts
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT CPSTable::Lookup(CObjectContext *pClientCtx, CObjectContext *pServerCtx,
                         CPolicySet **ppPS, BOOL fCachedPS)
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Lookup pCliCtx:%x pSrvCtx:%x\n",
                    pClientCtx, pServerCtx));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertReaderOrWriterLockHeld();

    DWORD dwHash;
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    // Sanity check
    Win4Assert(pClientCtx || pServerCtx);

    // Obtain Hash value
    dwHash = s_PSHashTbl.Hash(pClientCtx, pServerCtx);

    // Lookup the policy set between the contexts
    CPolicySet *pPS = s_PSHashTbl.Lookup(dwHash, pClientCtx, pServerCtx);
    if(pPS)
    {
        if(pPS->IsCached() && (fCachedPS == FALSE))
            pPS = NULL;

        if(pPS)
        {
            pPS->AddRef();
            hr = S_OK;
        }
    }

    // Initialize the return value
    *ppPS = pPS;
    Win4Assert(FAILED(hr) == (*ppPS == NULL));

    gPSRWLock.AssertReaderOrWriterLockHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Lookup returning hr:0x%x, ppPS:0x%x, *ppPS:0x%x\n",
                     hr, ppPS, *ppPS));
    return(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::UncacheIfNecessary
//
//  Synopsis:   Marks the policy set as uncached by delivering AddRef events
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
BOOL CPolicySet::UncacheIfNecessary()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::UncacheIfNecessary this:%x\n", this));
    gPSRWLock.AssertNotHeld();

    // Sanity check
    Win4Assert(_cRefs);

    // NOTE: there should be no races between the context destruction
    //       path and this one since the calling code should have a reference
    //       on the contexts in order to do this operation
    BOOL fUncached = FALSE;

    // Deliver AddRefPolicy events
    DeliverAddRefPolicyEvents();

    // Acquire writer lock
    gPSRWLock.AcquireWriterLock();

    // Check for the need to uncache
    if(IsCached())
    {
        UnsafeToDestroy();
        MarkUncached();
        fUncached = TRUE;
    }

    // Release the writer lock
    gPSRWLock.ReleaseWriterLock();

    // Uncache if needed
    if(fUncached)
        Uncache();
    else
        DeliverReleasePolicyEvents();

    gPSRWLock.AssertNotHeld();
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::UncacheIfNecessary return:%x\n", fUncached));
    return fUncached;
}



//+-------------------------------------------------------------------
//
//  Function:   CoGetObjectContext            public
//
//  Synopsis:   Obtains the current object context
//
//  History:    15-Jan-98   Gopalk      Created
//              12-Nov-98   Johnstra    Modified to hand out user
//                                      context instead of real one.
//
//+-------------------------------------------------------------------
STDAPI CoGetObjectContext(REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_POLICYSET, "CoGetObjectContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Initialize
    *ppv = NULL;

    // Initalize channel
    hr = InitChannelIfNecessary();
    if(SUCCEEDED(hr))
    {
        CObjectContext *pContext = GetCurrentContext();
        if(pContext)
        {
            // We are returning a reference to a context to user code,
            // so we want them to have a user reference instead of
            // an internal ref, hence QI instead of InternalQI.
            hr = pContext->QueryInterface(riid, ppv);
        }
        else
            hr = CO_E_NOTINITIALIZED;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CoGetObjectContext pv:%x hr:0x%x\n", *ppv, hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CoSetObjectContext            public
//
//  Synopsis:   Sets the current object context
//
//  History:    04-Oct-99   Gopalk      Created
//
//+-------------------------------------------------------------------
STDAPI CoSetObjectContext(IUnknown *pUnk)
{
    ContextDebugOut((DEB_POLICYSET, "CoSetObjectContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Ensure that the supplied punk is really a context object
    CObjectContext *pContext;
    HRESULT hr = pUnk->QueryInterface(IID_IStdObjectContext, (void **) &pContext);
    if(SUCCEEDED(hr))
    {
        COleTls Tls(hr);
        if(SUCCEEDED(hr))
        {
            Tls->pCurrentCtx = pContext;
            Tls->ContextId = pContext->GetId();
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   DeterminePolicySet      Private
//
//  Synopsis:   Determines the policy set for the given contexts
//
//  History:    15-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT DeterminePolicySet(CObjectContext *pClientCtx,
                           CObjectContext *pServerCtx,
                           DWORD dwFlags, CPolicySet **ppCPS)
{
    ContextDebugOut((DEB_POLICYSET, "DeterminePolicySet pCliCtx:%x pSrvCtx:%x\n",
                    pClientCtx, pServerCtx));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    HRESULT hr;
    void *pvCltNode, *pvSvrNode;

    // Sanity check
    Win4Assert(pClientCtx || pServerCtx);
    if (!(pClientCtx || pServerCtx))
        return E_UNEXPECTED;

    // Initialize cookies used for enumerating properties in contexts
    // Initialization might fail if object context has not been frozen
    if(pClientCtx)
    {
        hr = pClientCtx->Reset(&pvCltNode);
        Win4Assert(SUCCEEDED(hr));
    }
    if(pServerCtx)
    {
        hr = pServerCtx->Reset(&pvSvrNode);
        Win4Assert(SUCCEEDED(hr));
    }

    // Create a new policy set
    CPolicySet *pCPS = new CPolicySet(dwFlags);
    if(pCPS)
    {
        HRESULT hr2;
        ContextProperty *pCtxProp;
        IPolicyMaker *pPM;

        // Check for server context
        if(pServerCtx && !pServerCtx->IsEmpty())
        {
            // Set policy set to server side
            pCPS->SetServerSide();

            // Enumerate PolicyMakers in the server context
            do
            {
                pCtxProp = pServerCtx->GetNextProperty(&pvSvrNode);
                if(pCtxProp == NULL)
                    break;

                // QI the property object for IPolicyMaker interface
                if(pCtxProp->pUnk)
                {
                    hr2 = pCtxProp->pUnk->QueryInterface(IID_IPolicyMaker,
                                                        (void **) &pPM);
                    if(SUCCEEDED(hr2))
                    {
                        if(pCPS->IsProxySide())
                            hr = pPM->AddEnvoyPoliciesToSet(pCPS, pClientCtx, pServerCtx);
                        else
                            hr = pPM->AddServerPoliciesToSet(pCPS, pClientCtx, pServerCtx);
                        pPM->Release();
                        if(FAILED(hr))
                            break;
                    }
                }
            } while(TRUE);

            // Reset policy set side
            pCPS->ResetServerSide();
        }

        // Check for client context
        if(SUCCEEDED(hr) && pClientCtx && !pClientCtx->IsEmpty())
        {
            // Set policy set to client side
            pCPS->SetClientSide();

            // Enumerate PolicyMakers in the client context
            do
            {
                pCtxProp = pClientCtx->GetNextProperty(&pvCltNode);
                if(pCtxProp == NULL)
                    break;

                // QI the property object for IPolicyMaker interface
                if(pCtxProp->pUnk)
                {
                    hr2 = pCtxProp->pUnk->QueryInterface(IID_IPolicyMaker,
                                                         (void **) &pPM);
                    if(SUCCEEDED(hr2))
                    {
                        hr = pPM->AddClientPoliciesToSet(pCPS, pClientCtx, pServerCtx);
                        pPM->Release();
                        if(FAILED(hr))
                            break;
                    }
                }
            } while(TRUE);

            // Reset policy set side
            pCPS->ResetClientSide();
        }

        // Update the policy set
        if(SUCCEEDED(hr))
        {
            pCPS->Freeze();
            pCPS->DeliverAddRefPolicyEvents();
            pCPS->MarkUncached();
        }
        else
        {
            delete pCPS;
            pCPS = NULL;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    // Sanity check
    Win4Assert((SUCCEEDED(hr)) == (pCPS!=NULL));
    *ppCPS = pCPS;

#if DBG==1
    if(FAILED(hr))
    {
        ContextDebugOut((DEB_ERROR,
                         "DeterminePolicySet failed to create a policy set "
                         "for contexts 0x%x-->0x%x with hr:0x%x\n",
                         pClientCtx, pServerCtx, hr));
    }
#endif

    gPSRWLock.AssertNotHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET,
                     "DeterminePolicySet returning 0x%x, pCPS=0x%x\n", hr, pCPS));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::SetClientContext    Private
//
//  Synopsis:   Chains the policy set to the list of policy sets
//              maintained by the client context. This method can
//              only be called once during the lifetime of the
//              policy set
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::SetClientContext(CObjectContext *pClientCtx)
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::SetClientContext this:%x ClientCtx:%x\n",
                     this, pClientCtx));

    // Sanity checks
    gPSRWLock.AssertWriterLockHeld();
    Win4Assert(!_pClientCtx);

    // Save the pointer to client context
    _pClientCtx = pClientCtx;

    // Chain the policy set into the list maintained by the
    // client context
    SPSCache *pPSCache = pClientCtx->GetPSCache();
    _PSCache.clientPSChain.pNext = pPSCache->clientPSChain.pNext;
    _PSCache.clientPSChain.pPrev = &(pPSCache->clientPSChain);
    _PSCache.clientPSChain.pNext->pPrev = &_PSCache.clientPSChain;
    pPSCache->clientPSChain.pNext = &(_PSCache.clientPSChain);
}


//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::SetServerContext    Private
//
//  Synopsis:   Chains the policy set to the list of policy sets
//              maintained by the server context. This method can
//              only be called once during the lifetime of the
//              policy set
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::SetServerContext(CObjectContext *pServerCtx)
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::SetServerContext this:%x pServerCtx:%x\n",
                     this, pServerCtx));

    // Sanity checks
    gPSRWLock.AssertWriterLockHeld();
    Win4Assert(!_pServerCtx);

    // Save the pointer to server context
    _pServerCtx = pServerCtx;
    pServerCtx->InternalAddRef();

    // Chain the policy set into the list maintained by the
    // server context
    SPSCache *pPSCache = pServerCtx->GetPSCache();
    _PSCache.serverPSChain.pNext = pPSCache->serverPSChain.pNext;
    _PSCache.serverPSChain.pPrev = &(pPSCache->serverPSChain);
    _PSCache.serverPSChain.pNext->pPrev = &_PSCache.serverPSChain;
    pPSCache->serverPSChain.pNext = &(_PSCache.serverPSChain);
}


//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::RemoveFromCacheLists    Private
//
//  Synopsis:   Removes the policy set from lists maintained by the
//              client and server contexts
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::RemoveFromCacheLists()
{
    // Sanity checks
    gPSRWLock.AssertWriterLockHeld();
    Win4Assert(_pServerCtx || _pClientCtx);

    // Remove from the list maintained by the client context
    if(_pClientCtx)
    {
        _pClientCtx = NULL;
        _PSCache.clientPSChain.pNext->pPrev = _PSCache.clientPSChain.pPrev;
        _PSCache.clientPSChain.pPrev->pNext = _PSCache.clientPSChain.pNext;
#if DBG==1
        _PSCache.clientPSChain.pNext = NULL;
        _PSCache.clientPSChain.pPrev = NULL;
#endif
    }

    // Remove from the list maintained by the server context
    if(_pServerCtx)
    {
        _PSCache.serverPSChain.pNext->pPrev = _PSCache.serverPSChain.pPrev;
        _PSCache.serverPSChain.pPrev->pNext = _PSCache.serverPSChain.pNext;
#if DBG==1
        _PSCache.serverPSChain.pNext = NULL;
        _PSCache.serverPSChain.pPrev = NULL;
#endif
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::PrepareForDestruction    Private
//
//  Synopsis:   Prepares the policy sets for destruction
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CPolicySet::PrepareForDestruction()
{
    // Sanity checks
    Win4Assert(_pClientCtx || _pServerCtx);
    gPSRWLock.AssertWriterLockHeld();

    // The following assert will fire if Wrapper are leaked by client
    // contexts
    //Win4Assert(IsCached() || (_pClientCtx == NULL) || (_pServerCtx == NULL) ||
    //           _pServerCtx->IsEnvoy() ||
    //           (_pClientCtx->GetComApartment() != _pServerCtx->GetComApartment()));

    // Remove the policy set from the policy set table
    gPSTable.Remove(this);
    RemoveFromCacheLists();
    MarkForDestruction();

    return;
}

//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::PreparePSCache    Private
//
//  Synopsis:   Prepares all the policy sets from lists maintained by the
//              client and server contexts
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::DestroyPSCache(CObjectContext *pCtx)
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::PreparePSCache pCtx:%x\n", pCtx));

    // Sanity check
    gPSRWLock.AssertNotHeld();

    const int CleanupPSListSize = 25;
    int iNumPS;
    CPolicySet *pPS;
    SPSCache *pPSCache = pCtx->GetPSCache();
    struct PSListEntry {
        CPolicySet *pPS;
        BOOL fCached;
    };
    PSListEntry *pCleanupPSList = (PSListEntry *) _alloca(sizeof(PSListEntry)
                                                          * CleanupPSListSize);
    // _alloca never returns if it fails to allocate memory on the stack
    Win4Assert(pCleanupPSList);

    while((pPSCache->clientPSChain.pNext != &(pPSCache->clientPSChain)) ||
          (pPSCache->serverPSChain.pNext != &(pPSCache->serverPSChain)))
    {
        // Initialize
        iNumPS = 0;

        // Acquire writer lock
        gPSRWLock.AcquireWriterLock();

        // Cleanup policy sets in the client list
        while((iNumPS < CleanupPSListSize) &&
              (pPSCache->clientPSChain.pNext != &(pPSCache->clientPSChain)))
        {
            pPS = ClientChainToPolicySet(pPSCache->clientPSChain.pNext);
            Win4Assert(pCtx == pPS->GetClientContext());
            pPS->PrepareForDestruction();
            pCleanupPSList[iNumPS].fCached = pPS->IsCached();
            if(!pPS->IsCached())
            {
                pPS->MarkCached();
                pPS->AddRef();
                pCleanupPSList[iNumPS++].pPS = pPS;
            }
            else if(pPS->IsSafeToDestroy())
            {
                Win4Assert(pPS->IsCached());
                pCleanupPSList[iNumPS++].pPS = pPS;
            }
        }

        // Cleanup policy sets in the server list
        while((iNumPS < CleanupPSListSize) &&
              (pPSCache->serverPSChain.pNext != &(pPSCache->serverPSChain)))
        {
            pPS = ServerChainToPolicySet(pPSCache->serverPSChain.pNext);
            Win4Assert(pCtx == pPS->GetServerContext());
            Win4Assert(pPS->IsCached());
            Win4Assert(pPS->IsSafeToDestroy());
            Win4Assert(!pPS->IsMarkedForDestruction());
            pPS->PrepareForDestruction();
            pCleanupPSList[iNumPS].fCached = TRUE;
            pCleanupPSList[iNumPS++].pPS = pPS;
        }

        // Release writer lock
        gPSRWLock.ReleaseWriterLock();

        // Destroy policy sets
        for(int i=0;i<iNumPS;i++)
        {
            if(pCleanupPSList[i].fCached == FALSE)
            {
                pCleanupPSList[i].pPS->DeliverReleasePolicyEvents();
                pCleanupPSList[i].pPS->Cache();
                pCleanupPSList[i].pPS->Release();
            }
            else
            {
                delete pCleanupPSList[i].pPS;
            }
        }
    }

    gPSRWLock.AssertNotHeld();
    return;
}


//+-------------------------------------------------------------------
//
//  Function:   PrivSetServerHResult    Private
//
//  Synopsis:   Sets the server's HRESULT for a given call.
//
//  History:    29-Mar-99   Johnstra      Created
//
//+-------------------------------------------------------------------
HRESULT PrivSetServerHResult(
    RPCOLEMESSAGE *pMsg,
    VOID          *pReserved,
    HRESULT        appsHr
    )
{
    CAsyncCall asyncCall(0);
    void* vptrAsync = *(void**) &asyncCall;
    CClientCall clientCall(0);
    void* vptrClient = *(void**) &clientCall;

    void* vptrCall = *(void**)pMsg->reserved1;
    
    // Obtain the context call object
    CCtxCall *pCtxCall;
    if (vptrCall == vptrAsync || vptrCall == vptrClient)
        pCtxCall = ((CMessageCall *) pMsg->reserved1)->GetServerCtxCall();
    else
        pCtxCall = (CCtxCall *) pMsg->reserved1;
        
    // Set the server's HRESULT in the call object.
    if (pCtxCall)
        pCtxCall->_hrServer = appsHr;
    
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   PrivSetServerHRESULTInTLS    Private
//
//  Synopsis:   Sets the server's HRESULT for a given call.  Retrieves
//              the call object from TLS
//
//  History:    21-Feb-01   JSimmons     Created
//
//+-------------------------------------------------------------------
HRESULT PrivSetServerHRESULTInTLS(
    VOID* pvReserved,
    HRESULT appsHR
    )
{
    HRESULT hr;

    if (pvReserved != NULL)
        return E_INVALIDARG;

    // There's no point in remembering the hresult if it isn't 
    // a failure code.
    if (SUCCEEDED(appsHR))
        return S_OK;
    
    // Note: i'm using the version of the COleTls constructor that 
    // doesn't fault in the TLS data.  If it isn't already there, too bad.
    COleTls tls;
    
    // Check to make sure TLS is there.
    if (tls.IsNULL())
        return CO_E_NOTINITIALIZED;
    
    // Check for call object in tls
    if (!tls->pCallInfo)
        return RPC_E_CALL_COMPLETE;

    // Retrieve the server ctx call obj
    CCtxCall* pCtxCall = tls->pCallInfo->GetServerCtxCall();

    // Dbl-check that one too
    if (!pCtxCall)
        return E_UNEXPECTED;

    // Done
    pCtxCall->_hrServer = appsHR;
    
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   CNullWalker::QueryInterface
//
//  Synopsis:   Standard QueryInterface Implementation
//
//  History:    03-Jan-01   JohnDoty      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CNullWalker::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;;

    if ((riid == IID_IUnknown) || 
        (riid == IID_ICallFrameWalker))
    {
        *ppv = this;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppv = NULL;
    }
    
    if (SUCCEEDED(hr))
        AddRef();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CNullWalker::OnWalkInterface
//
//  Synopsis:   ICallFrameWalker::OnWalkInterface.  Simply NULLs the
//              offending pointer so that nobody Releases it.
//
//  History:    03-Jan-01   JohnDoty      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CNullWalker::OnWalkInterface(REFIID riid, void **ppv,
                                          BOOL fIn, BOOL fOut)
{
    if (ppv)
        *ppv = NULL;
    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\orpc_dbg.h ===
//--------------------------------------------------------------------------
// ORPC_DBG.H (tabs 4)
//
//  !!!!!!!!! !!!!!!!!! NOTE NOTE NOTE NOTE !!!!!!!!! !!!!!!!!!!
//
//          SEND MAIL TO SANJAYS  IF YOU MODIFY THIS FILE!
//            WE MUST KEEP OLE AND LANGUAGES IN SYNC!
//
//  !!!!!!!!! !!!!!!!!! NOTE NOTE NOTE NOTE !!!!!!!!! !!!!!!!!!!
//
// Created 07-Oct-1993 by Mike Morearty.  The master copy of this file
// is in the LANGAPI project owned by the Languages group.
//
// Macros and functions for OLE RPC debugging.  For a detailed explanation,
// see OLE2DBG.DOC.
//
//--------------------------------------------------------------------------


#ifndef __ORPC_DBG__
#define __ORPC_DBG__

//--------------------------------------------------------------------------
// Public:
//--------------------------------------------------------------------------

// This structure is the information packet which OLE sends the debugger
// when it is notifying it about an OLE debug event. The first field in this
// structure points to the signature which identifies the type of the debug 
// notification. The consumer of the notification can then get the relevant 
// information from the struct members. Note that for each OLE debug notification
// only a subset of the struct members are meaningful. 


typedef struct ORPC_DBG_ALL 
{
	BYTE *				pSignature;
	RPCOLEMESSAGE *		pMessage;
	const IID *	 		refiid;
	IRpcChannelBuffer *	pChannel;
	IUnknown *			pUnkProxyMgr;
	void *				pInterface;
	IUnknown *			pUnkObject;
	HRESULT				hresult;
	void *				pvBuffer;
	ULONG				cbBuffer;	
	ULONG *				lpcbBuffer; 
	void * 				reserved;
} ORPC_DBG_ALL;

typedef ORPC_DBG_ALL __RPC_FAR *LPORPC_DBG_ALL;

// Interface definition for IOrpcDebugNotify 

typedef interface IOrpcDebugNotify IOrpcDebugNotify;

typedef IOrpcDebugNotify __RPC_FAR * LPORPCDEBUGNOTIFY;

#if defined(__cplusplus) && !defined(CINTERFACE)

	interface IOrpcDebugNotify : public IUnknown
	{
	public:
		virtual VOID __stdcall ClientGetBufferSize (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ClientFillBuffer (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ClientNotify (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ServerNotify (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ServerGetBufferSize (LPORPC_DBG_ALL) = 0;
		virtual VOID __stdcall ServerFillBuffer (LPORPC_DBG_ALL) = 0;
	};

#else /* C style interface */

	typedef struct IOrpcDebugNotifyVtbl
	{
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOrpcDebugNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOrpcDebugNotify __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOrpcDebugNotify __RPC_FAR * This);

		VOID ( __stdcall __RPC_FAR *ClientGetBufferSize)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ClientFillBuffer)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ClientNotify)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ServerNotify)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ServerGetBufferSize)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);
		
		VOID ( __stdcall __RPC_FAR *ServerFillBuffer)(
			IOrpcDebugNotify __RPC_FAR * This,
			LPORPC_DBG_ALL lpOrpcDebugAll);

		} IOrpcDebugNotifyVtbl;

		interface IOrpcDebugNotify 
		{
			CONST_VTBL struct IOrpcDebugNotifyVtbl __RPC_FAR *lpVtbl;
		};

#endif

// This is the structure that is passed by the debugger to OLE when it enables ORPC 
// debugging. 
typedef struct ORPC_INIT_ARGS
{
	IOrpcDebugNotify __RPC_FAR * lpIntfOrpcDebug;
	void *	pvPSN;	// contains ptr to Process Serial No. for Mac ORPC debugging.
	DWORD	dwReserved1; // For future use, must be 0.
	DWORD	dwReserved2;
} ORPC_INIT_ARGS;

typedef ORPC_INIT_ARGS  __RPC_FAR * LPORPC_INIT_ARGS;
				
// Function pointer prototype for the "DllDebugObjectRPCHook" function.
typedef BOOL (WINAPI* ORPCHOOKPROC)(BOOL, LPORPC_INIT_ARGS); 

// The first four bytes in the debug specific packet are interpreted by the
// ORPC debug layer. The valid values are the ones defined below.

#define ORPC_DEBUG_ALWAYS					(0x00000000L)	// Notify always.
#define ORPC_DEBUG_IF_HOOK_ENABLED			(0x00000001L)	// Notify only if hook enabled.
 

// This exception code indicates that the exception is really an 
// ORPC debug notification.

#define EXCEPTION_ORPC_DEBUG (0x804f4c45)


//--------------------------------------------------------------------------------------
// Private: Declarations below this point are related to the implementation and should
// be removed from the distributable version of the header file.
//--------------------------------------------------------------------------------------


// Helper routines to set & restore the "Auto" value in the registry

BOOL WINAPI DebugORPCSetAuto(VOID);
VOID WINAPI DebugORPCRestoreAuto(VOID);

 ULONG WINAPI DebugORPCClientGetBufferSize(
	RPCOLEMESSAGE *	pMessage,
	REFIID			iid,
	void *			reserved,
	IUnknown *		pUnkProxyMgr,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

void WINAPI DebugORPCClientFillBuffer(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	void *				reserved,
	IUnknown *			pUnkProxyMgr,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

void WINAPI DebugORPCClientNotify(
	RPCOLEMESSAGE *	pMessage,
	REFIID			iid,
	void *			reserved,
	IUnknown *		pUnkProxyMgr,
	HRESULT			hresult,
	void *			pvBuffer,
	ULONG			cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

void WINAPI DebugORPCServerNotify(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

ULONG WINAPI DebugORPCServerGetBufferSize(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

void WINAPI DebugORPCServerFillBuffer(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled);

#endif // __ORPC_DBG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\refcache.cxx ===
//+-------------------------------------------------------------------
//
//  File:       refcache.cxx
//
//  Contents:   class implementing a cache for client side reference
//              counts process wide.
//
//  Classes:    CRefCache
//
//  History:    31-Jul-97 MattSmit  Created
//              10-Nov-98 Rickhi    Merged code from Resolver
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <resolver.hxx>      // gResolver
#include    <refcache.hxx>      // class def's
#include    <smemscm.hxx>

#ifdef _CHICAGO_
#include <objbase.h>            // for CoInitializeEx
#include <forward.h>            // IID_IRemoteActivator
#endif // _CHICAGO_


// critical section guarding channel initialization
extern COleStaticMutexSem  gChannelInitLock;


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//                                                                        //
//                           CRefCache Implementation                     //
//                                                                        //
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
// Member:    Constructor
//
// Synopsis:  Initialize members
//
// History:   07-24-97  MattSmit   Created
//
//+-------------------------------------------------------------------------
CRefCache::CRefCache() :
    _cRefs(1),
    _cStrongItfs(0),
    _cWeakItfs(0),
    _cTableStrong(0),
    _cIRCs(0),
    _pIRCList(NULL)
{
    RefCacheDebugOut((DEB_TRACE, "CRefCache created: this = 0x%x\n", this));
}

//+-------------------------------------------------------------------------
//
// Member:    Destructor
//
// Synopsis:  delete list nodes
//
// History:   07-24-97  MattSmit   Created
//
//+-------------------------------------------------------------------------
CRefCache::~CRefCache()
{
    ASSERT_LOCK_HELD(gIPIDLock);
    RefCacheDebugOut((DEB_TRACE, "CRefCache destroyed: this = 0x%x\n", this));
    AssertValid();
    Win4Assert(!_cRefs);
    Win4Assert(!_cStrongItfs);
    Win4Assert(!_cWeakItfs);

    // cleanup the list of IRCEntries chained off this guy.
    while (_pIRCList)
    {
        Win4Assert(!_pIRCList->cStrongUsage &&
                   !_pIRCList->cWeakUsage &&
                   !_pIRCList->cStrongRefs &&
                   !_pIRCList->cWeakRefs);

        IRCEntry *pTemp = _pIRCList;
        _pIRCList = _pIRCList->pNext;
        delete pTemp;
    }
}

//+-------------------------------------------------------------------------
//
// Member:    AssertValid
//
// Synopsis:  assert internal integrity
//
// History:   07-24-97  MattSmit   Created
//
//+-------------------------------------------------------------------------
#if DBG==1
void CRefCache::AssertValid()
{
    ASSERT_LOCK_HELD(gIPIDLock);

    ULONG cStrongCheck = 0;
    ULONG cWeakCheck   = 0;
    ULONG cCountCheck  = 0;

    IRCEntry *pIRCEntry = _pIRCList;
    while (pIRCEntry)
    {
        Win4Assert(_cStrongItfs || _cTableStrong || !pIRCEntry->cStrongRefs);
        Win4Assert(_cWeakItfs || !pIRCEntry->cWeakRefs);

        cStrongCheck += pIRCEntry->cStrongUsage;
        cWeakCheck   += pIRCEntry->cWeakUsage;
        cCountCheck++;
        pIRCEntry     = pIRCEntry->pNext;
    }

    // The sum of the counts in the IRCs should equal
    // the total in the CRefCache object
    Win4Assert(_cIRCs == cCountCheck);
    Win4Assert(cStrongCheck == _cStrongItfs);
    Win4Assert(cWeakCheck == _cWeakItfs);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::TrackIPIDEntry
//
//  Synopsis:   Inform the cache to keep track of this proxy
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void CRefCache::TrackIPIDEntry(IPIDEntry *pIPIDEntry)
{
    RefCacheDebugOut((DEB_TRACE,
      "CRefCache::TrackIPIDEntry this:%x pIPIDEntry:0x%x\n",this,pIPIDEntry));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    // make this routine idempotent since it could get
    // called on another thread when this one yields to
    // call RemoteAddref
    if (!pIPIDEntry->pIRCEntry)
    {
        // find or make an IRCEntry
        IRCEntry *pIRCEntry = ClientFindIRCEntry(pIPIDEntry->ipid);
        if (pIRCEntry)
        {
            pIPIDEntry->pIRCEntry = pIRCEntry;

            // mark IPIDEntry as holding a strong ref in the IRCEntry
            // and increment usage counts.
            Win4Assert(!pIPIDEntry->cWeakRefs);
            pIPIDEntry->dwFlags |= IPIDF_STRONGREFCACHE;
            ++ pIRCEntry->cStrongUsage;
            ++ _cStrongItfs;
        }

        AssertValid();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::ClientFindIRCEntry
//
//  Synopsis:   Returns the IRCEntry for the given IPID
//
//  History:    30-Mar-97   Rickhi      Created.
//
//--------------------------------------------------------------------
IRCEntry *CRefCache::ClientFindIRCEntry(REFIPID ripid)
{
    RefCacheDebugOut((DEB_TRACE,
       "CRefCache::ClientFindIRCEntry this:%x ipid:%I\n", this, &ripid));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    // look for a matching IPID in the IRC list
    IRCEntry *pIRCEntry = _pIRCList;
    while (pIRCEntry)
    {
        if (InlineIsEqualGUID(pIRCEntry->ipid, ripid))
        {
            // found the entry, break
            break;
        }
        pIRCEntry =  pIRCEntry->pNext;
    }

    if (pIRCEntry == NULL)
    {
        // no record found, try to allocate one for this IPID
        pIRCEntry = new IRCEntry;
        if (pIRCEntry)
        {
            // initialize it and chain it to the SOIDReg.
            pIRCEntry->ipid         = ripid;
            pIRCEntry->cStrongRefs  = 0;
            pIRCEntry->cWeakRefs    = 0;
            pIRCEntry->cPrivateRefs = 0;
            pIRCEntry->cStrongUsage = 0;
            pIRCEntry->cWeakUsage   = 0;
            pIRCEntry->pRefCache    = this;

            pIRCEntry->pNext        = _pIRCList;
            _pIRCList               = pIRCEntry;
            _cIRCs                 += 1;
        }
    }

    AssertValid();
    RefCacheDebugOut((DEB_TRACE,
            "CRefCache::ClientFindIRCEntry pIRCEntry: %x\n", pIRCEntry));
    return pIRCEntry;
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::ReleaseIPIDEntry
//
//  Synopsis:   Stop tracking a proxy in the reference cache
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void  CRefCache::ReleaseIPIDEntry(IPIDEntry            *pIPIDEntry,
                                  REMINTERFACEREF     **ppRifRef,
                                  USHORT               *pcRifRef)
{
    RefCacheDebugOut((DEB_TRACE, "CRefCache::ReleaseIPIDEntry pIPIDEntry:0x%x"
               "ipid:%I ppRifRef = OX%x, pcRifRef = %d\n",
               pIPIDEntry, &pIPIDEntry->ipid, ppRifRef, pcRifRef));
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(!(pIPIDEntry->dwFlags & IPIDF_NOPING));
    AssertValid();

    // Use references for convenience
    REMINTERFACEREF    *&pRifRef = *ppRifRef;
    USHORT              &cRifRef = *pcRifRef;

    if (!pIPIDEntry->pIRCEntry)
    {
        // no caching, so just release the references
        RefCacheDebugOut((DEB_TRACE,
            "CRefCache::ReleaseIPIDEntry no caching .. releasing reference\n"));

        if (pIPIDEntry->cStrongRefs > 0)
        {
            if (pRifRef)
            {
                pRifRef->cPublicRefs     = pIPIDEntry->cStrongRefs;
                pRifRef->cPrivateRefs    = 0;
                pRifRef->ipid            = pIPIDEntry->ipid;
                pRifRef++;
                cRifRef++;
            }
            pIPIDEntry->cStrongRefs  = 0;
        }
        else if (pIPIDEntry->cWeakRefs > 0)
        {
            if (pRifRef)
            {
                pRifRef->cPublicRefs     = pIPIDEntry->cWeakRefs;
                pRifRef->cPrivateRefs    = 0;
                pRifRef->ipid            = pIPIDEntry->ipid;
                pRifRef->ipid.Data1     |= IPIDFLAG_WEAKREF;
                pRifRef++;
                cRifRef++;
            }
            pIPIDEntry->cWeakRefs    = 0;
        }
    }
    else
    {
        IRCEntry *pIRCEntry = pIPIDEntry->pIRCEntry;

        if (pIPIDEntry->dwFlags & IPIDF_WEAKREFCACHE)
        {
            // give the weak references to the IRCEntry
            Win4Assert(!pIPIDEntry->cPrivateRefs);
            pIRCEntry->cWeakRefs  += pIPIDEntry->cWeakRefs;
            pIPIDEntry->cWeakRefs  = 0;

            // count one less weak reference user
            pIPIDEntry->dwFlags &= ~IPIDF_WEAKREFCACHE;
            --pIRCEntry->cWeakUsage;
            if (--_cWeakItfs == 0)
            {
                // this is the last weak proxy -- cleanup
                CleanupWeak(&pRifRef, &cRifRef);
            }
        }
        else
        {
            Win4Assert(pIPIDEntry->dwFlags & IPIDF_STRONGREFCACHE);

            // give the strong references to the IRCEntry
            pIRCEntry->cStrongRefs  += pIPIDEntry->cStrongRefs;
            pIPIDEntry->cStrongRefs  = 0;

            // count one less strong reference user
            pIPIDEntry->dwFlags &= ~IPIDF_STRONGREFCACHE;
            --pIRCEntry->cStrongUsage;
            if (--_cStrongItfs == 0 && _cTableStrong == 0)
            {
                // this is the last strong proxy -- cleanup
                CleanupStrong(&pRifRef, &cRifRef);
            }
        }

        // don't reference the IRCEntry from this client any more
        pIPIDEntry->pIRCEntry = NULL;
    }

    // we can't cache private references w/o keeping track of the
    // principle of the apartment they came from.  Too much work,
    // so we'll just release them now.
    if (pIPIDEntry->cPrivateRefs > 0)
    {
        if (pRifRef)
        {
            pRifRef->cPrivateRefs    = pIPIDEntry->cPrivateRefs;
            pRifRef->cPublicRefs     = 0;
            pRifRef->ipid            = pIPIDEntry->ipid;
            pRifRef++;
            cRifRef++;
        }
        pIPIDEntry->cPrivateRefs = 0;
    }

    AssertValid();
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::GetSharedRefs
//
//  Synopsis:   Gets any available shared references for an interface IPID
//
//  History:    30-Mar-97   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRefCache::GetSharedRefs(IPIDEntry *pIPIDEntry, ULONG cStrong)
{
    RefCacheDebugOut((DEB_TRACE,
       "CRefCache::GetSharedRefs this:%x pIPIDEntry:%x cStrong = %d\n",
       this, pIPIDEntry, cStrong));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    HRESULT hr = E_FAIL;

    IRCEntry *pIRCEntry = pIPIDEntry->pIRCEntry;
    if (pIRCEntry)
    {
        if (pIRCEntry->cStrongRefs >= cStrong)
        {
            // got all the references we need right here
            pIRCEntry->cStrongRefs -= cStrong;
            hr = S_OK;
        }
    }

    AssertValid();
    RefCacheDebugOut((DEB_TRACE, "CRefCache::GetSharedRefs hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::GiveUpRefs
//
//  Synopsis:   Takes extra references and stores them in the cache
//
//  History:    01-Aug-97   MattSmit     Created.
//
//--------------------------------------------------------------------
void CRefCache::GiveUpRefs(IPIDEntry *pIPIDEntry)
{
    RefCacheDebugOut((DEB_TRACE,"CRefCache::GiveUpRefs this:%x pIPIDEntry:%x\n",
       this, pIPIDEntry));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    IRCEntry *pIRCEntry = pIPIDEntry->pIRCEntry;
    if (pIRCEntry)
    {
        // store extra references in the cache
        if (pIPIDEntry->cStrongRefs > 0)
        {
            Win4Assert(pIPIDEntry->dwFlags & IPIDF_STRONGREFCACHE);
            pIRCEntry->cStrongRefs += pIPIDEntry->cStrongRefs;
            pIPIDEntry->cStrongRefs = 0;
        }
        else if (pIPIDEntry->cWeakRefs > 1)
        {
            Win4Assert(pIPIDEntry->dwFlags & IPIDF_WEAKREFCACHE);
            pIRCEntry->cWeakRefs += pIPIDEntry->cWeakRefs - 1;
            pIPIDEntry->cWeakRefs = 1;
        }
    }

    AssertValid();
    RefCacheDebugOut((DEB_TRACE, "leaving CRefCache::GiveUpRefs\n"));
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::ChangeRef
//
//  Synopsis:   Changes cached references from weak to strong and vice
//              versa
//
//  Parameters: [pIPIDEntry] - ptr to IPIDEntry
//              [fLock] - TRUE:  Convert Weak Refs to Strong Refs
//                        FALSE: Convert Strong Refs to Weak Refs
//              [ppRifRefChange] - references to change
//              [pcRifRefChange] - count of references to change
//              [ppRifRefRelease] - cached references to release
//              [pcRifRefRelease] - count of cached refs to change
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void CRefCache::ChangeRef(IPIDEntry           *pIPIDEntry,
                          BOOL                 fLock,
                          REMINTERFACEREF    **ppRifRefChange,
                          USHORT              *pcRifRefChange,
                          REMINTERFACEREF    **ppRifRefRelease,
                          USHORT              *pcRifRefRelease)

{
    RefCacheDebugOut((DEB_TRACE, "CRefCache::ChangeRef pIPIDEntry:0x%x "
               "ppRifRefChange = 0x%x, pcRifRefChange = 0x%x "
               "ppRifRefRelease = OX%X, pcRifRefRelease = %d\n",
               pIPIDEntry, ppRifRefChange, pcRifRefChange,
               ppRifRefRelease, pcRifRefRelease));
    Win4Assert(ppRifRefChange  && pcRifRefChange &&
               ppRifRefRelease && pcRifRefRelease);
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    IRCEntry *pIRCEntry = pIPIDEntry->pIRCEntry;
    if (!pIRCEntry)
    {
        RefCacheDebugOut((DEB_TRACE, "CRefCache::ChangeRef No pIRCEntry ... Leaving.\n"));
        return;
    }
    Win4Assert(pIRCEntry->pRefCache == this);
    Win4Assert(pIPIDEntry->cPrivateRefs == 0);

    // use references
    REMINTERFACEREF    *&pRifRefChange = *ppRifRefChange;
    USHORT              &cRifRefChange = *pcRifRefChange;

    if (!fLock && (pIPIDEntry->dwFlags & IPIDF_STRONGREFCACHE))
    {
        Win4Assert(pIRCEntry->cStrongUsage > 0);
        if (-- pIRCEntry->cStrongUsage == 0 && pIRCEntry->cStrongRefs &&
            _cTableStrong == 0)
        {
            // No more strong objects using this IPID
            // Need to change all the refs in the cache so the
            // object will get a call on IExternalConnection.
            pRifRefChange->cPublicRefs  = pIRCEntry->cStrongRefs;
            pRifRefChange->cPrivateRefs = 0;
            pRifRefChange->ipid         = pIPIDEntry->ipid;
            ++ cRifRefChange;
            ++ pRifRefChange;
            pIRCEntry->cWeakRefs       += pIRCEntry->cStrongRefs;
            pIRCEntry->cStrongRefs      = 0;
        }

        // adjust the usage counts to count one more weak and one less
        // strong reference, and mark the IPIDEntry appropriately.
        ++ pIRCEntry->cWeakUsage;
        ++ _cWeakItfs;
        pIPIDEntry->dwFlags |= IPIDF_WEAKREFCACHE;
        pIPIDEntry->dwFlags &= ~IPIDF_STRONGREFCACHE;
        if (-- _cStrongItfs == 0 && _cTableStrong == 0)
        {
            // changing this reference to weak released the last strong
            // count on this identity.  Relase all the strong counts
            // the cache is holding so IExternalConnection wil be called
            CleanupStrong(ppRifRefRelease, pcRifRefRelease);
        }
    }
    else if (fLock && (pIPIDEntry->dwFlags & IPIDF_WEAKREFCACHE))
    {
        // weak -> strong
        Win4Assert(pIRCEntry->cWeakUsage > 0);
        if ((-- pIRCEntry->cWeakUsage == 0) && (pIRCEntry->cWeakRefs))
        {
            // we don't really need to do this, because the
            // cached weak references would get cleaned up when
            // the last strong count goes, but since we are
            // already making the trip, we'll convert these
            // references also so we can use them if we need them
            pRifRefChange->cPublicRefs   = pIRCEntry->cWeakRefs;
            pRifRefChange->cPrivateRefs  = 0;
            pRifRefChange->ipid          = pIPIDEntry->ipid;
            ++ cRifRefChange;
            ++ pRifRefChange;
            pIRCEntry->cStrongRefs      += pIRCEntry->cWeakRefs;
            pIRCEntry->cWeakRefs         = 0;
        }

        // adjust the usage counts to count one more strong and one less
        // weak reference, and mark the IPIDEntry appropriately.
        ++ pIRCEntry->cStrongUsage;
        ++ _cStrongItfs;
        pIPIDEntry->dwFlags |= IPIDF_STRONGREFCACHE;
        pIPIDEntry->dwFlags &= ~IPIDF_WEAKREFCACHE;
        -- _cWeakItfs;
        // No need to call CleanupWeak because it does nothing if
        // there are still strong objects which there are because
        // we just converted one
    }

    AssertValid();
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::CleanupStrong
//
//  Synopsis:   Called when the number of strong interfaces goes to
//              zero.  Releases all strong references in the cache.
//              Also releases weak references if there are no weak
//              interfaces left.
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void CRefCache::CleanupStrong(REMINTERFACEREF **ppRifRef, USHORT *pcRifRef)
{
    RefCacheDebugOut((DEB_TRACE, "CRefCache::CleanupStrong "
               "this = 0x%x, ppRifRef = OX%x, pcRifRef = %d\n",
               this, ppRifRef, pcRifRef));
    ASSERT_LOCK_HELD(gIPIDLock);

    // use references -- more conveinient
    REMINTERFACEREF    *&pRifRef = *ppRifRef;
    USHORT              &cRifRef = *pcRifRef;

    IRCEntry *pIRCEntry = _pIRCList;

    while (pIRCEntry)
    {
        if (pIRCEntry->cStrongRefs)
        {
            if (pRifRef)
            {            
                pRifRef->cPublicRefs    = pIRCEntry->cStrongRefs;
                pRifRef->cPrivateRefs   = 0;
                pRifRef->ipid           = pIRCEntry->ipid;
                pRifRef++;
                cRifRef++;
            }
            pIRCEntry->cStrongRefs  = 0;
        }
        // clean up any weak reference if there are no more
        // weak proxies.
        if (!_cWeakItfs && (pIRCEntry->cWeakRefs))
        {
            if (pRifRef)
            {
                pRifRef->cPublicRefs    = pIRCEntry->cWeakRefs;
                pRifRef->cPrivateRefs   = 0;
                pRifRef->ipid           = pIRCEntry->ipid;
                pRifRef->ipid.Data1    |= IPIDFLAG_WEAKREF;
                pRifRef++;
                cRifRef++;
            }
            pIRCEntry->cWeakRefs    = 0;
        }

        pIRCEntry = pIRCEntry->pNext;
    }

    AssertValid();
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::CleanupWeak
//
//  Synopsis:   Called when the number of weak interfaces goes to
//              zero.  If there are still strong interfaces, this
//              function does nothing and lets the CleanupStrong
//              cleanup the weak counts as well.  If there are no
//              strong proxies left, the weak references are released.
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void CRefCache::CleanupWeak(REMINTERFACEREF **ppRifRef, USHORT *pcRifRef)
{
    RefCacheDebugOut((DEB_TRACE, "CRefCache::CleanupWeak "
               "this = 0x%x, ppRifRef = OX%X, pcRifRef = 0x%x\n",
               this, ppRifRef, pcRifRef));
    ASSERT_LOCK_HELD(gIPIDLock);

    if (_cStrongItfs == 0)
    {
        // use references -- more conveinient
        REMINTERFACEREF    *&pRifRef  = *ppRifRef;
        USHORT              &cRifRef  = *pcRifRef;
        IRCEntry           *pIRCEntry = _pIRCList;

        while (pIRCEntry)
        {
            RefCacheDebugOut((DEB_TRACE, "CRefCache::CleanupWeak "
                              "pIRCEntry:0x%x, ipid:%I, cWeakRefs:%d\n",
                              pIRCEntry, &pIRCEntry->ipid, pIRCEntry->cWeakRefs));
            if (pIRCEntry->cWeakRefs)
            {
                if (pRifRef)
                {
                    pRifRef->cPublicRefs    = pIRCEntry->cWeakRefs;
                    pRifRef->cPrivateRefs   = 0;
                    pRifRef->ipid           = pIRCEntry->ipid;
                    pRifRef->ipid.Data1    |= IPIDFLAG_WEAKREF;
                    pRifRef++;
                    cRifRef++;
                }
                pIRCEntry->cWeakRefs    = 0;
            }
            pIRCEntry = pIRCEntry->pNext;
        }
    }

    AssertValid();
}


//+-------------------------------------------------------------------
//
//  Member:     CRefCache::IncTableStrongCnt
//
//  Synopsis:   Called when a client marshals a proxy TABLESTRONG.
//              This keeps the client process pinging the server
//              object even in the absence of a proxy.
//
//  History:    01-Feb-99   Rickhi  Created
//
//+-------------------------------------------------------------------
ULONG CRefCache::IncTableStrongCnt()
{
    RefCacheDebugOut((DEB_TRACE,
        "CRefCache::IncTableStrongCnt this:%x _cTableStrong:%x\n",
        this, _cTableStrong+1));

    ASSERT_LOCK_HELD(gIPIDLock);
    ULONG cRefs = (++_cTableStrong);
    if (cRefs == 1)
    {
        // first TABLESTRONG reference, ensure we keep pinging the object.
        gROIDTbl.IncOIDRefCnt(&_soidReg);
    }

    return cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::DecTableStrongCnt
//
//  Synopsis:   Called when a client RMD's a proxy TABLESTRONG objref.
//              This stops the client process pinging the server
//              in the absence of an instantiated proxy.
//
//  History:    01-Feb-99   Rickhi  Created
//
//+-------------------------------------------------------------------
ULONG CRefCache::DecTableStrongCnt(BOOL fMarshaled,
                                   REMINTERFACEREF **ppRifRef,
                                   USHORT *pcRifRef)
{
    RefCacheDebugOut((DEB_TRACE,
        "CRefCache::DecTableStrongCnt this:%x _cTableStrong:%x\n",
        this, _cTableStrong-1));
    ASSERT_LOCK_HELD(gIPIDLock);

    // don't allow decrement if the count is already 0. Can happen if a
    // client does CRMD on a TABLESTRONG packet that the client did not
    // marshal TABLESTRONG (ie. they got the packet from the server).
    if (_cTableStrong == 0)
        return 0;

    ULONG cRefs = (--_cTableStrong);
    if (cRefs == 0)
    {
        // last TABLESTRONG reference, count one less usage and,
        // if it is the last usage, stop pinging.
        gROIDTbl.ClientDeRegisterOIDFromPingServer(this, fMarshaled);

        if (_cStrongItfs == 0)
        {
            // no more strong or tablestrong users, remote release the
            // remaining strong references.
            CleanupStrong(ppRifRef, pcRifRef);
        }
    }

    return cRefs;
}


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//                                                                        //
//                           CROIDTable Implementation                    //
//                                                                        //
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

SHashChain OIDBuckets[C_OIDBUCKETS] = {   {&OIDBuckets[0],  &OIDBuckets[0]},
                                          {&OIDBuckets[1],  &OIDBuckets[1]},
                                          {&OIDBuckets[2],  &OIDBuckets[2]},
                                          {&OIDBuckets[3],  &OIDBuckets[3]},
                                          {&OIDBuckets[4],  &OIDBuckets[4]},
                                          {&OIDBuckets[5],  &OIDBuckets[5]},
                                          {&OIDBuckets[6],  &OIDBuckets[6]},
                                          {&OIDBuckets[7],  &OIDBuckets[7]},
                                          {&OIDBuckets[8],  &OIDBuckets[8]},
                                          {&OIDBuckets[9],  &OIDBuckets[9]},
                                          {&OIDBuckets[10], &OIDBuckets[10]},
                                          {&OIDBuckets[11], &OIDBuckets[11]},
                                          {&OIDBuckets[12], &OIDBuckets[12]},
                                          {&OIDBuckets[13], &OIDBuckets[13]},
                                          {&OIDBuckets[14], &OIDBuckets[14]},
                                          {&OIDBuckets[15], &OIDBuckets[15]},
                                          {&OIDBuckets[16], &OIDBuckets[16]},
                                          {&OIDBuckets[17], &OIDBuckets[17]},
                                          {&OIDBuckets[18], &OIDBuckets[18]},
                                          {&OIDBuckets[19], &OIDBuckets[19]},
                                          {&OIDBuckets[20], &OIDBuckets[20]},
                                          {&OIDBuckets[21], &OIDBuckets[21]},
                                          {&OIDBuckets[22], &OIDBuckets[22]}
};


// the global ROID table
CROIDTable  gROIDTbl;

// static data in the ROID table class
#ifndef SHRMEM_OBJEX
// List of OIDs to register/ping/revoke with the resolver used
// for lazy/batch client-side OID processing.
SOIDRegistration CROIDTable::_ClientOIDRegList;
ULONG     CROIDTable::_cOidsToAdd    = 0; // # OIDs to add next call
ULONG     CROIDTable::_cOidsToRemove = 0; // # OIDs to remove next call
DWORD     CROIDTable::_dwSleepPeriod = 0; // worker thread sleep period
BOOL      CROIDTable::_fWorker = FALSE;   // worker thread not present
#endif // SHRMEM_OBJEX
CUUIDHashTable CROIDTable::_ClientRegisteredOIDs;


//+-------------------------------------------------------------------
//
//  Method:     CROIDTable::Initialize, public
//
//  Synopsis:   called to initialize the registered OID table.
//
//  History:    03-Nov-98   Rickhi      Created
//
//+-------------------------------------------------------------------
void CROIDTable::Initialize()
{
    LOCK(gIPIDLock);
    _ClientRegisteredOIDs.Initialize(OIDBuckets, &gIPIDLock);

#ifndef SHRMEM_OBJEX
    // empty the OIDRegList. Any SOIDRegistration records have already
    // been deleted by the gClientRegisteredOIDs list cleanup code.
    _ClientOIDRegList.pPrevList = &_ClientOIDRegList;
    _ClientOIDRegList.pNextList = &_ClientOIDRegList;
    _cOidsToAdd       = 0;
    _cOidsToRemove    = 0;
#endif // SHRMEM_OBJEX

    UNLOCK(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CleanupRegOIDs, public
//
//  Synopsis:   called to delete each node of the registered OID list.
//
//+-------------------------------------------------------------------
void CleanupRegOIDs(SHashChain *pNode)
{
    SOIDRegistration *pOIDReg = (SOIDRegistration *) pNode;
    CRefCache *pRefCache = pOIDReg->pRefCache;
    pOIDReg->pRefCache = NULL;
    ULONG cRefs = pRefCache->DecRefCnt();
    Win4Assert(cRefs == 0);
}

//+-------------------------------------------------------------------
//
//  Method:     CROIDTable::Cleanup, public
//
//  Synopsis:   called to cleanup the registered OID table.
//
//  History:    03-Nov-98   Rickhi      Created
//
//+-------------------------------------------------------------------
void CROIDTable::Cleanup()
{
    LOCK(gIPIDLock);
    _ClientRegisteredOIDs.Cleanup(CleanupRegOIDs);

#ifndef SHRMEM_OBJEX
    // empty the OIDRegList. Any SOIDRegistration records have already
    // been deleted by the gClientRegisteredOIDs list cleanup code.
    _ClientOIDRegList.pPrevList = &_ClientOIDRegList;
    _ClientOIDRegList.pNextList = &_ClientOIDRegList;
    _cOidsToAdd       = 0;
    _cOidsToRemove    = 0;
#endif // SHRMEM_OBJEX

    UNLOCK(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::ClientRegisterOIDWithPingServer
//
//  Synopsis:   registers an OID with the Ping Server if it has
//              not already been registered.
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CROIDTable::ClientRegisterOIDWithPingServer(REFMOID moid,
                                                    REFOXID roxid,
                                                    REFMID  rmid,
                                                    CRefCache **ppRefCache)
{
    ComDebOut((DEB_OXID, "ClientRegisterOIDWithPingServer moid:%I\n", &moid));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    HRESULT hr  = S_OK;
    *ppRefCache = NULL;

    // see if this OID already has a client-side registration
    // record created by another apartment in this process.

    DWORD iHash;
    SOIDRegistration *pOIDReg = LookupSOID(moid, &iHash);

    if (pOIDReg == NULL)
    {
        // not yet registered with resolver, create a new entry and
        // add it to the hash table and to the List of items to register
        // with the Resolver.

#ifndef SHRMEM_OBJEX
        // make sure we have a worker thread ready to do the register
        // at some point in the future.
        hr = EnsureWorkerThread();
#else // SHRMEM_OBJEX
        // we are using shared memory
        // just make sure we have a connection
        hr = gResolver.GetConnection();
#endif // SHRMEM_OBJEX

        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;
            CRefCache *pRefCache = new CRefCache();
            if (pRefCache)
            {
                pOIDReg = pRefCache->GetSOIDPtr();

                pOIDReg->cRefs      = 1;
                pOIDReg->pRefCache  = pRefCache;
                pOIDReg->mid        = rmid;
                pOIDReg->oxid       = roxid;

                // add a refcounted copy of it's pointer to the hash table
                pRefCache->IncRefCnt();
                _ClientRegisteredOIDs.Add(iHash, moid, (SUUIDHashNode *)pOIDReg);

                // return the RefCache ptr to the caller (caller takes ownership
                // of the initial refcnt)
                *ppRefCache = pRefCache;
#ifndef SHRMEM_OBJEX
                // using a worker thread so add it to the list to be registered
                // when the worker thread runs.
                pOIDReg->flags = ROIDF_REGISTER;
                AddToList(pOIDReg, &_ClientOIDRegList);
                _cOidsToAdd++;
                hr = S_OK;
#else // SHRMEM_OBJEX
                // we are using shared memory so add it to the shared memory
                // list immediately.
                pOIDReg->flags = 0;
                OID oid;
                OIDFromMOID(moid, &oid);
                hr = ClientAddOID(_ph, moid, roxid, rmid);
#endif // SHRMEM_OBJEX
            }
        }
    }
    else
    {
        // already have a record for this OID, count one more
        // reference

        // return the RefCache ptr to the caller, AddRef'd.
        *ppRefCache = pOIDReg->pRefCache;
        Win4Assert(*ppRefCache);
        (*ppRefCache)->IncRefCnt();

        // inc the refcnt
        IncOIDRefCnt(pOIDReg);
    }

    AssertValid();
    ASSERT_LOCK_HELD(gIPIDLock);
    ComDebOut((DEB_OXID,
            "ClientRegisterOIDWithPingServer pOIDReg:%x pRefCache:%x hr:%x\n",
            pOIDReg, *ppRefCache, hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::ClientDeRegisterOIDWithPingServer
//
//  Synopsis:   de-registers an OID that has previously been registered
//              with the Ping Server
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CROIDTable::ClientDeRegisterOIDFromPingServer(CRefCache *pRefCache,
                                                      BOOL fMarshaled)
{
    ComDebOut((DEB_OXID,"ClientDeRegisterOIDWithPingServer pRefCache:%x\n",
              pRefCache));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    SOIDRegistration *pOIDReg = pRefCache->GetSOIDPtr();
    Win4Assert(pOIDReg->pRefCache == pRefCache);
    Win4Assert((pOIDReg->flags == ROIDF_REGISTER) ||
               (pOIDReg->flags == (ROIDF_REGISTER | ROIDF_PING)) ||
               (pOIDReg->flags == 0));

#if DBG==1
    // find the OID in the hash table. it better still be there!
    DWORD iHash;
    SOIDRegistration *pOIDReg2 = LookupSOID(pOIDReg->Node.key, &iHash);
    Win4Assert(pOIDReg2 != NULL);
    Win4Assert(pOIDReg2 == pOIDReg);
#endif // DBG

    if (-- pOIDReg->cRefs == 0)
    {
        // this was the last registration of the OID in this process.

#ifndef SHRMEM_OBJEX
        // this never happens with shared memory
        if (pOIDReg->flags & ROIDF_REGISTER)
        {
            // still on the Register list, have not yet told the Ping Server
            // about this OID so dont have to do anything unless it was
            // client-side marshaled.

            if (fMarshaled || pOIDReg->flags & ROIDF_PING)
            {
                // object was marshaled by the client. Still need to tell
                // the Ping Server to ping the OID then forget about it.

                pOIDReg->flags = ROIDF_PING;
                _cOidsToRemove++;

                // make sure we have a worker thread ready to do the deregister
                // at some point in the future.  Not much we can do about an
                // error here. If transient, then a thread will most likely
                // be created later.
                EnsureWorkerThread();
            }
            else
            {
                // dont need this record any longer. remove from chain
                // and delete the record.

                RemoveFromList(pOIDReg);
                _cOidsToAdd--;
                _ClientRegisteredOIDs.Remove((SHashChain *)pOIDReg);
                pRefCache->DecRefCnt(); // release ref that hash table owned
                pOIDReg->pRefCache = NULL;
            }
        }
        else
        {
            // must already be registered with the resolver. now need to
            // deregister it so put it on the Registration list for delete.

            pOIDReg->flags = ROIDF_DEREGISTER;
            AddToList(pOIDReg, &_ClientOIDRegList);
            _cOidsToRemove++;

            // make sure we have a worker thread ready to do the deregister
            // at some point in the future.  Not much we can do about an
            // error here. If transient, then a thread will most likely
            // be created later.
            EnsureWorkerThread();
        }

#else // SHRMEM_OBJEX
        // make sure we have a connection --
        // Do we ever try to deregister something we didn't register?

        gResolver.GetConnection();

        OID Oid;
        OIDFromMOID(pOIDReg->Node.key, &Oid);
        MID Mid = pOIDReg->mid;

        ClientDropOID(_ph,Oid,Mid);
#endif // SHRMEM_OBJEX

    }

    AssertValid();
    ASSERT_LOCK_HELD(gIPIDLock);
    ComDebOut((DEB_OXID,"ClientDeRegisterOIDWithPingServer pOIDReg:%x hr:%x\n",
              pOIDReg, S_OK));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::IncOIDRefCnt
//
//  Synopsis:   Increments the RefCnt on an SOIDRegistration and determines
//              what, if any, effect this has on the state that needs to
//              be updated with the Ping Server.
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CROIDTable::IncOIDRefCnt(SOIDRegistration *pOIDReg)
{
    RefCacheDebugOut((DEB_TRACE,
        "CROIDTable::IncOIDRefCnt pOIDReg:%x cRefs:%x\n",
        pOIDReg, pOIDReg->cRefs+1));

    // inc the refcnt
    pOIDReg->cRefs++;
    if (pOIDReg->cRefs == 1)
    {
#ifndef SHRMEM_OBJEX
        // re-using an entry that had a count of zero, so it must have
        // been going to be deregistered or pinged.
        Win4Assert((pOIDReg->flags == ROIDF_PING) ||
                   (pOIDReg->flags == ROIDF_DEREGISTER));

        _cOidsToRemove--;

        if (pOIDReg->flags & ROIDF_PING)
        {
            // was only going to be pinged, now must be added.
            pOIDReg->flags |= ROIDF_REGISTER;
        }
        else
        {
            // was going to be unregistered, already registered so does
            // not need to be on the registration list anymmore

            Win4Assert(pOIDReg->flags & ROIDF_DEREGISTER);
            pOIDReg->flags = 0;
            RemoveFromList(pOIDReg);
        }
#endif // SHRMEM_OBJEX
    }
}


#ifndef SHRMEM_OBJEX
//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::ClientBulkUpdateOIDWithPingServer
//
//  Synopsis:   registers/deregisters/pings any OIDs waiting to be
//              sent to the ping server.
//
//  History:    30-Oct-95   Rickhi      Created.
//              13-Mar-01   Jsimmons    Modified to send soid unpins also
//
//--------------------------------------------------------------------
HRESULT CROIDTable::ClientBulkUpdateOIDWithPingServer(ULONG cOxidsToRemove,
                                                      ULONG cSOidsToUnpin)
{
    ComDebOut((DEB_OXID, "ClientBulkUpdateOIDWithPingServer\n"));
    ASSERT_LOCK_HELD(gIPIDLock);
    ASSERT_HELD_CONTINUOS_START(gIPIDLock);
    AssertValid();

    // Copy the counters so we can reset them before we make the call.
    // Allocate space for the Add, Status, and Remove lists to send to the
    // ping server, and remember the start address so we can free the
    // memory later. Compute the address of the other lists within the
    // one allocated memory block.

    ULONG cOidsToAdd     = _cOidsToAdd;
    ULONG cOidsToRemove  = _cOidsToRemove;
    Win4Assert((_cOidsToAdd + _cOidsToRemove + cOxidsToRemove + cSOidsToUnpin) != 0);

    // We're allocating five arrays of stuff in a single allocation.
    //
    // OXID_OID_PAIR pOidsToAdd[ cOidsToAdd ];
    // OID_MID_PAIR  pOidsToRemove[ cOidsToRemove ];
    // OID           pServerOidsToUnpin[ cSOidsToUnpin ];
    // OXID_REF      pOxidsToRemove[ cOxidsToRemove ];
    // ULONG         pStatusOfAdds[ cOidsToAdd ];
    //
    // pStatusOfAdds[] must appear at the end, otherwise subsequent arrays
    // will be unaligned in the event of an odd-numbered cOidsToAdd.

    ULONG cBytesToAlloc = (cOidsToAdd * sizeof(OXID_OID_PAIR))
                        + (cOidsToRemove * sizeof(OID_MID_PAIR))
                        + (cSOidsToUnpin * sizeof(OID))
                        + (cOxidsToRemove * sizeof(OXID_REF))
                        + (cOidsToAdd * sizeof(ULONG));


    OXID_OID_PAIR *pOidsToAdd;
    PVOID pvBytes;

    if (cBytesToAlloc < 0x7000)
    {
        pvBytes = NULL;
        pOidsToAdd = (OXID_OID_PAIR *)alloca(cBytesToAlloc);
    }
    else
    {
        pvBytes = PrivMemAlloc(cBytesToAlloc);
        pOidsToAdd = (OXID_OID_PAIR *) pvBytes;
    }

    if (pOidsToAdd == NULL)
    {
        // cant allocate memory. Leave the registration lists alone for
        // now, this may be a transient problem and we can handle the
        // registration later (unless of course the problem persists and
        // our object is run down!).

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        ComDebOut((DEB_ERROR, "ClientBulkUpdate OOM\n"));
        return E_OUTOFMEMORY;
    }

    OXID_OID_PAIR *pOidsToAddStart    = pOidsToAdd;
    OID_MID_PAIR  *pOidsToRemove      = (OID_MID_PAIR *)(&pOidsToAddStart[cOidsToAdd]);
    OID           *pSOidsToUnpin      = (OID*)&(pOidsToRemove[cOidsToRemove]);
    OXID_REF      *pOxidsToRemove     = (OXID_REF *) (&pSOidsToUnpin[cSOidsToUnpin]);
    LONG          *pStatusOfAdds      = (LONG *) (&pOxidsToRemove[cOxidsToRemove]);


    // Track the number of entries processed.
    DWORD cOidsAdded      = 0;
    DWORD cOidsRemoved    = 0;

    // loop through each OID registration records in the list filling in
    // the Add and Remove lists. Pinged OIDs are placed in both lists.

    while (_ClientOIDRegList.pNextList != &_ClientOIDRegList &&
           cOidsAdded + cOidsRemoved < cOidsToAdd + cOidsToRemove)
    {
        // get the entry and remove it from the registration list
        SOIDRegistration *pOIDReg = _ClientOIDRegList.pNextList;
        RemoveFromList(pOIDReg);

        // reset the state flags before we begin
        DWORD dwFlags = pOIDReg->flags;
        pOIDReg->flags = 0;

        if (dwFlags & (ROIDF_REGISTER | ROIDF_PING))
        {
            // register the OID with the ping server
            pOidsToAdd->mid  = pOIDReg->mid;
            pOidsToAdd->oxid = pOIDReg->oxid;
            OIDFromMOID  (pOIDReg->Node.key, &pOidsToAdd->oid);
            ComDebOut((DEB_OXID, "\tadd    moid:%I\n", &pOIDReg->Node.key));

            pOidsToAdd++;
            cOidsAdded++;
        }

        if (dwFlags == ROIDF_DEREGISTER || dwFlags == ROIDF_PING)
        {
            // ensure we have not exceeded the count
            Win4Assert(cOidsRemoved != cOidsToRemove);

            // deregister the OID with the ping server
            // Node.key is the OID+MID so extract each part
            pOidsToRemove->mid = pOIDReg->mid;
            OIDFromMOID(pOIDReg->Node.key, &pOidsToRemove->oid);
            ComDebOut((DEB_OXID, "\tremove moid:%I\n", &pOIDReg->Node.key));

            pOidsToRemove++;
            cOidsRemoved++;

            // dont need the entry any more since there are no more
            // users of it.  remove from hash table and release the
            // reference the hash table owned.
            _ClientRegisteredOIDs.Remove((SHashChain *)pOIDReg);
            pOIDReg->pRefCache->DecRefCnt();
        }
    }

    // make sure we got all the entries and that our counters work correctly.
    _cOidsToAdd    -= cOidsAdded;
    _cOidsToRemove -= cOidsRemoved;

    Win4Assert(_cOidsToAdd == 0);
    Win4Assert(_cOidsToRemove == 0);
    AssertValid();

    ASSERT_HELD_CONTINUOS_FINISH(gIPIDLock);
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Ask the OXID table to fill in the list of OXIDs to remove.
    // Note: We need to take the gChannelInitLock since that prevents
    // other threads from accessing anything we are about to cleanup
    // in FreeExpireEntries, in particular, the COXIDTable and CIPIDTable.
    ASSERT_LOCK_NOT_HELD(gChannelInitLock);
    LOCK(gChannelInitLock);

    gOXIDTbl.GetOxidsToRemove(pOxidsToRemove, &cOxidsToRemove);

    UNLOCK(gChannelInitLock);
    ASSERT_LOCK_NOT_HELD(gChannelInitLock);
		
    // Ask the server oid table to fill in the list of server oids that
    // need to be unpinned.
    if (cSOidsToUnpin > 0)
    {
        gOIDTable.GetServerOidsToUnpin(pSOidsToUnpin, &cSOidsToUnpin);
    }

    // reset the OidsToRemove and OxidsToRemove list pointers since we mucked with
    // them above.
    pOidsToRemove = (OID_MID_PAIR *)(&pOidsToAddStart[cOidsToAdd]);

    // CODEWORK: We could tell the resolver about OIDs that have been used
    // and freed. This would reduce the working set of the resolver in cases
    // where objects are created/destroyed frequently.

    // call the ping server
    HRESULT
    hr = gResolver.BulkUpdateOIDs(cOidsToAdd,       // #oids to add
                                  pOidsToAddStart,  // ptr to oids to add
                                  pStatusOfAdds,    // status of adds
                                  cOidsToRemove,    // #oids to remove
                                  pOidsToRemove,    // ptr to oids to remove
                                  cSOidsToUnpin,    // #soids to unpin
                                  pSOidsToUnpin,    // ptr to soids to unpin
                                  cOxidsToRemove,   // #oxids to remove
                                  pOxidsToRemove);  // ptr to oxids to remove
    if (cSOidsToUnpin > 0)
    {
        // The success cases we care about here are OR_OK or OR_PARTIAL_UPDATE.
        gOIDTable.NotifyUnpinOutcome(SUCCEEDED(hr));
    }

    // CODEWORK: reset the status flags for any OIDs not successfully added
    // to the resolver.

#if DBG==1
    LOCK(gIPIDLock);
    AssertValid();
    UNLOCK(gIPIDLock);
#endif

    PrivMemFree(pvBytes);  //  NULL if stack allocated

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_OXID, "ClientBulkUpdateOIDWithPingServer hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::EnsureWorkerThread
//
//  Synopsis:   Make sure there is a worker thread. Create one if
//              necessary.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CROIDTable::EnsureWorkerThread(void)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    HRESULT hr = S_OK;

    if (!_fWorker)
    {
        // no worker thread currently exists, try to create one. First, make
        // sure that we have a connection to the resolver.

        hr = gResolver.GetConnection();

        if (SUCCEEDED(hr))
        {
            // compute the sleep period for the registration worker thread
            // (which is 1/6th the ping period). The ping period may differ
            // on debug and retail builds.
            _dwSleepPeriod = BULK_UPDATE_RATE;

            hr = CacheCreateThread( WorkerThreadLoop, 0 );
            _fWorker = SUCCEEDED(hr);
            if (!_fWorker)
                ComDebOut((DEB_ERROR,"Create CROIDTable worker thread hr:%x\n",hr));
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::WorkerThreadLoop
//
//  Synopsis:   Worker thread for doing lazy/bulk OID registration
//              with the ping server.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
DWORD _stdcall  CROIDTable::WorkerThreadLoop(void *param)
{
    while (TRUE)
    {
        // sleep for a while to let the OIDs batch up in the registration list
        Sleep(_dwSleepPeriod);

        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);

        // NumOxids is not protected by the gIPIDLock so save it
        // off in a local variable and pass it in as a parameter
        ULONG cOxidsToRemove = gOXIDTbl.NumOxidsToRemove();
        ULONG cServerOidsToUnpin = gOIDTable.NumServerOidsToUnpin();

        if (_cOidsToAdd == 0 && 
            _cOidsToRemove == 0 &&
            cOxidsToRemove == 0 && 
            cServerOidsToUnpin == 0)
        {
            // There is no work to do. Exit this thread. If we need to
            // register more oids later we will spin up another thread.

            _fWorker = FALSE;
            UNLOCK(gIPIDLock);
            break;
        }

        ASSERT_LOCK_HELD(gIPIDLock);
        ClientBulkUpdateOIDWithPingServer(cOxidsToRemove, cServerOidsToUnpin);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::NotifyWorkWaiting
//
//  Synopsis:   Used by folks who are also depending on our worker 
//              thread to run.   Tries to create a worker thread. 
//
//  History:    13-Mar-01   JSimmons   Created.
//
//--------------------------------------------------------------------
void CROIDTable::NotifyWorkWaiting(void)
{
    ASSERT_LOCK_DONTCARE(gIPIDLock);
    LOCK(gIPIDLock);

    (void)EnsureWorkerThread();

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_DONTCARE(gIPIDLock);

    return;
}

#endif // SHRMEM_OBJEX


#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::AssertValid
//
//  Synopsis:   validates the state of this object
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CROIDTable::AssertValid()
{
#ifndef SHRMEM_OBJEX

    ASSERT_LOCK_HELD(gIPIDLock);

    Win4Assert((_cOidsToAdd & 0xf0000000) == 0x00000000);
    Win4Assert((_cOidsToRemove & 0xf0000000) == 0x00000000);

    if (_cOidsToAdd == 0 && _cOidsToRemove == 0)
    {
        // make sure the Reg list is empty.
        Win4Assert(_ClientOIDRegList.pPrevList == &_ClientOIDRegList);
        Win4Assert(_ClientOIDRegList.pNextList == &_ClientOIDRegList);
    }
    else
    {
        // make sure we have a worker thread. we cant assert because
        // we could be OOM trying to create the thread.
        if (!_fWorker)
        {
            ComDebOut((DEB_WARN, "No CROIDTable Worked Thread\n"));
        }

        // make sure the Reg list is consistent with the counters
        ULONG cAdd = 0;
        ULONG cRemove = 0;

        SOIDRegistration *pOIDReg = _ClientOIDRegList.pNextList;
        while (pOIDReg != &_ClientOIDRegList)
        {
            // make sure the flags are valid
            Win4Assert(pOIDReg->flags == ROIDF_REGISTER   ||
                       pOIDReg->flags == ROIDF_DEREGISTER ||
                       pOIDReg->flags == ROIDF_PING       ||
                       pOIDReg->flags == (ROIDF_PING | ROIDF_REGISTER));

            if (pOIDReg->flags & (ROIDF_REGISTER | ROIDF_PING))
            {
                // OID is to be registered
                cAdd++;
            }

            if (pOIDReg->flags == ROIDF_DEREGISTER ||
                pOIDReg->flags == ROIDF_PING)
            {
                // OID is to be deregistered
                cRemove++;
            }

            pOIDReg = pOIDReg->pNextList;
        }

        Win4Assert(cAdd == _cOidsToAdd);
        Win4Assert(cRemove == _cOidsToRemove);
    }

    ASSERT_LOCK_HELD(gIPIDLock);
#endif // SHRMEM_OBJEX
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\resolver.cxx ===
//+-------------------------------------------------------------------
//
//  File:       resolver.cxx
//
//  Contents:   class implementing interface to RPC OXID/PingServer
//              resolver process. Only one instance per process.
//
//  Classes:    CRpcResolver
//
//  History:    20-Feb-95   Rickhi      Created
//              30-Oct-98   TarunA      Added PID param to connect
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <resolver.hxx>      // CRpcResolver
#include    <service.hxx>       // GetStringBindings
#include    <locks.hxx>         // LOCK/UNLOCK etc
#include    <marshal.hxx>       // GetOXIDFromObjRef
#include    <channelb.hxx>      // gfCatchServerExceptions and gfBreakOnSilencedExceptions
#include    <sobjact.hxx>       // CObjServer
#include    <security.hxx>      // Security globals
#include    <events.hxx>        // Event logging functions
#include    <chock.hxx>         // Channel hook globals
#include    <secdes.hxx>        // CWorldSecurityDescriptor
#include    <smemscm.hxx>
#include    <immact.hxx>

#ifdef _CHICAGO_
#include <objbase.h>            // for CoInitializeEx
#include <forward.h>            // IID_IRemoteActivator
#endif // _CHICAGO_


// global instance of OXID resolver
CRpcResolver gResolver;

// static members of CRpcResolver
handle_t  CRpcResolver::_hRpc = NULL;       // binding handle to resolver
DWORD     CRpcResolver::_dwFlags = 0;       // flags
CDualStringArray* CRpcResolver::_pdsaLocalResolver = NULL;
DWORD64   CRpcResolver::_dwCurrentBindingsID = 0;
ULONG     CRpcResolver::_cReservedOidsAvail = 0;
__int64   CRpcResolver::_OidNextReserved = 0;
LPWSTR    CRpcResolver::_pwszWinstaDesktop = NULL;
ULONG64   CRpcResolver::_ProcessSignature = 0;
DWORD     CRpcResolver::_procID = 0;
ISCMLocalActivator *CRpcResolver::_pSCMProxy = NULL;     // scm proxy
COleStaticMutexSem  CRpcResolver::_mxsResolver;
PHPROCESS CRpcResolver::_ph = NULL;         // context handle to resolver process
GUID      CRpcResolver::_GuidRPCSSProcessIdentifier = GUID_NULL;

// MID (machine ID) of local machine
MID gLocalMid;

// Ping period in milliseconds.
DWORD giPingPeriod;

// Used for win95 and for ole enabled components loaded into
// rpcss (like cstore.lib)
static DummyISCMActivator gISCMActivator;
DummyISCMActivator * gpISCMActivator = &gISCMActivator;

// String arrays for the SCM process. These are used to tell the interface
// marshaling code the protocol and endpoint of the SCM process.
typedef struct tagSCMSA
{
    unsigned short wNumEntries;     // Number of entries in array.
    unsigned short wSecurityOffset; // Offset of security info.
    WCHAR awszStringArray[62];
} SCMSA;

// The last 4 characters in the string define the security bindings.
// \0xA is RPC_C_AUTHN_WINNT
// \0xFFFF is COM_C_AUTHZ_NONE
// \0 is an empty principle name
SCMSA saSCM = {24, 20, L"ncalrpc:[epmapper]\0\0\xA\xFFFF\0\0"};

// string binding to the resolver
const WCHAR *pwszResolverBindString = L"ncalrpc:[epmapper,Security=Impersonation Dynamic False]";

const DWORD ANY_CLOAKING = EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING;

// Global to tell us if we're in a 64bit process or not
#ifndef _WIN64
const BOOL gbWin64Process = FALSE;
#else
const BOOL gbWin64Process = TRUE;
#endif

BOOL GetEnvBlock( PRIV_SCM_INFO * pScmInfo );

extern "C" HRESULT GetActivationPropertiesIn(
                                    ActivationPropertiesIn *pActIn,
                                    REFCLSID rclsid,
                                    DWORD dwContext,
                                    COSERVERINFO * pServerInfo,
                                    DWORD cIIDs,
                                    IID *iidArray,
                                    DWORD actvflags,
                                    PVOID notUsed1,
                                    PVOID notUsed2);

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::Cleanup, public
//
//  Synopsis:   cleanup the resolver state. Called by ProcessUninitialze.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CRpcResolver::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    LOCK(_mxsResolver);

    // release our context handle
    if (_ph != NULL)
    {
        RpcSmDestroyClientContext(&_ph);
        _ph = NULL;
    }

    // release regular handle
    if (_hRpc)
    {
        RpcBindingFree(&_hRpc);
        _hRpc = NULL;
    }

    // Release the string bindings for the local object exporter.
    SetLocalResolverBindings(0, NULL);

    if (_pwszWinstaDesktop != NULL)
    {
        PrivMemFree(_pwszWinstaDesktop);
        _pwszWinstaDesktop = NULL;
    }

    _procID = 0;

    // reset the flags
    _dwFlags = 0;

    UNLOCK(_mxsResolver);
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ReleaseSCMProxy, public
//
//  Synopsis:   cleanup the resolver state. Called by ProcessUninitialze.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CRpcResolver::ReleaseSCMProxy()
{
    LOCK(_mxsResolver);

    // NULL the ptr in a thread-safe fashion
    ISCMLocalActivator *pSCM = _pSCMProxy;
    _pSCMProxy = NULL;

    UNLOCK(_mxsResolver);

    if (pSCM != NULL)
    {
        // release the proxy to the SCM
        pSCM->Release();
    }

    // CODEWORK: Why are these here and not in the activation
    // cleanup code?
    if (gpMTAObjServer != NULL)
    {
        delete gpMTAObjServer;
        gpMTAObjServer = NULL;
    }

    if (gpNTAObjServer != NULL)
    {
        delete gpNTAObjServer;
        gpNTAObjServer = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetSCMProxy, public
//
//  Synopsis:   Gets a proxy to the SCM.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::GetSCMProxy(ISCMLocalActivator** ppScmProxy)
{
    HRESULT hr = BindToSCMProxy();

    if (FAILED(hr))
    {
        return hr;
    }

    *ppScmProxy = _pSCMProxy;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::RetryRPC, private
//
//  Synopsis:   determine if we need to retry the RPC call due to
//              the resolver being too busy.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
BOOL CRpcResolver::RetryRPC(RPC_STATUS sc)
{
    if (sc != RPC_S_SERVER_TOO_BUSY)
        return FALSE;

    // give the resolver time to run, then try again.
    Sleep(100);

    // CODEWORK: this is currently an infinite loop. Should we limit it?
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::CheckStatus, private
//
//  Synopsis:   Checks the status code of an Rpc call, prints a debug
//              ERROR message if failed, and maps the failed status code
//              into an HRESULT.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::CheckStatus(RPC_STATUS sc)
{
    if (sc != RPC_S_OK)
    {
        ComDebOut((DEB_ERROR, "OXID Resolver Failure sc:%x\n", sc));
        sc = HRESULT_FROM_WIN32(sc);
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetConnection, public
//
//  Synopsis:   connects to the resolver process
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::GetConnection()
{
    ComDebOut((DEB_OXID,"CRpcResolver::GetConnection\n"));

    // ensure TLS is initialized for this thread.
    HRESULT     hr;
    COleTls     tls(hr);
    if (FAILED(hr))
        return(hr);

    // if already initailized, just return
    if (IsConnected())
        return S_OK;


    RPC_STATUS  sc = RPC_S_OK;

    // only 1 thread should do the initialization
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    LOCK(_mxsResolver);

    if (!IsConnected())
    {
        OID     oidBase;
        DWORD   fConnectFlags;
        DUALSTRINGARRAY *psaResolver = NULL;
        DWORD   dwFlags = 0;

        _procID = GetCurrentProcessId();

        if (gbWin64Process)
            dwFlags |= CONNECT_FLAGS_64BIT;

        if ( _pwszWinstaDesktop == NULL )
            sc = GetThreadWinstaDesktop();

        if ( sc == RPC_S_OK )
        {
            sc = RpcBindingFromStringBinding((LPWSTR)pwszResolverBindString, &_hRpc);
            ComDebErr(sc != RPC_S_OK, "Resolver Binding Failed.\n");
        }

        if (sc == RPC_S_OK)
        {
            BOOL fRunningInWinlogon = FALSE;
            HANDLE hImpToken = NULL;
            
            // There are times when this code gets called in winlogon while 
            // impersonating; we don't want resolver to cache the thread token,
            // so strip it before calling.   This really should be done for all
            // apps but appcompat concerns say do minimal change.
            fRunningInWinlogon = RunningInWinlogon();
            if (fRunningInWinlogon)
            {
                SuspendImpersonate(&hImpToken);
            }

            do
            {
                // call the resolver to get a context handle
                sc = Connect(_hRpc,
                             _pwszWinstaDesktop,
                             _procID,
                             dwFlags,
                             &_ph,
                             &giPingPeriod,
                             &psaResolver,
                             &gLocalMid,
                             MAX_RESERVED_OIDS,
                             &oidBase,
                             &fConnectFlags,
                             (WCHAR **) &gLegacySecurity,
                             &gAuthnLevel,
                             &gImpLevel,
                             &gServerSvcListLen,
                             &gServerSvcList,
                             &gClientSvcListLen,
                             &gClientSvcList,
                             &gcChannelHook,
                             &gaChannelHook,
                             &(tls->dwApartmentID),
                             &gdwScmProcessID,
                             &_ProcessSignature,
                             &_GuidRPCSSProcessIdentifier);
            }  while (RetryRPC(sc));

            ResumeImpersonate(hImpToken);
			
            if (sc == RPC_S_OK)
            {
                Win4Assert(_pdsaLocalResolver == NULL);
                Win4Assert((psaResolver != NULL) && "out-param NULL on success");

                sc = RPC_S_OUT_OF_MEMORY;
                
                // Can't use psaResolver in our CDualStringArray object, since 
                // RPC uses a different heap.  So make a copy.
                DUALSTRINGARRAY* psaLocalCopy;
                hr = CopyDualStringArray(psaResolver, &psaLocalCopy);
                if (SUCCEEDED(hr))
                {
                    // Allocate initial wrapper object for resolver bindings.
                    CDualStringArray* pdsaResolver = new CDualStringArray(psaLocalCopy);
                    if (pdsaResolver)
                    {
                        _pdsaLocalResolver = pdsaResolver;
                        sc = RPC_S_OK;

                        // We no longer need the RPC-allocated bindings
                        MIDL_user_free( psaResolver );
                        psaResolver = NULL;
                    }
                    else
                        delete psaLocalCopy;
                }
            }

            // If the call fails, some out parameters may be set while others
            // are not.  Make the out parameters consistent.
            if (sc != RPC_S_OK)
            {
                // Leak any principal names stored in gClientSvcList because
                // there is no way to tell how much of the structure was
                // initialized.
                MIDL_user_free( gClientSvcList );
                MIDL_user_free( gServerSvcList );
                MIDL_user_free( gLegacySecurity );
                MIDL_user_free( psaResolver );

                gServerSvcListLen = 0;
                gServerSvcList    = NULL;
                gClientSvcListLen = 0;
                gClientSvcList    = NULL;
                gLegacySecurity   = NULL;
            }
            else
            {
                // Sanity check
                Win4Assert((_ph != 0) && (gdwScmProcessID != 0) &&
                           (_pdsaLocalResolver->DSA() != 0) && (_ProcessSignature != 0));
            }
        }

        if (sc == RPC_S_OK)
            
        {
            gfCatchServerExceptions = fConnectFlags & CONNECT_CATCH_SERVER_EXCEPTIONS;
            gfBreakOnSilencedExceptions = fConnectFlags & CONNECT_BREAK_ON_SILENCED_SERVER_EXCEPTIONS;
            gDisableDCOM            = fConnectFlags & CONNECT_DISABLEDCOM;

            if (fConnectFlags & CONNECT_MUTUALAUTH)
                gCapabilities = EOAC_MUTUAL_AUTH;
            else
                gCapabilities = EOAC_NONE;
            if (fConnectFlags & CONNECT_SECUREREF)
                gCapabilities |= EOAC_SECURE_REFS;

            // remember the reserved OID base.
            _OidNextReserved    = oidBase;
            _cReservedOidsAvail = MAX_RESERVED_OIDS;

            // Mark the security data as initialized.
            gGotSecurityData = TRUE;
            if (IsWOWProcess())
            {
                gDisableDCOM = TRUE;
            }
#ifndef SSL
            // Don't use SSL until the bug fixes are checked in.
            DWORD i;
            for (i = 0; i < gServerSvcListLen; i++)
                if (gServerSvcList[i] == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                    // Remove SSL without reordering the list.
                    memcpy( &gServerSvcList[i], &gServerSvcList[i+1],
                            sizeof(gServerSvcList[i]) * (gServerSvcListLen-i-1) );
                    gServerSvcListLen -= 1;
                    break;
                }

            for (i = 0; i < gClientSvcListLen; i++)
                if (gClientSvcList[i].wId == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                    // Remove SSL without reordering the list.
                    MIDL_user_free( gClientSvcList[i].pName );
                    memcpy( &gClientSvcList[i], &gClientSvcList[i+1],
                            sizeof(gClientSvcList[i]) * (gClientSvcListLen-i-1) );
                    gClientSvcListLen -= 1;
                    break;
                }
#endif
            // Convert the ping period from seconds to milliseconds.
            giPingPeriod *= 1000;
            Win4Assert(_pdsaLocalResolver->DSA()->wNumEntries != 0);

            // mark the resolver as connected now
            _dwFlags |= ORF_CONNECTED;
        }
        else
        {
            ComDebOut((DEB_ERROR, "Resolver Connect Failed sc:%x\n", sc));
            if (_hRpc)
            {
                RpcBindingFree(&_hRpc);
                _hRpc = NULL;
            }

            // release our context handle
            if (_ph != NULL)
            {
                RpcSmDestroyClientContext(&_ph);
                _ph = NULL;
            }
            Win4Assert(_pdsaLocalResolver == NULL);
        }
    }

    UNLOCK(_mxsResolver);
    ASSERT_LOCK_NOT_HELD(_mxsResolver);

    hr = CheckStatus(sc);
#if DBG==1
    if(FAILED(hr))
        ComDebOut((DEB_ERROR, "GetConnection Failed hr:0x%x\n",hr));
#endif
    ComDebOut((DEB_OXID,"CRpcResolver::GetConnection hr:%x\n", hr));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerGetReservedMOID, public
//
//  Synopsis:   Get an OID that does not need to be pinged.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//----------------------------------------------------------------------------
HRESULT CRpcResolver::ServerGetReservedMOID(MOID *pmoid)
{
    ComDebOut((DEB_OXID,"ServerGetReservedMOID\n"));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);

    OID oid;
    HRESULT hr = ServerGetReservedID(&oid);

    MOIDFromOIDAndMID(oid, gLocalMid, pmoid);

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID,"ServerGetReservedMOID hr:%x moid:%I\n", hr, pmoid));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerGetReservedID, public
//
//  Synopsis:   Get an ID that does not need to be pinged.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//----------------------------------------------------------------------------
HRESULT CRpcResolver::ServerGetReservedID(OID *pid)
{
    ComDebOut((DEB_OXID,"ServerGetReservedID\n"));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);

    HRESULT hr = S_OK;

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    LOCK(_mxsResolver);

    if ( _cReservedOidsAvail == 0 )
    {
        // go get more reserved OIDs from the ping server
        UNLOCK(_mxsResolver);
        ASSERT_LOCK_NOT_HELD(_mxsResolver);

        OID OidBase;

        do
        {
            hr = ::AllocateReservedIds(
                                      _hRpc,             // Rpc binding handle
                                      MAX_RESERVED_OIDS, // count of OIDs requested
                                      &OidBase);         // place to hold base id

        } while ( RetryRPC(hr) );

        // map Rpc status if necessary
        hr = CheckStatus(hr);

        ASSERT_LOCK_NOT_HELD(_mxsResolver);
        LOCK(_mxsResolver);

        if (SUCCEEDED(hr))
        {
            // copy into global state. Dont have to worry about two threads
            // getting more simultaneously, since these OIDs are expendable.
            _cReservedOidsAvail = MAX_RESERVED_OIDS;
            _OidNextReserved = OidBase;
        }
    }

    if (SUCCEEDED(hr))
    {
        // take the next OID on the list.
        *pid = _OidNextReserved;
        _OidNextReserved++;
        _cReservedOidsAvail--;
    }

    UNLOCK(_mxsResolver);
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID,"ServerGetReservedID hr:%x id:%08x %08x\n",
              hr, *pid ));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerRegisterOXID, public
//
//  Synopsis:   allocate an OXID and Object IDs with the local ping server
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::ServerRegisterOXID(OXID_INFO &oxidInfo,
                                         OXID      *poxid,
                                         ULONG     *pcOidsToAllocate,
                                         OID        arNewOidList[])
{
    ComDebOut((DEB_OXID, "ServerRegisterOXID TID:%x\n", GetCurrentThreadId()));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    Win4Assert(IsConnected());

    // make sure we have the local binding and security strings
    HRESULT hr = StartListen();
    ComDebErr(hr != S_OK, "StartListen Failed.\n");

    DWORD64 dwBindingsID = 0;
    DUALSTRINGARRAY *psaNewORBindings = NULL;
    if (hr == S_OK)
    {
        DUALSTRINGARRAY *psaSB = gpsaCurrentProcess; // string bindings
        DUALSTRINGARRAY *psaSC = gpsaSecurity;       // security bindings

        if (_dwFlags & ORF_STRINGSREGISTERED)
        {
            // already registered these once, dont need to do it again.
            psaSB = NULL;
            psaSC = NULL;
        }

        ComDebOut((DEB_OXID,"ServerRegisterOXID oxidInfo:%x psaSB:%x psaSC:%x\n",
            &oxidInfo, psaSB, psaSC));

        do
        {
            hr = ::ServerAllocateOXIDAndOIDs(
                            _hRpc,              // Rpc binding handle
                            _ph,                // context handle
                            poxid,              // OXID of server
                            IsSTAThread(),      // fApartment Threaded
                            *pcOidsToAllocate,  // count of OIDs requested
                            arNewOidList,       // array of reserved oids
                            pcOidsToAllocate,   // count actually allocated
                            &oxidInfo,          // OXID_INFO to register
                            psaSB,              // string bindings for process
                            psaSC,              // security bindings for process
                            &dwBindingsID,      // bindings id of psaNewORBindings
                            &psaNewORBindings); // current OR bindings, if non-NULLs
        } while (RetryRPC(hr));

        // map Rpc status if necessary
        hr = CheckStatus(hr);
    }
	
    // Save new OR bindings
    if (SUCCEEDED(hr) && psaNewORBindings)
    {
        hr = IUpdateResolverBindings(dwBindingsID, psaNewORBindings, NULL, NULL);
    }

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID, "ServerRegisterOXID hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerAllocOIDs, private
//
//  Synopsis:   allocate Object IDs from the local ping server
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::ServerAllocOIDs(OXID   &oxid,
                                      ULONG  *pcOidsToAllocate,
                                      OID    *parNewOidList,
                                      ULONG  cOidsToReturn,
                                      OID    *parOidsToReturn)
{
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    Win4Assert(IsConnected());
    HRESULT hr;

    do
    {
        hr = ::ServerAllocateOIDs(
                          _hRpc,            // Rpc binding handle
                          _ph,              // context handle
                          &oxid,            // OXID of server
                          cOidsToReturn,    // count of OIDs to return
                          parOidsToReturn,  // array of OIDs to return
                         *pcOidsToAllocate, // count of OIDs requested
                          parNewOidList,    // array of reserved oids
                          pcOidsToAllocate  // count actually allocated
                          );
    } while (RetryRPC(hr));

    // map Rpc status if necessary
    hr = CheckStatus(hr);

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerFreeOXIDAndOIDs, public
//
//  Synopsis:   frees an OXID and associated OIDs that were  pre-registered
//              with the local ping server
//
//  History:    20-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::ServerFreeOXIDAndOIDs(OXID &oxid, ULONG cOids, OID *pOids)
{
    ComDebOut((DEB_OXID, "CRpcResolver::ServerFreeOXID TID:%x\n", GetCurrentThreadId()));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    Win4Assert(IsConnected());

    // call the resolver.
    HRESULT hr;

    do
    {
        Win4Assert(_ph != NULL);

        hr = ::ServerFreeOXIDAndOIDs(
                            _hRpc,      // Rpc binding handle
                            _ph,        // context handle
                            oxid,       // OXID of server
                            cOids,      // count of OIDs to de-register
                            pOids);     // ptr to OIDs to de-register

    } while (RetryRPC(hr));

    // map Rpc status if necessary
    hr = CheckStatus(hr);

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID, "CRpcResolver::ServerFreeOXID hr:%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ClientResolveOXID, public
//
//  Synopsis:   Resolve client-side OXID and returns the oxidInfo
//              structure.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::ClientResolveOXID(REFOXID   roxid,
                                        OXID_INFO *poxidInfo,
                                        MID       *pmid,
                                        DUALSTRINGARRAY *psaResolver,
                                        USHORT    *pusAuthnSvc)
{
    ComDebOut((DEB_OXID,"ClientResolveOXID oxid:%08x %08x psa:%x\n",
               roxid, psaResolver));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    Win4Assert(IsConnected());

    RPC_STATUS sc = RPC_S_OK;

    do
    {
        Win4Assert(_ph != NULL);

        sc = ::ClientResolveOXID(
                        _hRpc,              // Rpc binding handle
                        _ph,
                        (OXID *)&roxid,     // OXID of server
                        psaResolver,        // resolver binging strings
                        IsSTAThread(),      // fApartment threaded
                        poxidInfo,          // resolver info returned
                        pmid,               // mid for the machine
                        pusAuthnSvc);       // exact authn svc used to talk to server

    } while (RetryRPC(sc));

    // map Rpc status if necessary
    sc = CheckStatus(sc);

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID,"ClientResolveOXID hr:%x poxidInfo:%x\n",
        sc, poxidInfo));
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::BulkUpdateOIDs
//
//  Synopsis:   registers/deregisters/pings any OIDs waiting to be
//              sent to the ping server.
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::BulkUpdateOIDs(ULONG          cOidsToAdd,
                                     OXID_OID_PAIR *pOidsToAdd,
                                     LONG          *pStatusOfAdds,
                                     ULONG          cOidsToRemove,
                                     OID_MID_PAIR  *pOidsToRemove,
                                     ULONG          cServerOidsToUnPin,
                                     OID           *aServerOidsToUnPin,
                                     ULONG          cOxidsToRemove,
                                     OXID_REF      *pOxidsToRemove)
{
    ASSERT_LOCK_NOT_HELD(_mxsResolver);

    // it is possible for the bulkupdate thread to call here after the
    // process has been uninitialized. Just return an error.
    RPC_STATUS sc = RPC_E_DISCONNECTED;

    if (IsConnected())
    {
        sc = RPC_S_OK;

        do
        {
            // call the Resolver.
            sc = ::BulkUpdateOIDs(_hRpc,          // Rpc binding handle
                              _ph,                // context handle
                              cOidsToAdd,         // #oids to add
                              pOidsToAdd,         // ptr to oids to add
                              pStatusOfAdds,      // status of adds
                              cOidsToRemove,      // #oids to remove
                              pOidsToRemove,      // ptr to oids to remove
                              0, 0,               // #, ptr to soids to free
                              cServerOidsToUnPin, // # soids to unpin
                              aServerOidsToUnPin, // ptr to soids to unpin
                              cOxidsToRemove,     // #oxids to remove
                              pOxidsToRemove);    // ptr to oxids to remove
        } while (RetryRPC(sc));
    }

    // map status if necessary
    sc = CheckStatus(sc);

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    return sc;
}

//+-------------------------------------------------------------------
//
//  Function:   FillLocalOXIDInfo
//
//  Synopsis:   Fills in a OXID_INFO structure for the current apartment.
//              Used by the Drag & Drop code to register with the resolver.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT FillLocalOXIDInfo(OBJREF &objref, OXID_INFO &oxidInfo)
{
    // extract the OXIDEntry from the objref
    OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
    Win4Assert(pOXIDEntry);

    // fill in the fields of the OXID_INFO structure.
    pOXIDEntry->FillOXID_INFO(&oxidInfo);
    oxidInfo.dwAuthnHint     = gAuthnLevel;

    HRESULT hr = GetStringBindings(&oxidInfo.psa);
    ComDebErr(hr != S_OK, "GetStringBindings Failed.\n");
    return (hr);
}

#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::AssertValid
//
//  Synopsis:   validates the state of this object
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CRpcResolver::AssertValid(void)
{
}
#endif // DBG


//+------------------------------------------------------------------------
//
//  Function:   MakeProxyHelper, public
//
//  Synopsis:   Creates a Proxy given bindings, a destination Process ID,
//              a destination MIDEntry, an AuthnLevel, and an IID.
//              Interface.
//
//  History:    14 Apr 95   AlexMit     Created  (as MakeSCMProxy)
//              24 Jun 96   SatishT     Generalized
//
//-------------------------------------------------------------------------
INTERNAL MakeProxyHelper(DUALSTRINGARRAY *psa, REFIID riid, DWORD dwAuthnHint,
                         DWORD ProcessID, void **ppProxy)
{
    ComDebOut((DEB_OXID, "MakeProxyHelper psa:%x ppProxy:%x\n", psa, ppProxy));

    Win4Assert(ProcessID != 0);

    // Init out parameter
    *ppProxy = NULL;

    // Make a fake oxidInfo for the SCM.
    OXID_INFO oxidInfo;
    oxidInfo.dwTid          = 0;
    oxidInfo.dwPid          = ProcessID;
    oxidInfo.version.MajorVersion = COM_MAJOR_VERSION;
    oxidInfo.version.MinorVersion = COM_MINOR_VERSION;
    oxidInfo.ipidRemUnknown = GUID_NULL;
    oxidInfo.dwFlags        = 0;
    oxidInfo.psa            = psa;
    oxidInfo.dwAuthnHint    = dwAuthnHint;

    // Make a fake OXID for the SCM. We can use any ID that the resolver
    // hands out as the OXID for the SCM.

    OXID oxid;
    HRESULT hr = gResolver.ServerGetReservedID(&oxid);

    if (SUCCEEDED(hr))
    {
        // make an entry in the OXID table for the SCM
        OXIDEntry *pOXIDEntry;
        hr = gOXIDTbl.MakeSCMEntry(oxid, &oxidInfo, &pOXIDEntry);

        if (SUCCEEDED(hr))
        {
            // Make an object reference for the SCM. The oid and ipid dont
            // matter, except the OID must be machine-unique.

            OBJREF objref;
            hr = MakeFakeObjRef(objref, pOXIDEntry, GUID_NULL, riid);
            if (SUCCEEDED(hr))
            {
                // now unmarshal the objref to create a proxy to the SCM.
                // use the internal form to reduce initialization time.
                hr = UnmarshalInternalObjRef(objref, ppProxy);
            }

            // release the reference to the OXIDEntry from AddEntry, since
            // UnmarshalInternalObjRef added another one if it was successful.
            pOXIDEntry->DecRefCnt();
        }
    }

    ComDebOut((DEB_OXID, "MakeProxyHelper hr:%x *ppProxy:%x\n", hr, *ppProxy));
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   MakeSCMProxy, public
//
//  Synopsis:   Creates an OXIDEntry and a proxy for the SCM Activation
//              Interface.
//
//  History:    14 Apr 95   AlexMit     Created
//              24 Jun 96   SatishT     Modified to use MakeProxyHelper
//
//-------------------------------------------------------------------------
INTERNAL MakeSCMProxy(DUALSTRINGARRAY *psaSCM, REFIID riid, void **ppSCM)
{
    ComDebOut((DEB_OXID, "MakeSCMProxy psaSCM:%x ppSCM:%x\n", psaSCM, ppSCM));

#if 0 // ifdef _CHICAGO_
    *ppSCM = (ISCMLocalActivator *) gpISCMActivator;
    return S_OK;

#else // _CHICAGO_
    Win4Assert(gdwScmProcessID != 0);

    if ( gdwScmProcessID == GetCurrentProcessId() )
    {
        *ppSCM = (ISCMLocalActivator *) gpISCMActivator;
        return S_OK;
    }



    // Call MakeProxyHelper to do the real work
    HRESULT hr = MakeProxyHelper(psaSCM,
                         riid,
                         RPC_C_AUTHN_LEVEL_CONNECT,
                         gdwScmProcessID,
                         ppSCM);


    if (SUCCEEDED(hr) && (
           (gImpLevel != RPC_C_IMP_LEVEL_IMPERSONATE) ||
           (gCapabilities & ANY_CLOAKING) ) )
    {
        // Make sure SCM can impersonate us. If the process is using either
        // static or dynamic cloaking, we want the SCM connection to use
        // dynamic cloaking since the user will expect us to do activation
        // using the current thread token in either case.

        hr = CoSetProxyBlanket( (IUnknown *) *ppSCM,
                               RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE, NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE,
                               NULL,
                               gCapabilities & ANY_CLOAKING ?
                                   EOAC_DYNAMIC_CLOAKING : EOAC_NONE );

        if (FAILED(hr))
        {
            ((IUnknown *) (*ppSCM))->Release();
            *ppSCM = NULL;
        }
    }

    ComDebOut((DEB_OXID, "MakeSCMProxy hr:%x *ppSCM:%x\n", hr, *ppSCM));
    return hr;
#endif // _CHICAGO_
}


#if 0 // ifdef _CHICAGO_
//+------------------------------------------------------------------------
//
//  Function:   MakeRPCSSProxy, public
//
//  Synopsis:   Creates a proxy for forwarding remote activation calls
//              to RPCSS for Chicago clients
//
//  History:    14 Apr 95   AlexMit     Created
//              24 Jun 96   SatishT     Modified to use MakeProxyHelper
//
//-------------------------------------------------------------------------
INTERNAL MakeRPCSSProxy(void **ppSCM)
{
    ComDebOut((DEB_OXID, "MakeRPCSSProxy"));
    Win4Assert(gdwScmProcessID != 0);

    // Call MakeProxyHelper to do the real work
    hr = MakeProxyHelper((DUALSTRINGARRAY *)&saSCM,
                         IID_IRemoteActivator,
                         RPC_C_AUTHN_LEVEL_NONE,
                         gdwScmProcessID,
                         ppSCM);


    ComDebOut((DEB_OXID, "MakeRPCSSProxy hr:%x *ppSCM:%x\n", hr, *ppSCM));
    return hr;
}
#endif // _CHICAGO_

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::BindToSCMProxy
//
//  Synopsis:   Get a proxy to the SCM Activation interface.
//
//  History:    19-May-95 Rickhi    Created
//
//  Notes:      The SCM activation interface is an ORPC interface so that
//              apartment model apps can receive callbacks and do cancels
//              while activating object servers.
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::BindToSCMProxy()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::BindToSCMProxy\n"));

    // since we are calling out on this thread, we have to ensure that the
    // call control is set up for this thread.

    HRESULT hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        // ensure we have connected to the resolver
        hr = GetConnection();
        if (SUCCEEDED(hr))
        {
            // single-thread access to this, don't use the _mxsResolver
            // lock since UnmarshalObjRef will assert that it is not
            // taken.
            COleStaticLock lck(g_mxsSingleThreadOle);

            if (_pSCMProxy == NULL)
            {
                // Make a proxy to the SCM
                hr = MakeSCMProxy((DUALSTRINGARRAY *)&saSCM, IID_ISCMLocalActivator, (void **) &_pSCMProxy);
            }
        }
    }

    ComDebOut((SUCCEEDED(hr) ? DEB_SCM : DEB_ERROR,
        "CRpcResolver::BindToSCMProxy for ISCMLocalActivator returns %x.\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateStarted
//
//  Synopsis:   Notify the SCM that a COM+ surrogate has been started
//
//  Arguments:  [pProcessActivatorToken] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    02-Apr-98 SatishT    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateStarted(
                        ProcessActivatorToken   *pProcessActivatorToken
                        )
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateStarted\n"));

    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    // Tell SCM that we are started
    error_status_t rpcstat;

    do
    {
        hr = ProcessActivatorStarted(
                _hRpc,
                _ph,
                pProcessActivatorToken,
                &rpcstat );

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateStarted returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateInitializing
//
//  Synopsis:   Notify the SCM that a class has been started
//
//  Arguments:  [rclsid] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    02-Apr-98 SatishT    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateInitializing()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateInitializing\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorInitializing(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateInitializing returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateReady
//
//  Synopsis:   Notify the SCM that a class has been started
//
//  Arguments:  [rclsid] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    02-Apr-98 SatishT    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateReady()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateReady\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorReady(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateReady returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateStopped
//
//  Synopsis:   Notify the SCM that a class has been started
//
//  Arguments:  [rclsid] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    02-Apr-98 SatishT    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateStopped()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateStopped\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorStopped(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateStopped returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogatePaused
//
//  Synopsis:   Notify the SCM that this surrogate process has been paused.
//
//  Arguments:  none
//
//  History:    09-Jan-00 JSimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogatePaused()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogatePaused\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorPaused(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogatePaused returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateResumed
//
//  Synopsis:   Notify the SCM that this surrogate process has been resumed.
//
//  Arguments:  none
//
//  History:    09-Jan-00 JSimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateResumed()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateResume\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorResumed(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateResume returned %x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateUserInitializing
//
//  Synopsis:   Notify the SCM that this surrogate process is entering
//              the initializing state.
//
//  History:    24-May-01 JohnDoty    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateUserInitializing()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateInitializing\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorUserInitializing(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateInitializing returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifyStarted
//
//  Synopsis:   Notify the SCM that a class has been started
//
//  Arguments:  [rclsid] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    19-May-92 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifyStarted(
    RegInput   *pRegIn,
    RegOutput **ppRegOut)
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifyStarted\n"));

    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    // Tell SCM that we are started
    error_status_t rpcstat;

    do
    {
        hr = ServerRegisterClsid(
                _hRpc,
                _ph,
                pRegIn,
                ppRegOut,
                &rpcstat );

    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "Class Registration returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    if (LogEventIsActive())
    {
        LogEventClassRegistration(hr, pRegIn, *ppRegOut);
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifyStopped
//
//  Synopsis:   Notify the SCM that the server is stopped.
//
//  History:    19-May-92 Ricksa    Created
//
//--------------------------------------------------------------------------
void CRpcResolver::NotifyStopped(
    REFCLSID rclsid,
    DWORD dwReg)
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifyStopped\n"));
    Win4Assert(IsConnected());

    error_status_t rpcstat;

    RevokeClasses revcls;
    revcls.dwSize = 1;
    revcls.revent[0].clsid = rclsid;
    revcls.revent[0].dwReg = dwReg;

    do
    {
        ServerRevokeClsid(
                        _hRpc,
                        _ph,
                        &revcls,
                        &rpcstat);

    } while (RetryRPC(rpcstat));

    if (LogEventIsActive())
    {
        LogEventClassRevokation(rclsid, dwReg);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetClassObject
//
//  Synopsis:   Send a get object request to the SCM
//
//  Arguments:  [rclsid] - class id for class object
//              [dwCtrl] - type of server required
//              [ppIFDClassObj] - marshaled buffer for class object
//              [ppwszDllToLoad] - DLL name to use for server
//
//  Returns:    S_OK
//
//  History:    20-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetClassObject(
    IActivationPropertiesIn   * pInActivationProperties,
    IActivationPropertiesOut **ppActOut
)
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::GetClassObject\n"));

    HRESULT                   hr;
    OXID                      OxidServer;
    DUALSTRINGARRAY         * pssaServerObjectResolverBindings;
    OXID_INFO                 OxidInfo;
    MID                       LocalMidOfRemote;
    OXIDEntry               * pOxidEntry;
    LPWSTR                    pwszWinstaDesktop;
    PRIV_SCM_INFO             PrivateScmInfo;

    IInstantiationInfo         * pInstantiationInfo = NULL;           // input
    ILegacyInfo                * pLegacyInfo = NULL;                  // input
    IActivationPropertiesOut   * pOutActivationProperties = NULL;     // output
    IScmRequestInfo            * pInScmResolverInfo = NULL;
    IScmReplyInfo              * pOutScmResolverInfo = NULL;
    PRIV_RESOLVER_INFO         * pPrivateResolverInfo = NULL;

    hr = BindToSCMProxy();
    if (FAILED(hr))
        return hr;
	
    hr = SetImpersonatingFlag(pInActivationProperties);
    if (FAILED(hr))
        return hr;

    memset(&PrivateScmInfo, 0, sizeof(PrivateScmInfo));

    PrivateScmInfo.Apartment = IsSTAThread();
    PrivateScmInfo.pwszWinstaDesktop = _pwszWinstaDesktop;
    PrivateScmInfo.ProcessSignature = _ProcessSignature;

    hr = pInActivationProperties->QueryInterface(
                                        IID_ILegacyInfo,
                                        (LPVOID*)&pLegacyInfo
                                        );
    if (hr != S_OK)
        return hr;

    COSERVERINFO *pServerInfo = NULL;
    pLegacyInfo->GetCOSERVERINFO(&pServerInfo);
    pLegacyInfo->Release();

    if ( ! GetEnvBlock( &PrivateScmInfo ) )
        return E_OUTOFMEMORY;

    hr = pInActivationProperties->QueryInterface(IID_IScmRequestInfo,
                                                 (LPVOID*)&pInScmResolverInfo);
    if (FAILED(hr))
        return hr;

    pInScmResolverInfo->SetScmInfo(&PrivateScmInfo);

    pInScmResolverInfo->Release();


    hr = GetSCM()->GetClassObject(
                        (IActivationPropertiesIn*)pInActivationProperties,
                        (IActivationPropertiesOut**)&pOutActivationProperties
                        );
    *ppActOut = pOutActivationProperties;

    if ( FAILED(hr) )
    {
        ComDebOut((DEB_ACTIVATE, "CRpcResolver::GetClassObject hr:%x\n", hr));
        return hr;
    }
    else
    {
        Win4Assert(pOutActivationProperties &&
            "CRpcResolver::GetClassObject Succeeded but returned NULL pOutActivationProperties");
    }

    hr = pOutActivationProperties->QueryInterface(IID_IScmReplyInfo,
                                                 (LPVOID*)&pOutScmResolverInfo);
    if (FAILED(hr))
        return hr;

    pOutScmResolverInfo->GetResolverInfo(&pPrivateResolverInfo);
    pOutScmResolverInfo->Release();

    if (pPrivateResolverInfo == NULL)
        return S_OK;

    if ( PrivateScmInfo.pEnvBlock )
        FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );

    // If no resolver info or OXID, then we must have a custom marshalled objref
    if ((!pPrivateResolverInfo) || (pPrivateResolverInfo->OxidServer == 0))
        return S_OK;

    {
        pOxidEntry = 0;
        hr = gOXIDTbl.FindOrCreateOXIDEntry(
            pPrivateResolverInfo->OxidServer,
            pPrivateResolverInfo->OxidInfo,
            FOCOXID_REF,
            pPrivateResolverInfo->pServerORBindings,
            pPrivateResolverInfo->LocalMidOfRemote,
            NULL,
            RPC_C_AUTHN_DEFAULT,
            &pOxidEntry );

        //
        // CODEWORK CODEWORK CODEWORK
        //
        // These comments also apply to CreateInstance and GetPersistentInstance
        // methods.
        //
        // Releasing the OXID and reacquiring it makes me a little
        // nervous. The Expired list is fairly short, so if multiple guys are doing
        // this simultaneously, the entries could get lost.  I guess this is not
        // too bad since it should be rare and the local resolver will have it
        // anyway, but I think there is a window where the local resolver could
        // lose it too, forcing a complete roundtrip back to the server.
        //
        // A better mechanism may be to pass the iid and ppunk into this method
        // and do the unmarshal inside it. We could improve performance by calling
        // UnmarshalObjRef instead of putting a stream wrapper around the
        // MInterfacePointer and then calling CoUnmarshalInterface. It would avoid
        // looking up the OXIDEntry twice, and would avoid the race where we could
        // lose the OXIDEntry off the expired list.  It would require a small
        // change in UnmarshalObjRef to deal with the custom marshal case.
        //

        //
        // Decrement our ref.  The interface unmarshall will do a LookupOXID
        // which will increment the count and move the OXIDEntry back to the
        // InUse list.
        //
        if (pOxidEntry)
            pOxidEntry->DecRefCnt();
    }

    ComDebOut((DEB_ACTIVATE, "CRpcResolver::GetClassObject hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::CreateInstance
//
//  Synopsis:   Legacy interface used by handlers
//
//  Arguments:
//
//  Returns:    S_OK
//
//  History:    20-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::CreateInstance(
    COSERVERINFO *pServerInfo,
    CLSID *pClsid,
    DWORD dwClsCtx,
    DWORD dwCount,
    IID *pIIDs,
    DWORD *pdwDllServerModel,
    WCHAR **ppwszDllServer,
    MInterfacePointer **pRetdItfs,
    HRESULT *pRetdHrs
)
{
    ActivationPropertiesIn actIn;
    IActivationPropertiesOut *pActOut=NULL;

    DWORD actvflags = CComActivator::GetActvFlags(dwClsCtx);
    
    actIn.SetNotDelete();
    HRESULT hr = GetActivationPropertiesIn(
                        &actIn,
                        *pClsid,
                        dwClsCtx,
                        pServerInfo,
                        dwCount,
                        pIIDs,
                        actvflags,
                        NULL,
                        NULL);

    if (SUCCEEDED(hr))
    {
        hr = CreateInstance(&actIn, &pActOut);
        actIn.Release();

        if (SUCCEEDED(hr))
        {
            IScmReplyInfo        * pOutScmResolverInfo;

            Win4Assert(pActOut != NULL);

            hr = pActOut->QueryInterface(IID_IScmReplyInfo,(LPVOID*)&pOutScmResolverInfo);
            if (FAILED(hr))
            {
                pActOut->Release();
                return hr;
            }

            PRIV_RESOLVER_INFO      * pPrivateResolverInfo;
            hr = pOutScmResolverInfo->GetResolverInfo(&pPrivateResolverInfo);
            Win4Assert(SUCCEEDED(hr));

            pOutScmResolverInfo->Release();

            if (pPrivateResolverInfo == NULL)
            {
                pActOut->Release();
                return E_UNEXPECTED;
            }

            *pdwDllServerModel = pPrivateResolverInfo->DllServerModel;
            *ppwszDllServer = pPrivateResolverInfo->pwszDllServer;

            IPrivActivationPropertiesOut *pPrivOut;
            hr = pActOut->QueryInterface(IID_IPrivActivationPropertiesOut,
                                                   (LPVOID*)&pPrivOut);
            if (FAILED(hr))
            {
                pActOut->Release();
                return hr;
            }

            DWORD count;
            IID *piids=0;
            hr = pPrivOut->GetMarshalledResults(&count, &piids, &pRetdHrs, &pRetdItfs);

            pPrivOut->Release();

            pActOut->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::CreateInstance
//
//  Synopsis:   Send a create instance request to the SCM
//
//  Arguments:
//
//  Returns:    S_OK
//
//  History:    20-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::CreateInstance(
    IActivationPropertiesIn   * pInActivationProperties,
    IActivationPropertiesOut **ppActOut
)
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::CreateInstance\n"));

    HRESULT hr = BindToSCMProxy();
    if (FAILED(hr))
        return hr;

    hr = SetImpersonatingFlag(pInActivationProperties);
    if (FAILED(hr))
        return hr;

    OXID_INFO           OxidInfo;
    OXIDEntry         * pOxidEntry;
    DUALSTRINGARRAY   * pssaServerObjectResolverBindings;
    PRIV_SCM_INFO       PrivateScmInfo;
    memset(&PrivateScmInfo, 0, sizeof(PRIV_SCM_INFO));

    IInstantiationInfo         * pInstantiationInfo = NULL;           // input
    ILegacyInfo                * pLegacyInfo = NULL;                  // input
    IActivationPropertiesOut   * pOutActivationProperties = NULL;     // output
    IScmRequestInfo            * pInScmResolverInfo = NULL;
    IScmReplyInfo              * pOutScmResolverInfo = NULL;
    PRIV_RESOLVER_INFO         * pPrivateResolverInfo = NULL;

    PrivateScmInfo.Apartment = IsSTAThread();
    PrivateScmInfo.pwszWinstaDesktop = _pwszWinstaDesktop;
    PrivateScmInfo.ProcessSignature = _ProcessSignature;

    hr = pInActivationProperties->QueryInterface(
                                        IID_ILegacyInfo,
                                        (LPVOID*)&pLegacyInfo
                                        );
    if (FAILED(hr))
        return hr;

    COSERVERINFO *pServerInfo = NULL;

    pLegacyInfo->GetCOSERVERINFO(&pServerInfo);
    pLegacyInfo->Release();

    if ( ! GetEnvBlock( &PrivateScmInfo ) )
        return E_OUTOFMEMORY;

    hr = pInActivationProperties->QueryInterface(IID_IScmRequestInfo,
                                                 (LPVOID*)&pInScmResolverInfo);
    if (FAILED(hr))
        return hr;

    pInScmResolverInfo->SetScmInfo(&PrivateScmInfo);
    pInScmResolverInfo->Release();


    pssaServerObjectResolverBindings = 0;
    OxidInfo.psa = 0;
    pOxidEntry = 0;

    hr = GetSCM()->CreateInstance(
            NULL,
            (IActivationPropertiesIn*)pInActivationProperties,
            (IActivationPropertiesOut**)&pOutActivationProperties
        );

    *ppActOut = pOutActivationProperties;

    if ( FAILED(hr) )
    {
        ComDebOut((DEB_ACTIVATE, "CRpcResolver::CreateInstance hr:%x\n", hr));
        return hr;
    }
    else
    {
        Win4Assert(pOutActivationProperties &&
            "CRpcResolver::CreateInstance Succeeded but returned NULL pOutActivationProperties");
    }

    if (pOutActivationProperties)
    {
        hr = pOutActivationProperties->QueryInterface(IID_IScmReplyInfo,
                                                 (LPVOID*)&pOutScmResolverInfo);
        if (FAILED(hr))
            return hr;

        pOutScmResolverInfo->GetResolverInfo(&pPrivateResolverInfo);
        pOutScmResolverInfo->Release();

        if (pPrivateResolverInfo==NULL)
            return E_UNEXPECTED;

        if ( PrivateScmInfo.pEnvBlock )
            FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );

        // If no resolver info, then we must have a custom marshalled objref
        if (pPrivateResolverInfo->OxidServer == 0)
            return S_OK;

        hr = gOXIDTbl.FindOrCreateOXIDEntry(
            pPrivateResolverInfo->OxidServer,
            pPrivateResolverInfo->OxidInfo,
            FOCOXID_REF,
            pPrivateResolverInfo->pServerORBindings,
            pPrivateResolverInfo->LocalMidOfRemote,
            NULL,
            RPC_C_AUTHN_DEFAULT,
            &pOxidEntry );

        CoTaskMemFree(OxidInfo.psa);
        CoTaskMemFree(pssaServerObjectResolverBindings);

        //
        // Decrement our ref.  The interface unmarshall will do a LookupOXID
        // which will increment the count and move the OXIDEntry back to the
        // InUse list.
        //

        if (pOxidEntry)
            pOxidEntry->DecRefCnt();
    }

    ComDebOut((DEB_ACTIVATE, "CRpcResolver::CreateInstance hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetPersistentInstance
//
//  Synopsis:   Send a get object request to the SCM
//
//GAJGAJ - fix this comment block
//  Arguments:  [rclsid] - class id for class object
//              [dwCtrl] - type of server required
//              [ppIFDClassObj] - marshaled buffer for class object
//              [ppwszDllToLoad] - DLL name to use for server
//
//  Returns:    S_OK
//
//  History:    20-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetPersistentInstance(
    IActivationPropertiesIn   * pInActivationProperties,
    IActivationPropertiesOut **ppActOut,
    BOOL *pFoundInROT)
{
    HRESULT hr = CreateInstance(pInActivationProperties,
                                ppActOut);
    IActivationPropertiesOut   * pOutActivationProperties = *ppActOut;
    if (pOutActivationProperties)
    {
        IScmReplyInfo        * pOutScmResolverInfo;
        PRIV_RESOLVER_INFO      * pPrivateResolverInfo;
        hr = pOutActivationProperties->QueryInterface(IID_IScmReplyInfo,
                                            (LPVOID*)&pOutScmResolverInfo);
        if (SUCCEEDED(hr))
        {
            hr = pOutScmResolverInfo->GetResolverInfo(&pPrivateResolverInfo);
            Win4Assert(SUCCEEDED(hr) && (pPrivateResolverInfo != NULL));

            *pFoundInROT = pPrivateResolverInfo->FoundInROT;
            pOutScmResolverInfo->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotRegister
//
//  Synopsis:   Register an object in the ROT
//
//  Arguments:  [pmkeqbuf] - moniker compare buffer
//              [pifdObject] - marshaled interface for object
//              [pifdObjectName] - marshaled moniker
//              [pfiletime] - file time of last change
//              [dwProcessID] -
//              [psrkRegister] - output of registration
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotRegister(
    MNKEQBUF *pmkeqbuf,
    InterfaceData *pifdObject,
    InterfaceData *pifdObjectName,
    FILETIME *pfiletime,
    DWORD dwProcessID,
    WCHAR *pwszServerExe,
    SCMREGKEY *psrkRegister)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotRegister(
            _hRpc,
            _ph,
            _pwszWinstaDesktop,
            pmkeqbuf,
            pifdObject,
            pifdObjectName,
            pfiletime,
            dwProcessID,
            pwszServerExe,
            psrkRegister,
            &rpcstat);
    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotRevoke
//
//  Synopsis:   Call to SCM to revoke object from the ROT
//
//  Arguments:  [psrkRegister] - moniker compare buffer
//              [fServerRevoke] - whether server for object is revoking
//              [pifdObject] - where to put marshaled object
//              [pifdName] - where to put marshaled moniker
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotRevoke(
    SCMREGKEY *psrkRegister,
    BOOL fServerRevoke,
    InterfaceData **ppifdObject,
    InterfaceData **ppifdName)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotRevoke(
            _hRpc,
            psrkRegister,
            fServerRevoke,
            ppifdObject,
            ppifdName,
            &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotIsRunning
//
//  Synopsis:   Call to SCM to determine if object is in the ROT
//
//  Arguments:  [pmkeqbuf] - moniker compare buffer
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotIsRunning(MNKEQBUF *pmkeqbuf)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotIsRunning(
                _hRpc,
                _ph,
                _pwszWinstaDesktop,
                pmkeqbuf,
                &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotGetObject
//
//  Synopsis:   Call to SCM to determine if object is in the ROT
//
//  Arguments:  [dwProcessID] - process ID for object we want
//              [pmkeqbuf] - moniker compare buffer
//              [psrkRegister] - registration ID in SCM
//              [pifdObject] - marshaled interface for the object
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotGetObject(
    DWORD dwProcessID,
    MNKEQBUF *pmkeqbuf,
    SCMREGKEY *psrkRegister,
    InterfaceData **pifdObject)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotGetObject(
                _hRpc,
                _ph,
                _pwszWinstaDesktop,
                dwProcessID,
                pmkeqbuf,
                psrkRegister,
                pifdObject,
                &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotNoteChangeTime
//
//  Synopsis:   Call to SCM to set time of change for object in the ROT
//
//  Arguments:  [psrkRegister] - SCM registration ID
//              [pfiletime] - time of change
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotNoteChangeTime(
    SCMREGKEY *psrkRegister,
    FILETIME *pfiletime)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotNoteChangeTime(
            _hRpc,
            psrkRegister,
            pfiletime,
            &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotGetTimeOfLastChange
//
//  Synopsis:   Call to SCM to get time changed of object in the ROT
//
//  Arguments:  [pmkeqbuf] - moniker compare buffer
//              [pfiletime] - where to put time of last change
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotGetTimeOfLastChange(
    MNKEQBUF *pmkeqbuf,
    FILETIME *pfiletime)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotGetTimeOfLastChange(
                _hRpc,
                _ph,
                _pwszWinstaDesktop,
                pmkeqbuf,
                pfiletime,
                &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotEnumRunning
//
//  Synopsis:   Call to SCM to enumerate running objects in the ROT
//
//  Arguments:  [ppMkIFList] - output pointer to array of marshaled monikers
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotEnumRunning(MkInterfaceList **ppMkIFList)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotEnumRunning(
                _hRpc,
                _ph,
                _pwszWinstaDesktop,
                ppMkIFList,
                &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetThreadID
//
//  Synopsis:   Get unique thread id from SCM.
//
//  Arguments:  [pThreadID] - Pointer to returned thread ID.
//
//  History:    22-Jan-96   Rickhi      Created
//--------------------------------------------------------------------------
void CRpcResolver::GetThreadID( DWORD * pThreadID )
{
    HRESULT hr;

    *pThreadID = 0;

    hr = GetConnection();
    if ( FAILED(hr) )
        return;

    //
    // If GetConnection does the initial connect to the SCM/OR then
    // our apartment thread id, which is aliased by pThreadID, will be set.
    //
    if ( *pThreadID != 0 )
        return;

    error_status_t rpcstat;

    do
    {
        ::GetThreadID( _hRpc, pThreadID, &rpcstat );
    } while (RetryRPC(rpcstat));
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::UpdateActivationSettings
//
//  Synopsis:   Tells rpcss to re-read default activation keys/values.
//              Used by OLE test team.
//
//  Arguments:  none
//
//--------------------------------------------------------------------------
void CRpcResolver::UpdateActivationSettings()
{
    HRESULT hr;

    hr = GetConnection();
    if ( FAILED(hr) )
        return;

    error_status_t rpcstat;

    do
    {
        ::UpdateActivationSettings( _hRpc, &rpcstat );
    } while (RetryRPC(rpcstat));
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::RegisterWindowPropInterface
//
//  Synopsis:   Register window property interface with the SCM
//
//  Arguments:
//
//  History:    22-Jan-96   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::RegisterWindowPropInterface(
    HWND       hWnd,
    STDOBJREF *pStd,
    OXID_INFO *pOxidInfo,
    DWORD_PTR *pdwCookie)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::RegisterWindowPropInterface(_hRpc, (DWORD_PTR)hWnd,
                                           pStd, pOxidInfo, pdwCookie, &rpcstat);
    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "RegisterWindowPropInterface returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::RegisterWindowPropInterface
//
//  Synopsis:   Get (and possibly Revoke) window property interface
//              registration with the SCM.
//
//  Arguments:
//
//  History:    22-Jan-96   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetWindowPropInterface(
    HWND       hWnd,
    DWORD_PTR  dwCookie,
    BOOL       fRevoke,
    STDOBJREF *pStd,
    OXID_INFO *pOxidInfo)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::GetWindowPropInterface(_hRpc, (DWORD_PTR)hWnd, dwCookie, fRevoke,
                                      pStd, pOxidInfo, &rpcstat);
    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "GetWindowPropInterface returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::EnableDisableDynamicIPTracking
//
//  Purpose:    Tells the SCM to start or stop dynamic address change tracking.
//
//  Returns:    hresult
//
//  History:    07-Oct-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::EnableDisableDynamicIPTracking(BOOL fEnable)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::EnableDisableDynamicIPTracking(_hRpc, _ph, fEnable, &rpcstat);
    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "EnableDisableDynamicIPTracking returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetCurrentAddrExclusionList
//
//  Purpose:    Retrieves the contents of the current IP exclusion list
//
//  Returns:    hresult
//
//  History:    09-Oct-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetCurrentAddrExclusionList(
        DWORD* pdwNumStrings,
        LPWSTR** ppszStrings)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::GetCurrentAddrExclusionList(_hRpc, _ph, pdwNumStrings, ppszStrings, &rpcstat);

    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "GetCurrentAddrExclusionList returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::SetAddrExclusionList
//
//  Purpose:    Sets the contents of the current IP exclusion list
//
//  Returns:    hresult
//
//  History:    09-Oct-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::SetAddrExclusionList(
        DWORD dwNumStrings,
        LPWSTR* pszStrings)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::SetAddrExclusionList(_hRpc, _ph, dwNumStrings, pszStrings, &rpcstat);
    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "SetAddrExclusionList returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::FlushSCMBindings
//
//  Purpose:    Tells the SCM to flush its binding handle cache for the 
//              specified server.
//
//  Returns:    hresult
//
//  History:    21-May-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::FlushSCMBindings(WCHAR* pszMachineName)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::FlushSCMBindings(_hRpc, _ph, pszMachineName, &rpcstat);

    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "FlushSCMBindings returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::RetireServer
//
//  Purpose:    Tells the SCM that this process is to be no longer used for
//              any activations whatsoever.
//
//  Returns:    hresult
//
//  History:    21-May-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::RetireServer(GUID* pguidProcessIdentifier)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::RetireServer(_hRpc, _ph, pguidProcessIdentifier, &rpcstat);

    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "RetireServer returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetThreadWinstaDesktop
//
//  Purpose:    Get the string representing the winsta\desktop for this
//              thread.
//
//  Returns:    String with winsta\desktop name.
//
//  History:    11-Nov-93 Ricksa    Created
//                 Apr-96 DKays     Return winsta\desktop pair
//
//--------------------------------------------------------------------------
DWORD CRpcResolver::GetThreadWinstaDesktop()
{
#ifdef _CHICAGO_
    _pwszWinstaDesktop = NULL;
    return S_OK;
#else // _CHICAGO_
    HWINSTA hWinsta;
    HDESK   hDesk;
    WCHAR   wszWinsta[32];
    WCHAR   wszDesktop[32];
    LPWSTR  pwszWinsta;
    LPWSTR  pwszDesktop;
    DWORD   WinstaSize;
    DWORD   DesktopSize;
    DWORD   Length;
    BOOL    Status;
    DWORD   Result;

    hWinsta = GetProcessWindowStation();

    if ( ! hWinsta )
        return GetLastError();

    hDesk = GetThreadDesktop(GetCurrentThreadId());

    if ( ! hDesk )
        return GetLastError();

    pwszWinsta = wszWinsta;
    pwszDesktop = wszDesktop;

    Length = sizeof(wszWinsta);

    Status = GetUserObjectInformation(
                hWinsta,
                UOI_NAME,
                pwszWinsta,
                Length,
                &Length );

    if ( ! Status )
    {
        Result = GetLastError();
        if ( Result != ERROR_INSUFFICIENT_BUFFER )
            goto WinstaDesktopExit;

        pwszWinsta = (LPWSTR)PrivMemAlloc( Length );
        if ( ! pwszWinsta )
        {
            Result = ERROR_OUTOFMEMORY;
            goto WinstaDesktopExit;
        }

        Status = GetUserObjectInformation(
                    hWinsta,
                    UOI_NAME,
                    pwszWinsta,
                    Length,
                    &Length );

        if ( ! Status )
        {
            Result = GetLastError();
            goto WinstaDesktopExit;
        }
    }

    Length = sizeof(wszDesktop);

    Status = GetUserObjectInformation(
                hDesk,
                UOI_NAME,
                pwszDesktop,
                Length,
                &Length );

    if ( ! Status )
    {
        Result = GetLastError();
        if ( Result != ERROR_INSUFFICIENT_BUFFER )
            goto WinstaDesktopExit;

        pwszDesktop = (LPWSTR)PrivMemAlloc( Length );
        if ( ! pwszDesktop )
        {
            Result = ERROR_OUTOFMEMORY;
            goto WinstaDesktopExit;
        }

        Status = GetUserObjectInformation(
                    hDesk,
                    UOI_NAME,
                    pwszDesktop,
                    Length,
                    &Length );

        if ( ! Status )
        {
            Result = GetLastError();
            goto WinstaDesktopExit;
        }
    }

    _pwszWinstaDesktop = (WCHAR *)
    PrivMemAlloc( (lstrlenW(pwszWinsta) + 1 + lstrlenW(pwszDesktop) + 1) * sizeof(WCHAR) );

    if ( _pwszWinstaDesktop )
    {
        lstrcpyW( _pwszWinstaDesktop, pwszWinsta );
        lstrcatW( _pwszWinstaDesktop, L"\\" );
        lstrcatW( _pwszWinstaDesktop, pwszDesktop );
        Result = S_OK;
    }
    else
    {
        Result = ERROR_OUTOFMEMORY;
    }

WinstaDesktopExit:

    if ( pwszWinsta != wszWinsta )
        PrivMemFree( pwszWinsta );

    if ( pwszDesktop != wszDesktop )
        PrivMemFree( pwszDesktop );

    // There have been some stress failures where _pwszWinstaDesktop
    // was NULL and result was zero.  Handle that case for now, but try
    // to catch it after NT 5 ships.
    Win4Assert( Result != 0 || _pwszWinstaDesktop != NULL );
    if (Result == 0 && _pwszWinstaDesktop == NULL)
        Result = ERROR_OUTOFMEMORY;
    return Result;
#endif // _CHICAGO_
}


// 
// The SCM needs to know if this client thread was impersonating or not.   We 
// store that information here in the outgoing activation blob.
// 
HRESULT CRpcResolver::SetImpersonatingFlag(IActivationPropertiesIn* pIActPropsIn)
{
    HRESULT hr;
    BOOL bResult;
    ISpecialSystemProperties* pISSP = NULL;
    HANDLE hToken = NULL;
    
    bResult = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if (!bResult)
    {
        DWORD dwGLE = GetLastError();
        
        // Okay if it failed due to no token on the thread;  blob data is FALSE
        // by default so no need to set it explicitly to that.
        hr = (dwGLE == ERROR_NO_TOKEN) ?  S_OK : HRESULT_FROM_WIN32(dwGLE);
    }
    else
    {
        // Thread is impersonating
        CloseHandle(hToken);

        hr = pIActPropsIn->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISSP);
        if (SUCCEEDED(hr))
        {
            hr = pISSP->SetClientImpersonating(TRUE);
            pISSP->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetLocalResolverBindings
//
//  Purpose:    Gets a refcounted ptr to the current set of bindings for the
//              local resolver.
//
//  Returns:    S_OK -- bindings were returned
//              E_UNEXPECTED -- no bindings were present
//
//  History:    10-Oct-00 JSimmons    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetLocalResolverBindings(CDualStringArray** ppdsaLocalResolver)
{
    LOCK(_mxsResolver);

    Win4Assert(ppdsaLocalResolver);
    Win4Assert(_pdsaLocalResolver);  // until we find a case where this shouldn't happen
    
    if (!_pdsaLocalResolver)
    {
        UNLOCK(_mxsResolver);  
        return E_UNEXPECTED;
    }

    *ppdsaLocalResolver = _pdsaLocalResolver;
    _pdsaLocalResolver->AddRef();

    UNLOCK(_mxsResolver);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::SetLocalResolverBindings
//
//  Purpose:    Replaces the currently cached local resolver bindings with 
//              the one passed in.  If NULL is passed, the current bindings
//              are released.
//
//  Returns:    S_OK
//
//  History:    10-Oct-00 JSimmons    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::SetLocalResolverBindings(DWORD64 dwBindingsID, CDualStringArray* pdsaLocalResolver)
{
    LOCK(_mxsResolver);  // may be a reentrancy of the lock

    if (pdsaLocalResolver && (dwBindingsID < _dwCurrentBindingsID))
    {
        // The specified bindings are older than the ones we
        // already have.  Just reject them.
        UNLOCK(_mxsResolver);  
        return E_FAIL;
    }

    if (_pdsaLocalResolver)
    {
        _pdsaLocalResolver->Release();
        _pdsaLocalResolver = NULL;
        _dwCurrentBindingsID = 0;
    }
    if (pdsaLocalResolver)
    {
        _pdsaLocalResolver = pdsaLocalResolver;
        _pdsaLocalResolver->AddRef();
        _dwCurrentBindingsID = dwBindingsID;
    }    

    UNLOCK(_mxsResolver);  

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::RunningInWinlogon
//
//  Purpose:    Detect if we are running within winlogon.
//
//  Returns:    TRUE  -- we are running within winlogon.exe
//              FALSE -- we are not running within winlogon.exe
//
//  History:    17-May-01 JSimmons    Created
//
//--------------------------------------------------------------------------
BOOL CRpcResolver::RunningInWinlogon()
{
    const WCHAR  wszWINLOGON[] = L"\\system32\\winlogon.exe";
    const size_t cchWINLOGON   = (sizeof(wszWINLOGON) / sizeof(WCHAR)); 

    // GetSystemWindowsDirectory returns enough space for the NULL.
    size_t cchBufferSize = (GetSystemWindowsDirectory(NULL, 0) - 1)
                           + cchWINLOGON;

    WCHAR *wszFullPath = (WCHAR *)alloca(cchBufferSize * sizeof(WCHAR));
    
    if (GetSystemWindowsDirectory(wszFullPath, cchBufferSize))
    {
        lstrcat(wszFullPath, wszWINLOGON);

        return (GetModuleHandle(wszFullPath)) ? TRUE : FALSE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     GetEnvBlock
//
//  Purpose:    Attempts to get the environment block for clients running
//              in the interactive windowstation.
//
//  Returns:    Nothing.
//
//  History:    Feb-97 DKays     Created
//
//--------------------------------------------------------------------------
BOOL GetEnvBlock( PRIV_SCM_INFO * pScmInfo )
{
    WCHAR * pwszWinsta;
    WCHAR * pwszWinsta0;
    WCHAR * pwszString;
    DWORD   StringLength;

    pScmInfo->pEnvBlock = 0;
    pScmInfo->EnvBlockLength = 0;

    //
    // First see if this user is running in the interactive windowstation.
    // The winsta desktop field is always in the form "winsta\desktop".
    //
    pwszWinsta = pScmInfo->pwszWinstaDesktop;
    pwszWinsta0 = L"WinSta0";

    for ( ; *pwszWinsta == *pwszWinsta0; pwszWinsta++, pwszWinsta0++ )
        ;

    if ( *pwszWinsta != L'\\' || *pwszWinsta0 != L'\0' )
        return TRUE;

    pScmInfo->pEnvBlock = GetEnvironmentStringsW();

    if ( ! pScmInfo->pEnvBlock )
        return FALSE;

    pwszString = pScmInfo->pEnvBlock;

    for ( ; *pwszString; )
    {
        StringLength = lstrlenW(pwszString);
        pwszString += StringLength + 1;
        pScmInfo->EnvBlockLength += StringLength + 1;
    }

    pScmInfo->EnvBlockLength++;

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     ScmGetThreadId
//
//  Purpose:    helper method so gResolver is not used in
//              com\class subdir.
//
//--------------------------------------------------------------------------
void ScmGetThreadId( DWORD * pThreadID )
{
    gResolver.GetThreadID( pThreadID );
}
//+---------------------------------------------------------------------
//
//  Function:   UpdateDCOMSettings
//
//  Synopsis:   Calls rpcss to re-read the default activation keys/values.
//
//----------------------------------------------------------------------
STDAPI_(void) UpdateDCOMSettings(void)
{
    gResolver.UpdateActivationSettings();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\remoteu.cxx ===
//+-------------------------------------------------------------------
//
//  File:       remoteu.cxx
//
//  Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.
//
//  Contents:   Remote Unknown object implementation
//
//  Classes:    CRemoteUnknown
//
//  History:    23-Feb-95   AlexMit     Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <remoteu.hxx>      // CRemoteUnknown
#include <ipidtbl.hxx>      // COXIDTable, CIPIDTable
#include <stdid.hxx>        // CStdIdentity
#include <ctxchnl.hxx>      // CCtxComChnl
#include <crossctx.hxx>     // SwitchForCallback
#include <resolver.hxx>     // giPingPeriod
#include <security.hxx>     // FromLocalSystem
#include <xmit.hxx>         // CXmitRpcStream


// If you make a cross thread call and the server asks who the client
// is, we return the contents of gLocalName.
const WCHAR *gLocalName = L"\\\\\\Thread to thread";


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::CRemoteUnknown, public
//
//  Synopsis:   ctor for the CRemoteUnknown
//
//  History:    22-Feb-95   Rickhi      Created
//              12-Feb-98   Johnstra    Made NTA aware
//
//--------------------------------------------------------------------
CRemoteUnknown::CRemoteUnknown(HRESULT &hr, IPID *pipid) :
    _pStdId(NULL)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Marshal the remote unknown and rundown, no pinging needed. Note
    // that we just marshal the IRundown interfaces since it inherits
    // from IRemUnknown.  This lets us use the same IPID for both
    // interfaces. Also, we use the Internal version of MarshalObjRef in
    // order to prevent registering the OID in the OIDTable. This allows
    // us to receive Release calls during IDTableThreadUninitialize since
    // we wont get cleaned up in the middle of that function. It also allows
    // us to lazily create the OIDTable.

    OBJREF objref;
    hr = MarshalInternalObjRef(objref, IID_IRundown, this, MSHLFLAGS_NOPING,
                               (void **)&_pStdId);
    if (SUCCEEDED(hr))
    {
        // return the IPID to the caller, and release any allocated resources
        // since all we wanted was the infrastructure, not the objref itself.

        *pipid = ORSTD(objref).std.ipid;
        FreeObjRef(objref);
    }

    ComDebOut((DEB_MARSHAL,
        "CRemoteUnk::CRemoteUnk this:%x pStdId:%x hr:%x\n", this, _pStdId, hr));
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::~CRemoteUnknown, public
//
//  Synopsis:   dtor for the CRemoteUnknown
//
//  History:    22-Feb-95   Rickhi      Created
//
//--------------------------------------------------------------------
CRemoteUnknown::~CRemoteUnknown()
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (_pStdId)
    {
        // Release stub manager
        ((CStdMarshal *) _pStdId)->Disconnect(DISCTYPE_SYSTEM);
        _pStdId->Release();
    }

    ComDebOut((DEB_MARSHAL, "CRemoteUnk::~CRemoteUnk this:%x\n", this));
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::QueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:    22-Feb-95   AlexMit     Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IRundown)    ||  // more common than IUnknown
        IsEqualIID(riid, IID_IRemUnknown) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IRundown *) this;
        // no need to AddRef since we dont refcount this object
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::AddRef, public
//
//  Synopsis:   increment reference count
//
//  History:    23-Feb-95   AlexMit     Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRemoteUnknown::AddRef(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::Release, public
//
//  Synopsis:   decrement reference count
//
//  History:    23-Feb-95   AlexMit     Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRemoteUnknown::Release(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Function:   GetIPIDEntry, private
//
//  Synopsis:   find the IPIDEntry given an IPID
//
//  History:    23-Feb-95   Rickhi      Created
//
//--------------------------------------------------------------------
IPIDEntry *GetIPIDEntry(REFIPID ripid)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    IPIDEntry *pEntry= gIPIDTbl.LookupIPID(ripid);

    if (pEntry && !(pEntry->dwFlags & IPIDF_DISCONNECTED))
    {
        return pEntry;
    }

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   GetStdIdFromIPID, private
//
//  Synopsis:   find the stdid from the ipid
//
//  History:    23-Feb-95   Rickhi      Created
//
//--------------------------------------------------------------------
CStdIdentity *GetStdIdFromIPID(REFIPID ripid)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    IPIDEntry *pEntry = GetIPIDEntry(ripid);

    if (pEntry)
    {
        CStdIdentity *pStdId = pEntry->pChnl->GetStdId();
        if (pStdId)
        {
            // keep it alive for the duration of the call
            pStdId->AddRef();
        }
        return pStdId;
    }

    return NULL;
}


//+-------------------------------------------------------------------
//
//  Function:   CrossAptQIFn            Internal
//
//  Synopsis:   This routine delegates CRemUnknown to do the actual QI
//              on the server object and building of IPIDEntries
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagXAptQIData
{
    const IPID     *pIPID;
    ULONG           cRefs;
    USHORT          cIids;
    IID            *iids;
    REMQIRESULT   **ppQIResults;
    CRemoteUnknown *pRemUnk;
} XAptQIData;

HRESULT __stdcall CrossAptQIFn(void *pv)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptQIFn\n"));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    XAptQIData *pXAptQIData = (XAptQIData *) pv;

    // Delegate to CRemoteUnknown
    hr = pXAptQIData->pRemUnk->RemQueryInterface(*pXAptQIData->pIPID,
                                                 pXAptQIData->cRefs,
                                                 pXAptQIData->cIids,
                                                 pXAptQIData->iids,
                                                 pXAptQIData->ppQIResults);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptQIFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemQueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:    22-Feb-95   AlexMit     Created
//              20-Jan-98   GopalK      Context related changes
//              05-Jul-99   a-sergiv    Move security check here
//
//  Notes:      Remote calls to QueryInterface for this OXID arrive here.
//              This routine looks up the object and calls MarshalIPID on
//              it for each interface requested.
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemQueryInterface(REFIPID ripid, ULONG cRefs,
                       USHORT cIids, IID *iids, REMQIRESULT **ppQIResults)
{
    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RemQueryInterface this:%x ipid:%I cRefs:%x cIids:%x iids:%x ppQIResults:%x\n",
        this, &ripid, cRefs, cIids, iids, ppQIResults));

    // init the out parameters
    *ppQIResults = NULL;

    // validate the input parameters
    if (cIids == 0)
    {
        return E_INVALIDARG;
    }

    // Perform access check. It is best to perform it no
    // matter what. This is cheaper than doing PreventDisconnect
    // and fiddling with gIPIDLock farther down in this function.
    BOOL bAccessDenied = (CheckAccess(NULL, NULL) != S_OK);

    // Remember whether the IPID is for a strong or a weak reference,
    // then clear the strong/weak bit so that GetIPIDEntry will find
    // the IPID. It is safe to mask off this bit because we are the
    // server for this IPID and we know it's format.

    DWORD mshlflags = MSHLFLAGS_NORMAL;
    DWORD sorfflags = SORF_NULL;

    if (ripid.Data1 & IPIDFLAG_WEAKREF)
    {
        mshlflags = MSHLFLAGS_WEAK;
        sorfflags = SORF_P_WEAKREF;
        ((IPID &)(ripid)).Data1 &= ~IPIDFLAG_WEAKREF;   // overcome the const
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    CStdIdentity *pStdId = GetStdIdFromIPID(ripid);
    if (pStdId == NULL)
    {
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        return RPC_E_INVALID_OBJECT;
    }

    // Get server context
    HRESULT hr;
    CPolicySet *pPS = pStdId->GetServerPolicySet();
    CObjectContext *pCurrentCtx = GetCurrentContext();
    CObjectContext *pServerCtx = pPS ? pPS->GetServerContext() : pCurrentCtx;

    if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
    {
        pStdId->Release();
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        return E_ACCESSDENIED;
    }

    // Compare contexts
    if (pServerCtx == pCurrentCtx)
    {
        // allocate space for the return parameters
        REMQIRESULT *pQIRes = (REMQIRESULT *)CoTaskMemAlloc(cIids *
                                                            sizeof(REMQIRESULT));
        // allocate space on the stack to hold the IPIDEntries
        // for each interface
        IPIDEntry **parIPIDs = (IPIDEntry **)alloca(cIids * sizeof(IPIDEntry *));

        if (pQIRes == NULL)
        {
            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            pStdId->Release();
            return E_OUTOFMEMORY;
        }

        hr = pStdId->PreventDisconnect();
        if (SUCCEEDED(hr))
        {
            *ppQIResults = pQIRes;

            // while holding the lock, marshal each interface that was requested
            for (USHORT i=0; i < cIids; i++, pQIRes++)
            {
                pQIRes->hResult = pStdId->MarshalIPID(iids[i], cRefs, mshlflags,
                                                      &parIPIDs[i], 0);
            }

            // we are done with the lock, the IPIDEntries will remain valid
            // as long as Disconnect has been prevented.
            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            USHORT cFails = 0;
            if (SUCCEEDED(hr))
            {
                // create a STDOBJREF for each interface from the info in the
                // IPIDEntries.
                pQIRes = *ppQIResults;  // reset the pointer

                for (USHORT i=0; i < cIids; i++, pQIRes++)
                {
                    if (SUCCEEDED(pQIRes->hResult))
                    {
                        // marshal for this interface succeeded, fill the STDOJBREF
                        pStdId->FillSTD(&pQIRes->std, cRefs, mshlflags, parIPIDs[i]);
                        pQIRes->std.flags |= sorfflags;
                    }
                    else
                    {
                        // marshaled failed. on failure, the STDOBJREF must be NULL
                        memset(&pQIRes->std, 0, sizeof(pQIRes->std));
                        cFails++;
                    }
                }
            }
            else
            {
                // free the memory since the call failed.
                CoTaskMemFree(pQIRes);
                pQIRes = NULL;
                Win4Assert(*ppQIResults == NULL);
            }

            if (cFails > 0)
            {
                hr = (cFails == cIids) ? E_NOINTERFACE : S_FALSE;
            }
        }
        else
        {
            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);
        }

        // handle any disconnects that came in while we were marshaling
        // the requested interfaces.
        hr = pStdId->HandlePendingDisconnect(hr);
        pStdId->Release();
    }
    else
    {
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        pStdId->Release();

        XAptQIData xAptQIData;

        // Switch to server context for the QI
        xAptQIData.pIPID = &ripid;
        xAptQIData.cRefs = cRefs;
        xAptQIData.cIids = cIids;
        xAptQIData.iids  = iids;
        xAptQIData.ppQIResults = ppQIResults;
        xAptQIData.pRemUnk = this;

        hr = SwitchForCallback(pPS, CrossAptQIFn, &xAptQIData,
                               IID_IUnknown, 0, NULL);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RemQueryInterface this:%x pQIRes:%x hr:%x\n",
        this, *ppQIResults, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::GetSecBinding
//
//  Synopsis:   Get the security binding of the caller
//
//  History:    21-Feb-96   AlexMit     Created
//
//--------------------------------------------------------------------
HRESULT CRemoteUnknown::GetSecBinding( SECURITYBINDING **pSecBind )
{
    HRESULT       hr;
    DWORD         lAuthnSvc;
    DWORD         lAuthzSvc;
    DWORD         lAuthnLevel;
    const WCHAR  *pPrivs;
    DWORD         lLen;

    hr = CoQueryClientBlanket( &lAuthnSvc, &lAuthzSvc, NULL,
                                &lAuthnLevel, NULL, (void **) &pPrivs, NULL );
    if (FAILED(hr))
        return hr;

    // For thread to thread calls, make up a privilege name.
    if (pPrivs == NULL && LocalCall())
        pPrivs = gLocalName;
    else if (lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE ||
             lAuthnLevel < gAuthnLevel)
        return E_INVALIDARG;

    if (pPrivs != NULL)
        lLen = lstrlenW( pPrivs ) * sizeof(WCHAR);
    else
        lLen = 0;
    *pSecBind = (SECURITYBINDING *) PrivMemAlloc(
                                     sizeof(SECURITYBINDING) + lLen );
    if (*pSecBind != NULL)
    {
        // Sometimes rpc returns authn svc 0.
        if (lAuthnSvc == RPC_C_AUTHN_NONE)
            lAuthnSvc = RPC_C_AUTHN_WINNT;

        (*pSecBind)->wAuthnSvc = (USHORT) lAuthnSvc;
        if (lAuthzSvc == RPC_C_AUTHZ_NONE)
            (*pSecBind)->wAuthzSvc = COM_C_AUTHZ_NONE;
        else
            (*pSecBind)->wAuthzSvc = (USHORT) lAuthzSvc;

        if (pPrivs != NULL)
            memcpy( &(*pSecBind)->aPrincName, pPrivs, lLen+2 );
        else
            (*pSecBind)->aPrincName = 0;

        return S_OK;
    }
    else
        return E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------
//
//  Function:   CrossAptAddRefFn        Internal
//
//  Synopsis:   This routine delegates CRemUnknown to do the actual
//              Addref on the server object
//
//  History:    07-May-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagXAptAddRefData
{
    USHORT           cIfs;
    REMINTERFACEREF *pIfRefs;
    HRESULT         *pResults;
    CRemoteUnknown  *pRemUnk;
} XAptAddRefData;

HRESULT __stdcall CrossAptAddRefFn(void *pv)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptAddRefFn\n"));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    XAptAddRefData *pXAptAddRefData = (XAptAddRefData *) pv;

    // Delegate to CRemoteUnknown
    hr = pXAptAddRefData->pRemUnk->RemAddRefWorker(pXAptAddRefData->cIfs,
                                                   pXAptAddRefData->pIfRefs,
                                                   pXAptAddRefData->pResults,
                                                   FALSE);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptAddRefFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemAddRef   public
//
//  Synopsis:   Remote calls to AddRef server objects arrive here.
//              This method delegates to RemAddRefWorker to do the
//              actual work
//
//  History:    07-May-98   Gopalk      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemAddRef(unsigned short cInterfaceRefs,
                                       REMINTERFACEREF InterfaceRefs[],
                                       HRESULT        *pResults)
{
    return(RemAddRefWorker(cInterfaceRefs, InterfaceRefs, pResults, TRUE));
}


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemAddRefWorker   public
//
//  Synopsis:   increment reference count
//
//  History:    22-Feb-95   AlexMit     Created
//              07-May-98   GopalK      Context related changes
//              05-Jul-99   a-sergiv    Move security check here
//
//  Description: Remote calls to AddRef for this OXID arrive
//               here.  This routine just looks up the correct remote
//               remote handler and asks it to do the work.
//
//--------------------------------------------------------------------
HRESULT CRemoteUnknown::RemAddRefWorker(unsigned short cInterfaceRefs,
                                        REMINTERFACEREF InterfaceRefs[],
                                        HRESULT *pResults,
                                        BOOL fTopLevel)
{
    // Adjust the reference count for each entry.
    HRESULT          hr       = S_OK;
    HRESULT          hr2;
    SECURITYBINDING *pSecBind = NULL;
    REMINTERFACEREF *pNext = InterfaceRefs;
    CStdIdentity    *pStdId, *pPrevStdId = NULL;

    // Get Current context
    CObjectContext *pCurrentCtx = GetCurrentContext();
    CObjectContext *pServerCtx;
    CPolicySet     *pPS;

    // Perform access check
    BOOL            bAccessDenied = (CheckAccess(NULL, NULL) != S_OK);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    for(USHORT i=0; i < cInterfaceRefs; i++, pNext++)
    {
        // Get the IPIDEntry for the specified IPID.
        IPIDEntry *pEntry = GetIPIDEntry(pNext->ipid);
        if(!pEntry)
        {
            // Don't assert on failure.  The server can disconnect and go away
            // while clients exist.
            pResults[i] = hr = CO_E_OBJNOTREG;
            continue;
        }

        // Get StdId
        pStdId = pEntry->pChnl->GetStdId();
        if(pStdId)
        {
            // Get server context
            pPS = pStdId->GetServerPolicySet();
            pServerCtx = pPS ? pPS->GetServerContext() : GetEmptyContext();

            // Compare contexts
            if (pServerCtx != pCurrentCtx)
            {
                // Check for top level call to this routine
                if (fTopLevel)
                {
                    UNLOCK(gIPIDLock);
                    ASSERT_LOCK_NOT_HELD(gIPIDLock);

                    if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
                    {
                        for(i=0;i<cInterfaceRefs;i++)
                            pResults[i] = E_ACCESSDENIED;
                        return E_ACCESSDENIED;
                    }

                    XAptAddRefData xAptAddRefData;

                    // Switch to server context for the AddRef
                    xAptAddRefData.cIfs     = cInterfaceRefs - i;
                    xAptAddRefData.pIfRefs  = pNext;
                    xAptAddRefData.pResults = pResults + i;
                    xAptAddRefData.pRemUnk  = this;

                    hr2 = SwitchForCallback(pPS, CrossAptAddRefFn,
                                            &xAptAddRefData,
                                            IID_IUnknown, 1, NULL);
                    if(FAILED(hr2))
                        hr = hr2;

                    return hr;
                }
                else
                {
                    OutputDebugStringW(L"CRemUnknown::RemAddRef called on objects "
                                      L"living in multiple contexts\n");
                    Win4Assert("CRemUnknown::RemAddRef called on objects living "
                               "in multiple contexts");
                    hr = pResults[i] = E_FAIL;
                    continue;
                }
            }
            else
            {
                ComDebOut((DEB_MARSHAL,
                           "CRemUnknown::RemAddRef pEntry:%x cCur:%x cAdd:%x "
                           "cStdId:%x ipid:%I\n", pEntry, pEntry->cStrongRefs,
                           pNext->cPublicRefs, pStdId->GetRC(), &pNext->ipid));

                Win4Assert(pNext->cPublicRefs > 0 || pNext->cPrivateRefs > 0);

                if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
                {
                    hr = pResults[i] = E_ACCESSDENIED;
                    continue;
                }

                // Lookup security info the first time an entry asks for
                // secure references.
                if (pNext->cPrivateRefs != 0 && pSecBind == NULL)
                {
                    hr2 = GetSecBinding( &pSecBind );
                    if (FAILED(hr2))
                    {
                        hr = pResults[i] = hr2;
                        continue;
                    }
                }

                hr2 = pStdId->IncSrvIPIDCnt(pEntry, pNext->cPublicRefs,
                                            pNext->cPrivateRefs, pSecBind,
                                            MSHLFLAGS_NORMAL);
                if (FAILED(hr2))
                    hr = pResults[i] = hr2;
                else
                    pResults[i] = S_OK;
            }
        }
        else
            hr = pResults[i] = CO_E_OBJNOTREG;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (pSecBind)
        PrivMemFree(pSecBind);

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CrossAptReleaseFn        Internal
//
//  Synopsis:   This routine delegates CRemUnknown to do the actual
//              Release on the server object
//
//  History:    07-May-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagXAptReleaseData
{
    USHORT            cIfs;
    REMINTERFACEREF  *pIfRefs;
    CRemoteUnknown   *pRemUnk;
} XAptReleaseData;

HRESULT __stdcall CrossAptReleaseFn(void *pv)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptReleaseFn\n"));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    XAptReleaseData *pXAptReleaseData = (XAptReleaseData *) pv;

    // Delegate to CRemoteUnknown
    hr = pXAptReleaseData->pRemUnk->RemReleaseWorker(pXAptReleaseData->cIfs,
                                                     pXAptReleaseData->pIfRefs,
                                                     FALSE);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptReleaseFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemRelease   public
//
//  Synopsis:   Remote calls to Release server objects arrive here
//              This method delegates to RemReleaseWorker to do the actual work
//
//  History:    07-May-98   Gopalk      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemRelease(unsigned short  cInterfaceRefs,
                                        REMINTERFACEREF InterfaceRefs[])
{
    return(RemReleaseWorker(cInterfaceRefs, InterfaceRefs, TRUE));
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemReleaseWorker  public
//
//  Synopsis:   decrement reference count
//
//  History:    22-Feb-95   AlexMit     Created
//              07-May-98   GopalK      Context related changes
//              05-Jul-99   a-sergiv    Move security check here
//
//  Description: Remote calls to Release for this OXID arrive
//               here.  This routine just looks up the correct remote
//               remote handler and asks it to do the work.
//
//--------------------------------------------------------------------
HRESULT CRemoteUnknown::RemReleaseWorker(unsigned short  cInterfaceRefs,
                                         REMINTERFACEREF InterfaceRefs[],
                                         BOOL fTopLevel)
{
    ComDebOut((DEB_MARSHAL,"CRemoteUnknown::RemReleaseWorker [in]\n"));
    REMINTERFACEREF *pNext    = InterfaceRefs;
    SECURITYBINDING *pSecBind = NULL;
    CStdIdentity   *pStdId    = NULL;

    // Get Current context
    CObjectContext *pCurrentCtx = GetCurrentContext();
    CObjectContext *pServerCtx;

    // Perform access check
    BOOL            bAccessDenied = (CheckAccess(NULL, NULL) != S_OK);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Adjust the reference count for each entry.
    for (USHORT i=0; i < cInterfaceRefs; i++, pNext++)
    {
        // Get the entry for the requested IPID. Remember whether this
        // is an IPID for a strong or a weak reference, then clear the
        // strong/weak bit so that GetIPIDEntry will find the IPID.

        DWORD mshlflags = (InterfaceRefs[i].ipid.Data1 & IPIDFLAG_WEAKREF)
                                ? MSHLFLAGS_WEAK : MSHLFLAGS_NORMAL;

        InterfaceRefs[i].ipid.Data1 &= ~IPIDFLAG_WEAKREF;
        IPIDEntry *pIPIDEntry = GetIPIDEntry(InterfaceRefs[i].ipid);

        if (pIPIDEntry)
        {
            // Get the entry for the requested IPID.
            HRESULT hr = S_OK;
            CStdIdentity *pStdIdNew = pIPIDEntry->pChnl->GetStdId();

            if (pStdIdNew == NULL)
            {
                hr = CO_E_OBJNOTCONNECTED;
            }
            else if (pStdIdNew != pStdId)
            {
                // the server object for this IPID differs from
                // the server object of the previous IPID, go figure
                // out what to do...

                // Get server context
                BOOL fSwitchContext = FALSE;
                CPolicySet *pPS = pStdIdNew->GetServerPolicySet();
                pServerCtx = pPS ? pPS->GetServerContext() : GetEmptyContext();

                if (pServerCtx != pCurrentCtx)
                {
                    // this new object lives in a different context than the
                    if (fTopLevel)
                    {
                        // top level call to this routine so OK to switch to
                        // server's context.
                        fSwitchContext = TRUE;
                    }
                    else
                    {
                        Win4Assert(!"CRemUnknown::RemRelease called on objects living "
                                    "in multiple contexts");
                        continue;
                    }
                }
                else
                {
                    // contexts match but the object is different. keep
                    // the new object alive while we do our work on it.
                    pStdIdNew->AddRef();
                    hr = pStdIdNew->PreventDisconnect();
                }

                if (pStdId)
                {
                    // there was a previous object, go cleanup that one.

                    // do the final release of the object while not holding
                    // the lock, since it may call into the server.
                    UNLOCK(gIPIDLock);
                    ASSERT_LOCK_NOT_HELD(gIPIDLock);

                    // This will handle any Disconnect that came in while we were
                    // busy.  Ignore error codes since we are releasing.
                    pStdId->HandlePendingDisconnect(S_OK);
                    pStdId->Release();
                    pStdId = NULL;

                    ASSERT_LOCK_NOT_HELD(gIPIDLock);
                    LOCK(gIPIDLock);
                }

                // the new StdId become the current one.
                pStdId = pStdIdNew;

                if (fSwitchContext)
                {
                    // need to switch to the server's context to do the release.
                    UNLOCK(gIPIDLock);
                    ASSERT_LOCK_NOT_HELD(gIPIDLock);

                    if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
                        return E_ACCESSDENIED;

                    // AddRef policy set to stabilize it
                    pPS->AddRef();

                    XAptReleaseData xAptReleaseData;

                    // Switch to server context for the AddRef
                    xAptReleaseData.cIfs    = cInterfaceRefs - i;
                    xAptReleaseData.pIfRefs = pNext;
                    xAptReleaseData.pRemUnk = this;

                    SwitchForCallback(pPS, CrossAptReleaseFn,
                                      &xAptReleaseData,
                                      IID_IUnknown, 2, NULL);

                    // Release policy set
                    pPS->Release();

                    return S_OK;
                }
            }

            if (SUCCEEDED(hr))
            {
                CPolicySet *pPS = pStdIdNew->GetServerPolicySet();
                pServerCtx = pPS ? pPS->GetServerContext() : NULL;

                if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
                    continue;
				
                // Get the client's security binding on the first entry
                // that releases secure references.
                if (pNext->cPrivateRefs > 0 && pSecBind == NULL)
                {
                    GetSecBinding( &pSecBind );
                    if (pSecBind == NULL)
                        continue;
                }

                ComDebOut((DEB_MARSHAL,
                           "CRemUnknown::RemRelease pEntry:%x cCur:%x "
                           "cStdId:%x cRel:%x mshlflags:%x ipid:%I\n",
                           pIPIDEntry, (mshlflags == MSHLFLAGS_WEAK) ?
                           pIPIDEntry->cWeakRefs : pIPIDEntry->cStrongRefs,
                           pStdId->GetRC(), pNext->cPublicRefs,
                           mshlflags, &pNext->ipid));
                Win4Assert(pNext->cPublicRefs > 0 || pNext->cPrivateRefs > 0);

                pStdId->DecSrvIPIDCnt(pIPIDEntry, pNext->cPublicRefs,
                                      pNext->cPrivateRefs, pSecBind,
                                      mshlflags);
            }
        }   // if IPIDEntry
    }   // for

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (pStdId)
    {
        // there was a last object, go clean it up.
        // This will handle any Disconnect that came in while we were
        // busy.  Ignore error codes since we are releasing.
        pStdId->HandlePendingDisconnect(S_OK);
        pStdId->Release();
    }

    PrivMemFree( pSecBind );
    ComDebOut((DEB_MARSHAL,"CRemoteUnknown::RemReleaseWorker [out]\n"));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   GetDestCtx
//
//  Synopsis:   Since we dont have the channel, get the DestCtx
//              from the CMessageCall in Tls.
//
//  History:    22-Nov-96        Rickhi Created
//
//--------------------------------------------------------------------
DWORD GetDestCtx(void **ppv)
{
    COleTls tls;
    Win4Assert( tls->pCallInfo != NULL );
    *ppv = NULL;
    return tls->pCallInfo->GetDestCtx();
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemQueryInterface2, public
//
//  Synopsis:   returns supported interfaces. Special version of
//              RemQI for objects which have handlers and aggregate
//              the standard marshaler. Such objects can add their own
//              data to the marshaled interface stream, so we have to
//              call IMarshal::MarshalInterface rather than shortcutting
//              to MarshalIPID.
//
//  History:    22-Nov-96        Rickhi    Created
//              05-Jul-99        a-sergiv  Move security check here
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemQueryInterface2(REFIPID ripid, USHORT cIids,
                         IID *iids, HRESULT *phr, MInterfacePointer **ppMIFs)
{
    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RemQueryInterface2 this:%x ipid:%I cIids:%x iids:%x ppMIFs:%x\n",
        this, &ripid, cIids, iids, ppMIFs));

    // validate the input parameters
    if (cIids == 0 || phr == NULL || ppMIFs == NULL)
    {
        return E_INVALIDARG;
    }

    // find the StdId
    HRESULT hr = RPC_E_INVALID_OBJECT;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    CStdIdentity *pStdId = GetStdIdFromIPID(ripid);
    if (pStdId)
    {
        hr = pStdId->PreventDisconnect();
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (SUCCEEDED(hr))
    {
        CPolicySet *pPS = pStdId->GetServerPolicySet();
        CObjectContext *pCurrentCtx = GetCurrentContext();
        CObjectContext *pServerCtx = pPS ? pPS->GetServerContext() : pCurrentCtx;

        if(!pPS || !pServerCtx->IsUnsecure())
        {
            if(CheckAccess(NULL, NULL) != S_OK)
            {
                pStdId->HandlePendingDisconnect(E_ACCESSDENIED);
                pStdId->Release();

                for(USHORT i=0;i<cIids;i++)
                    phr[i] = E_ACCESSDENIED;

                return E_ACCESSDENIED;
            }
        }

        USHORT  cFails = 0;

        // find outer IMarshal
        IMarshal *pIM = NULL;
        hr = pStdId->QueryInterface(IID_IMarshal, (void **)&pIM);

        if (SUCCEEDED(hr))
        {
            // get an IUnknown and DestCtx to pass to MarshalInterface
            IUnknown *pUnk = pStdId->GetServer();   // not AddRef'd
            void *pvDestCtx;
            DWORD dwDestCtx = GetDestCtx(&pvDestCtx);

            // loop on the cIIDs marshaling each requested interface
            for (USHORT i=0; i < cIids; i++)
            {
                // make a stream on memory.
                CXmitRpcStream Stm;

                // marshal the requested interface
                phr[i] = pIM->MarshalInterface(&Stm,
                                            iids[i], pUnk,
                                            dwDestCtx, pvDestCtx,
                                            MSHLFLAGS_NORMAL);

                if (SUCCEEDED(phr[i]))
                {
                    // extract the data ptr and cbData from the stream
                    Stm.AssignSerializedInterface((InterfaceData **)&ppMIFs[i]);
                }
                else
                {
                    // call failed, increment count of fails
                    cFails++;
                }
            }

            // release the IMarshal interface pointer
            pIM->Release();
        }

        if (cFails > 0)
        {
            hr = (cFails == cIids) ? E_NOINTERFACE : S_FALSE;
        }

        // handle any disconnects that came in while we were marshaling
        // the requested interfaces.
        hr = pStdId->HandlePendingDisconnect(hr);
    }

    if (pStdId)
        pStdId->Release();

    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RemQueryInterface2 this:%x phr:%x pMIF:%x hr:%x\n",
        this, phr[0], ppMIFs[0], hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemChangeRefs, public
//
//  Synopsis:   Change an interface reference from strong/weak or vice versa.
//
//  History:    08-Nov-95   Rickhi      Created
//
//  Note:       It is safe for this routine to ignore private refcounts
//              becuase it is only called locally hence we own the client
//              implementation and can guarantee they are zero.
//
//--------------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemChangeRef(ULONG flags, USHORT cInterfaceRefs,
                                          REMINTERFACEREF InterfaceRefs[])
{
    // figure out the flags to pass to the Inc/DecSrvIPIDCnt
    BOOL  fMakeStrong = flags & IRUF_CONVERTTOSTRONG;
    DWORD IncFlags    = fMakeStrong ? MSHLFLAGS_NORMAL : MSHLFLAGS_WEAK;
    DWORD DecFlags    = fMakeStrong ? MSHLFLAGS_WEAK : MSHLFLAGS_NORMAL;
    DecFlags |= (flags & IRUF_DISCONNECTIFLASTSTRONG) ? 0 : MSHLFLAGS_KEEPALIVE;

    CStdIdentity *pStdId = NULL;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    for (USHORT i=0; i < cInterfaceRefs; i++)
    {
        // Get the entry for the specified IPID.
        IPIDEntry *pEntry = GetIPIDEntry(InterfaceRefs[i].ipid);

        if (pEntry)
        {
            // find the StdId for this IPID. We assume that the client
            // only gives us IPIDs for the same object, so first time
            // we find a StdId we remember it and AddRef it. This is a safe
            // assumption cause the client is local to this machine (ie
            // we wrote the client).

            CStdIdentity *pStdIdTmp = pEntry->pChnl->GetStdId();

            if (pStdIdTmp != NULL)
            {
                if (pStdId == NULL)
                {
                    pStdId = pStdIdTmp;
                    pStdId->AddRef();
                }

                // We assume that all IPIDs are for the same object. We
                // just verify that here.

                if (pStdId == pStdIdTmp)
                {
                    // tweak the reference counts
                    pStdId->IncSrvIPIDCnt(
                        pEntry, InterfaceRefs[i].cPublicRefs,
                        fMakeStrong ? InterfaceRefs[i].cPrivateRefs : 0,
                        NULL, IncFlags);
                    pStdId->DecSrvIPIDCnt(
                        pEntry, InterfaceRefs[i].cPublicRefs,
                        fMakeStrong ? 0 : InterfaceRefs[i].cPrivateRefs,
                        NULL, DecFlags);
                }
            }
        }
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (pStdId)
    {
        // release the AddRef (if any) we did above
        pStdId->Release();
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RundownOid, public
//
//  Synopsis:   Tell the server that no clients are using an object
//
//  History:    25 May 95   AlexMit     Created
//              19 Jun 98   GopalK      Context changes
//              19 Dec 2000 DickD       COM+ Prefix bug 22887
//
//  Description: Lookup each OID in the IDTable.  If found and not
//               recently marshaled, call DisconnectObject on it.
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RundownOid(ULONG cOid, OID aOid[],
                                        BYTE aRundownStatus[])
{
    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RundownOid this:%x cOid:%x aOid:%x afOkToRundown:%x\n",
        this, cOid, aOid, aRundownStatus));

    if (IsCallerLocalSystem())
    {
        // allocate space for a bunch of results and OIDs. Control the
        // size of the allocation so we don't have to worry about
        // overflowing the stack.

#if DBG==1
        const int cMAX_OID_ALLOC = 2;
        MOID arMOID[cMAX_OID_ALLOC];
#else
        const int cMAX_OID_ALLOC = 100;
#endif

        ULONG cAlloc = min(cOid, cMAX_OID_ALLOC);
        RUNDOWN_RESULT *arResult = (RUNDOWN_RESULT *)
                                    _alloca(sizeof(RUNDOWN_RESULT) * cAlloc);
        CStdIdentity  **arpStdId = (CStdIdentity **)
                                    _alloca(sizeof(CStdIdentity *) * cAlloc);


        // now loop over the results, filling in the response
        DWORD iNow    = GetCurrentTime();
        DWORD dwAptId = GetCurrentApartmentId();

        CComApartment *pComApt;

        HRESULT hr = GetCurrentComApartment(&pComApt);
        if (FAILED(hr))	// COM+ 22887 GetCurrentComApartment can fail
        {
            return hr;
        }

        ULONG i = 0;
        while (i < cOid)
        {
            // first, ask the apartment object if it knows about these oids.
            // For each OID it knows about, it will tell us which ones can be
            // rundown now and which cannot. For the ones it does not know
            // about, we will have to look in the OID table.

            pComApt->CanRundownOIDs(min(cAlloc, cOid - i), &aOid[i], arResult);

            // lookup a bunch while we hold the lock. This saves a lot of
            // LOCK/UNLOCK activity which causes contention in a busy server.
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            for (ULONG j=0; i+j<cOid && j<cAlloc; j++)
            {
                arpStdId[j] = NULL;

                if (arResult[j] == RUNDWN_RUNDOWN)
                {
                    // OK to rundown the OID
                    aRundownStatus[i+j] = ORS_OK_TO_RUNDOWN;
                }
                else if (arResult[j] == RUNDWN_KEEP)
                {
                    // not OK to rundown the OID
                    aRundownStatus[i+j] = ORS_DONTRUNDOWN;
                }
                else
                {
                    // don't know about this OID, look it up
                    Win4Assert(arResult[j] == RUNDWN_UNKNOWN);

                    MOID moid;
                    MOIDFromOIDAndMID(aOid[i+j], gLocalMid, &moid);
#if DBG==1
                    arMOID[j] = moid;
#endif
                    hr = ObtainStdIDFromOID(moid, dwAptId, TRUE, &arpStdId[j]);
                    if (SUCCEEDED(hr))
                    {
                        // found it, ask the stdid if it can be run down.
                        Win4Assert(arpStdId[j] != NULL);
                        aRundownStatus[i+j] = arpStdId[j]->CanRunDown(iNow);

                        // assert stdid returned valid status
                        Win4Assert(aRundownStatus[i+j] == ORS_DONTRUNDOWN ||
                                   aRundownStatus[i+j] == ORS_OK_TO_RUNDOWN ||
                                   aRundownStatus[i+j] == ORS_OID_PINNED);
                    }
                    else 
                    {
                        // if we did not find it, could be because the OID is in an
                        // intermediate stage (not in the list, but not yet registered
                        // either, default to FALSE).
                        Win4Assert(arpStdId[j] == NULL);
                        aRundownStatus[i+j] = ORS_DONTRUNDOWN;
                    }
                }
            }

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            for (j=0; i+j<cOid && j<cAlloc; j++)
            {
                Win4Assert(i<cOid);
                CStdIdentity *pStdId = arpStdId[j];
                if (pStdId)
                {
                    if (aRundownStatus[i+j] == ORS_OK_TO_RUNDOWN)
                    {
                        ComDebOut((DEB_MARSHAL,
                           "Running Down Object: pStdId:%x pCtrlUnk:%x moid:%I\n",
                            pStdId, pStdId->GetCtrlUnk(), &arMOID[j]));
                        pStdId->DisconnectAndRelease(DISCTYPE_RUNDOWN);
                    }
                    else
                    {
                        pStdId->Release();
                    }
                }
            }

            // increment the counter
            i += j;
        }

        pComApt->Release();
    }
    else
    {
        // Rather then being rude and returning access denied, tell the caller
        // that all the objects have been released.
        ComDebOut((DEB_ERROR, "Invalid user called CRemoteUnknown::RundownOid" ));
        for (ULONG i = 0; i < cOid; i++)
            aRundownStatus[i] = ORS_OK_TO_RUNDOWN;
    }

#if DBG==1
    // print out the results
    ULONG *ptr = (ULONG *)aOid;
    for (ULONG k=0; k<cOid; k++, ptr+=2)
    {
        ComDebOut((DEB_MARSHAL, "OID: %x %x  Result:%s\n", *ptr, *(ptr+1),
                  (aRundownStatus[k] == ORS_OK_TO_RUNDOWN) ? "RUNDOWN" : "KEEP"));
    }
#endif // DBG==1

    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Method:     DoCallback                Internal
//
//  Synopsis:   This method is used for the apartment switching part
//              of the context callback implementation
//
//  History:    19-Apr-98   Johnstra      Created
//              30-Jun-98   GopalK        Rewritten
//
//+-------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::DoCallback(XAptCallback *pCallbackData)
{
    ContextDebugOut((DEB_WRAPPER, "CRemoteUnknown::DoCallback\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    CObjectContext *pServerCtx = (CObjectContext *) pCallbackData->pServerCtx;

    // Check for the need to switch
    if (pServerCtx != GetCurrentContext())
    {
        BOOL fCreate = TRUE;
        CPolicySet *pPS;

        // Obtain policy set
        hr = ObtainPolicySet(NULL, pServerCtx, PSFLAG_STUBSIDE,
                             &fCreate, &pPS);
        if(SUCCEEDED(hr))
        {
            // Execute callback
            hr = SwitchForCallback(pPS,
                                   (PFNCTXCALLBACK) pCallbackData->pfnCallback,
                                   (void *) pCallbackData->pParam,
                                   pCallbackData->iid,
                                   pCallbackData->iMethod,
                                   (IUnknown *) pCallbackData->pUnk);

            // Release policy set
            pPS->Release();
        }
    }
    else
    {
        // Execute the callback
        hr = ((PFNCTXCALLBACK) pCallbackData->pfnCallback)((void *) pCallbackData->pParam);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CRemoteUnknown::DoCallback returning hr:0x%x\n", hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\rpchelp.cxx ===
//+-------------------------------------------------------------------
//
//  File:       rpchelp.cxx
//
//  Contents:   class for implementing IRpcHelper used by RPC
//              to get information from DCOM.
//
//  Classes:    CRpcHelper
//
//  History:    09-Oct-97   RickHi  Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <locks.hxx>
#include <objsrv.h>         // IRpcHelper


extern HRESULT GetIIDFromObjRef(OBJREF &objref, IID **piid);

//+-------------------------------------------------------------------
//
// Class:       CRpcHelper
//
// Synopsis:    Implements the IRpcHelper interface used by the
//              RPC runtime to get private information from the
//              DCOM version running on this machine.
//
// History:     09-Oct-97   RickHi     Created
//
//--------------------------------------------------------------------
class CRpcHelper : public IRpcHelper
{
public:
    // construction
    CRpcHelper() { _cRefs = 1; }
    friend HRESULT CRpcHelperCF_CreateInstance(IUnknown *pUnkOuter,
                                               REFIID riid,
                                               void** ppv);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *pv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IRpcHelper
    STDMETHOD(GetDCOMProtocolVersion)(DWORD *pComVersion);
    STDMETHOD(GetIIDFromOBJREF)(void *pObjRef, IID **piid);

private:
    ULONG               _cRefs;     // reference count
};

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::QueryInterface
//
//  History:    09-Oct-97   RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRpcHelper::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IRpcHelper) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IRpcHelper *)this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::AddRef
//
//  History:    09-Oct-97   RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcHelper::AddRef()
{
    return InterlockedIncrement((long *)&_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::Release
//
//  History:    09-Oct-97    RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcHelper::Release()
{
    ULONG cRefs = InterlockedDecrement((long *)&_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }
    return cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::GetDCOMProtocolVersion
//
//  Synopsis:   return local processes DCOM protocol version
//
//  History:    09-Oct-97    RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRpcHelper::GetDCOMProtocolVersion(DWORD *pComVersion)
{
    ComDebOut((DEB_TRACE, "CRpcHelper::GetDCOMProtocolVersion pComVersion:%x",
               pComVersion));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    ((COMVERSION *)pComVersion)->MajorVersion = COM_MAJOR_VERSION;
    ((COMVERSION *)pComVersion)->MinorVersion = COM_MINOR_VERSION;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_TRACE, "CRpcHelper::GetDCOMProtocolVersion hr:%x ComVersion:%x",
               hr, *pComVersion));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::GetIIDFromOBJREF
//
//  Synopsis:   return the IID of the interface that was marshaled
//              in the supplied OBJREF.
//
//  History:    09-Oct-97    RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRpcHelper::GetIIDFromOBJREF(void *pObjRef, IID **piid)
{
    ComDebOut((DEB_TRACE,
        "CRpcHelper::GetIIDFromOBJREF pObjRef:%x piid:%x", pObjRef, piid));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = GetIIDFromObjRef(*(OBJREF *)pObjRef, piid);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_TRACE, "CRpcHelper::GetIIDFromOBJREF hr:%x iid:%I", hr, *piid));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CRpcHelperCF_CreateInstance, public
//
//  History:    09-Oct-97   Rickhi  Created
//
//  Notes:      Class Factory CreateInstance function.
//
//--------------------------------------------------------------------
HRESULT CRpcHelperCF_CreateInstance(IUnknown *pUnkOuter,
                                    REFIID riid,
                                    void** ppv)
{
    Win4Assert(pUnkOuter == NULL);

    HRESULT hr = E_OUTOFMEMORY;
    CRpcHelper *pRpcHlp = new CRpcHelper();
    if (pRpcHlp)
    {
        hr = pRpcHlp->QueryInterface(riid, ppv);
        pRpcHlp->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\rpcopt.cxx ===
//+-------------------------------------------------------------------
//
//  File:       rpcopt.cxx
//
//  Contents:   class for implementing IRpcOptions
//
//  Classes:    CRpcOptions
//
//  History:    09-Jan-97    MattSmit       Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <locks.hxx>

#if (_WIN32_WINNT >= 0x500)
#include <ctxchnl.hxx>
#else
#include <channelb.hxx>
#endif

#include <ipidtbl.hxx>
#include "rpcopt.hxx"

//+-------------------------------------------------------------------
//
// Section:   IUnknown Methods for CRpcOptions
//
//--------------------------------------------------------------------

STDMETHODIMP CRpcOptions::QueryInterface(REFIID riid, LPVOID *pv)
{
    return _pUnkOuter->QueryInterface(riid, pv);
}

STDMETHODIMP_(ULONG) CRpcOptions::AddRef()
{
    return _pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CRpcOptions::Release()
{
    return _pUnkOuter->Release();
}


//+-------------------------------------------------------------------
//
// Section:   IRpcOptions Methods for CRpcOptions
//
//--------------------------------------------------------------------


CRpcOptions::CRpcOptions(CStdIdentity *pStdId, IUnknown *pUnkOuter)
    : _pStdId(pStdId), _pUnkOuter(pUnkOuter)
{
//    Win4Assert(_pStdId);
//    Win4Assert(_pUnkOuter);
}




//+-------------------------------------------------------------------
//
// Member:     Set
//
// Synopsis:   Set message queue specific properties on a proxy
//
// Arguments:
//   pPrx -       [in] Indicates the proxy to set.
//   dwProperty - [in] A single DWORD value from the COMBND_xxxx enumeration
//   dwValue -    [in] A single DWORD specifying the value for the
//                property being set.
//
// Returns:    S_OK, E_INVALIDARG
//
// Algorithm:  Use the IPID table to find the corresponding channel
//             object.  Query the channel object for the binding
//             handle and set the option on the handle
//
// History:    09-Jan-96    MattSmit  Created
//
//--------------------------------------------------------------------


STDMETHODIMP CRpcOptions::Set( IUnknown * pPrx,
                               DWORD      dwProperty,
                               ULONG_PTR  dwValue)
{
    ComDebOut((DEB_TRACE, "CRpcOptions::Set pPrx = 0x%p, dwProperty = 0x%x, dwValue = 0x%p\n",
               pPrx, dwProperty, dwValue));



#if (_WIN32_WINNT >= 0x500)
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    CChannelHandle *pRpc;
#else
    ASSERT_LOCK_RELEASED

    handle_t       hRpc;
#endif

    CRpcChannelBuffer *pChannel;
    HRESULT hr = S_OK;

    // parameter checking

    if (!IsValidInterface(pPrx) ||
        (dwProperty != COMBND_RPCTIMEOUT))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // Implements COMBND_RPCTIMEOUT

        // get the binding handle
#if (_WIN32_WINNT >= 0x500)
        hr = ProxyToBindingHandle(pPrx, &pRpc, TRUE);
#else
        hr = ProxyToBindingHandle(pPrx, &hRpc);
#endif
        if (SUCCEEDED(hr))
        {
            // set the properties.
#if (_WIN32_WINNT >= 0x500)
            RPC_STATUS sc = RpcMgmtSetComTimeout(pRpc->_hRpc, PtrToUint((void *)dwValue));
#else
            RPC_STATUS sc = RpcMgmtSetComTimeout(hRpc, dwValue);
#endif
            if (sc != RPC_S_OK)
            {
                hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC, sc);
            }
#if (_WIN32_WINNT >= 0x500)
            pRpc->Release();
#endif
        }

    }

#if (_WIN32_WINNT >= 0x500)
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
#else
    ASSERT_LOCK_RELEASED
#endif

    return hr;
}

//+-------------------------------------------------------------------
//
// Member:     Query
//
// Synopsis:   Query message queue specific properties on a proxy
//
// Arguments:
//   pPrx -        [in] Indicates the proxy to query.
//   pdwProperty - [in] A single DWORD value from the COMBND_xxxx enumeration
//   dwValue -     [in] A single DWORD pointer specifying where to place
//                 the result of the query
//
// Returns:    S_OK, E_INVALIDARG
//
// Algorithm:  Use the IPID table to find the corresponding channel
//             object.  Query the channel object for the binding
//             handle and query the binding handle for the property
//             status.
//
// History:    09-Jan-96    MattSmit  Created
//
//--------------------------------------------------------------------


STDMETHODIMP CRpcOptions::Query( IUnknown * pPrx,
                                 DWORD dwProperty,
                                 ULONG_PTR * pdwValue)
{
    ComDebOut((DEB_TRACE, "CRpcOptions::Query pPrx = 0x%p, dwProperty = 0x%x, pdwValue = 0x%p\n",
               pPrx, dwProperty, pdwValue));



#if (_WIN32_WINNT >= 0x500)
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    CChannelHandle *pHandle;
#else
    ASSERT_LOCK_RELEASED

    handle_t       pHandle;
#endif

    HRESULT hr = S_OK;

    // parameter checking

    if (!IsValidInterface(pPrx) ||
       !IsValidPtrOut(pdwValue, sizeof(ULONG_PTR)) ||
        (dwProperty != COMBND_RPCTIMEOUT))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // For COMBND_RPCTIMEOUT

        // Query the binding handle
#if (_WIN32_WINNT >= 0x500)
        hr = ProxyToBindingHandle(pPrx, &pHandle, FALSE);
#else
        hr = ProxyToBindingHandle(pPrx, &pHandle);
#endif

        // set the property
        if (SUCCEEDED(hr))
        {
            RPC_STATUS sc;

#if (_WIN32_WINNT >= 0x500)
            UINT dwTimeout = 0;
            sc = RpcMgmtInqComTimeout(pHandle->_hRpc, &dwTimeout);
            *pdwValue = dwTimeout;      //Allow Compiler to widen it on Win64
#else
            sc = RpcMgmtInqComTimeout(pHandle, (UINT*)pdwValue);
#endif

            if (sc != RPC_S_OK)
            {
                hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, sc);
            }
#if (_WIN32_WINNT >= 0x500)
            pHandle->Release();
#endif
        }

#if (_WIN32_WINNT >= 0x500)
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
#else
        ASSERT_LOCK_RELEASED
#endif

    }
    return hr;

}


//+-------------------------------------------------------------------
//
// Member:     ProxyToBindingHandle
//
// Synopsis:   Use internal DCOM data structure to get the corr-
//             esponding binding handle for the specified proxy.
//
// Arguments:
//   pPrx          [in]  proxy
//   pHandle       [out] Channel handle
//   fSave         [in]  {W2K}Whether the binding handle, if created, is saved in the channel
//
// Returns:    S_OK, E_INVALIDARG
//
// Algorithm:  Verify the parameters. Use the proxy manager to get
//             the proxy's IPID entry.  Get the handle from the
//             channel object in the IPID entry.
//
// History:    09-Jan-96    MattSmit  Created
//
//--------------------------------------------------------------------



#if (_WIN32_WINNT >= 0x500)
HRESULT CRpcOptions::ProxyToBindingHandle(void *pPrx, CChannelHandle **pHandle, BOOL fSave )
#else
HRESULT CRpcOptions::ProxyToBindingHandle(void *pPrx, handle_t *pHandle )
#endif
{
    ComDebOut((DEB_TRACE,
              "CRpcOptions::ProxyToBindingHandle pPrx = 0x%p, pHandle = 0x%p\n",
              pPrx, pHandle));

#if (_WIN32_WINNT >= 0x500)
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
#else
    ASSERT_LOCK_RELEASED
    LOCK(gComLock);
#endif

    IPIDEntry *pIPID;
    HRESULT hr = _pStdId->FindIPIDEntryByInterface(pPrx, &pIPID);

    if (SUCCEEDED(hr))
    {
        // disallow server entries
        if (pIPID->dwFlags & IPIDF_SERVERENTRY)
        {
            hr = E_INVALIDARG;
        }
        // No rpc options for disconnected proxies.
        else if (pIPID->dwFlags & IPIDF_DISCONNECTED)
        {
            hr = RPC_E_DISCONNECTED;
        }
        // No rpc options for process local proxies.
        else if (pIPID->pChnl->ProcessLocal())
        {
            hr = E_INVALIDARG;
        }
        else
        {
#if (_WIN32_WINNT >= 0x500)
            hr = pIPID->pChnl->GetHandle(pHandle, fSave);
#else
            hr = pIPID->pChnl->GetHandle(pHandle);
#endif

        }
    }

#if (_WIN32_WINNT >= 0x500)
    UNLOCK(gIPIDLock);
#else
    UNLOCK(gComLock);
#endif

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   remote
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES    = \
    ..\..\..\common\$(DEST_TREE);\
    ..\..\..\ih;\
    ..;..\..\inc;\
    ..\..\class;\
    ..\..\objact;\
    ..\..\..\idl\public\$(DEST_TREE)\$(O);\
    ..\..\..\idl\internal\$(DEST_TREE)\$(O);\
    ..\..\..\idl\private\$(DEST_TREE)\$(O);\
    ..\..\..\actprops;\
    $(BASE_INC_PATH)

MIDL_UUIDDIR=$(O)
PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)
MIDL_TLBDIR=$(O)

C_DEFINES=    \
              $(C_DEFINES) -DMSWMSG

SOURCES=      $(SOURCES)      \
              ..\stub_rawprivact_c.c  \
              ..\aggid.cxx    \
              ..\aprtmnt.cxx  \
              ..\callctrl.cxx \
              ..\call.cxx     \
              ..\callmgr.cxx  \
              ..\chancont.cxx \
              ..\channelb.cxx \
              ..\chock.cxx    \
              ..\coapi.cxx    \
              ..\context.cxx  \
              ..\crossctx.cxx \
              ..\ctxchnl.cxx  \
              ..\destobj.cxx  \
              ..\events.cxx   \
              ..\excepn.cxx   \
              ..\giptbl.cxx   \
              ..\hash.cxx     \
              ..\idobj.cxx    \
              ..\ipaddr.cxx   \
              ..\ipidtbl.cxx  \
              ..\ipmrshl.cxx  \
              ..\locks.cxx    \
              ..\marshal.cxx  \
              ..\orpc_dbg.c   \
              ..\pgalloc.cxx  \
              ..\pstable.cxx  \
              ..\rpchelp.cxx  \
              ..\refcache.cxx \
              ..\remoteu.cxx  \
              ..\resolver.cxx \
              ..\riftbl.cxx   \
              ..\rpcopt.cxx   \
              ..\security.cxx \
              ..\service.cxx  \
              ..\stdid.cxx    \
              ..\stream.cxx   \
              ..\sync.cxx     \
              ..\surract.cxx  \
              ..\threads.cxx  \
              ..\svcdomain.cxx \

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\service.cxx ===
//+-------------------------------------------------------------------
//
//  File:       service.cxx
//
//  Contents:   APIs to simplify RPC setup
//
//  Functions:
//
//  History:    23-Nov-92   Rickhi
//              20-Feb-95   Rickhi  Major Simplification for DCOM
//              20-Jan-97   Ronans  Merged predefined  endpoint changes
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <service.hxx>           // CRpcService
#include    <orcb.h>                // IOrCallback
#include    <malloc.hxx>            // MIDL_user_allocate
#include    <locks.hxx>             // LOCK/UNLOCK etc
#include    <security.hxx>          // gpsaSecurity
#include    <riftbl.hxx>            // gRemUnknownIf. gRemUnknownIf2
#include    <TCHAR.H>               // portability macros
#include    <netevent.h>            // EVENT_DCOM_INVALID_ENDPOINT_DATA
#include    <secdes.hxx>            // Security descriptor utilities
#include    <resolver.hxx>          // CRpcResolver 
#include    <ipidtbl.hxx>           // CMIDTable

BOOL             gSpeedOverMem      = FALSE;    // Trade memory for speed.
BOOL             gfListening        = FALSE;    // Server is/isn't listening
BOOL             gfDefaultStrings   = FALSE;    // Using precomputed string bindings
BOOL             gfLrpc             = FALSE;    // Registered for ncalrpc
DWORD            gdwEndPoint        = 0;
DWORD            gdwPsaMaxSize      = 0;
DUALSTRINGARRAY *gpsaCurrentProcess = NULL;
const DWORD      MAX_LOCAL_SB       = 23;

#ifndef _CHICAGO_
CWorldSecurityDescriptor* pLrpcSecurityDescriptor = NULL;
BOOL                      fLrpcSDInitialized = FALSE;
#endif

// ronans - flags for endpoint processing
#define POLICY_PROTSEQ_DISALLOWED 3

// flag to indicate endpoints have been added programmatically
// in this case no endpoints will be read from registry
static BOOL sfProgrammaticEndpoints = FALSE;

// flag to indicate if endpoints have already been processed for server
// if so disallow any more endpoints
static BOOL sfEndpointsProcessed = FALSE;

// forward declarations for predefined endpoint processing
static HRESULT wGetFinalEndpointTable();

// global endpoint table per process
CEndpointsTable gEndpointsTable;

// ronans DCOMHTTTP
// CODEWORK - add this to common header
#ifndef ID_DCOMHTTP
#define ID_DCOMHTTP (0x1f)
#endif


// Private Interface Registration. We need to register interfaces such as
// IOrCallback and IRemUnknown, and IRemUnknown2 because these never get
// marshaled by CoMarshalInterface.

typedef struct tagRegIf
{
    RPC_IF_HANDLE   hServerIf;      // interface handle
    DWORD           dwRegFlags;     // registration flags
} RegIf;

const ULONG cDcomInterfaces = 3;

RegIf   arDcomInterfaces[] =
        {
            {_IOrCallback_ServerIfHandle, RPC_IF_AUTOLISTEN},
            {(RPC_IF_HANDLE) &gRemUnknownIf,  RPC_IF_AUTOLISTEN | RPC_IF_OLE},
            {(RPC_IF_HANDLE) &gRemUnknownIf2, RPC_IF_AUTOLISTEN | RPC_IF_OLE},
        };


#if DBG==1
//+-------------------------------------------------------------------
//
//  Function:   DisplayAllStringBindings, private
//
//  Synopsis:   prints the stringbindings to the debugger
//
//  Notes:      This function requires the caller to hold gComLock.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
void DisplayAllStringBindings(void)
{
    ASSERT_LOCK_HELD(gComLock);

    if (gpsaCurrentProcess)
    {
        LPWSTR pwszNext = gpsaCurrentProcess->aStringArray;
        LPWSTR pwszEnd = pwszNext + gpsaCurrentProcess->wSecurityOffset;

        while (pwszNext < pwszEnd)
        {
            ComDebOut((DEB_CHANNEL, "pSEp=%x %ws\n", pwszNext, pwszNext));
            pwszNext += lstrlenW(pwszNext) + 1;
        }
    }
}
#endif // DBG == 1


//+-------------------------------------------------------------------
//
//  Function:   InitializeLrpcSecurity, private
//
//  Synopsis:   Create a DACL allowing all access to NCALRPC endpoints.
//
//--------------------------------------------------------------------
void InitializeLrpcSecurity()
{
#ifndef _CHICAGO_
    if (!fLrpcSDInitialized)
    {
        //
        // This function may be called by multiple threads
        // simultaneously and we don't want to allocate more than
        // one object. Hence the InterlockedCompareExchange trick.
        //

        CWorldSecurityDescriptor *pWSD = new CWorldSecurityDescriptor;
        if(!pWSD) return;

        if(InterlockedCompareExchangePointer((PVOID*) &pLrpcSecurityDescriptor,
                                             pWSD,
                                             NULL) != NULL)
        {            
            delete pWSD;  // Someone beat us.
        }
        else
        {
            fLrpcSDInitialized = TRUE;
        }

    }
#endif
}

//+-------------------------------------------------------------------
//
//  Function:   RegisterLrpc, private
//
//  Synopsis:   Register the ncalrpc transport.
//
//--------------------------------------------------------------------
RPC_STATUS RegisterLrpc()
{
    RPC_STATUS sc;
    WCHAR      pwszEndPoint[50];
    HANDLE     hThread;
    BOOL       fRet;

    // Make sure RPC doesn't create any threads while impersonating.
    SuspendImpersonate( &hThread );

    InitializeLrpcSecurity();
    if(!pLrpcSecurityDescriptor)
        return RPC_S_OUT_OF_MEMORY;

    lstrcpyW( pwszEndPoint, L"OLE" );
    fRet = our_ultow(gdwEndPoint, &pwszEndPoint[3], 40, 16 );  // actually 47, but oh well
    Win4Assert(fRet);

    // The second parameter is a hint that tells lrpc whether or not it
    // can preallocate additional resources (threads).

    ComDebOut((DEB_CHANNEL, "->RpcServerUseProtseqEp(protseq=ncalrpc, maxcalls= %lu, endpt=%ws, xxx)\n",
              gSpeedOverMem ? RPC_C_PROTSEQ_MAX_REQS_DEFAULT + 1 : RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
              pwszEndPoint));
    sc = RpcServerUseProtseqEp(L"ncalrpc",
                               RPC_C_PROTSEQ_MAX_REQS_DEFAULT + 1,
                               pwszEndPoint,
#ifndef _CHICAGO_
                               pLrpcSecurityDescriptor);
#else
                               NULL);
#endif
    ComDebOut((DEB_CHANNEL, "<-RpcServerUseProtseqEp(status=0x%x)\n",sc));

    // Put the impersonation token back.
    ResumeImpersonate( hThread );

    // Assume that duplicate endpoint means we registered the endpoint and
    // got unload and reloaded instead of it meaning someone else registered
    // the endpoint.
    if (sc == RPC_S_DUPLICATE_ENDPOINT)
    {
        gfLrpc = TRUE;
        return RPC_S_OK;
    }
    else if (sc == RPC_S_OK)
    {
        gfLrpc = TRUE;
    }
    return sc;
}

//+-------------------------------------------------------------------
//
//  Function:   CheckLrpc, private
//
//  Synopsis:   Register the ncalrpc transport if not already registered.
//
//--------------------------------------------------------------------
HRESULT CheckLrpc()
{
    RPC_STATUS sc = S_OK;

    ASSERT_LOCK_DONTCARE(gComLock);
    LOCK(gComLock);

    if (!gfLrpc)
    {
        // Get a unique number and convert it to a string endpoint.
        if (gdwEndPoint == 0)
        {
            gdwEndPoint = CoGetCurrentProcess();
        }

        if (gdwEndPoint == 0)
        {
            sc = E_FAIL;
        }
        else
        {
            // Register LRPC.
            sc = RegisterLrpc();
            if (sc != RPC_S_OK)
                sc = HRESULT_FROM_WIN32(sc);
        }
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_DONTCARE(gComLock);
    return sc;
}



//+-------------------------------------------------------------------
//
//  Function:   DefaultStringBindings, private
//
//  Synopsis:   Create a string binding with an entry for just ncalrpc.
//
//  Notes:      This function requires the caller to hold gComLock.
//
//--------------------------------------------------------------------
RPC_STATUS DefaultStringBindings()
{
    ULONG cChar;
    BOOL fRet;

    ASSERT_LOCK_HELD(gComLock);

    // Reserve space for the string
    // ncalrpc:[OLEnnnnnnnn]
    Win4Assert(gfLrpc);

    // Allocate memory.  Reserve space for an empty security binding.
    gpsaCurrentProcess = (DUALSTRINGARRAY *) PrivMemAlloc( SASIZE(27) );

    // Give up if the allocation failed.
    if (gpsaCurrentProcess == NULL)
        return RPC_S_OUT_OF_RESOURCES;

    // Build a string binding for ncalrpc.
    lstrcpyW( gpsaCurrentProcess->aStringArray, L"ncalrpc:[OLE" );
    fRet = our_ultow( gdwEndPoint, &gpsaCurrentProcess->aStringArray[12], 8, 16 );
    Win4Assert(fRet);

    cChar = lstrlenW( gpsaCurrentProcess->aStringArray );
    gpsaCurrentProcess->aStringArray[cChar++] = L']';
    gpsaCurrentProcess->aStringArray[cChar++] = 0;

    // Stick on an empty security binding.
    gpsaCurrentProcess->aStringArray[cChar++] = 0;
    gpsaCurrentProcess->wSecurityOffset       = (USHORT) cChar;
    gpsaCurrentProcess->aStringArray[cChar++] = 0;
    gpsaCurrentProcess->aStringArray[cChar++] = 0;
    gpsaCurrentProcess->wNumEntries           = (USHORT) cChar;
    gfDefaultStrings                          = TRUE;
    return RPC_S_OK;
}


//+-------------------------------------------------------------------
//
//  Function:   InquireStringBindings, private
//
//  Synopsis:   Get and server binding handles from RPC and convert them
//              into a string array.
//
//  Notes:      This function requires the caller to hold gComLock.
//
//  History:    23 May 95 AlexMit       Created
//
//--------------------------------------------------------------------
BOOL InquireStringBindings( WCHAR *pProtseq)
{
    ASSERT_LOCK_HELD(gComLock);

    BOOL                fFound    = FALSE;
    DWORD               cbProtseq;
    RPC_BINDING_VECTOR *pBindVect = NULL;
    RPC_STATUS sc = RpcServerInqBindings(&pBindVect);


    if (sc == S_OK)
    {
        LPWSTR *apwszFullStringBinding;
        ULONG  *aulStrLen;
        ULONG   ulTotalStrLen = MAX_LOCAL_SB; // Total string lengths
        ULONG   j             = 0;            // BindString we're using

        if (pProtseq != NULL)
            cbProtseq = lstrlenW( pProtseq ) * sizeof(WCHAR);
        else
            cbProtseq = 0;
        apwszFullStringBinding = (LPWSTR *) PrivMemAlloc( pBindVect->Count *
                                                          sizeof(LPWSTR) );
        aulStrLen              = (ULONG *)  PrivMemAlloc( pBindVect->Count *
                                                          sizeof(ULONG) );
        if (apwszFullStringBinding != NULL &&
            aulStrLen              != NULL)
        {
            //  iterate over the handles to get the string bindings
            //  and dynamic endpoints for all available protocols.

            for (ULONG i=0; i<pBindVect->Count; i++)
            {
                LPWSTR  pwszStringBinding = NULL;
                LPWSTR  pwszProtseq       = NULL;
                LPWSTR  pwszEndpoint      = NULL;

                apwszFullStringBinding[j] = NULL;
                aulStrLen[j]              = 0;

                sc = RpcBindingToStringBinding(pBindVect->BindingH[i],
                                               &pwszStringBinding);
                if (sc == RPC_S_OK)
                {

                    sc = RpcStringBindingParse(pwszStringBinding,
                                               0,
                                               &pwszProtseq,
                                               0,
                                               &pwszEndpoint,
                                               0);



                    ComDebOut((DEB_MARSHAL, "InquireStringBindings processing binding %ws\n", pwszStringBinding));


                    if (sc == RPC_S_OK)
                    {
                        // Determine is this is the protseq we are looking for.
                        if (memcmp( pProtseq, pwszStringBinding, cbProtseq ) == 0)
                            fFound = TRUE;

                        // Skip OLE ncalrpc endpoints -- added back in below
                        if ( (lstrcmpW( L"ncalrpc", pwszProtseq)  != 0) ||
                             (lstrlenW(pwszEndpoint) < 3) ||
                             (lstrcmpW( L"OLE", pwszEndpoint) != 0))
                        {
                            //  record the string lengths for later. include room
                            //  for the NULL terminator.
                            apwszFullStringBinding[j] = pwszStringBinding;
                            aulStrLen[j]              = lstrlenW(apwszFullStringBinding[j])+1;
                            ulTotalStrLen            += aulStrLen[j];
                            j++;

                        }
                        else
                        {
                            RpcStringFree( &pwszStringBinding );
                        }
                        RpcStringFree(&pwszProtseq);
                        RpcStringFree(&pwszEndpoint);
                    }
                }
            }   //  for


            //  now that all the string bindings and endpoints have been
            //  accquired, allocate a DUALSTRINGARRAY large enough to hold them
            //  all and copy them into the structure.

            if (ulTotalStrLen > 0)
            {
                void *pNew = PrivMemAlloc( sizeof(DUALSTRINGARRAY) +
                                           (ulTotalStrLen+1)*sizeof(WCHAR) );
                if (pNew)
                {
                    PrivMemFree( gpsaCurrentProcess );
                    gpsaCurrentProcess = (DUALSTRINGARRAY *) pNew;
                    LPWSTR pwszNext    = gpsaCurrentProcess->aStringArray;

                    // Copy in ncalrpc:[OLEnnnnnnnn]
                    if (gfLrpc)
                    {	
                        BOOL fRet;
                        lstrcpyW( pwszNext, L"ncalrpc:[OLE" );
                        fRet = our_ultow(gdwEndPoint, &pwszNext[12], 8, 16);
                        Win4Assert(fRet);
                        lstrcatW( pwszNext, L"]" );
                        pwszNext += lstrlenW(pwszNext) + 1;
                    }

                    // copy in the strings
                    for (i=0; i<j; i++)
                    {
                        lstrcpyW(pwszNext, apwszFullStringBinding[i]);
                        pwszNext += aulStrLen[i];
                    }

                    // Add a second null to terminate the string binding
                    // set.  Add a third and fourth null to create an empty
                    // security binding set.

                    pwszNext[0] = 0;
                    pwszNext[1] = 0;
                    pwszNext[2] = 0;

                    // Fill in the size fields.
                    gpsaCurrentProcess->wSecurityOffset = (USHORT) (pwszNext -
                                       gpsaCurrentProcess->aStringArray + 1);
                    gpsaCurrentProcess->wNumEntries =
                                       gpsaCurrentProcess->wSecurityOffset + 2;
                }
                else
                {
                    sc = RPC_S_OUT_OF_RESOURCES;
                }
            }
            else
            {
                //  no binding strings. this is an error.
                ComDebOut((DEB_ERROR, "No Rpc ProtSeq/EndPoints Generated\n"));
                sc = RPC_S_NO_PROTSEQS;
            }

            // free the full string bindings we allocated above
            for (i=0; i<j; i++)
            {
                //  free the old strings
                RpcStringFree(&apwszFullStringBinding[i]);
            }
        }
        else
        {
            sc = RPC_S_OUT_OF_RESOURCES;
        }

        //  free the binding vector allocated above
        RpcBindingVectorFree(&pBindVect);
        PrivMemFree( apwszFullStringBinding );
        PrivMemFree( aulStrLen );
    }

#if DBG==1
    //  display our binding strings on the debugger
    DisplayAllStringBindings();
#endif

    return fFound;
}

//+-------------------------------------------------------------------
//
//  Function:   StartListen, public
//
//  Synopsis:   this starts the Rpc service listening. this is required
//              in order to marshal interfaces.  it is executed lazily,
//              that is, we dont start listening until someone tries to
//              marshal a local object interface. this is done so we dont
//              spawn a thread unnecessarily.
//
//  Notes:      This function takes gComLock.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT StartListen(void)
{
    if (gfListening)
    {
        //already listening
        return S_OK;
    }

    ComDebOut((DEB_MARSHAL,"[IN] StartListen.\n"));
    RPC_STATUS sc = S_OK;

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    if (!gfListening)
    {
        // Register ncalrpc.
        sc = CheckLrpc();
        if (sc == S_OK)
        {
            // register the private DCOM interfaces that dont get registered
            // during CoMarshalInterface.
            sc = RegisterDcomInterfaces();

            if (sc == RPC_S_OK)
            {
                sc = DefaultStringBindings();
            }
            if (sc != RPC_S_OK)
            {
                sc = HRESULT_FROM_WIN32(sc);
            }
        }

        if (sc == RPC_S_OK)
        {
            gfListening = TRUE;
            sc = S_OK;
        }
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // If something failed, make sure everything gets cleaned up.
    if (FAILED(sc))
    {
        UnregisterDcomInterfaces();
    }

    ComDebOut(((sc == S_OK) ? DEB_MARSHAL : DEB_ERROR,
               "[OUT] StartListen hr: 0x%x\n", sc));
    return sc;
}

//+-------------------------------------------------------------------
//
//  Function:   GetStringBindings, public
//
//  Synopsis:   Return an array of strings bindings for this process
//
//  Notes:      This function takes gComLock.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT GetStringBindings( DUALSTRINGARRAY **psaStrings )
{
    TRACECALL(TRACE_RPC, "GetStringBindings");
    ComDebOut((DEB_CHANNEL, "[IN]  GetStringBindings\n"));

    *psaStrings = NULL;

    HRESULT hr = StartListen();
    if (SUCCEEDED(hr))
    {
        LOCK(gComLock);
        hr = CopyStringArray(gpsaCurrentProcess, gpsaSecurity, psaStrings);
        UNLOCK(gComLock);
    }

    ComDebOut((DEB_CHANNEL, "[OUT] GetStringBindings hr:%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CopyStringArray, public
//
//  Synopsis:   Combines the string bindings from the first DUALSTRINGARRAY
//              with the security bindings from the second DUALSTRINGARRAY
//              (if present) into a new DUALSTRINGARRAY.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT CopyStringArray(DUALSTRINGARRAY *psaStringBinding,
                        DUALSTRINGARRAY *psaSecurity,
                        DUALSTRINGARRAY **ppsaNew)
{
    // compute size of string bindings
    USHORT lSizeSB = SASIZE(psaStringBinding->wNumEntries);

    // compute size of additional security strings
    USHORT lSizeSC = (psaSecurity == NULL) ? 0 :
      psaSecurity->wNumEntries - psaSecurity->wSecurityOffset;

    *ppsaNew = (DUALSTRINGARRAY *) PrivMemAlloc( lSizeSB +
                                                 lSizeSC * sizeof(USHORT));

    if (*ppsaNew != NULL)
    {
        // copy in the string bindings
        memcpy(*ppsaNew, psaStringBinding, lSizeSB);

        if (psaSecurity != NULL)
        {
            // copy in the security strings, and adjust the overall length.
            memcpy(&(*ppsaNew)->aStringArray[psaStringBinding->wSecurityOffset],
                   &psaSecurity->aStringArray[psaSecurity->wSecurityOffset],
                   lSizeSC*sizeof(USHORT));

            (*ppsaNew)->wNumEntries = psaStringBinding->wSecurityOffset +
                                      lSizeSC;
        }
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------
//
//  Function:   RegisterDcomInterfaces
//
//  Synopsis:   Register the private DCOM interfaces.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
SCODE RegisterDcomInterfaces(void)
{
    ComDebOut((DEB_CHANNEL, "[IN] RegisterDcomInterfaces\n"));
    ASSERT_LOCK_HELD(gComLock);

    RPC_STATUS sc = RPC_S_OK;

    for (int i=0; i<cDcomInterfaces; i++)
    {
        ComDebOut((DEB_CHANNEL,
            "->RpcServerRegisterIfEx(iface=0x%x, flags:%x RPC_IF_AUTOLISTEN, 0xffff, xxx)\n",
            arDcomInterfaces[i].hServerIf, arDcomInterfaces[i].dwRegFlags));

        // The MaxRpcSize for this set of interfaces is the system default size
        sc = RpcServerRegisterIfEx(arDcomInterfaces[i].hServerIf,
                                   NULL, NULL,
                                   arDcomInterfaces[i].dwRegFlags,
                                   0xffff, NULL);

        ComDebOut((DEB_CHANNEL, "->RpcServerRegisterIfEx(status=0x%x)\n", sc));

        if (sc != RPC_S_OK && sc != RPC_S_TYPE_ALREADY_REGISTERED)
        {
            ComDebOut((DEB_ERROR, "RegisterDcomInterfaces sc:%x\n", sc));
            break;
        }

        sc = RPC_S_OK;
    }

    if (sc != RPC_S_OK)
        sc = HRESULT_FROM_WIN32(sc);

    ASSERT_LOCK_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "[OUT] RegisterDcomInterfaces hr:%x\n", sc));
    return sc;
}

//+-------------------------------------------------------------------
//
//  Function:   UnregisterDcomInterfaces
//
//  Synopsis:   Unregister the private DCOM interfaces and mark
//              DCOM as no longer accepting remote calls.
//
//  Notes:      This function requires that the caller guarantee
//              serialization without taking gComLock.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
SCODE UnregisterDcomInterfaces(void)
{
    ComDebOut((DEB_CHANNEL, "[IN] UnregisterDcomInterfaces\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    RPC_STATUS sc = RPC_S_OK;

    if (gfListening)
    {
        for (int i=0; i<cDcomInterfaces; i++)
        {
            // Unregister the interface. This can result in calls being
            // dispatched.  Do not hold the lock around this call.

            ComDebOut((DEB_CHANNEL,
                "->RpcServerUnregisterIf(iface=0x%x, 0, 1)\n",
                arDcomInterfaces[i].hServerIf));

            sc = RpcServerUnregisterIf(arDcomInterfaces[i].hServerIf, 0, 1 );

            ComDebOut((DEB_CHANNEL,
                "->RpcServerUnregisterIf(status=0x%x)\n", sc));
        }

        gfListening = FALSE;
    }

    gSpeedOverMem = FALSE;

    if (sc != RPC_S_OK)
        sc = HRESULT_FROM_WIN32(sc);

    ComDebOut((DEB_CHANNEL, "[OUT] UnregisterDcomInterfaces hr:%x\n", sc));
    return sc;
}


static void LogEndpointFailure(WCHAR *pszProtseq,
                               WCHAR *pszEndpoint,
                               DWORD  dwFlags)
{
    HANDLE  LogHandle;
    WCHAR const *  Strings[3]; // array of message strings.
    WCHAR szFlags[20];
    wsprintf(szFlags, L"0x%x", dwFlags);

    Strings[0] = pszProtseq;
    Strings[1] = pszEndpoint;
    Strings[2] = szFlags;

    // Get the log handle, then report the event.
    LogHandle = RegisterEventSource( NULL, L"DCOM" );

    if ( LogHandle )
    {
        ReportEventW( LogHandle,
                      EVENTLOG_ERROR_TYPE,
                      0,             // event category
                      EVENT_DCOM_INVALID_ENDPOINT_DATA,
                      NULL,
                      3,             // 3 strings passed
                      0,             // 0 bytes of binary
                      Strings,       // array of strings
                      NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   UseProtseq
//
//  Synopsis:   Use the specified protseq and return a list of all string
//              bindings.
//
//  History:    25 May 95 AlexMit       Created
//              01 Feb 97 Ronans        modified to use towerIds and custom endpoints
//              14 Jul 00 Sergei        Added IsCallerLocalSystem check
//
//--------------------------------------------------------------------


error_status_t _UseProtseq( handle_t hRpc,
                            unsigned short wTowerId,
                            DUALSTRINGARRAY **ppsaNewBindings,
                            DUALSTRINGARRAY **ppsaSecurity )
{
    // [Sergei O. Ivanov (sergei), 7/14/2000]
    // Only let clients running under SYSTEM account call _UseProtseq.
    // This foils possible Denial of Service (DoS) attacks.
    // Only RPCSS ever needs to call this fcn, and it runs as SYSTEM.
    if(!IsCallerLocalSystem(hRpc))
        return RPC_E_ACCESS_DENIED;

    BOOL fInUse = FALSE;
    RPC_STATUS sc = RPC_S_OK;
    wchar_t *pwstrProtseq = (wchar_t*)utGetProtseqFromTowerId(wTowerId);

    // Parameter validation:  the caller must pass in a valid tower
    // id, as well as valid out ptrs for the string\sec bindings.
    if (!pwstrProtseq || !ppsaNewBindings || !ppsaSecurity)
        return E_INVALIDARG;

#if 0 // #ifdef _CHICAGO_
    // It is possible that RPCSS was started after we connected
    // since a local middleman may have marshalled one of our
    // objrefs for export to another machine
    ReConnectResolver();
#endif // _CHICAGO_

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Make sure security is initialized.
    sc = DefaultAuthnServices();

    // If we have never inquired string bindings, inquire them before doing
    // anything else.
    if (sc == RPC_S_OK && gfDefaultStrings)
    {
        fInUse = InquireStringBindings( pwstrProtseq );
        gfDefaultStrings = FALSE;
    }

    if (sc == RPC_S_OK && !fInUse)
    {
        Win4Assert( lstrcmpW( pwstrProtseq, L"ncalrpc" ) != 0 );
        ComDebOut((DEB_CHANNEL, "->RpcServerUseProtseq(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL)\n",
                   pwstrProtseq));

        // ronans - added code to process custom endpoint entries
        CEndpointEntry *pCustomEntry;

        ComDebOut((DEB_CHANNEL, "_UseProtseq - searching custom endpoints table\n"));

        if ((gEndpointsTable.GetCount()) &&
            (pCustomEntry = gEndpointsTable.FindEntry(wTowerId)))
        {
            // setup custom entry
            RPC_POLICY rpcPolicy;
            rpcPolicy.Length = sizeof(RPC_POLICY);
            rpcPolicy.EndpointFlags = pCustomEntry -> m_dwFlags;
            rpcPolicy.NICFlags = 0;

            if (rpcPolicy.EndpointFlags != POLICY_PROTSEQ_DISALLOWED)
            {
                // call extended versions providing policy
                if (!pCustomEntry -> m_pszEndpoint)
                {
                    ComDebOut((DEB_CHANNEL,
                        "->RpcServerUseProtseqEx(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL)\n",
                           pwstrProtseq));

                    sc = RpcServerUseProtseqExW(pwstrProtseq,
                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                            NULL,
                            &rpcPolicy);

                    if (sc != RPC_S_OK)
                    {
                        LogEndpointFailure(pwstrProtseq,
                                           L"(not specified)",
                                           pCustomEntry -> m_dwFlags);
                    }
                }
                else
                {
                    ComDebOut((DEB_CHANNEL,
                        "->RpcServerUseProtseqEpEx(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, endpoint=%ws, NULL)\n",
                           pwstrProtseq, pCustomEntry -> m_pszEndpoint));

                    sc = RpcServerUseProtseqEpExW(pwstrProtseq,
                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                            pCustomEntry -> m_pszEndpoint,
                            NULL,
                            &rpcPolicy);

                    if (sc != RPC_S_OK)
                    {
                        LogEndpointFailure(pwstrProtseq,
                                           pCustomEntry -> m_pszEndpoint,
                                           pCustomEntry -> m_dwFlags);
                    }
                }

                ComDebOut((DEB_CHANNEL, "<-RpcServerUseProtseqEpEx(status=0x%x)\n",sc));
            }
            else
            {
                sc = RPC_E_ACCESS_DENIED;
                ComDebOut((DEB_CHANNEL, "<-_UseProtoseq - protocol sequence disabled\n",sc));
            }
        }
        else
        {
            // ronans - DCOMHTTP - if we're using DCOMHTTP - use the internet range of ports
            if (wTowerId == ID_DCOMHTTP)
            {
                // setup custom entry
                RPC_POLICY rpcPolicy;
                rpcPolicy.Length = sizeof(RPC_POLICY);
                rpcPolicy.EndpointFlags = RPC_C_USE_INTERNET_PORT;
                rpcPolicy.NICFlags = 0;

                // call extended versions providing policy
                ComDebOut((DEB_CHANNEL,
                    "->RpcServerUseProtseqEx(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL)\n",
                   pwstrProtseq));

                sc = RpcServerUseProtseqExW(pwstrProtseq,
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                        NULL,
                        &rpcPolicy);

                ComDebOut((DEB_CHANNEL, "<-RpcServerUseProtseqEx(status=0x%x)\n",sc));
            }
            else
            {
                ComDebOut((DEB_CHANNEL,
                            "->RpcServerUseProtseq(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL)\n",
                            pwstrProtseq));
                sc = RpcServerUseProtseq(pwstrProtseq,
                                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                        NULL);
                ComDebOut((DEB_CHANNEL, "<-RpcServerUseProtseq(status=0x%x)\n",sc));
            }

        }

        if (sc != RPC_S_OK)
        ComDebOut((DEB_CHANNEL, "Could not register protseq %ws: 0x%x\n",
                  pwstrProtseq, sc ));

        // Return the latest string bindings. Ignore failures.
        InquireStringBindings( NULL );
    }

    // Generate a copy to return.
    sc = CopyStringArray( gpsaCurrentProcess, NULL, ppsaNewBindings );
    if (SUCCEEDED(sc))
    {
        sc = CopyStringArray( gpsaSecurity, NULL, ppsaSecurity );
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
    return sc;
}



// static page allocator for endpoints table
CPageAllocator  CEndpointsTable ::_palloc;


//+------------------------------------------------------------------------
//
//  Member:     CEndpointsTable::Initialize, public
//
//  Synopsis:   Initializes the endpoints table static info.
//
//  Notes:      This function requires the caller to hold gComLock.
//
//  History:    20-Jan-97       Ronans  created
//
//-------------------------------------------------------------------------
void CEndpointsTable::Initialize()
{
    ComDebOut((DEB_CHANNEL, "CEndpointsTable Initialize \n"));
    LOCK(gComLock);

    m_pHead = NULL;
    m_nCount = 0;

    // note no locking will be used for page allocator
    _palloc.Initialize(sizeof(CEndpointEntry),ENDPOINTS_PER_PAGE,
                       (COleStaticMutexSem *)NULL);

    UNLOCK(gComLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::Cleanup
//
//  Synopsis:   removes all endpoints from table
//
//  Notes:      This function requires the caller to hold gComLock.
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
void CEndpointsTable::Cleanup()
{
    ComDebOut((DEB_CHANNEL, "CEndpointsTable Cleanup \n"));
    LOCK(gComLock);

    // delete all entries
    while (m_pHead)
    {
        CEndpointEntry* ptmp = m_pHead ;
        m_pHead = m_pHead -> m_pNext;
        delete ptmp;
    }

    m_nCount = 0;
    _palloc.Cleanup();

    UNLOCK(gComLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::GetIterator
//
//  Synopsis:   iterator to iterate through endpoints in table
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
ULONG_PTR CEndpointsTable::GetIterator()
{
    ASSERT_LOCK_HELD(gComLock);

    return (ULONG_PTR)m_pHead;
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::GetNextEntry
//
//  Synopsis:   get next entry and update iterator
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry * CEndpointsTable::GetNextEntry(ULONG_PTR &rIterator)
{
    ASSERT_LOCK_HELD(gComLock);

    ASSERT(rIterator != 0);
    CEndpointEntry * pEntry = (CEndpointEntry *)rIterator;

    rIterator = pEntry ? (ULONG_PTR) (pEntry -> m_pNext) : 0;
    return pEntry;
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::RemoveEntry
//
//  Synopsis:   removes specific endpoint from table
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
void CEndpointsTable::RemoveEntry(CEndpointEntry *pEntry)
{
    ASSERT_LOCK_HELD(gComLock);

    ASSERT(GetCount() != 0);

    CEndpointEntry *pTmp = NULL;
    CEndpointEntry *pNextTmp = m_pHead;

    while (pNextTmp  )
    {
        if (pNextTmp == pEntry)
        {
            if (pTmp)
                    pTmp -> m_pNext = pNextTmp -> m_pNext;
            else
                    m_pHead = pNextTmp -> m_pNext;
            delete pNextTmp;
            pNextTmp = NULL;
            m_nCount--;
        }
        else
        {
            pTmp = pNextTmp;
            pNextTmp = pNextTmp -> m_pNext;
        }
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::AddEntry
//
//  Synopsis:   adds new endpoint to table
//
//  Notes:      this method requires that gComLock is held before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry * CEndpointsTable::AddEntry(USHORT wTowerId, WCHAR* pszProtSeqEP, DWORD dwFlags)
{
    ComDebOut((DEB_CHANNEL, "CEndpointsTable AddEntry %d, %ws\n", wTowerId, pszProtSeqEP));

    ASSERT_LOCK_HELD(gComLock);

    CEndpointEntry *pNewEntry = new CEndpointEntry(wTowerId, pszProtSeqEP, dwFlags);
    if (pNewEntry && (pNewEntry -> IsValid()))
    {
        pNewEntry -> m_pNext = m_pHead;
        m_pHead = pNewEntry;
        m_nCount++;
    }
    else
    {
        if (pNewEntry)
        {
            delete pNewEntry;
            ComDebOut((DEB_ERROR, "CEndpointsTable - endpoint entry is invalid\n"));
            pNewEntry = NULL;
        }
        else
        {
            ComDebOut((DEB_ERROR, "CEndpointsTable - couldn't allocate entry\n"));
        }
    }

    return pNewEntry;
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointEntry constructor
//
//  Synopsis:   represents endpoint in table
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry::CEndpointEntry( USHORT wTowerId, WCHAR* pszEndpoint, DWORD dwFlags)
{
    m_dwFlags  = dwFlags;
    m_wTowerId = wTowerId;
    m_pszEndpoint = NULL;
    m_pNext = NULL;

    if (pszEndpoint)
    {
        if (m_pszEndpoint = new WCHAR[lstrlenW(pszEndpoint)+1])
            lstrcpyW(m_pszEndpoint, pszEndpoint);
        else
        {
            // reset towerid to 0 to indicate invalid state
            m_wTowerId = 0;

            // send error message to debugger
            ComDebOut((DEB_ERROR, "CEndpointEntry ::contructor - couldn't allocate memory for string copy\n"));
        }
    }

    ComDebOut((DEB_CHANNEL, "CEndpointEntry:: constructor structure [0x%p] %d, %ws %ld \n", this, m_wTowerId, m_pszEndpoint, m_dwFlags));
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointEntry destructor
//
//  Synopsis:   represents endpoint in table
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry::~CEndpointEntry()
{
    ComDebOut((DEB_CHANNEL, "CENdpointEntry:: destructor\n"));

    if (m_pszEndpoint)
        delete m_pszEndpoint;
}


//+-------------------------------------------------------------------
//
//  Function:   CEndpointEntry ::new operator
//
//  Synopsis:   custom allocator for endpoint entry
//
//  Notes:      requires holding gComLock before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
void* CEndpointEntry::operator new(size_t t)
{
    ComDebOut((DEB_CHANNEL, "CENdpointEntry:: new operator\n"));

    ASSERT_LOCK_HELD(gComLock);

    return (void*)(CEndpointsTable::_palloc.AllocEntry());
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointEntry ::delete operator
//
//  Synopsis:   custom allocator support for endpoint entry
//
//  Notes:      requires holding gComLock before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
void CEndpointEntry::operator delete(void *p)
{
    ComDebOut((DEB_CHANNEL, "CENdpointEntry:: delete operator\n"));

    ASSERT_LOCK_HELD(gComLock);

    CEndpointsTable::_palloc.ReleaseEntry((PageEntry*)p);
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::FindEntry
//
//  Synopsis:   finds endpoint in table if present
//
//  Notes:      requires gComLock to be held before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry * CEndpointsTable::FindEntry(unsigned short wTowerId)
{
    ComDebOut((DEB_CHANNEL, "CEndpointsTable:: find entry\n"));

    ASSERT_LOCK_HELD(gComLock);

    if (!wTowerId)
        return NULL;

    // iterate through list looking for entry
    ULONG_PTR nIterator  = gEndpointsTable.GetIterator();

    // search table looking for endpoint
    while (nIterator)
    {
        CEndpointEntry *pEntry = gEndpointsTable.GetNextEntry(nIterator);
        if (pEntry && (pEntry -> m_wTowerId == wTowerId))
            return pEntry;
    }
    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   wCoRegisterComBinding
//
//  Synopsis:   worker function to register an endpoint in the endpoint table.
//
//  Notes:              When registering endpoints via this API, COM will ignore
//                              AppID registry specified endpoints.
//
//              requires gComLock held
//
//  History:    20-Feb-1997     Ronans  Created
//
//--------------------------------------------------------------------
HRESULT wCoRegisterComBinding(WCHAR * pszProtseqEP, WCHAR* pszEndpoint, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    USHORT wTmpTowerId;

    ComDebOut((DEB_CHANNEL, "wCoRegisterProtSeqEp([%ws],[%ws],[%ld]\n", pszProtseqEP, pszEndpoint,dwFlags));

    wTmpTowerId = utGetTowerId(pszProtseqEP );

    // check if its a valid tower id
    if (!wTmpTowerId )
    {
        ComDebOut((DEB_ERROR, "wCoRegisterProtSeqEp - can't find tower id for (%ws)\n", pszProtseqEP));
        return E_INVALIDARG;
    }

    // check lock before accessing global table
    ASSERT_LOCK_HELD(gComLock);

        // check if we can still register endpoints
    if (!sfEndpointsProcessed)
    {
        CEndpointEntry *pEntry = gEndpointsTable.AddEntry(wTmpTowerId, pszEndpoint, dwFlags);

        // check that entry was allocated
        if (!pEntry)
        {
            ComDebOut((DEB_ERROR, "CoRegisterProtSeqEp - out of memory allocating entry\n"));
            hr = E_OUTOFMEMORY;
        }

        // set flag to indicate endpoints have been added
        sfProgrammaticEndpoints = TRUE;
    }
    else
    {
        ComDebOut((DEB_ERROR, "CoRegisterProtSeqEp - function called after DCOM resolver initialized\n"));
        hr = E_UNEXPECTED;
    }

    return hr;
}

static HRESULT wReadProtseqsForAppid(HKEY hkAppID);


//+-------------------------------------------------------------------
//
//  Function:   wGetEndpointsForApp, internal
//
//  Synopsis:   Get the endpoints for the current app.  First,
//              look under the app id for the current exe name.  If that
//              fails return default endpoints  .
//
//  Notes:              requires gComLock to be held before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
HRESULT wGetEndpointsForApp( GUID* pAppID)
{
    // Holds either Appid\{guid} or Appid\module_name.
    WCHAR   aKeyName[MAX_PATH+7];
    HRESULT hr = S_OK;
    LONG lErr;
    HKEY    hKey  = NULL;

    ASSERT_LOCK_HELD(gComLock);

    // ensure its not too late to process endpoints
    Win4Assert(!sfEndpointsProcessed);

    if (sfEndpointsProcessed)
    {
        ComDebOut((DEB_ERROR, "wGetEndpointsForApp - shouldn't be called twice"));
        return E_UNEXPECTED;
    }

    lstrcpyW( aKeyName, L"AppID\\" );
    int nOffset = lstrlenW(aKeyName);

    // If pAppId is not null - it contains a pointer to the AppId GUID
    if (pAppID != NULL)
    {
        if (StringFromIID2( *pAppID, &aKeyName[nOffset], sizeof(aKeyName) - nOffset ) != 0)
            hr = S_OK;
        else
        {
            ComDebOut((DEB_ERROR, "wGetEndpointsForApp - error converting IID to string\n"));
            return E_UNEXPECTED;
        }
    }
    else
    {
        // Look up the app id from the exe name.
        hr = utGetAppIdForModule(&aKeyName[nOffset], (MAX_PATH + 7) - nOffset);
    }


    if (SUCCEEDED(hr))
    {
        lErr = RegOpenKeyEx( HKEY_CLASSES_ROOT, aKeyName, NULL, KEY_READ, &hKey );

        // Get the endpoints from the registry.
        if (lErr == ERROR_SUCCESS)
        {
            ComDebOut((DEB_CHANNEL, "wGetEndpointsForApp - opened appid [%ws]\n", aKeyName));
            hr = wReadProtseqsForAppid( hKey);
            RegCloseKey(hKey);
        }
        else
        {
            ComDebOut((DEB_ERROR, "wGetEndpointsForApp - can't open AppID key for %ws\n", aKeyName));
            hr = E_FAIL;    // indicate normal failure
        }
    }

    return hr;
}



const WCHAR szEndpointText[] = L"Endpoint";
const int lenEndpoint = (sizeof(szEndpointText) / sizeof(TCHAR)) -1;

//+-------------------------------------------------------------------
//
//  Function:   wStrtok
//
//  Synopsis:   local implementation of wcstok - needed as wcstok is not in
//              libraries for standard build
//
//  Notes:              not threadsafe
//
//  History:    20-Feb-1997     Ronans  Created
//
//--------------------------------------------------------------------
static WCHAR * wStrtok(WCHAR * lpszStr, WCHAR * lpszDelim)
{
    static WCHAR *lpszLastStr = NULL;
    WCHAR * lpszRetval = NULL;

    int nLenDelim = lstrlenW(lpszDelim);
    int index;

    // save string to search if necessary
    if (lpszStr)
        lpszLastStr = lpszStr;

    // return NULL string if necessary
    if (!lpszLastStr || !*lpszLastStr)
    {
        return NULL;
    }

    // skip initial delimiters
    while (*lpszLastStr)
    {
        for (index = 0; (index < nLenDelim) && (*lpszLastStr != lpszDelim[index]); index++);
            // do nothing

        if (index < nLenDelim)
             lpszLastStr++;
        else
            break;
    }

    // skip non-delimiter characters
    if (*lpszLastStr)
    {
        lpszRetval = lpszLastStr;

        while (*lpszLastStr)
        {
            for (index = 0;
                (index < nLenDelim) && (*lpszLastStr != lpszDelim[index]);
                index++);
                // do nothing

            if (index == nLenDelim)
                 lpszLastStr++;
            else
            {
                *lpszLastStr++ = NULL;
                break;
            }
        }
    }
    else
        lpszLastStr = NULL;

    return lpszRetval;
}

//+-------------------------------------------------------------------
//
//  Function:   wReadProtseqForAppID
//
//  Synopsis:   read endpoints from registry for particular appid
//                              and add them to the endpoint table
//
//  Notes:              requires gComLock to be held before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
static HRESULT wReadProtseqsForAppid(HKEY hkAppID)
{
    HRESULT hr = S_OK;
    DWORD dwType = REG_MULTI_SZ;
    DWORD dwcbBuffer = 1024;
    WCHAR* pszBuffer;

    ComDebOut((DEB_CHANNEL,
                "wReadProtseqsForApp -  reading endpoints from the registry\n"));

    ASSERT_LOCK_HELD(gComLock);

    // read DCOM endpoint data from the registry
    Win4Assert(hkAppID != 0);


    if (!(pszBuffer = new WCHAR[1024]))
    {
        ComDebOut((DEB_ERROR,
                    "wReadProtseqsForApp -  could'nt allocate buffer for endpoints\n"));
        return E_OUTOFMEMORY;
    }

    // try to read values into default sized buffer
    LONG lErr = RegQueryValueExW(hkAppID,
                        L"Endpoints",
                        0,
                        &dwType,
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);

    // if buffer is not big enough, extend it and reread
    if (lErr == ERROR_MORE_DATA)
    {
        delete  pszBuffer;
        DWORD dwNewSize = (dwcbBuffer + 1 / sizeof(TCHAR));
        pszBuffer = new WCHAR[dwNewSize];
        if (pszBuffer)
            dwcbBuffer = dwNewSize;
        else
        {
            ComDebOut((DEB_ERROR,
                        "wReadProtseqsForApp -  could'nt allocate buffer for endpoints\n"));
            return E_OUTOFMEMORY;
        }


        lErr = RegQueryValueExW(hkAppID,
                        L"Endpoints",
                        0,
                        &dwType,
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);
    }

    // if we have read the Endpoints value successfully
    if ((lErr == ERROR_SUCCESS) &&
        (dwcbBuffer > 0) &&
        (dwType == REG_MULTI_SZ))
    {
        // parse each string
        WCHAR * lpszRegEntry = pszBuffer;

        while(*lpszRegEntry)
        {
            // caclulate length of entry
            int nLenEntry = lstrlenW(lpszRegEntry);

            // ok its a valid endpoint so parse it
            WCHAR* pszProtseq = NULL;
            WCHAR* pszEndpointData = NULL;
            WCHAR* pszTmpDynamic = NULL;
            DWORD dwFlags;

            pszProtseq = wStrtok(lpszRegEntry, L", ");

            pszTmpDynamic = wStrtok(NULL, L", ");
            if (pszTmpDynamic == NULL)
                dwFlags = 0;
            else
                dwFlags = (DWORD) _wtol(pszTmpDynamic);

            pszEndpointData = wStrtok(NULL, L", ");

            // at this point we should have the protseq, endpoint and flags
            // .. so add the entry

            // ignore result as we will continue even if one fails
            wCoRegisterComBinding(pszProtseq, pszEndpointData, dwFlags);
            lpszRegEntry += nLenEntry + 1;
        }
    }
    else if ((lErr != ERROR_SUCCESS) && (lErr != ERROR_FILE_NOT_FOUND))
    {
        ComDebOut((DEB_ERROR, "wReadProtseqsForApp -  invalid registry entry\n" ));
    }

    delete pszBuffer;

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   wGetFinalEndpointTable
//
//  Synopsis:   checks if endpoints have been added programmatically
//              if not read them from the registry. This will be called by
//              the COM server when it needs to determine whether to negotiate
//              specific endpoints for the application or use the COM default
//              endpoints.
//
//  Notes:      Requires gComLock to be held before calling
//
//  History:    20-Jan-97       Ronans       Created
//
//--------------------------------------------------------------------
static HRESULT wGetFinalEndpointTable()
{
    ComDebOut((DEB_CHANNEL, "wGetFinalEndpointTable\n"));
    ASSERT_LOCK_HELD(gComLock);

    HRESULT hr = S_OK;

    // if endpoints have not been added programmatically
    if (!sfProgrammaticEndpoints)
    {
        // ... then get them
        GUID * pAppID = NULL;

        // locate AppID
        hr = wGetEndpointsForApp(pAppID);

        // E_FAIL indicates no endpoints so mark the endpoints as processed in this
        // case also.
        if (SUCCEEDED(hr) || (hr == E_FAIL))
            sfEndpointsProcessed = TRUE;
    }
    else
        sfEndpointsProcessed = TRUE;

    return ((SUCCEEDED(hr) || (hr == E_FAIL)) ? S_OK : hr);
}

//+-------------------------------------------------------------------
//
//  Function:   IsAllowableProtseq
//
//  Synopsis:   Check a towerId against the list of machine protseqs
//
//  History:    20-Jan-97       Ronans       Created
//
//--------------------------------------------------------------------
BOOL IsAllowableProtseq(unsigned short wTowerId, unsigned short cMyProtseqs,
                        unsigned short aMyProtseqs[])
{
    for (int i = 0; i < cMyProtseqs; i++)
    {
        if (wTowerId == aMyProtseqs[i])
            return TRUE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Function:   GetCustomProtseqInfo
//
//  Synopsis:   Get a list of the custom specified protocol sequences and
//              return them in a DUALSTRINGARRAY.
//
//  Notes:      Exported as part of RPC interface to be called by
//              DCOMSS during ResolveOXID
//              Takes gComLock during processing
//
//  History:    20-Jan-97       Ronans       Created
//
//--------------------------------------------------------------------
error_status_t _GetCustomProtseqInfo( handle_t hRpc,
                            unsigned short cMachineProtseqs,
                            unsigned short aMachineProtseqs[  ],
                            DUALSTRINGARRAY **pdsaCustomProtseqs)
{
    ComDebOut((DEB_CHANNEL, "_GetCustomProtseqInfo ==> \n"));

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    // force endpoint table to be parsed.
    HRESULT hr = S_OK;

    // should only be called once - however could happen
    if (!sfEndpointsProcessed)
        hr = wGetFinalEndpointTable();
    else
    {
        ComDebOut((DEB_ERROR, "Warning - _GetCustomProtseqInfo called twice for same process\n"));
        ComDebOut((DEB_ERROR, "Warning - Possible race condition in UseProtseqIfNeeded\n"));
    }

    int nItems = 0;

    // build up custom protseqinfo as compressed dual string array
    // process table.
    DUALSTRINGARRAY* pdsaResults = NULL;
    unsigned short nSize = 3; // entries for nulls
    ULONG_PTR nIterator  = gEndpointsTable.GetIterator();

    // calculate length needed for overall DUALSTRINGARRAY string
    while (nIterator)
    {
        // for each entry - check if its available in the machine protseqs
        CEndpointEntry *pData = gEndpointsTable.GetNextEntry(nIterator);

        if (pData && IsAllowableProtseq(pData -> m_wTowerId, cMachineProtseqs, aMachineProtseqs))
        {
            nItems ++;
            nSize += 2; // size of wTowerid and sizeof null

            // add size of endpoint data also
            if (pData -> m_pszEndpoint)
                    nSize += (USHORT) lstrlenW(pData -> m_pszEndpoint);
        }
    }

    // build DSA from results
    if (nItems)
    {
        pdsaResults = (DUALSTRINGARRAY*)
                        MIDL_user_allocate( sizeof(DUALSTRINGARRAY) +
                                            nSize*sizeof(WCHAR) );
        nIterator   = gEndpointsTable.GetIterator();

        ASSERT(nIterator != NULL);

        if (pdsaResults)
        {
            // copy strings
            LPWSTR pszNext = pdsaResults -> aStringArray;

            while (nIterator)
            {
                CEndpointEntry *pData = gEndpointsTable.GetNextEntry(nIterator);

                    if (pData &&
                    IsAllowableProtseq(pData -> m_wTowerId, cMachineProtseqs, aMachineProtseqs))
                {
                    // first part of string is tower id for compressed strings
                    *pszNext++ = (WCHAR) pData -> m_wTowerId;
                    if (pData -> m_pszEndpoint)
                    {
                        lstrcpyW( pszNext, pData -> m_pszEndpoint);
                        pszNext += lstrlenW(pszNext) + 1;
                    }
                    else
                        *pszNext++ = (WCHAR)0;
                    }
            }

            // Add a second null to terminate the string binding
            // set.

            pszNext[0] = 0;

            // set blank security info
            pszNext[1] = 0;
            pszNext[2] = 0;

            // Fill in the size fields.
            pdsaResults->wSecurityOffset = nSize - 2;
            pdsaResults->wNumEntries = nSize;
            *pdsaCustomProtseqs = pdsaResults;
        }
        else
        {
            ComDebOut(( DEB_ERROR, "Failed to allocate memory for compressed string array\n"));
            hr = E_OUTOFMEMORY;
        }
    }
    else
        *pdsaCustomProtseqs = NULL;

    ASSERT_LOCK_HELD(gComLock);
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    ComDebOut((DEB_CHANNEL, "_GetCustomProtseqInfo <== [0x%lx] returning S_OK\n", hr));

    // always return S_OK as any errors will not be fixed by retrying (except for E_OUTOFMEMORY)
    return ((hr == E_OUTOFMEMORY) ? E_OUTOFMEMORY : S_OK);
}

//+-------------------------------------------------------------------
//
//  Function:   _UpdateResolverBindings
//
//  Synopsis:   Updates the process-wide resolver bindings.
//
//  Notes:      Exported as part of RPC interface to be called by
//              RPCSS when resolver bindings change and someone has
//              requested dynamic updates of same to running processes.
//
//  History:    09-Oct-00       Jsimmons    Created
//
//--------------------------------------------------------------------
error_status_t _UpdateResolverBindings( 
                    RPC_ASYNC_STATE* pAsync,
                    handle_t hRpc,
                    DUALSTRINGARRAY* pdsaResolverBindings,
                    DWORD64* pdwBindingsID,
                    DUALSTRINGARRAY **ppdsaNewBindings,
                    DUALSTRINGARRAY **ppdsaNewSecurity)     
{
    ComDebOut((DEB_CHANNEL, "_UpdateResolverBindings ==> \n"));

    HRESULT hr = RPC_E_ACCESS_DENIED;
    RPC_STATUS status = RPC_E_ACCESS_DENIED;

    // Parameter validation
    if (!pAsync ||
        !hRpc ||
        !pdsaResolverBindings ||
        !pdwBindingsID ||
        !ppdsaNewBindings ||
        !ppdsaNewSecurity)
    {
        // just fall thru
    }
    else
    {
        // Security check
        if(IsCallerLocalSystem(hRpc))
        {
            hr = IUpdateResolverBindings(*pdwBindingsID,
                            pdsaResolverBindings,
                            ppdsaNewBindings,
                            ppdsaNewSecurity);          
        }
    }

    // Need to complete the call regardless of outcome
    status = RpcAsyncCompleteCall(pAsync, &hr);

    ComDebOut((DEB_CHANNEL, "_UpdateResolverBindings <== returning 0x%8x\n", hr));

    return status;
}

//+-------------------------------------------------------------------
//
//  Function:   IUpdateResolverBindings
//
//  Synopsis:   Updates the process-wide resolver bindings.
//
//  Notes:      Helper function for updating the process-wide resolver
//              bindings.
//
//              Right now I am holding gComLock across this function; not
//              sure if it is needed, but this is not a high-perf code
//              path so I don't think it can hurt.
//
//  History:    09-Oct-00       Jsimmons    Created
//
//--------------------------------------------------------------------
HRESULT IUpdateResolverBindings(
                    DWORD64 dwBindingsID,   
                    DUALSTRINGARRAY* pdsaResolverBindings,
                    DUALSTRINGARRAY **ppdsaNewBindings,
                    DUALSTRINGARRAY **ppdsaNewSecurity
                    )
{
    HRESULT hr;

    // Check apcompat info
    if (DisallowDynamicORBindingChanges())
    {
        // this process does not want to recognize dynamic changes
        // in the resolver bindings.   So don't do it.
        hr = S_OK;

        // We can get called directly from the resolver after a call to
        // ServerAllocateOxidAndOids, when this occurs ppdsaNewBindings
        // and ppdsaNewSecurity will be null.
        if (ppdsaNewBindings && ppdsaNewSecurity)
        {
            hr = CopyStringArray(gpsaCurrentProcess, NULL, ppdsaNewBindings);
            if (SUCCEEDED(hr))
            {
                hr = CopyStringArray(gpsaSecurity, NULL, ppdsaNewSecurity);
            }
        }
        return hr;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    DUALSTRINGARRAY* pdsaLocalCopyResolverBindings = NULL;

    // Make copy of incoming bindings.   
    hr = CopyDualStringArray(pdsaResolverBindings, &pdsaLocalCopyResolverBindings);
    if (SUCCEEDED(hr))
    {        
        CDualStringArray* pdsaResolver = new CDualStringArray(pdsaLocalCopyResolverBindings);
        if (pdsaResolver)
        {
            // Change cached resolver bindings.  The pdsaResolver object now owns
            // the pdsaResolver bindings.  SetLocalResolverBindings may fail if
            // we are trying update using older bindings
            hr = gResolver.SetLocalResolverBindings(dwBindingsID, pdsaResolver);
            if (SUCCEEDED(hr))
            {
                // Change cached local midentry
                hr = gMIDTbl.ReplaceLocalEntry(pdsaResolverBindings);
                if (SUCCEEDED(hr))
                {
                    ASSERT_LOCK_NOT_HELD(gOXIDLock);
                    hr = gOXIDTbl.UpdateCachedLocalMIDEntries();
                    ASSERT_LOCK_NOT_HELD(gOXIDLock);

                    if (SUCCEEDED(hr) &&
                        ppdsaNewBindings && 
                        ppdsaNewSecurity)
                    {
                        // Generate binding copies to return.
                        hr = CopyStringArray(gpsaCurrentProcess, NULL, ppdsaNewBindings);
                        if (SUCCEEDED(hr))
                        {
                            hr = CopyStringArray(gpsaSecurity, NULL, ppdsaNewSecurity);
                        }
                    }
                }
            }
            pdsaResolver->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            // free the copy made above
            delete pdsaLocalCopyResolverBindings;
        }
    }

    ASSERT_LOCK_HELD(gComLock);
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\riftbl.cxx ===
//+------------------------------------------------------------------------
//
//  File:       riftbl.cxx
//
//  Contents:   RIF (Registered Interfaces) Table.
//
//  Classes:    CRIFTable
//
//  History:    12-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
#include <ole2int.h>
#include <riftbl.hxx>       // class definition
#include <locks.hxx>        // LOCK/UNLOCK
#include <channelb.hxx>     // ThreadInvoke
#include <objsrv.h>
#include <sxstypes.h>


// number of Registered Interface Entries per allocator page
#define RIFS_PER_PAGE   32


// Table of system interfaces used to prefill the RIFTable with known IIDs.
// We dont want anyone to try to override our implementations of these.

extern "C" const IID IID_IDLLHost;
extern "C" const IID IID_ILocalSystemActivator;
extern "C" const IID IID_ISystemActivator;
extern "C" const IID IID_IISCMLocalActivator;
extern "C" const IID IID_IInterfaceFromWindowProp;
extern "C" const IID IID_IRemoteQI;

const IID *gKnownSystemIIDs[] = {
                           &IID_IRemUnknown,
                           &IID_IRemUnknown2,
                           &IID_IRundown,
                           &IID_IDLLHost,
                           &IID_ILocalSystemActivator,
                           &IID_ISystemActivator,
                           &IID_ISCMLocalActivator,
#ifdef SERVER_HANDLER
                           &IID_IServerHandler,
                           &IID_IClientSiteHandler,
#endif // SERVER_HANDLER
                           &IID_IClassFactory,
                           &IID_IInterfaceFromWindowProp,
                           &IID_IRemoteQI,
                           NULL};

const CLSID *gKnownSystemCLSIDs[] = {
                           &CLSID_RemoteUnknownPSFactory,
                           &CLSID_RemoteUnknownPSFactory,
                           &CLSID_RemoteUnknownPSFactory,
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
#ifdef SERVER_HANDLER
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
#endif // SERVER_HANDLER
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
                           NULL};



// global RIF table
CRIFTable gRIFTbl;
BOOL               CRIFTable::_fPreFilled = FALSE; // table not pre-filled
CUUIDHashTable     CRIFTable::_HashTbl;      // interface lookup hash table
CPageAllocator     CRIFTable::_palloc;       // page allocator
COleStaticMutexSem CRIFTable::_mxs;          // critical section


//+------------------------------------------------------------------------
//
//  Vector Table: All calls on registered interfaces are dispatched through
//  this table to ThreadInvoke, which subsequently dispatches to the
//  appropriate interface stub. All calls on COM interfaces are dispatched
//  on method #0 so the table only needs to be 1 entry long.
//
//+------------------------------------------------------------------------
const RPC_DISPATCH_FUNCTION vector[] =
{
    (void (_stdcall *) (struct  ::_RPC_MESSAGE *)) ThreadInvoke,
};

const RPC_DISPATCH_TABLE gDispatchTable =
{
    sizeof(vector)/sizeof(RPC_DISPATCH_FUNCTION),
    (RPC_DISPATCH_FUNCTION *)&vector, 0
};


//+------------------------------------------------------------------------
//
//  Interface Templates. When we register an interface with the RPC runtime,
//  we allocate an structure, copy one of these templates in (depending on
//  whether we want client side or server side) and then set the interface
//  IID to the interface being registered.
//
//  We hand-register the RemUnknown interface because we normally marshal its
//  derived verion (IRundown), yet expect calls on IRemUnknown.
//
//+------------------------------------------------------------------------

// NOTE: For 64-bit COM, we support non-NDR transfer syntaxes. In this
// case, we get RPC_SERVER_INERFACE directly from the RPC NDR engine
// and will not use the fake gServerIf struct below on the server 
// side - Sajia

// NOTE - Updating RPC_SERVER_INTERFACE to reflect the current 
// version of the struct-Sajia

extern const RPC_SERVER_INTERFACE gServerIf =
{
   sizeof(RPC_SERVER_INTERFACE),
   {0x69C09EA0, 0x4A09, 0x101B, 0xAE, 0x4B, 0x08, 0x00, 0x2B, 0x34, 0x9A, 0x02,
    {0, 0}},
   {0x8A885D04, 0x1CEB, 0x11C9, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60,
    {2, 0}},
   (RPC_DISPATCH_TABLE *)&gDispatchTable, 0, 0, 0, 0, 0
};

// NOTE: For 64-bit COM, we support non-NDR transfer syntaxes. In this
// case, we get RPC_CLIENT_INERFACE directly from the RPC NDR engine
// and will not use the fake gClientIf struct below on the client 
// side - Sajia

// NOTE - Updating RPC_CLIENT_INTERFACE to reflect the current 
// version of the struct-Sajia

const RPC_CLIENT_INTERFACE gClientIf =
{
   sizeof(RPC_CLIENT_INTERFACE),
   {0x69C09EA0, 0x4A09, 0x101B, 0xAE, 0x4B, 0x08, 0x00, 0x2B, 0x34, 0x9A, 0x02,
    {0, 0}},
   {0x8A885D04, 0x1CEB, 0x11C9, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60,
    {2, 0}},
   0, 0, 0, 0, 0, 0
};

const RPC_SERVER_INTERFACE gRemUnknownIf =
{
   sizeof(RPC_SERVER_INTERFACE),
   {0x00000131, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
    {0, 0}},
   {0x8A885D04, 0x1CEB, 0x11C9, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60,
    {2, 0}},
   (RPC_DISPATCH_TABLE *)&gDispatchTable, 0, 0, 0
};

const RPC_SERVER_INTERFACE gRemUnknownIf2 =
{
   sizeof(RPC_SERVER_INTERFACE),
   {0x00000143, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
    {0, 0}},
   {0x8A885D04, 0x1CEB, 0x11C9, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60,
    {2, 0}},
   (RPC_DISPATCH_TABLE *)&gDispatchTable, 0, 0, 0
};


//+------------------------------------------------------------------------
//
//  Registered Interface hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain RIFBuckets[23] =
{
    {&RIFBuckets[0],  &RIFBuckets[0]},
    {&RIFBuckets[1],  &RIFBuckets[1]},
    {&RIFBuckets[2],  &RIFBuckets[2]},
    {&RIFBuckets[3],  &RIFBuckets[3]},
    {&RIFBuckets[4],  &RIFBuckets[4]},
    {&RIFBuckets[5],  &RIFBuckets[5]},
    {&RIFBuckets[6],  &RIFBuckets[6]},
    {&RIFBuckets[7],  &RIFBuckets[7]},
    {&RIFBuckets[8],  &RIFBuckets[8]},
    {&RIFBuckets[9],  &RIFBuckets[9]},
    {&RIFBuckets[10], &RIFBuckets[10]},
    {&RIFBuckets[11], &RIFBuckets[11]},
    {&RIFBuckets[12], &RIFBuckets[12]},
    {&RIFBuckets[13], &RIFBuckets[13]},
    {&RIFBuckets[14], &RIFBuckets[14]},
    {&RIFBuckets[15], &RIFBuckets[15]},
    {&RIFBuckets[16], &RIFBuckets[16]},
    {&RIFBuckets[17], &RIFBuckets[17]},
    {&RIFBuckets[18], &RIFBuckets[18]},
    {&RIFBuckets[19], &RIFBuckets[19]},
    {&RIFBuckets[20], &RIFBuckets[20]},
    {&RIFBuckets[21], &RIFBuckets[21]},
    {&RIFBuckets[22], &RIFBuckets[22]}
};


//+-------------------------------------------------------------------
//
//  Function:   CleanupRIFEntry
//
//  Synopsis:   Call the RIFTable to cleanup an entry. This is called
//              by the hash table cleanup code.
//
//  History:    12-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CleanupRIFEntry(SHashChain *pNode)
{
    gRIFTbl.UnRegisterInterface((RIFEntry *)pNode);
}

//+------------------------------------------------------------------------
//
//  Member:     CRIFTable::Initialize, public
//
//  Synopsis:   Initialize the Registered Interface Table
//
//  History:    12-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CRIFTable::Initialize()
{
    ComDebOut((DEB_CHANNEL, "CRIFTable::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    _fPreFilled = FALSE;
    _HashTbl.Initialize(RIFBuckets, &_mxs);
    _palloc.Initialize(sizeof(RIFEntry), RIFS_PER_PAGE, NULL);
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+------------------------------------------------------------------------
//
//  Member:     CRIFTable::Cleanup, public
//
//  Synopsis:   Cleanup the Registered Interface Table.
//
//  History:    12-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CRIFTable::Cleanup()
{
    ComDebOut((DEB_CHANNEL, "CRIFTable::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    _HashTbl.Cleanup(CleanupRIFEntry);
    _palloc.Cleanup();
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::GetClientInterfaceInfo, public
//
//  Synopsis:   returns the interface info for a given interface
//
//  History:    12-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
RPC_CLIENT_INTERFACE *CRIFTable::GetClientInterfaceInfo(REFIID riid)
{
	RPC_CLIENT_INTERFACE *ret = NULL;

    DWORD iHash = _HashTbl.Hash(riid);
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    RIFEntry *pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);
    Win4Assert(pRIFEntry);      // must already be registered
	if (pRIFEntry)
	{
		Win4Assert(pRIFEntry->pCliInterface);
		ret = pRIFEntry->pCliInterface;
	}
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);

    return ret;
}
//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::GetServerInterfaceInfo, public
//
//  Synopsis:   returns the interface info for a given interface
//
//  History:    27-Apr-97    MattSmit  Created
//
//--------------------------------------------------------------------
RPC_SERVER_INTERFACE *CRIFTable::GetServerInterfaceInfo(REFIID riid)
{
	RPC_SERVER_INTERFACE *ret = NULL;
    DWORD iHash;

    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    
	iHash = _HashTbl.Hash(riid);
	
    RIFEntry *pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);
    Win4Assert(pRIFEntry);      // must already be registered
	if (pRIFEntry)
	{
		Win4Assert(pRIFEntry->pSrvInterface);
		ret = pRIFEntry->pSrvInterface;
	}
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);

    return ret;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterInterface, public
//
//  Synopsis:   returns the proxy stub clsid of the specified interface,
//              and adds an entry to the registered interface hash table
//              if needed.
//
//  History:    12-Feb-96   Rickhi      Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//--------------------------------------------------------------------
#ifdef _WIN64
HRESULT CRIFTable::RegisterInterface(REFIID riid, BOOL fServer, IRpcStubBuffer *pStub, 
				     RIFEntry *pRIFEntry)
#else
HRESULT CRIFTable::RegisterInterface(REFIID riid, BOOL fServer, CLSID *pClsid)
#endif				     
{
#ifdef _WIN64
    Win4Assert ((!fServer && !pStub) || (fServer && pStub));
    Win4Assert(pRIFEntry);
#endif				     
    ComDebOut((DEB_CHANNEL, "CRIFTable::RegisterInterface riid:%I\n", &riid));
    ASSERT_LOCK_NOT_HELD(_mxs);
    HRESULT hr = E_INVALIDARG;
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    
#ifndef _WIN64
    // look for the interface in the table.
    RIFEntry *pRIFEntry;
    hr = GetPSClsidHelper(riid, pClsid, &pRIFEntry);
#endif				     
    if (pRIFEntry)
    {
#ifdef _WIN64
        hr = S_OK;
#endif				     
	// found it, look to ensure either server or client side is
        // registered.
        if (fServer)
        {
            if (pRIFEntry->pSrvInterface == NULL)
            {
                // server side not yet registered, go register it
#ifdef _WIN64
                hr = RegisterServerInterface(pRIFEntry, riid, pStub);
#else
                hr = RegisterServerInterface(pRIFEntry, riid);
#endif
            }
        }
        else if (pRIFEntry->pCliInterface == NULL)
        {
            // client side not yet registered, go register it
            hr = RegisterClientInterface(pRIFEntry, riid);
        }
    }

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
#ifndef _WIN64
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::RegisterInterface hr:%x clsid:%I\n", hr, pClsid));
#endif    
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterClientInterface, private
//
//  Synopsis:   Register with the RPC runtime a client RPC interface
//              structure for the given IID. The IID must not already
//              be registered.
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::RegisterClientInterface(RIFEntry *pRIFEntry, REFIID riid)
{
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::RegisterClientInterface pRIFEntry:%x\n", pRIFEntry));
    Win4Assert(pRIFEntry->pCliInterface == NULL);
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = E_OUTOFMEMORY;
    pRIFEntry->pCliInterface = (RPC_CLIENT_INTERFACE *)
                             PrivMemAlloc(sizeof(RPC_CLIENT_INTERFACE));

    if (pRIFEntry->pCliInterface != NULL)
    {
        memcpy(pRIFEntry->pCliInterface, &gClientIf, sizeof(gClientIf));
        pRIFEntry->pCliInterface->InterfaceId.SyntaxGUID = riid;
        hr = S_OK;
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterServerInterface, private
//
//  Synopsis:   Register with the RPC runtime a server RPC interface
//              structure for the given IID. The IID must not already
//              be registered
//
//  History:    12-Feb-96   Rickhi      Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//
//--------------------------------------------------------------------
#ifdef _WIN64
HRESULT CRIFTable::RegisterServerInterface(RIFEntry *pRIFEntry, REFIID riid, IRpcStubBuffer *pStub)
#else
HRESULT CRIFTable::RegisterServerInterface(RIFEntry *pRIFEntry, REFIID riid)
#endif
{
    RPC_STATUS sc;
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::RegisterServerInterface pRIFEntry:%x\n", pRIFEntry));
    Win4Assert(pRIFEntry->pSrvInterface == NULL);
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = E_OUTOFMEMORY;
    pRIFEntry->pSrvInterface = (RPC_SERVER_INTERFACE *)
                               PrivMemAlloc(sizeof(RPC_SERVER_INTERFACE));

    if (pRIFEntry->pSrvInterface != NULL)
    {
        hr = S_OK;
        memcpy(pRIFEntry->pSrvInterface, &gServerIf, sizeof(gServerIf));
        pRIFEntry->pSrvInterface->InterfaceId.SyntaxGUID = riid;
#ifdef _WIN64
	sc = NdrCreateServerInterfaceFromStub (pStub, pRIFEntry->pSrvInterface);
        if (sc != RPC_S_OK)
        {
            ComDebOut((DEB_ERROR,
                "NdrCreateServerInterfaceFromStub %I failed:0x%x.\n", &riid, sc));

            PrivMemFree(pRIFEntry->pSrvInterface);
            pRIFEntry->pSrvInterface = NULL;
            hr = HRESULT_FROM_WIN32(sc);
	    return hr;
        }
	pRIFEntry->pSrvInterface->DispatchTable=(RPC_DISPATCH_TABLE *)&gDispatchTable;
#endif	
        sc = RpcServerRegisterIf2(pRIFEntry->pSrvInterface, NULL,
                                              NULL,
                                              RPC_IF_AUTOLISTEN | RPC_IF_OLE,
                                              0xffff, (unsigned int)-1, NULL);
        if (sc != RPC_S_OK)
        {
            ComDebOut((DEB_ERROR,
                "RegisterServerInterface %I failed:0x%x.\n", &riid, sc));

            PrivMemFree(pRIFEntry->pSrvInterface);
            pRIFEntry->pSrvInterface = NULL;
            hr = HRESULT_FROM_WIN32(sc);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::UnRegisterInterface
//
//  Synopsis:   UnRegister with the RPC runtime a server RPC interface
//              structure for the given IID. This is called by
//              CUUIDHashTable::Cleanup during CoUninitialize. Also
//              delete the interface structures.
//
//  History:    12-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CRIFTable::UnRegisterInterface(RIFEntry *pRIFEntry)
{
    if (pRIFEntry->pSrvInterface)
    {
        // server side entry exists, unregister the interface with RPC.
        // Note that this can result in calls being dispatched so we
        // have to release the lock around the call.

        ASSERT_LOCK_HELD(_mxs);
        UNLOCK(_mxs);
        ASSERT_LOCK_NOT_HELD(_mxs);

        // Get the status, but we don't really care.
        RPC_STATUS st = RpcServerUnregisterIf(pRIFEntry->pSrvInterface, 0, 1);

        ASSERT_LOCK_NOT_HELD(_mxs);
        LOCK(_mxs);
        ASSERT_LOCK_HELD(_mxs);

        PrivMemFree(pRIFEntry->pSrvInterface);
        pRIFEntry->pSrvInterface = NULL;
    }

    PrivMemFree(pRIFEntry->pCliInterface);

    _palloc.ReleaseEntry((PageEntry *)pRIFEntry);
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::GetPSClsidHelper, internal
//
//  Synopsis:   Finds the RIFEntry in the table for the given riid, and
//              adds an entry if one is not found. Called by CoGetPSClsid
//              and by CRIFTable::RegisterInterface.
//
//  Notes:      This takes the critical section and calls a common helper
//              function.
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::GetPSClsid(REFIID riid, CLSID *pclsid, RIFEntry **ppEntry)
{
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::GetPSClsid riid:%I pclsid:%x\n", &riid, pclsid));

    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = GetPSClsidHelper(riid, pclsid, ppEntry);

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::GetPSClsidHelper, internal
//
//  Synopsis:   Finds the RIFEntry in the table for the given riid, and
//              adds an entry if one is not found. Called by CoGetPSClsid
//              and by CRIFTable::RegisterInterface.
//
//  Notes:      This assumes the caller is holding the critical section
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::GetPSClsidHelper(REFIID riid, CLSID *pclsid, RIFEntry **ppEntry)
{
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::GetPSClsid riid:%I pclsid:%x\n", &riid, pclsid));
    ASSERT_LOCK_HELD(_mxs);
    HRESULT hr = S_OK;
    ACTCTX_SECTION_KEYED_DATA askd;
    GUID *pSxsProxyStubClsid32 = NULL;

    // look for the interface in the table.
    DWORD iHash = _HashTbl.Hash(riid);
    RIFEntry *pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);

    if (pRIFEntry == NULL)
    {
        // make sure the known IIDs are prefilled in the cache. We've
        // delayed adding them until this point in order to avoid
        // touching the pages until a request is actually issued.
        pRIFEntry = PreFillKnownIIDs(riid);
    }

    if (pRIFEntry == NULL || !(pRIFEntry->dwFlags & RIFFLG_HASCLSID))
    {
        // still no entry exists for this interface, add one. Dont
        // hold the lock over a call to the registry

        UNLOCK(_mxs);
        ASSERT_LOCK_NOT_HELD(_mxs);

        askd.cbSize = sizeof(askd);

        if (!::FindActCtxSectionGuid(
                    0,              // dwFlags
                    NULL,           // lpExtensionGuid
                    ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION,
                    &riid,
                    &askd))
        {
            const DWORD dwLastError = ::GetLastError();
            if ((dwLastError != ERROR_SXS_KEY_NOT_FOUND) &&
                (dwLastError != ERROR_SXS_SECTION_NOT_FOUND))
            {
                LOCK(_mxs);
                ASSERT_LOCK_HELD(_mxs);
                return HRESULT_FROM_WIN32(dwLastError);
            }
        }
        else
        {
            // Add additional cases here to deal with other data formats in the future.
            if (askd.ulDataFormatVersion == ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FORMAT_WHISTLER)
            {
                pSxsProxyStubClsid32 = &((PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION) askd.lpData)->ProxyStubClsid32;
            }
        }

        hr = wRegQueryPSClsid(riid, pclsid);

        if (SUCCEEDED(hr))
        {
            if (pSxsProxyStubClsid32 != NULL)
            {
                // Verify that they match; otherwise something very broken is going on.
                if ((*pclsid) != (*pSxsProxyStubClsid32))
                {
                    ComDebOut((DEB_CHANNEL, "OLE/SXS: ProxyStubClsid32 in manifest does not match interface's registered ProxyStubClsid32\n"));

                    LOCK(_mxs);
                    ASSERT_LOCK_HELD(_mxs);
                    return REGDB_E_INVALIDVALUE;
                }
            }
        }
        else if (hr == REGDB_E_IIDNOTREG)
        {
            if (pSxsProxyStubClsid32 != NULL)
            {
                *pclsid = *pSxsProxyStubClsid32;
                hr = NOERROR;
            }
        }

        ASSERT_LOCK_NOT_HELD(_mxs);
        LOCK(_mxs);
        ASSERT_LOCK_HELD(_mxs);

        // now that we are holding the lock again, do another lookup incase
        // some other thread came it while the lock was released.

        pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);
        if (pRIFEntry == NULL && SUCCEEDED(hr)) // <--- NOTE: do not change w/o 
        {                                       //      changing else if condition
            hr = AddEntry(*pclsid, riid, iHash, &pRIFEntry);
        }
        else if (SUCCEEDED(hr) && !(pRIFEntry->dwFlags & RIFFLG_HASCLSID))
        {
            // an entry was created, but the clsid has not
            // been filled in.
            pRIFEntry->psclsid = *pclsid;
            pRIFEntry->dwFlags |= RIFFLG_HASCLSID;
        }

    }
    else
    {
        // found an entry, return the clsid
        *pclsid = pRIFEntry->psclsid;
    }

    *ppEntry = pRIFEntry;

    ASSERT_LOCK_HELD(_mxs);
    ComDebOut((DEB_CHANNEL, "CRIFTable::RegisterPSClsid pRIFEntry:%x\n", pRIFEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::PreFillKnownIIDs, public
//
//  Synopsis:   PreFills the RIFTable with the known IID->PSCLSID mappings.
//              The known mappings are the ones that COM uses internally.
//              This saves registry lookups and prevents tampering with
//              the system interface stubs.
//
//  History:    22-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
RIFEntry *CRIFTable::PreFillKnownIIDs(REFIID riid)
{
    if (_fPreFilled)
    {
        return NULL;
    }

    RIFEntry *pRIFEntry = NULL;
    const IID *piid;
    int i=0;

    while ((piid = gKnownSystemIIDs[i++]) != NULL)
    {
        // add each mapping to the table
        RIFEntry *pRIFTmp;
        DWORD iHash = _HashTbl.Hash(*piid);
        if (SUCCEEDED(AddEntry(*gKnownSystemCLSIDs[i-1], *piid, iHash, &pRIFTmp)))
        {
            if (InlineIsEqualGUID(riid, *piid))
            {
                pRIFEntry = pRIFTmp;
            }
        }
    }

    // mark the table as pre-filled
    _fPreFilled = TRUE;
    return pRIFEntry;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterPSClsid, public
//
//  Synopsis:   Adds an entry to the table. Used by CoRegisterPSClsid
//              so that applications can add a temporary entry that only
//              affects the local process without having to muck with
//              the system registry.
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::RegisterPSClsid(REFIID riid, REFCLSID rclsid)
{
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::RegisterPSClsid rclsid:%I riid:%I\n", &rclsid, &riid));

    HRESULT hr = S_OK;
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);

    // look for the interface in the table.
    DWORD iHash = _HashTbl.Hash(riid);
    RIFEntry *pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);

    if (pRIFEntry == NULL)
    {
        // no entry exists for this interface, add one.
        hr = AddEntry(rclsid, riid, iHash, &pRIFEntry);
    }
    else
    {
        // found an entry, update the clsid
        pRIFEntry->psclsid = rclsid;
    }

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_CHANNEL, "CRIFTable::RegisterPSClsid hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::AddEntry, private
//
//  Synopsis:   allocates and entry, fills in the values, and adds it
//              to the hash table.
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::AddEntry(REFCLSID rclsid, REFIID riid,
                            DWORD iHash, RIFEntry **ppRIFEntry)
{
    ASSERT_LOCK_HELD(_mxs);
    RIFEntry *pRIFEntry = (RIFEntry *) _palloc.AllocEntry();

    if (pRIFEntry)
    {
        pRIFEntry->psclsid = rclsid;
        pRIFEntry->dwFlags = RIFFLG_HASCLSID;
        pRIFEntry->pSrvInterface = NULL;
        pRIFEntry->pCliInterface = NULL;
        *ppRIFEntry = pRIFEntry;

        // add to the hash table
        _HashTbl.Add(iHash, riid, &pRIFEntry->HashNode);

        ComDebOut((DEB_CHANNEL,
            "Added RIFEntry riid:%I pRIFEntry\n", &riid, pRIFEntry));
        return S_OK;
    }

    ASSERT_LOCK_HELD(_mxs);
    return E_OUTOFMEMORY;
}
//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::SyncFromAsync public
//
//  Synopsis:   gets mapping from asynchronous IID to synchronous IID
//
//  History:    03-May-99   MattSmit  Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::SyncFromAsync(const IID &async, IID *psync)
{
    return InterfaceMapHelper(async, psync, FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::AsyncFromSync public
//
//  Synopsis:   gets mapping from synchronous IID to asynchronous IID
//
//  History:    03-May-99   MattSmit  Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::AsyncFromSync(const IID &sync, IID *pasync)
{
    return InterfaceMapHelper(sync, pasync, TRUE);
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::InterfaceMapHelper private
//
//  Synopsis:   does the work of getting the mapping.
//
//  History:    03-May-99   MattSmit  Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::InterfaceMapHelper(const IID &riid1, IID *piid2, BOOL fAsyncFromSync)
{

    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    
    DWORD dwHash = _HashTbl.Hash(riid1);
    HRESULT hr;
    RIFEntry *pRifEntry = (RIFEntry *) _HashTbl.Lookup(dwHash, riid1);
    if (!pRifEntry || !(pRifEntry->dwFlags & RIFFLG_HASCOUNTERPART))
    {
        UNLOCK(_mxs);
        ASSERT_LOCK_NOT_HELD(_mxs);
        
        if (fAsyncFromSync)
            hr = wRegQueryAsyncIIDFromSyncIID(riid1, piid2);
        else
            hr = wRegQuerySyncIIDFromAsyncIID(riid1, piid2);

        LOCK(_mxs);
        ASSERT_LOCK_HELD(_mxs);

        if (SUCCEEDED(hr))
        {
            hr = RegisterInterfaceMapping(riid1, *piid2, dwHash, pRifEntry);
        }
    }
    else
    {
        *piid2 = pRifEntry->iidCounterpart;
        hr = S_OK;
    }
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterInterfaceMapping private
//
//  Synopsis:   creates a mapping between two interfaces
//
//  History:    03-May-99   MattSmit  Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::RegisterInterfaceMapping(const IID &iid1, const IID &iid2, 
                                            DWORD dwHash, RIFEntry *pRifEntry)
{
    ASSERT_LOCK_HELD(_mxs);
    if (!pRifEntry)
    {
        pRifEntry = (RIFEntry *) _HashTbl.Lookup(dwHash, iid1);
    }

    if (!pRifEntry)
    {
        // no RifEntry in the table, so allocate one.

        pRifEntry = (RIFEntry *) _palloc.AllocEntry();
        if (pRifEntry)
        {
            memset(pRifEntry, 0, sizeof(RIFEntry));
            // add to the hash table
            _HashTbl.Add(dwHash, iid1, &pRifEntry->HashNode);
        }
    }

    if (pRifEntry)
    {
        // fill in counterpart member

        Win4Assert(pRifEntry->HashNode.key == iid1);
        pRifEntry->iidCounterpart = iid2;
        pRifEntry->dwFlags |= RIFFLG_HASCOUNTERPART;
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CoRegisterPSClsid, public
//
//  Synopsis:   registers a IID->PSCLSID mapping that applies only within
//              the current process. Can be used by code downloaded over
//              a network to do custom interface marshaling without having
//              to muck with the system registry.
//
//  Algorithm:  validate the parameters then add an entry to the RIFTable.
//
//  History:    15-Apr-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDAPI CoRegisterPSClsid(REFIID riid, REFCLSID rclsid)
{
    ComDebOut((DEB_MARSHAL,
        "CoRegisterPSClsid riid:%I rclsid:%I\n", &riid, &rclsid));

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    hr = E_INVALIDARG;

    if ((&riid != NULL) && (&rclsid != NULL) &&
        IsValidPtrIn(&riid, sizeof(riid)) &&
        IsValidPtrIn(&rclsid, sizeof(rclsid)))
    {
        hr = gRIFTbl.RegisterPSClsid(riid, rclsid);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoGetPSClsid,    public
//
//  Synopsis:   returns the proxystub clsid associated with the specified
//              interface IID.
//
//  Arguments:  [riid]      - the interface iid to lookup
//              [lpclsid]   - where to return the clsid
//
//  Returns:    S_OK if successfull
//              REGDB_E_IIDNOTREG if interface is not registered.
//              REGDB_E_READREGDB if any other error
//
//  Algorithm:  First it looks in the local RIFTable for a matching IID. If
//              no entry is found, the RIFTable looks in the shared memory
//              table (NT only), and if not found and the table is FULL, it
//              will look in the registry itself.
//
//  History:    07-Apr-94   Rickhi      rewrite
//
//--------------------------------------------------------------------------
STDAPI CoGetPSClsid(REFIID riid, CLSID *pclsid)
{
    ComDebOut((DEB_MARSHAL, "CoGetPSClsid riid:%I pclsid:%x\n", &riid, pclsid));

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    hr = E_INVALIDARG;

    if ((&riid != NULL) &&
        IsValidPtrIn(&riid, sizeof(riid)) &&
        IsValidPtrOut(pclsid, sizeof(*pclsid)))
    {
        RIFEntry *pRIFEntry;
        hr = gRIFTbl.GetPSClsid(riid, pclsid, &pRIFEntry);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\security.cxx ===
//+-------------------------------------------------------------------
//
//  File:       security.cxx
//
//  Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.
//
//  Contents:   Classes for channel security
//
//  Classes:    CClientSecurity, CServerSecurity
//
//  History:    11 Oct 95       AlexMit Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <locks.hxx>
#include <security.hxx>
#include <ctxchnl.hxx>
#include <ipidtbl.hxx>
#include <resolver.hxx>
#include <service.hxx>
#include <iaccess.h>
#include <stream.hxx>
#include <secdes.hxx>

C2Security gC2Security;

extern "C"
{
#define SECURITY_WIN32 // Used by security.h
#include <security.h>
}

#include <ntsecapi.h>
#include <capi.h>      // Crypto API
#include <rpcssl.h>

#if 0 // #ifdef _CHICAGO_
#include <apiutil.h>
#include <wksta.h>
#endif

#ifdef DCOM_SECURITY
/**********************************************************************/
// Definitions.

// SSL prinicpal name prefixes.
const WCHAR FULL_SUBJECT_ISSUER_CHAIN[]    = L"fullsic:";
const WCHAR MICROSOFT_STANDARD[]           = L"MSStd:";

// Versions of the permissions in the registry.
const WORD COM_PERMISSION_SECDESC = 1;
const WORD COM_PERMISSION_ACCCTRL = 2;

// Guess length of user name.
const DWORD SIZEOF_NAME         = 80;

// This leaves space for 8 sub authorities.  Currently NT only uses 6 and
// Cairo uses 7.
const DWORD SIZEOF_SID          = 44;

// This leaves space for 2 access allowed ACEs in the ACL.
const DWORD SIZEOF_ACL          = sizeof(ACL) + 2 * sizeof(ACCESS_ALLOWED_ACE) +
                                  2 * SIZEOF_SID;

const DWORD SIZEOF_TOKEN_USER   = sizeof(TOKEN_USER) + SIZEOF_SID;

const SID   LOCAL_SYSTEM_SID    = {SID_REVISION, 1, {0,0,0,0,0,5},
                                   SECURITY_LOCAL_SYSTEM_RID };

const DWORD NUM_SEC_PKG         = 8;

const DWORD ACCESS_CACHE_LEN    = 5;

const DWORD VALID_BLANKET_FLAGS = EOAC_MUTUAL_AUTH | EOAC_STATIC_CLOAKING |
                                  EOAC_DYNAMIC_CLOAKING | EOAC_MAKE_FULLSIC |
                                  EOAC_DEFAULT
#if MANUAL_CERT_CHECK // in concert with RPC codebase
                                  | EOAC_ANY_AUTHORITY
#endif // MANUAL_CERT_CHECK
                                  ;  // this terminates const statement

const DWORD VALID_INIT_FLAGS    = (VALID_BLANKET_FLAGS & ~EOAC_DEFAULT) |
                                  EOAC_SECURE_REFS |
                                  EOAC_ACCESS_CONTROL | EOAC_APPID |
                                  EOAC_DYNAMIC | EOAC_REQUIRE_FULLSIC |
                                  EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL;

const DWORD ANY_CLOAKING        = EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING;

// Remove this for NT 5.0 when we link to oleext.lib
const IID IID_IAccessControl = {0xEEDD23E0,0x8410,0x11CE,{0xA1,0xC3,0x08,0x00,0x2B,0x2B,0x8D,0x8F}};

// Map impersonation level to flags for APIs
const SECURITY_IMPERSONATION_LEVEL ImpLevelToSecLevel[5] =
  { SecurityAnonymous, SecurityAnonymous, SecurityIdentification,
    SecurityImpersonation, SecurityDelegation };
const DWORD ImpLevelToAccess[5]   = { 0, TOKEN_QUERY, TOKEN_QUERY,
                                      TOKEN_IMPERSONATE | TOKEN_QUERY,
                                      TOKEN_IMPERSONATE | TOKEN_QUERY };

// Stores results of AccessCheck.
typedef struct
{
    BOOL  fAccess;
    LUID  lClient;
} SAccessCache;

// Header in access permission key.
typedef struct
{
    WORD  wVersion;
    WORD  wPad;
    GUID  gClass;
} SPermissionHeader;

// Stores SSL certificate information.
typedef struct tagSCertificate
{
    struct tagSCertificate *pNext;
    WCHAR                   aSubject[1];
} SCertificate;

#if 0 // #ifdef _CHICAGO_
typedef unsigned
  (*NetWkstaGetInfoFn) ( const char FAR *     pszServer,
                         short                sLevel,
                         char FAR *           pbBuffer,
                         unsigned short       cbBuffer,
                         unsigned short FAR * pcbTotalAvail );
#endif

typedef WINCRYPT32API BOOL (*CertCloseStoreFn)(
    HCERTSTORE hCertStore,
    DWORD dwFlags );

typedef WINCRYPT32API PCCERT_CONTEXT (*CertEnumCertificatesInStoreFn)(
    HCERTSTORE hCertStore,
    PCCERT_CONTEXT pPrevCertContext );

typedef WINCRYPT32API BOOL (*CertFreeCertificateContextFn)(
    PCCERT_CONTEXT pCertContext );

typedef WINCRYPT32API HCERTSTORE (*CertOpenSystemStoreFn)(
    HCRYPTPROV      hProv,
    LPCWSTR         szSubsystemProtocol );

/**********************************************************************/
// Classes.

//+----------------------------------------------------------------
//
//  Class:       CAuthInfo
//
//  Purpose:     Maintains a list of default client authentication
//               information.
//
//  Description: This is a static class just to make it easy to find
//               all accesses to the data.
//
//-----------------------------------------------------------------
class CAuthInfo
{
  public:
    static void    Cleanup();
    static HRESULT Copy   ( SOLE_AUTHENTICATION_LIST *pAuthInfo,
                            SOLE_AUTHENTICATION_LIST **pCopyAuthInfo,
                            DWORD dwCapabilities );
    static void   *Find   ( SECURITYBINDING *pSecBind );
    static void    Set    ( SOLE_AUTHENTICATION_LIST *pAuthInfo );

  private:
    static SOLE_AUTHENTICATION_LIST *_sList;
    static BOOL                      _fNeedSSL;
};

//+----------------------------------------------------------------
//
//  Class:       CSSL
//
//  Purpose:     Save the handles associated with the default SSL
//               identity.
//
//  Description: This is a static class just to make it easy to find
//               all accesses to the data.
//
//-----------------------------------------------------------------
class CSSL
{
  public:
    static void    Cleanup      ();
    static HRESULT DefaultCert  ( PCCERT_CONTEXT *pCert );
    static HRESULT PrincipalName( const CERT_CONTEXT *pCert, WCHAR **pSSL );

  private:
    static HCRYPTPROV                     _hProvider;
    static HCERTSTORE                     _hMyStore;
    static HCERTSTORE                     _hRootStore;
    static const CERT_CONTEXT            *_pCert;
    static HRESULT                        _hr;
    static HINSTANCE                      _hCrypt32;
    static CertCloseStoreFn               _hCertCloseStore;
    static CertEnumCertificatesInStoreFn  _hCertEnumCertificatesInStore;
    static CertFreeCertificateContextFn   _hCertFreeCertificateContext;
    static CertOpenSystemStoreFn          _hCertOpenSystemStore;
};

/**********************************************************************/
// Externals.

EXTERN_C const IID IID_ILocalSystemActivator;


/**********************************************************************/
// Prototypes.
WCHAR  *AuthnName              ( DWORD lAuthnService );
void    CacheAccess            ( LUID lClient, BOOL fAccess );
BOOL    CacheAccessCheck       ( LUID lClient, BOOL *pAccess );
HRESULT CheckAccessControl     ();
HRESULT CheckAcl               ( void );
HRESULT CopySecDesc            ( SECURITY_DESCRIPTOR *pOrig,
                                 SECURITY_DESCRIPTOR **pCopy );
HRESULT FixupAccessControl     ( SECURITY_DESCRIPTOR **pSD, DWORD cbSD );
HRESULT FixupSecurityDescriptor( SECURITY_DESCRIPTOR **pSD, DWORD cbSD );
HRESULT GetLegacyBlanket       ( SECURITY_DESCRIPTOR **, DWORD *, DWORD * );
void    GetRegistryAuthnLevel  ( HKEY hKey, DWORD *pAuthnLevel );
HRESULT GetRegistrySecDesc     ( HKEY, WCHAR *pAccessName,
                                 SECURITY_DESCRIPTOR **pSD, DWORD *, BOOL * );
DWORD   HashSid                ( SID * );
DWORD   LocalAuthnService      ( USHORT wAuthnService );
HRESULT LookupPrincName        ( USHORT, WCHAR ** );
HRESULT MakeSecDesc            ( SECURITY_DESCRIPTOR **, DWORD * );
HRESULT RegisterAuthnServices  ( DWORD cbSvc, SOLE_AUTHENTICATION_SERVICE * );
DWORD   RemoteAuthnService     ( USHORT wAuthnService, DUALSTRINGARRAY * );
DWORD   StrEscByteCnt          ( WCHAR * );
WCHAR  *StrEscCopy             ( WCHAR *, WCHAR * );
WCHAR  *StrQual                ( WCHAR *, BOOL * );


/**********************************************************************/
// Globals.

// These variables hold the default authentication information.
DWORD                            gAuthnLevel       = RPC_C_AUTHN_LEVEL_NONE;
DWORD                            gImpLevel         = RPC_C_IMP_LEVEL_IDENTIFY;
DWORD                            gCapabilities     = EOAC_NONE;
SECURITYBINDING                 *gLegacySecurity   = NULL;

// Initial values for CAuthInfo class.
SOLE_AUTHENTICATION_LIST *CAuthInfo::_sList    = NULL;
BOOL                      CAuthInfo::_fNeedSSL = TRUE;

// Initial values for the CSSL class.
HCRYPTPROV                    CSSL::_hProvider                    = NULL;
HCERTSTORE                    CSSL::_hMyStore                     = NULL;
HCERTSTORE                    CSSL::_hRootStore                   = NULL;
const CERT_CONTEXT           *CSSL::_pCert                        = NULL;
HRESULT                       CSSL::_hr                           = S_FALSE;
HINSTANCE                     CSSL::_hCrypt32                     = NULL;
CertCloseStoreFn              CSSL::_hCertCloseStore              = NULL;
CertEnumCertificatesInStoreFn CSSL::_hCertEnumCertificatesInStore = NULL;
CertFreeCertificateContextFn  CSSL::_hCertFreeCertificateContext  = NULL;
CertOpenSystemStoreFn         CSSL::_hCertOpenSystemStore         = NULL;
SCHANNEL_CRED                 gSchannelCred;
PCCERT_CONTEXT                gSchannelContext                    = NULL;

// These variables define a list of security providers OLE clients can
// use and a list OLE servers can use.
SECPKG              *gClientSvcList      = NULL;
DWORD                gClientSvcListLen   = 0;
USHORT              *gServerSvcList      = NULL;
DWORD                gServerSvcListLen   = 0;

// gDisableDCOM is read from the registry by CRpcResolver::GetConnection.
// If TRUE, all machine remote calls will be failed.  It is set TRUE in WOW.
BOOL                 gDisableDCOM        = FALSE;

// Set TRUE when CRpcResolver::GetConnection initializes the previous globals.
BOOL                 gGotSecurityData    = FALSE;

// The security descriptor to check when new connections are established.
// gAccessControl and gSecDesc will not both be nonNULL at the same time.
IAccessControl      *gAccessControl      = NULL;
SECURITY_DESCRIPTOR *gSecDesc            = NULL;

// The security string array.  If gDefaultService is TRUE, compute the
// security string array the first time a remote protocol sequence is
// registered.
DUALSTRINGARRAY     *gpsaSecurity        = NULL;
BOOL                 gDefaultService     = FALSE;

// The security descriptor to check in RundownOID.
SECURITY_DESCRIPTOR *gRundownSD          = NULL;

// Don't map any of the generic bits to COM_RIGHTS_EXECUTE or any other bit.
GENERIC_MAPPING      gMap  = { 0, 0, 0, 0 };
PRIVILEGE_SET        gPriv = { 1, 0 };

// Cache of results of calls to AccessCheck.
SAccessCache         gAccessCache[ACCESS_CACHE_LEN] =
{ {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}};
DWORD                gMostRecentAccess = 0;
COleStaticMutexSem   gSecurityLock;

// Cache of RPC connection access checks and head of Most Recently Used list.
// Stores results of AccessCheck.
typedef struct SConnectionCache
{
    SPointerHashNode         sChain;
    BOOL                     fAccess;
    struct SConnectionCache *pNext;     // Most Recently Used list
    struct SConnectionCache *pPrev;
    DWORD                    lBirth;
} SConnectionCache;

const DWORD CONNECTION_CACHE_TIMEOUT = 60000;

CConnectionCache     gConnectionCache;
BOOL                 CConnectionCache::_fInitialized = FALSE;
CPageAllocator       CConnectionCache::_cAlloc;
COleStaticMutexSem   CConnectionCache::_mxs;
SConnectionCache     gMRUHead = { { NULL, NULL, 0 },
                                  FALSE, &gMRUHead, &gMRUHead, 0 };

// Cache of CServerSecurity objects.
const ULONG          SS_PER_PAGE = 10;  // server security objects per page
CPageAllocator       CServerSecurity::_palloc;
COleStaticMutexSem   CServerSecurity::_mxs;


//+-------------------------------------------------------------------
//
//  Function:   AuthnName
//
//  Synopsis:   Return the string name for the authentication service.
//
//  Note:       The name must be present because the id and the name
//              are both stored in gClientSvcList.
//
//--------------------------------------------------------------------
WCHAR *AuthnName( DWORD lAuthnService )
{
    DWORD i;

    for (i = 0; i < gClientSvcListLen; i++)
        if (gClientSvcList[i].wId == lAuthnService)
            return gClientSvcList[i].pName;
    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   CacheAccess
//
//  Synopsis:   Store the results of the access check in the cache.
//
//--------------------------------------------------------------------
void CacheAccess( LUID lClient, BOOL fAccess )
{
    SAccessCache *pNew;
    DWORD         cbSid;

    ASSERT_LOCK_NOT_HELD(gSecurityLock);
    LOCK(gSecurityLock);

    // Find the next record.
    gMostRecentAccess += 1;
    if (gMostRecentAccess >= ACCESS_CACHE_LEN)
        gMostRecentAccess = 0;

    // Save the access results.
    gAccessCache[gMostRecentAccess].fAccess = fAccess;
    gAccessCache[gMostRecentAccess].lClient = lClient;

    UNLOCK(gSecurityLock);
    ASSERT_LOCK_NOT_HELD(gSecurityLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CacheAccessCheck
//
//  Synopsis:   Look for the specified LUID in the cache.  If found,
//              return the results of the cached access check.
//
//--------------------------------------------------------------------
BOOL CacheAccessCheck( LUID lClient, BOOL *pAccess )
{
    DWORD         i;
    DWORD         j;
    BOOL          fFound = FALSE;
    SAccessCache  sSwap;

    ASSERT_LOCK_NOT_HELD(gSecurityLock);
    LOCK(gSecurityLock);

    // Look for the SID.
    j = gMostRecentAccess;
    for (i = 0; i < ACCESS_CACHE_LEN; i++)
    {
        if (gAccessCache[j].lClient.LowPart == lClient.LowPart &&
            gAccessCache[j].lClient.HighPart == lClient.HighPart)
        {
            // Move this entry to the head.
            fFound                          = TRUE;
            *pAccess                        = gAccessCache[j].fAccess;
            sSwap                           = gAccessCache[gMostRecentAccess];
            gAccessCache[gMostRecentAccess] = gAccessCache[j];
            gAccessCache[j]                 = sSwap;
            break;
        }
        if (j == 0)
            j = ACCESS_CACHE_LEN - 1;
        else
            j -= 1;
    }

    UNLOCK(gSecurityLock);
    ASSERT_LOCK_NOT_HELD(gSecurityLock);
    return fFound;
}

//+-------------------------------------------------------------------
//
//  Function:   CAuthInfo::Cleanup
//
//  Synopsis:   Cleanup the authentication list.
//
//--------------------------------------------------------------------
void CAuthInfo::Cleanup()
{
    PrivMemFree( _sList );
    _sList = NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   CAuthInfo::Copy
//
//  Synopsis:   Copy an authentication information graph.
//
//  Note: This function needs to be updated as we support new
//        authentication services and as they support new
//        authentication information types.
//
//--------------------------------------------------------------------
HRESULT CAuthInfo::Copy( SOLE_AUTHENTICATION_LIST  *pAuthInfo,
                         SOLE_AUTHENTICATION_LIST **pCopyAuthInfo,
                         DWORD                      dwCapabilities )
{
    DWORD                      i;
    DWORD                      cbCopy;
    DWORD                      cAuthInfo = 0;
    DWORD                      dwAuthnSvc;
    SOLE_AUTHENTICATION_INFO  *aAuthInfo;
    char                      *pData;
    SEC_WINNT_AUTH_IDENTITY_W *pNtlm;
    SEC_WINNT_AUTH_IDENTITY_W *pNtlmCopy;
    BOOL                       fSSL      = FALSE;

    // Do nothing if there is no list.
    *pCopyAuthInfo = NULL;
    if (pAuthInfo == NULL)
        return S_OK;
    if (pAuthInfo == COLE_DEFAULT_AUTHINFO)
        return E_INVALIDARG;

    // Compute the size of the graph.
    cbCopy = sizeof(SOLE_AUTHENTICATION_LIST);
    for (i = 0; i < pAuthInfo->cAuthInfo; i++)
    {
        // Validate the parameters.
        dwAuthnSvc = pAuthInfo->aAuthInfo[i].dwAuthnSvc;
        pNtlm      = (SEC_WINNT_AUTH_IDENTITY_W *)
                         pAuthInfo->aAuthInfo[i].pAuthInfo;
        if (pNtlm == COLE_DEFAULT_AUTHINFO    ||
            dwAuthnSvc == RPC_C_AUTHN_DEFAULT ||
            pAuthInfo->aAuthInfo[i].dwAuthzSvc == RPC_C_AUTHZ_DEFAULT)
            return E_INVALIDARG;

        // Check the allowed structures for NTLM and Kerberos.
        else if (dwAuthnSvc == RPC_C_AUTHN_WINNT ||
                 dwAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS)
        {
            if (pNtlm != NULL)
                if (pNtlm->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE)
                {
                    cbCopy += (pNtlm->UserLength + 1)*sizeof(WCHAR);
                    cbCopy += (pNtlm->DomainLength + 1)*sizeof(WCHAR);
                    cbCopy += (pNtlm->PasswordLength + 1)*sizeof(WCHAR);
                    cbCopy    += sizeof(SEC_WINNT_AUTH_IDENTITY_W);
                    cAuthInfo += 1;
                }
                else
                    return E_INVALIDARG;
        }

        // Check the allowed structure for SSL.
        else if (dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            if (dwCapabilities & ANY_CLOAKING)
                return E_INVALIDARG;
            cAuthInfo += 1;
            fSSL       = TRUE;
        }

        // All other authentication services can only have NULL auth info.
        else if (pNtlm != NULL)
            return E_INVALIDARG;
    }

    // Leave space for SSL credentials to be added later if not already
    // present.
    if (!fSSL)
        cAuthInfo += 1;

    // Add space for the SOLE_AUTHENTICATION_INFO structures.  Nothing
    // needs to be done if no authentication services had credentials.
    if (cAuthInfo == 0)
        return S_OK;
    cbCopy += cAuthInfo * sizeof(SOLE_AUTHENTICATION_INFO);

    // Allocate memory.
    *pCopyAuthInfo = (SOLE_AUTHENTICATION_LIST *) PrivMemAlloc( cbCopy );
    if (*pCopyAuthInfo == NULL)
        return E_OUTOFMEMORY;

    // Copy the graph.
    aAuthInfo = (SOLE_AUTHENTICATION_INFO *) ((*pCopyAuthInfo) + 1);
    pData     = (char *) (aAuthInfo + cAuthInfo);
    if (fSSL)
        (*pCopyAuthInfo)->cAuthInfo = cAuthInfo;
    else
        (*pCopyAuthInfo)->cAuthInfo = cAuthInfo - 1;
    (*pCopyAuthInfo)->aAuthInfo = aAuthInfo;
    for (i = 0; i < pAuthInfo->cAuthInfo; i++)
    {
        // Copy the structure for NTLM and Kerberos
        dwAuthnSvc = pAuthInfo->aAuthInfo[i].dwAuthnSvc;
        pNtlm      = (SEC_WINNT_AUTH_IDENTITY_W *)
                         pAuthInfo->aAuthInfo[i].pAuthInfo;
        if (dwAuthnSvc == RPC_C_AUTHN_WINNT ||
            dwAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS)
        {
            // Copy the auth info.
            aAuthInfo->dwAuthnSvc = dwAuthnSvc;
            if (pNtlm == NULL)
                aAuthInfo->pAuthInfo = NULL;
            else
            {
                aAuthInfo->pAuthInfo  = pData;
                pNtlmCopy             = (SEC_WINNT_AUTH_IDENTITY_W *) pData;
                pData                 = (char *) (pNtlmCopy + 1);
                *pNtlmCopy            = *pNtlm;
                if (pAuthInfo->aAuthInfo[i].dwAuthzSvc == RPC_C_AUTHZ_NONE)
                    aAuthInfo->dwAuthzSvc = 0xffff;
                else
                    aAuthInfo->dwAuthzSvc = pAuthInfo->aAuthInfo[i].dwAuthzSvc;

                // Copy the strings.
                if (pNtlm->UserLength != 0)
                {
                    pNtlmCopy->User = (WCHAR *) pData;
                    memcpy( pNtlmCopy->User, pNtlm->User,
                            (pNtlm->UserLength + 1)*sizeof(WCHAR) );
                    pData += (pNtlm->UserLength + 1)*sizeof(WCHAR);
                }
                else
                    pNtlmCopy->User = NULL;
                if (pNtlm->DomainLength != 0)
                {
                    pNtlmCopy->Domain = (WCHAR *) pData;
                    memcpy( pNtlmCopy->Domain, pNtlm->Domain,
                            (pNtlm->DomainLength + 1)*sizeof(WCHAR) );
                    pData += (pNtlm->DomainLength + 1)*sizeof(WCHAR);
                }
                else
                    pNtlmCopy->Domain = NULL;
                if (pNtlm->PasswordLength != 0)
                {
                    pNtlmCopy->Password = (WCHAR *) pData;
                    memcpy( pNtlmCopy->Password, pNtlm->Password,
                            (pNtlm->PasswordLength + 1)*sizeof(WCHAR) );
                    pData += (pNtlm->PasswordLength + 1)*sizeof(WCHAR);
                }
                else
                    pNtlmCopy->Password = NULL;
            }

            // Advance the auth info.
            aAuthInfo += 1;
        }

        // Copy the structure for SSL.
        else if (dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            // Copy the auth info.
            aAuthInfo->dwAuthnSvc = dwAuthnSvc;
            aAuthInfo->pAuthInfo  = pAuthInfo->aAuthInfo[i].pAuthInfo;
            if (pAuthInfo->aAuthInfo[i].dwAuthzSvc == RPC_C_AUTHZ_NONE)
                aAuthInfo->dwAuthzSvc = 0xffff;
            else
                aAuthInfo->dwAuthzSvc = pAuthInfo->aAuthInfo[i].dwAuthzSvc;

            // Advance the auth info.
            aAuthInfo += 1;
        }
    }
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   CAuthInfo::Find
//
//  Synopsis:   Scan the global authentication information array for
//              authentication information for the specified
//              authentication/authorization service pair.
//
//--------------------------------------------------------------------
void *CAuthInfo::Find( SECURITYBINDING *pSecBind )
{
    DWORD                i;
    DWORD                cAuthInfo;
    const CERT_CONTEXT  *pCert;
    HRESULT              hr;

    // Determine the list length.
    if (_sList == NULL)
        cAuthInfo = 0;
    else
        cAuthInfo = _sList->cAuthInfo;

    // Scan the list.
    for (i = 0; i < cAuthInfo; i++)
        if (_sList->aAuthInfo[i].dwAuthnSvc == pSecBind->wAuthnSvc &&
            _sList->aAuthInfo[i].dwAuthzSvc == pSecBind->wAuthzSvc)
            return _sList->aAuthInfo[i].pAuthInfo;

    // If the requested authentication service is SSL, try to find some
    // default SSL credentials.
    if (pSecBind->wAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL &&
        pSecBind->wAuthzSvc == RPC_C_AUTHZ_NONE         &&
        _fNeedSSL)
    {
        // Don't try again.
        _fNeedSSL = FALSE;

        // Try to get a certificate.
        hr = CSSL::DefaultCert( &pCert );

        // Save the authentication information and return it.
        if (SUCCEEDED(hr))
        {
            _sList->aAuthInfo[_sList->cAuthInfo].dwAuthnSvc = RPC_C_AUTHN_GSS_SCHANNEL;
            _sList->aAuthInfo[_sList->cAuthInfo].dwAuthzSvc = RPC_C_AUTHZ_NONE;
            _sList->aAuthInfo[_sList->cAuthInfo].pAuthInfo  = (void *) pCert;
            _sList->cAuthInfo += 1;
            return (void *) pCert;
        }
    }
    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   CAuthInfo::Set
//
//  Synopsis:   Save the specified authentication information list.
//
//--------------------------------------------------------------------
void CAuthInfo::Set( SOLE_AUTHENTICATION_LIST *pAuthList )
{
    _sList    = pAuthList;
    _fNeedSSL = TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CClientSecurity::CopyProxy, public
//
//  Synopsis:   Create a new IPID entry for the specified IID.
//
//--------------------------------------------------------------------
STDMETHODIMP CClientSecurity::CopyProxy( IUnknown *pProxy, IUnknown **ppCopy )
{
   // Make sure TLS is initialized on this thread.
   HRESULT          hr;
   COleTls          tls(hr);
   if (FAILED(hr))
       return hr;

    // Ask the marshaller to copy the proxy.
    return _pStdId->PrivateCopyProxy( pProxy, ppCopy );
}

//+-------------------------------------------------------------------
//
//  Member:     CClientSecurity::QueryBlanket, public
//
//  Synopsis:   Get the binding handle for a proxy.  Query RPC for the
//              authentication information for that handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CClientSecurity::QueryBlanket(
                                IUnknown                *pProxy,
                                DWORD                   *pAuthnSvc,
                                DWORD                   *pAuthzSvc,
                                OLECHAR                **pServerPrincName,
                                DWORD                   *pAuthnLevel,
                                DWORD                   *pImpLevel,
                                void                   **pAuthInfo,
                                DWORD                   *pCapabilities )
{
    HRESULT           hr;
    IPIDEntry        *pIpid;
    IRemUnknown      *pRemUnk = NULL;

    // Initialize all out parameters to default values.
    if (pServerPrincName != NULL)
        *pServerPrincName = NULL;
    if (pAuthnLevel != NULL)
        *pAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    if (pImpLevel != NULL)
        *pImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    if (pAuthnSvc != NULL)
        *pAuthnSvc = RPC_C_AUTHN_WINNT;
    if (pAuthInfo != NULL)
        *pAuthInfo = NULL;
    if (pAuthzSvc != NULL)
        *pAuthzSvc = RPC_C_AUTHZ_NONE;
    if (pCapabilities != NULL)
        *pCapabilities = EOAC_NONE;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // For IUnknown just call QueryBlanket on the IRemUnknown of
    // the IPID or the OXID.
    if (_pStdId->GetCtrlUnk() == pProxy)
    {
        pIpid = _pStdId->GetConnectedIPID();
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        hr = _pStdId->GetSecureRemUnk( &pRemUnk, pIpid->pOXIDEntry );
        if (pRemUnk != NULL)
        {
            hr = CoQueryProxyBlanket( pRemUnk, pAuthnSvc, pAuthzSvc,
                                      pServerPrincName, pAuthnLevel,
                                      pImpLevel, pAuthInfo, pCapabilities );
        }
    }

    // Find the right IPID entry.
    else
    {
        hr = _pStdId->FindIPIDEntryByInterface( pProxy, &pIpid );
        UNLOCK(gIPIDLock);

        if (SUCCEEDED(hr))
        {
            // Disallow server entries.
            if (pIpid->dwFlags & IPIDF_SERVERENTRY)
                hr = E_INVALIDARG;

            // No security for disconnected proxies.
            else if (pIpid->dwFlags & IPIDF_DISCONNECTED)
                hr = RPC_E_DISCONNECTED;

            else
            {
                LOCK(gComLock);
                hr = QueryBlanketFromChannel(pIpid->pChnl, pAuthnSvc, pAuthzSvc,
                                              pServerPrincName, pAuthnLevel,
                                              pImpLevel, pAuthInfo, pCapabilities);
                UNLOCK(gComLock);
            }
        }

    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}
//+----------------------------------------------------------------------------
//
//  Function:      QueryBlanketFromChannel
//
//  Synopsis:      Helper function fills in security blanket given a channel
//                 object.
//
//  History:       6-Mar-98  MattSmit  Created
//
//-----------------------------------------------------------------------------

HRESULT QueryBlanketFromChannel(CRpcChannelBuffer       *pChnl,
                               DWORD                   *pAuthnSvc,
                               DWORD                   *pAuthzSvc,
                               OLECHAR                **pServerPrincName,
                               DWORD                   *pAuthnLevel,
                               DWORD                   *pImpLevel,
                               void                   **pAuthInfo,
                               DWORD                   *pCapabilities )
{
    ComDebOut((DEB_CHANNEL, "QueryBlanketFromChannel IN pChnl:0x%x, pAuthnSvc:0x%x, "
               "pAuthzSvc:0x%x, pServerPrincName:0x%x, pAuthnLevel:0x%x, pImpLevel:0x%x, "
               "pAuthInfo:0x%x, pCapabilities:0x%x\n", pChnl, pAuthnSvc, pAuthzSvc,
               pServerPrincName, pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities));


    ASSERT_LOCK_HELD(gComLock);

    HRESULT hr;
    RPC_STATUS        sc;
    CChannelHandle   *pHandle;
    RPC_SECURITY_QOS  sQos;
    DWORD             iLen;
    OLECHAR          *pCopy;


    // If it is local, use the default values for everything but the
    // impersonation level.
    if (pChnl->ProcessLocal())
    {
        if (pImpLevel != NULL)
            *pImpLevel = pChnl->GetImpLevel();
          hr = S_OK;
    }

    // Otherwise ask RPC.
    else
    {
        // Get the binding handle to query.
        hr = pChnl->GetHandle( &pHandle, FALSE );

        if (SUCCEEDED(hr))
        {
            sc = RpcBindingInqAuthInfoExW( pHandle->_hRpc,
                                           pServerPrincName, pAuthnLevel,
                                           pAuthnSvc, pAuthInfo,
                                           pAuthzSvc,
                                           RPC_C_SECURITY_QOS_VERSION,
                                           &sQos );

            // It is not an error for a handle to have default
            // security.
            if (sc == RPC_S_BINDING_HAS_NO_AUTH)
            {
                // By default remote handles are unsecure
                if (!(pChnl->GetOXIDEntry()->IsOnLocalMachine()))
                {
                    if (pAuthnLevel != NULL)
                        *pAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
                    if (pAuthnSvc != NULL)
                        *pAuthnSvc = RPC_C_AUTHN_NONE;
                }
                if (pServerPrincName != NULL)
                    *pServerPrincName = NULL;
            }

            // RPC sometimes sets out parameters on error.
            else if (sc != RPC_S_OK)
            {
                if (pServerPrincName != NULL)
                    *pServerPrincName = NULL;
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
            }
            else
            {
                // Return the impersonation level and capabilities.
                if (pImpLevel != NULL)
                    *pImpLevel = sQos.ImpersonationType;
                if (pCapabilities != NULL)
                {
                    if (sQos.Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH)
                        *pCapabilities = EOAC_MUTUAL_AUTH;
                    if (sQos.IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
                        *pCapabilities |= EOAC_DYNAMIC_CLOAKING;
                    if (pHandle->_eState & static_cloaking_hs)
                        *pCapabilities |= EOAC_STATIC_CLOAKING;
#if MANUAL_CERT_CHECK
                    if (sQos.Capabilities & RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY)
                        *pCapabilities |= EOAC_ANY_AUTHORITY;
#endif // MANUAL_CERT_CHECK
                }

                // Reallocate the principal name using the OLE memory allocator.
                if (pServerPrincName != NULL && *pServerPrincName != NULL)
                {
                    iLen = lstrlenW( *pServerPrincName ) + 1;
                    pCopy = (OLECHAR *) CoTaskMemAlloc( iLen * sizeof(OLECHAR) );
                    if (pCopy != NULL)
                        memcpy( pCopy, *pServerPrincName, iLen*sizeof(USHORT) );
                    else
                        hr = E_OUTOFMEMORY;
                    RpcStringFree( pServerPrincName );
                    *pServerPrincName = pCopy;
                }

                // [Sergei O. Ivanov (sergei), 7/19/2000]
                // Retrieve certificate out of SChannel credential

                if(*pAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                    SCHANNEL_CRED *pCred = ((SCHANNEL_CRED*) *pAuthInfo);
                    *pAuthInfo = (void*) *(pCred->paCred);
                }
            }
            pHandle->Release();
        }
    }

    ASSERT_LOCK_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "QueryBlanketFromChannel OUT hr:0x%x\n", hr));
    return hr;
}




//+-------------------------------------------------------------------
//
//  Member:     CClientSecurity::SetBlanket, public
//
//  Synopsis:   Get the binding handle for a proxy.  Call RPC to set the
//              authentication information for that handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CClientSecurity::SetBlanket(
                                IUnknown *pProxy,
                                DWORD     AuthnSvc,
                                DWORD     AuthzSvc,
                                OLECHAR  *pServerPrincName,
                                DWORD     AuthnLevel,
                                DWORD     ImpLevel,
                                void     *pAuthInfo,
                                DWORD     Capabilities )
{
    HRESULT           hr;
    IPIDEntry        *pIpid;
    IRemUnknown      *pRemUnk;
    IRemUnknown      *pSecureRemUnk = NULL;

    ASSERT_LOCK_NOT_HELD(gComLock);

    // IUnknown is special.  Set the security on IRemUnknown instead.
    if (_pStdId->GetCtrlUnk() == pProxy)
    {
        // Make sure the identity has its own copy of the OXID's
        // IRemUnknown.
        if (!_pStdId->CheckSecureRemUnk())
        {
            // This will get the remote unknown from the OXID.
            LOCK(gIPIDLock);
            pIpid = _pStdId->GetConnectedIPID();
            UNLOCK(gIPIDLock);
            hr = _pStdId->GetSecureRemUnk( &pRemUnk, pIpid->pOXIDEntry );

            if (SUCCEEDED(hr))
            {
                hr = CoCopyProxy( pRemUnk, (IUnknown **) &pSecureRemUnk );
                if (SUCCEEDED(hr))
                {
                    // Remote Unknown proxies are not supposed to ref count
                    // the OXID.

                    ULONG cRefs = pIpid->pOXIDEntry->DecRefCnt();
                    Win4Assert(cRefs != 0);

                    // Only keep the proxies if no one else made a copy
                    // while this thread was making a copy.

                    // CODEWORK: Make this an atomic operation on the stdid
                    // using interlockedcompare etc. to avod taking the lock.
                    LOCK(gComLock);
                    if (!_pStdId->CheckSecureRemUnk())
                    {
                        _pStdId->SetSecureRemUnk( pSecureRemUnk );
                        pSecureRemUnk = NULL;
                    }
                    UNLOCK(gComLock);

                    // Discard the newly created remunk if someone else
                    // created on.
                    if (pSecureRemUnk != NULL)
                    {
                        pSecureRemUnk->Release();
                    }
                    hr = _pStdId->GetSecureRemUnk( &pSecureRemUnk, NULL );
                }
            }
        }
        else
            hr = _pStdId->GetSecureRemUnk( &pSecureRemUnk, NULL );

        // Call SetBlanket on the copy of IRemUnknown.
        if (pSecureRemUnk != NULL)
            hr = CoSetProxyBlanket( pSecureRemUnk, AuthnSvc, AuthzSvc,
                                    pServerPrincName, AuthnLevel,
                                    ImpLevel, pAuthInfo, Capabilities );
    }

    else
    {
        // Find the right IPID entry.
        LOCK(gIPIDLock);
        hr = _pStdId->FindIPIDEntryByInterface( pProxy, &pIpid );
        UNLOCK(gIPIDLock);

        if (SUCCEEDED(hr))
        {
            // Disallow server entries.
            if (pIpid->dwFlags & IPIDF_SERVERENTRY)
                hr = E_INVALIDARG;

            // No security for disconnected proxies.
            else if (pIpid->dwFlags & IPIDF_DISCONNECTED)
                hr = RPC_E_DISCONNECTED;

            // Compute the real values for any default parameters.
            else
            {
                LOCK(gComLock);
                hr = SetBlanketOnChannel(pIpid->pChnl, AuthnSvc, AuthzSvc,
                                          pServerPrincName, AuthnLevel,
                                          ImpLevel, pAuthInfo, Capabilities);
                UNLOCK(gComLock);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:      SetBlanketOnChannel
//
//  Synopsis:      Helper function to set the security blanket on a channel
//                 object.
//
//  History:       6-Mar-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT SetBlanketOnChannel(CRpcChannelBuffer *pChnl,
                             DWORD     AuthnSvc,
                             DWORD     AuthzSvc,
                             OLECHAR  *pServerPrincName,
                             DWORD     AuthnLevel,
                             DWORD     ImpLevel,
                             void     *pAuthInfo,
                             DWORD     Capabilities )
{
    ComDebOut((DEB_CHANNEL, "SetBlanketOnChannel IN pChnl:0x%x, AuthnSvc:0x%x, "
               "AuthzSvc:0x%x, pServerPrincName:0x%x, AuthnLevel:0x%x, ImpLevel:0x%x, "
               "pAuthInfo:0x%x, Capabilities:0x%x\n", pChnl, AuthnSvc, AuthzSvc,
               pServerPrincName, AuthnLevel, ImpLevel, pAuthInfo, Capabilities));
    ASSERT_LOCK_HELD(gComLock);

    SBlanket          sBlanket;
    HRESULT           hr;
    CChannelHandle   *pRpc          = NULL;
    RPC_STATUS        sc;
    BOOL              fResume;
    HANDLE            hThread;
    DWORD             lSvcIndex;

#ifndef SSL
    // Don't allow SSL until the fixes are checked in.
    if (AuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, RPC_S_UNKNOWN_AUTHN_SERVICE );
#endif

#ifdef SSL
    // Sergei O. Ivanov (a-sergiv)  9/14/99  NTBUG #402305 and #402311
    // Validate authn/imp levels for SSL

    if(AuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
    {
        if(AuthnLevel == RPC_C_AUTHN_LEVEL_NONE
           || ImpLevel == RPC_C_IMP_LEVEL_IDENTIFY
           || ImpLevel == RPC_C_IMP_LEVEL_DELEGATE
           || (ImpLevel == RPC_C_IMP_LEVEL_ANONYMOUS && pAuthInfo != NULL)
           )
        {
            // SSL does not support these authn/imp levels.
            return E_INVALIDARG;
        }
    }
#endif // SSL

    // Check the authentication service.
    if (AuthnSvc == RPC_C_AUTHN_DEFAULT)
        lSvcIndex = DefaultAuthnSvc( pChnl->GetOXIDEntry() );
    else
        lSvcIndex = GetAuthnSvcIndexForBinding( AuthnSvc, pChnl->GetOXIDEntry()->GetBinding() );

    // Compute all the other defaults.
    sBlanket._lAuthnLevel = AuthnLevel;
    
    hr = DefaultBlanket( lSvcIndex, pChnl->GetOXIDEntry(), &sBlanket );
    if(FAILED(hr)) return hr;

    if (AuthzSvc != RPC_C_AUTHZ_DEFAULT)
        sBlanket._lAuthzSvc = AuthzSvc;
    if (AuthnLevel != RPC_C_AUTHN_LEVEL_DEFAULT)
        sBlanket._lAuthnLevel = AuthnLevel;
    if (AuthnSvc != RPC_C_AUTHN_DEFAULT)
        sBlanket._lAuthnSvc = AuthnSvc;
    else if (sBlanket._lAuthnLevel != RPC_C_AUTHN_LEVEL_NONE &&
             sBlanket._lAuthnSvc == RPC_C_AUTHN_NONE)
        sBlanket._lAuthnSvc = RPC_C_AUTHN_WINNT;
    if (ImpLevel != RPC_C_IMP_LEVEL_DEFAULT)
        sBlanket._sQos.ImpersonationType = ImpLevel;
    else
    {
        // Verify that default imp level works with SSL.
        // Sergei O. Ivanov (a-sergiv)  9/21/99  NTBUG #403493

        if(sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL
           && sBlanket._sQos.ImpersonationType != RPC_C_IMP_LEVEL_IMPERSONATE)
            return SEC_E_UNSUPPORTED_FUNCTION; // BUGBUG: CO_E_DEF_IMP_LEVEL_INCOMPAT (define this!)
    }
    if (pServerPrincName != COLE_DEFAULT_PRINCIPAL)
        sBlanket._pPrincipal = pServerPrincName;
    if (pAuthInfo != COLE_DEFAULT_AUTHINFO)
    {
        // Pass the certificate for SSL in a SCHANNEL_CRED structure which was
        // initialized by DefaultBlanket.
        if (sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            sBlanket._pAuthId = (void *) &sBlanket._sCred;

            if (!pAuthInfo)
            {
                CSSL::DefaultCert(&sBlanket._pCert);
                // TODO: Check if pCert is still NULL and return error
            }
            else
                sBlanket._pCert = (PCCERT_CONTEXT) pAuthInfo;
        }
        else
            sBlanket._pAuthId = pAuthInfo;
    }
    if (Capabilities != EOAC_DEFAULT)
        sBlanket._lCapabilities = Capabilities;

    // Don't allow both cloaking and auth info.
    if (sBlanket._pAuthId != NULL &&
        (sBlanket._lCapabilities & ANY_CLOAKING) &&
        sBlanket._lAuthnSvc != RPC_C_AUTHN_GSS_NEGOTIATE)
        hr = E_INVALIDARG;

    // Don't allow both cloaking flags.
    else if ((sBlanket._lCapabilities & ANY_CLOAKING) == ANY_CLOAKING)
        hr = E_INVALIDARG;

    else if (pChnl->ProcessLocal())
    {
        // Local calls can use no authn service or winnt.
        if (sBlanket._lAuthnSvc != RPC_C_AUTHN_NONE &&
            sBlanket._lAuthnSvc != RPC_C_AUTHN_WINNT &&
            sBlanket._lAuthnSvc != RPC_C_AUTHN_DCE_PRIVATE)
            hr = E_INVALIDARG;

        // Make sure the authentication level is not invalid.
        else if ((sBlanket._lAuthnSvc == RPC_C_AUTHN_NONE &&
                  sBlanket._lAuthnLevel != RPC_C_AUTHN_LEVEL_NONE) ||
                 (sBlanket._lAuthnSvc == RPC_C_AUTHN_WINNT &&
                  sBlanket._lAuthnLevel > RPC_C_AUTHN_LEVEL_PKT_PRIVACY))
            hr = E_INVALIDARG;

        // No authorization services are supported locally.
        else if (sBlanket._lAuthzSvc != RPC_C_AUTHZ_NONE)
            hr = E_INVALIDARG;

        // You cannot supply credentials locally.
        else if (sBlanket._pAuthId != NULL)
            hr = E_INVALIDARG;

        // Range check the impersonation level.
        else if (sBlanket._sQos.ImpersonationType < RPC_C_IMP_LEVEL_ANONYMOUS ||
                 sBlanket._sQos.ImpersonationType > RPC_C_IMP_LEVEL_DELEGATE)
            hr = E_INVALIDARG;

                    // No capabilities are supported yet.
        else if (sBlanket._lCapabilities & ~VALID_BLANKET_FLAGS)
            hr = E_INVALIDARG;

        // Create a new handle object and discard the old one.
        else
        {
            // Create a new handle.
            pRpc = new CChannelHandle( sBlanket._lAuthnLevel,
                                       sBlanket._sQos.ImpersonationType,
                                       sBlanket._lCapabilities,
                                       pChnl->GetOXIDEntry(),
                                       pChnl->GetState() | app_security_cs,
                                       &hr );
            if (pRpc == NULL)
                hr = E_OUTOFMEMORY;
            else
            {
                // Replace the old one.
                if (SUCCEEDED(hr))
                    pChnl->ReplaceHandle( pRpc );
                pRpc->Release();
            }
        }
    }

    // If it is remote, tell RPC.
    else
    {
        // Validate the capabilities.
        if (sBlanket._lCapabilities & ~VALID_BLANKET_FLAGS)
            hr = E_INVALIDARG;
        else if ((sBlanket._lCapabilities & ANY_CLOAKING) &&
                 sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
            hr = E_INVALIDARG;
        else
        {
            // Create a new handle.
            pRpc = new CChannelHandle( sBlanket._lAuthnLevel,
                                       sBlanket._sQos.ImpersonationType,
                                       sBlanket._lCapabilities,
                                       pChnl->GetOXIDEntry(),
                                       pChnl->GetState() | app_security_cs,
                                       &hr );
            if (pRpc == NULL)
                hr = E_OUTOFMEMORY;
            else if (FAILED(hr))
            {
                pRpc->Release();
                pRpc = NULL;
            }
        }

        if (SUCCEEDED(hr))
        {
#ifdef _CHICAGO_
            // If the principal name is not known, the server must be
            // NT.  Replace the principal name in that case
            // because a NULL principal name is a flag for some
            // Chicago security hack.
            if (sBlanket._pPrincipal == NULL      &&
                sBlanket._lAuthnSvc == RPC_C_AUTHN_WINNT &&
                (! pChnl->GetOXIDEntry()->IsOnLocalMachine()))
                sBlanket._pPrincipal = L"Default";
#endif // _CHICAGO_

            // Adjust the thread token to the one RPC needs to see.
            pRpc->AdjustToken( SET_BLANKET_AT, &fResume, &hThread );

            // Initialize the QOS structure.
            if (sBlanket._pPrincipal != NULL)
                sBlanket._sQos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
            else
                sBlanket._sQos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
#ifdef MANUAL_CERT_CHECK
            if (sBlanket._lCapabilities & EOAC_ANY_AUTHORITY)
                sBlanket._sQos.Capabilities |= RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY;
#endif
            if (sBlanket._lCapabilities & EOAC_DYNAMIC_CLOAKING)
                sBlanket._sQos.IdentityTracking   = RPC_C_QOS_IDENTITY_DYNAMIC;
            else
                sBlanket._sQos.IdentityTracking   = RPC_C_QOS_IDENTITY_STATIC;

            // RPC wants authentication service winnt for
            // unsecure same machine calls.
            if (sBlanket._lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE &&
                sBlanket._lAuthnSvc   == RPC_C_AUTHN_NONE       &&
                (pRpc->_eState & machine_local_hs))
                sBlanket._lAuthnSvc = RPC_C_AUTHN_WINNT;

            // [Sergei O. Ivanov (sergei), 7/19/2000]
            // Store the credential inside CChannelHandle for SSL
            if(sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
            {
                pRpc->_pCert = sBlanket._pCert;
                pRpc->_sCred = sBlanket._sCred;
                pRpc->_sCred.paCred = &pRpc->_pCert;

                if(pRpc->_pCert)
                    pRpc->_sCred.cCreds = 1;  // there is a cert
                else
                    pRpc->_sCred.cCreds = 0;  // there is no cert

                sBlanket._pAuthId = (void *) &pRpc->_sCred;
            }

            // Set the level on the handle.
            sc = RpcBindingSetAuthInfoExW( pRpc->_hRpc,
                                           sBlanket._pPrincipal,
                                           sBlanket._lAuthnLevel,
                                           sBlanket._lAuthnSvc,
                                           sBlanket._pAuthId,
                                           sBlanket._lAuthzSvc,
                                           &sBlanket._sQos );

            // Restore the thread token.
            pRpc->RestoreToken( fResume, hThread );

            if (sc != RPC_S_OK)
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
            else
                pChnl->ReplaceHandle( pRpc );
            pRpc->Release();
        }
    }

    ASSERT_LOCK_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "SetBlanketOnChannel OUT hr:0x%x\n", hr));
    return hr;

}

//+-------------------------------------------------------------------
//
//  Method:     CConnectionCache::Add
//
//  Synopsis:   Add an entry to the cache.
//
//--------------------------------------------------------------------
void CConnectionCache::Add( BOOL fAccess )
{
    SConnectionCache *pNode;
    CServerSecurity  *pSS;
    HRESULT           hr;
    DWORD             lNow;

    // Get the server security.
    hr = CoGetCallContext( IID_IServerSecurity, (void **) &pSS );

    // Look for a cached entry.
    if (SUCCEEDED(hr))
    {
        ASSERT_LOCK_NOT_HELD(_mxs);
        LOCK(_mxs);

        pNode = (SConnectionCache *) CPointerHashTable::Lookup(
            Hash(pSS->GetConnection()), pSS->GetConnection() );

        // If not found, create a cache entry.
        if (pNode == NULL)
        {
            // try to allocate without growing the table
            lNow = GetTickCount();
            pNode = (SConnectionCache *) _cAlloc.AllocEntry(FALSE);
            if (pNode == NULL)
            {
                // There is no free space in the cache, see if there is an
                // old entry that can be reused.

                // The time arithmatic handles the time wrapping.
                if (gMRUHead.pPrev != &gMRUHead &&
                    lNow - gMRUHead.pPrev->lBirth > CONNECTION_CACHE_TIMEOUT)
                {
                    // Remove the old node from the MRU list.
                    pNode               = gMRUHead.pPrev;
                    pNode->pPrev->pNext = pNode->pNext;
                    pNode->pNext->pPrev = pNode->pPrev;

                    // Remove the old node from the hash table.
                    CHashTable::Remove( &pNode->sChain.chain );
                }
            }

            // If not reusing an entry, ask the page table for one.
            if (pNode == NULL)
                pNode = (SConnectionCache *) _cAlloc.AllocEntry();

            // If got page entry, add it
            if (pNode != NULL)
            {
                // Add the node to the hash table.
                CPointerHashTable::Add( Hash(pSS->GetConnection()),
                                        pSS->GetConnection(), &pNode->sChain );

                // Add the node to the MRU list.
                pNode->pNext        = gMRUHead.pNext;
                pNode->pPrev        = &gMRUHead;
                pNode->pNext->pPrev = pNode;
                gMRUHead.pNext      = pNode;
                pNode->lBirth       = lNow;
                pNode->fAccess      = fAccess;
            }
        }

        UNLOCK(_mxs);
        ASSERT_LOCK_NOT_HELD(_mxs);
        pSS->Release();
    }
}

//+-------------------------------------------------------------------
//
//  Method:     CConnectionCache::Cleanup
//
//  Synopsis:   Empty the cache.
//
//--------------------------------------------------------------------
void CConnectionCache::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    // Initialize the MRU list.
    gMRUHead.pNext = &gMRUHead;
    gMRUHead.pPrev = &gMRUHead;

    // Tell the cache to empty itself.
    if (_fInitialized)
    {
        CHashTable::Cleanup( FreeConnection );
        _cAlloc.Cleanup();
        _fInitialized = FALSE;
    }

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Function:   CConnectionCache::FreeConnection, public
//
//  Synopsis:   Called to free a node from the hash table to the page
//              table.
//
//+-------------------------------------------------------------------
void CConnectionCache::FreeConnection( SHashChain *pNode )
{
    ASSERT_LOCK_HELD(_mxs);
    _cAlloc.ReleaseEntry( (PageEntry *) pNode );
}

//+-------------------------------------------------------------------
//
//  Method:     CConnectionCache::Initialize
//
//  Synopsis:   Initialize the cache.
//
//--------------------------------------------------------------------
void CConnectionCache::Initialize()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    // Initialize the hash buckets.
    for (DWORD i = 0; i < NUM_HASH_BUCKETS; i++)
    {
        _sBuckets[i].pNext = &_sBuckets[i];
        _sBuckets[i].pPrev = &_sBuckets[i];
    }

    // Initialize the hash table.
    CHashTable::Initialize( _sBuckets, &_mxs );

    // Initialize the page allocator. We guarantee mutual exclusion
    // on calls to it, so it does not need to.
    _cAlloc.Initialize( sizeof(SConnectionCache), 32, NULL );
    _fInitialized = TRUE;

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Method:     CConnectionCache::Lookup
//
//  Synopsis:   Find an entry in the cache.
//
//--------------------------------------------------------------------
HRESULT CConnectionCache::Lookup( BOOL *pAccess )
{
    SConnectionCache *pNode;
    CServerSecurity  *pSS;
    HRESULT           hr;

    ASSERT_LOCK_NOT_HELD(_mxs);

    // Get the server security.
    *pAccess = FALSE;
    hr = CoGetCallContext( IID_IServerSecurity, (void **) &pSS );

    // Look for a cached entry.
    if (SUCCEEDED(hr))
    {
        LOCK(_mxs);
        pNode = (SConnectionCache *) CPointerHashTable::Lookup(
            Hash(pSS->GetConnection()), pSS->GetConnection() );
        if (pNode != NULL)
        {
            // Remove this node from the MRU list.
            *pAccess = pNode->fAccess;
            pNode->pPrev->pNext = pNode->pNext;
            pNode->pNext->pPrev = pNode->pPrev;

            // Move this node to the head of the MRU list.
            pNode->pPrev        = &gMRUHead;
            pNode->pNext        = gMRUHead.pNext;
            pNode->pNext->pPrev = pNode;
            gMRUHead.pNext      = pNode;
            pNode->lBirth       = GetTickCount();
        }
        else
            hr = E_FAIL;
        UNLOCK(_mxs);
        pSS->Release();
    }

    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CConnectionCache::Remove, private
//
//  Synopsis:   Remove an entry from the cache.
//
//--------------------------------------------------------------------
void CConnectionCache::Remove( void *pConnection )
{
    ASSERT_LOCK_HELD(_mxs);

    SConnectionCache *
    pNode = (SConnectionCache *) CPointerHashTable::Lookup( Hash(pConnection),
                                                            pConnection );
    if (pNode != NULL)
    {
        // Remove the node from the hash table.
        CHashTable::Remove( &pNode->sChain.chain );

        // Remove the node from the MRU list.
        pNode->pNext->pPrev = pNode->pPrev;
        pNode->pPrev->pNext = pNode->pNext;

        // Release the node to the page table.
        _cAlloc.ReleaseEntry( (PageEntry *) pNode );
    }

    ASSERT_LOCK_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Method:     CConnectionCache::GetConnection
//
//  Synopsis:   Get the connection id for the current call and
//              flush any stale entries in the connection cache
//              if this is a new connection.
//
//  Notes:      The lock must be held from before the I_RpcBindingInqConnId
//              untill after the call to Remove to prevent one thread from
//              getting the first flag and getting swapped before clearing
//              the stale cache entries.
//
//--------------------------------------------------------------------
HRESULT CConnectionCache::GetConnection(handle_t hRpc, void **ppConnection )
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    BOOL fFirst = FALSE;
    HRESULT hr = I_RpcBindingInqConnId( hRpc, ppConnection, &fFirst );
    if (SUCCEEDED(hr))
    {
        if (fFirst)
            Remove( *ppConnection );
    }

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CheckAccess
//
//  Synopsis:   Determine if the caller has permission to make a call.
//              If this function returns a result other then S_OK,
//              access will be denied.
//
//  Notes:      Convert all error codes to E_ACCESSDENIED since activation
//              tests, and applications expect security failures to return
//              it.
//
//--------------------------------------------------------------------
HRESULT CheckAccess( IPIDEntry *pIpid, CMessageCall *pCall )
{
    HRESULT result;
    DWORD   lAuthnLevel;
    BOOL    fAccess;
    BOOL    fDynamic      = FALSE;
    IServerSecurity *pISS = NULL;

    ASSERT_LOCK_NOT_HELD(gComLock);

    // If process local always succeed (until we have real security
    // boundaries in COM Base). We short-circuit the inproc case as
    // quickly as possible.
    if (pCall && pCall->ProcessLocal())
        return S_OK;

    if(pIpid)
    {
        // Unsecure Callbacks feature requires us to bypass access check
        // for calls on CRemUnknown. CRemUnknown will perform its own
        // access check just before calling into the user object.
        //
        // REVIEW: Does it suffice to check for IRundown only?
        if(pIpid->iid == IID_IRundown)
            return S_OK;

        // Check the target context to see if it wants to allow unsecure calls.
        CPolicySet *pPS = pIpid->pChnl->GetStdId()->GetServerPolicySet();
        if (pPS && pPS->GetServerContext()->IsUnsecure())
            return S_OK;            // unsecure calls are allowed
    }

    result = CoGetCallContext(IID_IServerSecurity, (void**) &pISS);
    if(FAILED(result))
        return E_ACCESSDENIED;
    else
        result = S_OK;

    fDynamic = ((CServerSecurity*) pISS)->_fDynamicCloaking;

    // Check authentication level.
    if (gAuthnLevel > RPC_C_AUTHN_LEVEL_NONE)
    {
        result = pISS->QueryBlanket( NULL, NULL, NULL, &lAuthnLevel, NULL,
                                     NULL, NULL );

        if (result != RPC_S_OK || lAuthnLevel < gAuthnLevel)
        {
            pISS->Release();
            return E_ACCESSDENIED;  // normal failure path for secure app
        }
    }

    pISS->Release();

    // If there is no ACL, allow access.
    if (gSecDesc == NULL && gAccessControl == NULL)
        return S_OK;

    // Never use the cache for dynamic.
    if (fDynamic)
    {
        // Check the ACL or IAccessControl.
        if (gSecDesc != NULL)
            result = CheckAcl();
        else
            result = CheckAccessControl();
    }

    // For static, look in a cache first.
    else
    {
#if 0
// Process local case removed here because we short-circuit this
// above for now...

        // If process local, use the call handle to cache the access result.
        if (pCall->ProcessLocal())
        {
            // Access is always allowed if there is no cloaking.
            if (pCall->_pHandle->_eState & any_cloaking_hs)

                // If the cached results deny access, fail now.
                if (pCall->_pHandle->_eState & deny_hs)
                    result = E_ACCESSDENIED;

                // If there are no cached results, actually check the ACL.
                else if ((pCall->_pHandle->_eState & allow_hs) == 0)
                {
                    // Check the ACL or IAccessControl.
                    if (gSecDesc != NULL)
                        result = CheckAcl();
                    else
                        result = CheckAccessControl(pCall);

                    // Save the results of the access check.
                    if (result == S_OK)
                        pCall->_pHandle->_eState |= allow_hs;
                    else
                        pCall->_pHandle->_eState |= deny_hs;
                }
        }

        // If process remote and static, use the connection cache.
        else
#endif
        {
            // Look in the connection cache.
            result = gConnectionCache.Lookup( &fAccess );
            if (result == S_OK)
                result = fAccess ? S_OK : E_ACCESSDENIED;

            // Check the ACL or IAccessControl.
            else
            {
                if (gSecDesc != NULL)
                    result = CheckAcl();
                else
                    result = CheckAccessControl();

                // Save the results of the access check.
                gConnectionCache.Add( result==S_OK );
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);

    // Convert all error codes to E_ACCESSDENIED since activation
    // tests, and applications expect security failures to return
    // it.
    if (result != S_OK)
        return E_ACCESSDENIED;
    else
        return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   CheckAccessControl
//
//  Synopsis:   Call the access control and ask it to check access.
//
//--------------------------------------------------------------------
HRESULT CheckAccessControl()
{
    HRESULT          hr;
    TRUSTEE_W        sTrustee;
    BOOL             fAccess = FALSE;
    COleTls          tls(hr);
#if DBG == 1
    char            *pFailure = "";
#endif

    sTrustee.ptstrName = NULL;
    if (FAILED(hr))
    {
#if DBG == 1
         pFailure = "Bad TLS: 0x%x\n";
#endif
    }

    else
    {
#if 0 // #ifdef _CHICAGO_
        // Chicago doesn't suport token's or cloaking.  Therefore, all local
        // access checks should succeed.
        if (pCall->pBinding->_eState & (process_local_hs | machine_local_hs))
            return RPC_S_OK;

        // ILocalSystemActivator can't be called remotely.
        else if ( *MSG_TO_IIDPTR( &pCall->message ) == IID_ILocalSystemActivator)
        {
#if DBG == 1
            pFailure = "ILocalSystemActivator can't be called remotely: 0x%x\n";
#endif
            hr = E_ACCESSDENIED;
        }
#endif

        if (SUCCEEDED(hr))
        {
            // Get the trustee name.
            hr = CoQueryClientBlanket( NULL, NULL, NULL, NULL, NULL,
                                       (void **) &sTrustee.ptstrName, NULL );

            if (hr == S_OK)
            {
                // Check access.
                sTrustee.pMultipleTrustee         = NULL;
                sTrustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
                sTrustee.TrusteeForm              = TRUSTEE_IS_NAME;
                sTrustee.TrusteeType              = TRUSTEE_IS_USER;
                hr = gAccessControl->IsAccessAllowed( &sTrustee, NULL,
                                              COM_RIGHTS_EXECUTE, &fAccess );
#if DBG==1
                if (FAILED(hr))
                    pFailure = "IsAccessAllowed failed: 0x%x\n";
#endif
                if (SUCCEEDED(hr) && !fAccess)
                {
                    hr = E_ACCESSDENIED;
#if DBG==1
                    pFailure = "IAccessControl does not allow user access.\n";
#endif
                }
            }
#if DBG == 1
            else
                pFailure = "RpcBindingInqAuthClientW failed: 0x%x\n";
#endif
        }
    }

#if DBG==1
    if (hr != S_OK)
    {
        ComDebOut(( DEB_WARN, "***** ACCESS DENIED *****\n" ));
        ComDebOut(( DEB_WARN, pFailure, hr ));

        // Print the user name.
        if (sTrustee.ptstrName != NULL)
            ComDebOut(( DEB_WARN, "User: %ws\n", sTrustee.ptstrName ));
    }
#endif
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CheckAcl
//
//  Synopsis:   Impersonate and do an AccessCheck against the global ACL.
//
//--------------------------------------------------------------------
HRESULT CheckAcl()
{
    HRESULT          hr;
    BOOL             fAccess = FALSE;
    BOOL             fSuccess;
    DWORD            lGrantedAccess;
    DWORD            lSetLen = sizeof(gPriv);
    HANDLE           hToken;
    DWORD            i;
    TOKEN_STATISTICS sTokenStatistics;
    DWORD            lSize      = sizeof(sTokenStatistics);
#if DBG==1
    char            *pFailure   = "";
#endif

    hr = CoImpersonateClient();

    if (hr == S_OK)
    {
        // Open the thread token.
        fSuccess = OpenThreadToken( GetCurrentThread(), TOKEN_READ,
                                    TRUE, &hToken );

        // Remove the thread token so the GetTokenInformation succeeds.
        SetThreadToken( NULL, NULL );

        if (fSuccess)
        {
            // Get the SID and see if its cached.
            fSuccess = GetTokenInformation( hToken, TokenStatistics,
                                            &sTokenStatistics, lSize, &lSize );

            // Lookup the cached access results.
            if (fSuccess)
                fSuccess = CacheAccessCheck( sTokenStatistics.ModifiedId,
                                             &fAccess );

            // If there are any cached access results, use them.
            if (fSuccess)
            {
                if (!fAccess)
                {
                    hr = E_ACCESSDENIED;
#if DBG==1
                    pFailure = "Security descriptor does not allow user access.\n";
#endif
                }
            }

            // Access check.
            else
            {
                fSuccess = AccessCheck( gSecDesc, hToken, COM_RIGHTS_EXECUTE,
                                        &gMap, &gPriv, &lSetLen, &lGrantedAccess,
                                        &fAccess );
                if (fSuccess)
                    CacheAccess( sTokenStatistics.ModifiedId, fAccess );

                if (!fAccess)
                {
                    hr = E_ACCESSDENIED;
#if DBG==1
                    pFailure = "Security descriptor does not allow user access.\n";
#endif
                }
#if DBG==1
                if (!fSuccess)
                    pFailure = "Bad security descriptor\n";
#endif
            }
            CloseHandle( hToken );
        }
        else
        {
            hr = GetLastError();
#if DBG==1
            pFailure = "Could not open thread token: 0x%x\n";
#endif
        }

        // Revert.
        CoRevertToSelf();

    }
#if DBG==1
    else
        pFailure = "Could not impersonate client: 0x%x\n";
#endif

#if DBG==1
    if (hr != S_OK)
    {
        ComDebOut(( DEB_WARN, "***** ACCESS DENIED *****\n" ));
        ComDebOut(( DEB_WARN, pFailure, hr ));

        // Print the user name.
        WCHAR *pClient = NULL;
        CoQueryClientBlanket( NULL, NULL, NULL, NULL, NULL,
                              (void **) &pClient, NULL );
        if (pClient != NULL)
            ComDebOut(( DEB_WARN, "User: %ws\n", pClient ));
        ComDebOut(( DEB_WARN, "Security Descriptor 0x%x\n", gSecDesc ));
    }
#endif
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CheckObjactAccess, private
//
//  Synopsis:   Determine whether caller has permission to make call.
//
//  Notes: This function was created to special case security on
//         activation calls using dynamic delegation on NT 4.  In NT 5
//         security on dynamic delegation calls is handled automaticly
//         so the function does nothing.
//
//  Old Notes: Since ILocalSystemActivator uses dynamic delegation, we have to allow
//  all calls to ILocalSystemActivator through the normal security (which only
//  checks access on connect) and check them manually.
//
//--------------------------------------------------------------------
BOOL CheckObjactAccess()
{
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:   CoCopyProxy, public
//
//  Synopsis:   Copy a proxy.
//
//--------------------------------------------------------------------
WINOLEAPI CoCopyProxy(
    IUnknown    *pProxy,
    IUnknown   **ppCopy )
{
    HRESULT          hr;
    IClientSecurity *pickle;

    // Check the parameters.
    if (pProxy == NULL || ppCopy == NULL)
        return E_INVALIDARG;

    // Ask the proxy for IClientSecurity.
    hr = ((IUnknown *) pProxy)->QueryInterface( IID_IClientSecurity,
                                                (void **) &pickle );
    if (FAILED(hr))
        return hr;
    else if (pickle == NULL)
        return E_NOINTERFACE;

    // Ask IClientSecurity to do the copy.
    hr = pickle->CopyProxy( pProxy, ppCopy );
    pickle->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetCallContext
//
//  Synopsis:   Get an interface that supplies contextual information
//              about the call.  Currently only IServerSecurity.
//
//--------------------------------------------------------------------
WINOLEAPI CoGetCallContext( REFIID riid, void **ppInterface )
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        if (ppInterface == NULL)
            return E_INVALIDARG;
        if (tls->pCallContext != NULL)
        {
            // Look up the requested interface.
            hr = tls->pCallContext->QueryInterface( riid, ppInterface );
        }
        else
        {
            // Fail if there is no call context.
            hr = RPC_E_CALL_COMPLETE;
        }

        // Only delegate to COM Services if COM Base failed the request and the
        // caller requested an interface unknown to us.
        if (FAILED(hr) && riid != IID_IServerSecurity)
        {
            // See if this is a request for the COM+ security call context
            static HRESULT (STDAPICALLTYPE *pfnCosGetCallContext)(REFIID, void**) = NULL;
            static HMODULE s_hComsvcsDll = NULL;
            if(pfnCosGetCallContext == NULL)
            {
                HMODULE hModule = GetModuleHandleW(L"comsvcs.dll");

                // Fail if the COM+ DLL isn't already loaded.
                if (hModule == NULL)
                    return hr;

                // Protect ourselves against comsvcs.dll going away out from 
                // underneath us.  We won't do this until we see it's already
                // loaded into the process (via GetModuleHandle above), but after
                // that we keep our own reference on the dll, for safety's sake.
                s_hComsvcsDll = LoadLibraryW(L"comsvcs.dll");
                if (s_hComsvcsDll == NULL)
                    return hr;
                
                pfnCosGetCallContext = (HRESULT (STDAPICALLTYPE *)(REFIID, void**))
                                       GetProcAddress(s_hComsvcsDll, "CosGetCallContext");

                // If the entry point isn't there, just return the original error.
                if (pfnCosGetCallContext == NULL)
                    return hr;
            }

            // Delegate the request to COM+ Services
            hr = (*pfnCosGetCallContext)(riid, ppInterface);
        }
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoImpersonateClient
//
//  Synopsis:   Get the server security for the current call and ask it
//              to do an impersonation.
//
//--------------------------------------------------------------------
WINOLEAPI CoImpersonateClient()
{
    HRESULT          hr;
    IServerSecurity *pSS;

    // Get the IServerSecurity.
    hr = CoGetCallContext( IID_IServerSecurity, (void **) &pSS );
    if (FAILED(hr))
        return hr;

    // Ask IServerSecurity to do the impersonate.
    hr = pSS->ImpersonateClient();
    pSS->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoInitializeSecurity, public
//
//  Synopsis:   Set the values to use for automatic security.  This API
//              can only be called once so it does not need to be thread
//              safe.
//
//--------------------------------------------------------------------
WINOLEAPI CoInitializeSecurity(
                    PSECURITY_DESCRIPTOR              pVoid,
                    LONG                              cAuthSvc,
                    SOLE_AUTHENTICATION_SERVICE      *asAuthSvc,
                    void                             *pReserved1,
                    DWORD                             dwAuthnLevel,
                    DWORD                             dwImpLevel,
                    void                             *pReserved2,
                    DWORD                             dwCapabilities,
                    void                             *pReserved3 )
{
    HRESULT                      hr             = S_OK;
    DWORD                        i;
    SECURITY_DESCRIPTOR         *pSecDesc       = (SECURITY_DESCRIPTOR *) pVoid;
    SECURITY_DESCRIPTOR         *pCopySecDesc   = NULL;
    IAccessControl              *pAccessControl = NULL;
    BOOL                         fFreeSecDesc   = FALSE;
    SOLE_AUTHENTICATION_SERVICE  sAuthSvc;
    SOLE_AUTHENTICATION_LIST    *pAuthInfo      = (SOLE_AUTHENTICATION_LIST *) pReserved2;
    SOLE_AUTHENTICATION_LIST    *pCopyAuthInfo  = NULL;
    WCHAR                       *pPrincName     = NULL;
    DWORD                        lNameLen       = 1;
    SECURITYBINDING             *pSecBind;

    // Fail if OLE is not initialized or TLS cannot be allocated.
    if (!IsApartmentInitialized())
        return CO_E_NOTINITIALIZED;

    // Make sure the security data is available.
    if (!gGotSecurityData)
    {
        hr = gResolver.GetConnection();
        if (FAILED(hr))
            return hr;
        Win4Assert(gGotSecurityData);
    }

    // Make sure only one of the flags defining the pVoid parameter is set.
    if ((dwCapabilities & (EOAC_APPID | EOAC_ACCESS_CONTROL)) ==
        (EOAC_APPID | EOAC_ACCESS_CONTROL))
        return E_INVALIDARG;

    // Convert the default authentication level to connect.
    if (dwAuthnLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;

    // If the appid flag is set, read the registry security.
    if (dwCapabilities & EOAC_APPID)
    {
        if (pSecDesc != NULL && !IsValidPtrIn( pSecDesc, sizeof(UUID) ))
            return E_INVALIDARG;

        // Get a security blanket from the registry.
        hr = GetLegacyBlanket( &pSecDesc, &dwCapabilities, &dwAuthnLevel );
        if (FAILED(hr))
            return hr;
        fFreeSecDesc = TRUE;

        // Fix up the security binding.
        if (gLegacySecurity != NULL)
        {
            // Ignore errors since the principal name may not be used anyway.
            LookupPrincName( gLegacySecurity->wAuthnSvc, &pPrincName );
            cAuthSvc                = 1;
            asAuthSvc               = &sAuthSvc;
            sAuthSvc.dwAuthnSvc     = gLegacySecurity->wAuthnSvc;
            sAuthSvc.dwAuthzSvc     = gLegacySecurity->wAuthzSvc;
            sAuthSvc.pPrincipalName = pPrincName;
            if (sAuthSvc.dwAuthzSvc == COM_C_AUTHZ_NONE)
                sAuthSvc.dwAuthzSvc = RPC_C_AUTHZ_NONE;
        }
        else
            cAuthSvc = 0xFFFFFFFF;

        // Initialize remaining parameters.
        pReserved1      = NULL;
        dwImpLevel      = gImpLevel;
        pAuthInfo       = NULL;
        pReserved3      = NULL;
        dwCapabilities |= gCapabilities;
    }

    // Fail if called too late, recalled, or called with bad parameters.
    if (dwImpLevel > RPC_C_IMP_LEVEL_DELEGATE        ||
        dwImpLevel < RPC_C_IMP_LEVEL_ANONYMOUS       ||
        dwAuthnLevel > RPC_C_AUTHN_LEVEL_PKT_PRIVACY ||
        pReserved1 != NULL                           ||
        pReserved3 != NULL                           ||
        (dwCapabilities & ~VALID_INIT_FLAGS)         ||
        (dwCapabilities & ANY_CLOAKING) == ANY_CLOAKING
        )
    {
        hr = E_INVALIDARG;
        goto Error;
    }
    if (dwAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
    {
        if (dwCapabilities & EOAC_SECURE_REFS)
        {
            hr = E_INVALIDARG;
            goto Error;
        }
    }
    else if (cAuthSvc == 0)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Validate the pointers.
    if (pSecDesc != NULL)
        if (dwCapabilities & EOAC_ACCESS_CONTROL)
        {
            if (!IsValidPtrIn( pSecDesc, 4 ))
            {
                hr = E_INVALIDARG;
                goto Error;
            }
        }
        else if (!IsValidPtrIn( pSecDesc, sizeof(SECURITY_DESCRIPTOR) ))
        {
            hr = E_INVALIDARG;
            goto Error;
        }
    if (cAuthSvc != 0 && cAuthSvc != -1 &&
        !IsValidPtrOut( asAuthSvc, sizeof(SOLE_AUTHENTICATION_SERVICE) * cAuthSvc ))
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Copy and validate the auth info.
    hr = CAuthInfo::Copy( pAuthInfo, &pCopyAuthInfo, dwCapabilities );
    if (FAILED(hr))
        goto Error;

#ifdef SSL
    // Sergei O. Ivanov, 8/16/99  We will lookup SSL certificate
    // only when RPC_C_AUTHN_GSS_SCHANNEL is explicitly specified.

    if(asAuthSvc)
    {
        for(LONG i=0;i<cAuthSvc;i++)
        {
            if(asAuthSvc[i].dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
            {
                // [Sergei O. Ivanov (sergei) 8/8/2000]
                // SSL does not support cloaking so we shall fail if cloaking is requested

                if(dwCapabilities & ANY_CLOAKING)
                {
                    hr = E_INVALIDARG;
                    goto Error;
                }

                // Just compute the default cert before taking the lock for now.
                // If SSL ends up working, fix this later.  This is not thread
                // safe and a waste of work if SSL isn't used.

                const CERT_CONTEXT *pCert;
                CSSL::DefaultCert( &pCert ); // ignore hr for now

                break;
            }
        }
    }
#endif

    LOCK(gComLock);

    if (gpsaSecurity != NULL)
        hr = RPC_E_TOO_LATE;

    if (SUCCEEDED(hr))
    {
        // Initialize the connection cache.
        gConnectionCache.Initialize();

        // If the app doesn't want security, don't set up a security
        // descriptor.
        if (dwAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
        {
            // Check for some more invalid parameters.
            if (pSecDesc != NULL && (dwCapabilities & EOAC_APPID) == 0)
                hr = E_INVALIDARG;
        }

        // Check whether security is done with ACLs or IAccessControl.
        else if (dwCapabilities & EOAC_ACCESS_CONTROL)
        {
            if (pSecDesc == NULL)
                hr = E_INVALIDARG;
            else
                hr = ((IUnknown *) pSecDesc)->QueryInterface(
                            IID_IAccessControl, (void **) &pAccessControl );
        }

        else
        {
#ifdef _CHICAGO_
            if (pSecDesc != NULL)
                hr = E_INVALIDARG;
#else
            // If specified, copy the security descriptor.
            if (pSecDesc != NULL)
                hr = CopySecDesc( pSecDesc, &pCopySecDesc );
#endif
        }
    }

    if (SUCCEEDED(hr))
    {
        // Delay the registration of authentication services if the caller
        // isn't picky.
        if (cAuthSvc == -1)
        {
            hr = LookupPrincName( RPC_C_AUTHN_WINNT, &pPrincName );
            if (SUCCEEDED(hr))
            {
                lNameLen = lstrlenW( pPrincName );

                gpsaSecurity = (DUALSTRINGARRAY *)
                               PrivMemAlloc( SASIZE(lNameLen + 6) );
                if (gpsaSecurity != NULL)
                {
                    gpsaSecurity->wNumEntries     = (USHORT) lNameLen + 6;
                    gpsaSecurity->wSecurityOffset = 2;
                    gpsaSecurity->aStringArray[0] = 0;
                    gpsaSecurity->aStringArray[1] = 0;
                    pSecBind = (SECURITYBINDING *) &gpsaSecurity->aStringArray[2];
                    pSecBind->wAuthnSvc = RPC_C_AUTHN_WINNT;
                    pSecBind->wAuthzSvc = COM_C_AUTHZ_NONE;
                    memcpy( &pSecBind->aPrincName, pPrincName,
                            (lNameLen+1) * sizeof(WCHAR) );
                    gpsaSecurity->aStringArray[lNameLen+5] = 0;
                    gDefaultService                        = TRUE;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                gpsaSecurity = (DUALSTRINGARRAY *) PrivMemAlloc( SASIZE(4) );
                if (gpsaSecurity != NULL)
                {
                    gpsaSecurity->wNumEntries     = 4;
                    gpsaSecurity->wSecurityOffset = 2;
                    memset( gpsaSecurity->aStringArray, 0, 4*sizeof(WCHAR) );
                    gDefaultService               = TRUE;
                    hr = S_OK;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }

        // Create an empty security binding if the caller wants no
        // security.
        else if (cAuthSvc == 0)
        {
            gpsaSecurity = (DUALSTRINGARRAY *) PrivMemAlloc( SASIZE(4) );
            if (gpsaSecurity != NULL)
            {
                gpsaSecurity->wNumEntries     = 4;
                gpsaSecurity->wSecurityOffset = 2;
                memset( gpsaSecurity->aStringArray, 0, 4*sizeof(WCHAR) );
            }
            else
                hr = E_OUTOFMEMORY;
        }

        // Otherwise, register the ones the caller specified.
        else
        {
            // Sergei O. Ivanov (a-sergiv)  10/07/99
            // RegisterAuthnServices may need to look at dwCapabilities
            // when registering authentication services. It does for SSL.
            //
            // It is quite OK to do this since we're holding gComLock.

            DWORD dwSavedCapabilities = gCapabilities;
            gCapabilities = dwCapabilities;

            hr = RegisterAuthnServices( cAuthSvc, asAuthSvc );

            gCapabilities = dwSavedCapabilities;
        }
    }

    // If everything succeeded, change the globals.
    if (SUCCEEDED(hr))
    {
        // Save the defaults.
        gAuthnLevel    = dwAuthnLevel;
        gImpLevel      = dwImpLevel;
        gCapabilities  = dwCapabilities;
        gSecDesc       = pCopySecDesc;
        gAccessControl = pAccessControl;
        CAuthInfo::Set( pCopyAuthInfo );

        // If cloaking was specified, remove SSL from the client service list.
        if (dwCapabilities & ANY_CLOAKING)
        {
            for (i = 0; i < gClientSvcListLen; i++)
                if (gClientSvcList[i].wId == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                    gClientSvcListLen -= 1;
                    if (i < gClientSvcListLen)
                        memcpy( &gClientSvcList[i], &gClientSvcList[i+1],
                                (gClientSvcListLen - i)*sizeof(SECPKG) );
                    break;
                }
        }
    }
    UNLOCK(gComLock);

    // If anything was allocated for app id security, free it.
Error:
    if (fFreeSecDesc && pSecDesc != NULL)
        if (dwCapabilities & EOAC_ACCESS_CONTROL)
            ((IAccessControl *) pSecDesc)->Release();
        else
            PrivMemFree( pSecDesc );
#if 0 // #ifdef _CHICAGO_
    #error This string wasn't allocated by PrivMemAlloc so it can't be freed here.
    PrivMemFree( pPrincName );
#else
    PrivMemFree( pPrincName );
#endif

    // If there was an error, free any memory allocated.
    if (FAILED(hr))
    {
        PrivMemFree( pCopySecDesc );
        PrivMemFree( pCopyAuthInfo );
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CopySecDesc
//
//  Synopsis:   Copy a security descriptor.
//
//  Notes: The function does not copy the SACL because we do not do
//  auditing.
//
//--------------------------------------------------------------------
HRESULT CopySecDesc( SECURITY_DESCRIPTOR *pOrig, SECURITY_DESCRIPTOR **pCopy )
{
    SID   *pOwner;
    SID   *pGroup;
    ACL   *pDacl;
    ULONG  cSize;
    ULONG  cOwner;
    ULONG  cGroup;
    ULONG  cDacl;

    // Assert if there is a new revision for the security descriptor or
    // ACL.
#if DBG== 1
    if (pOrig->Revision != SECURITY_DESCRIPTOR_REVISION)
        ComDebOut(( DEB_ERROR, "Someone made a new security descriptor revision without telling me." ));
    if (pOrig->Dacl != NULL)
        Win4Assert( pOrig->Dacl->AclRevision <= ACL_REVISION4 ||
                    !"Someone made a new acl revision without telling me." );
#endif

    // Validate the security descriptor and ACL.
    if (pOrig->Revision != SECURITY_DESCRIPTOR_REVISION ||
        (pOrig->Control & SE_SELF_RELATIVE) != 0        ||
        pOrig->Owner == NULL                            ||
        pOrig->Group == NULL                            ||
        pOrig->Sacl != NULL                             ||
        (pOrig->Dacl != NULL && pOrig->Dacl->AclRevision > ACL_REVISION4))
        return E_INVALIDARG;

    // Figure out how much memory to allocate for the copy and allocate it.
    cOwner = GetLengthSid( pOrig->Owner );
    cGroup = GetLengthSid( pOrig->Group );
    cDacl  = pOrig->Dacl == NULL ? 0 : pOrig->Dacl->AclSize;
    cSize = sizeof(SECURITY_DESCRIPTOR) + cOwner + cGroup + cDacl;
    *pCopy = (SECURITY_DESCRIPTOR *) PrivMemAlloc( cSize );
    if (*pCopy == NULL)
        return E_OUTOFMEMORY;

    // Get pointers to each of the parts of the security descriptor.
    pOwner = (SID *) (*pCopy + 1);
    pGroup = (SID *) (((char *) pOwner) + cOwner);
    if (pOrig->Dacl != NULL)
        pDacl = (ACL *) (((char *) pGroup) + cGroup);
    else
        pDacl = NULL;

    // Copy each piece.
   **pCopy = *pOrig;
   memcpy( pOwner, pOrig->Owner, cOwner );
   memcpy( pGroup, pOrig->Group, cGroup );
   if (pDacl != NULL)
       memcpy( pDacl, pOrig->Dacl, pOrig->Dacl->AclSize );
   (*pCopy)->Owner = pOwner;
   (*pCopy)->Group = pGroup;
   (*pCopy)->Dacl  = pDacl;
   (*pCopy)->Sacl  = NULL;

    // Check the security descriptor.
#if DBG==1
    if (!IsValidSecurityDescriptor( *pCopy ))
    {
        Win4Assert( !"COM Created invalid security descriptor." );
        return GetLastError();
    }
#endif
   return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   CoQueryAuthenticationServices, public
//
//  Synopsis:   Return a list of the registered authentication services.
//
//--------------------------------------------------------------------
WINOLEAPI CoQueryAuthenticationServices( DWORD *pcAuthSvc,
                                      SOLE_AUTHENTICATION_SERVICE **asAuthSvc )
{
    DWORD      i;
    DWORD      lNum = 0;
    WCHAR     *pNext;
    HRESULT    hr   = S_OK;

    // Validate the parameters.
    if (asAuthSvc == NULL)
        return E_INVALIDARG;

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Count the number of services in the security string array.
    if (gpsaSecurity != NULL)
    {
        pNext = (PWCHAR)&gpsaSecurity->aStringArray[gpsaSecurity->wSecurityOffset];
        while (*pNext != 0)
        {
            lNum++;
            pNext += lstrlenW(pNext)+1;
        }
    }

    // Return nothing if there are no authentication services.
    *pcAuthSvc = lNum;
    if (lNum == 0)
    {
        *asAuthSvc  = NULL;
        goto exit;
    }

    // Allocate a list of pointers.
    *asAuthSvc = (SOLE_AUTHENTICATION_SERVICE *)
                   CoTaskMemAlloc( lNum * sizeof(SOLE_AUTHENTICATION_SERVICE) );
    if (*asAuthSvc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize it.
    for (i = 0; i < lNum; i++)
        (*asAuthSvc)[i].pPrincipalName = NULL;

    // Fill in one SOLE_AUTHENTICATION_SERVICE record per service
    pNext = (PWCHAR)&gpsaSecurity->aStringArray[gpsaSecurity->wSecurityOffset];
    for (i = 0; i < lNum; i++)
    {
        (*asAuthSvc)[i].dwAuthnSvc = *(pNext++);
        (*asAuthSvc)[i].hr         = S_OK;
        if (*pNext == COM_C_AUTHZ_NONE)
        {
            (*asAuthSvc)[i].dwAuthzSvc = RPC_C_AUTHZ_NONE;
            pNext += 1;
        }
        else
            (*asAuthSvc)[i].dwAuthzSvc = *(pNext++);

        // Allocate memory for the principal name string.
        (*asAuthSvc)[i].pPrincipalName = (OLECHAR *)
          CoTaskMemAlloc( (lstrlenW(pNext)+1)*sizeof(OLECHAR) );
        if ((*asAuthSvc)[i].pPrincipalName == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        lstrcpyW( (*asAuthSvc)[i].pPrincipalName, pNext );
        pNext += lstrlenW(pNext) + 1;
    }

    // Clean up if there wasn't enough memory.
    if (FAILED(hr))
    {
        for (i = 0; i < lNum; i++)
            CoTaskMemFree( (*asAuthSvc)[i].pPrincipalName );
        CoTaskMemFree( *asAuthSvc );
        *asAuthSvc  = NULL;
        *pcAuthSvc = 0;
    }

exit:
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoQueryClientBlanket
//
//  Synopsis:   Get the authentication settings the client used to call
//              the server.
//
//--------------------------------------------------------------------
WINOLEAPI CoQueryClientBlanket(
    DWORD             *pAuthnSvc,
    DWORD             *pAuthzSvc,
    OLECHAR          **pServerPrincName,
    DWORD             *pAuthnLevel,
    DWORD             *pImpLevel,
    RPC_AUTHZ_HANDLE  *pPrivs,
    DWORD             *pCapabilities )
{
    HRESULT          hr;
    IServerSecurity *pSS;

    // Get the IServerSecurity.
    hr = CoGetCallContext( IID_IServerSecurity, (void **) &pSS );
    if (FAILED(hr))
        return hr;

    // Ask IServerSecurity to do the query.
    hr = pSS->QueryBlanket( pAuthnSvc, pAuthzSvc, pServerPrincName,
                            pAuthnLevel, pImpLevel, pPrivs, pCapabilities );

    pSS->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoQueryProxyBlanket, public
//
//  Synopsis:   Get the authentication settings from a proxy.
//
//--------------------------------------------------------------------
WINOLEAPI CoQueryProxyBlanket(
    IUnknown                  *pProxy,
    DWORD                     *pAuthnSvc,
    DWORD                     *pAuthzSvc,
    OLECHAR                  **pServerPrincName,
    DWORD                     *pAuthnLevel,
    DWORD                     *pImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  *pAuthInfo,
    DWORD                     *pCapabilities )
{
    HRESULT          hr;
    IClientSecurity *pickle;

    // Ask the proxy for IClientSecurity.
    if (pProxy == NULL)
        return E_INVALIDARG;
    hr = ((IUnknown *) pProxy)->QueryInterface( IID_IClientSecurity,
                                                (void **) &pickle );
    if (FAILED(hr))
        return hr;
    else if (pickle == NULL)
        return E_NOINTERFACE;

    // Ask IClientSecurity to do the query.
    hr = pickle->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                               pAuthnLevel, pImpLevel, pAuthInfo,
                               pCapabilities );
    pickle->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoRevertToSelf
//
//  Synopsis:   Get the server security for the current call and ask it
//              to revert.
//
//--------------------------------------------------------------------
WINOLEAPI CoRevertToSelf()
{
    HRESULT          hr;
    IServerSecurity *pSS;

    // Get the IServerSecurity.
    hr = CoGetCallContext( IID_IServerSecurity, (void **) &pSS );
    if (FAILED(hr))
        return hr;

    // Ask IServerSecurity to do the revert.
    hr = pSS->RevertToSelf();
    pSS->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoSetProxyBlanket, public
//
//  Synopsis:   Set the authentication settings for a proxy.
//
//--------------------------------------------------------------------
WINOLEAPI CoSetProxyBlanket(
    IUnknown                 *pProxy,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthnLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities )
{
    HRESULT          hr;
    IClientSecurity *pickle;

    // Ask the proxy for IClientSecurity.
    if (pProxy == NULL)
        return E_INVALIDARG;
    hr = ((IUnknown *) pProxy)->QueryInterface( IID_IClientSecurity,
                                                (void **) &pickle );
    if (FAILED(hr))
        return hr;
    else if (pickle == NULL)
        return E_NOINTERFACE;

    // Ask IClientSecurity to do the set.
    hr = pickle->SetBlanket( pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
                             dwAuthnLevel, dwImpLevel, pAuthInfo,
                             dwCapabilities );
    pickle->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoSwitchCallContext
//
//  Synopsis:   Replace the call context object in TLS.  Return the old
//              context object.  This API is used by custom marshallers
//              to support security.
//
//--------------------------------------------------------------------
WINOLEAPI CoSwitchCallContext( IUnknown *pNewObject, IUnknown **ppOldObject )
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        *ppOldObject      = tls->pCallContext;
        tls->pCallContext = pNewObject;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CServerSecurity::AddRef()
{
    return InterlockedIncrement( (long *) &_iRefCount );
}

//+-------------------------------------------------------------------
//
//  Function:   CServerSecurity::Initialize
//
//  Synopsis:   Initialize the authentication list.
//
//--------------------------------------------------------------------
/* static */
void CServerSecurity::Initialize()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    _palloc.Initialize(sizeof(CServerSecurity), SS_PER_PAGE, &_mxs);

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//---------------------------------------------------------------------------
//
//  Method:     CServerSecurity::Cleanup
//
//  Synopsis:   Free all elements in the cache.
//
//---------------------------------------------------------------------------
/* static */
void CServerSecurity::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    _palloc.Cleanup();

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::CServerSecurity, public
//
//  Synopsis:   Construct a server security for a call.
//
//--------------------------------------------------------------------
CServerSecurity::CServerSecurity( CMessageCall *call, handle_t hRpc,
                                  HRESULT *hr )
{
    *hr        = S_OK;
    _iRefCount = 1;
    _pHandle   = call->_pHandle;
    _hRpc      = hRpc;

    // This member is only valid for cross-process calls!
    _fDynamicCloaking = FALSE;

    if (call->ProcessLocal())
    {
        _iFlags      = SS_PROCESS_LOCAL;
        _pClientCall = call;
        _pConnection = NULL;
    }
    else
    {
        _iFlags      = 0;
        _pClientCall = NULL;

        // Get the connection id and flush any stale entries in
        // the connection cache if this is a new connection.

        *hr = gConnectionCache.GetConnection(hRpc, &_pConnection);
        if (FAILED(*hr))
        {
            return;
        }

    }

    // Handle impersonation.
    *hr = SetupSecurity();
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::SetupSecurity, public
//
//  Synopsis:   Auto impersonates if necessary
//
//--------------------------------------------------------------------
HRESULT CServerSecurity::SetupSecurity()
{
    COleTls         tls;

    // Save the impersonation data for the previous call on this thread.
    if (tls->dwFlags & OLETLS_IMPERSONATING)
    {
        _iFlags      |= SS_WAS_IMPERSONATING;
        _hSaved       = tls->hRevert;
        tls->hRevert  = NULL;
        tls->dwFlags &= ~OLETLS_IMPERSONATING;
    }
    else
        _hSaved = NULL;

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::RestoreSecurity, public
//
//  Synopsis:   Clears the stored binding handle because the call
//              this object represents is over.
//
//  Note:       When async finish completes, RPC destroys the binding
//              handle _hRpc even if async begin has not completed.
//
//--------------------------------------------------------------------
void CServerSecurity::RestoreSecurity( BOOL fCallDone )
{
    // Revert if the app forgot to.
    RevertToSelf();
    if (fCallDone)
    {
        _iFlags |= SS_CALL_DONE;
        _pHandle = NULL;
        _hRpc    = NULL;
    }

    // Restore the impersonation data for the previous call on this thread.
    if (_iFlags & SS_WAS_IMPERSONATING)
    {
        COleTls tls;
        tls->dwFlags |= OLETLS_IMPERSONATING;
        Win4Assert( tls->hRevert == NULL );
        tls->hRevert  = _hSaved;
        _hSaved       = NULL;
        _iFlags      &= ~SS_WAS_IMPERSONATING;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::ImpersonateClient, public
//
//  Synopsis:   Calls RPC to impersonate for the stored binding handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CServerSecurity::ImpersonateClient()
{
#ifdef _CHICAGO_
    return E_NOTIMPL;
#else

    HRESULT    hr;
    RPC_STATUS sc;
    BOOL       fSuccess;
    HANDLE     hProcess;
    HANDLE     hToken;
    HANDLE     hThread;
    SECURITY_IMPERSONATION_LEVEL eDuplicate;
    COleTls    tls(hr);

    // If TLS could not be created, fail.
    if (FAILED(hr))
        return hr;

    // If the call is over, fail this request.
    if (_iFlags & SS_CALL_DONE)
        return RPC_E_CALL_COMPLETE;

    // If this is the first impersonation on this thread, save the
    // current thread token.  Ignore errors.
    if ((tls->dwFlags & OLETLS_IMPERSONATING) == 0)
        OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE, TRUE,
                         &tls->hRevert );

    // For process local calls, ask the channel to impersonate.
    if (_iFlags & SS_PROCESS_LOCAL)
    {

        // A NULL token means the client wasn't cloaking, use the process
        // token.
        if (_pHandle->_hToken == NULL)
        {
            // Determine what rights to duplicate the token with.
            eDuplicate = ImpLevelToSecLevel[_pHandle->_lImp];

            // If there is a thread token it can cause the Open or Duplicate
            // to fail or create a bad token.
            SuspendImpersonate( &hThread );

            // If the channel doesn't have a token, use the process token.
            if (OpenProcessToken( GetCurrentProcess(),
                                  TOKEN_DUPLICATE,
                                  &hProcess ))
            {
                if (DuplicateToken( hProcess, eDuplicate, &hToken ))
                {
                    if (!SetThreadToken( NULL, hToken ))
                        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

                    // If the channel still doesn't have a token, save this one.
                    LOCK(gComLock);
                    if (_pHandle->_hToken == NULL)
                        _pHandle->_hToken = hToken;
                    else
                        CloseHandle( hToken );
                    UNLOCK(gComLock);
                }
                else
                    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
                CloseHandle( hProcess );
            }
            else
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

            // Restore the thread token.
            if (hThread != NULL)
            {
                if (FAILED(hr))
                    SetThreadToken( NULL, hThread );
                CloseHandle( hThread );
            }
        }
        else
        {
            fSuccess = SetThreadToken( NULL, _pHandle->_hToken );
            if (!fSuccess)
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        }
    }

    // For process remote calls, ask RPC to impersonate.
    else
    {
        sc = RpcImpersonateClient( _hRpc );
        if (sc != RPC_S_OK)
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
    }

    // If successful, set the impersonating flag in TLS.
    if (SUCCEEDED(hr))
        tls->dwFlags |= OLETLS_IMPERSONATING;

    // If the impersonate failed and the start of this function saved a
    // token, release it.
    else if ((tls->dwFlags & OLETLS_IMPERSONATING) == 0 && tls->hRevert != NULL)
    {
        CloseHandle( tls->hRevert );
        tls->hRevert = NULL;
    }
    return hr;
#endif
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::IsImpersonating, public
//
//  Synopsis:   Return TRUE if ImpersonateClient has been called.
//
//--------------------------------------------------------------------
STDMETHODIMP_(BOOL) CServerSecurity::IsImpersonating()
{
#ifdef _CHICAGO_
    return FALSE;
#else
    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
        return (tls->dwFlags & OLETLS_IMPERSONATING) ? TRUE : FALSE;
    else
        return FALSE;
#endif
}

//---------------------------------------------------------------------------
//
//  Method:     CServerSecurity::operator delete
//
//  Synopsis:   Cache or actually free a server security object.
//
//---------------------------------------------------------------------------
void CServerSecurity::operator delete( void *pSS )
{
    _palloc.ReleaseEntry((PageEntry *)pSS);
}

//---------------------------------------------------------------------------
//
//  Method:     CServerSecurity::operator new
//
//  Synopsis:   Keep a cache of CServerSecuritys.
//
//---------------------------------------------------------------------------
void *CServerSecurity::operator new( size_t size )
{
    Win4Assert(size == sizeof(CServerSecurity));
    return _palloc.AllocEntry();
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::QueryBlanket, public
//
//  Synopsis:   Calls RPC to return the authentication information
//              for the stored binding handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CServerSecurity::QueryBlanket(
                                            DWORD    *pAuthnSvc,
                                            DWORD    *pAuthzSvc,
                                            OLECHAR **pServerPrincName,
                                            DWORD    *pAuthnLevel,
                                            DWORD    *pImpLevel,
                                            void    **pPrivs,
                                            DWORD    *pCapabilities )
{
    HRESULT    hr = S_OK;
    RPC_STATUS sc;
    DWORD      iLen;
    OLECHAR   *pCopy;

    // Initialize the out parameters.  Currently the impersonation level
    // and capabilities can not be determined.
    if (pPrivs != NULL)
        *((void **) pPrivs) = NULL;
    if (pServerPrincName != NULL)
        *pServerPrincName = NULL;
    if (pAuthnSvc != NULL)
        *pAuthnSvc = RPC_C_AUTHN_WINNT;
    if (pAuthnLevel != NULL)
        *pAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    if (pImpLevel != NULL)
        *pImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
    if (pAuthzSvc != NULL)
        *pAuthzSvc = RPC_C_AUTHZ_NONE;
    if (pCapabilities != NULL)
        *pCapabilities = EOAC_NONE;

    // If the call is over, fail this request.
    if (_iFlags & SS_CALL_DONE)
        hr = RPC_E_CALL_COMPLETE;

    // For process local calls, use the defaults. Otherwise ask RPC.
    else if ((_iFlags & SS_PROCESS_LOCAL) == 0)
    {
        sc = RpcBindingInqAuthClientW( _hRpc, pPrivs, pServerPrincName,
                                      pAuthnLevel, pAuthnSvc, pAuthzSvc );

        // Sometimes RPC sets out parameters in error cases.
        if (sc != RPC_S_OK)
        {
            if (pServerPrincName != NULL)
                *pServerPrincName = NULL;
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
        }
        else if (pServerPrincName != NULL && *pServerPrincName != NULL)
        {
            // Reallocate the principle name using the OLE memory allocator.
            iLen = lstrlenW( *pServerPrincName );
            pCopy = (OLECHAR *) CoTaskMemAlloc( (iLen+1) * sizeof(OLECHAR) );
            if (pCopy != NULL)
                lstrcpyW( pCopy, *pServerPrincName );
            else
                hr = E_OUTOFMEMORY;
            RpcStringFree( pServerPrincName );
            *pServerPrincName = pCopy;
        }
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CServerSecurity::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
      IsEqualIID(riid, IID_IServerSecurity))
  {
    *ppvObj = (IServerSecurity *) this;
  }
  else if(IsEqualIID(riid, IID_ICancelMethodCalls))
  {
    *ppvObj = (ICancelMethodCalls *) this;
  }
  else if(IsEqualIID(riid, IID_IComDispatchInfo))
  {
    *ppvObj = (IComDispatchInfo *) this;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }

  AddRef();
  return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CServerSecurity::Release()
{
    ULONG lRef = InterlockedDecrement( (long*) &_iRefCount );

    if (lRef == 0)
    {
        // Don't let anyone call release too many times.
        Win4Assert( _iFlags & SS_CALL_DONE );
        if ((_iFlags & SS_CALL_DONE) == 0)
            DebugBreak();
        else
            delete this;
    }

    return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::RevertToSelf, public
//
//  Synopsis:   If ImpersonateClient was called, then either ask RPC to
//              revert or restore the thread token ourself.
//
//--------------------------------------------------------------------
HRESULT CServerSecurity::RevertToSelf()
{
#ifdef _CHICAGO_
    return S_OK;
#else
    HRESULT    hr;
    RPC_STATUS sc;
    BOOL       fSuccess;
    COleTls    tls(hr);

    // If TLS doesn't initialize, we can't be impersonating.
    if (FAILED(hr))
        return S_OK;

    // Don't do anything if this security object isn't impersonating.
    if (tls->dwFlags & OLETLS_IMPERSONATING)
    {
        // Ask RPC to revert for process remote calls.
        tls->dwFlags &= ~OLETLS_IMPERSONATING;
        if ((_iFlags & SS_PROCESS_LOCAL) == 0)
        {
            sc = RpcRevertToSelfEx( _hRpc );
            if (sc != RPC_S_OK)
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
        }

        // If there was no token before impersonating, NULL the thread token.
        // Note that if we set the token on this thread after impersonating
        // RpcRevertToSelfEx won't remove it, but we have to call
        // RpcRevertToSelfEx to prevent RPC from automaticly reverting later
        // so set the thread token NULL even after calling RpcRevertToSelfEx.
        if (tls->hRevert == NULL)
        {
            fSuccess = SetThreadToken( NULL, NULL );
            if (!fSuccess)
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        }

        // If there was a token before impersonating, put it back.
        // Ignore errors.
        else if (tls->hRevert != NULL)
        {
            SetThreadToken( NULL, tls->hRevert );
            CloseHandle( tls->hRevert );
            tls->hRevert = NULL;
        }
    }
    return hr;
#endif
}

//+-------------------------------------------------------------------
//
//  Method:     CServerSecurity::Cancel     public
//
//  Synopsis:   Not valid on the server side
//
//  History:    July 26, 97     GopalK      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CServerSecurity::Cancel(ULONG ulSeconds)
{
    CairoleDebugOut((DEB_WARN, "Cancel on CServerSecurity:0x%x\n", this));
    return(E_NOTIMPL);
}

//+-------------------------------------------------------------------
//
//  Method:     CServerSecurity::TestCancel     public
//
//  Synopsis:   Answers whether the current call has been canceled
//
//  History:    July 26, 97     GopalK      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CServerSecurity::TestCancel()
{
    RPC_STATUS hr;

    // Check for local case
    if(_pClientCall)
        return(_pClientCall->TestCancel());

    // Non local case
    hr = RpcServerTestCancel(_hRpc);
    if(hr == RPC_S_OK)
        return(RPC_E_CALL_CANCELED);

    return(RPC_S_CALLPENDING);
}

//+-------------------------------------------------------------------
//
//  Method:     CServerSecurity::EnableComInits   public
//
//  Synopsis:   This method allows future STA inits on dispatch threads
//              to succeed
//
//  History:    June 26, 98     GopalK      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CServerSecurity::EnableComInits(void **ppvCookie)
{
    COleTls Tls(TRUE);
    HRESULT hr;

    if(((SOleTlsData *) Tls != NULL) &&
       (Tls->cCalls == 1) &&
       (Tls->dwFlags & OLETLS_DISPATCHTHREAD))
    {
        *ppvCookie = (SOleTlsData *) Tls;
        Tls->dwFlags &= ~OLETLS_DISPATCHTHREAD;
        hr = S_OK;
    }
    else
    {
        *ppvCookie = NULL;
        hr = CO_E_NOT_SUPPORTED;
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CServerSecurity::DisableComInits   public
//
//  Synopsis:   This method disables future STA inits
//
//  History:    June 26, 98     GopalK      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CServerSecurity::DisableComInits(void *pvCookie)
{
    COleTls Tls(TRUE);
    HRESULT hr;

    if((pvCookie != NULL) &&
       ((SOleTlsData *) Tls == pvCookie))
    {
        Tls->dwFlags |= OLETLS_DISPATCHTHREAD;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CSSL::Cleanup
//
//  Synopsis:   Free the handles.
//
//+-------------------------------------------------------------------
void CSSL::Cleanup()
{
    DWORD status;

    _hr = S_FALSE;
    if (_pCert != NULL)
    {
        // This has to succeed because we have to have loaded the DLL in order
        // to have a certificate.
        if (_hCertFreeCertificateContext == NULL)
        {
            status = LoadSystemProc( "crypt32.dll", "CertFreeCertificateContext",
                                     &_hCrypt32,
                                     (FARPROC *) &_hCertFreeCertificateContext );
            Win4Assert( status == NO_ERROR );
        }

        _hCertFreeCertificateContext(_pCert);
        _pCert = NULL;
    }
    if (_hMyStore != NULL)
    {
        // This has to succeed because we have to have loaded the DLL in order
        // to have a store.
        if (_hCertCloseStore == NULL)
        {
            status = LoadSystemProc( "crypt32.dll", "CertCloseStore",
                                     &_hCrypt32, (FARPROC *) &_hCertCloseStore );
            Win4Assert( status == NO_ERROR );
        }

        _hCertCloseStore( _hMyStore, 0 );
        _hMyStore = NULL;
    }
    if (_hRootStore != NULL)
    {
        // This has to succeed because we have to have loaded the DLL in order
        // to have a store.
        if (_hCertCloseStore == NULL)
        {
            status = LoadSystemProc( "crypt32.dll", "CertCloseStore",
                                     &_hCrypt32, (FARPROC *) &_hCertCloseStore );
            Win4Assert( status == NO_ERROR );
        }

        _hCertCloseStore( _hRootStore, 0 );
        _hRootStore = NULL;
    }
    if (_hProvider != 0 )
    {
        CryptReleaseContext(_hProvider, 0);
        _hProvider = NULL;
    }
    if (_hCrypt32 != NULL)
    {
        FreeLibrary(_hCrypt32);
        _hCrypt32                           = NULL;
        _hCertCloseStore                    = NULL;
        _hCertEnumCertificatesInStore       = NULL;
        _hCertFreeCertificateContext        = NULL;
        _hCertOpenSystemStore               = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Method:      CSSL::DefaultCert
//
//  Synopsis:    Try to get a default certificate.
//
//  Description: Only try once.
//
//+-------------------------------------------------------------------
HRESULT CSSL::DefaultCert( PCCERT_CONTEXT *pCert )
{
    BOOL    fSuccess;
    HRESULT hr;
    DWORD   status;

    // Codework - Currently CryptAcquireContext calls CoInitialize which
    // causes a deadlock.  Find a solution when testing SSL.
#ifndef SSL
    return E_NOTIMPL;
#else
    // If this function has already been called, return the previous
    // results.
    if (_hr != S_FALSE)
        if (_pCert != NULL)
        {
            *pCert = _pCert;
            return S_OK;
        }
        else
            return _hr;

    // Open the CSP provider.
    fSuccess = CryptAcquireContext( &_hProvider, NULL, NULL, PROV_RSA_FULL,
                                    CRYPT_VERIFYCONTEXT );
    if (!fSuccess)
    {
        _hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        return _hr;
    }

    // Get the APIs needed from crypt32.dll
    status = LoadSystemProc( "crypt32.dll", "CertOpenSystemStoreW", &_hCrypt32,
                             (FARPROC *) &_hCertOpenSystemStore );
    if (status == NO_ERROR)
    {
        status = LoadSystemProc( "crypt32.dll", "CertEnumCertificatesInStore",
                                 &_hCrypt32,
                                 (FARPROC *) &_hCertEnumCertificatesInStore );

        if (status == NO_ERROR)
        {

            // Open the store for the current user.
            _hMyStore = _hCertOpenSystemStore( _hProvider, L"my" );
            if (_hMyStore != NULL)
            {

                // Get a certificate.
                _pCert = _hCertEnumCertificatesInStore( _hMyStore, NULL );
                if (_pCert != NULL)
                    hr = S_OK;
                else
                    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
            }
            else
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        }
        else
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, status );
    }
    else
        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, status );

    // If something failed, clean up.
    if (FAILED(hr))
        Cleanup();
    *pCert = _pCert;
    _hr    = hr;
    return hr;
#endif
}

//+-------------------------------------------------------------------
//
//  Method:      CSSL::PrincipalName
//
//  Synopsis:    Get a principal name from a certificate.
//
//  Description: Generate a standard or full principal name depending
//               on the capabilities flags.  However, if the standard
//               form fails, try the full form.
//
//  Note:        The string returned must be freed with RpcStringFree.
//
//+-------------------------------------------------------------------
HRESULT CSSL::PrincipalName( const CERT_CONTEXT *pApp, WCHAR **pSSL )
{
    RPC_STATUS status = RPC_S_INTERNAL_ERROR;

    //  If the EOAC_MAKE_FULLSIC flag is not set, try the standard form.
    if ((gCapabilities & EOAC_MAKE_FULLSIC) == 0)
        status = RpcCertGeneratePrincipalName( pApp, 0, pSSL );

    // If the EOAC_MAKE_FULLSIC flag is set or the standard function failed,
    // try the full form.
    if (status != RPC_S_OK)
        status = RpcCertGeneratePrincipalName( pApp, RPC_C_FULL_CERT_CHAIN, pSSL );

    if (status == RPC_S_OK)
        return S_OK;
    else
        return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, status );
}

//+-------------------------------------------------------------------
//
//  Function:   DefaultAuthnServices, private
//
//  Synopsis:   Register authentication services with RPC and build
//              a string array of authentication services and principal
//              names that were successfully registered.
//
//              Build the best security bindings possible and ignore
//              errors since the user may not need security.
//
//--------------------------------------------------------------------
HRESULT DefaultAuthnServices()
{
    HRESULT                hr;
    DWORD                  i;
    SECURITYBINDING       *pSecBind   = (SECURITYBINDING *)
                  &gpsaSecurity->aStringArray[gpsaSecurity->wSecurityOffset];
    WCHAR                 *pPrincName = NULL;
    DWORD                  lNameLen   = gpsaSecurity->wNumEntries - 5;
    USHORT                *pNextString;
    DUALSTRINGARRAY       *pOld;
    DWORD                  cwBinding  = 0;
    BOOL                  *aSuccess   = (BOOL *) _alloca( sizeof(BOOL) *
                                                          gServerSvcListLen );
    WCHAR                 *pKerberos  = NULL;
    WCHAR                 *pSnego     = NULL;
    WCHAR                 *pSSL       = NULL;
    const CERT_CONTEXT    *pCert;

    ASSERT_LOCK_HELD(gComLock);
    Win4Assert( gGotSecurityData );

    if (gpsaSecurity->aStringArray[gpsaSecurity->wSecurityOffset] != 0)
		pPrincName = &pSecBind->aPrincName;
	
    // Return if the security bindings are already computed.
    if (!gDefaultService)
        return S_OK;

    // Make sure NTLM is first in the list because some NT 4 and Windows
    // 95 machines try to use Kerberos or Snego even thought they don't
    // support then.
    if (gServerSvcList[0] != RPC_C_AUTHN_WINNT)
        for (i = 1; i < gServerSvcListLen; i++)
            if (gServerSvcList[i] == RPC_C_AUTHN_WINNT)
            {
                gServerSvcList[i] = gServerSvcList[0];
                gServerSvcList[0] = RPC_C_AUTHN_WINNT;
                break;
            }

    // Loop over the server service list.
    for (i = 0; i < gServerSvcListLen; i++)
    {
        // Compute the certificate and principal name for SSL.
        // Register SSL.
        if (gServerSvcList[i] == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            aSuccess[i] = FALSE;
            hr = CSSL::DefaultCert( &pCert );
            if (SUCCEEDED(hr))
            {
                // Initialize the schannel credential structure.
                memset( &gSchannelCred, 0, sizeof(gSchannelCred) );
                gSchannelContext        = pCert;
                gSchannelCred.dwVersion = SCHANNEL_CRED_VERSION;
                gSchannelCred.cCreds    = 1;
                gSchannelCred.paCred    = &gSchannelContext;

                // Register SSL.
                hr = RpcServerRegisterAuthInfoW( NULL, RPC_C_AUTHN_GSS_SCHANNEL,
                                                 NULL, (WCHAR *) &gSchannelCred );

                // Figure out how much space to save.
                if (SUCCEEDED(hr))
                {
                    hr = CSSL::PrincipalName( pCert, &pSSL );
                    if (SUCCEEDED(hr))
                    {
                        cwBinding += lstrlenW( pSSL ) + 3;
                        aSuccess[i] = TRUE;
                    }
                }
            }
        }

        else if (gServerSvcList[i] == RPC_C_AUTHN_GSS_KERBEROS)
        {
            aSuccess[i] = FALSE;
            hr = LookupPrincName( RPC_C_AUTHN_GSS_KERBEROS, &pKerberos );
            if (SUCCEEDED(hr))
            {
                hr = RpcServerRegisterAuthInfoW( pKerberos,
                                                 RPC_C_AUTHN_GSS_KERBEROS,
                                                 NULL, NULL );

                // Figure out how much space to save.
                if (SUCCEEDED(hr))
                {
                    cwBinding += lstrlenW( pKerberos ) + 3;
                    aSuccess[i] = TRUE;
                }
            }

        }

        else if (gServerSvcList[i] == RPC_C_AUTHN_GSS_NEGOTIATE)
        {
            aSuccess[i] = FALSE;
            hr = LookupPrincName( RPC_C_AUTHN_GSS_NEGOTIATE, &pSnego );
            if (SUCCEEDED(hr))
            {
                hr = RpcServerRegisterAuthInfoW( pSnego,
                                                 RPC_C_AUTHN_GSS_NEGOTIATE,
                                                 NULL, NULL );

                // Figure out how much space to save.
                if (SUCCEEDED(hr))
                {
                    cwBinding += lstrlenW( pSnego ) + 3;
                    aSuccess[i] = TRUE;
                }
            }

        }

        // Register other authentication services.
        else
        {
            hr = RpcServerRegisterAuthInfoW( pPrincName, gServerSvcList[i],
                                             NULL, NULL );

            // Figure out how much space to save.
            if (SUCCEEDED(hr))
            {
                aSuccess[i] = TRUE;
                cwBinding += lNameLen + 3;
            }
            else
                aSuccess[i] = FALSE;
        }
    }

    // Allocate memory for the string array.  Include space for the header,
    // each security binding, 2 nulls to say there are no protocol sequences,
    // and two nulls if the list is empty (one of them is included in the
    // size of the header).
    pOld = gpsaSecurity;
    gpsaSecurity = (DUALSTRINGARRAY *) PrivMemAlloc( sizeof(DUALSTRINGARRAY) +
                                             (cwBinding + 3) * sizeof(WCHAR) );
    if (gpsaSecurity != NULL)
    {
        // Fill in the array of security information. First two characters
        // are NULLs to signal empty binding strings.
        gDefaultService               = FALSE;
        gpsaSecurity->wSecurityOffset = 2;
        gpsaSecurity->aStringArray[0] = 0;
        gpsaSecurity->aStringArray[1] = 0;
        pNextString                   = &gpsaSecurity->aStringArray[2];

        for (i = 0; i < gServerSvcListLen; i++)
        {
            // Fill in the security bindings for authentication services
            // that registered successfully.
            if (aSuccess[i])
            {
                // Fill in authentication service and authorization service.
                *(pNextString++) = gServerSvcList[i];
                *(pNextString++) = COM_C_AUTHZ_NONE;

                // For SSL, use the generated principal name.
                if (gServerSvcList[i] == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                    lstrcpyW( (LPWSTR)pNextString, pSSL );
                    pNextString += lstrlenW(pSSL)+1;
                }

                // For Kerberos, use the appropriate principal name.
                else if (gServerSvcList[i] == RPC_C_AUTHN_GSS_KERBEROS)
                {
                    lstrcpyW( (LPWSTR)pNextString, pKerberos );
                    pNextString += lstrlenW(pKerberos)+1;
                }

                // Same goes for SNEGO.
                else if (gServerSvcList[i] == RPC_C_AUTHN_GSS_NEGOTIATE)
                {
                    lstrcpyW( (LPWSTR)pNextString, pSnego );
                    pNextString += lstrlenW(pSnego)+1;
                }

                // Otherwise use the principal name from the process token.
                else
                {
                    if (pPrincName == NULL)
                        *pNextString = 0;
                    else
                        memcpy( pNextString, pPrincName, lNameLen*sizeof(USHORT) );
                    pNextString += lNameLen;
                }
            }
        }

        // Add a final NULL.  Special case an empty list which requires
        // two NULLs.
        *(pNextString++) = 0;
        if (pNextString == &gpsaSecurity->aStringArray[3])
            *(pNextString++) = 0;
        gpsaSecurity->wNumEntries = (USHORT)
                                  (pNextString-gpsaSecurity->aStringArray);
        hr = S_OK;
        PrivMemFree( pOld );
    }

    // If the memory allocation failed, don't change the string bindings.
    else
    {
        hr           = E_OUTOFMEMORY;
        gpsaSecurity = pOld;
    }

    // Cleanup interm memory allocations.
    RpcStringFree( &pSSL );
    PrivMemFree( pKerberos );
    PrivMemFree( pSnego );
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   DefaultAuthnSvc
//
//  Synopsis:   Return the index in the security binding of the
//              default authentication service.  If the server is
//              machine local, find NTLM.  Otherwise, find a security
//              provider available on both the client and server.
//              If there are several matches, select the first one
//              from the client's authentication service list.  If
//              there are no matches return an index past the end of
//              the security binding.
//
//--------------------------------------------------------------------

DWORD DefaultAuthnSvc( OXIDEntry *pOxid )
{
    USHORT                       wNext;
    USHORT                       wFirst;
    USHORT                       wServer;
    DWORD                        i;
    DWORD                        lIndex;

    ASSERT_LOCK_HELD(gComLock);
    DUALSTRINGARRAY *pBinding = pOxid->GetBinding();

    // For machine local servers, always pick NTLM
    if (pOxid->IsOnLocalMachine())
        return GetAuthnSvcIndexForBinding ( RPC_C_AUTHN_WINNT, pBinding );

    // For machine remote servers, find a match.
    else
    {
        // Look through all the authentication services in the interface
        // till we find one that works on this machine.

        wNext  = pBinding->wSecurityOffset;
        wFirst = 0xffff;
        lIndex = 0xffffffff;
        while (wNext < pBinding->wNumEntries &&
               pBinding->aStringArray[wNext] != 0)
        {
            // Don't use Kerberos or Snego to talk to old builds because they
            // register those ids even thought they don't support them.
            wServer = pBinding->aStringArray[wNext];
            if (pOxid->GetComVersion().MinorVersion > 3 ||
                (wServer != RPC_C_AUTHN_GSS_KERBEROS &&
                 wServer != RPC_C_AUTHN_GSS_NEGOTIATE))
            {
                i = LocalAuthnService( wServer );
                if (i != -1)
                {
                    if (i < lIndex)
                    {
                        lIndex = i;
                        wFirst = wNext;
                    }
                }
            }

            // Skip to the next authentication service.
            wNext += lstrlenW( (LPCWSTR)&pBinding->aStringArray[wNext] ) + 1;
        }

        // If there was a match, return its index.
        if (wFirst != 0xffff)
            return wFirst;

        // Otherwise return a bad index.
        else
            return pBinding->wNumEntries;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   DefaultBlanket
//
//  Synopsis:   Compute the default security blanket for the specified
//              authentication service.
//              The authentication level is the higher of the process
//              default and the level in the interface.  The
//              impersonation level is the process default.
//
//--------------------------------------------------------------------

HRESULT DefaultBlanket( DWORD lAuthnSvc, OXIDEntry *pOxid, SBlanket *pBlanket )
{
    USHORT                       wAuthnSvc;
    USHORT                       wNext;
    WCHAR                       *pEnd;
    DWORD                        cbAuthId;
    DWORD                        i;
    DWORD                        lIndex;
    SECURITYBINDING             *pSecBind;
    SEC_WINNT_AUTH_IDENTITY_EXW *pAuthId;

    ASSERT_LOCK_HELD(gComLock);

    // Pick the highest authentication level between the process default
    // and the interface hint.
    if (pBlanket->_lAuthnLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
        if (gAuthnLevel > pOxid->GetAuthnHint())
            pBlanket->_lAuthnLevel = gAuthnLevel;
        else
            pBlanket->_lAuthnLevel = pOxid->GetAuthnHint();

    // Compute the quality of service parameter.
    pBlanket->_lCapabilities           = gCapabilities & VALID_BLANKET_FLAGS;
    pBlanket->_sQos.Version            = RPC_C_SECURITY_QOS_VERSION;
    pBlanket->_sQos.ImpersonationType  = gImpLevel;
    pBlanket->_sQos.Capabilities       = RPC_C_QOS_CAPABILITIES_DEFAULT;
    if (gCapabilities & EOAC_DYNAMIC_CLOAKING)
        pBlanket->_sQos.IdentityTracking   = RPC_C_QOS_IDENTITY_DYNAMIC;
    else
        pBlanket->_sQos.IdentityTracking   = RPC_C_QOS_IDENTITY_STATIC;

    // [Sergei O. Ivanov (sergei), 7/20/2000]
    // This fixes a number of bugs that surface when cAuthSvc
    // is -1 in an earlier user call to CoInitalizeSecurity.

    // Fill in the schannel cred structure.
    memset( &pBlanket->_sCred, 0, sizeof(pBlanket->_sCred) );
    pBlanket->_sCred.dwVersion = SCHANNEL_CRED_VERSION;
    pBlanket->_sCred.cCreds    = 1;
    pBlanket->_sCred.paCred    = &pBlanket->_pCert;
    pBlanket->_pCert           = NULL;

    // If the index is bad or the default authentication level is none,
    // make up return values.
    DUALSTRINGARRAY *pBinding = pOxid->GetBinding();
    if (pBinding == NULL                   ||
        lAuthnSvc >= pBinding->wNumEntries ||
        pBlanket->_lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
    {
        if (pBlanket->_lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
            pBlanket->_lAuthnSvc     = RPC_C_AUTHN_NONE;
        else
            pBlanket->_lAuthnSvc     = RPC_C_AUTHN_WINNT;
        pBlanket->_pPrincipal    = NULL;
        pBlanket->_pAuthId       = NULL;
        pBlanket->_lAuthzSvc     = RPC_C_AUTHZ_NONE;

        return S_OK;
    }

    // Get the principal name.
    pSecBind = (SECURITYBINDING *) &pBinding->aStringArray[lAuthnSvc];
    pBlanket->_pPrincipal = (WCHAR *)&pSecBind->aPrincName;
    if (pBlanket->_pPrincipal[0] == 0)
        pBlanket->_pPrincipal = NULL;

    // For SChannel, work around the case when server certificate
    // has no email and MSSTD format name is sent from the server
    if (pSecBind->wAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL
        && pBlanket->_pPrincipal != NULL
        && lstrcmpi(pBlanket->_pPrincipal, L"msstd:") == 0)
        return CO_E_MALFORMED_SPN;

#ifdef _CHICAGO_
    // If the principal name is not known, the server must be
    // NT.  Replace the principal name in that case
    // because a NULL principal name is a flag for some
    // Chicago security hack.
    if (pBlanket->_pPrincipal == NULL &&
        pSecBind->wAuthnSvc == RPC_C_AUTHN_WINNT)
        pBlanket->_pPrincipal = L"Default";
#endif // _CHICAGO_

    // Fix up the authorization service.
    pBlanket->_lAuthnSvc = pSecBind->wAuthnSvc;
    pBlanket->_lAuthzSvc = pSecBind->wAuthzSvc;
    if (pBlanket->_lAuthzSvc == COM_C_AUTHZ_NONE)
        pBlanket->_lAuthzSvc = RPC_C_AUTHZ_NONE;

    // For Snego, build the special authid parameter.
    if (pBinding->aStringArray[lAuthnSvc] == RPC_C_AUTHN_GSS_NEGOTIATE)
    {
        // Only build the snego authid parameter if it doesn't exist.
        if (pOxid->GetAuthId() == NULL)
        {
            // Compute the size of the authentication service name strings.
            wNext  = pBinding->wSecurityOffset;
            cbAuthId = sizeof(*pAuthId);
            while (wNext < pBinding->wNumEntries &&
                   (wAuthnSvc = pBinding->aStringArray[wNext]) != 0)
            {
                if (LocalAuthnService( wAuthnSvc ) != -1)
                {
                    if (wAuthnSvc != RPC_C_AUTHN_GSS_NEGOTIATE)
                        cbAuthId += (lstrlenW( AuthnName( wAuthnSvc ) ) + 1)*
                                    sizeof(WCHAR);
                }

                // Skip to the next authentication service.
                wNext += lstrlenW( (LPCWSTR)&pBinding->aStringArray[wNext] ) + 1;
            }

            // Allocate the authentication identity structure.
            pAuthId = (SEC_WINNT_AUTH_IDENTITY_EXW *) PrivMemAlloc( cbAuthId );
            if (pAuthId == NULL)
                return E_OUTOFMEMORY;
            pOxid->SetAuthId(pAuthId);

            // Initialize it.
            pEnd                       = (WCHAR *) (pAuthId+1);
            pAuthId->Version           = SEC_WINNT_AUTH_IDENTITY_VERSION;
            pAuthId->Length            = sizeof(*pAuthId);
            pAuthId->User              = NULL;
            pAuthId->UserLength        = 0;
            pAuthId->Domain            = NULL;
            pAuthId->DomainLength      = 0;
            pAuthId->Password          = NULL;
            pAuthId->PasswordLength    = 0;
            pAuthId->Flags             = SEC_WINNT_AUTH_IDENTITY_UNICODE;
            pAuthId->PackageList       = (unsigned short *)pEnd;
            pAuthId->PackageListLength = (cbAuthId - sizeof(*pAuthId)) /
                                         sizeof(WCHAR);

            // Copy in the authentication service name strings.
            wNext  = pBinding->wSecurityOffset;
            for (i = 0; i < gClientSvcListLen; i++)
                if (gClientSvcList[i].wId != RPC_C_AUTHN_GSS_NEGOTIATE)
                {
                    lIndex = RemoteAuthnService( gClientSvcList[i].wId,
                                                 pBinding );
                    if (lIndex != -1)
                    {
                        lstrcpyW( pEnd, AuthnName( gClientSvcList[i].wId ) );
                        pEnd      += lstrlenW( pEnd );
                        pEnd[0]    = L',';
                        pEnd      += 1;
                    }
                }
            pEnd   -= 1;
            pEnd[0] = 0;
        }
        pBlanket->_pAuthId = pOxid->GetAuthId();
    }

    // For all other security providers, look up the authid parameter.
    else
    {

        // Find the authentication information only for remote machines.
        if (!(pOxid->IsOnLocalMachine()))
            pBlanket->_pAuthId = CAuthInfo::Find( pSecBind );
        else
            pBlanket->_pAuthId = NULL;

        if (pSecBind->wAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            // Verify that the principal name for SSL is in the correct form.
            if ((gCapabilities & EOAC_REQUIRE_FULLSIC) &&
                 (pBlanket->_pPrincipal == NULL ||
                  wcsncmp( pBlanket->_pPrincipal, FULL_SUBJECT_ISSUER_CHAIN,
                      sizeof(FULL_SUBJECT_ISSUER_CHAIN) ) != 0))
                return RPC_E_FULLSIC_REQUIRED;

            // Fill in the schannel cred structure.
            pBlanket->_pCert = (PCCERT_CONTEXT) pBlanket->_pAuthId;

            if (pBlanket->_pCert)
                pBlanket->_pAuthId = (void *) &pBlanket->_sCred;
        }
    }
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   FixupAccessControl, internal
//
//  Synopsis:   Get the access control class id.  Instantiate the access
//              control class and load the data.
//
//  Notes:      The caller has already insured that the structure is
//              at least as big as a SPermissionHeader structure.
//
//--------------------------------------------------------------------
HRESULT FixupAccessControl( SECURITY_DESCRIPTOR **pSD, DWORD cbSD )
{
    SPermissionHeader *pHeader;
    IAccessControl    *pControl = NULL;
    IPersistStream    *pPersist = NULL;
    CNdrStream         cStream( ((unsigned char *) *pSD) + sizeof(SPermissionHeader),
                                cbSD - sizeof(SPermissionHeader) );
    HRESULT            hr;

    // Get the class id.
    pHeader = (SPermissionHeader *) *pSD;

    // Instantiate the class.
    hr = CoCreateInstance( pHeader->gClass, NULL, CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                           IID_IAccessControl, (void **) &pControl );

    // Get IPeristStream
    if (SUCCEEDED(hr))
    {
        hr = pControl->QueryInterface( IID_IPersistStream, (void **) &pPersist );

        // Load the stream.
        if (SUCCEEDED(hr))
            hr = pPersist->Load( &cStream );
    }

    // Release resources.
    if (pPersist != NULL)
        pPersist->Release();
    if (SUCCEEDED(hr))
    {
        PrivMemFree( *pSD );
        *pSD = (SECURITY_DESCRIPTOR *) pControl;
    }
    else if (pControl != NULL)
        pControl->Release();
    return hr;
}



//+-------------------------------------------------------------------
//
//  Function:   FixupSecurityDescriptor, internal
//
//  Synopsis:   Convert the security descriptor from self relative to
//              absolute form and check for errors.
//
//--------------------------------------------------------------------
HRESULT FixupSecurityDescriptor( SECURITY_DESCRIPTOR **pSD, DWORD cbSD )
{

#ifdef _WIN64

    DWORD local_cbSD = cbSD;
    if ( MakeAbsoluteSD2( *pSD, &local_cbSD ) == FALSE )
    {
        // Failed to convert the self-relative SD to absolute.  Let's see if
        // we can figure out why and if we can do something about it.

        HRESULT hr = REGDB_E_INVALIDVALUE;

        if (local_cbSD > cbSD)
        {
            // The buffer containing the self-relative security descriptor is
            // not big enough to convert to absolute form.  To correct this:
            // allocate a new buffer, copy the contents of the existing buffer
            // into it, release the original buffer, and try to convert again.

            hr = E_OUTOFMEMORY;
            SECURITY_DESCRIPTOR *pASD = (SECURITY_DESCRIPTOR *) PrivMemAlloc(local_cbSD);
            if (pASD)
            {
                CopyMemory(pASD, *pSD, cbSD);

                SECURITY_DESCRIPTOR *pTemp = *pSD;
                *pSD = pASD;
                PrivMemFree(pTemp);

                if ( MakeAbsoluteSD2( *pSD, &local_cbSD ) == FALSE )
                    hr = REGDB_E_INVALIDVALUE;
            }
        }
    }
#else  // !_WIN64

    // Fix up the security descriptor.
    (*pSD)->Control &= ~SE_SELF_RELATIVE;
    (*pSD)->Sacl     = NULL;
    if ((*pSD)->Dacl != NULL)
    {
        if (cbSD < (sizeof(ACL) + sizeof(SECURITY_DESCRIPTOR)) ||
            (ULONG) (*pSD)->Dacl > cbSD - sizeof(ACL))
            return REGDB_E_INVALIDVALUE;
        (*pSD)->Dacl = (ACL *) (((char *) *pSD) + ((ULONG) (*pSD)->Dacl));
        if ((*pSD)->Dacl->AclSize + sizeof(SECURITY_DESCRIPTOR) > cbSD)
            return REGDB_E_INVALIDVALUE;
    }

    // Set up the owner and group SIDs.
    if ((*pSD)->Group == 0 || ((ULONG) (*pSD)->Group) + sizeof(SID) > cbSD ||
        (*pSD)->Owner == 0 || ((ULONG) (*pSD)->Owner) + sizeof(SID) > cbSD)
        return REGDB_E_INVALIDVALUE;
    (*pSD)->Group = (SID *) (((BYTE *) *pSD) + (ULONG) (*pSD)->Group);
    (*pSD)->Owner = (SID *) (((BYTE *) *pSD) + (ULONG) (*pSD)->Owner);

#endif // !_WIN64

    // Check the security descriptor.
#if DBG==1
    if (!IsValidSecurityDescriptor( *pSD ))
        return REGDB_E_INVALIDVALUE;
#endif

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   GetLegacyBlanket, internal
//
//  Synopsis:   Get a security blanket for the current app.  First,
//              look under the app id for the current exe name.  If that
//              fails look up the default descriptor.  If that fails,
//              create one.
//
//  Note: It is possible that the security descriptor size could change
//  during the size computation.  Add code to retry.
//
//--------------------------------------------------------------------
HRESULT GetLegacyBlanket( SECURITY_DESCRIPTOR **pSD, DWORD *pCapabilities,
                          DWORD *pAuthnLevel)
{
    extern GUID g_AppId;

    // Holds either Appid\{guid} or Appid\module_name.
    WCHAR   aKeyName[MAX_PATH+7] = L"";
 // But first it holds nothing.
    HRESULT hr;
    HKEY    hKey   = NULL;
    DWORD   lSize;
    WCHAR   aModule[MAX_PATH];
    DWORD   cModule;
    DWORD   i;
    WCHAR   aAppid[40];         // Hold a registry GUID.
    DWORD   lType;
    BOOL    fContinue = TRUE;

    // If the flag EOAC_APPID is set, the security descriptor contains the
    // app id.
    if ((*pCapabilities & EOAC_APPID) && *pSD != NULL)
    {
        if (StringFromIID2( *((GUID *) *pSD), aAppid, sizeof(aAppid) / sizeof(WCHAR) ) == 0)
            return RPC_E_UNEXPECTED;

        // Open the application id key.  A GUID in the registry is stored.
        // as a 38 character string.
        lstrcpyW( aKeyName, L"AppID\\" );
        memcpy( &aKeyName[6], aAppid, 39*sizeof(WCHAR) );
        hr = wRegOpenKeyEx( HKEY_CLASSES_ROOT, aKeyName,
                            NULL, KEY_READ, &hKey );
        Win4Assert( hr == ERROR_SUCCESS || hKey == NULL );

        g_AppId = *((GUID *) (*pSD));
    }

    // Look up the app id from the exe name.
    else
    {
        // Get the executable's name.  Find the start of the file name.
        cModule = GetModuleFileName( NULL, aModule, MAX_PATH );
        if (cModule >= MAX_PATH)
        {
            Win4Assert( !"Module name too long." );
            return RPC_E_UNEXPECTED;
        }
        for (i = cModule-1; i > 0; i--)
            if (aModule[i] == '/' ||
                aModule[i] == '\\' ||
                aModule[i] == ':')
                break;
        if (i != 0)
            i += 1;

        // Open the key for the EXE's module name.
        lstrcpyW( aKeyName, L"AppID\\" );
        memcpy( &aKeyName[6], &aModule[i], (cModule - i + 1) * sizeof(WCHAR) );
        hr = wRegOpenKeyEx( HKEY_CLASSES_ROOT, aKeyName,
                            NULL, KEY_READ, &hKey );
        Win4Assert( hr == ERROR_SUCCESS || hKey == NULL );

        // Look for an application id.
        if (hr == ERROR_SUCCESS)
        {
            lSize = sizeof(aAppid);
            hr = RegQueryValueEx( hKey, L"AppID", NULL, &lType,
                                  (unsigned char *) &aAppid, &lSize );
            RegCloseKey( hKey );
            hKey = NULL;

            // Open the application id key.  A GUID in the registry is stored.
            // as a 38 character string.
            if (hr == ERROR_SUCCESS && lType == REG_SZ &&
                lSize == 39*sizeof(WCHAR))
            {
                memcpy( &aKeyName[6], aAppid, 39*sizeof(WCHAR) );
                hr = wRegOpenKeyEx( HKEY_CLASSES_ROOT, aKeyName,
                                    NULL, KEY_READ, &hKey );
                Win4Assert( hr == ERROR_SUCCESS || hKey == NULL );
            }
        }
    }

    // Get the authentication level.
    *pSD = NULL;
    hr   = S_OK;
    GetRegistryAuthnLevel( hKey, pAuthnLevel );

    // If the authentication level is not none, get a security descriptor.
    if (*pAuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
    {

        // Use the appid key to open access permissions.
        if (hKey != NULL)
        {
            hr = GetRegistrySecDesc( hKey, L"AccessPermission",
                                     pSD, pCapabilities, &fContinue );
            RegCloseKey( hKey );
            hKey = NULL;
        }

        // If the appid access permission does not exist, try the default
        // access permission.
        if (fContinue)
        {
            // Open the default key.
            hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\OLE",
                               NULL, KEY_READ, &hKey );
            Win4Assert( hr == ERROR_SUCCESS || hKey == NULL );

            // Get the security descriptor from the registry.
            if (hr == ERROR_SUCCESS)
            {
                hr = GetRegistrySecDesc( hKey, L"DefaultAccessPermission",
                                         pSD, pCapabilities, &fContinue );

                // If that failed, make one.
                if (fContinue)
                    hr = MakeSecDesc( pSD, pCapabilities );
            }
            else
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, hr );
        }
    }

    // Free the security descriptor memory if anything failed.
    if (FAILED(hr))
    {
        PrivMemFree( *pSD );
        *pSD = NULL;
    }

    // Close the registry keys.
    if (hKey != NULL)
        RegCloseKey( hKey );
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   GetRegistryAuthnLevel, internal
//
//  Synopsis:   Look for the authentication level under the appid.
//              If not found, use the default.
//
//--------------------------------------------------------------------
void GetRegistryAuthnLevel( HKEY hKey, DWORD *pAuthnLevel )

{
    DWORD   lType;
    HRESULT hr;
    DWORD   cbDword = sizeof(DWORD);

    // If there is no key, use the default.
    if (hKey == NULL)
        *pAuthnLevel = gAuthnLevel;

    // Get the authentication level
    else
    {
        hr = RegQueryValueEx( hKey, L"AuthenticationLevel", NULL, &lType,
                             (unsigned char *) pAuthnLevel, &cbDword );

        // If it wasn't present use the default.
        if (hr != ERROR_SUCCESS)
            *pAuthnLevel = gAuthnLevel;

        // If the type was wrong, use a bad value.
        else if (lType != REG_DWORD || cbDword != sizeof(DWORD))
            *pAuthnLevel = 0xffffffff;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   GetRegistrySecDesc, internal
//
//  Synopsis:   Read a security descriptor from the registry.
//              Convert it from self relative to
//              absolute form.  Stuff in an owner and a group.
//
//  Notes:      pContinue indicates whether or not the security
//              descriptor exists in the registry.  TRUE means it does not.
//
//              pContinue is assumed to be TRUE on entry.  If the
//              security descriptor is read correctly, or it exists but
//              is bad, or it may exist, set pContinue FALSE.
//
//              The caller must free the security descriptor in both the
//              success and failure cases.
//
//--------------------------------------------------------------------
HRESULT GetRegistrySecDesc( HKEY hKey, WCHAR *pAccessName,
                            SECURITY_DESCRIPTOR **pSD, DWORD *pCapabilities,
                            BOOL *pContinue )

{
    SID    *pGroup;
    SID    *pOwner;
    DWORD   cbSD = 256, cbAlloc = cbSD;
    DWORD   lType;
    HRESULT hr;
    WORD    wVersion;

    // Guess how much memory to allocate for the security descriptor.
    size_t stDeltaSize = 0;

#ifdef _WIN64

    // Make sure that the initially allocated buffer has space for the size difference between the
    // disk representation and the memory representation of security descriptors
    stDeltaSize = sizeof( SECURITY_DESCRIPTOR ) - sizeof( SECURITY_DESCRIPTOR_RELATIVE );

    Win4Assert (stDeltaSize < sizeof( SECURITY_DESCRIPTOR ));

    stDeltaSize = OLE2INT_ROUND_UP( stDeltaSize, sizeof(PVOID) );
    cbAlloc += stDeltaSize;

#endif // _WIN64


    *pContinue = FALSE;
    *pSD = (SECURITY_DESCRIPTOR *) PrivMemAlloc( cbAlloc );
    if (*pSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Find put how much memory to allocate for the security
    // descriptor.
    hr = RegQueryValueEx( hKey, pAccessName, NULL, &lType,
                         (unsigned char *) *pSD, &cbSD );
    if (hr != ERROR_SUCCESS && hr != ERROR_MORE_DATA)
    {
        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, hr );
        *pContinue = TRUE;
        goto cleanup;
    }
    if (lType != REG_BINARY || cbSD < sizeof(SECURITY_DESCRIPTOR_RELATIVE))
    {
        hr = REGDB_E_INVALIDVALUE;
        goto cleanup;
    }

    // If the first guess wasn't large enough, reallocate the memory.
    if (hr == ERROR_MORE_DATA)
    {
        PrivMemFree( *pSD );

        cbAlloc = cbSD + stDeltaSize;
        *pSD = (SECURITY_DESCRIPTOR *) PrivMemAlloc( cbAlloc );
        if (*pSD == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        // Read the security descriptor.
        hr = RegQueryValueEx( hKey, pAccessName, NULL, &lType,
                              (unsigned char *) *pSD, &cbSD );
        if (hr != ERROR_SUCCESS)
        {
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, hr );
            *pContinue = TRUE;
            goto cleanup;
        }
        if (lType != REG_BINARY || cbSD < sizeof(SECURITY_DESCRIPTOR_RELATIVE))
        {
            hr = REGDB_E_INVALIDVALUE;
            goto cleanup;
        }
    }

    // Check the first DWORD to determine what type of data is in the
    // registry value.
    wVersion = *((WORD *) *pSD);
#ifndef _CHICAGO_
    if (wVersion == COM_PERMISSION_SECDESC)
        hr = FixupSecurityDescriptor( pSD, cbAlloc);
    else
#endif
    if (wVersion == COM_PERMISSION_ACCCTRL)
    {
        hr = FixupAccessControl( pSD, cbSD );
        if (SUCCEEDED(hr))
            *pCapabilities |= EOAC_ACCESS_CONTROL;
    }
    else
        hr = REGDB_E_INVALIDVALUE;

cleanup:
    if (FAILED(hr))
    {
        PrivMemFree( *pSD );
        *pSD = NULL;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   HashSid
//
//  Synopsis:   Create a 32 bit hash of a SID.
//
//--------------------------------------------------------------------
DWORD HashSid( SID *pSid )
{
    DWORD          lHash = 0;
    DWORD          cbSid = GetLengthSid( pSid );
    DWORD          i;
    unsigned char *pData = (unsigned char *) pSid;

    for (i = 0; i < cbSid; i++)
        lHash = (lHash << 1) + *pData++;
    return lHash;
}

//+-------------------------------------------------------------------
//
//  Function:   InitializeSecurity, internal
//
//  Synopsis:   Called the first time the channel is used.  If the app
//              has not initialized security yet, this function sets
//              up legacy security.
//
//--------------------------------------------------------------------
HRESULT InitializeSecurity()
{
    HRESULT  hr = S_OK;

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // skip if already initialized.
    if (gpsaSecurity == NULL)
    {
        // Initialize.  All parameters are ignored except the security descriptor
        // since the capability is set to app id.
        hr = CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                   RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_APPID,
                                   NULL );

        // Convert confusing error codes.
        if (hr == E_INVALIDARG)
            hr = REGDB_E_INVALIDVALUE;
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   IsCallerLocalSystem
//
//  Synopsis:   Impersonate the caller and do an ACL check.  The first
//              time this function is called, create the ACL
//
//  History:    14 Jul 00 Sergei        Modified to work inside both
//                                      COM and RPC calls
//
//--------------------------------------------------------------------
BOOL IsCallerLocalSystem(handle_t hRpc)
{
    HRESULT              hr          = S_OK;
    DWORD                granted_access;
    BOOL                 access;
    HANDLE               token;
    DWORD                privilege_size = sizeof(gPriv);
    BOOL                 success;
    SECURITY_DESCRIPTOR *pSecDesc = NULL;
    DWORD                lIgnore;

    ASSERT_LOCK_NOT_HELD(gComLock);

    // If the security descriptor does not exist, create it.
    if (gRundownSD == NULL)
    {
        // Make the security descriptor.
        hr = MakeSecDesc( &pSecDesc, &lIgnore );

        // Save the security descriptor.
        LOCK(gComLock);
        if (gRundownSD == NULL)
            gRundownSD = pSecDesc;
        else
            PrivMemFree( pSecDesc );
        UNLOCK(gComLock);
    }

    // Impersonate.
    if (SUCCEEDED(hr))
    {
        if(!hRpc)
            hr = CoImpersonateClient();
        else
            hr = RpcImpersonateClient(hRpc);
    }

    // Get the thread token.
    if (SUCCEEDED(hr))
    {
        success = OpenThreadToken( GetCurrentThread(), TOKEN_READ,
                                   TRUE, &token );
        if (!success)
            hr = E_FAIL;
    }

    // Check access.
    if (SUCCEEDED(hr))
    {
        success = AccessCheck( gRundownSD, token, COM_RIGHTS_EXECUTE,
                               &gMap, &gPriv, &privilege_size,
                               &granted_access, &access );
        if (!success || !access)
            hr = E_FAIL;
        CloseHandle( token );
    }

    // Just call revert since it detects whether or not the impersonate
    // succeeded.
    if(!hRpc)
        CoRevertToSelf();
    else
        RpcRevertToSelfEx(hRpc);

    ASSERT_LOCK_NOT_HELD(gComLock);

    return SUCCEEDED(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   LocalAuthnService
//
//  Synopsis:   Returns the index of the specified authentication
//              service in gClientSvcListLen or -1.
//
//--------------------------------------------------------------------
DWORD LocalAuthnService( USHORT wAuthnService )
{
    DWORD l;

    for (l = 0; l < gClientSvcListLen; l++)
        if (gClientSvcList[l].wId == wAuthnService)
            return l;
    return -1;
}

#ifndef _CHICAGO_
//+-------------------------------------------------------------------
//
//  Function:   LookupPrincName, private
//
//  Synopsis:   Open the process token and find the user's name.
//
//  Notes:      NTLM includes a special case for LocalSystem - in this case
//              we want need to construct "NT Authority\System" as the
//              principal name.  This is the default returned by SID
//              lookup.  For all other authentication services we need
//              to use LsaQueryInformationPolicy.
//
//--------------------------------------------------------------------
HRESULT LookupPrincName( USHORT wAuthnSvc, WCHAR **pPrincName )
{
    HRESULT            hr          = S_OK;
    BYTE               aMemory[SIZEOF_TOKEN_USER];
    TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
    HANDLE             hToken      = NULL;
    DWORD              lSize;
    DWORD              lNameLen    = 80;
    DWORD              lDomainLen  = 80;
    WCHAR             *pUserName   = NULL;
    SID_NAME_USE       sIgnore;
    BOOL               fSuccess;
    HANDLE             hThread;
    BOOL	       bPrepend$ = FALSE;
     
    // Suspend the thread token.
    SuspendImpersonate( &hThread );

    // Open the process's token.
    *pPrincName = NULL;
    if (OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
    {

        // Lookup SID of process token.
        if (GetTokenInformation( hToken, TokenUser, pTokenUser, sizeof(aMemory),
                                 &lSize ))
        {
            // Preallocate some memory (including the '$').
            lSize       = lNameLen+lDomainLen+2;
            *pPrincName = (WCHAR *) PrivMemAlloc( lSize*sizeof(WCHAR) );
            pUserName   = (WCHAR *) _alloca( lNameLen*sizeof(WCHAR) );

            if (*pPrincName != NULL && pUserName != NULL)
            {
                // The name for local system varies depending on the authentication
                // service.  Use "NT Authority\System" (returned by LookupAccountSid
                // for NTLM and LsaQueryInformationPolicy for everything else.
                if (wAuthnSvc != RPC_C_AUTHN_WINNT &&
                    EqualSid( (PVOID) &LOCAL_SYSTEM_SID, pTokenUser->User.Sid ))
                {
                    if (GetComputerName(pUserName, &lNameLen))
                    {
                        LSA_HANDLE                  hLSA;
                        LSA_OBJECT_ATTRIBUTES       oaLSA;
                        POLICY_PRIMARY_DOMAIN_INFO *pPrimaryDomainInfo;

                        memset( &oaLSA, 0, sizeof (LSA_OBJECT_ATTRIBUTES) );
                        oaLSA.Length = sizeof (LSA_OBJECT_ATTRIBUTES);

                        hr = LsaOpenPolicy( NULL,
                                            &oaLSA,
                                            POLICY_VIEW_LOCAL_INFORMATION,
                                            &hLSA );

                        if (hr == ERROR_SUCCESS)
                        {
                            hr = LsaQueryInformationPolicy( hLSA,
                                                            PolicyPrimaryDomainInformation,
                                                            (void **) &pPrimaryDomainInfo );

                            if (hr == ERROR_SUCCESS)
                            {
                                lstrcpyW( *pPrincName,
                                          pPrimaryDomainInfo->Name.Buffer );
				bPrepend$ = TRUE;
                                LsaFreeMemory( pPrimaryDomainInfo );
                            }
                            LsaClose(hLSA);
                        }

                        if (hr != ERROR_SUCCESS)
                            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, hr );
                    }
                    else
                        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
                }

                else
                {
                    // Find the user's name.
                    fSuccess = LookupAccountSidW( NULL, pTokenUser->User.Sid,
                                                  pUserName, &lNameLen,
                                                  *pPrincName, &lDomainLen,
                                                  &sIgnore );

                    // If the call failed, try allocating more memory.
                    if (!fSuccess)
                    {

                        // Allocate memory for the user's name.
                        PrivMemFree( *pPrincName );
                        *pPrincName = (WCHAR *) PrivMemAlloc(
                                        (lNameLen+lDomainLen+1)*sizeof(WCHAR) );
                        pUserName   = (WCHAR *) _alloca(
                                        lNameLen*sizeof(WCHAR) );
                        if (*pPrincName != NULL && pUserName != NULL)
                        {

                            // Find the user's name.
                            if (!LookupAccountSidW( NULL, pTokenUser->User.Sid,
                                                    pUserName, &lNameLen,
                                                    *pPrincName, &lDomainLen,
                                                    &sIgnore ))
                                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        CloseHandle( hToken );
    }
    else
        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

    // Restore the thread token.
    ResumeImpersonate( hThread );

    if (hr != S_OK)
    {
        PrivMemFree( *pPrincName );
        *pPrincName = NULL;
    }

    // Append the user name.
    else
    {
        lstrcatW( *pPrincName, L"\\" );
        lstrcatW( *pPrincName, pUserName );
	if (bPrepend$) 
	{
	   lstrcatW( *pPrincName, L"$" );
	}
    }
    return hr;
}

#else // _CHICAGO_
//+-------------------------------------------------------------------
//
//  Function:   LookupPrincName, private
//
//  Synopsis:   We have a service other than NTLMSSP.
//              Find the first (!) such and find the user's name.
//
//--------------------------------------------------------------------
HRESULT LookupPrincName( WCHAR **pPrincName )
{
    // assume failure lest thou be disappointed
    RPC_STATUS status = RPC_S_INVALID_AUTH_IDENTITY;

    *pPrincName = NULL;

    for (ULONG i = 0; i < gServerSvcListLen; i++)
    {
        if (gServerSvcList[i] != RPC_C_AUTHN_WINNT)
        {
            status = RpcServerInqDefaultPrincNameW(
                         gServerSvcList[i],
                         pPrincName);
            if (status == RPC_S_OK)
            {
            break;
            }
        }
    }

    return HRESULT_FROM_WIN32(status);
}

#endif // _CHICAGO_

#if 0 // #ifdef _CHICAGO_
//+-------------------------------------------------------------------
//
//  Function:   MakeSecDesc, private
//
//  Synopsis:   Make an access control that allows the current user
//              access.
//
//  NOTE: NetWkstaGetInfo does not return the size needed unless the size
//        in is zero.
//
//--------------------------------------------------------------------
HRESULT MakeSecDesc( SECURITY_DESCRIPTOR **pSD, DWORD *pCapabilities )
{
    HRESULT                   hr         = S_OK;
    IAccessControl           *pAccess    = NULL;
    DWORD                     cTrustee;
    WCHAR                    *pTrusteeW;
    char                     *pTrusteeA;
    DWORD                     cDomain;
    DWORD                     cUser;
    char                     *pBuffer;
    struct wksta_info_10     *wi10;
    USHORT                    cbBuffer;
    HINSTANCE                 hMsnet;
    NetWkstaGetInfoFn         fnNetWkstaGetInfo;
    ACTRL_ACCESSW             sAccessList;
    ACTRL_PROPERTY_ENTRYW     sProperty;
    ACTRL_ACCESS_ENTRY_LISTW  sEntryList;
    ACTRL_ACCESS_ENTRYW       sEntry;

    // Load msnet32.dll
    hMsnet = LoadLibraryA( "msnet32.dll" );
    if (hMsnet == NULL)
        return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

    // Get the function NetWkstaGetInfo.
    fnNetWkstaGetInfo = (NetWkstaGetInfoFn) GetProcAddress( hMsnet,
                                                            (char *) 57 );
    if (fnNetWkstaGetInfo == NULL)
    {
        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        goto cleanup;
    }

    // Find out how much space to allocate for the domain and user names.
    cbBuffer = 0;
    fnNetWkstaGetInfo( NULL, 10, NULL, 0, &cbBuffer );
    pBuffer = (char *) _alloca( cbBuffer );

    // Get the domain and user names.
    hr = fnNetWkstaGetInfo( NULL, 10, pBuffer, cbBuffer, &cbBuffer );
    if (hr != 0)
    {
        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, hr );
        goto cleanup;
    }

    // Stick the user name and domain name in the same string.
    wi10      = (struct wksta_info_10 *) pBuffer;
    Win4Assert( wi10->wki10_logon_domain != NULL );
    Win4Assert( wi10->wki10_username != NULL );
    cDomain   = lstrlenA( wi10->wki10_logon_domain );
    cUser     = lstrlenA( wi10->wki10_username );
    pTrusteeA = (char *) _alloca( cDomain+cUser+2 );
    lstrcpyA( pTrusteeA, wi10->wki10_logon_domain );
    lstrcpyA( &pTrusteeA[cDomain+1], wi10->wki10_username );
    pTrusteeA[cDomain] = '\\';

    // Find out how long the name is in Unicode.
    cTrustee = MultiByteToWideChar( GetConsoleCP(), 0, pTrusteeA,
                                    cDomain+cUser+2, NULL, 0 );

    // Convert the name to Unicode.
    pTrusteeW = (WCHAR *) _alloca( cTrustee * sizeof(WCHAR) );
    if (!MultiByteToWideChar( GetConsoleCP(), 0, pTrusteeA,
                              cDomain+cUser+2, pTrusteeW, cTrustee ))
    {
        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        goto cleanup;
    }

    // Create an AccessControl.
    *pSD = NULL;
    hr = CoCreateInstance( CLSID_DCOMAccessControl, NULL,
                           CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                           IID_IAccessControl, (void **) &pAccess );
    if (FAILED(hr))
        goto cleanup;

    // Give the current user access.
    sAccessList.cEntries                    = 1;
    sAccessList.pPropertyAccessList         = &sProperty;
    sProperty.lpProperty                    = NULL;
    sProperty.pAccessEntryList              = &sEntryList;
    sProperty.fListFlags                    = 0;
    sEntryList.cEntries                     = 1;
    sEntryList.pAccessList                  = &sEntry;
    sEntry.fAccessFlags                     = ACTRL_ACCESS_ALLOWED;
    sEntry.Access                           = COM_RIGHTS_EXECUTE;
    sEntry.ProvSpecificAccess               = 0;
    sEntry.Inheritance                      = NO_INHERITANCE;
    sEntry.lpInheritProperty                = NULL;
    sEntry.Trustee.pMultipleTrustee         = NULL;
    sEntry.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    sEntry.Trustee.TrusteeForm              = TRUSTEE_IS_NAME;
    sEntry.Trustee.TrusteeType              = TRUSTEE_IS_USER;
    sEntry.Trustee.ptstrName                = pTrusteeW;
    hr = pAccess->GrantAccessRights( &sAccessList );

cleanup:
    FreeLibrary( hMsnet );
    if (SUCCEEDED(hr))
    {
        *pSD = (SECURITY_DESCRIPTOR *) pAccess;
        *pCapabilities |= EOAC_ACCESS_CONTROL;
    }
    else if (pAccess != NULL)
        pAccess->Release();
    return hr;
}

#else
//+-------------------------------------------------------------------
//
//  Function:   MakeSecDesc, private
//
//  Synopsis:   Make a security descriptor that allows the current user
//              and local system access.
//
//  NOTE: Compute the length of the sids used rather then using constants.
//
//--------------------------------------------------------------------
HRESULT MakeSecDesc( SECURITY_DESCRIPTOR **pSD, DWORD *pCapabilities )
{
    HRESULT            hr         = S_OK;
    ACL               *pAcl;
    DWORD              lSidLen;
    SID               *pGroup;
    SID               *pOwner;
    BYTE               aMemory[SIZEOF_TOKEN_USER];
    TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
    HANDLE             hToken      = NULL;
    DWORD              lIgnore;
    HANDLE             hThread;

    Win4Assert( *pSD == NULL );

    // Open the process's token.
    if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
    {
        // If the thread has a token, remove it and try again.
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE, TRUE,
                              &hThread ))
            return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        if (!SetThreadToken( NULL, NULL ))
        {
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
            CloseHandle( hThread );
            return hr;
        }
        if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        SetThreadToken( NULL, hThread );
        CloseHandle( hThread );
        if (FAILED(hr))
            return hr;
    }

    // Lookup SID of process token.
    if (!GetTokenInformation( hToken, TokenUser, pTokenUser, sizeof(aMemory),
                                 &lIgnore ))
        goto last_error;

    // Compute the length of the SID.
    lSidLen = GetLengthSid( pTokenUser->User.Sid );
    Win4Assert( lSidLen <= SIZEOF_SID );

    // Allocate the security descriptor.
    *pSD = (SECURITY_DESCRIPTOR *) PrivMemAlloc(
                  sizeof(SECURITY_DESCRIPTOR) + 2*lSidLen + SIZEOF_ACL );
    if (*pSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    pGroup = (SID *) (*pSD + 1);
    pOwner = (SID *) (((BYTE *) pGroup) + lSidLen);
    pAcl   = (ACL *) (((BYTE *) pOwner) + lSidLen);

    // Initialize a new security descriptor.
    if (!InitializeSecurityDescriptor(*pSD, SECURITY_DESCRIPTOR_REVISION))
        goto last_error;

    // Initialize a new ACL.
    if (!InitializeAcl(pAcl, SIZEOF_ACL, ACL_REVISION2))
        goto last_error;

    // Allow the current user access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              pTokenUser->User.Sid))
        goto last_error;

    // Allow local system access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              (void *) &LOCAL_SYSTEM_SID ))
        goto last_error;

    // Add a new ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl( *pSD, TRUE, pAcl, FALSE ))
        goto last_error;

    // Set the group.
    memcpy( pGroup, pTokenUser->User.Sid, lSidLen );
    if (!SetSecurityDescriptorGroup( *pSD, pGroup, FALSE ))
        goto last_error;

    // Set the owner.
    memcpy( pOwner, pTokenUser->User.Sid, lSidLen );
    if (!SetSecurityDescriptorOwner( *pSD, pOwner, FALSE ))
        goto last_error;

    // Check the security descriptor.
#if DBG==1
    if (!IsValidSecurityDescriptor( *pSD ))
    {
        Win4Assert( !"COM Created invalid security descriptor." );
        goto last_error;
    }
#endif

    goto cleanup;
last_error:
    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

cleanup:
    if (hToken != NULL)
        CloseHandle( hToken );
    if (FAILED(hr))
    {
        PrivMemFree( *pSD );
        *pSD = NULL;
    }
    return hr;
}
#endif

//+-------------------------------------------------------------------
//
//  Function:   OpenThreadTokenAtLevel
//
//  Synopsis:   Open the thread token and duplicate it to the specified
//              impersonation level.  If there is no thread token
//              return success and NULL.  If there is an identify
//              level token, return an error.
//
//--------------------------------------------------------------------
HRESULT OpenThreadTokenAtLevel( DWORD lImpReq, HANDLE *pToken )
{
    BOOL                         fSuccess;
    DWORD                        status     = S_OK;

    // COM+ 22868: This used to be like this. But this looks wrong,
    // since we need TOKEN_IMPERSONATE right to restore thread token.
    // Further, access to a token object is not the same as token
    // imp level. Access mask is property of a handle whereas imp level
    // is a property of a token object itself.
    //
    //DWORD                        dwOpen     = ImpLevelToAccess[lImpReq];

    DWORD                        dwOpen = TOKEN_QUERY | TOKEN_IMPERSONATE;
    DWORD                        dwOpenWithDup;
    SECURITY_IMPERSONATION_LEVEL eDuplicate = ImpLevelToSecLevel[lImpReq];
    HANDLE                       hThread;
    DWORD                        lImpTok;
    DWORD                        lIgnore;
    BOOL                         fClose;


    // Open the thread token, first with TOKEN_DUPLICATE since some code paths
    // require that we dup the token:
    *pToken = NULL;
    dwOpenWithDup = dwOpen | TOKEN_DUPLICATE;
    fSuccess= OpenThreadToken( GetCurrentThread(), dwOpenWithDup, TRUE, &hThread );
    if (!fSuccess)
    {
      // Hmm.  For some reason we failed to get the thread token with
      // TOKEN_DUPLICATE.    Well, for some cases this will not be fatal.  Try
      // again without it, and maybe things will work:
      fSuccess= OpenThreadToken( GetCurrentThread(), dwOpen, TRUE, &hThread );
    }

    if (fSuccess)
    {
        // Remove the thread token.  Ignore errors.
        fClose = TRUE;
        SetThreadToken( NULL, NULL );

        // Check the impersonation level.
        fSuccess = GetTokenInformation( hThread, TokenImpersonationLevel,
                                        &lImpTok, sizeof(lImpTok), &lIgnore );

        if (fSuccess)
        {
            // Don't allow identify level tokens.
            if (lImpTok < SecurityImpersonation)
                status = RPC_E_ACCESS_DENIED;

            else
            {
                // If the impersonation level is correct, return the
                // current token.
                if (lImpTok+1 <= lImpReq)
                {
                    *pToken = hThread;
                    fClose  = FALSE;
                }

                // Duplication the token to the correct level.
                else
                    fSuccess = DuplicateToken( hThread, eDuplicate, pToken );
            }
        }

        // Restore the thread token.  Ignore errors.
        SetThreadToken( NULL, hThread );

        // Close the thread token.  Ignore errors.
        if (fClose)
            CloseHandle( hThread );
    }

    // Convert a status code to a HRESULT and convert ERROR_NO_TOKEN to
    // success.
    if (!fSuccess)
    {
        status = GetLastError();
        if (status != ERROR_NO_TOKEN)
            return MAKE_WIN32( status );
        else
            return S_OK;
    }
    return status;
}

//+-------------------------------------------------------------------
//
//  Function:   RegisterAuthnServices, public
//
//  Synopsis:   Register the specified services.  Build a security
//              binding.
//
//--------------------------------------------------------------------
HRESULT RegisterAuthnServices(  DWORD                        cAuthSvc,
                                SOLE_AUTHENTICATION_SERVICE *asAuthSvc )
{
    DWORD                        i;
    RPC_STATUS                   sc;
    USHORT                       wNumEntries = 0;
    USHORT                      *pNext;
    HRESULT                      hr;
    DWORD                        lNameLen;
    WCHAR                       *pSSL        = NULL;
    WCHAR                       *pPrincipal;
    const CERT_CONTEXT          *pCert;
    SOLE_AUTHENTICATION_SERVICE *pService    = asAuthSvc;
    WCHAR                       *pArg        = NULL;

    ASSERT_LOCK_HELD(gComLock);

    // Register all the authentication services specified.
    for (i = 0; i < cAuthSvc; i++)
    {
        // Validate the parameters.
        pPrincipal = pService->pPrincipalName;
        if (pPrincipal == COLE_DEFAULT_PRINCIPAL        ||
            pService->dwAuthnSvc == RPC_C_AUTHN_DEFAULT ||
            pService->dwAuthzSvc == RPC_C_AUTHZ_DEFAULT)
            hr = E_INVALIDARG;

        // Determine a principal name for SSL.
        else if (pService->dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
#ifndef SSL
            // Don't allow SSL until bug fixes are checked in.
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, RPC_S_UNKNOWN_AUTHN_SERVICE );
#else
            // If no certificate is specified, try to find a default.
            if (pPrincipal == NULL)
                hr = CSSL::DefaultCert( &pCert );
            else
            {
                pCert = (PCCERT_CONTEXT) pPrincipal;
                if (pCert == NULL)
                    hr = E_INVALIDARG;
                else
                    hr = S_OK;
            }

            // Initialize the schannel credential structure.
            memset( &gSchannelCred, 0, sizeof(gSchannelCred) );
            gSchannelContext        = pCert;
            gSchannelCred.dwVersion = SCHANNEL_CRED_VERSION;
            gSchannelCred.cCreds    = 1;
            gSchannelCred.paCred    = &gSchannelContext;
            pArg                    = (WCHAR *) &gSchannelCred;

            // Compute the principal name from the certificate.
            if (SUCCEEDED(hr))
            {
                hr = CSSL::PrincipalName( pCert, &pSSL );
                if (SUCCEEDED(hr))
                    pPrincipal = (WCHAR *) pCert;
            }
#endif
        }
        else
        {
            pArg = NULL;
            hr = S_OK;
        }

        // Register the authentication service.
        if (SUCCEEDED(hr))
        {
            sc = RpcServerRegisterAuthInfoW( pPrincipal, pService->dwAuthnSvc,
                                             NULL, pArg );

            // If the registration failed, store the failure code.
            if (sc != RPC_S_OK)
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
        }

        // If everything is ok for this entry, determine how much space to
        // reserve.
        if (SUCCEEDED(hr))
        {
            // For SSL we registered the cert, not the principal name.
            if (pService->dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
                pPrincipal = pSSL;

            // Find the length of the security binding with or without a
            // principal name.
            pService->hr = S_OK;
            if (pPrincipal != NULL)
                wNumEntries += lstrlenW( pPrincipal ) + 3;
            else
                wNumEntries += 3;
        }

        // Save any failure codes.
        else
            pService->hr = hr;

        pService += 1;
    }

    // It is an error for all registrations to fail.
    if (wNumEntries == 0)
        hr = RPC_E_NO_GOOD_SECURITY_PACKAGES;

    // If some services were registered, build a string array.
    else
    {
        // Make room for the two NULLs that placehold for the empty
        // string binding and the trailing NULL.
        wNumEntries += 3;
        gpsaSecurity = (DUALSTRINGARRAY *) PrivMemAlloc(
                     wNumEntries*sizeof(USHORT) + sizeof(DUALSTRINGARRAY) );
        if (gpsaSecurity == NULL)
            hr = E_OUTOFMEMORY;
        else
        {
            gpsaSecurity->wNumEntries     = wNumEntries;
            gpsaSecurity->wSecurityOffset = 2;
            gpsaSecurity->aStringArray[0] = 0;
            gpsaSecurity->aStringArray[1] = 0;
            pNext                         = &gpsaSecurity->aStringArray[2];
            pService                      = asAuthSvc;

            for (i = 0; i < cAuthSvc; i++)
            {
                if (pService->hr == S_OK)
                {
                    // Fill in authentication service, authorization service,
                    // and principal name.
                    *(pNext++) = (USHORT) pService->dwAuthnSvc;
                    *(pNext++) = (USHORT) (pService->dwAuthzSvc == 0 ?
                                                  COM_C_AUTHZ_NONE :
                                                  pService->dwAuthzSvc);
                    if (pService->dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
                    {
                        lNameLen = lstrlenW( pSSL ) + 1;
                        memcpy( pNext, pSSL, lNameLen*sizeof(USHORT) );
                        pNext += lNameLen;
                    }
                    else if (pService->pPrincipalName != NULL)
                    {
                        lNameLen = lstrlenW( pService->pPrincipalName ) + 1;
                        memcpy( pNext, pService->pPrincipalName,
                                lNameLen*sizeof(USHORT) );
                        pNext += lNameLen;
                    }
                    else
                        *(pNext++) = 0;
                }
                pService += 1;
            }
            *pNext = 0;

            hr = S_OK;
        }
    }

    // Free interm strings.
    RpcStringFree( &pSSL );
    ASSERT_LOCK_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   RemoteAuthnService
//
//  Synopsis:   Returns the index of the specified authentication
//              service in the specified dual string array or -1.
//
//--------------------------------------------------------------------
DWORD RemoteAuthnService( USHORT wAuthnService, DUALSTRINGARRAY *pRemote )
{
    DWORD l;

    // Loop over all the security elements.
    l = pRemote->wSecurityOffset;
    while (pRemote->aStringArray[l] != 0)
        if (pRemote->aStringArray[l] == wAuthnService)
            return l;
        else
            l += lstrlenW( (LPCWSTR)&pRemote->aStringArray[l] ) + 1;
    return -1;
}



//+-------------------------------------------------------------------
//
//  Function:   StrEscByteCnt
//
//  Synopsis:   Return the number of bytes of memory needed to hold
//              the specified string including the null terminator
//              and add space so StrEscCopy can replace all slashes
//              with double slashes
//
//--------------------------------------------------------------------
DWORD StrEscByteCnt( WCHAR *pStr )
{
    DWORD cLen = 2;

    while (*pStr != 0)
    {
        if (*pStr == '\\')
            cLen += 4;
        else
            cLen += 2;
        pStr += 1;
    }
    return cLen;
}

//+-------------------------------------------------------------------
//
//  Function:   StrEscCopy
//
//  Synopsis:   Return the number of bytes of memory needed to hold
//              the specified string including the null terminator
//              and replacing all slashes with double slashes.  Return
//              a pointer to the null terminator in the destinition
//              string.
//
//--------------------------------------------------------------------
WCHAR *StrEscCopy( WCHAR *pDest, WCHAR *pSrc )
{
    WCHAR c;

    // Copy the source and escape any slashes.
    while ((c = *pSrc++) != 0)
        if (c == '\\')
        {
            *pDest++ = '\\';
            *pDest++ = '\\';
        }
        else
            *pDest++ = c;

    // Add the final null terminiation.
    *pDest = 0;
    return pDest;
}

//+-------------------------------------------------------------------
//
//  Function:   StrQual
//
//  Synopsis:   Find a CN= or E= prefix in the specified string.
//              Return a pointer to the string after the prefix.
//              Replace the next comma with a NULL.
//
//--------------------------------------------------------------------
WCHAR *StrQual( WCHAR *pSubject, BOOL *pEmail )
{
    WCHAR *pComma;
    WCHAR *pEqual = &pSubject[1];

    // Fail if the string is empty.
    if (pSubject == NULL || pSubject[0] == '\0')
        return NULL;

    // Check each equal sign.
    while (pEqual != NULL)
    {
        // Find the next equal sign.
        pEqual = wcschr( pEqual, L'=' );

        if (pEqual != NULL)
        {
            if (pEqual[-1] == L'e' || pEqual[-1] == L'E')
            {
                *pEmail = TRUE;
                break;
            }
            if ((pEqual[-1] == L'n' || pEqual[-1] == L'N') &&
                pEqual - pSubject > 1)
                if (pEqual[-2] == 'c' || pEqual[-2] == 'C')
                {
                    *pEmail = FALSE;
                    break;
                }

            // Skip past the equal sign.
            pEqual += 1;
        }
    }

    // If a match was found, null terminate it.
    if (pEqual != NULL)
    {
        pComma = wcschr( pEqual, L',' );
        if (pComma != NULL)
            *pComma = 0;
        return pEqual + 1;
    }
    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   GetAuthnSvcIndexForBinding
//
//  Synopsis:   Find the index of the specified authentication service
//              in the specified security binding.
//
//--------------------------------------------------------------------
DWORD GetAuthnSvcIndexForBinding ( DWORD lAuthnSvc, DUALSTRINGARRAY *pBinding )
{
    USHORT wNext;

    // Return zero for process local bindings.
    if (pBinding == NULL)
        return 0;

    // Loop over the security binding.
    wNext = pBinding->wSecurityOffset;
    while (wNext < pBinding->wNumEntries &&
           pBinding->aStringArray[wNext] != 0)
    {
        // Return the index of the authentication service.
        if (pBinding->aStringArray[wNext] == lAuthnSvc)
            return wNext;

        // Skip to the next authentication service.
        wNext += lstrlenW( (LPCWSTR)&pBinding->aStringArray[wNext] ) + 1;
    }

    // The authentication service isn't in the list.  Return a bad index.
    return pBinding->wNumEntries;
}

//+-------------------------------------------------------------------
//
//  Function:   UninitializeSecurity, internal
//
//  Synopsis:   Free resources allocated while initializing security.
//
//--------------------------------------------------------------------
void UninitializeSecurity()
{
    DWORD i;

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    PrivMemFree(gSecDesc);
    PrivMemFree(gpsaSecurity);
    PrivMemFree( gRundownSD );
#ifndef SHRMEM_OBJEX
    for (i = 0; i < gClientSvcListLen; i++)
        MIDL_user_free( gClientSvcList[i].pName );
    MIDL_user_free( gClientSvcList );
    MIDL_user_free( gServerSvcList );
    MIDL_user_free( gLegacySecurity );
#else // SHRMEM_OBJEX
    delete [] gClientSvcList;
    delete [] gServerSvcList;
    delete [] gLegacySecurity;
#endif // SHRMEM_OBJEX
    for (i = 0; i < ACCESS_CACHE_LEN; i++)
    {
        gAccessCache[i].lClient.LowPart  = 0;
        gAccessCache[i].lClient.HighPart = 0;
    }

    gConnectionCache.Cleanup();
    if (gAccessControl != NULL)
        gAccessControl->Release();

    CAuthInfo::Cleanup();
    CSSL::Cleanup();
    gAccessControl         = NULL;
    gSecDesc               = NULL;
    gAuthnLevel            = RPC_C_AUTHN_LEVEL_NONE;
    gImpLevel              = RPC_C_IMP_LEVEL_IDENTIFY;
    gCapabilities          = EOAC_NONE;
    gLegacySecurity        = NULL;
    gpsaSecurity           = NULL;
    gClientSvcList         = NULL;
    gServerSvcList         = NULL;
    gClientSvcListLen      = 0;
    gGotSecurityData       = FALSE;
    gRundownSD             = NULL;
    gDefaultService        = FALSE;
    gMostRecentAccess      = 0;

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\stream.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994 Microsoft Corporation.  All rights reserved.

Module Name:
    stream.cxx

Abstract:
    Implements the IStream interface on a memory buffer.

Author:
    ShannonC    09-Mar-1994

Environment:
    Windows NT and Windows 95.  We do not support DOS and Win16.

Revision History:
    12-Oct-94   ShannonC    Reformat for code review.

--*/

#include <ole2int.h>
#include <stream.hxx>

CNdrStream::CNdrStream(
    IN  unsigned char * pData,
    IN  unsigned long   cbMax)
    : pBuffer(pData), cbBufferLength(cbMax)
/*++

Routine Description:
    This function creates a stream on the specified memory buffer.

Arguments:
    pData - Supplies pointer to memory buffer.
    cbMax - Supplies size of memory buffer.

Return Value:
    None.

--*/
{
    RefCount = 1;
    position = 0;
}


ULONG STDMETHODCALLTYPE
CNdrStream::AddRef()
/*++

Routine Description:
    Increment the reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    InterlockedIncrement(&RefCount);
    return (ULONG) RefCount;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Clone(
    OUT IStream **ppstm)
/*++

Routine Description:
    Create a new IStream object.  The new IStream gets an
    independent seek pointer but it shares the underlying
    data buffer with the original IStream object.

Arguments:
    ppstm - Pointer to the new stream.

Return Value:
    S_OK            - The stream was successfully copied.
    E_OUTOFMEMORY   - The stream could not be copied due to lack of memory.

--*/
{
    HRESULT     hr;
    CNdrStream *pStream = new CNdrStream(pBuffer, cbBufferLength);

    if(pStream != 0)
    {
        pStream->position = position;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    *ppstm = (IStream *) pStream;

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Commit(
    IN DWORD grfCommitFlags)
/*++

Routine Description:
    This stream does not support transacted mode.  This function does nothing.

Arguments:
    grfCommitFlags

Return Value:
    S_OK

--*/
{
  return S_OK;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::CopyTo(
    IN  IStream *       pstm,
    IN  ULARGE_INTEGER  cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Routine Description:
    Copies data from one stream to another stream.

Arguments:
    pstm        - Specifies the destination stream.
    cb          - Specifies the number of bytes to be copied to the destination stream.
    pcbRead     - Returns the number of bytes read from the source stream.
    pcbWritten  - Returns the number of bytes written to the destination stream.

Return Value:
    S_OK        - The data was successfully copied.
    Other errors from IStream::Write.

--*/
{
    HRESULT         hr;
    unsigned char * pSource;
    unsigned long   cbRead;
    unsigned long   cbWritten;
    unsigned long   cbRemaining;

    //Check if we are going off the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if((cb.HighPart == 0) && (cb.LowPart <= cbRemaining))
        cbRead = cb.LowPart;
    else
        cbRead = cbRemaining;

    pSource = pBuffer + position;

    //copy the data
    hr = pstm->Write(pSource, cbRead, &cbWritten);

    //advance the current position
    position += cbRead;

    if (pcbRead != 0)
    {
        pcbRead->LowPart = cbRead;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten != 0)
    {
        pcbWritten->LowPart = cbWritten;
        pcbWritten->HighPart = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::LockRegion(
    IN ULARGE_INTEGER   libOffset,
    IN ULARGE_INTEGER   cb,
    IN DWORD            dwLockType)
/*++

Routine Description:
    Range locking is not supported by this stream.

Return Value:
    STG_E_INVALIDFUNCTION.

--*/
{
    return STG_E_INVALIDFUNCTION;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::QueryInterface(
    REFIID riid,
    void **ppvObj)
/*++

Routine Description:
    Query for an interface on the stream.  The stream supports
    the IUnknown and IStream interfaces.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    HRESULT hr;

    if ((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
       (memcmp(&riid, &IID_IStream, sizeof(IID)) == 0))
    {
        this->AddRef();
        *ppvObj = (IStream *) this;
        hr = S_OK;
    }
    else
    {
        *ppvObj = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Read(
    OUT void * pv,
    IN  ULONG  cb,
    OUT ULONG *pcbRead)
/*++

Routine Description:
    Reads data from the stream starting at the current seek pointer.

Arguments:
    pv      - Returns the data read from the stream.
    cb      - Supplies the number of bytes to read from the stream.
    pcbRead - Returns the number of bytes actually read from the stream.

Return Value:
    S_OK    - The data was successfully read from the stream.
    S_FALSE - The number of bytes read was smaller than the number requested.

--*/
{
    HRESULT         hr;
    unsigned long   cbRead;
    unsigned long   cbRemaining;

    //Check if we are reading past the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if(cb <= cbRemaining)
    {
        cbRead = cb;
        hr = S_OK;
    }
    else
    {
        cbRead = cbRemaining;
        hr = S_FALSE;
    }

    //copy the data
    memcpy(pv, pBuffer + position, cbRead);

    //advance the current position
    position += cbRead;

    if(pcbRead != 0)
        *pcbRead = cbRead;

    return hr;
}

ULONG STDMETHODCALLTYPE
CNdrStream::Release()
/*++

Routine Description:
    Decrement the reference count.  When the reference count
    reaches zero, the stream is deleted.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG count = InterlockedDecrement(&RefCount);

    if(count == 0)
    {
        delete this;
    }

    return count;
}


HRESULT STDMETHODCALLTYPE
CNdrStream::Revert()
/*++

Routine Description:
    This stream does not support transacted mode.  This function does nothing.

Arguments:
    None.

Return Value:
    S_OK.

--*/
{
  return S_OK;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Seek(
    IN  LARGE_INTEGER   dlibMove,
    IN  DWORD           dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition)
/*++

Routine Description:
    Sets the position of the seek pointer.  It is an error to seek
    before the beginning of the stream or past the end of the stream.

Arguments:
    dlibMove        - Supplies the offset from the position specified in dwOrigin.
    dwOrigin        - Supplies the seek mode.
    plibNewPosition - Returns the new position of the seek pointer.

Return Value:
    S_OK                    - The seek pointer was successfully adjusted.
    STG_E_INVALIDFUNCTION   - dwOrigin contains invalid value.
    STG_E_SEEKERROR         - The seek pointer cannot be positioned before the
                              beginning of the stream or past the
                              end of the stream.

--*/
{
    HRESULT         hr;
    long            high;
    long            low;
    unsigned long   offset;
    unsigned long   cbRemaining;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        //Set the seek position relative to the beginning of the stream.
        if((dlibMove.HighPart == 0) && (dlibMove.LowPart <= cbBufferLength))
        {
            position = dlibMove.LowPart;
            hr = S_OK;
        }
        else
        {
            //It is an error to seek past the end of the stream.
            hr = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:
        //Set the seek position relative to the current position of the stream.
        high = (long) dlibMove.HighPart;
        if(high < 0)
        {
            //Negative offset
            low = (long) dlibMove.LowPart;
            offset = -low;

            if((high == -1) && (offset <= position))
            {
                position -= offset;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek before the beginning of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        else
        {
            //Positive offset
            if(position < cbBufferLength)
                cbRemaining = cbBufferLength - position;
            else
                cbRemaining = 0;

            if((dlibMove.HighPart == 0) && (dlibMove.LowPart <= cbRemaining))
            {
                position += dlibMove.LowPart;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek past the end of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        break;

    case STREAM_SEEK_END:
    //Set the seek position relative to the end of the stream.
        high = (long) dlibMove.HighPart;
        if(high < 0)
        {
            //Negative offset
            low = (long) dlibMove.LowPart;
            offset = -low;

            if((high == -1) && (offset <= cbBufferLength))
            {
                position = cbBufferLength - offset;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek before the beginning of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        else if(dlibMove.QuadPart == 0)
        {
            position = cbBufferLength;
            hr = S_OK;
        }
        else
        {
            //Positive offset
            //It is an error to seek past the end of the stream.
            hr = STG_E_SEEKERROR;
        }
        break;

    default:
        //dwOrigin contains an invalid value.
        hr = STG_E_INVALIDFUNCTION;
    }

    if (plibNewPosition != 0)
    {
        plibNewPosition->LowPart = position;
        plibNewPosition->HighPart = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::SetSize(
    IN ULARGE_INTEGER libNewSize)
/*++

Routine Description:
    Changes the size of the stream.

Arguments:
    libNewSize - Supplies the new size of the stream.

Return Value:
    S_OK                - The stream size was successfully changed.
    STG_E_MEDIUMFULL    - The stream size could not be changed.

--*/
{
    HRESULT hr;

    if((libNewSize.HighPart == 0) && (libNewSize.LowPart <= cbBufferLength))
    {
        cbBufferLength = libNewSize.LowPart;
        hr = S_OK;
    }
    else
    {
        hr = STG_E_MEDIUMFULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Stat(
    OUT STATSTG *   pstatstg,
    IN  DWORD       grfStatFlag)
/*++

Routine Description:
    This function gets information about this stream.

Arguments:
    pstatstg    - Returns information about this stream.
    grfStatFlg  - Specifies the information to be returned in pstatstg.

Return Value:
    S_OK.

--*/
{
    memset(pstatstg, 0, sizeof(STATSTG));
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.LowPart = cbBufferLength;
    pstatstg->cbSize.HighPart = 0;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::UnlockRegion(
    IN ULARGE_INTEGER   libOffset,
    IN ULARGE_INTEGER   cb,
    IN DWORD            dwLockType)
/*++

Routine Description:
    Range locking is not supported by this stream.

Return Value:
    STG_E_INVALIDFUNCTION.

--*/
{
    return STG_E_INVALIDFUNCTION;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Write(
    IN  void const *pv,
    IN  ULONG       cb,
    OUT ULONG *     pcbWritten)
/*++

Routine Description:
    Write data to the stream starting at the current seek pointer.

Arguments:
    pv          - Supplies the data to be written to the stream.
    cb          - Specifies the number of bytes to be written to the stream.
    pcbWritten  - Returns the number of bytes actually written to the stream.

Return Value:
    S_OK                - The data was successfully written to the stream.
    STG_E_MEDIUMFULL    - Data cannot be written past the end of the stream.

--*/
{
    HRESULT         hr;
    unsigned long   cbRemaining;
    unsigned long   cbWritten;

    //Check if we are writing past the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if(cb <= cbRemaining)
    {
        cbWritten = cb;
        hr = S_OK;
    }
    else
    {
        cbWritten = cbRemaining;
        hr = STG_E_MEDIUMFULL;
    }

    // Write the data.
    memcpy(pBuffer + position, pv, cbWritten);

    //Advance the current position
    position += cbWritten;

    //update pcbWritten
    if (pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\stdid.cxx ===
//+-------------------------------------------------------------------
//
//  File:       stdid.cxx
//
//  Contents:   identity object and creation function
//
//  History:     1-Dec-93   CraigWi     Created
//              13-Sep-95   Rickhi      Simplified
//
//--------------------------------------------------------------------
#include <ole2int.h>

#include <stdid.hxx>        // CStdIdentity
#include <marshal.hxx>      // CStdMarshal
#include <ctxchnl.hxx>      // Context channel
#include "callmgr.hxx"
#include <excepn.hxx>       // Exception filter routines

#include "..\objact\objact.hxx"  // used in IProxyManager::CreateServer
#include "crossctx.hxx"     // ObtainPolicySet


#if DBG==1
// head of linked list of identities for debug tracking purposes
CStdIdentity gDbgIDHead;
#endif  // DBG


//+----------------------------------------------------------------
//
//  Class:      CStdIdentity (stdid)
//
//  Purpose:    To be the representative of the identity of the object.
//
//  History:    11-Dec-93   CraigWi     Created.
//              21-Apr-94   CraigWi     Stubmgr addref's object; move strong cnt
//              10-May-94   CraigWi     IEC called for strong connections
//              17-May-94   CraigWi     Container weak connections
//              31-May-94   CraigWi     Tell object of weak pointers
//
//  Details:
//
//  The identity is determined on creation of the identity object. On the
//  server side a new OID is created, on the client side, the OID contained
//  in the OBJREF is used.
//
//  The identity pointer is typically stored in the OIDTable, NOT AddRef'd.
//  SetOID adds the identity to the table, and can be called from ctor or
//  from Unmarshal. RevokeOID removes the identity from the table, and can
//  be called from Disconnect, or final Release.
//
//--------------------------------------------------------------------

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CStdIdentity, private
//
//  Synopsis:   ctor for identity object
//
//  Arguments:  for all but the last param, see CreateIdentityHandler.
//              [ppUnkInternal] --
//                  when aggregated, this the internal unknown;
//                  when not aggregated, this is the controlling unknown
//
//  History:    15-Dec-93   CraigWi     Created.
//              12-Dec-96   Gopalk      Initialize connection status
//              22-Apr-98   SatishT     Control QI for IExternalConnection
//--------------------------------------------------------------------
CStdIdentity::CStdIdentity(DWORD flags, DWORD dwAptId, IUnknown *pUnkOuter,
                IUnknown *pUnkControl, IUnknown **ppUnkInternal, BOOL *pfSuccess) :
    m_refs(1),
    m_cStrongRefs(0),
    m_cWeakRefs(0),
    m_flags(flags),
    m_pIEC(NULL),
    m_moid(GUID_NULL),
    m_ConnStatus(S_OK),
    m_dwAptId(dwAptId),
    m_pUnkOuter((pUnkOuter) ? pUnkOuter : (IMultiQI *)&m_InternalUnk),
    m_pUnkControl((pUnkControl) ? pUnkControl : m_pUnkOuter),
    CClientSecurity( this ),
    CRpcOptions(this, m_pUnkOuter)
{
    ComDebOut((DEB_MARSHAL, "CStdIdentity %s Created this:%x\n",
                IsClient() ? "CLIENT" : "SERVER", this));
    Win4Assert(!!IsClient() == (pUnkControl == NULL));
    Win4Assert(pfSuccess != NULL);

    *pfSuccess = TRUE;

#if DBG==1
    // Chain this identity onto the global list of instantiated identities
    // so we can track even the ones that are not placed in the ID table.
    LOCK(gComLock);
    m_pNext            = gDbgIDHead.m_pNext;
    m_pPrev            = &gDbgIDHead;
    gDbgIDHead.m_pNext = this;
    m_pNext->m_pPrev   = this;
    UNLOCK(gComLock);
#endif

    if (pUnkOuter)
    {
        m_flags |= STDID_AGGREGATED;
    }

    CLSID clsidHandler;
    DWORD dwSMFlags = SMFLAGS_CLIENT_SIDE;  // assume client side

    if (!IsClient())
    {
#if DBG == 1
        // the caller should have a strong reference and so these tests
        // should not disturb the object. These just check the sanity of
        // the object we are attempting to marshal.

        // addref/release pUnkControl; shouldn't go away (i.e.,
        // should be other ref to it).
        {
            pUnkControl->AddRef();
            if (pUnkControl->Release() == 0  &&
                !IsTaskName(L"EXCEL.EXE")    &&
                !IsTaskName(L"EXPLORER.EXE") &&
                !IsTaskName(L"IEXPLORE.EXE") &&
                !IsTaskName(L"DLLHOST.EXE"))
            {
                // Do this only if it is not Excel or Explorer as they always
                // return 0 which will trigger the assert on debug builds
                // unnecessarily!

                Win4Assert(!"pUnkControl incorrect refcnt");
            }

            // verify that pUnkControl is in fact the controlling unknown
            IUnknown *pUnkT;
            Verify(pUnkControl->QueryInterface(IID_IUnknown,(void **)&pUnkT)==NOERROR);
            Win4Assert(pUnkControl == pUnkT);
            if (pUnkT->Release() == 0        &&
                !IsTaskName(L"EXCEL.EXE")    &&
                !IsTaskName(L"EXPLORER.EXE") &&
                !IsTaskName(L"IEXPLORE.EXE") &&
                !IsTaskName(L"DLLHOST.EXE"))
            {
                // Do this only if it is not Excel or Explorer as they always
                // return 0 which will trigger the assert on debug builds
                // unnecessarily!

                Win4Assert(!"pUnkT incorrect refcnt");
            }
        }
#endif

        dwSMFlags = 0;      // server side
        if(!IsAggregated())
        {
            // If aggregated the aggregation rules dictate that we
            // don't need to AddRef.
            m_pUnkControl->AddRef();
        }

        // determine if we will write a standard or handler objref. we write
        // standard unless the object implements IStdMarshalInfo and overrides
        // the standard class. we ignore all errors from this point onward in
        // order to maintain backward compatibility.

        ASSERT_LOCK_NOT_HELD(gComLock);

        IStdMarshalInfo *pSMI;
        HRESULT hr = m_pUnkControl->QueryInterface(IID_IStdMarshalInfo,
                                                   (void **)&pSMI);
        if (SUCCEEDED(hr))
        {
            hr = pSMI->GetClassForHandler(NULL, NULL, &clsidHandler);
            if (SUCCEEDED(hr) && !IsEqualCLSID(clsidHandler, CLSID_NULL))
            {
                dwSMFlags |= SMFLAGS_HANDLER;

                if (IsAggregated())
                {
                    // server side aggregated StdMarshal & outer unk
                    // provides a handler, so use CLSID_AggStdMarshal
                    dwSMFlags |= SMFLAGS_USEAGGSTDMARSHAL;
                }
            }
            else
            {
                clsidHandler = GUID_NULL;
            }
            pSMI->Release();
        }

        // look for the IExternalConnection interface. The StdId will use
        // this for Inc/DecStrongCnt. We do the QI here while we are not
        // holding the LOCK.

        if (!(flags & STDID_NOIEC))
        {
            hr = m_pUnkControl->QueryInterface(IID_IExternalConnection,
                                               (void **)&m_pIEC);
            if(SUCCEEDED(hr))
            {
                if(IsAggregated())
                {
                    // Follow aggregation rules and don't hold a
                    // reference to the server.
                    m_pUnkControl->Release();
                }
            }
            else
            {
                // make sure it is NULL
                m_pIEC = NULL;
            }
        }
        else
        {
            // make sure it is NULL
            m_pIEC = NULL;
        }

        if (!(m_flags & STDID_IGNOREID))
        {
            // Look for the IMarshalOptions interface, and if supported query
            // for any marshal options specified by the client.  This is a 
            // private mechanism used by COM+ only.
            IMarshalOptions* pIMrshlOpts = NULL;
            hr = m_pUnkControl->QueryInterface(IID_IMarshalOptions, (void**)&pIMrshlOpts);
            if (SUCCEEDED(hr))
            {
                DWORD dwMarshalFlags = 0;
                Win4Assert(pIMrshlOpts);
                pIMrshlOpts->GetStubMarshalFlags(&dwMarshalFlags);
                pIMrshlOpts->Release();
            
                // Translate user flags to internal flags
                if (dwMarshalFlags & MARSHOPT_NO_OID_REGISTER)
                    m_flags |= STDID_IGNOREID;
            }
        }

        ASSERT_LOCK_NOT_HELD(gComLock);
    }
    else
    {
        m_cStrongRefs = 1;
    }

    if (m_flags & STDID_STCMRSHL)
    {
        dwSMFlags |= SMFLAGS_CSTATICMARSHAL;
    }
    if (m_flags & STDID_SYSTEM)
    {
        dwSMFlags |= SMFLAGS_SYSTEM;
    }

    if (m_flags & STDID_FTM)
        dwSMFlags |= SMFLAGS_FTM;

    // now intialize the standard marshaler
    if (CStdMarshal::Init(m_pUnkControl, this, clsidHandler, dwSMFlags) == FALSE)
    {
        // construction failed. Release any resources held.
    	*pfSuccess = FALSE;
    	if (!IsClient() && !IsAggregated())
    	{
    	    m_pUnkControl->Release(); // construction failed; release ref count
    	    m_pUnkControl = NULL;
    	}
    	if (m_pIEC)
    	{
    	    m_pIEC->Release();
    	    m_pIEC = NULL;
    	}
    	// if initialization fails, set refcount to zero. User then deletes object instead of
    	// calling Release (too many different refcounts and I don't see a straightforward
    	// way to call Release and have this object cleaned up).
    	m_refs = 0;
    }
    else
    {
        *ppUnkInternal = (IMultiQI *)&m_InternalUnk; // this is what the m_refs=1 is for
        AssertValid();
    }
}

#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CStdIdentity, public
//
//  Synopsis:   Special Identity ctor for the debug list head.
//
//+-------------------------------------------------------------------
CStdIdentity::CStdIdentity() : CClientSecurity(this), CRpcOptions(this, NULL)
{
    Win4Assert(this == &gDbgIDHead);
    m_pNext = this;
    m_pPrev = this;
}
#endif  // DBG

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::~CStdIdentity, private
//
//  Synopsis:   Final destruction of the identity object.  ID has been
//              revoked by now (in internal ::Release).  Here we disconnect
//              on server.
//
//  History:    15-Dec-93   CraigWi     Created.
//                          Rickhi      Simplified
//
//--------------------------------------------------------------------
CStdIdentity::~CStdIdentity()
{
#if DBG==1
    if (this != &gDbgIDHead)
    {
#endif  // DBG

        ComDebOut((DEB_MARSHAL, "CStdIdentity %s Deleted this:%x\n",
                    IsClient() ? "CLIENT" : "SERVER", this));

        Win4Assert(m_refs == 0 || m_refs == CINDESTRUCTOR);
        m_refs++;               // simple guard against reentry of dtor
        SetNowInDestructor();   // debug flag which enables asserts to detect

        // find out if this is an AsyncRelease
        HRESULT hr;
        COleTls tls(hr);
        if (SUCCEEDED(hr))
        {
            SetAsyncRelease(tls->pAsyncRelease);
        }

        // make sure we have disconnected
        CStdMarshal::Disconnect(DISCTYPE_RELEASE);

        if (SUCCEEDED(hr))
        {
            // propogate async release status
            tls->pAsyncRelease = GetAsyncRelease();
        }

#if DBG==1
        // UnChain this identity from the global list of instantiated identities
        // so we can track even the ones that are not placed in the ID table.
        LOCK(gComLock);
        m_pPrev->m_pNext = m_pNext;
        m_pNext->m_pPrev = m_pPrev;
        UNLOCK(gComLock);
    }
#endif  // DBG
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::QueryInterface, private
//
//  Synopsis:   Queries for an interface. Just delegates to the common
//              code in QueryMultipleInterfaces.
//
//  History:    26-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CInternalUnk::QueryInterface(REFIID riid, VOID **ppv)
{
    if (ppv == NULL)
    {
        return E_INVALIDARG;
    }

    MULTI_QI mqi;
    mqi.pIID = &riid;
    mqi.pItf = NULL;

    HRESULT hr = QueryMultipleInterfaces(1, &mqi);

    *ppv = (void *)mqi.pItf;
    // carefull what gets returned here.
    return (hr == E_NOINTERFACE || hr == S_FALSE) ? mqi.hr : hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::QueryMultipleInterfacesLocal, public
//
//  Synopsis:   loop over the interfaces looking for locally supported interfaces,
//              instantiated proxies, and unsupported interfaces.
//
//  History:    06-Jan-98    MattSmit  Created -- factored out of QueryMultipleInterfaces
//
//--------------------------------------------------------------------
USHORT CStdIdentity::CInternalUnk::QueryMultipleInterfacesLocal(ULONG       cMQIs,
                                                                 MULTI_QI   *pMQIs,
                                                                 MULTI_QI  **ppMQIPending,
                                                                 IID        *pIIDPending,
                                                                 ULONG      *pcAcquired)
{
    ComDebOut((DEB_CHANNEL, "CStdIdentity::CInternalUnk::QueryMultipleInterfacesLocal IN cMQIs:0x%d, "
               "pMQIs:0x%x, ppMQIPending:0x%x, pIIDPending:%I, pcAcquired:0x%x\n",
               cMQIs, pMQIs, ppMQIPending, pIIDPending, pcAcquired));

    // loop over the interfaces looking for locally supported interfaces,
    // instantiated proxies, and unsupported interfaces. Gather up all the
    // interfaces that dont fall into the above categories, and issue a
    // remote query to the server.
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
    USHORT cPending  = 0;
    ULONG &cAcquired = *pcAcquired;
    cAcquired = 0;
    MULTI_QI *pMQI   = pMQIs;

    for (ULONG i=0; i<cMQIs; i++, pMQI++)
    {
        if (pMQI->pItf != NULL)
        {
            // skip any entries that are not set to NULL. This allows
            // progressive layers of handlers to optionally fill in the
            // interfaces that they know about and pass the whole array
            // on to the next level.
            cAcquired++;
            continue;
        }

        pMQI->hr   = S_OK;

        // always allow - IUnknown, IMarshal, IStdIdentity, IProxyManager,
        // and Instantiated proxies.
        if (InlineIsEqualGUID(*(pMQI->pIID), IID_IUnknown))
        {
            pMQI->pItf = (IMultiQI *)this;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IMarshal))
        {
            pMQI->pItf = (IMarshal *)pStdID;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IMarshal2))
        {
            pMQI->pItf = (IMarshal2 *)pStdID;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IStdIdentity))
        {
            pMQI->pItf = (IUnknown *)(void*)pStdID;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IProxyManager))
        {
            // old code exposed this IID and things now depend on it.
            pMQI->pItf = (IProxyManager *)pStdID;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IRemUnknown) &&
                 pStdID->InstantiatedProxy(IID_IRundown,(void **)&pMQI->pItf,
                                           &pMQI->hr))
        {
            ;
        }
        else if (pStdID->InstantiatedProxy(*(pMQI->pIID),(void **)&pMQI->pItf,
                                            &pMQI->hr))
        {
            // a proxy for this interface already exists
            //
            // NOTE: this call also set pMQI->hr = E_NOINTERFACE if the
            // StId has never been connected, and to CO_E_OBJNOTCONNECTED if
            // it has been connected but is not currently connected. This is
            // required for backwards compatibility, and will cause us to skip
            // the QueryRemoteInterface.
            ;
        }
        else if (pStdID->IsAggregated())
        {
            // aggregate case
            // allow - IInternalUnknown
            // dissallow - IMultiQI, IClientSecurity, IServerSecurity,
            // IRpcOptions, ICallFactory, IForegroundTranfer

            if (InlineIsEqualGUID(*(pMQI->pIID), IID_IInternalUnknown))
            {
                pMQI->pItf = (IInternalUnknown *)this;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IMultiQI)           ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IRpcOptions)        ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IClientSecurity)    ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IServerSecurity)    ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IForegroundTransfer)||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_ICallFactory))
            {
                pMQI->hr = E_NOINTERFACE;
            }
        }

        if ((pMQI->pItf == NULL) && (!pStdID->IsAggregated() || pStdID->IsCStaticMarshal()))
        {
            // non-aggregate case
            // allow - IClientSecurity, IMultiQI, IRpcOptions
            // dissallow - IInternalUnknown, IServerSecurity

            if (InlineIsEqualGUID(*(pMQI->pIID), IID_IClientSecurity))
            {
                pMQI->pItf = (IClientSecurity *)pStdID;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IRpcOptions))
            {
                pMQI->pItf = (IRpcOptions *)pStdID;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_ICallFactory) &&
                     pStdID->GetClientPolicySet()==NULL)
            {
                pMQI->pItf = (ICallFactory *)pStdID;
                pMQI->hr   = S_OK;
            }

            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IMultiQI))
            {
                pMQI->pItf = (IMultiQI *)this;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IForegroundTransfer))
            {
                pMQI->pItf = (IForegroundTransfer *)pStdID;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IInternalUnknown) ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IServerSecurity))
            {
                pMQI->hr = E_NOINTERFACE;
            }
        }


        // never said we had this interface, never said we didn't
        // so, we'll call out to the object.

        if ((pMQI->pItf == NULL) && (pMQI->hr == S_OK))
        {
            pMQI->hr = RPC_S_CALLPENDING;
        }


        if (pMQI->hr == S_OK)
        {
            // got an interface to return, AddRef it and count one more
            // interface acquired.

            pMQI->pItf->AddRef();
            cAcquired++;
        }
        else if (pMQI->hr == RPC_S_CALLPENDING)
        {
            // fill in a remote QI structure and count one more
            // pending interface

            *pIIDPending    = *(pMQI->pIID);
            *ppMQIPending   = pMQI;

            pIIDPending++;
            ppMQIPending++;
            cPending++;
        }
    }

    ComDebOut((DEB_CHANNEL, "CStdIdentity::CInternalUnk::QueryMultipleInterfacesLocal OUT\n"));
    return cPending;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::QueryMultipleInterfaces, public
//
//  Synopsis:   QI for >1 interface
//
//  History:    26-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CInternalUnk::QueryMultipleInterfaces(ULONG cMQIs,
                                        MULTI_QI *pMQIs)
{
    // Make sure TLS is initialized.
    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;


    // ensure it is callable in the current apartment
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
    hr = pStdID->IsCallableFromCurrentApartment();
    if (FAILED(hr))
        return hr;

    pStdID->AssertValid();

    // allocate some space on the stack for the intermediate results. declare
    // working pointers and remember the start address of the allocations.

    MULTI_QI  **ppMQIAlloc = (MULTI_QI **)_alloca(sizeof(MULTI_QI *) * cMQIs);
    IID       *pIIDAlloc   = (IID *)      _alloca(sizeof(IID) * cMQIs);
    SQIResult *pSQIAlloc   = (SQIResult *)_alloca(sizeof(SQIResult) * cMQIs);

    MULTI_QI  **ppMQIPending = ppMQIAlloc;
    IID       *pIIDPending   = pIIDAlloc;
    ULONG     cAcquired;

    USHORT cPending = QueryMultipleInterfacesLocal(cMQIs, pMQIs, ppMQIPending, pIIDPending, &cAcquired);


    if (cPending > 0)
    {
        memset(pSQIAlloc, 0, sizeof(SQIResult) * cPending);
        // there are some interfaces which we dont yet know about, so
        // go ask the remoting layer to Query the server and build proxies
        // where possible. The results are returned in the individual
        // SQIResults, so the overall return code is ignored.

        pStdID->QueryRemoteInterfaces(cPending, pIIDAlloc, pSQIAlloc);

        CopyToMQI(cPending, pSQIAlloc, ppMQIAlloc, &cAcquired);
    }



    // if we got all the interfaces, return S_OK. If we got none of the
    // interfaces, return E_NOINTERFACE. If we got some, but not all, of
    // the interfaces, return S_FALSE;

    if (cAcquired == cMQIs)
        return S_OK;
    else if (cAcquired > 0)
        return S_FALSE;
    else
        return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::QueryInternalInterface, public
//
//  Synopsis:   return interfaces that are internal to the aggregated
//              proxy manager.
//
//  History:    26-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CInternalUnk::QueryInternalInterface(REFIID riid,
                                                                VOID **ppv)
{
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
    HRESULT hr = pStdID->IsCallableFromCurrentApartment();
    if (FAILED(hr))
        return hr;

    pStdID->AssertValid();

    if (!pStdID->IsAggregated())
    {
        // this method is only valid when we are part of a client-side
        // aggregate.
        return E_NOTIMPL;
    }

    if (InlineIsEqualGUID(riid, IID_IUnknown) ||
        InlineIsEqualGUID(riid, IID_IInternalUnknown))
    {
        *ppv = (IInternalUnknown *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_IMultiQI))
    {
        *ppv = (IMultiQI *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_IStdIdentity))
    {
        *ppv = pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_IClientSecurity))
    {
        *ppv = (IClientSecurity *)pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_ICallFactory))
    {
        *ppv = (ICallFactory *)pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_IRpcOptions) &&
             pStdID->IsCStaticMarshal())
    {
        *ppv = (IRpcOptions *)pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_IProxyManager))
    {
        *ppv = (IProxyManager *)pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_IForegroundTransfer))
    {
        *ppv = (IForegroundTransfer *)pStdID;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::AddRef, public
//
//  Synopsis:   Nothing special.
//
//  History:    15-Dec-93   CraigWi     Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdIdentity::CInternalUnk::AddRef(void)
{
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
    pStdID->AssertValid();

    DWORD cRefs = InterlockedIncrement((long *)&pStdID->m_refs);

    // ComDebOut((DEB_MARSHAL, "StdId:CtrlUnk::AddRef this:%x m_refs:%x\n", pStdID, cRefs));
    return cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::Release, public
//
//  Synopsis:   Releases the identity object.  When the ref count goes
//              to zero, revokes the id and destroys the object.
//
//  History:    15-Dec-93   CraigWi     Created.
//              18-Apr-95   Rickhi      Rewrote much faster/simpler
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdIdentity::CInternalUnk::Release(void)
{
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
    pStdID->AssertValid();

    // decrement the refcnt. if the refcnt went to zero it will be marked
    // as being in the dtor, and fTryToDelete will be true.
    ULONG cNewRefs;
    BOOL fTryToDelete = InterlockedDecRefCnt(&pStdID->m_refs, &cNewRefs);
    // ComDebOut((DEB_MARSHAL, "StdId:CtrlUnk::Release this:%x m_refs:%x\n", pStdID, cNewRefs));

    while (fTryToDelete)
    {
        // refcnt went to zero, try to delete this entry

        if (pStdID->IsCStaticMarshal())
        {
            // If the aggregator is the AGGID, we stay around until
            // it gets deleted
            break;
        }

        if (IsOKToDeleteClientObject(pStdID, &pStdID->m_refs))
        {
            // the refcnt did not change while we acquired the lock
            // (i.e. the idtable did not just hand out a reference).
            // OK to delete the identity object.
            delete pStdID;
            break;  // all done. the entry has been deleted.
        }

        // the entry was not deleted because some other thread changed
        // the refcnt while we acquired the lock. Try to restore the refcnt
        // to turn off the CINDESTRUCTOR bit. Note that this may race with
        // another thread changing the refcnt, in which case we may decide to
        // try to loop around and delete the object once again.
        fTryToDelete = InterlockedRestoreRefCnt(&pStdID->m_refs, &cNewRefs);
    }

    return (cNewRefs & ~CINDESTRUCTOR);
}


//+-------------------------------------------------------------------
//
//  Function:   IsOKToDeleteClientObject, private
//
//  Synopsis:   Called when a client side object reference count hits
//              zero. Takes a lock and re-checks the reference count to
//              ensure the OID table did not just hand out a reference,
//              removes the OID from the OID table.
//
//  Returns:    TRUE - safe to delete object
//              FALSE - unsafe to delete object
//
//  History:    31-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
INTERNAL_(BOOL) IsOKToDeleteClientObject(CStdIdentity *pStdID, ULONG *pcRefs)
{
    BOOL fDelete = FALSE;
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // check if we are already in the dtor and skip a second destruction
    // if so. The reason we need this is that some crusty old apps do
    // CoMarshalInterface followed by CoLockObjectExternal(FALSE,TRUE),
    // expecting this to accomplish a Disconnect. It subtracts from the
    // references, but it takes away the ones that the IPIDEntry put on,
    // without telling the IPIDEntry, so when we release the IPIDEntry,
    // our count goes negative!!!

    // the LockedInMemory flag is for the gpStdMarshal instance that we
    // may hand out to clients, but which we never want to go away,
    // regardless of how many times they call Release.

    if (*pcRefs == CINDESTRUCTOR)
    {
        // refcnt is still zero, so the idtable did not just hand
        // out a reference behind our back.

        if (!pStdID->IsLockedOrInDestructor())
        {
            // remove from the OID table and delete the identity
            // We dont delete while holding the table mutex.
            CIDObject *pID = pStdID->GetIDObject();
            if((pID==NULL) || pID->IsOkToDisconnect())
            {
                pStdID->RevokeOID();
                if(pID)
                    pID->RemoveStdID();
                fDelete = TRUE;
            }
        }
        else
        {
            // this object is locked in memory and we should never
            // get here, but some broken test app was doing this in
            // stress.

            *pcRefs = CINDESTRUCTOR | 0x100;
        }
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
    return fDelete;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IUnknown methods, public
//
//  Synopsis:   External IUnknown methods; delegates to m_pUnkOuter.
//
//  History:    15-Dec-93   CraigWi     Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::QueryInterface(REFIID riid, VOID **ppvObj)
{
    AssertValid();

    // It is necessary to switch to the NA if this is an FTM object
    // because our internal unk QI uses QueryMultipleInterfaces which
    // verifies that the call is occuring in the correct apt.

    ENTER_NA_IF_NECESSARY()
    HRESULT hr = m_pUnkOuter->QueryInterface(riid, ppvObj);
    LEAVE_NA_IF_NECESSARY()
    return hr;
}

STDMETHODIMP_(ULONG) CStdIdentity::AddRef(void)
{
    AssertValid();
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CStdIdentity::Release(void)
{
    AssertValid();
    return m_pUnkOuter->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::UnlockAndRelease, public
//
//  Synopsis:   Version of Release used for gpStdMarshal, that is
//              currently locked in memory so nobody but us can
//              release it, regardless of refcnt.
//
//  History:    19-Apr-96   Rickhi      Created
//
//--------------------------------------------------------------------
ULONG CStdIdentity::UnlockAndRelease(void)
{
    m_flags &= ~STDID_LOCKEDINMEM;
    m_refs = 1;
    return m_pUnkOuter->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IncStrongCnt, public
//
//  Synopsis:   Increments the strong reference count on the identity.
//
//  History:    15-Dec-93   Rickhi      Created.
//
//--------------------------------------------------------------------
void CStdIdentity::IncStrongCnt()
{
    Win4Assert(!IsClient());

    // we might be holding the lock here if this is called from
    // ObtainStdID, since we have to be holding the lock while
    // doing the lookup. We cant release it or we could go away.

    ASSERT_LOCK_DONTCARE(gComLock);

    ComDebOut((DEB_MARSHAL,
        "CStdIdentity::IncStrongCnt this:%x cStrong:%x\n",
        this, m_cStrongRefs+1));

    AddRef();
    InterlockedIncrement(&m_cStrongRefs);

    if (m_pIEC)
    {
        m_pIEC->AddConnection(EXTCONN_STRONG, 0);
    }

    ASSERT_LOCK_DONTCARE(gComLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::DecStrongCnt, public
//
//  Synopsis:   Decrements the strong reference count on the identity,
//              and releases the object if that was the last strong
//              reference.
//
//  History:    15-Dec-93   Rickhi      Created.
//
//--------------------------------------------------------------------
void CStdIdentity::DecStrongCnt(BOOL fKeepAlive)
{
    Win4Assert(!IsClient());
    ASSERT_LOCK_NOT_HELD(gComLock);

    ComDebOut((DEB_MARSHAL,
        "CStdIdentity::DecStrongCnt this:%x cStrong:%x fKeepAlive:%x\n",
        this, m_cStrongRefs-1, fKeepAlive));

    LONG cStrongRefs = InterlockedDecrement(&m_cStrongRefs);

    if (m_pIEC)
    {
        m_pIEC->ReleaseConnection(EXTCONN_STRONG, 0, !fKeepAlive);
    }

    // If aggregated on the server side, then the last strong reference
    // should cause a Disconnect, otherwise the stubs will hold the object
    // alive when unmarshaling in the server apartment.
    fKeepAlive = IsAggregated() ? FALSE : fKeepAlive;

    if (cStrongRefs == 0 && !fKeepAlive && (m_pIEC == NULL || IsWOWThread()))
    {
        // strong count has gone to zero, disconnect.
        CStdMarshal::Disconnect(DISCTYPE_NORMAL);
	if (m_cStrongRefs <0 ) 
	   m_cStrongRefs = 0;  // make sure a negative count is corrected
                            // see comment below
    }

    if (cStrongRefs >= 0)
    {
        // some apps call CoMarshalInterface + CoLockObjectExternal(F,T)
        // and expect the object to go away. Doing that causes Release to
        // be called too many times (once for each IPID, once for CLOE, and
        // once for the original Lookup).
        Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IncWeakCnt, public
//
//  Synopsis:   Increments the weak reference count on the identity.
//
//  History:    15-Dec-93   Rickhi      Created.
//
//--------------------------------------------------------------------
void CStdIdentity::IncWeakCnt()
{
    Win4Assert(!IsClient());

    // we might be holding the lock here if this is called from
    // ObtainStdID, since we have to be holding the lock while
    // doing the lookup. We cant release it or we could go away.

    ASSERT_LOCK_DONTCARE(gComLock);

    ComDebOut((DEB_MARSHAL,
        "CStdIdentity::IncWeakCnt this:%x cWeak:%x\n",
        this, m_cWeakRefs+1));

    AddRef();
    InterlockedIncrement(&m_cWeakRefs);

    ASSERT_LOCK_DONTCARE(gComLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::DecWeakCnt, public
//
//  Synopsis:   Decrements the weak reference count on the identity,
//              and releases the object if that was the last strong
//              and weak reference.
//
//  History:    15-Dec-93   Rickhi      Created.
//
//--------------------------------------------------------------------
void CStdIdentity::DecWeakCnt(BOOL fKeepAlive)
{
    Win4Assert(!IsClient());
    ComDebOut((DEB_MARSHAL,
        "CStdIdentity::DecWeakCnt this:%x cWeak:%x fKeepAlive:%x\n",
        this, m_cWeakRefs-1, fKeepAlive));

    LONG cWeakRefs = InterlockedDecrement(&m_cWeakRefs);

    // If aggregated on the server side, then the last strong or weak reference
    // should cause a Disconnect, otherwise the stubs will hold the object
    // alive when unmarshaling in the server apartment.
    fKeepAlive = IsAggregated() ? FALSE : fKeepAlive;

    if (cWeakRefs == 0 && !fKeepAlive && m_cStrongRefs == 0)
    {
        // strong and weak count have gone to zero, disconnect.
        DisconnectObject(0);
    }

    Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::LockObjectExternal, public
//
//  Synopsis:   locks (or unlocks) the object so the remoting layer does
//              not (or does) go away.
//
//  History:    09-Oct-96   Rickhi      Moved from CoLockObjectExternal.
//
//--------------------------------------------------------------------
HRESULT CStdIdentity::LockObjectExternal(BOOL fLock, BOOL fLastUR)
{
    HRESULT hr = S_OK;

    if (GetServer() == NULL)
    {
        // attempt to lock handler, return error!
        hr = E_UNEXPECTED;
    }
    else if (fLock)
    {
        // lock (and ignore rundowns) so it does not go away
        IncStrongCnt();
        LOCK(gIPIDLock);
        IncTableCnt();
        UNLOCK(gIPIDLock);
    }
    else
    {
        // unlock so that it can go away
        LOCK(gIPIDLock);
        DecTableCnt();
        UNLOCK(gIPIDLock);
        DecStrongCnt(!fLastUR);
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::GetServer, public
//
//  Synopsis:   Returns a pUnk for the identified object; NULL on client side
//              The pointer is optionally addrefed depending upon fAddRef
//
//  Returns:    The pUnk on the object.
//
//  History:    15-Dec-93   CraigWi     Created.
//
//--------------------------------------------------------------------
IUnknown * CStdIdentity::GetServer()
{
    if (IsClient() || m_pUnkControl == NULL)
        return NULL;

    // Verify validity
    Win4Assert(IsValidInterface(m_pUnkControl));
    return m_pUnkControl;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::ReleaseCtrlUnk, public
//
//  Synopsis:   Releases the server side controlling unknown
//              This code is safe for reentrant calls.
//
//  History:    11-Jun-95   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdIdentity::ReleaseCtrlUnk(void)
{
    AssertValid();
    Win4Assert(!IsClient());
    __try
    {
        if (m_pUnkControl)
        {
            // release the real object's m_pUnkControl

            AssertSz(IsValidInterface(m_pUnkControl),
                 "Invalid IUnknown during disconnect");
            IUnknown *pUnkControl = m_pUnkControl;
            m_pUnkControl = NULL;

            if (m_pIEC)
            {
                AssertSz(IsValidInterface(m_pIEC),
                 "Invalid IExternalConnection during disconnect");
                m_pIEC->Release();
                m_pIEC = NULL;
            }

            if(!IsAggregated())
                pUnkControl->Release();
        }
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), IID_IUnknown, 2))
    {
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::SetOID, public
//
//  Synopsis:   Associates the OID and the object (handler or server).
//
//  History:    20-Feb-95   Rickhi      Simplified
//
//--------------------------------------------------------------------
HRESULT CStdIdentity::SetOID(REFMOID rmoid)
{
    Win4Assert(rmoid != GUID_NULL);
    ASSERT_LOCK_HELD(gComLock);

    HRESULT hr = S_OK;

    if (!(m_flags & STDID_HAVEID))
    {
        if (!(m_flags & STDID_IGNOREID))
        {
            GetIDObject()->SetOID(rmoid);
            gOIDTable.Add(GetIDObject());
        }

        if (SUCCEEDED(hr))
        {
            m_flags |= STDID_HAVEID;
            m_moid = rmoid;
        }
    }

    ComDebErr(hr != S_OK, "SetOID Failed. Probably OOM.\n");
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::RevokeOID, public
//
//  Synopsis:   Disassociates the OID and the object (handler or server).
//              Various other methods will fail (e.g., MarshalInterface).
//
//  History:    15-Dec-93   CraigWi     Created.
//              20-Feb-95   Rickhi      Simplified
//
//--------------------------------------------------------------------
void CStdIdentity::RevokeOID(void)
{
    AssertValid();
    ASSERT_LOCK_HELD(gComLock);

    if (m_flags & STDID_HAVEID)
    {
        m_flags &= ~STDID_HAVEID;

        if (!(m_flags & STDID_IGNOREID))
            gOIDTable.Remove(GetIDObject());
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IsCallableFromCurrentApartment, public
//
//  Synopsis:   Determines if the object is callable from the current
//              apartment or not.
//
//  History:    08-Mar-97   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CStdIdentity::IsCallableFromCurrentApartment(void)
{
    if (m_dwAptId == GetCurrentApartmentId() || IsFreeThreaded())
    {
        return S_OK;
    }
    return RPC_E_WRONG_THREAD;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IsConnected, public
//
//  Synopsis:   Indicates if the client is connected to the server.
//              Only the negative answer is definitive because we
//              might not be able to tell if the server is connected
//              and even if we could, the answer might be wrong by
//              the time the caller acted on it.
//
//  Returns:    TRUE if the server might be connected; FALSE if
//              definitely not.
//
//  History:    16-Dec-93   CraigWi     Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(BOOL) CStdIdentity::IsConnected(void)
{
    Win4Assert(IsClient());             // must be client side
    AssertValid();

    return RemIsConnected();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::Disconnect, public
//
//  Synopsis:   IProxyManager::Disconnect implementation, just forwards
//              to the standard marshaller, which may call us back to
//              revoke our OID and release our CtrlUnk.
//
//              May also be called by the IDTable cleanup code.
//
//  History:    11-Jun-95   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CStdIdentity::Disconnect()
{
    AssertValid();
    CStdMarshal::Disconnect(DISCTYPE_APPLICATION);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::LockConnection, public
//
//  Synopsis:   IProxyManager::LockConnection implementation. Changes
//              all interfaces to weak from strong, or strong from weak.
//
//  History:    11-Jun-95   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::LockConnection(BOOL fLock, BOOL fLastUnlockReleases)
{
    HRESULT hr = IsCallableFromCurrentApartment();
    if (FAILED(hr))
        return hr;
    AssertValid();

    if (!IsClient() || !(m_flags & STDID_DEFHANDLER))
    {
        // this operation does not make sense on the server side,
        // and is not allowed except by the OLE default handler
        return E_NOTIMPL;
    }

    if (IsMTAThread())
    {
        // this call is not allowed if we are FreeThreaded. Report
        // success, even though we did not do anything.
        return S_OK;
    }


    if (( fLock && (++m_cStrongRefs == 1)) ||
        (!fLock && (--m_cStrongRefs == 0)))
    {
        // the strong count transitioned from 0 to 1 or 1 to 0, so
        // call the server to change our references.

        return RemoteChangeRef(fLock, fLastUnlockReleases);
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CreateServer, public
//
//  Synopsis:   Creates the server clsid in the given context and
//              attaches it to this handler.
//
//  History:    16-Dec-93   CraigWi     Created.
//
// CODEWORK:    this code is not thread safe in the freethreading case. We
//              need to decide if the thread safety is the responsibility
//              of the caller, or us. In the latter case, we would check
//              if we are already connected before doing UnmarshalObjRef, and
//              instead do a ::ReleaseMarshalObjRef.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CreateServer(REFCLSID rclsid, DWORD clsctx, void *pv)
{
    ComDebOut((DEB_ACTIVATE, "ScmCreateObjectInstance this:%x clsctx:%x pv:%x\n",
                this, clsctx, pv));
    AssertValid();
    Win4Assert(IsClient());                         // must be client side
    Win4Assert(IsValidInterface(m_pUnkControl));    // must be valid
    //Win4Assert(!IsConnected());
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (!(m_flags & STDID_DEFHANDLER))
    {
        // this operation is not allowed except by the OLE default handler
        return E_NOTIMPL;
    }

    // Loop trying to get object from the server. Because the server can be
    // in the process of shutting down and respond with a marshaled interface,
    // we will retry this call if unmarshaling fails assuming that the above
    // is true.

    HRESULT hr = IsCallableFromCurrentApartment();
    if (FAILED(hr))
        return hr;

    hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    const int MAX_SERVER_TRIES = 3;

    for (int i = 0; i < MAX_SERVER_TRIES; i++)
    {
        // create object and get back marshaled interface pointer
        InterfaceData *pIFD = NULL;

        // Dll ignored here since we are just doing this to get
        // the remote handler.
        DWORD dwServerModel;
        WCHAR *pwszServerDll = NULL;

        HRESULT hrinterface;
        hr = gResolver.CreateInstance(
                NULL, (CLSID *)&rclsid, clsctx, 1,
                (IID *)&IID_IUnknown, &dwServerModel, &pwszServerDll,
                (MInterfacePointer **)&pIFD, &hrinterface );

        if (pwszServerDll != NULL)
        {
            CoTaskMemFree(pwszServerDll);
        }

        if (FAILED(hr))
        {
            // If an error occurred, return that otherwise convert a wierd
            // success into E_FAIL. The point here is to return an error that
            // the caller can figure out what happened.
            hr = FAILED(hr) ? hr : E_FAIL;
            break;
        }


        // make a stream out of the interface data returned, then read the
        // objref from the stream. No need to find another instance of
        // CStdMarshal because we already know it is for us!

        CXmitRpcStream Stm(pIFD);
        OBJREF  objref;
        hr = ReadObjRef(&Stm, objref);

        if (SUCCEEDED(hr))
        {
            // become this identity by unmarshaling the objref into this
            // object. Note the objref must use standard marshaling.
            Win4Assert(objref.flags & (OBJREF_HANDLER  | OBJREF_STANDARD |
                                       OBJREF_EXTENDED));
            Win4Assert(IsEqualIID(objref.iid, IID_IUnknown));

            // Server should be in a non-default context
            if (!(objref.flags & OBJREF_EXTENDED))
            {
                IUnknown *pUnk = NULL;
                hr = UnmarshalObjRef(objref, (void **)&pUnk);
                if (SUCCEEDED(hr))
                {
                    // release the AddRef done by unmarshaling
                    pUnk->Release();

                    // Reconnect the interface proxies
                    CStdMarshal::ReconnectProxies();
                }
            }
            else
            {
                hr = RPC_E_INVALID_OBJREF;
            }

            // free the objref we read above.
            FreeObjRef(objref);
        }

        CoTaskMemFree(pIFD);


        // If either this worked or we got a packet we couldn't unmarshal
        // at all we give up. Otherwise, we will hope that recontacting the
        // SCM will fix things.

        if (SUCCEEDED(hr) || (hr == E_FAIL))
        {
            break;
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_ACTIVATE, "ScmCreateObjectInstance this:%x hr:%x\n",
                this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CreateServerWithHandler, public
//
//  Synopsis:   Creates the server clsid in the given context and
//              attaches it to this handler.
//
//  History:    10-Oct-95   JohannP     Created
//              30-Oct-96   rogerg      Altered for New ServerHandler.
//
// CODEWORK:    this code is not thread safe in the freethreading case. We
//              need to decide if the thread safety is the responsibility
//              of the caller, or us. In the latter case, we would check
//              if we are already connected before doing UnmarshalObjRef, and
//              instead do a ::ReleaseMarshalObjRef.
//
//--------------------------------------------------------------------
#ifdef SERVER_HANDLER
STDMETHODIMP CStdIdentity::CreateServerWithEmbHandler(REFCLSID rclsid, DWORD clsctx,
                                        REFIID riidEmbedSrvHandler,void **ppEmbedSrvHandler, void *pv)
{
    ComDebOut((DEB_ACTIVATE, "ScmCreateObjectInstance this:%x clsctx:%x pv:%x\n",
                this, clsctx, pv));
    AssertValid();
    Win4Assert(IsClient());                         // must be client side
    Win4Assert(IsValidInterface(m_pUnkControl));    // must be valid
    //Win4Assert(!IsConnected());
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (!(m_flags & STDID_DEFHANDLER))
    {
        // this operation is not allowed except by the OLE default handler
        return E_NOTIMPL;
    }

    // Loop trying to get object from the server. Because the server can be
    // in the process of shutting down and respond with a marshaled interface,
    // we will retry this call if unmarshaling fails assuming that the above
    // is true.

    *ppEmbedSrvHandler = NULL;

    HRESULT hr = IsCallableFromCurrentApartment();
    if (FAILED(hr))
        return hr;

    hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    const int MAX_SERVER_TRIES = 3;

    for (int i = 0; i < MAX_SERVER_TRIES; i++)
    {
        // create object and get back marshaled interface pointer
        InterfaceData *pIFD = NULL;

        // Dll ignored here since we are just doing this to get
        // the remote handler.
        DWORD dwServerModel;
        WCHAR *pwszServerDll = NULL;

        // Need to ask for both IUnknown and IServerHandler so if Server Handler
        // fails or is disabled can still return the object pointer.

        HRESULT hrinterface[2];
        IID iidArray[2];
        InterfaceData *pIFDHandler[2] = { NULL, NULL };

        iidArray[0] = IID_IUnknown;
        iidArray[1] = riidEmbedSrvHandler;

        hr = gResolver.CreateInstance( NULL, (CLSID *)&rclsid, clsctx, 2,
                (IID *) iidArray, &dwServerModel, &pwszServerDll,
                (MInterfacePointer **)&pIFDHandler, &hrinterface[0] );

        if (pwszServerDll != NULL)
        {
            CoTaskMemFree(pwszServerDll);
        }

        // if failed to create object or couldn't Object IUknown interface return an error.
        if (FAILED(hr) || FAILED(hrinterface[0]) )
        {
            // If an error occurred, return that otherwise convert a wierd
            // success into E_FAIL. The point here is to return an error that
            // the caller can figure out what happened.
            hr = FAILED(hr) ? hr : E_FAIL;
            break;
        }

        // make a stream out of the Object interface data returned, then read the
        // objref from the stream. No need to find another instance of
        // CStdMarshal because we already know it is for us!

        pIFD = pIFDHandler[0];

        CXmitRpcStream Stm(pIFD);
        OBJREF  objref;
        hr = ReadObjRef(&Stm, objref);

        if (SUCCEEDED(hr))
        {
            // become this identity by unmarshaling the objref into this
            // object. Note the objref must use standard marshaling.
            Win4Assert(objref.flags & (OBJREF_HANDLER  | OBJREF_STANDARD));
            Win4Assert(IsEqualIID(objref.iid, IID_IUnknown));

            IUnknown *pUnk = NULL;
            hr = UnmarshalObjRef(objref, (void **)&pUnk);
            if (SUCCEEDED(hr))
            {
                // release the AddRef done by unmarshaling

                pUnk->Release();

                // Reconnect the interface proxies
                CStdMarshal::ReconnectProxies();
            }

            // free the objref we read above.
            FreeObjRef(objref);
        }

        CoTaskMemFree(pIFD);

        // Unmarshal the Server Handler Interface.
        // even if fail to get Server Handler continue

        if (NOERROR == hrinterface[1])
        {
            // Embedded Server handler was returned UnMarshal and get real Server Object.
            *ppEmbedSrvHandler = NULL;
            UnMarshalHelper( (MInterfacePointer *) pIFDHandler[1],riidEmbedSrvHandler,(void **) ppEmbedSrvHandler);
            CoTaskMemFree(pIFDHandler[1]);
        }


        // If either this worked or we got a packet we couldn't unmarshal
        // at all we give up. Otherwise, we will hope that recontacting the
        // SCM will fix things.

        if (SUCCEEDED(hr) || (hr == E_FAIL))
        {
            break;
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_ACTIVATE, "ScmCreateObjectInstance this:%x hr:%x\n",
                this, hr));

    if ( FAILED(hr) &&  (NULL != *ppEmbedSrvHandler) )
    {
        ( (IUnknown *) *ppEmbedSrvHandler)->Release();
        *ppEmbedSrvHandler = NULL;
    }

    return hr;
}
#endif // SERVER_HANDLER

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::AllowForegroundTransfer, public
//
//  Synopsis:   Implements IForegroundTransfer::AllowForegroundTransfer
//              Forwards to the standard marshaller.
//
//  History:    02-Feb-99   MPrabhu Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::AllowForegroundTransfer(void *lpvReserved)
{
    AssertValid();
    return CStdMarshal::AllowForegroundTransfer(lpvReserved);
}

#if DBG == 1
//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::AssertValid
//
//  Synopsis:   Validates that the state of the object is consistent.
//
//  History:    26-Jan-94   CraigWi     Created.
//
//--------------------------------------------------------------------
void CStdIdentity::AssertValid()
{
    LOCK(gComLock);

    if ((m_refs & ~CINDESTRUCTOR) >= 0x7fff)
        ComDebOut((DEB_WARN, "Identity ref count unreasonable this:%p m_refs:%x\n", this, m_refs & ~CINDESTRUCTOR));
//    AssertSz((m_refs & ~CINDESTRUCTOR) < 0x7fff, "Identity ref count unreasonable");

    if ((STDID_AGGID & m_flags) || (STDID_STCMRSHL & m_flags))
    {
        // The vtbl for the CAggId and CStdMarshal  haven't been
        // constructed yet so we can't assert the interface valid
        Win4Assert(NULL != m_pUnkOuter);
    }
    else
    {
        // ensure we have the controlling unknown
        Win4Assert(IsValidInterface(m_pUnkOuter));  // must be valid
    }

    // NOTE: don't carelessly AddRef/Release because of weak references

    // make sure only valid flags are set
    Win4Assert((m_flags & ~STDID_ALL) == 0);

    // these flags have to match up, the former is defined in olerem.h
    Win4Assert(STDID_CLIENT_DEFHANDLER == (STDID_CLIENT | STDID_DEFHANDLER));

	// if you've got the LightNA flag set, you'd better be a stub.
	if (LightNA())
		Win4Assert(!(m_flags & STDID_CLIENT) && "LightNA but not server!");

    if ((m_flags & STDID_HAVEID) &&
        !(m_flags & (STDID_FREETHREADED | STDID_IGNOREID | STDID_FTM)))
    {
		// Stubs for FTM objects and stubs for NA objects don't have this apartment affinity...
		// this is for the ease of system code, since users should never recieve an inproc 
		// reference to one of these stubs.
        Win4Assert((m_dwAptId == GetCurrentApartmentId() || IsFreeThreaded() || LightNA()) &&
                  "This object has an affinity to a particular apartment. The" &&
                  "application has attempted to call it from the wrong apartment.");

        CStdIdentity *pStdID;
        Verify(ObtainStdIDFromOID(m_moid, m_dwAptId,
                                  FALSE /*fAddRef*/, &pStdID) == NOERROR);
        Win4Assert(pStdID == this);
        // pStdID not addref'd
    }

    if (IsClient())
    {
        if (!IsCStaticMarshal())
        {
            Win4Assert(m_pUnkControl == m_pUnkOuter);
        }
    }

    // Same problem as above.
    if ((STDID_AGGID & m_flags) || (STDID_STCMRSHL & m_flags))
    {
        Win4Assert(NULL != m_pUnkControl);
    }
    else
    {
        // must have RH tell identity when object goes away so we can NULL this
        if (m_pUnkControl != NULL)
            Win4Assert(IsValidInterface(m_pUnkControl));    // must be valid
    }

    if (m_pIEC != NULL)
        Win4Assert(IsValidInterface(m_pIEC));   // must be valid

    UNLOCK(gComLock);
}
#endif // DBG == 1

//+-------------------------------------------------------------------
//
//  Function:   CreateIdentityHandler, private
//
//  Synopsis:   Creates a client side identity object (one which is
//              initialized by the first unmarshal).
//
//  Arguments:  [pUnkOuter] - controlling unknown if aggregated
//              [StdIDFlags]- flags (indicates free-threaded or not)
//              [pServerCtx]- server context
//              [dwAptId]   - client apartment ID
//              [riid]      - interface requested
//              [ppv]       - place for pointer to that interface.
//
//  History:    16-Dec-93   CraigWi     Created.
//              20-Feb-95   Rickhi      Simplified
//
//--------------------------------------------------------------------
INTERNAL CreateIdentityHandler(IUnknown *pUnkOuter, DWORD StdIdFlags,
                               CObjectContext *pServerCtx, DWORD dwAptId,
                               REFIID riid, void **ppv)
{
#if DBG == 1
	ASSERT_LOCK_NOT_HELD(gComLock);
	Win4Assert(IsApartmentInitialized());

    // if aggregating, it must ask for IUnknown.
    Win4Assert(pUnkOuter == NULL ||
               IsEqualGUID(riid, IID_IUnknown) ||
               (StdIdFlags & STDID_AGGID));

    if (pUnkOuter != NULL)
    {
        // addref/release pUnkOuter; shouldn't go away (i.e.,
        // should be other ref to it).
        // Except Excel which always returns 0 on Release!
        if (!IsTaskName(L"EXCEL.EXE"))
        {
            pUnkOuter->AddRef();
            Verify(pUnkOuter->Release() != 0);

            // verify that pUnkOuter is in fact the controlling unknown
            IUnknown *pUnkT;
            Verify(pUnkOuter->QueryInterface(IID_IUnknown,(void**)&pUnkT)==NOERROR);
            Win4Assert(pUnkOuter == pUnkT);
            Verify(pUnkT->Release() != 0);
        }
    }
#endif

    *ppv = NULL;
    IUnknown *pUnkID;
    BOOL fSuccess = FALSE;
    HRESULT hr = E_OUTOFMEMORY;

    CStdIdentity *pStdID = new CStdIdentity(StdIdFlags, dwAptId, pUnkOuter,
                                            NULL, &pUnkID, &fSuccess);

    if (pStdID && fSuccess == FALSE)
    {
        delete pStdID;
        pStdID = NULL;        
    }
    
    if (pStdID)
    {
        // get the interface the caller asked for.
        if (StdIdFlags & STDID_AGGID)
        {
            Win4Assert(IsEqualIID(riid, IID_IStdIdentity));
            *ppv = pStdID;
            hr = S_OK;
        }
        else
        {
            hr = pUnkID->QueryInterface(riid, ppv);
            pUnkID->Release();
        }

        if (SUCCEEDED(hr) && !(StdIdFlags & STDID_SYSTEM))
        {
            hr = E_OUTOFMEMORY; // assume OOM

            // Aquire lock
            LOCK(gComLock);

            // Create object identity representing the client
            CIDObject *pID = new CIDObject(pUnkOuter, pServerCtx, dwAptId,
                                           IDFLAG_CLIENT);
            // Establish object identity
            if (pID)
            {
                // Set object identity inside StdID. This will
                // AddRef the IDObject.
                pStdID->SetIDObject(pID);

                // Set the StdID inside object identity
                pID->SetStdID(pStdID);
                pID->Release();
                hr = S_OK;
				// Release lock
				UNLOCK(gComLock);
            }
            else
            {
				// Release lock
				UNLOCK(gComLock);
				*ppv = NULL;
				delete pStdID;
            }
        }
    }

    CALLHOOKOBJECTCREATE(hr,CLSID_NULL,riid,(IUnknown **)ppv);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CreateCall, public
//
//  Synopsis:   Create an async call object.
//
//  History:    15-Jul-98   Gopalk    Aggregation changes
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CreateCall(REFIID asyncIID, LPUNKNOWN pCtrlUnk,
                                      REFIID objIID, LPUNKNOWN *ppUnk)
{
    ComDebOut((DEB_CHANNEL,
               "CStdIdentity::CreateCall  asyncIID:%I pCtrlUnk:%x "
               "objIID:%I ppUnk:%x\n", &asyncIID, pCtrlUnk, &objIID, ppUnk));
    ASSERT_LOCK_NOT_HELD(gComLock);


    HRESULT hr;

    // Ensure that caller asks for IUnknown when aggregating the call object
    if(pCtrlUnk && (objIID != IID_IUnknown))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        IID syncIID;

        // Obatin the sync IID corresponding to the requested async IID
        hr = GetSyncIIDFromAsyncIID(asyncIID, &syncIID);
        if(SUCCEEDED(hr))
        {
            // Ensure that proxy for the sync IID is available
            if ((syncIID != IID_IUnknown) && (syncIID != IID_IMultiQI))
            {
                IUnknown *pUnkTest;
                hr =  QueryInterface(syncIID, (void **) &pUnkTest);
                if(SUCCEEDED(hr))
                    pUnkTest->Release();
            }

            // Create the call object
            if(SUCCEEDED(hr))
            {
                IUnknown *pInnerUnk = NULL;
                PVOID pCallMgr;
                if ((syncIID == IID_IUnknown) || (syncIID == IID_IMultiQI))
                {
                    pCallMgr = new CAsyncUnknownMgr(pCtrlUnk, syncIID, asyncIID,
                                                    this, 0, hr, &pInnerUnk);
                }
                else
                {
                    pCallMgr = new CClientCallMgr(pCtrlUnk, syncIID, asyncIID,
                                                  this, 0, hr, &pInnerUnk);
                }
                if(pCallMgr)
                {
                    if(SUCCEEDED(hr))
                    {
                        // Obtain the requested interface on the call object
                        if(pCtrlUnk == NULL)
                        {
                            hr = pInnerUnk->QueryInterface(objIID, (void **)ppUnk);

                            // Fix up the refcount. This could be the last release
                            // if the above call failed
                            pInnerUnk->Release();
                        }
                        else
                            *ppUnk = pInnerUnk;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "CStdIdentity::CreateCall hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::GetWrapperForContext
//
//  Synopsis:   Finds or creates a valid wrapper for our server object
//              in the requested context.
//
//  Arguments:  pCtx- The client context for the wrapper
//              riid- The IID of the returned wrapper
//              ppv-  Pointer to the return location
//
//  History:    29-Sep-00   JohnDoty      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdIdentity::GetWrapperForContext(CObjectContext *pCtx,
                                                REFIID riid,
                                                void **ppv)
{
    HRESULT hr = E_UNEXPECTED;

    // Get or create the wrapper for this object.
    CIDObject *pID = GetIDObject();
    if (pID)
    {
        // If we don't have a server, we cannot create a wrapper.
        // REVIEW: Can we change this?  Should we change this?
        BOOL fCreate = GetCtrlUnk() ? TRUE : FALSE;
        CStdWrapper *pStdWrapper = NULL;

        // Make sure to hold the lock across GetOrCreateWrapper()
        LOCK(gComLock);
        hr = pID->GetOrCreateWrapper(fCreate, 0, &pStdWrapper);
        UNLOCK(gComLock);

        if (SUCCEEDED(hr))
        {            
            // Now that we have the wrapper, get the proxy for the server
            // on it.
            hr = pStdWrapper->WrapInterfaceForContext(pCtx, NULL, riid, ppv);

            // Since WrapInterfaceForContext does not give us a new reference,
            // we'll re-use the one from GetOrCreateWrapper if it succeeded.
            if (FAILED(hr))
            {
                pStdWrapper->InternalRelease(NULL);
            }
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ObtainStdIDFromUnk      Private
//
//  Synopsis:   Obtains the StdID representing the server object
//              Modified version of LookupIDFromUnk
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT ObtainStdIDFromUnk(IUnknown *pUnk, DWORD dwAptId, CObjectContext *pServerCtx,
                           DWORD dwFlags, CStdIdentity **ppStdID)
{
    // QI for IStdID; if ok, return that
    if (SUCCEEDED(pUnk->QueryInterface(IID_IStdIdentity, (void **) ppStdID)))
        return S_OK;

    // Obtain pointer id
    IUnknown *pServer;
    if (FAILED(pUnk->QueryInterface(IID_IUnknown, (void **) &pServer)))
        return E_UNEXPECTED;

    BOOL fCreate = (dwFlags & IDLF_CREATE) ? TRUE : FALSE;

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Lookup StdID for the server object
    CIDObject *pID = NULL;
    HRESULT hr = gPIDTable.FindOrCreateIDObject(pServer, pServerCtx, fCreate,
                                                dwAptId, &pID);

    if (SUCCEEDED(hr))
    {
        hr = pID->GetOrCreateStdID(fCreate, dwFlags, ppStdID);
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (pID) {

        if (FAILED (hr))
        {
            // The call to GetOrCreateStdID failed for some reason.
            // If pID doesn't have an StdID here, then it wasn't Addref'd
            // and may be released below without having been marked as a 'zombie',
            // causing an Assert to be fired during debug builds (COM+ BUG 14310)
            //
            // Calling StdIDRelease will ensure that if pID has no StdID (either via
            // the call made above or through another thread's intervention), 
            // the object will marked as a 'zombie' when it is released
            
            ComDebOut((DEB_CHANNEL, "GetOrCreateStdID failed, calling StdIDRelease hr:%x\n", hr));
            pID->StdIDRelease();
        }
        
        pID->Release();
    }
    
    pServer->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   GetStdId, private
//
//  Synopsis:   Creates a std id.
//
//  Arguments:  [punkOuter] - controlling unknown
//              [ppv] - The coresponding identity object if successfull
//
//  Returns:    S_OK - have the identity object
//
//  History:    16-Nov-96   Rickhi  Created
//              12-Mar-98   Gopalk  Modified for new ID Tables
//
//--------------------------------------------------------------------
INTERNAL GetStdId(IUnknown *punkOuter, IUnknown **ppUnkInner)
{
    HRESULT hr = E_OUTOFMEMORY;

    DWORD dwAptId = GetCurrentApartmentId();
    BOOL fSuccess = FALSE;
    
    CStdIdentity *pStdID = new CStdIdentity(STDID_SERVER, dwAptId,
                                            punkOuter, punkOuter,
                                            ppUnkInner, &fSuccess);

    if (pStdID && fSuccess == FALSE)
    {
    	delete pStdID;
    	pStdID = NULL;
    }
    
    if (pStdID)
    {
        Win4Assert(pStdID->IsAggregated());

        // Obtain an OID for the server object
        MOID moid;
        hr = GetPreRegMOID(&moid);

        if (SUCCEEDED(hr))
        {
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Ensure the StdID has not already been created
            // for the server object
            CIDObject *pID = NULL;
            hr = gPIDTable.FindOrCreateIDObject(punkOuter, GetCurrentContext(),
                                                TRUE /*fCreate*/, dwAptId,
                                                &pID);
            if (SUCCEEDED(hr))
            {
                if (pID->GetStdID() == NULL)
                {
                    // Set object identity inside StdID. This
                    // will AddRef the IDObject.
                    pStdID->SetIDObject(pID);

                    // Set the StdID inside object identity
                    pID->SetStdID(pStdID);

                    // Establish OID for the object. This registers it
                    // with the gOIDTable.
                    pStdID->SetOID(moid);
                }
                else
                {
                    hr = RPC_E_TOO_LATE;
                }
            }

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            if (pID)
            {
                // release the reference to the IDObject
                pID->Release();
            }
        }

        if (FAILED(hr))
        {
            (*ppUnkInner)->Release();
            *ppUnkInner = NULL;
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ObtainStdIDFromOID      Private
//
//  Synopsis:   Obtains the StdID representing the server object
//              Modified version of LookupIDFromID
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT ObtainStdIDFromOID(REFMOID moid, DWORD dwAptId, BOOL fAddRef,
                           CStdIdentity **ppStdID)
{
    ASSERT_LOCK_HELD(gComLock);

    CStdIdentity *pStdID = NULL;

    // Lookup the OID in OID table
    CIDObject *pID = gOIDTable.Lookup(moid, dwAptId);
    if(pID)
    {
        // Obtain the StdID
        pStdID = pID->GetStdID();
        if(fAddRef && pStdID)
           pStdID->AddRef();

        // This cannot be the last release
        pID->Release();
    }

    // Initialize
    *ppStdID = pStdID;

    return (pStdID == NULL) ? CO_E_OBJNOTREG : NOERROR;
}

#if DBG == 1
//+-------------------------------------------------------------------
//
//  Function:   Dbg_FindRemoteHdlr
//
//  Synopsis:   finds a remote object handler for the specified object,
//              and returns an instance of IMarshal on it. This is debug
//              code for assert that reference counts are as expected and
//              is used by tmarshal.exe.
//
//  History:    23-Nov-93   Rickhi       Created
//              23-Dec-93   CraigWi      Changed to identity object
//
//--------------------------------------------------------------------
extern "C" IMarshal * _stdcall Dbg_FindRemoteHdlr(IUnknown *punkObj)
{
    //  validate input parms
    Win4Assert(punkObj);

    IMarshal *pIM = NULL;
    CStdIdentity *pStdID = NULL;

    // Try to obtain the StdID from the current apartment/context.
    //
    HRESULT hr = ObtainStdIDFromUnk(punkObj,
                                    GetCurrentApartmentId(),
                                    GetCurrentContext(),
                                    0,
                                    &pStdID);

    // If no StdID in this apartment/context, switch to the NA and
    // try again.
    //
    if (FAILED(hr))
    {
        // Switch thread to the NA.
        CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx);

        hr = ObtainStdIDFromUnk(punkObj,
                                GetCurrentApartmentId(),
                                GetCurrentContext(),
                                0,
                                &pStdID);

        // Pop back to the apartment the thread was in on entry.
        //
        pSavedCtx = LeaveNTA(pSavedCtx);
        Win4Assert(pSavedCtx == g_pNTAEmptyCtx);
    }

    if (hr == NOERROR)
    {
        pIM = (IMarshal *)pStdID;
    }

    return pIM;
}
#endif  //  DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\stub_rawprivact_c.c ===
/* Stub for generated file rawprivact_c.c */
#include <rawprivact_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\svcdomain.cxx ===
//+-------------------------------------------------------------------
//
//  File:       svcdomain.cxx
//
//  Contents:   Services Without Components APIs
//
//  Functions:  CoPushServiceDomain
//              CoPopServiceDomain
//
//  Notes:      This code represents the APIs provided to COM+ by
//              ole32.dll in order to enable services without components
//
//  History:    02-08-2001  mfeingol created
//
//+-------------------------------------------------------------------

#include "ole2int.h"
#include "crossctx.hxx"

STDAPI CoPushServiceDomain (IObjContext* pObjContext)
{
    if (!pObjContext || !IsValidInterface (pObjContext))
    {
        return E_INVALIDARG;
    }
    
    if (!IsApartmentInitialized())
    {
        return CO_E_NOTINITIALIZED;
    }

    return EnterServiceDomain (pObjContext);
}

STDAPI CoPopServiceDomain (IObjContext** ppObjContext)
{   
    if (!ppObjContext)
    {
        return E_INVALIDARG;
    }

    return LeaveServiceDomain (ppObjContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\surract.cxx ===
//+-------------------------------------------------------------------
//
//  File:       surract.cxx
//
//  Contents:   Implementation of surrogate process activator
//
//  Classes:    CSurrogateProcessActivator
//
//  History:    08-Apr-98   SteveSw      Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <activate.h>
#include <catalog.h>
#include <resolver.hxx>
#include <stdid.hxx>
#include <comsrgt.hxx>
#include <srgtprot.h>
#include <unisrgt.h>
#include <surract.hxx>
#include <netevent.h>

//=========================================================================
//
//  CSurrogateProcessActivator Class Definition
//
//  This class is not intended to be used in inheritance. It's not intended
//  that more than one of these exist in a particular process. In
//  particular, some of the resolver tools used to communicate with the SCM
//  won't work if you create several of these.
//
//-------------------------------------------------------------------------

class CSurrogateProcessActivator :
public CSurrogateActivator,
public ISurrogate,
public IPAControl,
public IProcessInitControl
{
    // Constructors and destructors.

public:
    CSurrogateProcessActivator();
    ~CSurrogateProcessActivator();
	
    HRESULT Initialize();

    inline void SetProcessGUID(REFGUID processGuid)
    {
        extern GUID g_AppId;

        g_AppId = processGuid;
        m_processGuid = processGuid;
    }

    // Our IUnknown implementation

public:
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

private:
    LONG m_lRC;


    // Methods and members that handle the dialog between Surrogate and SCM.

public:
    STDMETHOD(TellSCMWeAreStarted)(REFGUID rguidProcessID);
    STDMETHOD(TellSCMWeAreReady)(void);
    STDMETHOD(TellSCMWeAreDone)(void);
    STDMETHOD(TellSCMWeAreInitializing)(void);

private:
    static DWORD WINAPI StartNTService(LPVOID ptr);
    static DWORD WINAPI PingSCM(LPVOID ptr);
    STDMETHOD(StartSendingSCMPings)(void);
    STDMETHOD(StopSendingSCMPings)(void);

    HANDLE m_hInitThread;

public:
    HANDLE m_hStopPingingSCM;

    static const PING_INTERVAL;

    // Methods and members that open the catalog, read from it, stash
    // away data found there, and/or act on the data while it's available.
    // Several of these methods feed later groups of functions, in that they
    // stash away data used by them.

public:
    STDMETHOD(OpenCatalog)(REFGUID rguidProcessID);
    STDMETHOD(StartNTServiceIfNecessary)(void);
    STDMETHOD(SetupSecurity)(void);
    STDMETHOD(SetupSurrogateTimeout)(void);
    STDMETHOD(AreServicesRequired)(void);
    STDMETHOD(SetupFusionContext)(void);
    STDMETHOD(CloseCatalog)(void);

private:
    IComProcessInfo* m_pIComProcessInfo;
    IProcessServerInfo* m_pIProcessServerInfo;
    CStdIdentity *m_pStdID;


    // These members are about ISurrogate interfaces. An ISurrogate interface
    // is passed down to us from the Surrogate host program; we store it,
    // and pass along an ISurrogate interface implemeneted by this class to
    // the COM infrastructure. The infrastructure calls our FreeSurrogate()
    // method when the process becomes inactive; we pass the call along to
    // the Surrogate host program when timeouts and locks are all right.
public:
    STDMETHOD(StoreISurrogate)(ISurrogate* pISurrogate);
    STDMETHOD(RemoveISurrogate)(void);
    STDMETHOD(LoadDllServer)(REFCLSID rclsid);
    STDMETHOD(FreeSurrogate)(void);

private:
    ISurrogate* m_pISurrogate;


    // These methods initialize the COMSvcs modules as requested in the
    // catalog, and then delete them later.  The HINSTANCE is for the COMSVCS.DLL.
    // IPAControl methods follow

public:
    STDMETHOD(InitializeServices)(REFGUID rguidProcessID);
    STDMETHOD(CleanupServices)(void);
    STDMETHOD(WaitForInitCompleted)(ULONG ulStartingCount, ULONG ulMaxWaits);

private:
    HINSTANCE      m_hCOMSVCS;
    IServicesSink* m_pServices;
    HANDLE         m_hInitCompleted;
    HANDLE         m_hFusionContext;
    ULONG          m_ulServicesPing;
    ULONG          m_ulInitTimeout;

    static const TIMEOUT_SERVICES;

public:
    STDMETHOD_(ULONG, AddRefOnProcess)(void);
    STDMETHOD_(ULONG, ReleaseRefOnProcess)(void);
    STDMETHOD_(void, PendingInit)(void);
    STDMETHOD_(void, ServicesReady)(void);
    STDMETHOD(SuspendApplication)( REFGUID rguidApplID );
    STDMETHOD(PendingApplication)( REFGUID rguidApplID );
    STDMETHOD(ResumeApplication)( REFGUID rguidApplID );
    STDMETHOD(SuspendAll)(void);
    STDMETHOD(ResumeAll)(void);
    STDMETHOD(ForcedShutdown)(void);
	STDMETHOD(SetIdleTimeoutToZero)(void);

private:
    LONG m_lProcessRefCount;

    // These methods and members implement the surrogate timeout logic. They're
    // fed by StoreISurrogate() and SetupSurrogateTimeout(), above. Check out
    // the description of the state transitions in the timeout logic, below.
private:
    CRITICAL_SECTION m_timeoutLock;
    BOOL m_bLockValid;
    HANDLE m_hTimeoutEvent;
    static DWORD WINAPI SurrogateTimeout(LPVOID ptr);
    STDMETHOD(BeginSurrogateTimeout)(void);
    STDMETHOD(ActivationBegins)(void);
    STDMETHOD(ActivationSucceeds)(void);
    STDMETHOD(ActivationFails)(void);

public:
    STDMETHOD(WaitForSurrogateTimeout)(void);

private:
    void LockTimeoutState()
    {
        EnterCriticalSection(&m_timeoutLock);
    }
    void UnlockTimeoutState()
    {
        LeaveCriticalSection(&m_timeoutLock);
    }

    enum
    {
        TIMEOUT_INACTIVE,
        TIMEOUT_PENDING,
        TIMEOUT_SUSPENDED,
        TIMEOUT_HAPPENING,
        TIMEOUT_FORCED_SHUTDOWN
    } m_timeoutState;
	
	// We had problems with VB objects Av'ing when we shutdown immediately upon
	// idle.    To avoid this we remain idle for this minimum # of milliseconds
    #define MINIMUM_IDLE_SHUTDOWN_PERIOD_MSEC    5000      

    ULONG m_cActivations;
    ULONG m_cMillisecondsTilDeath;
    DWORD m_cTimeoutPeriod;
    BOOL  m_bPaused;

    static const TIMEOUT_SPINLOCK;

public:
    // These methods implement the IProcessInitControl interface, used by COM+
    // user process-initialization to ping us (so that we don't think they are
    // wedged).
    STDMETHOD(ResetInitializerTimeout)(DWORD dwSecondsRemaining);

private:
    BOOL  m_bInitNotified;


    // The SPA provides the SCM an ILocalSystemActivator interface. This is
    // the portal through which all out-of-process activations arrive in
    // the process from the SCM. In some sense this is our raison-d'etre.
public:
    STDMETHOD(GetClassObject)(IActivationPropertiesIn *pActPropsIn,
                              IActivationPropertiesOut **ppActPropsOut);

    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter,
                              IActivationPropertiesIn *pActPropsIn,
                              IActivationPropertiesOut **ppActPropsOut);
    STDMETHOD(ObjectServerLoadDll)(GUID* pclsid, STATUSTYPE* pStatus);


    // These methods are to support running as an NT Service
public:
    static void NTServiceMain        (DWORD argc, LPWSTR *argv);
    static void NTServiceCtrlHandler (DWORD code);

private:
    HANDLE m_hNTServiceThread;
    SERVICE_STATUS_HANDLE m_hNTServiceHandle;
    SERVICE_STATUS        m_NTServiceStatus;
    WCHAR                 m_NTServiceName[256];
};


//=========================================================================
//
//  TIMEOUT_SPINLOCK controls the spinlock behavior of the critical section
//  used to guard the state of the activity timeout mechanism.
//
//      TIMEOUT_SERVICES is the duration within which COMSVCS must ping us or
//      we will fail initialization assuming it is hung or otherwise confused.
//
//  s_pCSPA is the static pointer to the single CSurrogateProcessActivator
//  object we create here. It's an object because, hey, we're object
//  oriented folks here, right? And I guess there's the namespace issues.
//
//-------------------------------------------------------------------------

const CSurrogateProcessActivator::TIMEOUT_SPINLOCK = 1000;
const CSurrogateProcessActivator::TIMEOUT_SERVICES = 20000;
const CSurrogateProcessActivator::PING_INTERVAL    = 30000;

CSurrogateProcessActivator* s_pCSPA = NULL;
CSurrogateActivator* CSurrogateActivator::s_pCSA = NULL;

// these are typical values for the WaitForInitCompleted() routine
#define INIT_STARTING   1
#define MAX_WAITS       6


//============================================================================
//
//  Function:   CoRegisterSurrogateEx (public)
//
//  Synopsis:   Called by a surrogate host process to register itself with
//                              COM.
//
//  History:    08-Apr-98   SteveSw      Created
//              13-Dec-99   JohnDoty     Modified to support running as
//                                       an NT Service
//
//----------------------------------------------------------------------------

STDAPI CoRegisterSurrogateEx (REFGUID rguidProcessID, ISurrogate* pSrgt)
{
    HRESULT hr = E_FAIL;
    BOOL    fLoadServices = FALSE;

    //  Error checking
    if ( s_pCSPA != NULL )
    {
        return CO_E_ALREADYINITIALIZED;
    }
    if ( !IsApartmentInitialized() )
    {
        return CO_E_NOTINITIALIZED;
    }


    //  Create the controlling CSurrogateProcessActivator object. Notify the
    //  SCM that we're beginning our initialization.
    s_pCSPA = new CSurrogateProcessActivator;
    if ( s_pCSPA == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = s_pCSPA->Initialize();
    if (FAILED(hr))
    {       
        s_pCSPA->Release();
        s_pCSPA = NULL;
        return hr;
    }

    //  Open up the catalog, and pull out all the data we need to remember
    //  in order to make everything else work. The error logic here is,
    //  we bail if we had problems with the catalog. The only cleanup we
    //  have to do is with the SCM.

    hr = s_pCSPA->OpenCatalog(rguidProcessID);
    if ( SUCCEEDED(hr) )
    {
        hr = s_pCSPA->StartNTServiceIfNecessary();
    }
    if ( SUCCEEDED(hr) )
    {
        hr = s_pCSPA->SetupFusionContext();
    }
    if ( SUCCEEDED(hr) )
    {
        hr = s_pCSPA->SetupSecurity();
    }
    if ( SUCCEEDED(hr) )
    {
        hr = s_pCSPA->SetupSurrogateTimeout();
    }
    if ( SUCCEEDED(hr) )
    {
        fLoadServices = ( s_pCSPA->AreServicesRequired() == S_OK );
    }

    HRESULT hr2 = s_pCSPA->CloseCatalog();
    if ( FAILED(hr2) || FAILED(hr) )
    {
        goto cleanup;
    }

    //  Ensure there is a main threaded apartment by ensuring there is a DLLHost
    //  AT thread.  This ensures that none of the STA Pool threads become the
    //  main thread, which can produce unpredictable results

    IUnknown *pHostAct;
    hr = CoCreateInstance(CLSID_ATHostActivator,
                          NULL,
                          CLSCTX_ALL,
                          IID_IUnknown,
                          (void **) &pHostAct);

    if ( FAILED(hr) )
    {
        if (hr != REGDB_E_CLASSNOTREG)
        {
            goto cleanup;
        }
    }
    else
    {
        // release this object. we only wanted the side effect.
        pHostAct->Release();
    }
    
    //  Now we tell the SCM we're starting up in earnest. The "bad thing"
    //  here would be if the total time between when DLLHOST is started and
    //  now was more than 90 seconds.
    hr = s_pCSPA->TellSCMWeAreStarted(rguidProcessID);
    if ( FAILED(hr) )
    {
        goto cleanup;
    }

    // Save process Guid
    s_pCSPA->SetProcessGUID(rguidProcessID);

    //  Do our real startup. We start up the services living undreneath us
    //  first, then we tell COM that we're running, and finally we tell the
    //  SCM that we're ready to accept activations. This order should avoid
    //  race conditions where one part of our infrastructure.
    if ( fLoadServices )
    {
        hr = s_pCSPA->InitializeServices(rguidProcessID);
        if ( FAILED(hr) )
        {
            hr = RPC_S_SERVER_TOO_BUSY;
            goto cleanup;
        }
    }

    hr = s_pCSPA->StoreISurrogate(pSrgt);
    if ( FAILED(hr) )
    {
        goto cleanup;
    }
    hr = s_pCSPA->TellSCMWeAreReady();
    if ( FAILED(hr) )
    {
        goto cleanup;
    }

    //  Now wait for the end

    hr = s_pCSPA->WaitForSurrogateTimeout();

    cleanup:
    (void) s_pCSPA->RemoveISurrogate();
    (void) s_pCSPA->CleanupServices();
    (void) s_pCSPA->TellSCMWeAreDone();
    (void) s_pCSPA->Release();
    s_pCSPA = NULL;

    return hr;
}


//============================================================================
//
//  Constructors and destructors for CSurrogateProcessActivator
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::CSurrogateProcessActivator
//
//  Synopsis:   Constructor for CSurrogateProcessActivator object. Does nothing
//                              but initializations
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------
CSurrogateProcessActivator::CSurrogateProcessActivator() :
m_cActivations(0),
m_cMillisecondsTilDeath(0),
m_cTimeoutPeriod(INFINITE),
m_pStdID(NULL),
m_hInitThread(NULL),
m_hNTServiceThread(NULL),
m_hStopPingingSCM(NULL),
m_hTimeoutEvent(NULL),
m_hFusionContext(INVALID_HANDLE_VALUE),
m_lRC(0),
m_hCOMSVCS(NULL),
m_pServices(NULL),
m_hInitCompleted(NULL),
m_ulServicesPing(0),
m_pIComProcessInfo(NULL),
m_pIProcessServerInfo(NULL),
m_pISurrogate(NULL),
m_timeoutState(TIMEOUT_INACTIVE),
m_lProcessRefCount(0),
m_bPaused(FALSE),
m_bInitNotified(FALSE),
m_hNTServiceHandle(NULL),
m_bLockValid(FALSE),
m_ulInitTimeout(TIMEOUT_SERVICES)
{
    m_hStopPingingSCM = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hTimeoutEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hInitCompleted = CreateEvent(NULL, FALSE, FALSE, NULL);
    AddRef();
    s_pCSA = (CSurrogateActivator *) this;
    m_fServicesConfigured = FALSE;

    m_NTServiceStatus.dwServiceType      = SERVICE_WIN32;
    m_NTServiceStatus.dwCurrentState     = SERVICE_START_PENDING;
    m_NTServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
    m_NTServiceStatus.dwWin32ExitCode    = 0;
    m_NTServiceStatus.dwServiceSpecificExitCode = 0;
    m_NTServiceStatus.dwCheckPoint       = 0;
    m_NTServiceStatus.dwWaitHint         = PING_INTERVAL * 2;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::Initialize
//
//  Synopsis:   Small init function to break out non-trivial init work from
//              the constructor.
//
//  History:    13-Apr-00   JSimmons   Created
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::Initialize()
{
    m_bLockValid = InitializeCriticalSectionAndSpinCount(&m_timeoutLock, TIMEOUT_SPINLOCK);
    
    return m_bLockValid ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::~CSurrogateProcessActivator
//
//  Synopsis:   Constructor for CSurrogateProcessActivator object. Should be
//                              able to cleanup from any state. Relies on the idempotency of
//                              each independent initialization/cleanup routine
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

CSurrogateProcessActivator::~CSurrogateProcessActivator()
{
    s_pCSA = NULL;
    CloseHandle (m_hStopPingingSCM);
    CloseHandle (m_hTimeoutEvent);
    CloseHandle (m_hInitCompleted);
    if (m_bLockValid)
        DeleteCriticalSection (&m_timeoutLock);

    // check that the services DLL (if any) has been released and free'd
    if ( m_pServices )
    {
        m_pServices->Release();
    }

    if( m_hFusionContext != INVALID_HANDLE_VALUE)
    {
        ReleaseActCtx(m_hFusionContext);
    }

    if ( m_hCOMSVCS )
    {
        FreeLibrary( m_hCOMSVCS );
    }
}


//============================================================================
//
//  IUnknown implementation for CSurrogateProcessActivator
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::QueryInterface
//
//  Synopsis:   Garden-variety QI() implementation for object
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::QueryInterface(REFIID riid, void** ppv)
{
    if ( ppv == NULL )
    {
        return E_POINTER;
    }

    if ( riid == IID_ILocalSystemActivator || riid == IID_IUnknown )
    {
        *ppv = (ILocalSystemActivator*)(this);
    }
    else if ( riid == IID_ISurrogate )
    {
        *ppv = static_cast<ISurrogate*>(this);
    }
    else if ( riid == IID_IPAControl )
    {
        *ppv = static_cast<IPAControl*>(this);
    }
    else if ( riid == IID_IProcessInitControl )
    {
        *ppv = static_cast<IProcessInitControl*>(this);
    }
    else
    {
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::AddRef
//
//  Synopsis:   Garden-variety AddRef() implementation for object
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSurrogateProcessActivator::AddRef(void)
{
    LONG lRC = 0xcdcdcdcd;

    lRC = InterlockedIncrement(&m_lRC);
    return lRC;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::Release
//
//  Synopsis:   Garden-variety Release() implementation for object
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSurrogateProcessActivator::Release(void)
{
    LONG lRC = 0xcdcdcdcd;

    lRC = InterlockedDecrement(&m_lRC);
    if ( lRC == 0 )
    {
        delete this;
    }
    return lRC;
}


//============================================================================
//
//  Methods that communicate with the SCM. These rely heavily on the gResolver
//  methods to abstract from the grotty details of communicating with the SCM.
//  They add is the logic to go fetch the IPID for this's ILocalSystemActivator
//  interface, and to deal with the periodic ping's we need to send them SCM
//  if it's taking us a long time to come up.
//
//  The SCM expects four different messages from us. "Started" means we have
//  started to come up. "Initializing" means, don't worry, we're still coming
//  up. "Ready" means we're ready for activations. "Stopped" means we're no
//  longer capable of handling activations.
//
//  These routines need not be thread-safe. We can count on them being called
//  during CoRegisterSurrogateEx(), and then from the Timeout worker thread
//  (there should only ever be one of those, and it won't appear until
//  after CoRegisterSurrogateEx() returns -- if it does, go ahead and grab
//  the TimeoutState lock in that routine, which will block all activations
//  and timeout activity while it's held).
//
//  The Initializing methods are sent to the SCM every thirty seconds, between
//  the times we say "Started" and "Ready". This is done by spinning up a
//  thread that just loops over a 30-second sleep and a call to the resolver
//  to send the ping. To stop these messages, we just hammer the thread.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::TellSCMWeAreStarted
//
//  Synopsis:   Using gResolver, tell the SCM that we're beginning to
//                              initialize ourselves for this ProcessID
//
//  History:    08-Apr-98   SteveSw      Created
//              15-Jun-98   GopalK       Simplified marshaling
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::TellSCMWeAreStarted(REFGUID rguidProcessID)
{
    HRESULT hr = E_FAIL;
    ProcessActivatorToken       procActToken;

    // This routine is called to register the interface with the bowels of
    // COM, so that we can get the IPID back we need in order to let the SCM
    // know how to pass activation requests for this processID back to the
    // surrogate.
    OBJREF objref;
    hr = MarshalInternalObjRef(objref,
                               IID_ILocalSystemActivator,
                               (ILocalSystemActivator*)(this),
                               MSHLFLAGS_NORMAL | MSHLFLAGS_NOPING, (void **) &m_pStdID);

    // gResolver's NotifySurrogateStarted() method needs this special
    // token to identify our ILocalSystemActivator interface to the SCM. We
    // build it and pass it to gResolver
    if ( SUCCEEDED(hr) )
    {
        procActToken.ProcessGUID = rguidProcessID;
        procActToken.ActivatorIPID = objref.u_objref.u_standard.std.ipid;
        procActToken.dwFlags = 0;  // flags field not currently being used

        hr = gResolver.NotifySurrogateStarted(&procActToken);
        FreeObjRef(objref);
    }
    else
        m_pStdID = NULL;

    // Once we've told the SCM we're starting, we kick off a process that
    // will periodically remind it that we're still here.
    if ( SUCCEEDED(hr) )
    {
        hr = StartSendingSCMPings();
    } 
    else 
    {
        if (m_pStdID)
        {
            ((CStdMarshal *) m_pStdID)->Disconnect(DISCTYPE_SYSTEM);
            m_pStdID->Release();
            m_pStdID = NULL;
        }
    }

    // Report....
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::TellSCMWeAreReady
//
//  Synopsis:   Using gResolver, tell the SCM that we're ready for activations
//                              for objects with this ProcessID. First, turn off those pings!
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::TellSCMWeAreReady()
{
    HRESULT hr = E_FAIL;

    hr = StopSendingSCMPings();
    if ( SUCCEEDED(hr) )
    {
        m_NTServiceStatus.dwCurrentState = SERVICE_RUNNING;
        m_NTServiceStatus.dwCheckPoint   = 0;
        m_NTServiceStatus.dwWaitHint     = 0;

        if (m_hNTServiceHandle)
        {
            if (!SetServiceStatus (m_hNTServiceHandle, &(m_NTServiceStatus)))
            {
                DWORD err = GetLastError();
                hr = HRESULT_FROM_WIN32(err);
            }
        }

        if ( SUCCEEDED(hr) )
            hr = gResolver.NotifySurrogateReady();
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::TellSCMWeAreDone
//
//  Synopsis:   The role of this routine is to be ready, regardless of the
//                              state of things, to clean up after the SCM connection tools.
//
//  History:    08-Apr-98   SteveSw      Created
//              15-Jun-98   GopalK       Simplified destruction
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::TellSCMWeAreDone()
{
    HRESULT                     hr                      = S_OK;
    ILocalSystemActivator*      pILocalSystemActivator  = NULL;

    // If we call this while we're pinging, we stop that first. Then, if we
    // have a valid objref to ourselves (we created it when we told the SCM
    // we were starting), we tell the SCM we're stopping, release the objref,
    // and then free it. This undoes all the stuff we did to the infrastructure
    // when we first created the marshaled internal objref.
    (void) StopSendingSCMPings();

    if (m_hNTServiceHandle)
    {
        m_NTServiceStatus.dwCurrentState = SERVICE_STOPPED;
        m_NTServiceStatus.dwCheckPoint   = 0;
        m_NTServiceStatus.dwWaitHint     = 0;
        if (!SetServiceStatus (m_hNTServiceHandle, &(m_NTServiceStatus)))
        {
            DWORD err = GetLastError();
            hr = HRESULT_FROM_WIN32(err);
        }
    }

    if ( m_pStdID )
    {
        (void) gResolver.NotifySurrogateStopped();
        ((CStdMarshal *) m_pStdID)->Disconnect(DISCTYPE_SYSTEM);
        m_pStdID->Release();
        m_pStdID = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::TellSCMWeAreInitializing
//
//  Synopsis:   This routine tells the SCM that we're transitioning into the
//              "running user initializer" state.  This state is used by COM+
//              to allow for potentially very long-running initializations.
//
//  History:    24-May-01   JohnDoty     Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::TellSCMWeAreInitializing()
{
    HRESULT hr = S_OK;

    if (!m_bInitNotified)
    {
        // Make sure we only tell the SCM once (since this can be called from
        // wherever).
        BOOL fOrig = (BOOL)InterlockedCompareExchange((LONG *)&m_bInitNotified, TRUE, FALSE);
        if (!fOrig)
        {
            hr = gResolver.NotifySurrogateUserInitializing();
            if (FAILED(hr))
                m_bInitNotified = FALSE; // Oops.
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::PingSCM
//
//  Synopsis:   This thread just loops, sending an Initialize() message to the
//                              SCM every thirty seconds. To stop the messages, kill the
//                              thread.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

DWORD WINAPI CSurrogateProcessActivator::PingSCM(LPVOID ptr)
{
    HRESULT hr = E_FAIL;
    CSurrogateProcessActivator* pSCPA = static_cast<CSurrogateProcessActivator*>(ptr);

    while ( WaitForSingleObject( pSCPA->m_hStopPingingSCM, PING_INTERVAL ) == WAIT_TIMEOUT )
    {
        if (pSCPA->m_hNTServiceHandle)
        {
            pSCPA->m_NTServiceStatus.dwCheckPoint++;
            SetServiceStatus(pSCPA->m_hNTServiceHandle, &(pSCPA->m_NTServiceStatus));
        }
        hr = gResolver.NotifySurrogateInitializing();
    }

    return 0;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StartSendingSCMPings
//
//  Synopsis:   Create the thread that will loop and send pings to the SCM
//                              every thirty seconds while we are starting up....
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::StartSendingSCMPings(void)
{
    DWORD                       threadID            = 0xcdcdcdcd;

    if ( m_hInitThread == NULL )
    {
        m_hInitThread = CreateThread (NULL, 0,
                                      CSurrogateProcessActivator::PingSCM,
                                      (PVOID) this, 0, &threadID);
        if ( m_hInitThread == NULL )
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StopSendingSCMPings
//
//  Synopsis:   Undo whatever StartSendingSCMPings() did. In this case, kill
//                              the thread. Close its handle. Return.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::StopSendingSCMPings(void)
{
    DWORD dwRet = 0;

    if ( m_hInitThread != NULL )
    {
        SetEvent(m_hStopPingingSCM);
        dwRet = WaitForSingleObject(m_hInitThread, 20000);  // 20 second wait
        CloseHandle(m_hInitThread);
        m_hInitThread = NULL;
        return ( ( dwRet == WAIT_OBJECT_0 ) ? S_OK : RPC_S_SERVER_TOO_BUSY ) ;
    }
    return S_FALSE;
}


//============================================================================
//
//  Methods that communicate with the catalog. Basically, what we have here
//  is an OpenCatalog(), a CloseCatalog(), and a bunch of SetupXXX() routines,
//  once for each component of the system. Basically, OpenCatalog() caches
//  interface pointers to the Catalog objects required by the SetupXXX()
//  routines. CloseCatalog() is responsible for cleaning up this cache if
//  there are any interfaces lying about. The SetupXXX() methods fill
//  variables, but it is the responsibility of whatever routine cleans up
//  the XXX tools to clean up the variables read in from the catalog
//  (if such cleanup is needed).
//
//  Other than that, no rocket science.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::OpenCatalog
//
//  Synopsis:   Open up all the catalog interfaces we need to self-configure.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::OpenCatalog(REFGUID rguidProcessID)
{
    HRESULT hr = E_FAIL;

    // Failures are sent back to caller. We use the OLE global catalog pointer.
    // We hope to leave one or more of the other interfaces non-null. We only
    // get the interfaces if the pointers have NULL values. Otherwise, this
    // has probably been called twice.

    hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_pIComProcessInfo == NULL )
    {
        hr = gpCatalog->GetProcessInfo(rguidProcessID,
                                       IID_IComProcessInfo,
                                       (void**) &m_pIComProcessInfo);
    }
    if ( SUCCEEDED(hr) && m_pIProcessServerInfo == NULL )
    {
        hr = m_pIComProcessInfo->QueryInterface(IID_IProcessServerInfo,
                                                (void**) &m_pIProcessServerInfo);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StartNTServiceIfNecessary()
//
//  Synopsis:   Register ourselves with the NT Service Control Manager if
//              we've been marked for activation as an NT service.
//
//  History:    13-Dec-99   JohnDoty      Created
//
//----------------------------------------------------------------------------

static const GUID APPID_SystemApp = 
{0x02D4B3F1,0xFD88,0x11D1,{0x96,0x0D,0x00,0x80,0x5F,0xC7,0x92,0x35}};

STDMETHODIMP CSurrogateProcessActivator::StartNTServiceIfNecessary (void)
{
    HRESULT hr = S_OK;
    WCHAR  *pServiceName;

    // Get the service name associated with this application...
    hr = m_pIComProcessInfo->GetServiceName (&pServiceName);
    if (hr == E_FAIL)
    {
        // E_FAIL is an OK thing to return, it just means "you aren't a service"
        hr = S_OK;
    } 
    else if (SUCCEEDED(hr) && pServiceName && (pServiceName[0]))
    {
        GUID *appid;
        hr = m_pIComProcessInfo->GetProcessId(&appid);

        // Special for the system application... it can't be paused or stopped
        if (SUCCEEDED(hr))
        {
            if (memcmp(appid, &APPID_SystemApp, sizeof(APPID_SystemApp)) == 0)
			{
                m_NTServiceStatus.dwControlsAccepted &= ~SERVICE_ACCEPT_PAUSE_CONTINUE;
			}

            // Fire up the thread that's going to register us with the SCM
            if ( m_hNTServiceThread == NULL )
            {
                lstrcpyW (m_NTServiceName, pServiceName);
                
                m_hNTServiceThread = CreateThread (NULL, 0,
                                                   CSurrogateProcessActivator::StartNTService,
                                                   (PVOID) this, 0, NULL);
                if ( m_hNTServiceThread == NULL )
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SetupSecurity
//
//  Synopsis:   Dreaded security setup....
//
//  History:    08-Apr-98   SteveSw      Created
//              25-Sep-98   A-Sergiv     Add process identity to process DACL
//              16-Nov-98   TAndrews     Undo DACL hacks - activation bug fixed
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::SetupSecurity(void)
{
    DWORD                       dwAuthnLevel        = 0xcdcdcdcd;
    DWORD                       dwCapabilities      = 0xcdcdcdcd;
    DWORD                       dwImpLevel          = 0xcdcdcdcd;
    HRESULT                     hr                  = E_FAIL;
    PSECURITY_DESCRIPTOR        pSecDesc            = NULL;
    DWORD                       cbSecDesc;

    //  Get the security descriptor from the catalog. It turns out that this
    //  is a self-relative SD
    hr = m_pIComProcessInfo->GetAccessPermission((void**) &pSecDesc, &cbSecDesc );

    if ( FAILED(hr) )
        return hr;

    //  Get all the other security bits from the catalog
    if ( SUCCEEDED(hr) )
    {
        hr = m_pIComProcessInfo->GetAuthenticationLevel(&dwAuthnLevel);
    }
    if ( SUCCEEDED(hr) )
    {
        hr = m_pIComProcessInfo->GetAuthenticationCapabilities(&dwCapabilities);
    }
    if ( SUCCEEDED(hr) )
    {
        hr = m_pIComProcessInfo->GetImpersonationLevel(&dwImpLevel);
    }

    // Having read values from the catalog, we initialize security for our
    // surrogate....
    if ( SUCCEEDED(hr) )
    {
        hr = CoInitializeSecurity(pSecDesc, -1, NULL, NULL,
                                  dwAuthnLevel, dwImpLevel, NULL,
                                  dwCapabilities, NULL);
    }

    // Who knows which failed, and why? Who cares?
    return hr;
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SetupSurrogateTimeout
//
//  Synopsis:   Read in the timeout interval used in SurrogateTimeout code
//              The value in the registry is in minutes; we use milliseconds.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::SetupSurrogateTimeout(void)
{
    HRESULT hr = E_FAIL;

    hr = m_pIProcessServerInfo->GetShutdownIdleTime(&m_cMillisecondsTilDeath);

    //
    // REVIEW:  Setting shutdown to at least 1 seconds because VB objects are
    // access violating otherwise.  Should find out real reason for access violation
    // to resolve this.
    //

    m_cMillisecondsTilDeath = max ((m_cMillisecondsTilDeath * 60 * 1000), MINIMUM_IDLE_SHUTDOWN_PERIOD_MSEC);


    return hr;
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::AreServicesRequired
//
//  Synopsis:   Returns S_OK if COMSVCS needs to be initialized; S_FALSE otherwise
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::AreServicesRequired(void)
{
    HRESULT hr = S_FALSE;
    IComServices* pServices = NULL;

    // simply QI and release, setting hr to S_OK if the interface exists

    if ( m_pIComProcessInfo->QueryInterface(IID_IComServices, (void**) &pServices) == S_OK )
    {
        hr = S_OK;
        pServices->Release();
        m_fServicesConfigured = TRUE;
    }


    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SetupFusionContext
//
//  Synopsis:   Sets fusion to the logical application root, if not initialized.
//
//  History:    26-Aug-00   ddriver      Created
//
//----------------------------------------------------------------------------

HRESULT CSurrogateProcessActivator::SetupFusionContext(void)
{
    HRESULT hr = S_FALSE;
    HRESULT hrApp = S_OK;
    IComProcessInfo2* pProcInfo = NULL;
    WCHAR* wszManifest = NULL;
    WCHAR* wszName     = NULL;

    hr = m_pIComProcessInfo->QueryInterface(IID_IComProcessInfo2, (void**)&pProcInfo);
    if(SUCCEEDED(hr))
    {
        hr = pProcInfo->GetManifestLocation(&wszManifest);
        if(SUCCEEDED(hr))
        {
            hrApp = pProcInfo->GetProcessName(&wszName);
        }
        pProcInfo->Release();

        if(SUCCEEDED(hr) && wszManifest != NULL && wszManifest[0] != 0)
        {
            // Create an activation context for this guy:
            ACTCTXW actctx = {0};

            actctx.cbSize              = sizeof (ACTCTXW);
            actctx.dwFlags             = ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID | ACTCTX_FLAG_LANGID_VALID;
            actctx.lpSource            = NULL; 
            actctx.wLangId             = LANG_USER_DEFAULT; 
            actctx.lpAssemblyDirectory = wszManifest;
            
            actctx.dwFlags |= ACTCTX_FLAG_SET_PROCESS_DEFAULT;
            
            if(SUCCEEDED(hrApp) && wszName != NULL && wszName[0] != 0) 
            {
                actctx.lpApplicationName = wszName;
                actctx.dwFlags |= ACTCTX_FLAG_APPLICATION_NAME_VALID;
            }

            m_hFusionContext = CreateActCtxW (&actctx); 
            if(m_hFusionContext == INVALID_HANDLE_VALUE)
            {
                DWORD gle = GetLastError();
                if (gle != ERROR_FILE_NOT_FOUND && gle != ERROR_PATH_NOT_FOUND)
                {
                    return HRESULT_FROM_WIN32 (gle);
                }
            }
        }
    }

    return(S_OK);
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::CloseCatalog
//
//  Synopsis:   Cleanup after OpenCatalog() by closing all interfaces
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::CloseCatalog(void)
{
    if ( m_pIComProcessInfo != NULL )
    {
        m_pIComProcessInfo->Release();
        m_pIComProcessInfo = NULL;
    }
    if ( m_pIProcessServerInfo != NULL )
    {
        m_pIProcessServerInfo->Release();
        m_pIProcessServerInfo = NULL;
    }

    return S_OK;
}


//============================================================================
//
//  Methods to handle communication down into COM and up back to the HOSTPLUS
//  process by means of calls to ISurrogate. This object implements an
//  ISurrogate interface with methods here. This interface is passed down
//  to COM, who only uses the FreeSurrogate() method, and that only when
//  COM deams the process to be idle (no cross-apartment or cross-process
//  activity). We implement a timer facility, which only passes on the call
//  to HOSTPLUS after a specified interval.
//
//  So, what these methods do is hold a counted reference to HOSTPLUS's
//  ISurrogate, and pass a pointer to ours down to COM. Our ISurrogate kicks
//  of the SurrogateTimer when FreeSurrogate() is called -- that code is
//  responsible for all the rest of the work of deciding when to communicate
//  with HOSTPLUS. When it decides it's time, it calls RemoveISurrogate(),
//  which tells HOSTPLUS we're done, releases HOSTPLUS's interface, and tells
//  COM that we don't care to hear any more about idleness, ourselves. This
//  in preparation for shutdown.
//
//  The LoadDllServer() is a vestigal remaint, left here so we don't have to
//  create an ISurrogate2(). If the fact that I return E_NOTIMPL here is a
//  problem, then I'll change it to some other "NO".
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StoreISurrogate
//
//  Synopsis:   Save HOSTPLUS's ISurrogate; give COM ours
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::StoreISurrogate(ISurrogate* pISurrogate)
{
    HRESULT hr = E_FAIL;

    m_pISurrogate = pISurrogate;
    if ( m_pISurrogate != NULL )
    {
        m_pISurrogate->AddRef();
    }
    hr = CCOMSurrogate::IsNewStyleSurrogate();
    hr = CCOMSurrogate::InitializeISurrogate ((LPSURROGATE) this);
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::RemoveISurrogate
//
//  Synopsis:   Fire HOSTPLUS's ISurrogate; take ours back from COM
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::RemoveISurrogate(void)
{
    if ( m_pISurrogate != NULL )
    {
        m_pISurrogate->FreeSurrogate();
        m_pISurrogate->Release();
        m_pISurrogate = NULL;
        return S_OK;
    }
    return S_FALSE;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::LoadDllServer
//
//  Synopsis:   In CoRegisterServerEx() world, obsolete member of ISurrogate
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::LoadDllServer(REFCLSID rclsid)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::FreeSurrogate
//
//  Synopsis:   ISurrogate method called by COM when process quiets; used here
//              to trigger SurrogateTimer mechanisms.
//
//  Note:       Returning S_FALSE tells COM that we want to remain alive to
//              it's notifications after this call....
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::FreeSurrogate()
{
    HRESULT hr = BeginSurrogateTimeout();

    return S_OK;
}


//============================================================================
//
//  Methods that mess around with Services. We've already read in all the
//  data that the services need to be initialized. Here we have a method that
//  initializes services (and returns the data their initialization required),
//  and a method that cleans up the services.
//
//  Right now these are both no-ops. When they get implemented, their grubbly
//  little hands will be all over the place....
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::InitializeServices
//
//  Synopsis:   Initialize services in surrogate dll, below. And then,
//                              clean up the resources used to hold configuration data.
//
//  History:    08-Apr-98   SteveSw      Created
//              25-Jun-98   WilfR        Added COMSVCS load and init
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::InitializeServices(REFGUID rguidProcessID)
{
    HRESULT hr = E_FAIL;
    FN_CoLoadServices pfnCoLoadServices = NULL;

    // load COMSVCS.DLL and get the CoLoadServices() entry point
    // The other way we load COMSVCS is with CoCI -- this results in the same LoadLibraryEx call

    if ( ( m_hCOMSVCS = LoadLibraryEx(L"COMSVCS.DLL", NULL,
                                      LOAD_WITH_ALTERED_SEARCH_PATH) ) == NULL )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if ( ( pfnCoLoadServices = (FN_CoLoadServices) GetProcAddress(m_hCOMSVCS,
                                                                  "CoLoadServices") ) == NULL )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // call the entry point passing in a reference to ourselves. Since this call will return
    // immediately, we need to block waiting for an acknowledgement from the services DLL that
    // it is ready to roll.

    // the counter is used to recognize that we are being pinged by the services DLL and
    // we should continue to wait.
    m_ulServicesPing = INIT_STARTING;

    // call to startup COMSVCS
    // NT #331848: Don't throw assert when comsvcs says "out of memory"
    if ( ( hr = pfnCoLoadServices(rguidProcessID,
                                  static_cast<IPAControl*>(this),
                                  IID_IServicesSink,
                                  (void**) &m_pServices ) ) != S_OK )
    {
        return hr;
    }

    if ( m_pServices == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // we now wait for the startup to complete (which will be set in our callback)
    if ( ( hr = WaitForInitCompleted( INIT_STARTING, MAX_WAITS ) ) != S_OK )
    {
        return hr;
    }

    m_ulServicesPing = INIT_STARTING;

    // fire the first application launch event -- for this release process GUID == appl GUID
    m_pServices->ApplicationLaunch(rguidProcessID, ServerApplication);

    // we now wait for the application launch to complete (which will be set in our callback)
    // TODO: with > 1 application these events will need to be separate if we allow concurrency
    // in this activator.  This logic should also be in the activation chain instead of here.
    //
    // We set 0 for the MAX_WAITS, because this could take a very long time to complete.
    if ( ( hr = WaitForInitCompleted( INIT_STARTING, 0 ) ) != S_OK )
    {
        return hr;
    }

    return hr;
}



//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::WaitForInitCompleted
//
//  Synopsis:   Monitors the pings from COMSVCS and returns S_OK if completed;
//                              otherwise E_FAIL;
//
//  History:    23-Jun-98   WilfR      Created
//              22-May-01   JohnDoty   Changed to support process initialzers
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::WaitForInitCompleted( ULONG ulStartingCount,
                                                               ULONG ulMaxWaits )
{
    ULONG ulWaits = 0;

    while ( WaitForSingleObject(m_hInitCompleted, m_ulInitTimeout) == WAIT_TIMEOUT )
    {
        // If this particular piece cares...
        if (ulMaxWaits)
        {
            // ...check if we have exhausted our waits
            if ( ++ulWaits == ulMaxWaits )
            {
                return E_FAIL;
            }
        }

        // read the current value (increments done using Interlocked instructions)
        ULONG ulNewCount = m_ulServicesPing;

        // the ping should increment this value.. if not then we assume COMSVCS is hung
        if ( ulStartingCount == ulNewCount )
        {
            return E_FAIL;
        }
        else
            ulStartingCount = ulNewCount;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::CleanupServices
//
//  Synopsis:   Cleanup all services, as part of shutdown.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::CleanupServices(void)
{
    // this will only happen if COMSVCS has been loaded during our operation
    if ( m_pServices )
    {
        m_pServices->ProcessFree();
    }

    return S_OK;
}


//============================================================================
//
//  Methods that implement the Surrogate Timeout mechanism. Once COM tells us
//  the world has shut down, we promise to wait a configurable number of
//  seconds, and then bring down the infrastructure maintained by this object.
//
//  The rub is, during this time we're waiting we may get object activation
//  requests in. If these requests succeed, then our server is no longer
//  dormant, and we cancel the timeout. Heck, we might get two or five
//  activations in; if any one of them succeeds, we cancel the timeout. And
//  we don't want to timeout while an activation is in process, even if it
//  takes a long time and our timeout interval expires.
//
//  It turns out we have three states, and five verbs. The states are
//  INACTIVE, PENDING, and SUSPENDED. The verbs are BEGIN,
//  STARTS, FAILS, SUCCEEDS, and TIMEOUT. The first four verbs happen in
//  routines of the same name; the last one happens in the thread we grab
//  from CoRegisterSurrogate's caller. We know that BEGIN can happen at any time (and
//  at unexpected times). STARTS happens when an activation comes in. It must
//  be matched by either a SUCCEEDS or a FAILS, which happen at the end of
//  an activation, announcing that the activation has completed.
//
//      Once the BEGIN comes in, the event is reset from INFINITE to the application-
//  specific timeout. When it timesout, it is either reset, or it leads to
//  the DLLHOST shutdown.
//
//  So, here's an ASCII kind of state table. Timeout states to the left.
//  Verbs across the top
//
//
//              BEGIN      Activation    Activation    Activation    TIMEOUT
//                           Starts        Fails        Succeeds
//
//  INACTIVE  to PENDING    Ignore         cSusp--       cSusp--      clear
//            set Timeout                                            timeout
//
//                        to SUSPENDED
//  PENDING     NO-OP       cSusp++        cSusp--       cSusp--     shutdown
//
//                                         cSusp--
//  SUSPENDED   NO-OP       cSusp++       cSusp==0 ?   to INACTIVE     set
//                                        to PENDING      clear      timeout
//                                       set timeout     timeout      to '1'
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::BeginSurrogateTimeout
//
//  Synopsis:   Begins the countdown to SurrogateTimeout. Triggered by COM's
//              call to the ISurrogate we implement in this object
//
//  History:    08-Apr-98   SteveSw      Created
//              04-May-98   SteveSw      Fixed races, simplified
//              29-May-98   Gopalk       Fixed races
//              28-Sep-98   SteveSw      Forced shutdown
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::BeginSurrogateTimeout(void)
{
    BOOL fSetEventWorked = FALSE;
    HRESULT hr = S_OK;
    LockTimeoutState();

    switch ( m_timeoutState )
    {
    //  If BEGIN comes in when the Timeout stuff is inactive, we reset the
    //  timer so that it'll go off in "m_cMillisecondsTilDeath" milliseconds.
    case TIMEOUT_INACTIVE:
        // Check for pending activations
        if ( m_cActivations > 0 )
            m_timeoutState = TIMEOUT_SUSPENDED;
        else
            m_timeoutState = TIMEOUT_PENDING;

        // Wake up the main thread
        m_cTimeoutPeriod = m_cMillisecondsTilDeath;
        fSetEventWorked = SetEvent(m_hTimeoutEvent);
        hr = E_UNEXPECTED;
        break;

    // We can get a superfluous BeginSurrogateTimeout if we are instructed to
    // reset the idle timeout to zero, and we were already in the idle state.    
    // If this happens, and the idle timeout changed, and we are in the pending
    // state, we need to wake up the the timeout thread so that he can take 
    // note of the new idle period.   
    case TIMEOUT_PENDING:
        if (m_cTimeoutPeriod != m_cMillisecondsTilDeath)
        {
			m_cTimeoutPeriod = m_cMillisecondsTilDeath;
			fSetEventWorked = SetEvent(m_hTimeoutEvent);
			hr = fSetEventWorked ? S_OK : HRESULT_FROM_WIN32(GetLastError());
        }
		// else no need to do anything
        break;

    // If an activation is on-going, we can ignore this BeginTimeout request
    case TIMEOUT_SUSPENDED:
        break;

    //  These cases mean we're about to die soon, so no need to do anything
    case TIMEOUT_HAPPENING:
    case TIMEOUT_FORCED_SHUTDOWN:
        break;
    }

    UnlockTimeoutState();

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ActivationBegins
//
//  Synopsis:   Temporarily suspends the timeout logic. Called when an
//                              activation comes in
//
//  History:    08-Apr-98   SteveSw      Created
//              04-May-98   SteveSw      Fixed races, simplified
//              29-May-98   Gopalk       Fixed races
//              28-Sep-98   SteveSw      Forced shutdown
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ActivationBegins(void)
{
    HRESULT hr = S_OK;

    LockTimeoutState();

    m_cActivations += 1;
    switch ( m_timeoutState )
    {
    case TIMEOUT_INACTIVE:
        //  Just keeping track of activations most of the time.
        break;

    case TIMEOUT_PENDING:
        //  Activations that come in when we're in a PENDING state push us
        //  into the SUSPENDED state
        m_timeoutState = TIMEOUT_SUSPENDED;
        break;

    case TIMEOUT_SUSPENDED:
        //  If we're suspended, we accept new activations
        break;

    case TIMEOUT_HAPPENING:
    case TIMEOUT_FORCED_SHUTDOWN:
        //  If we're shutting down, we turn away new activations
        m_cActivations -= 1;  // undo previous increment
        hr = CO_E_SERVER_STOPPING;
        break;
    }

    UnlockTimeoutState();

    return  hr ;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ActivationFails
//
//  Synopsis:   Resumes the timeout logic after an unsuccessful activation
//                              call.
//
//  History:    08-Apr-98   SteveSw      Created
//              04-May-98   SteveSw      Fixed races, simplified
//              29-May-98   Gopalk       Fixed races
//              28-Sep-98   SteveSw      Forced shutdown
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ActivationFails(void)
{
    Win4Assert (m_cActivations > 0);

    LockTimeoutState();

    m_cActivations -= 1;
    switch ( m_timeoutState )
    {
    case TIMEOUT_FORCED_SHUTDOWN:
        // If we're shutting down, we ignore this failure....
        break;

    case TIMEOUT_INACTIVE:
        //  These cases are about failures that arrive after we're back in a new
        //  cycle.
        break;

    case TIMEOUT_PENDING:
        // Assert that we never land here
        Win4Assert(!"Timeout pending during activation");
        break;

    case TIMEOUT_SUSPENDED:
        //  We again decrement our suspension count. But, if we hit 0, we
        //  transition back into PENDING state.
        if ( m_cActivations == 0 )
            m_timeoutState = TIMEOUT_PENDING;
        break;

    case TIMEOUT_HAPPENING:
        // Assert the we never land here
        Win4Assert(!"Timeout happening during activation");
        break;
    }

    UnlockTimeoutState();

    return  S_OK ;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ActivationSucceeds
//
//  Synopsis:   Cancels the timeout logic after a successful activation
//                              call.
//
//  History:    08-Apr-98   SteveSw      Created
//              04-May-98   SteveSw              Fixed races, simplified
//              28-Sep-98   SteveSw      Forced shutdown
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ActivationSucceeds(void)
{
    Win4Assert (m_cActivations > 0);

    LockTimeoutState();

    m_cActivations -= 1;
    switch ( m_timeoutState )
    {
    case TIMEOUT_FORCED_SHUTDOWN:
        //  If we're shutting down, this "success" is worthless shortly
        break;

    case TIMEOUT_INACTIVE:
        //  These are about successes that return after we've moved into a new world.
        break;

    case TIMEOUT_PENDING:
        // Assert that we never land here
        Win4Assert(!"Timeout pending during activation");
        break;

    case TIMEOUT_SUSPENDED:
        //  Otherwise, a win means drop the waiting and go back to the inactive
        //  state
        m_timeoutState = TIMEOUT_INACTIVE;
        m_cTimeoutPeriod = INFINITE;
        break;

    case TIMEOUT_HAPPENING:
        break;
    }

    UnlockTimeoutState();
    return S_OK;
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::WaitForSurrogateTimeout
//
//  Synopsis:   Waits until the surrogate times out, then returns
//
//  History:    04-May-98   SteveSw              Created
//              28-Sep-98   SteveSw      Forced shutdown & process refcounts
//
//----------------------------------------------------------------------------


STDMETHODIMP CSurrogateProcessActivator::WaitForSurrogateTimeout(void)
{
    DWORD dwWaitStatus;
    HRESULT hr = S_FALSE;

    if ( m_hTimeoutEvent == NULL )
    {
        hr = E_OUTOFMEMORY;
    }

    LockTimeoutState();
    while ( hr == S_FALSE )
    {
        UnlockTimeoutState();
        dwWaitStatus = WaitForSingleObject (m_hTimeoutEvent, (m_lProcessRefCount > 0) ? INFINITE : m_cTimeoutPeriod);
        LockTimeoutState();

        if ( m_timeoutState == TIMEOUT_FORCED_SHUTDOWN )
        {
            //  If we're shutting down, we just bail....
            hr = S_OK;
        }
        else if ( dwWaitStatus == WAIT_OBJECT_0 || m_lProcessRefCount > 0 )
        {
            //  The event signals a change in the timeout period
            //  m_lProcessRefCount signals externally held references on the process
            //  In either case, we just want to return to the wait
            continue;
        }
        else if ( dwWaitStatus == WAIT_TIMEOUT )
        {
            if ( m_timeoutState == TIMEOUT_PENDING )
            {
                //  Here we're done
                hr = S_OK;
            }
            else if ( m_timeoutState == TIMEOUT_SUSPENDED )
            {
                //  Here we're done, but we still have outstanding activations
                m_cTimeoutPeriod = 1000; // wait one second
                continue;
            }
            else if ( m_timeoutState == TIMEOUT_INACTIVE )
            {
                //  Here we're back to our normal state, go to sleep
                m_cTimeoutPeriod = INFINITE;
                continue;
            }
        }
        else
        {
            hr =  E_UNEXPECTED;
        }
    }

    m_timeoutState = TIMEOUT_HAPPENING;
    UnlockTimeoutState();
    return hr;
}


//============================================================================
//
//  Methods that implement the IProcessInitControl interface.  This interface
//  is handed to COM+ process initializers.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ResetInitializerTimeout
//
//  Synopsis:   Reset the timeout used in WaitForInitCompleted, and bump the 
//              ping count so WaitForInitCompleted doesn't think we're stuck.
//
//  History:    22-May-01   JohnDoty      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ResetInitializerTimeout(DWORD dwSecondsRemaining)  
{
    const DWORD dwMaxSeconds = (0xFFFFFFFF / 1000); // Max number of seconds without overflow

    if (dwSecondsRemaining > dwMaxSeconds)
        return E_INVALIDARG;

    // Notify the SCM that we are in the initializing state.
    HRESULT hr = TellSCMWeAreInitializing();

    if (SUCCEEDED(hr))
    {
        // Reset the timeout, and then increment the ping.  There are all kinds of 
        // timing issues, but if you update them in this order, you will at least
        // get the specified amount of time before you die.  (You might get twice
        // that.  Is it necessary to be picky?)
        m_ulInitTimeout = dwSecondsRemaining * 1000; // (Convert to ms)
        
        InterlockedIncrement( (PLONG) &m_ulServicesPing );
    }
   
    return hr;
}


//============================================================================
//
//  Methods that implement the ILocalSystemActivator interface. We do this
//  instead of your garden-variety ISystemActivator because we're talking
//  to the SCM, and the SCM needs this kind of interface. Since we're building
//  an unRAW ILocalSystemActivator, it's just the same old ISystemActivator
//  with an extra method there at the bottom that we ignore.
//
//  This activator sits at the very beginning of the local activation
//  chain. It's only job is to "set the stage", so to speak, and then
//  delegate on to the other activators at the Server Process Stage.
//
//  The wrinkle is, activation is intertwined with the whole SurrogateTimeout
//  mechanism. When COM sees that the process has quiesced, it notifies us
//  with a callback. Each ProcessID is associated with a timeout value, a
//  number of seconds to wait after quiescence before we actually bail out
//  and shut down the server. During that time, if an activation succeeds,
//  then we're back in the saddle again, all thoughts of timing out gone.
//  If the activation fails, we just resume the timeout process as though
//  it hadn't happened. This logic is also in these methods.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::GetClassObject
//
//  Synopsis:   The part of the GetClassObject activation chain that lives
//                              between the SCM and the list of Process Activators
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::GetClassObject(IActivationPropertiesIn *pActPropsIn,
                                                        IActivationPropertiesOut **ppActPropsOut)
{
    HRESULT hr = E_FAIL;
    IActivationStageInfo*       pActStageInfo       = NULL;
    InstantiationInfo*         pInstantiationInfo  = NULL;
    int nRetries = 0;

    //  Notify the timeout mechanism that a timeout has begun. This guy will return
    //  failure if we need to abandon the activation here....
    hr = ActivationBegins();
    if ( FAILED(hr) )
    {
        return hr;
    }
    // The activation work proper. First, change the CLSCTX to INPROC.
    hr = pActPropsIn->QueryInterface(IID_IInstantiationInfo, (void**) &pInstantiationInfo);
    if ( SUCCEEDED(hr) && pInstantiationInfo != NULL )
    {
        hr = pInstantiationInfo->SetClsctx(CLSCTX_INPROC_SERVER);
        pInstantiationInfo->Release();
        pInstantiationInfo = NULL;
    }
    if ( FAILED(hr) )
    {
        return hr;
    }

     //Check that activations in our server are not paused
    if(TRUE == m_bPaused)
    {
    	ActivationFails();
    	return CO_E_SERVER_PAUSED;
    }

RETRY_ACTIVATION:
    // Set the Stage. Release the interface. Delegate.
    hr = pActPropsIn->QueryInterface(IID_IActivationStageInfo, (void**) &pActStageInfo);
    if ( SUCCEEDED(hr) && pActStageInfo != NULL )
    {
        hr = pActStageInfo->SetStageAndIndex (SERVER_PROCESS_STAGE, 0);
        pActStageInfo->Release();
        pActStageInfo = NULL;
    }
    if ( FAILED(hr) )
    {
        return hr;
    }

    // Send the activation on down the path
    hr = pActPropsIn->DelegateGetClassObject(ppActPropsOut);
    // Sajia-support for partitions
    // If the delegated activation returns ERROR_RETRY,
    // we walk the chain again, but AT MOST ONCE.
    if (ERROR_RETRY == hr) {
       Win4Assert(!nRetries);
       if (!nRetries)
       {
	  nRetries++;
	  goto RETRY_ACTIVATION;
       }
    }
    
    // Keeping track of the status of our creates, for the timeout mechanism
    if ( FAILED(hr) )
    {
        ActivationFails();
    }
    else
    {
        ActivationSucceeds();
    }

    // This return passed upstream to them what delegated to us....
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::CreateInstance
//
//  Synopsis:   The part of the CreateInstance activation chain that lives
//                              between the SCM and the list of Process Activators
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::CreateInstance(IUnknown *pUnkOuter,
                                                        IActivationPropertiesIn *pActPropsIn,
                                                        IActivationPropertiesOut **ppActPropsOut)
{
    HRESULT                     hr                  = E_FAIL;
    IActivationStageInfo*       pActStageInfo       = NULL;
    InstantiationInfo*          pInstantiationInfo  = NULL;
    int nRetries = 0;

    //  Notify the timeout mechanism that a timeout has begun. This guy will return
    //  failure if we need to abandon the activation here....
    hr = ActivationBegins();
    if ( FAILED(hr) )
    {
        return hr;
    }

    // The activation work proper. First, change the CLSCTX to INPROC.
    hr = pActPropsIn->QueryInterface(IID_IInstantiationInfo, (void**) &pInstantiationInfo);
    if ( SUCCEEDED(hr) && pInstantiationInfo != NULL )
    {
        hr = pInstantiationInfo->SetClsctx(CLSCTX_INPROC_SERVER);
        pInstantiationInfo->Release();
        pInstantiationInfo = NULL;
    }
    if ( FAILED(hr) )
    {
        return hr;
    }

    //Check that activations in our server are not paused
    if(TRUE == m_bPaused)
    {
    	ActivationFails();
    	return CO_E_SERVER_PAUSED;
    }


RETRY_ACTIVATION:
    // Set the Stage. Release the interface. Delegate.
    hr = pActPropsIn->QueryInterface(IID_IActivationStageInfo, (void**) &pActStageInfo);
    if ( SUCCEEDED(hr) && pActStageInfo != NULL )
    {
        hr = pActStageInfo->SetStageAndIndex (SERVER_PROCESS_STAGE, 0);
        pActStageInfo->Release();
        pActStageInfo = NULL;
    }
    if ( FAILED(hr) )
    {
        return hr;
    }

    // Send the work downstream
    hr = pActPropsIn->DelegateCreateInstance(pUnkOuter, ppActPropsOut);
    // Sajia-support for partitions
    // If the delegated activation returns ERROR_RETRY,
    // we walk the chain again, but AT MOST ONCE.
    if (ERROR_RETRY == hr) {
       Win4Assert(!nRetries);
       if (!nRetries)
       {
	  nRetries++;
	  goto RETRY_ACTIVATION;
       }
    }
    // If the Suspend really suspended, then we need to either RESUME or CANCEL,
    // depending on the outcome of the delegation.
    // Keeping track of the status of our creates, for the timeout mechanism
    if ( FAILED(hr) )
    {
        ActivationFails();
    }
    else
    {
        ActivationSucceeds();
    }

    // This return passed upstream to them what delegated to us....
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ObjectServerLoadDll
//
//  Synopsis:   Member of ILocalSystemActivator. Other than its name, I have
//                              no idea what it does. It's unimplemented here.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ObjectServerLoadDll(GUID* pclsid, STATUSTYPE* pStatus)
{
    Win4Assert(! "Surrogate's ObjectServerLoadDll not implemented");
    if ( pStatus != NULL )
    {
        *pStatus = E_NOTIMPL;
    }
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::AddRefOnProcess
//
//  Synopsis:   Member of IPAControl. While process lock > 0, surrogate timeouts
//                              are disabled.
//
//  History:    23-Jun-98   WilfR      Created
//              28-Sep-98   SteveSw    Implemented
//
//----------------------------------------------------------------------------

ULONG CSurrogateProcessActivator::AddRefOnProcess()
{
    BOOL fSetEventWorked;
    ULONG refCount;

    LockTimeoutState();
    if ( m_lProcessRefCount == 0 )
    {
        fSetEventWorked = SetEvent(m_hTimeoutEvent);
    }
    refCount = ++m_lProcessRefCount;
    UnlockTimeoutState();

    return refCount;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ReleaseRefOnProcess
//
//  Synopsis:   Member of IPAControl. When process lock goes from 1->0, surrogate timeout
//                              may be initiated if there are no activations.
//
//  History:    23-Jun-98   WilfR      Created
//              28-Sep-98   SteveSw    Implemented
//
//----------------------------------------------------------------------------

ULONG CSurrogateProcessActivator::ReleaseRefOnProcess()
{
    BOOL fSetEventWorked;
    ULONG refCount;

    LockTimeoutState();

    if ( m_lProcessRefCount > 0 )
    {
        m_lProcessRefCount--;
    }
    refCount = m_lProcessRefCount;

    if ( m_lProcessRefCount == 0 )
    {
        fSetEventWorked = SetEvent(m_hTimeoutEvent);
    }

    UnlockTimeoutState();

    return refCount;
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::PendingInit
//
//  Synopsis:   Member of IPAControl. Services DLL uses this to ping the activator.
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------

void CSurrogateProcessActivator::PendingInit()
{
    InterlockedIncrement( (PLONG) &m_ulServicesPing );
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ServicesReady
//
//  Synopsis:   Member of IPAControl. Services DLL uses this to acknowledge it
//                              has completed initialization
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------

void CSurrogateProcessActivator::ServicesReady()
{
    if (m_hInitCompleted != NULL)
    {
        SetEvent( m_hInitCompleted );
    }
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SuspendApplication
//
//  Synopsis:   Member of IPAControl. Disables application activations.
//                              Not currently implemented
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::SuspendApplication( REFGUID rguidApplID )
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::PendingApplication
//
//  Synopsis:   Member of IPAControl. Indicates an application startup is still
//                              pending.  Note that multiple applications where applid != processID
//                              is NOT currently implemented
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::PendingApplication( REFGUID rguidApplID )
{
    InterlockedIncrement( (PLONG) &m_ulServicesPing );
    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ResumeApplication
//
//  Synopsis:   Member of IPAControl. Indicates an application startup has completed
//                              Note that multiple applications where applid != processID
//                              is NOT currently implemented
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::ResumeApplication( REFGUID rguidApplID )
{
    if (m_hInitCompleted != NULL)
    {
        SetEvent( m_hInitCompleted );
        return S_OK;
    }
    else
    {
        return E_UNEXPECTED;
    }
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SuspendAll
//
//  Synopsis:   Member of IPAControl. Indicates all activations should be suspended
//
//  History:    23-Jun-98   WilfR      Created
//              17-Aug-99   JamesAn    Implemented
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::SuspendAll(void)
{
	HRESULT hr = S_OK;

	LockTimeoutState();

	if(m_bPaused)
		hr = CO_E_SERVER_PAUSED;
	else
	{
            //If we are in the middle of a shutdown we don't suspend and leave the timeout alone
            if(m_timeoutState == TIMEOUT_HAPPENING ||
               m_timeoutState == TIMEOUT_FORCED_SHUTDOWN)
                hr = CO_E_SERVER_STOPPING;
            else
            {
                // Ordering here is important;  first we tell the SCM that we're paused, and 
                // only then do we mark our own state as paused. 
                hr = gResolver.NotifySurrogatePaused();
                if (SUCCEEDED(hr))
                {
                    m_bPaused = TRUE;
                    m_timeoutState = TIMEOUT_INACTIVE;
                }
            }
	}
		
	UnlockTimeoutState();
	return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ResumeAll
//
//  Synopsis:   Member of IPAControl. Indicates all activations can be resumed
//
//
//  History:    23-Jun-98   WilfR      Created
//              17-Aug-99   JamesAn    Implemented
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::ResumeAll(void)
{
    HRESULT hr = S_OK;
    
    LockTimeoutState();
    
    if(!m_bPaused)
        hr = CO_E_SERVER_NOT_PAUSED;
    else
    {
        
        //If we are in the middle of a shutdown we don't suspend and leave the timeout alone
        if(m_timeoutState == TIMEOUT_HAPPENING ||
           m_timeoutState == TIMEOUT_FORCED_SHUTDOWN)
            hr = CO_E_SERVER_STOPPING;
        else
        {
            // Here we reverse the order that we did things in SuspendAll.  This is because 
            // once the SCM thinks we're not paused, it might start sending us activations
            // immediately, but before the notifyresumed call returns to us here.  We would
            // then reject those calls, which would be strange to the user.
            
            m_bPaused = FALSE;
            
            //If we have activations we are suspended, otherwise pending.
            m_timeoutState = (m_cActivations > 0) ? TIMEOUT_SUSPENDED : TIMEOUT_PENDING;
            m_cTimeoutPeriod = m_cMillisecondsTilDeath;
            
            hr = gResolver.NotifySurrogateResumed();
            if (FAILED(hr))
            {
                // Reset ourselves back to the paused state
                m_bPaused = TRUE;
                m_timeoutState = TIMEOUT_INACTIVE;
            }
        }
    }
    
    UnlockTimeoutState();
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ForcedShutdown
//
//  Synopsis:   Member of IPAControl. Indicates that a shutdown request has been
//              received and process termination should be commenced.
//
//  History:    23-Jun-98   WilfR      Created
//              28-Sep-98   SteveSw    Forced shutdown implemented
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::ForcedShutdown(void)
{
    BOOL fSetEventWorked;

    LockTimeoutState();

    m_timeoutState = TIMEOUT_FORCED_SHUTDOWN;
    m_cTimeoutPeriod = 0;
    fSetEventWorked = SetEvent(m_hTimeoutEvent);

    UnlockTimeoutState();

    return fSetEventWorked ? S_OK : E_UNEXPECTED;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SetIdleTimeoutToZero
//
//  Synopsis:   Member of IPAControl. Indicates that somebody (ie, com+) wants
//              us to re-set the idle timeout of this process to zero, no matter
//              what it was before.
//
//  History:    27-May-00   JSimmons   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CSurrogateProcessActivator::SetIdleTimeoutToZero(void)
{
	BOOL fSetEventWorked;

    LockTimeoutState();
    
    // Reset m_cMillisecondsTilDeath;  we never set this to zero due to 
    // av shutdown probs seen with VB objects.   We do this no matter
    // what state we are currently in.
    m_cMillisecondsTilDeath = MINIMUM_IDLE_SHUTDOWN_PERIOD_MSEC;  

    UnlockTimeoutState();   

	FreeSurrogateIfNecessary();

    return S_OK;
}

//============================================================================
//
//  Methods that communicate with the NT Service Control Manager.  We need
//  to keep the NT SCM informed of our starting progress along with the normal
//  SCM.  The NT SCM also provides another way that the surrogate may get
//  shut down, so that is taken care of as well.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StartNTService
//
//  Synopsis:   This thread hands control off to the NT SCM to let it start
//              our NT Service.
//
//  History:    13-Dec-99   JohnDoty      Created
//
//----------------------------------------------------------------------------
DWORD WINAPI CSurrogateProcessActivator::StartNTService(LPVOID ptr)
{
    CSurrogateProcessActivator* pSCPA = static_cast<CSurrogateProcessActivator*>(ptr);
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        SERVICE_TABLE_ENTRYW  DispatchTable[] = 
        { 
            { pSCPA->m_NTServiceName, CSurrogateProcessActivator::NTServiceMain }, 
            { NULL,                   NULL          } 
        };
        
        if (!StartServiceCtrlDispatcher(DispatchTable))
        { 
            //TODO: Log the error somehow...
            hr = E_FAIL;
        }
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::NTServiceMain
//
//  Synopsis:   The ServiceMain for the NT Service.  Register our service
//              control handler and get back a handle that we're going to
//              use for our status updates.
//
//              This is yet another piece of code that relies on there being
//              only one CSurrogateProcessActivator.
//
//  History:    13-Dec-99   JohnDoty      Created
//
//----------------------------------------------------------------------------
void CSurrogateProcessActivator::NTServiceMain(DWORD argc, LPWSTR *argv)
{
    SERVICE_STATUS_HANDLE hSS = RegisterServiceCtrlHandlerW( argv[0], NTServiceCtrlHandler );
    
    if (hSS != (SERVICE_STATUS_HANDLE)0)
    { 
        s_pCSPA->m_hNTServiceHandle = hSS;

        SetServiceStatus (hSS, &(s_pCSPA->m_NTServiceStatus));
    } 
    else 
    {
        //TODO: Log error somehow
    }
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::NTServiceCtrlHandler
//
//  Synopsis:   The function that the NT SCM calls when somebody wants to
//              start, stop, pause, continue, or just plain question this
//              service.
//
//              This is yet another piece of code that relies on there being
//              only one CSurrogateProcessActivator.
//
//  History:    13-Dec-99   JohnDoty      Created
//
//----------------------------------------------------------------------------
void CSurrogateProcessActivator::NTServiceCtrlHandler (DWORD code)
{
    HRESULT          hr   = S_OK;

    switch (code)
    {
    case SERVICE_CONTROL_PAUSE:      
        hr = s_pCSPA->m_pServices->PauseApplication();

        if (SUCCEEDED(hr))
        {
            s_pCSPA->m_NTServiceStatus.dwCurrentState = SERVICE_PAUSED;
            s_pCSPA->m_NTServiceStatus.dwWaitHint     = 0;
            s_pCSPA->m_NTServiceStatus.dwCheckPoint   = 0;
        }
        break;

    case SERVICE_CONTROL_CONTINUE:
        hr = s_pCSPA->m_pServices->ResumeApplication();

        if (SUCCEEDED(hr))
        {
            s_pCSPA->m_NTServiceStatus.dwCurrentState = SERVICE_RUNNING;
            s_pCSPA->m_NTServiceStatus.dwWaitHint     = 0;
            s_pCSPA->m_NTServiceStatus.dwCheckPoint   = 0;
        }
        break;

    case SERVICE_CONTROL_STOP:
        hr = s_pCSPA->ForcedShutdown ();

        if (SUCCEEDED(hr))
        {
            s_pCSPA->m_NTServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            s_pCSPA->m_NTServiceStatus.dwWaitHint     = 0; // Do I need to give a hint?
            s_pCSPA->m_NTServiceStatus.dwCheckPoint   = 0;
        }
        break;

    case SERVICE_CONTROL_INTERROGATE:
        // Ok boss.
        break;
    }

    SetServiceStatus (s_pCSPA->m_hNTServiceHandle, &(s_pCSPA->m_NTServiceStatus));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\sync.cxx ===
//+--------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       sync.cxx
//
//  Contents:   This module contains classes implementing ISynchronize
//
//  Classes:    CStdEvent
//              CManualResetEvent
//              CSynchronizeContainer
//
//----------------------------------------------------------------------

#include <ole2int.h>
#include <chancont.hxx>
#include <callctrl.hxx>
#include <sync.hxx>

//------------------------------------------------------------------------------
//
// CoWaitForMultipleHandles
//
// Description: Waits on the set of Win32 handles passed in.
//
// Return: S_OK
//         E_INVALIDARG
//         RPC_E_NO_SYNC
//         RPC_S_CALLPENDING
//
// Notes:
//
//------------------------------------------------------------------------------

WINOLEAPI CoWaitForMultipleHandles (DWORD dwFlags,
                                    DWORD dwTimeout,
                                    ULONG cHandles,
                                    LPHANDLE pHandles,
                                    LPDWORD  lpdwindex)
{
    DWORD         hr = S_OK;
    DWORD         dwSignaled = 0;


    if ((pHandles == NULL) || (lpdwindex == NULL))
    {
        if (lpdwindex) *lpdwindex = 0;
        return E_INVALIDARG;
    }

    if ((dwFlags & ~(COWAIT_WAITALL | COWAIT_ALERTABLE)) != 0)
    {
        *lpdwindex = 0;
        return E_INVALIDARG;
    }

    // If nothing to do, return
    if (cHandles == 0)
    {
        *lpdwindex = 0;
        return RPC_E_NO_SYNC;
    }

    // On MTA threads, just wait
    HRESULT hrTls;
    COleTls Tls(hrTls);

    if (FAILED(hrTls) || ((Tls->dwFlags & OLETLS_APARTMENTTHREADED) == FALSE))
    {
        dwSignaled = WaitForMultipleObjectsEx(cHandles,
                                              pHandles,
                                              dwFlags & COWAIT_WAITALL,
                                              dwTimeout,
                                              dwFlags & COWAIT_ALERTABLE);

        // Fix up the error code if the wait timed out.
        if (dwSignaled == WAIT_TIMEOUT)
            hr = RPC_S_CALLPENDING;
        else if ((LONG) dwSignaled < WAIT_OBJECT_0 ||
                 dwSignaled >= WAIT_OBJECT_0 + cHandles)
            hr = MAKE_WIN32(GetLastError());
        else
            dwSignaled -= WAIT_OBJECT_0;
    }

    // On STA threads, use the modal loop
    else
    {        
        // Tell the modal loop how long to wait.
        hr = InitChannelIfNecessary();
        if (SUCCEEDED(hr))
        {
            CCliModalLoop CML( 0,
                               QS_ALLINPUT | QS_TRANSFER | QS_ALLPOSTMESSAGE,
                               dwFlags);
            CML.StartTimer( dwTimeout );

            // Enter a modal loop.
            hr = RPC_S_CALLPENDING;
            while (hr == RPC_S_CALLPENDING || hr == RPC_S_WAITONTIMER)
                hr = CML.BlockFn( pHandles, cHandles, &dwSignaled );

            // Fix up the error code if the wait timed out.
            if (hr == RPC_E_SERVERCALL_RETRYLATER)
                //hr = RPC_E_TIMEOUT;
                hr = RPC_S_CALLPENDING;
        }
    }
    *lpdwindex = dwSignaled;
    return hr;
}




//+-------------------------------------------------------------------
//
//  Function:   CStdEvent_CreateInstance, public
//
//  Synopsis:   Create an instance of the requested class
//
//--------------------------------------------------------------------
HRESULT CStdEventCF_CreateInstance( IUnknown *pUnkOuter,
                                    REFIID riid, void **ppv )
{
    Win4Assert(*ppv == NULL);
    HRESULT hr = E_OUTOFMEMORY;
    CStdEvent *pAC = new CStdEvent( pUnkOuter );
    if (pAC != NULL)
    {
        IUnknown *pUnk = NULL;
        hr = pAC->_cInner.QueryInterface( riid, (void **) &pUnk );
        pAC->_cInner.Release();
        if (FAILED(hr))
        {
            return hr;
        }
        *ppv = pUnk;
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CManualResetEvent_CreateInstance, public
//
//  Synopsis:   Create an instance of the requested class
//
//--------------------------------------------------------------------
HRESULT CManualResetEventCF_CreateInstance( IUnknown *pUnkOuter,
                                            REFIID riid, void **ppv )
{
    Win4Assert(*ppv == NULL);
    HRESULT hr = E_OUTOFMEMORY;
    CManualResetEvent *pMRE = new CManualResetEvent( pUnkOuter, &hr );
    if (SUCCEEDED(hr))
    {
        IUnknown *pUnk = NULL;
        hr = pMRE->_cInner.QueryInterface( riid, (void **) &pUnk );
        pMRE->_cInner.Release();
        if (FAILED(hr))
        {
            return hr;
        }
        *ppv = pUnk;
    } else
    {
        delete pMRE;
    }

    return hr;

}

//+-------------------------------------------------------------------
//
//  Function:   CSynchronizeContainer_CreateInstance, public
//
//  Synopsis:   Create an instance of the requested class
//
//--------------------------------------------------------------------
HRESULT CSynchronizeContainerCF_CreateInstance( IUnknown *pUnkOuter,
                                                REFIID riid, void **ppv )
{
    Win4Assert(*ppv == NULL);
    HRESULT hr = E_OUTOFMEMORY;
    CSynchronizeContainer *pAC = new CSynchronizeContainer( pUnkOuter );
    if (pAC != NULL)
    {
        IUnknown *pUnk = NULL;
        hr = pAC->_cInner.QueryInterface( riid, (void **) &pUnk );
        pAC->_cInner.Release();
        if (FAILED(hr))
        {
            return hr;
        }
        *ppv = pUnk;
    }

    return hr;
}


// CStdEvent Methods
//+-------------------------------------------------------------------
//
//  Member:     CSTInnerUnknown::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSTInnerUnknown::AddRef()
{
    return InterlockedIncrement( (long *) &_iRefCount );
}

//+-------------------------------------------------------------------
//
//  Member:     CSTInnerUnknown::CSTInnerUnknown
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CSTInnerUnknown::CSTInnerUnknown( CStdEvent *pParent )
{
    _iRefCount = 1;
    _pParent   = pParent;
}

//+-------------------------------------------------------------------
//
//  Member:     CSTInnerUnknown::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CSTInnerUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown *pUnk;

    if (IsEqualIID(riid, IID_IUnknown))
        pUnk = (IUnknown *) this;
    else if (IsEqualIID(riid, IID_ISynchronize))
        pUnk = (ISynchronize *) _pParent;
    else if (IsEqualIID(riid, IID_ISynchronizeEvent))
        pUnk = (ISynchronizeEvent *) _pParent;
    else if (IsEqualIID(riid, IID_ISynchronizeHandle))
        pUnk = (ISynchronizeHandle *) _pParent;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CSTInnerUnknown::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSTInnerUnknown::Release()
{
    ULONG lRef = InterlockedDecrement( (long*) &_iRefCount );

    if (lRef == 0)
    {
        delete _pParent;
    }

    return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::AddRef, public
//
//  Synopsis:   Forwards AddRef to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdEvent::AddRef()
{
    return _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::CStdEvent
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CStdEvent::CStdEvent( IUnknown *pControl ) :
_cInner( this ),
m_hEvent(NULL)
{
    if (pControl != NULL)
        _pControl = pControl;
    else
        _pControl = &_cInner;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::~CStdEvent
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------
CStdEvent::~CStdEvent()
{
    if (m_hEvent != NULL)
        CloseHandle(m_hEvent);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::QueryInterface, public
//
//  Synopsis:   Forwards QueryInterface to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return _pControl->QueryInterface( riid, ppvObj );
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::Release, public
//
//  Synopsis:   Forwards Release to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdEvent::Release()
{
    return _pControl->Release();

}


//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::Wait, public
//
//  Synopsis:   Waits for call to complete.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::Wait(DWORD dwFlags, DWORD dwTimeout)
{
    HANDLE _aEvent[1];
    DWORD index = 0;
    if (m_hEvent == NULL)
        return RPC_E_NO_SYNC;

    _aEvent[0] = m_hEvent;
    return CoWaitForMultipleHandles(dwFlags,
                                    dwTimeout,
                                    1,
                                    _aEvent,
                                    &index);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::Signal, public
//
//  Synopsis:   Signal Event
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::Signal()
{
    if (m_hEvent)
    {
        if (SetEvent(m_hEvent))
           return S_OK;

        return MAKE_WIN32(GetLastError());
    }

    return RPC_E_NO_SYNC;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::Reset, public
//
//  Synopsis:   Resets ISynchronize state.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::Reset()
{
    if (m_hEvent)
    {
        if (ResetEvent(m_hEvent))
            return S_OK;

        return MAKE_WIN32(GetLastError());
    }

    return RPC_E_NO_SYNC;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::GetHandle, public
//
//  Synopsis:   Returns pointer to event
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::GetHandle(HANDLE *ph)
{
    *ph = m_hEvent;
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::SetEventHandle, public
//
//  Synopsis:   Sets an event handle
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::SetEventHandle(HANDLE *ph)
{
    if (m_hEvent == NULL)
    {
        m_hEvent = *ph;
        return S_OK;
    }

    return E_FAIL;
}


// Manual Reset Methods
//+-------------------------------------------------------------------
//
//  Member:     CMREInnerUnknown::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMREInnerUnknown::AddRef()
{
    return InterlockedIncrement( (long *) &_iRefCount );
}

//+-------------------------------------------------------------------
//
//  Member:     CMREInnerUnknown::CMREInnerUnknown
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CMREInnerUnknown::CMREInnerUnknown( CManualResetEvent *pParent )
{
    _iRefCount = 1;
    _pParent   = pParent;
}

//+-------------------------------------------------------------------
//
//  Member:     CMREInnerUnknown::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CMREInnerUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown *pUnk;

    if (IsEqualIID(riid, IID_IUnknown))
        pUnk = (IUnknown *) this;
    else if (IsEqualIID(riid, IID_ISynchronize))
        pUnk = (ISynchronize *) _pParent;
    else if (IsEqualIID(riid, IID_ISynchronizeHandle))
        pUnk = (ISynchronizeHandle *) _pParent;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CMREInnerUnknown::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMREInnerUnknown::Release()
{
    ULONG lRef = InterlockedDecrement( (long*) &_iRefCount );

    if (lRef == 0)
    {
        delete _pParent;
    }

    return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::AddRef, public
//
//  Synopsis:   Forwards AddRef to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CManualResetEvent::AddRef()
{
    return _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::CManualResetEvent
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CManualResetEvent::CManualResetEvent( IUnknown *pControl, HRESULT *phr ) :
_cInner( this )
{
    // CManualResetEvent creates a CStdEvent containing a
    // ManualResetEvent, and delegates its methods to
    // CStdEvent

    if (pControl != NULL)
        _pControl = pControl;
    else
        _pControl = &_cInner;

    m_cStdEvent = new CStdEvent(NULL);

    if (m_cStdEvent == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Create an unnamed manual reset event
    HANDLE hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (hEvent == NULL)
    {
        *phr = E_FAIL;
        return;
    }

    *phr = m_cStdEvent->SetEventHandle(&hEvent);
    if (FAILED(*phr))
    {
        return;
    }
    *phr = S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::~CManualResetEvent
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------
CManualResetEvent::~CManualResetEvent( )
{
    if (m_cStdEvent != NULL)
        m_cStdEvent->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::QueryInterface, public
//
//  Synopsis:   Forwards QueryInterface to the controlling unknown
//
//-------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return _pControl->QueryInterface( riid, ppvObj );
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::Release, public
//
//  Synopsis:   Forwards Release to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CManualResetEvent::Release()
{
    return _pControl->Release();
}


//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::Wait, public
//
//  Synopsis:   Waits for call to complete.  For MTA it just blocks.
//              For STA it enters a message loop.
//
//--------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::Wait(DWORD dwFlags, DWORD dwTimeout )
{
    return m_cStdEvent->Wait(dwFlags, dwTimeout);
}


//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::Signal, public
//
//  Synopsis:   Invoked when the call is done.  Sets event.
//
//--------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::Signal()
{
    return m_cStdEvent->Signal();
}


//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::Reset, public
//
//  Synopsis:   Resets ISynchronize state.
//
//--------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::Reset()
{
    return m_cStdEvent->Reset();
}


//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::GetHandle, public
//
//  Synopsis:   Gets Event handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::GetHandle(HANDLE *ph)
{
    return m_cStdEvent->GetHandle(ph);
}


// ISynchronizeContainer Methods
//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSCInnerUnknown::AddRef()
{
    return InterlockedIncrement( (long *) &_iRefCount );
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::CSCInnerUnknown
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CSCInnerUnknown::CSCInnerUnknown( CSynchronizeContainer *pParent )
{
    _iRefCount = 1;
    _pParent   = pParent;
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CSCInnerUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown *pUnk;

    if (IsEqualIID(riid, IID_IUnknown))
        pUnk = (IUnknown *) this;
    else if (IsEqualIID(riid, IID_ISynchronizeContainer))
        pUnk = (ISynchronizeContainer *) _pParent;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSCInnerUnknown::Release()
{
    ULONG lRef = InterlockedDecrement( (long*) &_iRefCount );

    if (lRef == 0)
    {
        delete _pParent;
    }

    return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::AddRef, public
//
//  Synopsis:   Forwards AddRef to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSynchronizeContainer::AddRef()
{
    return _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::CSynchronizeContainer
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CSynchronizeContainer::CSynchronizeContainer( IUnknown *pControl) :
_cInner( this ),
_lLast(0)
{
    if (pControl != NULL)
        _pControl = pControl;
    else
        _pControl = &_cInner;
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::~CSynchronizeContainer
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------
CSynchronizeContainer::~CSynchronizeContainer( )
{
    DWORD i;
    // Free any remaining synchronizes.
    for (i = 0; i < _lLast; i++)
        _aSync[i]->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::QueryInterface, public
//
//  Synopsis:   Forwards QueryInterface to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP CSynchronizeContainer::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return _pControl->QueryInterface( riid, ppvObj );
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::Release, public
//
//  Synopsis:   Forwards Release to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSynchronizeContainer::Release()
{
    return _pControl->Release();
}


//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::AddSynchronize, public
//
//  Synopsis:   Adds an ISynchronize Object to the list of objects
//              to wait on.
//
//--------------------------------------------------------------------
STDMETHODIMP CSynchronizeContainer::AddSynchronize(ISynchronize *pSync)
{

    HRESULT            hr;
    HANDLE             hEvent;
    ISynchronizeHandle *pEvent;

    if (pSync == NULL)
    {
        return E_INVALIDARG;
    }


    // Get the synchronize's event.
    hr = pSync->QueryInterface( IID_ISynchronizeHandle, (void **) &pEvent );
    if (FAILED(hr))
        return hr;

    hr = pEvent->GetHandle( &hEvent );
    pEvent->Release();
    if (FAILED(hr))
        return hr;

    // Add the synchronize at the end of the array (if its not full).
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    if (_lLast < MAX_SYNC)
    {
        _aEvent[_lLast] = hEvent;
        _aSync[_lLast]  = pSync;
        _lLast         += 1;
    } else
        hr = RPC_E_OUT_OF_RESOURCES;
    UNLOCK(gComLock);

    // If we kept the ISynchronize, AddRef it.
    if (SUCCEEDED(hr))
        pSync->AddRef();
    return hr;

}


//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::WaitMultiple, public
//
//  Synopsis:   Waits for objects to be signaled.
//
//--------------------------------------------------------------------
//  CODEWORK: There are race conditions that can occur if multiple threads
//    are executing WaitMultiple on the same container. The underlying
//    Win32 APIs use an array of handles. To meet the spec, the signaled
//    synchronize object is to be removed from the container when signaled.
//    This causes the array of events to be modified. It is unpredictable
//    what will happen if another thread is in WaitMultiple when this occurs.
//    Should this be detected (and an error returned) to enforce only a
//    single thread can be in WaitMultiple at a time?
//
STDMETHODIMP CSynchronizeContainer::WaitMultiple(DWORD dwFlags,
                                                 DWORD dwTimeout,
                                                 ISynchronize **ppSync)
{
    DWORD index = 0;
    if (dwFlags&COWAIT_WAITALL)
    {
        // Wait all not supported
        return E_INVALIDARG;
    }

    if (_lLast == 0)
    {
        // Nothing to Synchronize
        return RPC_E_NO_SYNC;
    }

    if (ppSync == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = CoWaitForMultipleHandles(dwFlags,
                                          dwTimeout,
                                          _lLast,
                                          _aEvent,
                                          &index);
    if (FAILED(hr))
    {
        *ppSync = NULL;
    } else
    {
        // Have interface that signaled, remove
        // From list and return it to caller
        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);

        *ppSync = _aSync[index];

        Win4Assert((_lLast>0) && (index<_lLast));

        _lLast--;
        for(; index<_lLast ; index++)
        {
          _aEvent[index] = _aEvent[index+1];
          _aSync[index] = _aSync[index+1];
        }

        UNLOCK(gComLock);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\cnct_tbl.h ===
// cnct_tbl.h

// CConnectionTable maps connection numbers (as returned by ::Advise())
// to clipformat's for DDE advise connections.

#ifndef fCnct_tbl_h
#define fCnct_tbl_h

class FAR CDdeConnectionTable : public CPrivAlloc
{
  public:
	CDdeConnectionTable();
	~CDdeConnectionTable();

	INTERNAL Add 		(DWORD dwConnection, CLIPFORMAT cf, DWORD grfAdvf);
	INTERNAL Subtract (DWORD dwConnection, CLIPFORMAT FAR* pcf, DWORD FAR* pgrfAdvf);
	INTERNAL Lookup	(CLIPFORMAT cf, LPDWORD pdwConnection);
	INTERNAL Erase		(void);

  private:
	HANDLE 	m_h;		  // handle to the table
	DWORD 	m_cinfo;	  // total number of INFO entries
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\threads.cxx ===
//+-------------------------------------------------------------------
//
//  File:       threads.cxx
//
//  Contents:   Rpc thread cache
//
//  Classes:    CRpcThread       - single thread
//              CRpcThreadCache  - cache of threads
//
//  Notes:      This code represents the cache of Rpc threads used to
//              make outgoing calls in the SINGLETHREADED object Rpc
//              model.
//
//  History:                Rickhi  Created
//              07-31-95    Rickhi  Fix event handle leak
//
//+-------------------------------------------------------------------
#include    <ole2int.h>
#include    <olerem.h>
#include    <threads.hxx>
#include    <security.hxx>   // SuspendImpersonate

// Rpc worker thread cache.
CRpcThreadCache     gRpcThreadCache;

// static members of ThreadCache class
CRpcThread * CRpcThreadCache::_pFreeList = NULL;// list of free threads
COleStaticMutexSem    CRpcThreadCache::_mxs;    // for list manipulation


//+-------------------------------------------------------------------
//
//  Member:     CRpcThreadCache::RpcWorkerThreadEntry
//
//  Purpose:    Entry point for an Rpc worker thread.
//
//  Returns:    nothing, it never returns.
//
//  Callers:    Called ONLY by a worker thread.
//
//+-------------------------------------------------------------------
DWORD _stdcall CRpcThreadCache::RpcWorkerThreadEntry(void *param)
{
    // First thing we need to do is LoadLibrary ourselves in order to
    // prevent our code from going away while this worker thread exists.
    // The library will be freed when this thread exits.

    HINSTANCE hInst = LoadLibrary(L"OLE32.DLL");

    // Call the worker loop for the thread object parameter and delete it
    // when its done.
    CRpcThread *pThrd = (CRpcThread *) param;
    pThrd->WorkerLoop();
    delete pThrd;

    // Simultaneously free our Dll and exit our thread. This allows us to
    // keep our Dll around incase a remote call was cancelled and the
    // worker thread is still blocked on the call, and allows us to cleanup
    // properly when all threads are done with the code.

    FreeLibraryAndExitThread(hInst, 0);

    // compiler wants a return value
    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcThread::CRpcThread
//
//  Purpose:    Constructor for a thread object.
//
//  Notes:      Allocates a wakeup event.
//
//  Callers:    Called ONLY by CacheCreateThread.
//
//+-------------------------------------------------------------------
CRpcThread::CRpcThread(LPTHREAD_START_ROUTINE fn, void *param) :
    _fn(fn),
    _param(param),
    _pNext(NULL),
    _fDone(FALSE)
{
    //  create the Wakeup event. Do NOT use the event cache, as there are
    //  some exit paths that leave this event in the signalled state!

#ifdef _CHICAGO_        // Chicago ANSI optimization
    _hWakeup = CreateEventA(NULL, FALSE, FALSE, NULL);
#else //_CHICAGO_
    _hWakeup = CreateEvent(NULL, FALSE, FALSE, NULL);
#endif //_CHICAGO_

    ComDebOut((DEB_CHANNEL,
        "CRpcThread::CRpcThread pThrd:%x _hWakeup:%x\n", this, _hWakeup));
}


//+-------------------------------------------------------------------
//
//  Member:     CRpcThread::~CRpcThread
//
//  Purpose:    Destructor for an Rpc thread object.
//
//  Notes:      When threads are exiting, they place the CRpcThread
//              object on the delete list. The main thread then later
//              pulls it from the delete list and calls this destructor.
//
//  Callers:    Called ONLY by a worker thread.
//
//+-------------------------------------------------------------------
CRpcThread::~CRpcThread()
{
    // close the event handle. Do NOT use the event cache, since not all
    // exit paths leave this event in the non-signalled state. Also, do
    // not close NULL handle.

    if (_hWakeup)
    {
        CloseHandle(_hWakeup);
    }

    ComDebOut((DEB_CHANNEL,
        "CRpcThread::~CRpcThread pThrd:%x _hWakeup:%x\n", this, _hWakeup));
}


//---------------------------------------------------------------------------
//
//  Method:     CRpcThread::operator delete
//
//  Synopsis:   Use the process heap rather then the COM debug heap.
//              See operator new.
//
//---------------------------------------------------------------------------
void CRpcThread::operator delete( void *thread )
{
    HeapFree( GetProcessHeap(), 0, thread );
}

//---------------------------------------------------------------------------
//
//  Method:     CRpcThread::operator new
//
//  Synopsis:   Allocate memory for this class directly out of the process
//              heap so the debug memory allocator doesn't track this
//              memory.  Threads frequently don't have a chance to clean up
//              before the process exits (CRpcResolver::WorkerThreadLoop)
//
//---------------------------------------------------------------------------
void *CRpcThread::operator new( size_t size )
{
    return HeapAlloc( GetProcessHeap(), 0, size );
}

//+-------------------------------------------------------------------
//
//  Function:   CRpcThread::WorkerLoop
//
//  Purpose:    Entry point for a new Rpc call thread.
//
//  Notes:      Dispatch to the specified function.  When it returns wait
//              if possible.  If we wake up with more work, do it.
//
//              When there is no more work after some timeout period, we
//              pull it from the free list and exit.
//
//  Callers:    Called ONLY by worker thread.
//
//+-------------------------------------------------------------------
void CRpcThread::WorkerLoop()
{
    // Main worker loop where we do some work then wait for more.
    // When the thread has been inactive for some period of time
    // it will exit the loop.

    while (!_fDone)
    {
    	Win4Assert( _fn != NULL );
    	
        // Dispatch the call.
        _fn(_param);

        // Leverage appverifier.   Do this before null'ing params, so
        // we know what code we just called into.
        RtlCheckForOrphanedCriticalSections(GetCurrentThread());

        _fn    = NULL;
        _param = NULL;

        if (!_hWakeup)
        {
            // we failed to create an event in the ctor so we cant
            // get put on the freelist to be re-awoken later with more
            // work. Just exit.
            break;
        }

        // put the thread object on the free list
        gRpcThreadCache.AddToFreeList(this);

        // Wait for more work or for a timeout.
        DWORD dwRet;
        ULONG i;
        
        i = 0;
        while (TRUE)
        {
            dwRet = WaitForSingleObjectEx(_hWakeup, THREAD_INACTIVE_TIMEOUT, 0);
            if (dwRet == WAIT_OBJECT_0)
            {
                // just break out, we have new work to do
                break;
            }
            else
            {
                // This assert might be overactive during stress?
                Win4Assert(dwRet == WAIT_TIMEOUT);
				
                //
                // Either we haven't gotten any new work in the last timeout period, or
                // WFSOEx is blowing chunks.  In either case try to remove ourself from 
                // the free thread list.  If _fDone is still FALSE, it means someone is 
                // about to give us more work to do (so go wait for that to happen).
                //
                // Note there is a possibility that WFSOEx might be so broken on an over-
                // stressed machine that it keeps failing, and we keep looping.  However
                // eventually we will either get new work to do, or we will manage to
                // get off of the free list and die.
                //
                gRpcThreadCache.RemoveFromFreeList(this);
                if(_fDone)
                {
                    // OK to exit and let this thread die.
                    break;
                }
            }

            i++; // for debugging if we ever get stuck in a loop
        }
    }

    // Assert that we are not exiting with work 
    // assigned to us.
    Win4Assert(_fn == NULL);
}


//+-------------------------------------------------------------------
//
//  Function:   CacheCreateThread
//
//  Purpose:    Finds the first free thread, and dispatches the request
//              to that thread, or creates a new thread if none are
//              available.
//
//  Notes:      This function is just like CreateThread except
//              - It doesn't return a thread handle
//              - It's faster when it uses a cached thread
//              - It handles shutdown when ole32.dll is unloaded
//              - It sets the security descriptor so you don't get
//                a random one if called when impersonating.
//
//  Returns:    S_OK if dispatched OK
//              HRESULT if it can't create a thread.
//
//+-------------------------------------------------------------------
HRESULT CacheCreateThread( LPTHREAD_START_ROUTINE fn, void *param )
{
    Win4Assert( fn != NULL );
    if( fn == NULL )
        return E_INVALIDARG;
		
    HRESULT hr = S_OK;

    CRpcThreadCache::_mxs.Request();

    // grab the first thread from the list
    CRpcThread *pThrd = CRpcThreadCache::_pFreeList;

    if (pThrd)
    {
        // update the free list pointer
        CRpcThreadCache::_pFreeList = pThrd->GetNext();
        CRpcThreadCache::_mxs.Release();

        // dispatch the call
        pThrd->Dispatch(fn, param);
    }
    else
    {
        // Remove the thread token.
        CRpcThreadCache::_mxs.Release();
        HANDLE hThread;
        SuspendImpersonate( &hThread );

        // no free threads, spin up a new one and dispatch directly to it.
        pThrd = new CRpcThread( fn, param );
        if (pThrd != NULL)
        {
            DWORD  dwThrdId;
            HANDLE hThrd = CreateThread(
                                        NULL,
                                        0,
                                        CRpcThreadCache::RpcWorkerThreadEntry,
                                        pThrd, 0,
                                        &dwThrdId);

            if (hThrd)
            {
                // close the thread handle since we dont need it for anything.
                CloseHandle(hThrd);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                delete pThrd;
                ComDebOut((DEB_ERROR,"CreatThread failed:%x\n", hr));
            }
        }
        else
            hr = E_OUTOFMEMORY;

        // Restore the thread token.
        ResumeImpersonate( hThread );
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CRpcThreadCache::RemoveFromFreeList
//
//  Purpose:    Tries to pull a thread from the free list.
//
//  Returns:    pThrd->_fDone TRUE if it was successfull and thread can exit.
//              pThrd->_fDone FALSE otherwise.
//
//  Callers:    Called ONLY by a worker thread.
//
//+-------------------------------------------------------------------
void CRpcThreadCache::RemoveFromFreeList(CRpcThread *pThrd)
{
    ComDebOut((DEB_CHANNEL,
        "CRpcThreadCache::RemoveFromFreeList pThrd:%x\n", pThrd));

    COleStaticLock lck(_mxs);

    //  pull pThrd from the free list. if it is not on the free list
    //  then either it has just been dispatched OR ClearFreeList has
    //  just removed it, set _fDone to TRUE, and kicked the wakeup event.

    CRpcThread *pPrev = NULL;
    CRpcThread *pCurr = _pFreeList;

    while (pCurr && pCurr != pThrd)
    {
        pPrev = pCurr;
        pCurr = pCurr->GetNext();
    }

    if (pCurr == pThrd)
    {
        // remove it from the free list.
        if (pPrev)
            pPrev->SetNext(pThrd->GetNext());
        else
            _pFreeList = pThrd->GetNext();

        // tell the thread to wakeup and exit
        pThrd->WakeAndExit();
    }
}


//+-------------------------------------------------------------------
//
//  Member:     CRpcThreadCache::ClearFreeList
//
//  Purpose:    Cleans up all threads on the free list.
//
//  Notes:      For any threads still on the free list, it pulls them
//              off the freelist, sets their _fDone flag to TRUE, and
//              kicks their event to wake them up. When the threads
//              wakeup, they will exit.
//
//              We do not free active threads. The only way for a thread
//              to still be active at this time is if it was making an Rpc
//              call and was cancelled by the message filter and the thread has
//              still not returned to us.  We cant do much about that until
//              Rpc supports cancel for all protocols.  If the thread ever
//              does return to us, it will eventually idle-out and delete
//              itself. This is safe because the threads LoadLibrary OLE32.
//
//  Callers:    Called ONLY by the last COM thread during
//              ProcessUninitialize.
//
//+-------------------------------------------------------------------
void CRpcThreadCache::ClearFreeList(void)
{
    ComDebOut((DEB_CHANNEL, "CRpcThreadCache::ClearFreeList\n"));

    {
        COleStaticLock lck(_mxs);

        CRpcThread *pThrd = _pFreeList;
        while (pThrd)
        {
            // use temp variable incase thread exits before we call GetNext
            CRpcThread *pThrdNext = pThrd->GetNext();
            pThrd->WakeAndExit();
            pThrd = pThrdNext;
        }

        _pFreeList = NULL;

        // the lock goes out of scope at this point. we dont want to hold
        // it while we sleep.
    }

    // yield to let the other threads run if necessary.
    Sleep(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\vsevfire.h ===
//+-------------------------------------------------------------------
//
//  File:       vsevfile.h
//
//  Contents:   Vista events and related functions
//
//  History:    26-Sep-97  RongC  Created
//
//  Note:       This file was generated from vsevfire.idl in the Vista land.
//              Since we only use a very small and stable subset part of
//              the original file, we don't want to build the IDL file
//              everytime.  We may, however, consider building vsevfire.idl
//              when it ships with NT 5.0 SDK.
//
//--------------------------------------------------------------------

typedef enum VSAParameterType {
    cVSAParameterKeyMask            = 0x80000000,
    cVSAParameterKeyString          = 0x80000000,
    cVSAParameterValueMask          = 0x7ffff,
    cVSAParameterValueTypeMask      = 0x70000,
    cVSAParameterValueUnicodeString = 0,
    cVSAParameterValueANSIString    = 0x10000,
    cVSAParameterValueGUID          = 0x20000,
    cVSAParameterValueDWORD         = 0x30000,
    cVSAParameterValueBYTEArray     = 0x40000,
    cVSAParameterValueLengthMask    = 0xffff
} VSAParameterFlags;

typedef enum VSAStandardParameter {
    cVSAStandardParameterSourceMachine      = 0,
    cVSAStandardParameterSourceProcess      = 1,
    cVSAStandardParameterSourceThread       = 2,
    cVSAStandardParameterSourceComponent    = 3,
    cVSAStandardParameterSourceSession      = 4,
    cVSAStandardParameterTargetMachine      = 5,
    cVSAStandardParameterTargetProcess      = 6,
    cVSAStandardParameterTargetThread       = 7,
    cVSAStandardParameterTargetComponent    = 8,
    cVSAStandardParameterTargetSession      = 9,
    cVSAStandardParameterSecurityIdentity   = 10,
    cVSAStandardParameterCausalityID        = 11,
    cVSAStandardParameterNoDefault          = 0x4000,
    cVSAStandardParameterSourceHandle       = 0x4000,
    cVSAStandardParameterTargetHandle       = 0x4001,
    cVSAStandardParameterArguments          = 0x4002,
    cVSAStandardParameterReturnValue        = 0x4003,
    cVSAStandardParameterException          = 0x4004,
    cVSAStandardParameterCorrelationID      = 0x4005
} VSAStandardParameters;

typedef enum eVSAEventFlags {
    cVSAEventStandard       = 0,
    cVSAEventDefaultSource  = 1,
    cVSAEventDefaultTarget  = 2,
    cVSAEventCanBreak       = 4
} VSAEventFlags;


const IID IID_ISystemDebugEventFire =
    {0x6C736DC1,0xAB0D,0x11D0,{0xA2,0xAD,0x00,0xA0,0xC9,0x0F,0x27,0xE8}};

interface ISystemDebugEventFire : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE BeginSession( 
        /* [in] */ REFGUID guidSourceID,
        /* [in] */ LPCOLESTR strSessionName) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE EndSession( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE IsActive( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE FireEvent( 
        /* [in] */ REFGUID guidEvent,
        /* [in] */ int nEntries,
        /* [size_is][in] */ PULONG_PTR rgKeys,
        /* [size_is][in] */ PULONG_PTR rgValues,
        /* [size_is][in] */ LPDWORD rgTypes,
        /* [in] */ DWORD dwTimeLow,
        /* [in] */ LONG dwTimeHigh,
        /* [in] */ VSAEventFlags dwFlags) = 0;
};


const IID IID_ISystemDebugEventShutdown =
    {0x6C736DCF,0xAB0D,0x11D0,{0xA2,0xAD,0x00,0xA0,0xC9,0x0F,0x27,0xE8}};

interface ISystemDebugEventShutdown : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
};


extern const CLSID CLSID_VSA_IEC =
    {0x6C736DB1,0xBD94,0x11D0,{0x8A,0x23,0x00,0xAA,0x00,0xB5,0x8E,0x10}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\cnct_tbl.cxx ===
// cnct_tbl.cpp
//
// class CConnectionTable
//
// CConnectionTable maps connection numbers (as returned by ::Advise())
// to clipformat's for DDE advise connections.

#include "ddeproxy.h"
#include "cnct_tbl.h"

ASSERTDATA

#define grfMemFlags (GMEM_MOVEABLE | GMEM_ZEROINIT)

// number of INFO entries to grow by
#define cinfoBlock 10

typedef struct INFO
{
    BOOL       fUsed;         // is this table entry used?
    DWORD      dwConnection;  // search key
    CLIPFORMAT cf;            // corresponding cf, for use in DDE_(UN)ADVISE
    DWORD      grfAdvf;       // ON_CHANGE or ON_SAVE or ON_CLOSE
} INFO, FAR* PINFO;



CDdeConnectionTable::CDdeConnectionTable ()
{
    m_h = GlobalAlloc (grfMemFlags, cinfoBlock * sizeof(INFO));
    Assert (m_h);
    m_cinfo=cinfoBlock;
}


CDdeConnectionTable::~CDdeConnectionTable ()
{
    Assert(m_h);
    m_h =GlobalFree (m_h);
    Assert (m_h==NULL);
    m_cinfo=0;
}




INTERNAL CDdeConnectionTable::Add
    (DWORD      dwConnection,
     CLIPFORMAT cf,
     DWORD      grfAdvf)
{
  Start:
    PINFO rginfo;

    if (NULL==(rginfo = (PINFO) GlobalLock(m_h)))
    {
        Puts ("ERROR: CDdeConnectionTable::Add out of memory\n");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    // Look for an empty table entry
    for (DWORD i=0; i<m_cinfo; i++)
    {
        if (!rginfo[i].fUsed)
        {
            rginfo[i].fUsed        = TRUE;
            rginfo[i].dwConnection = dwConnection;
            rginfo[i].cf           = cf;
            rginfo[i].grfAdvf      = grfAdvf;
            break;
        }
        else
        {
            Assert (rginfo[i].dwConnection != dwConnection);
        }
    }
    GlobalUnlock (m_h);
    if (i==m_cinfo) // if no empty entry found
    {
        Puts ("Growing the connection table\n");
        m_h = GlobalReAlloc (m_h,(m_cinfo += cinfoBlock) * sizeof(INFO),
                             grfMemFlags);
        if (m_h==NULL)
            return ReportResult(0, E_OUTOFMEMORY, 0, 0);
        goto Start;
    }
    else
    {
        return NOERROR;
    }
}




INTERNAL CDdeConnectionTable::Subtract
    (DWORD           dwConnection,
     CLIPFORMAT FAR* pcf,          // out parm
     DWORD FAR* pgrfAdvf)          // out parm
{
    PINFO rginfo;
    if (dwConnection==0)
    {
        Puts ("CDdeConnectionTable::Subtract called with dwConnection==0\n");
        return ReportResult(0, E_INVALIDARG, 0, 0);
    }

    if (NULL==(rginfo = (PINFO) GlobalLock(m_h)))
    {
        Assert (0);
        Puts ("ERROR: CDdeConnectionTable::Subtract out of memory\n");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    for (DWORD i=0; i<m_cinfo; i++)
    {
        if (rginfo[i].fUsed && rginfo[i].dwConnection == dwConnection)
        {
            Assert (pcf);
            *pcf = rginfo[i].cf;
            Assert (pgrfAdvf);
            *pgrfAdvf = rginfo[i].grfAdvf;
            rginfo[i].fUsed = FALSE;  // remove this connection
            GlobalUnlock (m_h);
            return NOERROR;
        }
    }
    GlobalUnlock (m_h);
    return ReportResult(0, S_FALSE, 0, 0); // not found
}




INTERNAL CDdeConnectionTable::Lookup
    (CLIPFORMAT cf,             // search key
    LPDWORD pdwConnection)      // out parm.  May be NULL on input
{
    PINFO rginfo;

    if (NULL==(rginfo = (PINFO) GlobalLock(m_h)))
    {
        Puts ("ERROR: CDdeConnectionTable::Lookup out of memory\n");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    for (DWORD i=0; i<m_cinfo; i++)
    {
        if (rginfo[i].fUsed &&
            rginfo[i].cf == cf)
        {
            if (pdwConnection)
                *pdwConnection = rginfo[i].dwConnection;
            GlobalUnlock (m_h);
            return NOERROR;
        }
    }
    GlobalUnlock (m_h);
    return ReportResult(0, S_FALSE, 0, 0); // not found
}



INTERNAL CDdeConnectionTable::Erase
    (void)
{
    PINFO rginfo;
    Assert (wIsValidHandle(m_h, NULL));
    if (NULL==(rginfo = (PINFO) GlobalLock(m_h)))
    {
        Puts ("ERROR: CDdeConnectionTable::Lookup out of memory\n");
        Assert (0);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    for (DWORD i=0; i<m_cinfo; i++)
    {
        rginfo[i].fUsed = FALSE;
    }
    GlobalUnlock (m_h);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddechc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       DdeChC.cxx
//
//  Contents:   CDdeChannelControl implementation for DDE. This
//		implementation requires no instance data, therefore it is
//		intended to be static.
//
//  Functions:
//
//  History:    08-May-94 Johann Posch (johannp)    Created
//  		10-May-94 KevinRo  Made simpler
//		29-May-94 KevinRo  Added DDE Server support
//
//--------------------------------------------------------------------------
#include "ddeproxy.h"

//+---------------------------------------------------------------------------
//
//  Function:	DispatchCall
//
//  Synopsis:   DispatchCall is called to handle incoming calls.
//
//  Effects:    Dispatches a call to the specified in the DispatchData.
//		This function is the result of a call in OnData(), which
//		processes incoming calls from the OLE 1.0 server.
//
//  Arguments:  [pDispData] -- Points to the dispatch data structure
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-16-94   JohannP Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL DispatchCall( PDISPATCHDATA pDispData )
{
    intrDebugOut((DEB_ITRACE,
		  "DispatchCall(pDispData=%x)\n",
		  pDispData));

    intrAssert(pDispData != NULL);
    POLE1DISPATCHDATA pData = (POLE1DISPATCHDATA)pDispData->pData;
    intrAssert(pData != NULL);

    switch (pData->wDispFunc)
    {
    case DDE_DISP_SENDONDATACHANGE: // OnDataChange
	{
	    PDDEDISPATCHDATA pDData = (PDDEDISPATCHDATA)pDispData->pData;
	    return pDData->pCDdeObject->SendOnDataChange(pDData->iArg);
	}

    case DDE_DISP_OLECALLBACK: // OleCallBack
	{
	    PDDEDISPATCHDATA pDData = (PDDEDISPATCHDATA)pDispData->pData;
	    return  pDData->pCDdeObject->OleCallBack(pDData->iArg,NULL);
	}

    //
    // The server window has an incoming call. Look in dde\server\srvr.cxx
    //
    case DDE_DISP_SRVRWNDPROC:
	return(SrvrDispatchIncomingCall((PSRVRDISPATCHDATA)pDispData->pData));
    //
    // This dispatches to a Document window
    //
    case DDE_DISP_DOCWNDPROC:
	return(DocDispatchIncomingCall((PDOCDISPATCHDATA)pDispData->pData));

    default:
	intrAssert(!"Unknown wDispFunc");
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddecnvrt.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ddecnvrt.cpp

Abstract:

    This module contains the code to read/write PBrush, MSDraw native data
    formats. This module also contains PBrush native format <->DIbFile stream,
    and MSDraw native format <-> placeable metafile stream conversion routines.

Author:

    Srini Koppolu (srinik)  06/29/1993

Revision History:

--*/

#ifndef _MAC


/************************   FILE FORMATS   **********************************


Normal Metafile (memory or disk based):

     ------------ ---------------
    | METAHEADER | Metafile bits |
     ------------ ---------------

Placeable Metafile:

     --------------------- -----------------
    | PLACEABLEMETAHEADER | Normal metafile |
     --------------------- -----------------

Memory Based DIB:

     ------------------ --------------- ----------
    | BITMAPINFOHEADER | RGBQUAD array | DIB bits |
     ------------------ --------------- ----------

DIB file format:

     ------------------ ------------------
    | BITMAPFILEHEADER | Memory based DIB |
     ------------------ ------------------

Ole10NativeStream Format:

     -------- ----------------------
    | dwSize | Object's Native data |
     -------- ----------------------

PBrush Native data format:

     -----------------
    | Dib File format |
     -----------------

MSDraw Native data format:

     --------------------- ------------- ------------- -----------------
    | mapping mode (WORD) | xExt (WORD) | yExt (WORD) | Normal metafile |
     --------------------- ------------- ------------- -----------------


*****************************************************************************/

#include <ole2int.h>

INTERNAL    UtGetHMFPICTFromMSDrawNativeStm
    (LPSTREAM pstm, DWORD dwSize, HANDLE FAR* lphdata)
{
    HRESULT     error;
    WORD        mfp[3]; // mm, xExt, yExt
    HMETAFILE   hMF = NULL;

    *lphdata = NULL;

    if (error = pstm->Read(mfp, sizeof(mfp), NULL))
        return error;

    dwSize -= sizeof(mfp);

    if (error = UtGetHMFFromMFStm(pstm, dwSize, FALSE, (void **)&hMF))
        return error;

    AssertSz(mfp[0] == MM_ANISOTROPIC, "invalid map mode in MsDraw native data");

    if (*lphdata = UtGetHMFPICT(hMF, TRUE, (int) mfp[1], (int) mfp[2]))
        return NOERROR;

    return ResultFromScode(E_OUTOFMEMORY);
}


INTERNAL UtPlaceableMFStmToMSDrawNativeStm
    (LPSTREAM pstmPMF, LPSTREAM pstmMSDraw)
{
    DWORD   dwSize; // size of metafile bits excluding the placeable MF header
    LONG    xExt;
    LONG    yExt;
    WORD    wBuf[5]; // dwSize(DWORD), mm(int), xExt(int), yExt(int)
    HRESULT error;

    if (error = UtGetSizeAndExtentsFromPlaceableMFStm(pstmPMF, &dwSize,
            &xExt, &yExt))
        return error;

    *((DWORD FAR*) wBuf) = dwSize + 3*sizeof(WORD);
    wBuf[2] = MM_ANISOTROPIC;
    wBuf[3] = (int) xExt;
    wBuf[4] = (int) yExt;

    if (error = pstmMSDraw->Write(wBuf, sizeof(wBuf), 0))
        return error;

    ULARGE_INTEGER ularge_int;
    ULISet32(ularge_int, dwSize);
    if ((error = pstmPMF->CopyTo(pstmMSDraw, ularge_int,
            NULL, NULL)) == NOERROR)
        StSetSize(pstmMSDraw);

    return error;

}


INTERNAL UtDIBFileStmToPBrushNativeStm
    (LPSTREAM pstmDIBFile, LPSTREAM pstmPBrush)
{
    BITMAPFILEHEADER bfh;
    HRESULT error;

    if (error = pstmDIBFile->Read(&bfh, sizeof(bfh), 0))
        return error;

    // seek to the begining of the stream
    LARGE_INTEGER large_int;
    LISet32( large_int, 0);
    if (error = pstmDIBFile->Seek(large_int, STREAM_SEEK_SET, 0))
        return error;

    if (error = pstmPBrush->Write(&(bfh.bfSize), sizeof(DWORD), 0))
        return error;

    ULARGE_INTEGER ularge_int;
    ULISet32(ularge_int, bfh.bfSize);

    if ((error = pstmDIBFile->CopyTo(pstmPBrush, ularge_int,
            NULL, NULL)) == NOERROR)
        StSetSize(pstmPBrush);

    return error;
}



INTERNAL UtContentsStmTo10NativeStm
    (LPSTORAGE pstg, REFCLSID rclsid, BOOL fDeleteSrcStm, UINT FAR* puiStatus)
{
    CLIPFORMAT  cf;
    LPOLESTR        lpszUserType = NULL;
    HRESULT     error;
    LPSTREAM    pstmSrc = NULL;
    LPSTREAM    pstmDst = NULL;

    *puiStatus = NULL;

    if (error = ReadFmtUserTypeStg(pstg, &cf, &lpszUserType))
        return error;


    if (! ((cf == CF_DIB  && rclsid == CLSID_PBrush)
            || (cf == CF_METAFILEPICT && rclsid == CLSID_MSDraw))) {
        error = ResultFromScode(DV_E_CLIPFORMAT);
        goto errRtn;
    }

    if (error = pstg->OpenStream(CONTENTS_STREAM, NULL,
                        (STGM_READ|STGM_SHARE_EXCLUSIVE),
                        0, &pstmSrc)) {
        *puiStatus |= CONVERT_NOSOURCE;

        // check whether OLE10_NATIVE_STREAM exists
        if (pstg->OpenStream(OLE10_NATIVE_STREAM, NULL,
                (STGM_READ|STGM_SHARE_EXCLUSIVE), 0, &pstmDst))
            *puiStatus |= CONVERT_NODESTINATION;
        else {
            pstmDst->Release();
            pstmDst = NULL;
        }

        goto errRtn;
    }

    if (error = OpenOrCreateStream(pstg, OLE10_NATIVE_STREAM, &pstmDst)) {
        *puiStatus |= CONVERT_NODESTINATION;
        goto errRtn;
    }

    if (cf == CF_METAFILEPICT)
        error = UtPlaceableMFStmToMSDrawNativeStm(pstmSrc, pstmDst);
    else
        error = UtDIBFileStmToPBrushNativeStm(pstmSrc, pstmDst);

errRtn:
    if (pstmDst)
        pstmDst->Release();

    if (pstmSrc)
        pstmSrc->Release();

    if (error == NOERROR) {
        LPOLESTR lpszProgId = NULL;
        ProgIDFromCLSID(rclsid, &lpszProgId);

        error = WriteFmtUserTypeStg(pstg,
                        RegisterClipboardFormat(lpszProgId),
                        lpszUserType);

        if (lpszProgId)
            delete lpszProgId;
    }

    if (error == NOERROR) {
        if (fDeleteSrcStm)
            pstg->DestroyElement(CONTENTS_STREAM);
    } else {
        pstg->DestroyElement(OLE10_NATIVE_STREAM);
    }

    if (lpszUserType)
        delete lpszUserType;

    return error;
}



INTERNAL Ut10NativeStmToContentsStm
    (LPSTORAGE pstg, REFCLSID rclsid, BOOL fDeleteSrcStm)
{
    extern CLIPFORMAT   cfPBrush;
    extern CLIPFORMAT   cfMSDraw;

    CLIPFORMAT  cfOld;
    CLIPFORMAT  cfNew;
    LPOLESTR        lpszUserType = NULL;
    HRESULT     error;
    LPSTREAM    pstmSrc = NULL;
    LPSTREAM    pstmDst = NULL;


    if (error = ReadFmtUserTypeStg(pstg, &cfOld, &lpszUserType))
        return error;

    if (rclsid == CLSID_StaticDib)
        cfNew = CF_DIB;
    else if (rclsid == CLSID_StaticMetafile)
        cfNew = CF_METAFILEPICT;
    else {
        AssertSz(FALSE, "Internal Error: this routine shouldn't have been called for this class");
        return ResultFromScode(E_FAIL);
    }

    if (cfOld == cfPBrush) {
        if (cfNew != CF_DIB) {
            error = ResultFromScode(DV_E_CLIPFORMAT);
            goto errRtn;
        }
    } else if (cfOld == cfMSDraw) {
        if (cfNew != CF_METAFILEPICT) {
            error = ResultFromScode(DV_E_CLIPFORMAT);
            goto errRtn;
        }
    } else {
        // Converted to static object from some class other than PBrush or
        // MSDraw. The data must be in a proper format in the CONTENTS
        // stream.
        return NOERROR;
    }

    if (error = pstg->OpenStream(OLE10_NATIVE_STREAM, NULL,
                        (STGM_READ|STGM_SHARE_EXCLUSIVE),
                        0, &pstmSrc))
        goto errRtn;

    if (error = OpenOrCreateStream(pstg, CONTENTS_STREAM, &pstmDst))
        goto errRtn;

    DWORD dwSize;
    if (error = pstmSrc->Read(&dwSize, sizeof(DWORD), NULL))
        goto errRtn;

    if (cfOld == cfMSDraw) {
        WORD mfp[3]; // mm, xExt, yExt

        if (error = pstmSrc->Read(mfp, sizeof(mfp), NULL))
            goto errRtn;

        dwSize -= sizeof(mfp);

        error = UtMFStmToPlaceableMFStm(pstmSrc, dwSize,
                    (LONG) mfp[1], (LONG) mfp[2], pstmDst);

    } else {
        // The PBrush native data format is DIB File format. So all we got to
        // do is CopyTo.

        ULARGE_INTEGER ularge_int;
        ULISet32(ularge_int, dwSize);
        if ((error = pstmSrc->CopyTo(pstmDst, ularge_int, NULL,
                NULL)) == NOERROR)
            StSetSize(pstmDst);
    }

errRtn:
    if (pstmDst)
        pstmDst->Release();

    if (pstmSrc)
        pstmSrc->Release();

    if (error == NOERROR) {
        error = WriteFmtUserTypeStg(pstg, cfNew, lpszUserType);

        if (fDeleteSrcStm)
            pstg->DestroyElement(OLE10_NATIVE_STREAM);

    } else {
        pstg->DestroyElement(CONTENTS_STREAM);
    }

    if (lpszUserType)
        delete lpszUserType;

    return error;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddedo.cxx ===
/*
ddedo.cpp
DDE Data Object

copyright (c) 1992  Microsoft Corporation

Abstract:

    This module contains the methods for DdeObject::DataObject

Author:

    Jason Fuller    (jasonful)  24-July-1992

*/

#include "ddeproxy.h"
#include <stddef.h>
#include "trgt_dev.h"


#define f10UserModel
// Should we ignore a request by a 2.0 client to get advise-on-change,
// so that the user must do an explicit File/Update or File/Close?
// Probably yes, because:
// 1) Advise-on-change can be expensive for apps like PaintBrush.
// 2) It is confusing if the container asks for change updates
//    ONLY on presentation and not on native because when the user
//    closes the server and is asked "Do you want to update?" he'll say no
//    because the picture LOOKS correct even though the container does not
//    have the native data.
// 3) Excel: if A1 is the first cell you create, changes to other cells
//    will not be sent to the client until you change A1 again.
//    If advises are only sent explicitly, then all the cells extant at that
//    time will be considered part of the object.


ASSERTDATA


//
// DataObject methods
//

STDUNKIMPL_FORDERIVED(DdeObject, DataObjectImpl)


static inline INTERNAL_(BOOL) NotEqual
    (DVTARGETDEVICE FAR* ptd1,
    DVTARGETDEVICE FAR* ptd2)
{
    if (NULL==ptd1 && NULL==ptd2)
        return FALSE;
    else if ((ptd1 && !ptd2)
            || (ptd2 && !ptd1)
            || (ptd1->tdSize != ptd2->tdSize))
    {
        return TRUE;
    }
    else
#ifdef WIN32
        return 0 != memcmp(ptd1, ptd2, (size_t)ptd1->tdSize);
#else
        return 0 != _fmemcmp(ptd1, ptd2, (size_t)ptd1->tdSize);
#endif
}



// GetData
//
// The data is copied out of a private cache consisting of
// DdeObject::m_hNative, DdeObject::m_hPict, and DdeObject::m_hExtra.
// If the cache is empty, data is requested using WM_DDE_REQUEST.
// The cache should only be empty before the first DDE_DATA message
// is received.
// See DdeObject::KeepData()
//
STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::GetData
    (LPFORMATETC pformatetcIn,
     LPSTGMEDIUM pmedium)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetData(%x,pformatetcIn=%x)\n",
		  this,pformatetcIn));

lStart:
    intrDebugOut((DEB_ITRACE,"::GetData(%x)lStart\n",this));

    LPSTR lpGlobal=NULL;
    HRESULT hres;
    VDATEPTROUT (pmedium, STGMEDIUM);
    pmedium->tymed = TYMED_NULL;
    pmedium->pUnkForRelease = NULL;

    if ((hres = wVerifyFormatEtc (pformatetcIn)) != NOERROR)
    {
	goto exitRtn;
    }

    hres = E_UNEXPECTED; // assume error unless a clipboard format is found.

    if (DVASPECT_ICON & pformatetcIn->dwAspect)
    {
        hres = GetDefaultIcon(m_pDdeObject->m_clsid, NULL, &pmedium->hGlobal);
	if (hres != NOERROR)
	{
	    goto exitRtn;
	}
        hres = NOERROR;
        goto lDone;
    }
    if (m_pDdeObject->m_fGotCloseData)
    {
        // If we already got DDE_DATA on close, don't try requesting more
        // data. (MSDraw will give a bogus metafile.)
        hres=OLE_E_NOTRUNNING;
	goto exitRtn;
    }

    if (NotEqual (pformatetcIn->ptd, m_pDdeObject->m_ptd))
    {
        // If caller is asking for a different target device
        // (We assume a different pointer points to a different target device)

        if (NOERROR!=m_pDdeObject->SetTargetDevice (pformatetcIn->ptd))
        {
            // 1.0 server did not accept target device
	    hres=DATA_E_FORMATETC;
	    goto exitRtn;
        }

        Assert (hres!=NOERROR); // Must do RequestData with new target device
    }
    else
    {
        // Pick a member handle (H) to return, based on clipboard format CF.
        // If caller did not pass in its own medium, we must allocate a new
        // handle.


        #define macro(CF,H)                                                     \
        if (pformatetcIn->cfFormat == CF) {                             \
            if (m_pDdeObject->H) {                                      \
                if (pmedium->tymed == TYMED_NULL) {                     \
		intrDebugOut((DEB_ITRACE,"::GetData giving cf==%x hData=%x\n",CF,m_pDdeObject->H)); \
                    pmedium->hGlobal = m_pDdeObject->H;                 \
                    m_pDdeObject->H = NULL;                             \
                }                                                       \
                hres = NOERROR; /* found data in right format */        \
            }                                                           \
        }

             macro (g_cfNative,               m_hNative)
        else macro (m_pDdeObject->m_cfPict, m_hPict  )
        else macro (m_pDdeObject->m_cfExtra,m_hExtra )

        // If we gave away our picture, we must forget its format.
        if (pformatetcIn->cfFormat == m_pDdeObject->m_cfPict)
            m_pDdeObject->m_cfPict = 0;
        #undef macro
    }

    if (hres!=NOERROR)
    {
	intrDebugOut((DEB_ITRACE,
		      "::GetData(%x) posting DDE_REQUEST for cf==%x\n",
		      this,
		      (ULONG)pformatetcIn->cfFormat));

        // Didn't find a handle for the requested format,
        // or handle was NULL, so request it.
        // The sequence should be:
        // GetData -> DDE_REQUEST -> DDE_DATA -> OnData -> return to GetData

        if (hres=m_pDdeObject->RequestData (pformatetcIn->cfFormat) != NOERROR)
	{
	    intrDebugOut((DEB_ITRACE,
			  "::GetData(%x) RequestData returns error %x\n",
			  this,hres));

	    hres = DV_E_CLIPFORMAT;
	    goto exitRtn;
	}

        // By now, a KeepData() should have been done with the right cf,
        // so try again.
	intrDebugOut((DEB_ITRACE,
		      "::GetData(%x) KeepData should have been called. Go again\n",
			  this));

        Puts ("KeepData should have been called. Trying GetData again.\n");
        goto lStart;
    }
  lDone:
    Puts ("pmedium->hGlobal =="); Puth(pmedium->hGlobal); Putn();
    pmedium->pUnkForRelease = NULL;   // Let caller release medium
    // Must set tymed _after_ the goto loop.
    // Otherwise it'll be changed the second time around.

    // tell caller what we're returning
    pmedium->tymed = UtFormatToTymed (pformatetcIn->cfFormat);


    intrDebugOut((DEB_ITRACE,
		  "::GetData(%x)tymed=%x cfFormat=%x hGlobal=%x\n",
		  this,
		  pmedium->tymed,
		  (USHORT)pformatetcIn->cfFormat,
		  pmedium->hGlobal));
exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "::GetData(%x)hres=%x\n",
		  this,
		  hres));
    return hres;
}



STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::GetDataHere
    (LPFORMATETC pformatetcIn,
     LPSTGMEDIUM pmedium)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetDataHere(%x,pformatetcIn=%x)\n",
		  this,
		  pformatetcIn));

    HRESULT hresult = NOERROR;
    STGMEDIUM medium;
    if (!(pformatetcIn->tymed & TYMED_HGLOBAL))
    {
	intrDebugOut((DEB_ITRACE,
		      "::GetDataHere(%x)DV_E_TYMED(%x)\n",
		      this,DV_E_TYMED));
        // Cannot GetDataHere for GDI objects
        hresult = DV_E_TYMED;
	goto exitRtn;
    }
    RetErr (GetData (pformatetcIn, &medium));
    if (medium.tymed != TYMED_HGLOBAL)
    {
	intrDebugOut((DEB_ITRACE,
		      "::GetDataHere(%x)medium.tymed != TYMED_HGLOBAL\n",
		      this));
        hresult = ResultFromScode (DV_E_TYMED);
        goto errRtn;
    }
    pmedium->tymed         = medium.tymed;
    pmedium->pUnkForRelease = medium.pUnkForRelease;
    ErrRtnH (wHandleCopy (pmedium->hGlobal, medium.hGlobal));

  errRtn:
    ReleaseStgMedium (&medium);

  exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetDataHere(%x) returning %x\n",
		  this,hresult));
    return hresult;
}



STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::QueryGetData
    (LPFORMATETC pformatetcIn)
{
    HRESULT hr;
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDdeObject::QueryGetData(pformatetcIn=%x)\n",
		  this,
		  pformatetcIn));

    hr = wVerifyFormatEtc (pformatetcIn);

    if (hr != NOERROR)
    {
	goto exitRtn;
    }
    if (pformatetcIn->cfFormat == g_cfEmbeddedObject
            || pformatetcIn->cfFormat == g_cfEmbedSource
            || pformatetcIn->cfFormat == g_cfLinkSource
            || pformatetcIn->cfFormat == g_cfFileName
            || pformatetcIn->cfFormat == g_cfCustomLinkSource
            || pformatetcIn->cfFormat == g_cfObjectDescriptor
            || pformatetcIn->cfFormat == g_cfLinkSrcDescriptor)
    {
	hr = S_FALSE;
    }

    hr = m_pDdeObject->IsFormatAvailable (pformatetcIn);

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDdeObject::QueryGetData returning %x\n",
		  this,hr));
    return(hr);

}


STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::SetData
    (LPFORMATETC    pformatetc,
     STGMEDIUM FAR* pmedium,
     BOOL           fRelease)
{
    HANDLE hDdePoke;
    HRESULT hresult;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDdeObject::SetData(pformatetc=%x)\n",
		  this,
		  pformatetc));

    hresult = wVerifyFormatEtc (pformatetc);

    if (hresult != NOERROR)
    {
	goto exitRtn;
    }
    intrDebugOut((DEB_ITRACE,
		  "%x ::SetData(pformatetc->cfFormat=%x)\n",
		  this,
		  (ULONG)pformatetc->cfFormat));

    if (pformatetc->dwAspect & DVASPECT_ICON)
    {
	intrDebugOut((DEB_ITRACE,
		      "%x ::SetData dwAspect & DVASPECT_ICON\n",
		      this));
	hresult = DV_E_DVASPECT;
	goto exitRtn;
    }


    if (pformatetc->ptd != m_pDdeObject->m_ptd)
    {
        // If caller is setting with a different target device
        // (We assume a different pointer points to a different target device)

        if (NOERROR != m_pDdeObject->SetTargetDevice (pformatetc->ptd))
        {
	    intrDebugOut((DEB_IERROR,
			  "%x ::SetData server did not accept target device\n",
			  this));
	    hresult = DV_E_DVTARGETDEVICE;
	    goto exitRtn;
        }
    }

    if (hDdePoke = wPreparePokeBlock (pmedium->hGlobal,
                                      pformatetc->cfFormat,
                                      m_pDdeObject->m_aClass,
                                      m_pDdeObject->m_bOldSvr))
    {
        hresult = m_pDdeObject->Poke (m_pDdeObject->m_aItem, hDdePoke);
        if (fRelease)
            ReleaseStgMedium (pmedium);
        goto exitRtn;
    }
    else
    {
        hresult = E_OUTOFMEMORY;
    }
exitRtn:

    intrDebugOut((DEB_ITRACE,"%x _OUT ::SetData returns %x\n",this,hresult));
    return(hresult);

}





STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::DAdvise
    (FORMATETC FAR*   pformatetc,
     DWORD            grfAdvf,
     IAdviseSink FAR* pAdvSink,
     DWORD FAR*       pdwConnection)
{
    HRESULT hresult;
    HRESULT hresLookup;
    FORMATETC formatetc;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDdeObject::DAdvise(pformatetc=%x,grfAdvf=%x,pAdvSink=%x)\n",
		  this,
		  pformatetc,
		  grfAdvf,
		  pAdvSink));

    VDATEPTROUT (pdwConnection, DWORD);
    *pdwConnection = 0;

    wNormalize (pformatetc, &formatetc);

    hresult =wVerifyFormatEtc (&formatetc);

    if ( hresult  != NOERROR)
    {
	goto errRtn;
    }

    intrDebugOut((DEB_ITRACE,
		  "%x ::DAdvise pformatetc->cfFormat=%x\n",
		  this,
                  pformatetc->cfFormat));

    if (NotEqual (formatetc.ptd, m_pDdeObject->m_ptd))
    {
        if (NOERROR != m_pDdeObject->SetTargetDevice (formatetc.ptd))
	{
            hresult= DV_E_DVTARGETDEVICE;
	    goto errRtn;
	}
    }

    hresLookup = m_pDdeObject->m_ConnectionTable.Lookup (formatetc.cfFormat, NULL);
    if (hresLookup != NOERROR)
    {
        // We have not already done a DDE advise for this format

        Puts (" m_iAdvChange = "); Puti (m_pDdeObject->m_iAdvChange); Puts("\n");

        if (m_pDdeObject->m_ulObjType == OT_LINK)
        {
            ErrRtnH (m_pDdeObject->AdviseOn (formatetc.cfFormat, ON_CHANGE));
            ErrRtnH (m_pDdeObject->AdviseOn (formatetc.cfFormat, ON_SAVE));
        }
        else
        {
            ErrRtnH (m_pDdeObject->AdviseOn (formatetc.cfFormat, ON_SAVE));
            ErrRtnH (m_pDdeObject->AdviseOn (formatetc.cfFormat, ON_CLOSE));
        }
    }

    ErrZS (m_pDdeObject->m_pDataAdvHolder, E_OUTOFMEMORY);
    hresult = m_pDdeObject->m_pDataAdvHolder->Advise (this, pformatetc, grfAdvf,
                                                     pAdvSink, pdwConnection);

    m_pDdeObject->m_ConnectionTable.Add (*pdwConnection, formatetc.cfFormat,
                                             grfAdvf);

  errRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDdeObject::DAdvise hresult=%x\n",
		  this,
		  hresult));
    return hresult;
}




STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::DUnadvise
    (DWORD dwConnection)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::DUnadvise(%x,dwConnection=%x)\n",
		  this,
		  dwConnection));

    CLIPFORMAT  cf;
    HRESULT     hres;
    DWORD       grfAdvf;

    // Remove connection from table.  Lookup the cf for this connection.
    if (m_pDdeObject->m_ConnectionTable.Subtract (dwConnection, &cf, &grfAdvf)
        == NOERROR)
    {
        // If there is not another connection that needs this format
        if (m_pDdeObject->m_ConnectionTable.Lookup (cf, NULL) != NOERROR)
        {
            // We did a DDE advise for this connection, so undo it.
            if (m_pDdeObject->m_ulObjType == OT_LINK)
            {
                if (NOERROR != (hres=m_pDdeObject->UnAdviseOn (cf, ON_CHANGE)))
                {
		    intrDebugOut((DEB_IWARN,
				  "::DUnadvise(%x,dwConnection=%x) ON_CHANGE failed\n",
				  this,
				  dwConnection));
                }
                if (NOERROR != (hres=m_pDdeObject->UnAdviseOn (cf, ON_SAVE)))
                {
		    intrDebugOut((DEB_IWARN,
				  "::DUnadvise(%x,dwConnection=%x) ON_SAVE failed\n",
				  this,
				  dwConnection));
                }
            }
            else
            {
                if (NOERROR != (hres=m_pDdeObject->UnAdviseOn (cf, ON_SAVE)))
                {
		    intrDebugOut((DEB_IWARN,
				  "::DUnadvise(%x,dwConnection=%x) ON_SAVE failed\n",
				  this,
				  dwConnection));
                }
                if (NOERROR != (hres=m_pDdeObject->UnAdviseOn (cf, ON_CLOSE)))
                {
		    intrDebugOut((DEB_IWARN,
				  "::DUnadvise(%x,dwConnection=%x) ON_CLOSE failed\n",
				  this,
				  dwConnection));
                }
            }
        }
    }

    // Delegate rest of the work to the DataAdviseHolder
    RetZS (m_pDdeObject->m_pDataAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pDataAdvHolder->Unadvise (dwConnection);
}

STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::EnumDAdvise
    (THIS_ LPENUMSTATDATA FAR* ppenumAdvise)
{
    RetZS (m_pDdeObject->m_pDataAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pDataAdvHolder->EnumAdvise(ppenumAdvise);
}

STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::EnumFormatEtc
    (DWORD dwDirection, LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    return OleRegEnumFormatEtc (m_pDdeObject->m_clsid, dwDirection,
                                ppenumFormatEtc);
}




STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::GetCanonicalFormatEtc
(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    VDATEPTROUT (pformatetcOut, FORMATETC);
    memcpy (pformatetcOut, pformatetc, sizeof (FORMATETC));
    return ReportResult(0, DATA_S_SAMEFORMATETC, 0, 0);
    // We must be very conservative and assume data will be different for
    // every formatetc
}



INTERNAL CDdeObject::RequestData
    (CLIPFORMAT cf)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::RequestData(%x,cf=%x)\n",
		  this,cf));

    LPARAM lparam;
    RetZ (m_pDocChannel);
    intrAssert(wIsValidAtom(m_aItem));
    ATOM aItem = wDupAtom (m_aItem);
    intrAssert(wIsValidAtom(aItem));

    lparam = MAKE_DDE_LPARAM (WM_DDE_REQUEST,cf, aItem);

    HRESULT hr = SendMsgAndWaitForReply (m_pDocChannel,
					 AA_REQUEST,
					 WM_DDE_REQUEST,
					 lparam,
					 TRUE);
    if ( aItem && FAILED(hr) )
    {
	GlobalDeleteAtom (aItem);
    }
    return hr;
}


// special name
const char achSpecialName[] = "DISPLAY";

//
// Return a 1.0 target device for the screen
//

static INTERNAL DefaultTargetDevice (HANDLE FAR* ph)
{
    intrDebugOut((DEB_ITRACE,
		  "DefaultTargetDevice(ph=%x)\n",ph));

    VDATEPTROUT ((LPVOID) ph, HANDLE);
    LPOLETARGETDEVICE p1=NULL;
    *ph = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, sizeof (*p1) + 10);
    RetZS (*ph, E_OUTOFMEMORY);
    p1 = (LPOLETARGETDEVICE) GlobalLock (*ph);
    RetZS (p1, E_OUTOFMEMORY);
    p1->otdDeviceNameOffset = 8;
    p1->otdDriverNameOffset = 0;	// The driver name is at otdData
    p1->otdPortNameOffset   = 9;
    p1->otdExtDevmodeOffset = 0;
    p1->otdExtDevmodeSize   = 0;
    p1->otdEnvironmentOffset= 0;
    p1->otdEnvironmentSize  = 0;

    //
    // Note that memcpy is moving a constant string. Therefore, sizeof()
    // will include the NULL terminator
    //
    //
    memcpy((LPSTR)p1->otdData, achSpecialName,sizeof(achSpecialName));
    p1->otdData[8] = 0;			// NULL the otdDeviceName
    p1->otdData[9] = 0;			// NULL the PortNameOffset
    GlobalUnlock (*ph);
    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Function:   Convert20TargetDevice
//
//  Synopsis:   Converts a 2.0 TargetDevice into a 1.0 OLETARGETDEVICE
//
//  Effects:	First converts the 2.0 UNICODE target device into ANSI,
//		then converts that into a 1.0 OLETARGETDEVICE. The astute
//		reader would say: Why not just 2.0 UNICODE to OLETARGETDEVICE?
//
//		Two reasons: time before we ship vs time needed elsewhere.
//
//		If you can spare some time, please change this to go
//		directly from one to the other.
//
//  Arguments:  [ptd] --
//		[phTD1] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-03-94   kevinro   Created
//
//  Notes:
//
//  the NT version of the OLE 1.0 used UINT as the size of the
//  structures members. This was baaaad, since we really need them to be
//  a fixed size. I am currently in the works of changing the NT 1.0 header
//  file to reflect what we really need it to be, which is USHORT's
//
//
// We have a DVTARGETDEVICE, but we want a OLETARGETDEVICE, which looks like
//
// typedef struct _OLETARGETDEVICE {
//    USHORT otdDeviceNameOffset;
//    USHORT otdDriverNameOffset;
//    USHORT otdPortNameOffset;
//    USHORT otdExtDevmodeOffset;
//    USHORT otdExtDevmodeSize;
//    USHORT otdEnvironmentOffset;
//    USHORT otdEnvironmentSize;
//    BYTE otdData[1];
// } OLETARGETDEVICE;
//
// A couple things to note:
//
// 1) The Names in the OLETARGETDEVICE need to be Ansi
// 2) The Environment member doens't exist in the DVTARGETDEVICE, and will
//    be created in this conversion
// 3) The ExtDevmode also needs to be ANSI
//
//----------------------------------------------------------------------------
INTERNAL Convert20TargetDevice
    (const DVTARGETDEVICE FAR* ptd,     // in parm
    HANDLE FAR* phTD1)                  // out parm
{
    const size_t cbHeader = SIZEOF_DVTARGETDEVICE_HEADER;
    HRESULT hr;
    LPOLETARGETDEVICE ptd1 = NULL;
    size_t cbTD1;
    size_t cbDevmode;
    size_t cbOffset;
    LPDEVMODEA pdevmode;

    intrDebugOut((DEB_ITRACE,
		  "Convert20TargetDevice(ptd=%x)\n",ptd));

    VDATEPTROUT ((LPVOID) phTD1, HANDLE);
    *phTD1 = NULL;

    //
    // If no device specified, then return the default
    //

    if (NULL==ptd)
    {
        return DefaultTargetDevice (phTD1);
    }

    //
    // Compute information for doing conversion using routines in utils.cpp
    // The following structure will get the sizes
    //

    DVTDINFO dvtdInfo;

    hr = UtGetDvtd32Info(ptd,&dvtdInfo);

    if (hr != NOERROR)
    {
        return DV_E_DVTARGETDEVICE;
    }

    //
    // The conversion routines require us to allocate memory to pass in.
    //

    DVTARGETDEVICE *pdvtdAnsi = (DVTARGETDEVICE *) PrivMemAlloc(dvtdInfo.cbConvertSize);

    if (pdvtdAnsi == NULL)
    {
	return(E_OUTOFMEMORY);
    }

    //
    // Convert the UNICODE target device into an ANSI target device
    //

    hr = UtConvertDvtd32toDvtd16(ptd,&dvtdInfo,pdvtdAnsi);

    if (hr != NOERROR)
    {
	goto errRtn;
    }

    //
    // pdvtdAnsi now holds an ANSI version of the DVTARGETDEVICE. Turns
    // out the structure we really want is the DVTARGETDEVICE, plus a
    // couple of extra header bytes. Therefore, we can just do a block
    // copy of the DVTARGETDEVICE's data, and fix up our OLETARGETDEVICE
    // header to have the correct offsets in the data.
    //
    // offset of data block from beginning of 2.0 target device
    //
    cbOffset = offsetof (DVTARGETDEVICE, tdData);

    //
    // Calculate a pointer to the DEVMODEA
    //
    pdevmode = pdvtdAnsi->tdExtDevmodeOffset ?
                    (LPDEVMODEA)((LPBYTE)pdvtdAnsi + pdvtdAnsi->tdExtDevmodeOffset)
                    : NULL;

    //
    // Quick sanity check on the resulting pointer.
    //
    if (pdevmode && !IsValidReadPtrIn (pdevmode, sizeof(DEVMODEA)))
    {
	hr = DV_E_DVTARGETDEVICE;
	goto errRtn;
    }

    //
    // Calculate the size of the devmode part.
    //

    cbDevmode = (pdevmode ? pdevmode->dmSize + pdevmode->dmDriverExtra:0);

    //
    // Calculate the total size needed. The DVTARGETDEVICE header has 12 bytes,
    // and the OLETARGETDEVICE has 14 bytes. We also need to make an extra copy
    // of the cbDevmode structure to fill in the environment. Therefore, there is
    // an extra cbDevmode, and a sizeof(USHORT) added to the size. The size includes
    // the size of the DVTARGETHEADER
    //

    cbTD1 = (size_t) pdvtdAnsi->tdSize +
		     cbDevmode +	  // For extra Environment data
		     sizeof (USHORT); // for Environment Size field

    *phTD1 = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, cbTD1);
    if (NULL== *phTD1)
    {
        intrAssert (!"GlobalAlloc Failed");
	hr = E_OUTOFMEMORY;
	goto errRtn;
    }

    ptd1 = (LPOLETARGETDEVICE) GlobalLock (*phTD1);
    if (NULL== ptd1)
    {
        intrAssert (!"GlobalLock Failed");
	hr = E_OUTOFMEMORY;
	goto errRtn;
    }

    // Set x1 (1.0 offset) based on x2 (2.0 offset)
    //
    // Note that the OLETARGETDEVICE offsets are relative to the array of bytes,
    // where the DVTARGETDEVICE is relative to the start of the structure. Thats
    // why cbOffset is subtracted
    //

    #define ConvertOffset(x1, x2) (x1 = (x2 ? x2 - cbOffset : 0))

    //
    // Using the above macro, and assuming
    //

    ConvertOffset (ptd1->otdDeviceNameOffset, pdvtdAnsi->tdDeviceNameOffset);
    ConvertOffset (ptd1->otdDriverNameOffset, pdvtdAnsi->tdDriverNameOffset);
    ConvertOffset (ptd1->otdPortNameOffset  , pdvtdAnsi->tdPortNameOffset  );
    ConvertOffset (ptd1->otdExtDevmodeOffset, pdvtdAnsi->tdExtDevmodeOffset);
    ptd1->otdExtDevmodeSize = (USHORT) cbDevmode;

    //
    // I found this in the OLE 2 information on OLETARGETDEVICE:
    //
    // The otdDeviceNameOffset, otdDriverNameOffset, and otdPortNameOffset
    // members should be null-terminated.  In Windows 3.1, the ability to
    // connect multiple printers to one port has made the environment
    // obsolete.  The environment information retrieved by the
    // GetEnvironment function can occasionally be incorrect.  To ensure that the
    // OLETARGETDEVICE structure is initialized correctly, the application
    // should copy information from the DEVMODEA structure retrieved by a
    // call to the ExtDeviceMode function to the environment position of
    // the OLETARGETDEVICE structure.
    //
    //

    //
    // Adjust the environment offset to the end of the converted structure, and
    // set the size. the sizeof(USHORT) accounts for the addition of the
    // otdEnvironmentSize field. The offsetof accounts for the fact that the
    // OLETARGETDEVICE offsets are based from the otdData array.
    //
    ptd1->otdEnvironmentOffset = (USHORT) pdvtdAnsi->tdSize +
					  sizeof(USHORT) -
					  offsetof(OLETARGETDEVICE,otdData);

    ptd1->otdEnvironmentSize  = (USHORT) cbDevmode;

    // Copy data block
    if(!IsValidPtrOut (ptd1->otdData,  (size_t) pdvtdAnsi->tdSize - cbHeader))
    {
	hr = E_UNEXPECTED;
	goto errRtn;
    }
    memcpy (ptd1->otdData, pdvtdAnsi->tdData, (size_t) pdvtdAnsi->tdSize - cbHeader);

    if (cbDevmode != 0)
    {
        if(!IsValidPtrOut (ptd1->otdData, sizeof (DEVMODEA)))
	{
	    hr = E_UNEXPECTED;
	    goto errRtn;
	}

        // Copy 2.0 Devmode into 1.0 environment

        memcpy (ptd1->otdData + ptd1->otdEnvironmentOffset,
		pdvtdAnsi->tdData   + pdvtdAnsi->tdExtDevmodeOffset,
		cbDevmode);
    }

    hr = NOERROR;

errRtn:

    if (ptd1 != NULL)
    {
        GlobalUnlock(*phTD1);
    }

    if (pdvtdAnsi != NULL)
    {
	PrivMemFree(pdvtdAnsi);
    }
    intrDebugOut((DEB_ITRACE,
		  "Convert20TargetDevice(ptd=%x) returns %x\n",ptd,hr));
    return(hr);
}



static INTERNAL CopyTargetDevice
    (const DVTARGETDEVICE FAR* ptd,
    DVTARGETDEVICE FAR* FAR* pptd)
{
    intrDebugOut((DEB_ITRACE,
		  "CopyTargetDevice(ptd=%x)\n",ptd));

    if (*pptd)
    {
        delete *pptd; // delete old target device
    }
    if (NULL==ptd)
    {
        *pptd = NULL;
    }
    else
    {
        *pptd = (DVTARGETDEVICE FAR*) operator new ((size_t) (ptd->tdSize));
        if (NULL==*pptd)
        {
            return ReportResult(0, E_OUTOFMEMORY, 0, 0);
        }
        _fmemcpy (*pptd, ptd, (size_t) ptd->tdSize);
    }
    return NOERROR;
}



INTERNAL CDdeObject::SetTargetDevice
    (const DVTARGETDEVICE FAR* ptd)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::SetTargetDevice(%x,ptd=%x)\n",
		  this,
		  ptd));

    HANDLE hTD1 = NULL;
    HANDLE hDdePoke=NULL;

    RetErr (Convert20TargetDevice (ptd, &hTD1));

    Assert (hTD1);
    Verify (hDdePoke = wPreparePokeBlock (hTD1, g_cfBinary, m_aClass, m_bOldSvr));
    if (hTD1)
    {
        GlobalFree (hTD1);
    }
    // Poke new target device to 1.0 server
    aStdTargetDevice = GlobalAddAtom (L"StdTargetDevice");
    intrAssert(wIsValidAtom(aStdTargetDevice));
    RetErr (Poke (aStdTargetDevice, hDdePoke));

    // Remember current target device
    RetErr (CopyTargetDevice (ptd, &m_ptd));
    // Flush the cache because it contains a picture for the wrong
    // target device.
    if (m_hPict)
        wFreeData (m_hPict, m_cfPict);
    m_cfPict = (CLIPFORMAT)0;
    m_hPict = NULL;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddeioc.cxx ===
/*

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeLink.cpp

Abstract:

    This module contains the DdeObject::OleItemContainer methods
    and other Link-related code

Author:

    Jason Fuller    (jasonful)  19-October-1992

*/

#include "ddeproxy.h"
// #include <limits.h>
// #include <utils.h>
// #include <moniker.h>


ASSERTDATA



STDUNKIMPL_FORDERIVED (DdeObject, OleItemContainerImpl)


static INTERNAL_(void) wSkipDelimiter
    (LPOLESTR * psz)
{
    if (wcschr (L"!\"'*+,./:;<=>?@[\\]`|" , **psz))
        (*psz)++;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::ParseDisplayName
    (LPBC pbc,
    LPOLESTR lpszDisplayName,
    ULONG * pchEaten,
    LPMONIKER * ppmkOut)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::ParseDisplayName(%x,lpsz=%ws)\n",
		  this,
		  lpszDisplayName));

    LPUNKNOWN pUnk = NULL;
    VDATEPTROUT(ppmkOut,LPMONIKER);
    *ppmkOut = NULL;
    VDATEIFACE(pbc);
    VDATEPTRIN(lpszDisplayName, char);
    VDATEPTROUT(pchEaten,ULONG);

    *pchEaten = lstrlenW(lpszDisplayName);
    wSkipDelimiter (&lpszDisplayName);
    // Validate the item name
    RetErr (GetObject (lpszDisplayName, BINDSPEED_INDEFINITE, pbc,
                        IID_IUnknown, (LPLPVOID) &pUnk));
    if (pUnk)
        pUnk->Release();
    return CreateItemMoniker (L"!", lpszDisplayName, ppmkOut);
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::EnumObjects
    (DWORD grfFlags,
     LPENUMUNKNOWN FAR* ppenumUnk)

{
    // OLE 1.0 provides no way to enumerate all the items in a document.
    // This method is unlikely to be called since our implementation of
    // file and item monikers does not call it.
    Puts ("OleItemContainer::EnumObjects\r\n");
    if (ppenumUnk)
    {
        *ppenumUnk = NULL;
        return E_NOTIMPL;
    }

    return E_INVALIDARG;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::LockContainer
    (BOOL fLock)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::LockContainer(%x,fLock=%x)\n",
		  this,
		  fLock));

    return NOERROR;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::GetObject
    (LPOLESTR lpszItem,
    DWORD  dwSpeedNeeded,
    LPBINDCTX pbc,
    REFIID riid,
    LPVOID * ppvObject)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetObject(%x,szItem=%ws)\n",
		  this,
		  lpszItem));


    HRESULT hresult = NOERROR;
    VDATEPTROUT (ppvObject, LPVOID);
    *ppvObject=NULL;
    LPUNKNOWN pUnk = NULL;       //  These refer to the
    CDdeObject FAR* pdde = NULL; //  same object

    RetZS (pUnk =CDdeObject::Create (NULL,m_pDdeObject->m_clsid,OT_LINK,
                     m_pDdeObject->m_aTopic,lpszItem,&pdde),
                     E_OUTOFMEMORY);

    // For handling invisible updates--propagate information from document
    // to item.
    pdde->DeclareVisibility (m_pDdeObject->m_fVisible);
    pdde->m_fDidLaunchApp = m_pDdeObject->m_fDidLaunchApp;
    pdde->m_fDidStdOpenDoc   = m_pDdeObject->m_fDidStdOpenDoc;

    intrAssert(wIsValidAtom(pdde->m_aItem));
    LPOLESTR pszAtomName = wAtomName(pdde->m_aItem);

    ErrZ (pszAtomName && 0==lstrcmpW(lpszItem, pszAtomName));

    // OPTIMIZATION: Could use a mini Running Object Table to map lpszItem to
    // LPUNKNOWN and avoiding the Connect() and DDE_REQUEST.

    // Open a DocChannel
    ErrRtnH (pdde->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL));

    // Request Native data in order to see if the item name is valid
    Assert (pdde->m_pDocChannel);
    LPARAM lp;
    lp=MAKE_DDE_LPARAM (WM_DDE_REQUEST,g_cfNative, wDupAtom(pdde->m_aItem));
    hresult = pdde->SendMsgAndWaitForReply (pdde->m_pDocChannel,
    					    AA_REQUESTAVAILABLE,
			                    WM_DDE_REQUEST,
                       			    lp,
                       			    TRUE);
    if ( FAILED( hresult ) )
    {
        // Try metafile.  Excel can't render large metafiles
        // but it can render native.
        lp=MAKE_DDE_LPARAM (WM_DDE_REQUEST,CF_METAFILEPICT, wDupAtom(pdde->m_aItem));
        hresult = pdde->SendMsgAndWaitForReply (pdde->m_pDocChannel,
						AA_REQUESTAVAILABLE,
                                    		WM_DDE_REQUEST,
                                    		lp,
                                    		TRUE);
        if ( FAILED( hresult ) )
        {
            Assert (pdde->m_refs==1);
            hresult = ResultFromScode (MK_E_NOOBJECT);
            goto errRtn;
        }
    }

    // Item name is valid
    hresult = pdde->m_pUnkOuter->QueryInterface (riid, (LPLPVOID) ppvObject);
    if (NOERROR==hresult)
    {
        m_pDdeObject->m_fDidGetObject = TRUE;
    }
  errRtn:
    if (pUnk)
        pUnk->Release();
    return hresult;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::GetObjectStorage
    (LPOLESTR lpszItem,
    LPBINDCTX ptc,
    REFIID riid,
    LPVOID * ppvStorage)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetObjectStorage(%x,szItem=%ws)\n",
		  this,
		  lpszItem));
    return MK_E_NOSTORAGE;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::IsRunning
    (LPOLESTR szItem)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::IsRunning(%x,szItem=%ws)\n",
		  this,
		  szItem));

    // By definition, all items are running
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddeproxy.h ===
// ddeproxy.h
//
//   Used by ddeproxy.cpp ddeDO.cpp ddeOO.cpp
//
//   Author:  Jason Fuller    jasonful        24-July-1992
//
//   Modified:
//   Brian Chapman  bchapman    Nov 1995
//      - Removed declarations of wAllocDdeChannel() and wGetRequestResponse()
//       because they were not used or even defined anywhere.
//      - Fixed the indention of the declarations of the "worker" routines
//       section.
//   RichN                      Aug 1996
//      - Added Send and Receive to CRpcChannelBuffer implementation
//
#ifndef fDdeProxy_h
#define fDdeProxy_h

//
// One of the oleint.h routines redefines GlobalAlloc and friends
// to perform some memory tracking functions.
//
// This doesn't work in these files, since the tracking functions
// add tail checking, and size to the data structures. GlobalSize
// is a common function to use to determine how much data to
// serialize, plus it turns out that the other side of a DDE
// connection will often be the caller to free the memory.
//
// Therefore, OLE_DDE_NO_GLOBAL_TRACKING is used to disable this in the
// global header file ih\memapi.hxx. Check to insure this
// flag is set on the compile line
//
#if !defined(OLE_DDE_NO_GLOBAL_TRACKING)
error OLE_DDE_OLE_DDE_NO_GLOBAL_TRACKING must be defined to build this directory
#endif


#include <ole2int.h>
#include <callctrl.hxx>
#include <ddeint.h>
#include <dde.h>
#include <olerem.h>
#include <ole1cls.h>
#include <limits.h>
// For fDdeCodeInOle2Dll flag
#include <ddeatoms.h>
#include <ddepack.h>
#include <ddedebug.h>

#ifdef OLE_DEBUG_EXT
#include <ntsdexts.h>
#endif OLE_DEBUG_EXT

#include "ddechc.hxx"
#define LPCALLINFO LPVOID
#include "ddeerr.h"
#include "cnct_tbl.h"

#define MAX_STR         256

// number of .01 mm per inch
#define HIMETRIC_PER_INCH 2540

//#define fDebugOutput

// callback notifications
#define ON_CHANGE       0
#define ON_SAVE         1
#define ON_CLOSE        2
#define ON_RENAME       3

// AwaitAck values
#define AA_NONE         0
#define AA_REQUEST      1
#define AA_ADVISE       2
#define AA_POKE         3
#define AA_EXECUTE      4
#define AA_UNADVISE     5
#define AA_INITIATE     6
#define AA_TERMINATE 7
// A DDE_REQUEST to see if a format is available, not to keep the data.
#define AA_REQUESTAVAILABLE     8

// Bits for Positive WM_DDE_ACK
//#define POSITIVE_ACK 0x8000
//#define NEGATIVE_ACK 0x0000

#define DDE_CHANNEL_DELETED     0xffffffff

typedef DWORD CHK;
const DWORD     chkDdeObj = 0xab01;  // magic cookie


class DDE_CHANNEL : public CPrivAlloc, public IInternalChannelBuffer
{
public:
       // *** IUnknown methods ***
       STDMETHOD(QueryInterface) ( REFIID riid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();

        // Provided IRpcChannelBuffer methods (for server side)
        STDMETHOD(GetBuffer)(
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid);

        STDMETHOD(SendReceive)(
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus);

        STDMETHOD(FreeBuffer)(
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage);

        STDMETHOD(GetDestCtx)(
            /* [out] */ DWORD __RPC_FAR *pdwDestContext,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext);

        STDMETHOD(IsConnected)( void);
        STDMETHOD(GetProtocolVersion)( DWORD *pdwVersion );

        // Provided IRpcChannelBuffer2 methods (not implemented)
        STDMETHODIMP Send(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }
        STDMETHODIMP Receive(RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }

        // Provided IRpcChannelBuffer3 methods (for client side)
        STDMETHOD(SendReceive2)(
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus);

        STDMETHOD(ContextInvoke)(
            /* [out][in] */ RPCOLEMESSAGE *pMessage,
            /* [in] */ IRpcStubBuffer *pStub,
            /* [in] */ IPIDEntry *pIPIDEntry,
            /* [out] */ DWORD *pdwFault);

        STDMETHOD(GetBuffer2)(
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid);
            
        // Provided IRpcChannelBuffer3 methods (not implemented)
        STDMETHODIMP Send2(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }
        STDMETHODIMP Receive2(RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }

        STDMETHODIMP Cancel        ( RPCOLEMESSAGE *pMsg )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetCallContext( RPCOLEMESSAGE *pMsg,
                                     REFIID riid,
                                     void **pInterface )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetDestCtxEx  ( RPCOLEMESSAGE *pMsg,
                                     DWORD *pdwDestContext,
                                     void **ppvDestContext )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetState      ( RPCOLEMESSAGE *pMsg,
                                     DWORD *pState )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP RegisterAsync ( RPCOLEMESSAGE *pMsg,
                                     IAsyncManager *pComplete )
                                                      { return E_NOTIMPL; }

        void SetCallState(SERVERCALLEX ServerCall, HRESULT hr = S_OK);

        // Provided IAsyncRpcChannelBuffer method (not implemented)
        STDMETHODIMP Send(RPCOLEMESSAGE *pMsg, ISynchronize*, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }
        STDMETHOD(Receive)  (RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }



    

       ULONG   AddReference()
       {
           return ++m_cRefs;
       }
       ULONG   ReleaseReference()
       {
           if (--m_cRefs == 0)
           {
               delete this;
               return(0);
           }
           return(m_cRefs);
       }

       ULONG    m_cRefs;
       HWND     hwndCli;
       HWND     hwndSvr;
       BOOL     bTerminating;
       int      iExtraTerms;
       WORD     wTimer;
       DWORD    dwStartTickCount;
       WORD     msgFirst;
       WORD     msgLast;
       HWND     msghwnd;        //
       BOOL     fRejected;      // because fBusy flag set in DDE_ACK
       WORD     wMsg;
       LPARAM   lParam;
       int      iAwaitAck;
       HRESULT  hres;
       HANDLE   hopt;           // Memory blocks I may have to free for DDE_ADVISE
       HANDLE   hDdePoke;       // for DDE_POKE
       HANDLE   hCommands;      // for DDE_EXECUTE
       WORD     wChannelDeleted;
       PDDECALLDATA  pCD;
       SERVERCALLEX      CallState;
       BOOL		bFreedhopt;
} ;


#define Channel_InModalloop 1
#define Channel_DeleteNow   2


typedef DDE_CHANNEL * LPDDE_CHANNEL;
extern BOOL               bWndClassesRegistered;

#define hinstSO g_hmodOLE2
extern HMODULE g_hmodOLE2;

extern INTERNAL_(BOOL) wRegisterClasses (void);

#ifndef _MAC
extern CLIPFORMAT g_cfNative;
extern CLIPFORMAT g_cfBinary;
#endif

#ifdef _CHICAGO_
//Note:POSTPPC
//
//  DelayDelete is used to delay deleting the CDdeObject
//  Guard will set it to DelayIt
//  UnGuard will reset it to NoDelay or delete the object
//  if state is ReadyToDelete
//
typedef enum
{
    NoDelay = 0,        // normal state
    DelayIt = 1,        // object is protected and deleting will be delayed
    ReadyToDelete = 2   // object was is DelayIt state and can be deleted
} DelayDelete;

#endif // _CHICAGO_

/*
 *     Definition of CDdeObject
 *
 */
class CMsgFilterInfo;
class  CDdeObject;

class CDdeObject : public CPrivAlloc
{
public:

       static INTERNAL_(LPUNKNOWN) Create (IUnknown * pUnkOuter,
                                    REFCLSID clsidClass,
                                    ULONG ulObjType = OT_EMBEDDED,
                                    ATOM aTopic = NULL,
                                    LPOLESTR szItem = NULL,
                                    CDdeObject * * ppdde = NULL,
                                    BOOL fAllowNullClsid = FALSE);

       INTERNAL_(void)  OnInitAck (LPDDE_CHANNEL pChannel, HWND hwndSvr);
       INTERNAL_(BOOL)  OnAck (LPDDE_CHANNEL pChannel, LPARAM lParam);
       INTERNAL_(void)  OnTimer (LPDDE_CHANNEL pChannel);
       INTERNAL                 OnData (LPDDE_CHANNEL pChannel, HANDLE hData,ATOM aItem);
       INTERNAL                 OnDataAvailable (LPDDE_CHANNEL pChannel, HANDLE hData,ATOM aItem);
       INTERNAL         OnTerminate (LPDDE_CHANNEL pChannel, HWND hwndPost);

       INTERNAL_(LPDDE_CHANNEL) GetSysChannel(void)
       { return m_pSysChannel; }

       INTERNAL_(LPDDE_CHANNEL) GetDocChannel(void)
       { return m_pDocChannel; }

       INTERNAL_(BOOL)  AllocDdeChannel(LPDDE_CHANNEL * lpChannel, BOOL fSysWndProc);
       INTERNAL_(BOOL)  InitSysConv (void);
       INTERNAL_(void)  SetTopic (ATOM aTopic);

       INTERNAL         SendOnDataChange (int iAdvOpt);
       INTERNAL         OleCallBack (int iAdvOpt,LPDDE_CHANNEL pChannel);
#ifdef _CHICAGO_
       //Note:POSTPPC
       INTERNAL_(void)  Guard()
       {
            intrDebugOut((DEB_IWARN ,"CDdeObject: %x DelayDelete is set to 'DelayIt'\n", this));
           _DelayDelete = DelayIt;
       }
       INTERNAL_(BOOL)  UnGuard()
       {
           if (_DelayDelete == ReadyToDelete)
           {
                intrDebugOut((DEB_IWARN ,"CDdeObject: %x DelayDelete it set 'ReadyToDelete'\n", this));
                delete this;
                intrDebugOut((DEB_IWARN ,"CDdeObject: %x was deleted\n", this));
                return TRUE;
           }
           else
           {
                intrDebugOut((DEB_IWARN ,"CDdeObject: %x DelayDelete set to 'NoDelay'\n", this));
                _DelayDelete = NoDelay;
           }

           return FALSE;
       }
#endif  // _CHICAGO_

       BOOL                     m_fDoingSendOnDataChange;
       ULONG                    m_cRefCount;

private:

                                CDdeObject (IUnknown * pUnkOuter);
                                ~CDdeObject (void);
       INTERNAL                 TermConv (LPDDE_CHANNEL pChannel,
                                          BOOL fWait=TRUE);
       INTERNAL_(void)          DeleteChannel (LPDDE_CHANNEL pChannel);
       INTERNAL_(BOOL)          LaunchApp (void);
       INTERNAL                         MaybeUnlaunchApp (void);
       INTERNAL                         UnlaunchApp (void);
       INTERNAL                 Execute (LPDDE_CHANNEL pChannel,
                                         HANDLE hdata,
                                         BOOL fStdCloseDoc=FALSE,
                                         BOOL fWait=TRUE,
                                         BOOL fDetectTerminate = TRUE);
       INTERNAL                 Advise (void);
       INTERNAL                 AdviseOn (CLIPFORMAT cfFormat,
                                          int iAdvOn);
       INTERNAL                 UnAdviseOn (CLIPFORMAT cfFormat,
                                            int iAdvOn);
       INTERNAL                 Poke (ATOM aItem, HANDLE hDdePoke);
       INTERNAL                 PostSysCommand (LPDDE_CHANNEL pChannel,
                                                LPCSTR szCmd,
                                                BOOL bStdNew=FALSE,
                                                BOOL fWait=TRUE);

       INTERNAL                SendMsgAndWaitForReply (LPDDE_CHANNEL pChannel,
                                              int iAwaitAck,
                                              WORD wMsg,
                                              LPARAM lparam,
                                              BOOL fFreeOnError,
                                              BOOL fStdCloseDoc = FALSE,
                                              BOOL fDetectTerminate = TRUE,
                                              BOOL fWait = TRUE);
       INTERNAL                 KeepData (LPDDE_CHANNEL pChannel, HANDLE hDdeData);
       INTERNAL                 ChangeTopic (LPSTR lpszTopic);
       INTERNAL_(void)          ChangeItem (LPSTR lpszItem);
       INTERNAL                 IsFormatAvailable (LPFORMATETC);
       INTERNAL_(BOOL)          CanCallBack(LPINT);
       INTERNAL                 RequestData (CLIPFORMAT);
       INTERNAL                 SetTargetDevice (const DVTARGETDEVICE *);
       INTERNAL                 DocumentLevelConnect (LPBINDCTX pbc);
       INTERNAL                 SendOnClose (void);
       INTERNAL                 UpdateAdviseCounts (CLIPFORMAT cf,
                                                    int iAdvOn,
                                                    signed int cDelta);
       INTERNAL                 DeclareVisibility (BOOL fVisible,
                                                   BOOL fCallOnShowIfNec=TRUE);
       INTERNAL                 Save (LPSTORAGE);
       INTERNAL                 Update (BOOL fRequirePresentation);

implementations:

       STDUNKDECL(CDdeObject,DdeObject)
       STDDEBDECL(CDdeObject,DdeObject)


    implement COleObjectImpl : IOleObject
    {
    public:
       COleObjectImpl (CDdeObject * pDdeObject)
        { m_pDdeObject = pDdeObject; }

       // *** IUnknown methods ***
       STDMETHOD(QueryInterface) ( REFIID riid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();

       // *** IOleObject methods ***
       STDMETHOD(SetClientSite) ( LPOLECLIENTSITE pClientSite);
       STDMETHOD(GetClientSite) ( LPOLECLIENTSITE * ppClientSite);
       STDMETHOD(SetHostNames) ( LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
       STDMETHOD(Close) ( DWORD reserved);
       STDMETHOD(SetMoniker) ( DWORD dwWhichMoniker, LPMONIKER pmk);
       STDMETHOD(GetMoniker) ( DWORD dwAssign, DWORD dwWhichMoniker,LPMONIKER * ppmk);
       STDMETHOD(InitFromData) ( LPDATAOBJECT pDataObject,BOOL fCreation,DWORD dwReserved);
       STDMETHOD(GetClipboardData) ( DWORD dwReserved,LPDATAOBJECT * ppDataObject);

       STDMETHOD(DoVerb) ( LONG iVerb,
                    LPMSG lpmsg,
                    LPOLECLIENTSITE pActiveSite,
                    LONG lindex,
                    HWND hwndParent,
                    const RECT * lprcPosRect);

       STDMETHOD(EnumVerbs) ( IEnumOLEVERB * * ppenumOleVerb);
       STDMETHOD(Update) ();
       STDMETHOD(IsUpToDate) ();
       STDMETHOD(GetUserClassID) ( CLSID * pClsid);
       STDMETHOD(GetUserType) ( DWORD dwFormOfType, LPOLESTR * pszUserType);
       STDMETHOD(SetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
       STDMETHOD(GetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
       STDMETHOD(Advise)( IAdviseSink * pAdvSink, DWORD * pdwConnection) ;
       STDMETHOD(Unadvise) ( DWORD dwConnection);
       STDMETHOD(EnumAdvise) ( LPENUMSTATDATA * ppenumAdvise);
       STDMETHOD(GetMiscStatus) ( DWORD dwAspect, DWORD * pdwStatus);
       STDMETHOD(SetColorScheme) ( LPLOGPALETTE lpLogpal);

    private:
       CDdeObject * m_pDdeObject;
    };


    implement CDataObjectImpl :  IDataObject
    {
    public:
       CDataObjectImpl (CDdeObject * pDdeObject)
        { m_pDdeObject = pDdeObject; }
       // *** IUnknown methods ***
       STDMETHOD(QueryInterface) ( REFIID riid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) () ;
       STDMETHOD_(ULONG,Release) ();

       STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,LPSTGMEDIUM pmedium );
       STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,LPSTGMEDIUM pmedium );
       STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
       STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,LPFORMATETC pformatetcOut);
       STDMETHOD(SetData) ( LPFORMATETC pformatetc, STGMEDIUM * pmedium, BOOL fRelease);
       STDMETHOD(EnumFormatEtc) ( DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc);
       STDMETHOD(DAdvise) ( FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD * pdwConnection) ;
       STDMETHOD(DUnadvise) ( DWORD dwConnection) ;
       STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA * ppenumAdvise) ;

    private:
       CDdeObject * m_pDdeObject;
    };


   implement CPersistStgImpl : IPersistStorage
   {
   public:
        CPersistStgImpl (CDdeObject * pDdeObject)
        { m_pDdeObject  = pDdeObject; }

       STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();
       STDMETHOD(GetClassID) ( LPCLSID pClassID);
       STDMETHOD(IsDirty) (void);
       STDMETHOD(InitNew) ( LPSTORAGE pstg);
       STDMETHOD(Load) ( LPSTORAGE pstg);
       STDMETHOD(Save) ( LPSTORAGE pstgSave, BOOL fSameAsLoad);
       STDMETHOD(SaveCompleted) ( LPSTORAGE pstgNew);
       STDMETHOD(HandsOffStorage) (void);

    private:
       CDdeObject * m_pDdeObject;
    };


   implement CProxyManagerImpl : IProxyManager
   {
   public:
       CProxyManagerImpl (CDdeObject * pDdeObject)
        { m_pDdeObject  = pDdeObject; }

       STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();

       STDMETHOD(CreateServer)(REFCLSID rclsid, DWORD clsctx, void *pv);
       STDMETHOD_(BOOL, IsConnected)(void);
       STDMETHOD(LockConnection)(BOOL fLock, BOOL fLastUnlockReleases);
       STDMETHOD_(void, Disconnect)();

#ifdef SERVER_HANDLER
       STDMETHOD(CreateServerWithEmbHandler)(REFCLSID rclsid, DWORD clsctx, 
                                             REFIID riidEmbedSrvHandler, 
                                             void **ppEmbedSrvHandler, void *pv);
#endif // SERVER_HANDLER

       STDMETHOD(GetConnectionStatus)(void)               { return(S_OK); }
       STDMETHOD_(void,SetMapping)(void *pv)              { return; }
       STDMETHOD_(void *,GetMapping)()                    { return(NULL); }
       STDMETHOD_(IObjContext *,GetServerObjectContext)() { return(NULL); }

       STDMETHOD(Connect)(GUID oid, REFCLSID rclsid);
       STDMETHOD(EstablishIID)(REFIID iid, LPVOID FAR* ppv);

       private:
        CDdeObject * m_pDdeObject;
       };


   implement COleItemContainerImpl : IOleItemContainer
   {
   public:
       COleItemContainerImpl (CDdeObject * pDdeObject)
           { m_pDdeObject       = pDdeObject; }

        STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();

       //  IParseDisplayName method
       STDMETHOD(ParseDisplayName) ( LPBC pbc,
                              LPOLESTR lpszDisplayName,
                              ULONG * pchEaten,
                              LPMONIKER * ppmkOut) ;

       //  IOleContainer methods
       STDMETHOD(EnumObjects) ( DWORD grfFlags,LPENUMUNKNOWN * ppenumUnk);

       STDMETHOD(LockContainer) (BOOL fLock);

       //  IOleItemContainer methods
       STDMETHOD(GetObject) ( LPOLESTR lpszItem,
                       DWORD dwSpeedNeeded,
                       LPBINDCTX pbc,
                       REFIID riid,
                       LPVOID * ppvObject) ;
       STDMETHOD(GetObjectStorage) ( LPOLESTR lpszItem,
                              LPBINDCTX pbc,
                              REFIID riid,
                              LPVOID * ppvStorage) ;

       STDMETHOD(IsRunning) ( LPOLESTR lpszItem) ;

    private:
       CDdeObject * m_pDdeObject;
    };


   implement CRpcStubBufferImpl : public IRpcStubBuffer
   {
   public:
       CRpcStubBufferImpl (CDdeObject * pDdeObject)
           { m_pDdeObject       = pDdeObject; }

       STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();
       STDMETHOD(Connect)(
            /* [in] */ IUnknown *pUnkServer);

        STDMETHOD_(void,Disconnect)( void);

        STDMETHOD(Invoke)(
            /* [in] */ RPCOLEMESSAGE *_prpcmsg,
            /* [in] */ IRpcChannelBuffer *_pRpcChannelBuffer);

        STDMETHOD_(IRpcStubBuffer *,IsIIDSupported)(
            /* [in] */ REFIID riid);

       STDMETHOD_(ULONG,CountRefs)( void);

        STDMETHOD(DebugServerQueryInterface)(
            void * *ppv);

        STDMETHOD_(void,DebugServerRelease)(
            void  *pv);

    private:
       CDdeObject * m_pDdeObject;
    };

       DECLARE_NC(CDdeObject, COleObjectImpl)
       DECLARE_NC(CDdeObject, CDataObjectImpl)
       DECLARE_NC(CDdeObject, CPersistStgImpl)
       DECLARE_NC(CDdeObject, CProxyManagerImpl)
       DECLARE_NC(CDdeObject, COleItemContainerImpl)
       DECLARE_NC(CDdeObject, CRpcStubBufferImpl)

       COleObjectImpl           m_Ole;
       CDataObjectImpl          m_Data;
       CPersistStgImpl          m_PersistStg;
       CProxyManagerImpl        m_ProxyMgr;
       COleItemContainerImpl    m_OleItemContainer;
       CRpcStubBufferImpl       m_RpcStubBuffer;

shared_state:
       ULONG                            m_refs;
#ifdef _CHICAGO_
       //Note:POSTPPC
       DelayDelete                      _DelayDelete;
#endif // _CHICAGO_
       ULONG                            m_ulObjType;
       CLSID                            m_clsid;
       ATOM                             m_aClass;
       ATOM                             m_aExeName;
       ATOM                             m_aTopic;
       ATOM                             m_aItem;
       BOOL                             m_bRunning;
       IUnknown *               m_pUnkOuter;
       IOleClientSite * m_pOleClientSite;
       LPSTORAGE                m_pstg;
       BOOL                     m_bInitNew;
       BOOL                     m_bOldSvr;
       HANDLE                   m_hNative;
       HANDLE                   m_hPict;
       HANDLE                   m_hExtra;
       CLIPFORMAT               m_cfPict;
       CLIPFORMAT               m_cfExtra;

       BOOL                             m_fDidSendOnClose;
       BOOL                             m_fNoStdCloseDoc;
       BOOL                             m_fDidStdCloseDoc;
       BOOL                             m_fDidStdOpenDoc;
       BOOL                             m_fDidGetObject;
       BOOL                             m_fDidLaunchApp;
       BOOL                             m_fUpdateOnSave;
       BOOL                             m_fGotCloseData;

#ifdef OLE1INTEROP
   BOOL           m_fOle1interop;
#endif

       // Invisible update stuff
       ULONG                            m_cLocks;   // PM::LockConnection lock count (init 1)
       BOOL                             m_fVisible; // is server visible (as best we know)?
       BOOL                             m_fWasEverVisible;
       BOOL                             m_fCalledOnShow; // Did we call IOleClientSite::OnShow

       CHK                                      m_chk;
       DVTARGETDEVICE * m_ptd;

       // m_iAdvClose and m_iAdvSave are counts (1 or 2) of the number of formats
       // that have advise connections of a given type (Save or Close)
       int                                      m_iAdvClose;
       int                                      m_iAdvSave;
       int                                      m_iAdvChange;

       BOOL                             m_fDidAdvNative;

       // Extent info
#ifdef OLD
       long                             m_cxContentExtent;
       long                             m_cyContentExtent;
#endif

       // terminate info - only used to detect a premature WM_DDE_TERMINATE
       WORD m_wTerminate;

       IDataAdviseHolder *      m_pDataAdvHolder;
       IOleAdviseHolder  *      m_pOleAdvHolder;
       CDdeConnectionTable      m_ConnectionTable;


       // DDE window related stuff
       LPDDE_CHANNEL            m_pSysChannel;
       LPDDE_CHANNEL            m_pDocChannel;

       friend INTERNAL DdeBindToObject
        (LPCOLESTR  szFile,
        REFCLSID clsid,
        BOOL       fPackageLink,
        REFIID   iid,
        LPLPVOID ppv);

       friend INTERNAL DdeIsRunning
        (CLSID clsid,
        LPCOLESTR szFile,
        LPBC pbc,
        LPMONIKER pmkToLeft,
        LPMONIKER pmkNewlyRunning);
#ifdef OLE_DEBUG_EXT

#endif OLE_DEBUG_EXT
};
//
// Note: WM_DDE_TERMINATE
//  A state machine is used to delay the executing of a premature WM_DDE_TERMINTE
//     message, which is send by some apps instead of WM_DDE_ACK (or alike).
//  The code is in WaitForReply() and in OnTerminate()
typedef enum {
       Terminate_None      = 0, // default state - terminate code is executed
       Terminate_Detect    = 1, // window proc will NOT execute terminate code
       Terminate_Received  = 2  // wait loop does not need to run, execute terminate code now
} TERMINATE_DOCUMENT;



INTERNAL_(BOOL)   wPostMessageToServer(LPDDE_CHANNEL pChannel,
                                       WORD wMsg,
                                       LPARAM lParam,
                                       BOOL fFreeOnError);

INTERNAL_(ATOM)   wAtomFromCLSID(REFCLSID rclsid);
INTERNAL_(ATOM)   wGetExeNameAtom (REFCLSID rclsid);
INTERNAL_(BOOL)   wIsWindowValid (HWND hwnd);
INTERNAL_(void)   wFreeData (HANDLE hData, CLIPFORMAT cfFormat,
                             BOOL fFreeNonGdiHandle=TRUE);
INTERNAL_(BOOL)   wInitiate (LPDDE_CHANNEL pChannel, ATOM aLow, ATOM aHigh);
INTERNAL          wScanItemOptions (ATOM aItem, int * lpoptions);
INTERNAL_(BOOL)   wClearWaitState (LPDDE_CHANNEL pChannel);
INTERNAL_(HANDLE) wStdCloseDocumentHandle (void);
INTERNAL_(ATOM)   wExtendAtom (ATOM aIitem, int iAdvOn);
INTERNAL_(int)    wAtomLen (ATOM atom);
INTERNAL_(int)    wAtomLenA (ATOM atom);
INTERNAL_(HANDLE) wHandleFromDdeData(HANDLE hDdeData);
INTERNAL_(BOOL)   wIsOldServer (ATOM aClass);
INTERNAL_(LPSTR)  wAllocDdePokeBlock (DWORD dwSize,
                                      CLIPFORMAT cfFormat,
                                      LPHANDLE phDdePoke);
INTERNAL_(void)   wFreePokeData (LPDDE_CHANNEL pChannel, BOOL fMSDrawBug);
INTERNAL_(HANDLE) wPreparePokeBlock (HANDLE hData,
                                     CLIPFORMAT cfFormat,
                                     ATOM aClass,
                                     BOOL bOldSvr);
INTERNAL_(HANDLE) wNewHandle (LPSTR lpstr, DWORD cb);
INTERNAL          wDupData (LPHANDLE ph, HANDLE h, CLIPFORMAT cf);
INTERNAL          wHandleCopy (HANDLE hDst, HANDLE hSrc);
INTERNAL          wGetItemFromClipboard (ATOM * paItem);
INTERNAL          GetDefaultIcon (REFCLSID clsidIn,
                                  LPCOLESTR szFile,
                                  HANDLE * phmfp);
INTERNAL_(BOOL)   wTerminateIsComing (LPDDE_CHANNEL);
INTERNAL          wTimedGetMessage (LPMSG pmsg,
                                    HWND hwnd,
                                    WORD wFirst,
                                    WORD wLast);

INTERNAL_(ATOM)   wGlobalAddAtom(LPCOLESTR sz);
INTERNAL_(ATOM)   wGlobalAddAtomA(LPCSTR sz);

INTERNAL          wVerifyFormatEtc (LPFORMATETC pformatetc);
INTERNAL          wNormalize (LPFORMATETC pfetc, LPFORMATETC pfetcOut);
INTERNAL          wTransferHandle (LPHANDLE phDst,
                                   LPHANDLE phSrc,
                                   CLIPFORMAT cf);
INTERNAL          wClassesMatch (REFCLSID clsidIn, LPOLESTR szFile);

#if DBG == 1
INTERNAL_(BOOL)   wIsValidHandle (HANDLE h, CLIPFORMAT cf);
INTERNAL_(BOOL)   wIsValidAtom (ATOM a);
#endif

const char achStdCloseDocument[]="[StdCloseDocument]";
const char achStdOpenDocument[]="StdOpenDocument";
const char achStdExit[]="StdExit";
const char achStdNewDocument[]="StdNewDocument";
const char achStdEditDocument[]="StdEditDocument";

HWND CreateDdeClientHwnd(void);

//+---------------------------------------------------------------------------
//
//  Function:   TLSGetDdeClientWindow()
//
//  Synopsis:   Returns a pointer to the per thread DdeClient window. If one
//              has not been created, it will create it and return
//
//  Returns:    Pointer to the DdeClientWindow. This window is used for per
//              thread cleanup
//
//  History:    12-12-94   kevinro   Created
//----------------------------------------------------------------------------
inline void * TLSGetDdeClientWindow()
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        if (tls->hwndDdeClient == NULL)
        {
            tls->hwndDdeClient = CreateDdeClientHwnd();
        }
        return tls->hwndDdeClient;
    }

    return NULL;
}


#endif // ddeproxy.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddemnker.cxx ===
/*

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeLink.cpp

Abstract:

    This module implements:
    DdeBindToObject
    DdeIsRunning

Author:

    Jason Fuller    (jasonful)  19-October-1992

*/
#include "ddeproxy.h"


INTERNAL DdeBindToObject
    (LPCOLESTR  szFileIn,
    REFCLSID clsid,
    BOOL     fPackageLink,
    REFIID   iid,
    LPLPVOID ppv)
{
    intrDebugOut((DEB_ITRACE,
		  "DdeBindToObject szFileIn(%ws) fPackageLink(%x)\n",
		  szFileIn,
		  fPackageLink));


    LPUNKNOWN punk;
    *ppv = NULL;
    CDdeObject FAR* pdde=NULL;
    HRESULT hresult = E_UNEXPECTED;
    BOOL fSysConnection = FALSE;
    WCHAR wszTmpFile [MAX_STR+5];

    COleTls Tls;
    if( Tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
    {
        // If DDE use is disabled we shouldn't have gotten here.
        //
        Assert(!"Executing DdeBindToObject when DDE is disabled");
        hresult = CO_E_OLE1DDE_DISABLED;
        goto exitRtn;
    }

    //
    // This protocol doesn't handle the fact that there are two names for
    // every file. This is a bit of a problem. So, we are going to choose
    // the short name as the one to look for. This means that DDE objects
    // using the long filename will not work very well.
    //
    WCHAR szFile[MAX_PATH];
    szFile[0] = L'\0';
    if ((lstrlenW(szFileIn) == 0) || (GetShortPathName(szFileIn,szFile,MAX_PATH) == 0))
    {
	//
	// Unable to determine a short path for this object. Use whatever we were
	// handed.
	//
	intrDebugOut((DEB_ITRACE,"No conversion for short path. Copy szFileIn\n"));
	lstrcpyW(szFile,szFileIn);
    }
    intrDebugOut((DEB_ITRACE,"Short file szFile(%ws)\n",szFile));

    RetZS (punk=CDdeObject::Create (NULL,clsid,OT_LINK,wGlobalAddAtom(szFile),
                    NULL,&pdde),E_OUTOFMEMORY);
    RetZ (pdde);

    // Document already running?

    if (NOERROR != (hresult = pdde->DocumentLevelConnect (NULL) ))
    {
        if (GetScode (hresult) != S_FALSE)
	{
	    intrDebugOut((DEB_ITRACE,
			  "DdeBindToObject szFile(%ws) DLC returns %x \n",
			  szFile,hresult));
	    goto exitRtn;
	}


        // If not already running, try to make a sys level connection

        if (!pdde->m_pSysChannel) {
	    if (!pdde->AllocDdeChannel (&pdde->m_pSysChannel, TRUE))
            {
                intrAssert( !"Out of memory");
		hresult = E_OUTOFMEMORY;
		goto exitRtn;
            }
        }

        hresult = ReportResult (0, E_UNEXPECTED, 0, 0);

        if (fPackageLink) {
            lstrcpyW (wszTmpFile, szFile);
            lstrcatW (wszTmpFile, L"/Link");
            pdde->SetTopic (wGlobalAddAtom(wszTmpFile));
        }

        if (pdde->InitSysConv())
        {
            fSysConnection = TRUE;

            // Try to make the server open the document
            ErrRtnH (pdde->PostSysCommand (pdde->m_pSysChannel, (LPSTR)&achStdOpenDocument,FALSE));
            pdde->m_fDidStdOpenDoc = TRUE;

        }
        else
        {
            // launch the server
	    if (!pdde->LaunchApp())
	    {
		hresult = CO_E_APPNOTFOUND;
		goto errRtn;
	    }
        }

        if (fPackageLink)
            pdde->SetTopic (wGlobalAddAtom(szFile));

        // Connect to document
        hresult = pdde->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL);
        if (hresult != NOERROR)
        {
            // Excel does not register its document in time if it loads
            // startup macros.  So we force it to open the document.
            if (pdde->InitSysConv())
            {
                fSysConnection = TRUE;
                // Try to make the server open the document.
                ErrRtnH (pdde->PostSysCommand (pdde->m_pSysChannel,
				               (LPSTR)&achStdOpenDocument,
					       FALSE));
                pdde->m_fDidStdOpenDoc = TRUE;
            }
            else
            {
                ErrRtnH (ResultFromScode (CO_E_APPDIDNTREG));
            }
            // Try connecting to document again.  Should succeed.
            hresult = pdde->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL);
        }
    }
    else
    {
        // Already running, so assume visible
        pdde->DeclareVisibility (TRUE);
    }

errRtn:
    if (pdde->m_pSysChannel) {
        if (fSysConnection)
            pdde->TermConv (pdde->m_pSysChannel);
        else
            pdde->DeleteChannel (pdde->m_pSysChannel);
    }

    if (hresult == NOERROR) {
        hresult = punk->QueryInterface (iid, ppv);
    }
    pdde->m_pUnkOuter->Release();
    if (hresult!=NOERROR)
    {
        Warn ("DdeBindToObject failed");
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "DdeBindToObject szFile(%ws) returns %x \n",
		  szFile,hresult));

    return hresult;
}


//
// This won't work in a multi-threaded world. But this is not
// a danger to DDE since it is very single threaded.
//
static LPOLESTR szOriginalUNCName;
static WCHAR cOriginalDrive;

static INTERNAL InitializeIterator
    (LPCOLESTR wszFile)
{
    WCHAR wszDrive[] = L"A:\\";

    if ((wszFile == NULL) || (wszFile[1] != ':'))
    {
        return(S_FALSE);
    }

    wszDrive[0] = (WCHAR)CharUpperW((LPWSTR)wszFile[0]);

    if (GetDriveType(wszDrive) == DRIVE_REMOTE)
    {

        DWORD cb = MAX_STR;
        wszDrive[2] = '\0';
        if (NULL==szOriginalUNCName)
        {
        szOriginalUNCName = new WCHAR [MAX_STR];
        }


	if (WN_SUCCESS == OleWNetGetConnection (wszDrive, szOriginalUNCName, &cb))
        {
        cOriginalDrive = (WCHAR)CharUpperW((LPWSTR)wszFile[0]);
        return NOERROR;
        }
    }
    // szFile is not a network file
    return ReportResult (0, S_FALSE, 0, 0);
}



// NextEquivalentNetDrive
//
// Change the drive letter of szFile to the next (modulo 'Z') drive letter
// that is connected to the same net drive
// Return S_FALSE when there are no more equivalent drives
//
// NOTE NOTE NOTE
//
// This routine is playing fast and furious with the relationship between
// the first 128 Unicode characters and the ASCII character set.
//
static INTERNAL NextEquivalentNetDrive
    (LPOLESTR szFile)
{
    #define incr(c) (c=='Z' ? c='A' : ++c)
    WCHAR wszDrive[3]= L"A:";
    Assert (szFile && szFile[1]==':');

    char cDrive = (char)CharUpperA((LPSTR)szFile[0]);

    while (cOriginalDrive != incr(cDrive))
    {

        DWORD cb = MAX_PATH;
        WCHAR szUNCName [MAX_PATH];
        wszDrive[0] = cDrive;

        Assert (cDrive >= 'A' && cDrive <= 'Z');
        Assert (szOriginalUNCName);

	if(cDrive >= 'A' && cDrive <= 'Z' && szOriginalUNCName)
	{
		if (WN_SUCCESS == OleWNetGetConnection (wszDrive,szUNCName, &cb) &&
        	(0 == lstrcmpW (szUNCName, szOriginalUNCName)))
	        {
        	    szFile[0] = cDrive;
	            return NOERROR;
	        }
	}
    }
    // We've gone through all the drives
    return ReportResult (0, S_FALSE, 0, 0);
}



// Dde_IsRunning
//
// Attempt to open a document-level conversation using the
// filename as a topic.  If the conversation is established we
// know the file is running and terminate the conversation.
// Otherwise it is not running.
//
INTERNAL DdeIsRunning
    (CLSID clsid,
    LPCOLESTR szFileIn,
    LPBC pbc,
    LPMONIKER pmkToLeft,
    LPMONIKER pmkNewlyRunning)
{
    intrDebugOut((DEB_ITRACE,
		  "DdeIsRunning szFileIn(%ws)\n",szFileIn));

    ATOM aTopic;
    CDdeObject FAR* pdde=NULL;
    HRESULT hres = ReportResult(0, S_FALSE, 0, 0);

    if (NULL==szFileIn || '\0'==szFileIn[0])
    {
        // A NULL filename is invalid for our purposes.
        // But if we did a DDE_INITIATE, NULL would mean "any topic",
        // and if we were called by RunningMoniker() with CLSID_NULL,
        // then we would be INITIATEing on "any app, any topic" and
        // SHELL (if not others) would respond.
	intrDebugOut((DEB_ITRACE,
		      "DdeIsRunning NULL szFileIn\n"));

        hres = S_FALSE;
	goto exitRtn;
    }
    //
    // This protocol doesn't handle the fact that there are two names for
    // every file. This is a bit of a problem. So, we are going to choose
    // the short name as the one to look for. This means that DDE objects
    // using the long filename will not work very well.
    //
    WCHAR szFile[MAX_PATH];
    szFile[0] = L'\0';
    if ((lstrlenW(szFileIn) == 0) || (GetShortPathName(szFileIn,szFile,MAX_PATH) == 0))
    {
	//
	// Unable to determine a short path for this object. Use whatever we were
	// handed.
	//
	intrDebugOut((DEB_ITRACE,"No conversion for short path. Copy szFileIn\n"));
	lstrcpyW(szFile,szFileIn);
    }
    intrDebugOut((DEB_ITRACE,"Short file szFile(%ws)\n",szFile));

    aTopic = wGlobalAddAtom (szFile);
    intrAssert(wIsValidAtom(aTopic));

    ErrZ (CDdeObject::Create (NULL, clsid, OT_LINK, aTopic, NULL, &pdde));

    if (NOERROR == pdde->DocumentLevelConnect (pbc))
    {
        // It is running!
        // Immediately terminate conversation.  We just wanted to know
        // if it was running.
        hres = NOERROR;
    }
    else
    {
        // Not running
        hres = ReportResult(0, S_FALSE, 0, 0);
    }

  errRtn:

    if (aTopic)
    {
        intrAssert(wIsValidAtom(aTopic));
        GlobalDeleteAtom (aTopic);
    }
    if (pdde)
    {
        Assert (pdde->m_refs==1);
        pdde->m_pUnkOuter->Release();
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "DdeIsRunning szFile(%ws) returns %x\n",szFile,hres));
    return hres;
}


#if 0
INTERNAL DdeIsRunning
    (CLSID clsid,
    LPCSTR cszFile,
    LPBC pbc,
    LPMONIKER pmkToLeft,
    LPMONIKER pmkNewlyRunning)
{
    HRESULT hresult = NOERROR;
    LPSTR szFile = NULL;

    // Normal case
    if (NOERROR == Dde_IsRunning (clsid, cszFile, pbc, pmkToLeft,
                                    pmkNewlyRunning))
    {
        return NOERROR;
    }

    if (cszFile[0]=='\\' && cszFile[1]=='\\')
    {
        RetErr (SzFixNet (pbc, (LPSTR)cszFile, &szFile));
        // Try with a drive letter instead of a UNC name
        if (NOERROR==Dde_IsRunning (clsid, szFile, pbc, pmkToLeft,
                                    pmkNewlyRunning))
        {
            hresult = NOERROR;
            goto errRtn;
        }
    }
    else
    {
        szFile = UtDupString (cszFile);  // so it can be deleted
    }

    // If failure, see if the file is running under a different net
    // drive letter that is mapped to the same drive.

    if (InitializeIterator (szFile) != NOERROR)
    {
        // file is probably not on a network drive
        hresult = ResultFromScode (S_FALSE);
        goto errRtn;
    }

    while (NOERROR==NextEquivalentNetDrive (szFile))
    {
        if (NOERROR == Dde_IsRunning (clsid, szFile, pbc, pmkToLeft,
                                    pmkNewlyRunning))
        {
            hresult = NOERROR;
            goto errRtn;
        }
    }
    // not running
    hresult = ResultFromScode (S_FALSE);

  errRtn:
    delete szFile;
    return hresult;
}
#endif



// CDdeObject::DocumentLevelConnect
//
// Try to connect to document (m_aTopic) even if the document is running
// under a different drive letter that is mapped to the same network drive.
//
INTERNAL CDdeObject::DocumentLevelConnect
    (LPBINDCTX pbc)
{
    ATOM aOriginal;
    ATOM aTopic;

    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::DocumentLevelConnect(%x)\n",this));
    HRESULT hresult = NOERROR;

    // Normal case
    if (NOERROR==m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
    {
	goto exitRtn;
    }


    WCHAR szFile[MAX_STR];
    WCHAR szUNCFile[MAX_STR];

    Assert (wIsValidAtom (m_aTopic));
    if (GlobalGetAtomName (m_aTopic, szFile, MAX_STR) == 0)
    {
	hresult = E_UNEXPECTED;
	goto exitRtn;
    }
    aOriginal = wDupAtom (m_aTopic);
    intrAssert(wIsValidAtom(aOriginal));

    intrDebugOut((DEB_ITRACE,
		  "::DocumentLevelConnect(szFile=%ws)\n",this,szFile));
    if (NOERROR != InitializeIterator (szFile))
    {
        // szFile probably not a network file
        hresult = ResultFromScode (S_FALSE);
        goto errRtn;
    }

    while (NOERROR == NextEquivalentNetDrive (szFile))
    {
        SetTopic (aTopic = wGlobalAddAtom (szFile));
        if (NOERROR==m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
        {
            // Inform client of new drive letter
            ChangeTopic (wAtomNameA(aTopic));
            hresult = NOERROR;
            goto errRtn;
        }
        else
        {
            SetTopic ((ATOM)0);
        }
    }

    // Try with full UNC name
    lstrcpyW (szUNCFile, szOriginalUNCName);
    lstrcatW (szUNCFile, szFile+2);  // skip X:
    SetTopic (aTopic = wGlobalAddAtom (szUNCFile));
    if (NOERROR==m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
    {
        // Inform client of new name
        ChangeTopic (wAtomNameA(aTopic));
        hresult = NOERROR;
        goto errRtn;
    }
    else
    {
        SetTopic ((ATOM)0);
    }

    // Not running
    hresult = S_FALSE;

errRtn:
    if (NOERROR != hresult)
        SetTopic (aOriginal);
    delete szOriginalUNCName;
    szOriginalUNCName = NULL;

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::DocumentLevelConnect(%x) returns %x\n",
		  this,hresult));

    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddeoo.cxx ===
/*
ddeoo.cpp
DDE Ole Object

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeoo.cpp

Abstract:

    This module contains the methods for DdeObject::OleObject

Author:

    Jason Fuller    (jasonful)  24-July-1992

*/

#include "ddeproxy.h"
#include <limits.h>

ASSERTDATA

//
// OleObject methods
//

STDUNKIMPL_FORDERIVED(DdeObject, OleObjectImpl)



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetClientSite
    (IOleClientSite FAR* pClientSite)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetClientSite(%x,pClientSite=%x)\n",
          this,
          pClientSite));

    ChkD (m_pDdeObject);

    if (m_pDdeObject->m_pOleClientSite)
        m_pDdeObject->m_pOleClientSite->Release();

    // we've decided to keep the pointer that's been passed to us. So we
    // must AddRef()
    if (m_pDdeObject->m_pOleClientSite = pClientSite)
        pClientSite->AddRef();

    // this pointer need not be sent to the server, because we will always
    // send our &m_MyDataSite as the client site
    return NOERROR;
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetClientSite
    (IOleClientSite FAR* FAR* ppClientSite)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetClientSite(%x)\n",
          this));

    ChkD (m_pDdeObject);
    // we've been asked to give the pointer so we should AddRef()
    if (*ppClientSite = m_pDdeObject->m_pOleClientSite)
        m_pDdeObject->m_pOleClientSite->AddRef();
    return NOERROR;
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::EnumVerbs
    (IEnumOLEVERB FAR* FAR* ppenumOleVerb)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::EnumVerbs(%x)\n",
          this));

    ChkD (m_pDdeObject);
    return ReportResult(0, OLE_S_USEREG, 0, 0);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::Update
( void )
{
    HRESULT hr;

    intrDebugOut((DEB_ITRACE,
          "CDdeObject::Update(%x)\n",
          this));

    ChkD (m_pDdeObject);

    hr = m_pDdeObject->Update(TRUE);
    if (hr == NOERROR)
    {
        hr = m_pDdeObject->Save(m_pDdeObject->m_pstg);
    }

    return hr;
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::IsUpToDate
( void )
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::IsUpToDate(%x)\n",
          this));

    ChkD (m_pDdeObject);
    // There is no way to know if a 1.0 server has edited its embedded
    // object, so we assume it has, to be on the safe side.
    return ResultFromScode (m_pDdeObject->m_ulObjType==OT_EMBEDDED
                            ? S_FALSE : S_OK);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetUserClassID
    (CLSID FAR* pClsid)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetUserClassID(%x)\n",
          this));

    *pClsid = m_pDdeObject->m_clsid;
    return NOERROR;
}

STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetUserType
    (DWORD dwFormOfType,
    LPOLESTR * pszUserType)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetUserType(%x)\n",
          this));

    return ReportResult (0, OLE_S_USEREG, 0, 0);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetExtent
( DWORD dwAspect, LPSIZEL lpsizel)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetExtent(%x)\n",
          this));

    HANDLE        hDdePoke = NULL;
    LPRECT16      lprc;

    ChkD (m_pDdeObject);
    Puts ("OleObject::SetExtent\n");
    if (!(dwAspect                              // at least one bit
          && !(dwAspect & (dwAspect-1))         // exactly one bit
          && (dwAspect & DVASPECT_CONTENT)))    // a bit we support
    {
        return ResultFromScode (DV_E_DVASPECT);
    }

#ifdef OLD
    m_pDdeObject->m_cxContentExtent = lpsizel->cx;
    m_pDdeObject->m_cyContentExtent = lpsizel->cy;
#endif

    if (!m_pDdeObject->m_pDocChannel)
    {
            return OLE_E_NOTRUNNING;
    }

    lprc = (LPRECT16) wAllocDdePokeBlock (sizeof(RECT16), g_cfBinary, &hDdePoke);

    if(lprc)
    {
        lprc->left = lprc->right = (SHORT) min(INT_MAX,lpsizel->cx);
        lprc->top  = lprc->bottom= (SHORT) min(INT_MAX,lpsizel->cy);
    }

    aStdDocDimensions = GlobalAddAtom (OLESTR("StdDocDimensions"));
    intrAssert(wIsValidAtom(aStdDocDimensions));

    if(hDdePoke)
        GlobalUnlock (hDdePoke);

    return m_pDdeObject->Poke(aStdDocDimensions, hDdePoke);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetExtent
( DWORD dwAspect, LPSIZEL lpsizel)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetExtent(%x)\n",
          this));

    ChkD (m_pDdeObject);


#ifdef OLD
    VDATEPTROUT (lpsizel, SIZEL);
    if (!(dwAspect                              // at least one bit
          && !(dwAspect & (dwAspect-1))         // exactly one bit
          && !(dwAspect & (DVASPECT_CONTENT | DVASPECT_ICON)))) // a bit we support
    {
        return ResultFromScode (DV_E_DVASPECT);
    }

    if (dwAspect & DVASPECT_CONTENT)
    {
        lpsizel->cx = m_pDdeObject->m_cxContentExtent;
        lpsizel->cy = m_pDdeObject->m_cyContentExtent;
    }

    return NOERROR;
#endif
    return ResultFromScode(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::DoVerb
//
//  Synopsis:   Send the server a message asking it to do a verb.
//
//  Effects:    OLE1.0 servers only know how to do a couple of
//      verbs. Specifically, it will respond to PRIMARY,
//      HIDE, OPEN, and SHOW. All others return error
//
//
//  Arguments:  [iVerb] -- Verb number
//      [lpmsg] -- Window message (ignored)
//      [pActiveSite] -- ActiveSite (ignored)
//      [lindex] -- Index (ignored)
//      [hwndParent] -- (ignored)
//      [lprcPosRect] -- (ignored)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//
//  ANSI ALERT!
//
//  The server is going to accept a command string from us. This string
//  needs to be done in ANSI, since we are going to pass it to old
//  servers. Therefore, the following code generates an ANSI string
//  The following are the supported verb strings
//
//  [StdShowItem("aItem",FALSE)]
//  [StdDoVerbItem("aItem",verb,FALSE,FALSE)]
//
//----------------------------------------------------------------------------
STDMETHODIMP NC(CDdeObject,COleObjectImpl)::DoVerb
    (LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite,
     LONG lindex, HWND hwndParent, const RECT FAR* lprcPosRect)
{
    WORD    len;
    ULONG     size;
    LPSTR   lpdata = NULL;
    LPSTR   lpdataStart = NULL;
    HANDLE  hdata = NULL;
    BOOL    bShow;
    HRESULT hresult;

    ChkD (m_pDdeObject);

    intrDebugOut((DEB_ITRACE,
          "CDdeObject::DoVerb(%x,iVerb=%x,lindex=%x)\n",
          this,iVerb,lindex));

    if (iVerb < OLEIVERB_HIDE)
    {
    intrDebugOut((DEB_ITRACE,
              "CDdeObject::DoVerb(%x)Returning invalid verb\n",
              this));
    return OLEOBJ_E_INVALIDVERB;
    }


    if (iVerb == OLEIVERB_HIDE)
    {
    intrDebugOut((DEB_ITRACE,"::DoVerb(%x) OLEIVERB_HIDE\n",this));

        if (m_pDdeObject->m_fVisible || OT_LINK==m_pDdeObject->m_ulObjType)
    {
        intrDebugOut((DEB_ITRACE,
              "::DoVerb(%x) CANNOT_DOVERB_NOW\n",this));
            return OLEOBJ_S_CANNOT_DOVERB_NOW;
    }

    intrDebugOut((DEB_ITRACE,"::DoVerb(%x) returns NOERROR\n",this));
    return NOERROR;
    }

    //
    // Calculate the number of bytes needed to pass the
    // execute command to the server.
    //
    if (bShow = (iVerb == OLEIVERB_SHOW
                 || iVerb == OLEIVERB_OPEN
                 || m_pDdeObject->m_bOldSvr))
    {
    //
        // [StdShowItem("aItem",FALSE)]
    //

        len = 23 + wAtomLenA (m_pDdeObject->m_aItem) + 1;

    }
    else
    {
        // [StdDoVerbItem("aItem",verb,FALSE,FALSE)]
        len = 32 + 10 /* for verb */ + wAtomLenA (m_pDdeObject->m_aItem) + 1;

    }

    if (!(hdata = GlobalAlloc (GMEM_DDESHARE, size = len)))
    {
    intrDebugOut((DEB_ITRACE,
              "::DoVerb(%x) cannot alloc %x bytes\n",
              this,size));
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }


    if (!(lpdata = (LPSTR)GlobalLock (hdata)))
    {
    intrDebugOut((DEB_ITRACE,
              "::DoVerb(%x) cannot lock\n",
              this));
        GlobalFree (hdata);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    lpdataStart = lpdata;


    strcpy (lpdata, bShow ? "[StdShowItem(\"" : "[StdDoVerbItem(\"");
    len = (WORD)strlen (lpdata);
    lpdata += len;

    // For links
    if (m_pDdeObject->m_aItem)
        lpdata += GlobalGetAtomNameA (m_pDdeObject->m_aItem, lpdata, size - len);

    if (!bShow) {
        wsprintfA (lpdata,"\",%lu,TRUE,FALSE)]", iVerb);
    } else {
        strcpy (lpdata, "\")]");
        // apps like excel and wingraph do not support activate at item level.
    }

    intrDebugOut((DEB_ITRACE,"::DoVerb(%x)lpdata(%s)\n",this,lpdataStart));

    Assert (strlen(lpdata) < size);

    GlobalUnlock (hdata);

    hresult = m_pDdeObject->Execute (m_pDdeObject->m_pDocChannel, hdata);

    if (NOERROR==hresult)
    {
        // Assume doing a verb makes the server visible.
        // This is not strictly true.
        m_pDdeObject->DeclareVisibility (TRUE);
    }
    else
    {
    intrDebugOut((DEB_ITRACE,
              "::DoVerb(%x)Execute returned %x\n",
              this,
              hresult));
    }
    return hresult;
}





//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::SetHostNames
//
//  Synopsis:   Sets the host names
//
//  Effects:
//
//  Arguments:  [szContainerApp] -- Name of container app
//      [szContainerObj] -- Name of contained object
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//  ANSI ALERT!
//
//  The server is going to accept a command string from us. This string
//  needs to be done in ANSI, since we are going to pass it to old
//  servers. Therefore, the following code generates an ANSI string
//
//----------------------------------------------------------------------------
STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetHostNames
(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetHostNames(%x,App=%ws,Obj=%ws)\n",
          this,szContainerApp,szContainerObj));

    WORD        cbName;
    WORD        wSize;
    LPSTR       lpBuf;
    HANDLE      hDdePoke = NULL;

    ChkD (m_pDdeObject);

    VDATEPTRIN (szContainerApp, char);

    if (!m_pDdeObject->m_pDocChannel)
        return NOERROR;
    if (szContainerObj==NULL)
        szContainerObj=OLESTR("");

    if (szContainerApp[0]=='\0')
        szContainerApp = OLESTR("Container Application");

    //
    // The OLE 1.0 server is going to want ANSI strings.
    // convert the two that we have
    //

    char pszContainerApp[MAX_STR];
    char pszContainerObj[MAX_STR];

    if (WideCharToMultiByte(CP_ACP,
                0,
                szContainerApp,
                -1,
                pszContainerApp,
                MAX_STR,
                NULL,
                NULL) == FALSE)
    {
    intrDebugOut((DEB_ERROR,
              "::SetHostNames(%x) can't convert szContainerApp(%ws) err=%x\n",
              this,szContainerApp,GetLastError()));

    //
    // Couldn't convert string
    //
    return(E_UNEXPECTED);
    }
    if (WideCharToMultiByte(CP_ACP,
                0,
                szContainerObj,
                -1,
                pszContainerObj,
                MAX_STR,
                NULL,
                NULL) == FALSE)
    {
    intrDebugOut((DEB_ERROR,
              "::SetHostNames(%x) can't convert szContainerObj(%ws) err=%x\n",
              this,szContainerObj,GetLastError));

    //
    // Couldn't convert string
    //
    return(E_UNEXPECTED);
    }


    //
    // We have found through experience that some OLE applications, like
    // Clipart, use a fixed size buffer for these names. Therefore, we
    // are going to limit the sizes of the strings, in case they are
    // too long to send. We do this by always sticking a NULL at offset
    // 80 in the file.
    //
    pszContainerApp[80]=0;
    pszContainerObj[80]=0;

    WORD cbObj;

    wSize = (WORD)((cbName = strlen(pszContainerApp)+1)
            + (cbObj = strlen(pszContainerObj)+1)
            + 2 * sizeof(WORD));  // for the two offsets

    lpBuf = wAllocDdePokeBlock ((DWORD)wSize, g_cfBinary, &hDdePoke);

    if(lpBuf)
    {
        ((WORD FAR*)lpBuf)[0] = 0;
        ((WORD FAR*)lpBuf)[1] = cbName;
        lpBuf += 2*sizeof(WORD);
        memcpy (lpBuf,pszContainerApp,cbName);
        memcpy (lpBuf+cbName, pszContainerObj,cbObj);
    }

    if(hDdePoke)
        GlobalUnlock (hDdePoke);

    aStdHostNames = GlobalAddAtom (OLESTR("StdHostNames"));
    intrAssert(wIsValidAtom(aStdHostNames));
    m_pDdeObject->Poke(aStdHostNames, hDdePoke);
    return NOERROR;
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::Close
    (DWORD dwSaveOption)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::Close(%x,dwSaveOption=%x)\n",
          this,dwSaveOption));


    ChkDR (m_pDdeObject);

    HRESULT hresult;
    if (m_pDdeObject->m_fDidSendOnClose)
        return ResultFromScode (RPC_E_CANTCALLOUT_INASYNCCALL);

    if (((OLECLOSE_SAVEIFDIRTY  == dwSaveOption) ||
         (OLECLOSE_PROMPTSAVE==dwSaveOption)) &&
         (m_pDdeObject->m_clsid != CLSID_Package))
    {
        // Packager gives truncated native data (header info with no
        // actual embedded file) if you DDE_REQUEST it. Bug 3103
        Update(); // IOleObject::Update
        m_pDdeObject->OleCallBack (ON_SAVE,NULL);
    }
    RetZ (m_pDdeObject->m_pDocChannel);

    HANDLE h = wNewHandle ((LPSTR)&achStdCloseDocument,sizeof(achStdCloseDocument));

    if(h)
    {
        hresult=m_pDdeObject->Execute (m_pDdeObject->m_pDocChannel,
                           h,
                           TRUE);
    }
    else
    {
        hresult=E_OUTOFMEMORY;
    }

    if (NOERROR==hresult)
        m_pDdeObject->m_fDidStdCloseDoc = TRUE;

    // Client sends StdCloseDocument. Srvr sends ACK. Srvr may or may not
    // send Terminate.  We may interpret the TERMINATE the server sends
    // as the reply to ours even if he posted first. But since some servers
    // post first and others wait for the client, this is what we need to do.

    BOOL fVisible = m_pDdeObject->m_fWasEverVisible; // TermConv clears this flag
    m_pDdeObject->TermConv (m_pDdeObject->m_pDocChannel);
    if (!fVisible)
        m_pDdeObject->MaybeUnlaunchApp();

    return hresult;
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetMoniker
    (DWORD dwWhichMoniker, LPMONIKER pmk)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetMoniker(%x,dwWhichMoniker=%x)\n",
          this,dwWhichMoniker));

    ChkD (m_pDdeObject);
    Puts ("OleObject::SetMoniker\r\n");
    // we ignore this always
    return NOERROR;
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetMoniker
    (DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetMoniker(%x,dwWhichMoniker=%x)\n",
          this,dwWhichMoniker));

    ChkD (m_pDdeObject);
    if (m_pDdeObject->m_pOleClientSite)
        return m_pDdeObject->m_pOleClientSite->GetMoniker(dwAssign,
                dwWhichMoniker, ppmk);
    else {
        // no client site
        *ppmk = NULL;
        return ReportResult(0, E_UNSPEC, 0, 0);
    }
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::InitFromData
    (LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::InitFromData(%x)\n",
          this));

    Puts ("OleObject::InitFromData\r\n");
    return ReportResult(0, E_NOTIMPL, 0, 0);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetClipboardData
    (DWORD dwReserved, LPDATAOBJECT FAR* ppDataObject)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetClipboardData(%x)\n",
          this));

    Puts ("OleObject::GetClipboardData\r\n");
    return ReportResult(0, E_NOTIMPL, 0, 0);
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::Advise
    (IAdviseSink FAR* pAdvSink,
     DWORD FAR*       pdwConnection)
{
    HRESULT hres;
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::Advise(%x)\n",
          this));

    ChkD (m_pDdeObject);
    Puts ("OleObject::Advise\n");
    // Esstablish a DDE advise connection.
    if (m_pDdeObject->m_ulObjType == OT_EMBEDDED
        && !m_pDdeObject->m_fDidAdvNative)
    {
        // Embedded case.
        // Always advise on Save and Close.
        if (hres = m_pDdeObject->AdviseOn (g_cfNative, ON_SAVE))
            return hres;
        if (hres = m_pDdeObject->AdviseOn (g_cfNative, ON_CLOSE))
            return hres;
        if (m_pDdeObject->m_clsid == CLSID_MSDraw)
        {
            // MSDraw has (another) bug.  If you do not do an Advise on
            // presentation, then File.Update does not work, and you
            // cannot close the app unless you answer "no" to the update
            // dialog.  This would happen when you "Display As Icon"
            // because ordinarily there is no need to advise on presentation.
            // The following "unnecessary" advise fixes this problem.
            if (hres = m_pDdeObject->AdviseOn (CF_METAFILEPICT, ON_SAVE))
                return hres;
            if (hres = m_pDdeObject->AdviseOn (CF_METAFILEPICT, ON_CLOSE))
                return hres;
        }
    }
    else {
        /* Linked case */
        if (hres = m_pDdeObject->AdviseOn (g_cfBinary, ON_RENAME))
            return hres;
    }
    RetZS (m_pDdeObject->m_pOleAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pOleAdvHolder->Advise (pAdvSink, pdwConnection);
}




STDMETHODIMP NC(CDdeObject,COleObjectImpl)::Unadvise
    (DWORD dwConnection)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::Unadvise(%x,dwConnection=%x)\n",
          this,dwConnection));

    HRESULT hres;
    ChkD (m_pDdeObject);

    // Terminate the DDE advise connection
    if (m_pDdeObject->m_ulObjType == OT_EMBEDDED)
    {
        // Embedded case.
        if (hres = m_pDdeObject->UnAdviseOn (g_cfNative, ON_SAVE))
            return hres;
        if (hres = m_pDdeObject->UnAdviseOn (g_cfNative, ON_CLOSE))
            return hres;
    }
    else
    {
        /* Linked case */
        if (hres = m_pDdeObject->UnAdviseOn (g_cfBinary, ON_RENAME))
            return hres;
    }
    RetZS (m_pDdeObject->m_pOleAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pOleAdvHolder->Unadvise (dwConnection);
}




STDMETHODIMP NC(CDdeObject,COleObjectImpl)::EnumAdvise
    (THIS_ LPENUMSTATDATA FAR* ppenumAdvise)
{
    ChkD (m_pDdeObject);
    RetZS (m_pDdeObject->m_pOleAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pOleAdvHolder->EnumAdvise(ppenumAdvise);
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetMiscStatus
    (DWORD dwAspect,
    DWORD FAR* pdwStatus)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetMiscStatus(%x)\n",
          this));

    VDATEPTRIN (pdwStatus, DWORD);
    *pdwStatus = 0L;
    return ResultFromScode (OLE_S_USEREG);
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetColorScheme
    (LPLOGPALETTE lpLogpal)
{
    HANDLE          hDdePoke    = NULL;
    LPLOGPALETTE    lptmpLogpal = NULL;

    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetColorScheme(%x)\n",
          this));

    ChkD (m_pDdeObject);

    if (!m_pDdeObject->m_pDocChannel)
        return NOERROR;

    aStdColorScheme = GlobalAddAtom (OLESTR("StdColorScheme"));
    intrAssert(wIsValidAtom(aStdColorScheme));

    DWORD dwSize = (max(lpLogpal->palNumEntries, 1) - 1) * sizeof(PALETTEENTRY)
                        + sizeof(LOGPALETTE);
    lptmpLogpal = (LPLOGPALETTE) wAllocDdePokeBlock (dwSize, g_cfBinary, &hDdePoke);

    if(!lptmpLogpal || !hDdePoke) return E_OUTOFMEMORY;

    memcpy(lptmpLogpal, lpLogpal, dwSize);

    GlobalUnlock(hDdePoke);
    return m_pDdeObject->Poke(aStdColorScheme, hDdePoke);
}



#ifdef _DEBUG
STDMETHODIMP_(void) NC(CDdeObject,CDebug)::Dump( IDebugStream FAR * pdbstm)
{
}

STDMETHODIMP_(BOOL) NC(CDdeObject,CDebug)::IsValid( BOOL fSuspicious )
{
    if( m_pDdeObject->m_refs > 0 && m_pDdeObject->m_chk == chkDdeObj )
        return TRUE;
    else
        return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddestg.cxx ===
/*

copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    ddeStg.cpp

Abstract:

    This module contains the DdeObject::PersistStg and
    DdeObject::ProxyManager methods

Author:

    Srini Koppolu   (srinik)    22-June-1992
    Jason Fuller    (jasonful)  24-July-1992

*/

#include "ddeproxy.h"
ASSERTDATA


/*
 *  IMPLEMENTATION of CPersistStgImpl methods
 *
 */


STDUNKIMPL_FORDERIVED(DdeObject, PersistStgImpl)


#pragma SEG(CDdeObject_CPersistStgImpl_GetClassID)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::GetClassID (CLSID FAR* pClassID)
{
    *pClassID = m_pDdeObject->m_clsid;
    return NOERROR;
}


#pragma SEG(CDdeObject_CPersistStgImpl_IsDirty)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::IsDirty ()
{
    return NOERROR;
}



#pragma SEG(CDdeObject_CPersistStgImpl_InitNew)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::InitNew
    (IStorage FAR* pstg)
{
    HRESULT hres;
    intrDebugOut((DEB_ITRACE,
                  "DdeObejct::InitNew(%x,pstg=%x)\n",
                  this,
                  pstg));

    if (hres = m_pDdeObject->PostSysCommand (m_pDdeObject->m_pSysChannel,
                                             (LPSTR)&achStdNewDocument,
                                             TRUE))
        return hres;

    if (hres = m_pDdeObject->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
        return hres;

    RetErr (m_pDdeObject->TermConv (m_pDdeObject->m_pSysChannel));
    if (m_pDdeObject->m_pstg)
    {
        m_pDdeObject->m_pstg->Release();
    }
    m_pDdeObject->m_pstg = pstg;
    pstg->AddRef();
    return hres;
}



#pragma SEG(CDdeObject_CPersistStgImpl_Load)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::Load (IStorage FAR* pstg)
{
    LPSTR        lpBuf=NULL;
    HANDLE      hDdePoke = NULL;
    DWORD       dwSize;
    CStmBufRead StmRead;
    CStmBufRead StmReadItem;
    HRESULT     hresult;

    intrDebugOut((DEB_ITRACE,"CDdeObject::Load(%x,pstg=%x)\n",this,pstg));

    {

        if (hresult = StmRead.OpenStream(pstg, OLE10_NATIVE_STREAM))
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) OpenStream failed(%x)\n",
                          this,
                          hresult));
            return hresult;
        }


        if (hresult = StmRead.Read(&dwSize, sizeof(DWORD)))
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) StRead failed(%x)\n",
                          this,
                          hresult));

            goto errRtn;
        }


        lpBuf = wAllocDdePokeBlock (dwSize, g_cfNative, &hDdePoke);

        if (lpBuf == NULL)
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) wAllocDdePokeBlock failed(%x)\n",
                          this,
                          hresult));

            hresult = E_OUTOFMEMORY;
            goto errRtn;
        }

        if (hresult = StmRead.Read(lpBuf, dwSize))
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) StRead of cfNative failed(%x)\n",
                          this,
                          hresult));
            goto errRtn;
        }

        if (m_pDdeObject->m_hNative)
        {
            GlobalFree (m_pDdeObject->m_hNative);
        }
        m_pDdeObject->m_hNative = wNewHandle (lpBuf, dwSize);

        if (m_pDdeObject->m_hNative == NULL)
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) m_hNative NULL\n",
                          this));
        }
    }

    GlobalUnlock (hDdePoke); // done with lpBuf

    if (hresult = m_pDdeObject->PostSysCommand (m_pDdeObject->m_pSysChannel,
                                                (LPSTR)&achStdEditDocument,
                                                FALSE))
    {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) PostSysCommand %s failed (%x)\n",
                          this,
                          &achStdEditDocument,
                          hresult));
        goto errRtn;
    }


    // Read Item Name, if there is one
    if (NOERROR == StmReadItem.OpenStream(pstg, OLE10_ITEMNAME_STREAM))
    {
        LPSTR szItemName = NULL;

        ErrRtnH (ReadStringStreamA (StmReadItem, &szItemName));
        m_pDdeObject->ChangeItem (szItemName);
        PubMemFree(szItemName);
    }

    if (hresult = m_pDdeObject->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
    {
        intrDebugOut((DEB_ITRACE,
                      "::Load(%x) ProxyMgr.Connect failed(%x)\n",
                      this,
                      hresult));
        goto errRtn;
    }


    if ((hresult = m_pDdeObject->Poke(m_pDdeObject->m_aItem, hDdePoke))
         != NOERROR)
    {
        intrDebugOut((DEB_ITRACE,
                      "::Load(%x) Poke failed(%x)\n",
                      this,
                      hresult));

        // the Poke calls frees the Poke data even in case of failure.
#ifdef LATER

        if (hresult = m_pDdeObject->Execute (m_pDdeObject->m_pDocChannel,
                                    wNewHandle ((LPSTR)achStdCloseDocument,sizeof(achStdCloseDocument)));
        goto errDoc;
#elseif
        goto errDoc;
#endif
    }

    hresult = m_pDdeObject->TermConv (m_pDdeObject->m_pSysChannel);
    if (hresult != NOERROR)
    {
        intrDebugOut((DEB_ITRACE,
                      "::Load(%x) TermConv on SysChannel failed(%x)\n",
                      this,
                      hresult));
        goto errRtn;
    }


    if (m_pDdeObject->m_pstg)
    {
        m_pDdeObject->m_pstg->Release();
    }

    m_pDdeObject->m_pstg = pstg;
    pstg->AddRef();
    goto LExit;

errRtn:
    if (hDdePoke)
        GlobalFree (hDdePoke);
    if (m_pDdeObject->m_pDocChannel)
        m_pDdeObject->TermConv (m_pDdeObject->m_pDocChannel);
LExit:
    StmReadItem.Release();
    StmRead.Release();

    intrDebugOut((DEB_ITRACE,"::Load(%x) returning (%x)\n",this,hresult));
    return hresult;
}


#pragma SEG(CDdeObject_CPersistStgImpl_Save)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::Save
    (IStorage FAR* pstgSave, BOOL fSameAsLoad)
{
    intrDebugOut((DEB_ITRACE,
                  "DdeObject::Save(%x,pstgSave=%x)\n",
                  this,
                  pstgSave));


    HRESULT hresult=NOERROR;

    if (m_pDdeObject->m_fUpdateOnSave
        && (m_pDdeObject->m_clsid != CLSID_Package
            || m_pDdeObject->m_hNative == NULL))
    {
        // Get latest data from server, if it is not shutting down
        // or telling us to Save, in which case it just gave us data.
        // (If it is shutting down, it probably won't respond.
        // Draw does respond, but gives bad data.)
        // Packager gives truncated native data (header info with no
        // actual embedded file) if you DDE_REQUEST it. Bug 3103
        m_pDdeObject->Update (FALSE);
    }

    if (m_pDdeObject->m_hNative == NULL)
    {
        // we still have nothing to save
        return ResultFromScode (E_BLANK);
    }

    hresult = m_pDdeObject->Save (pstgSave);

    Puts ("PersistStg::Save done\n");
    return hresult;
}


#pragma SEG(CDdeObject_CPersistStgImpl_SaveCompleted)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::SaveCompleted
    (IStorage FAR* pstgNew)
{
    intrDebugOut((DEB_ITRACE,
                  "DdeObejct::SaveCompleted(%x,pstgNew=%x)\n",
                  this,
                  pstgNew));

    RetZ (m_pDdeObject->m_pOleAdvHolder);
    m_pDdeObject->m_pOleAdvHolder->SendOnSave();
    if (pstgNew)
    {
        if (m_pDdeObject->m_pstg)
            m_pDdeObject->m_pstg->Release();
        m_pDdeObject->m_pstg = pstgNew;
        pstgNew->AddRef();
    }
    return NOERROR;
}


#pragma SEG(CDdeObject_CPersistStgImpl_HandsOffStorage)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::HandsOffStorage(void)
{
    intrDebugOut((DEB_ITRACE,"DdeObejct::HandsOffStorage(%x)\n",this));
    if (m_pDdeObject->m_pstg)
    {
        m_pDdeObject->m_pstg->Release();
        m_pDdeObject->m_pstg = NULL;
    }
    return NOERROR;
}


/*
 *  IMPLEMENTATION of CProxyManagerImpl methods
 *
 */


STDUNKIMPL_FORDERIVED(DdeObject, ProxyManagerImpl)



#pragma SEG(CDdeObject_CProxyManagerImpl_CreateServer)
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::CreateServer(REFCLSID rclsid,
                                 DWORD clsctx,
                                 void *pv)
{
    intrDebugOut((DEB_ITRACE,"DdeObejct::CreateServer(%x)\n",this));
    HRESULT hresult = NOERROR;

    if (m_pDdeObject->m_pSysChannel)
    {
        intrDebugOut((DEB_ITRACE,
                      "::CreateServer(%x)m_pSysChannel exists\n",
                      this));
        return NOERROR;
    }

    if (m_pDdeObject->m_aExeName == NULL)
    {
        intrDebugOut((DEB_ITRACE,
                      "::CreateServer(%x) Class Not Registered\n",
                      this));
        return(REGDB_E_CLASSNOTREG);
    }


    if (!m_pDdeObject->AllocDdeChannel(&m_pDdeObject->m_pSysChannel,TRUE))
    {
        intrDebugOut((DEB_ITRACE,
                      "::CreateServer(%x)AllocDdeChannel is failing\n",
                      this));
        return ReportResult(0, E_OUTOFMEMORY,0,0);
    }

    if (!m_pDdeObject->InitSysConv())
    {
        if (!(m_pDdeObject->LaunchApp()))
        {
            intrDebugOut((DEB_IERROR,"::CreateServer Could not launch app\n"));
            hresult = ResultFromScode (CO_E_APPNOTFOUND);
            goto errRtn;
        }

        if (!m_pDdeObject->InitSysConv())
        {
            intrDebugOut((DEB_IERROR,"::CreateServer Second init failed\n"));
            hresult = ResultFromScode (CO_E_APPDIDNTREG);
            goto errRtn;
        }
    }

    return NOERROR;

errRtn:
    intrDebugOut((DEB_ITRACE,"DdeObejct::CreateServer(%x) is failing(%x)\n",this,hresult));
    m_pDdeObject->DeleteChannel (m_pDdeObject->m_pSysChannel);
    Assert (hresult != NOERROR); // This is an error path
    return hresult;

}


#pragma SEG(CDdeObject_CProxyManagerImpl_Connect)
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::Connect(GUID oid, REFCLSID rclsid)
{
    intrDebugOut((DEB_ITRACE,"DdeObject::Connect(%x)\n",this));

    if (m_pDdeObject->m_pDocChannel)
        return NOERROR;

    if (!m_pDdeObject->AllocDdeChannel (&m_pDdeObject->m_pDocChannel,FALSE))
    {
        intrDebugOut((DEB_ITRACE,
                      "::Connect(%x) AllocDdeChannel failed, return E_OUTOFMEMORY\n",
                      this));
        return ReportResult(0, E_OUTOFMEMORY,0,0);
    }

    // Bug 3701
    m_pDdeObject->m_fDidSendOnClose = FALSE;
    if (wInitiate (m_pDdeObject->m_pDocChannel, m_pDdeObject->m_aClass,
                m_pDdeObject->m_aTopic))
    {
        return NOERROR;
    }

    intrDebugOut((DEB_ITRACE,"::Connect(%x) wInitiate failed\n",this));
    m_pDdeObject->DeleteChannel (m_pDdeObject->m_pDocChannel);
    return ResultFromScode (E_FAIL);
}


#pragma SEG(CDdeObject_CProxyManagerImpl_LockConnection)
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::LockConnection(BOOL fLock, BOOL fLastUnlockReleases)
{
    intrDebugOut((DEB_ITRACE,
          "DdeObject::LockConnection(%x,fLock=%x,fLastUnlockReleases=%x)\n",
                  this,
                  fLock,
                  fLastUnlockReleases));

    if (fLock)
        m_pDdeObject->m_cLocks++;
    else
    {
        if (m_pDdeObject->m_cLocks!=0 && 0 == --m_pDdeObject->m_cLocks &&
            fLastUnlockReleases && !m_pDdeObject->m_fVisible)
            (void)m_pDdeObject->m_Ole.Close (OLECLOSE_SAVEIFDIRTY);
    }
    return NOERROR;
}


#ifdef NOTNEEDED
#pragma SEG(CDdeObject_CProxyManagerImpl_GetClassID)
STDMETHODIMP_(void) NC(CDdeObject, CProxyManagerImpl)::GetClassID(CLSID FAR* pClsid)
{
    *pClsid = m_pDdeObject->m_clsid;
}


#pragma SEG(CDdeObject_CProxyManagerImpl_GetOID)
STDMETHODIMP_(OID) NC(CDdeObject, CProxyManagerImpl)::GetOID()
{
    if (m_pDdeObject->m_pSysChannel)
        return (OID) m_pDdeObject->m_pSysChannel;

    if (m_pDdeObject->m_pDocChannel)
        return (OID) m_pDdeObject->m_pDocChannel;

    return NULL;
}
#endif

#pragma SEG(CDdeObject_CProxyManagerImpl_IsConnected)
STDMETHODIMP_(BOOL) NC(CDdeObject, CProxyManagerImpl)::IsConnected(void)
{
    return m_pDdeObject->m_pDocChannel != NULL;
}


#pragma SEG(CDdeObject_CProxyManagerImpl_EstablishIID)
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::EstablishIID(REFIID iid, LPVOID FAR* ppv)
{
    // REVIEW: this is correct, but can we be smarter like in the real PM?
    return QueryInterface(iid, ppv);
}


#pragma SEG(wTerminateIsComing)
INTERNAL_(BOOL) wTerminateIsComing (LPDDE_CHANNEL pChannel)
{
    MSG msg;
    return SSPeekMessage (&msg, pChannel->hwndCli, 0, 0, PM_NOREMOVE)
            && msg.message == WM_DDE_TERMINATE
            && (HWND)msg.wParam==pChannel->hwndSvr;
}


#pragma SEG(CDdeObject_CProxyManagerImpl_Disconnect)
STDMETHODIMP_(void) NC(CDdeObject, CProxyManagerImpl)::Disconnect()
{
    intrDebugOut((DEB_ITRACE,"DdeObject::Disonnect(%x)\n",this));

    if (m_pDdeObject->m_pDocChannel)
    {
        BOOL fTermComing = wTerminateIsComing (m_pDdeObject->m_pDocChannel);
        if ((!m_pDdeObject->m_fNoStdCloseDoc
             || (!m_pDdeObject->m_fWasEverVisible      // invisible update or
                 && !m_pDdeObject->m_fDidGetObject     // link from file case.
                 && m_pDdeObject->m_fDidStdOpenDoc))   // only do StdClose if did StdOpen
            && !m_pDdeObject->m_fDidStdCloseDoc
            && !fTermComing)
        {
            HANDLE h = wNewHandle ((LPSTR)&achStdCloseDocument,sizeof(achStdCloseDocument));

            if(h)
            {
                m_pDdeObject->Execute (m_pDdeObject->m_pDocChannel,
                                       h,
                                       /*fStdClose*/TRUE,
                                       /*fWait*/TRUE,
                                       /*fDetectTerminate*/TRUE);
            }

            m_pDdeObject->m_fDidStdCloseDoc = TRUE;
        }
        if (!m_pDdeObject->m_fDidSendOnClose /*|| fTermComing*/)
        {
            // if we did not call SendOnClose() then Disconnect() was called
            // by a Release method, not by SendOnClose().
            // This happens when user deletes object in container.
            BOOL fVisible = m_pDdeObject->m_fWasEverVisible; // TermConv clears this flag
            m_pDdeObject->TermConv (m_pDdeObject->m_pDocChannel);
            if (!fVisible)
                m_pDdeObject->MaybeUnlaunchApp();
        }
    }

    if (m_pDdeObject->m_pSysChannel)
    {
        intrDebugOut((DEB_IWARN,"Terminating system conversation in Disconnect()\n"));
        // This should never happen, I think.
        m_pDdeObject->TermConv (m_pDdeObject->m_pSysChannel);
    }
}

#ifdef SERVER_HANDLER
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::CreateServerWithEmbHandler(REFCLSID rclsid, DWORD clsctx, 
			                            REFIID riidEmbedSrvHandler,void **ppEmbedSrvHandler, void *pv)
{
    // No Embedded Server Handler for DDE. Set ppEmbedSrvHandler to NULL and Call ::CreateServer.
    clsctx &= ~CLSCTX_ESERVER_HANDLER;
    *ppEmbedSrvHandler = NULL;

    return CreateServer(rclsid,clsctx,pv);
}
#endif // SERVER_HANDLER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddewnd.cxx ===
/*++

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddewnd.cpp

Abstract:

    This module contains the code for the dde window procs

Author:

    Srini Koppolu   (srinik)    20-June-1992

Revision History:

--*/
#include "ddeproxy.h"



#define SYS_MSG 0
#define DOC_MSG 1

// SysWndProc: Window Procedure for System Topic DDE conversations
// wndproc for system topic


STDAPI_(LRESULT) SysWndProc (
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    StackAssert(SSOnSmallStack());
    CDdeObject FAR* pDdeObj = NULL;
    LPDDE_CHANNEL   pChannel = NULL;

    if (message>=WM_DDE_FIRST && message <= WM_DDE_LAST)
    {
        if (pDdeObj = (CDdeObject FAR*) GetWindowLongPtr (hwnd, 0))
		{
            pChannel = pDdeObj->GetSysChannel();
		}

		if (pChannel == NULL)
		{
			intrAssert(pChannel != NULL);
			return SSDefWindowProc (hwnd, message, wParam, lParam);
		}
    }

    if (pChannel
        && (pChannel->iAwaitAck == AA_EXECUTE
	        || pChannel->iAwaitAck == AA_INITIATE) )
    {
		MSG msg;
		BOOL fDisp = FALSE;
		while (SSPeekMessage(&msg, hwnd, WM_DDE_ACK, WM_DDE_ACK, PM_REMOVE | PM_NOYIELD) )
		{
			intrDebugOut((DEB_WARN, "DDE SysWndProc: dispatching WM_DDE_ACK message (%x)\n",pChannel));
				SSDispatchMessage(&msg);
			fDisp = TRUE;
		}
        if (fDisp && (pDdeObj = (CDdeObject FAR*) GetWindowLongPtr (hwnd, 0)))
		{
            pChannel = pDdeObj->GetSysChannel();
            intrAssert(pChannel != NULL);
		}
    }

	if (pChannel == NULL)
	{
		//intrAssert(pChannel != NULL);
		return SSDefWindowProc (hwnd, message, wParam, lParam);
	}

    switch (message){
    case WM_DDE_ACK:
		intrDebugOut((DEB_ITRACE,
		      "SWP: WM_DDE_ACK pChannel(%x)\n",pChannel));
		if (pChannel->bTerminating)
		{
			intrDebugOut((DEB_ITRACE,
		      "SWP: pChannel->bTerminating: no action\n"));
            break;
        }

        switch (pChannel->iAwaitAck) {
        case AA_INITIATE:
            pDdeObj->OnInitAck (pChannel, (HWND)wParam);
            if (LOWORD(lParam))
                GlobalDeleteAtom (LOWORD(lParam));
            if (HIWORD(lParam))
                GlobalDeleteAtom (HIWORD(lParam));
            break;

        case AA_EXECUTE:
            pDdeObj->OnAck (pChannel, lParam);
            break;

        default:
            intrDebugOut((DEB_ITRACE,
		      "SWP: WM_DDE_ACK UnhandledpChannel(%x)\n",pChannel));
            break;
        }
        break;

    case WM_TIMER:
        pDdeObj->OnTimer (pChannel);
        break;

    case WM_DDE_TERMINATE:
		intrDebugOut((DEB_ITRACE,
		      "SWP: WM_DDE_TERMINATE pChannel(%x)\n",pChannel));
        pDdeObj->OnTerminate (pChannel, (HWND)wParam);
        break;

    default:
        return SSDefWindowProc (hwnd, message, wParam, lParam);
    }

    return 0L;
}


// ClientDocWndProc: Window procedure used to document DDE conversations
STDAPI_(LRESULT) ClientDocWndProc (
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    StackAssert(SSOnSmallStack());
    CDdeObject FAR* pDdeObj = NULL;
    LPDDE_CHANNEL   pChannel = NULL;
    HANDLE hData;
    ATOM aItem;

    if (message>=WM_DDE_FIRST && message <= WM_DDE_LAST)
    {

        if (pDdeObj = (CDdeObject FAR*) GetWindowLongPtr (hwnd, 0))
	    pChannel = pDdeObj->GetDocChannel();

	if (pChannel == NULL)
	{
	    //
	    // pChannel == NULL. Something is very wrong! But, lets
	    // not fault on it.
	    //
	    //intrAssert(pChannel != NULL);
	    return SSDefWindowProc (hwnd, message, wParam, lParam);
	}

    }
    if (   pChannel
	&& (   pChannel->iAwaitAck == AA_EXECUTE
	    || pChannel->iAwaitAck == AA_INITIATE
	    || pChannel->iAwaitAck == AA_REQUESTAVAILABLE
	    || pChannel->iAwaitAck == AA_REQUEST
	    || pChannel->iAwaitAck == AA_UNADVISE
	    || pChannel->iAwaitAck == AA_EXECUTE
	    || pChannel->iAwaitAck == AA_ADVISE
	    || pChannel->iAwaitAck == AA_POKE)	)
    {
	MSG msg;
	BOOL fDisp = FALSE;
	while (SSPeekMessage(&msg, hwnd, WM_DDE_ACK, WM_DDE_ACK, PM_REMOVE | PM_NOYIELD) )
	{
	    intrDebugOut((DEB_WARN, "DDE DocWndProc: dispatching WM_DDE_ACK message (%x)\n",pChannel));
	    SSDispatchMessage(&msg);
	    fDisp = TRUE;
	}

	if (fDisp && (pDdeObj = (CDdeObject FAR*) GetWindowLongPtr (hwnd, 0)))
	{
	    pChannel = pDdeObj->GetDocChannel();
	}

	if (pChannel == NULL)
	{
	    intrAssert(pChannel != NULL);
	    return SSDefWindowProc (hwnd, message, wParam, lParam);
	}
    }

    switch (message)
    {
    case WM_DDE_ACK:

	intrDebugOut((DEB_ITRACE,
		      "ClientWndProc: WM_DDE_ACK pChannel(%x)\n",
		      pChannel));
	if (pChannel->bTerminating){
	    // ### this error recovery may not be correct.
	    DEBUG_OUT ("No action due to termination process",0)
	    break;
	 }

	 switch(pChannel->iAwaitAck){
	     case AA_INITIATE:
		 pDdeObj->OnInitAck (pChannel, (HWND)wParam);
		 if (LOWORD(lParam))
		     GlobalDeleteAtom (LOWORD(lParam));
		 if (HIWORD(lParam))
		     GlobalDeleteAtom (HIWORD(lParam));
		 break;

	     case AA_REQUESTAVAILABLE:
	     case AA_REQUEST:
	     case AA_UNADVISE:
	     case AA_EXECUTE:
	     case AA_ADVISE:
		 pDdeObj->OnAck (pChannel, lParam);
		 break;

	     case AA_POKE:
		 // freeing pokedata is done in handleack
		 pDdeObj->OnAck (pChannel, lParam);
		 break;

	     default:
		 intrDebugOut((DEB_IERROR,
		      "ClientWndProc: WM_DDE_ACK unhandled\n"));
		 break;

	} // end of switch
	break;

    case WM_DDE_DATA:
#ifdef _CHICAGO_
	//Note:POSTPPC
	pDdeObj->Guard();
#endif // _CHICAGO_
	hData = GET_WM_DDE_DATA_HDATA(wParam,lParam);
	aItem = GET_WM_DDE_DATA_ITEM(wParam,lParam);
	intrDebugOut((DEB_ITRACE,
		      "CWP: WM_DDE_DATA pChannel(%x) hData(%x) aItem(%x)\n",
		      pChannel,hData,aItem));
	pDdeObj->OnData (pChannel, hData, aItem);
#ifdef _CHICAGO_
	//Note:POSTPPC
	if (pDdeObj->UnGuard())
	{
	    SetWindowLong(hwnd, 0, (LONG)0);
	    intrDebugOut((DEB_IWARN, "DDE ClientDocWndProc Release on pUnkOuter == 0 (this:%x, hwnd:%x\n",pDdeObj, hwnd ));
	}
#endif // _CHICAGO_

	break;

    case WM_DDE_TERMINATE:
#ifdef _CHICAGO_
	//Note:POSTPPC
	pDdeObj->Guard();
#endif // _CHICAGO_
	intrDebugOut((DEB_ITRACE,
		      "CWP: WM_DDE_TERMINATE pChannel(%x)\n",pChannel));


	if (pDdeObj->m_fDoingSendOnDataChange)
	{
#ifdef _CHICAGO_
	    //Note:POSTPPC
	    BOOL  fPostMsg = TRUE;
#endif
	    //
	    // Cheese alert! This protocol is very bad. The original
	    // 16 bit code something even more worse, so we are stuck
	    // to do something roughly compatible.
	    //
	    // If fDoingSendOnDataChange, the client may be asking for
	    // additional information from the server. The way the code
	    // is structured, it doesn't handle OnTerminate gracefully
	    // in this case.
	    //
	    // To fix this, we first tell the call control that
	    // the server has died. Then we repost the terminate
	    // message so we can handle it later.
	    //
	    // The old code did a
	    // pDdeObj->QueueMsg (hwnd, message, wParam, lParam);
	    //
	    // and the old SendOnDataChange removed the message.
	    // This probably didn't work either, but was never
	    // actually encountered.
	    //

	    intrDebugOut((DEB_ITRACE,
			  "CWP: term doing SendOnDataChange \n"));
	    //
	    // If we got here, there should be a CallData assigned
	    // to the channel.
	    //
	    if (pChannel->pCD)
	    {
		intrDebugOut((DEB_ITRACE,"CWP: Setting call state\n"));

		pChannel->SetCallState(SERVERCALLEX_ISHANDLED, RPC_E_SERVER_DIED);

	    }
	    else
	    {
		//
		// If there is no call data, then we aren't waiting in
		// the channel. Terminate the conversation.
		//

		intrDebugOut((DEB_ERROR,"CWP: No call state exists\n"));
		pDdeObj->OnTerminate (pChannel, (HWND)wParam);
#ifdef _CHICAGO_
		//Note:POSTPPC
		fPostMsg = FALSE;
#else
	    	break;
#endif //
	    }

#ifdef _CHICAGO_
            //Note:POSTPPC
	    if (fPostMsg)
	    {
#endif
		//
		// Repost the message and try again.
		//
		intrDebugOut((DEB_ITRACE,"CWP: Reposting WM_DDE_TERMINATE\n"));
		PostMessage(hwnd,message,wParam,lParam);
#ifdef _CHICAGO_
            //Note:POSTPPC
	    }
#else
	    break;
#endif

	}
	else
	{
	    pDdeObj->OnTerminate (pChannel, (HWND)wParam);
	}
#ifdef _CHICAGO_
	//Note:POSTPPC
	if (pDdeObj->UnGuard())
	{
	    SetWindowLong(hwnd, 0, (LONG)0);
	    intrDebugOut((DEB_IWARN, "DDE ClientDocWndProc Release on pUnkOuter == 0 (this:%x, hwnd:%x\n",pDdeObj, hwnd ));
	}
#endif // _CHICAGO_
	break;

    default:
	return SSDefWindowProc (hwnd, message, wParam, lParam);

    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddeproxy.cxx ===
/*
copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeproxy.cpp

Abstract:

    This module contains the code for the dde proxy (wrapper)

Author:

    Srini  Koppolu   (srinik)    22-June-1992
    Jason  Fuller   (jasonful)  24-July-1992
*/
#include "ddeproxy.h"
#include <tls.h>

DebugOnly (static UINT v_cDdeObjects=0;)
/*
 *  IMPLEMENTATION of CDdeObject
 *
 */

#ifdef OLD
#define UpdateExtent(old,new) do { if ((long)new!=old) {old=(long)new; } } while (0)
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CreateDdeClientHwnd
//
//  Synopsis:   Creates a per thread ClientDde window.
//
//  Effects:    This window is created so we can keep a list of windows that
//              need to be cleaned up in the event the thread dies or OLE32 is
//              unloaded. In the case of DLL unload, we will fault if we don't
//              cleanup this window, since user will dispatch messages to
//              non-existant code. The easy way to track these windows is to
//              make them children of a common per thread window.
//
//              This routine is called by the TLSGetDdeClient() routine to
//              create a window per thread. This window doesn't need to respond
//              to DDE Initiates.
//
//  Arguments:  [void] --
//
//  Returns:    HWND to DdeClientWindow.
//
//  History:    12-10-94   kevinro   Created
//
//----------------------------------------------------------------------------

HWND CreateDdeClientHwnd(void)
{
    return SSCreateWindowExA(0,"STATIC","DdeClientHwnd",WS_DISABLED,
                         0,0,0,0,NULL,NULL,hinstSO,NULL);
}

// CreateDdeProxy
//
// This corresponds to ProxyManager::Create in 2.0
//


INTERNAL_ (LPUNKNOWN) CreateDdeProxy
    (IUnknown * pUnkOuter,
    REFCLSID clsid)
{
    LPUNKNOWN punk;
    intrDebugOut((DEB_ITRACE,"CreateDdeProxy(pUnkOuter=%x)\n",pUnkOuter));

    COleTls Tls;
    if (Tls->dwFlags & OLETLS_DISABLE_OLE1DDE)
    {
        // If DDE use is disabled we shouldn't have gotten here.
        // This is a bad place to error because we can't return an
        // HResult.
        //
        Assert(!"Executing CreateDdeProxy when DDE is disabled");
        return NULL;
    }

    punk = CDdeObject::Create (pUnkOuter, clsid);
    intrDebugOut((DEB_ITRACE,
                  "CreateDdeProxy(pUnkOuter=%x) returns %x\n",
                  pUnkOuter,
                  punk));
    return punk;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::Create
//
//  Synopsis:   Creates a CDdeObject
//
//  Effects:
//
//  Arguments:  [pUnkOuter] --  Controlling IUnknown
//      [clsid] --      OLE1 ClassID
//      [ulObjType] --  Object type. Optional: def to OT_EMBEDDED
//      [aTopic] --     Atom of link. Optional: def to NULL
//      [szItem] --     String for link object (def to NULL)
//      [ppdde] --      Output pointer to CDdeObject (def to NULL)
//      [fAllowNullClsid] -- Is NULL clsid OK? Default: false
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPUNKNOWN) CDdeObject::Create
    (IUnknown *     pUnkOuter,
    REFCLSID        clsid,
    ULONG           ulObjType,// optional, default OT_EMBEDDED
    ATOM            aTopic,   // optional, only relevant if ulObjType==OT_LINK
    LPOLESTR            szItem,   // optional, only relevant if ulObjType==OT_LINK
    CDdeObject * * ppdde,       // optional, thing created
    BOOL            fAllowNullClsid) // default FALSE
{
    COleTls Tls;
    if(Tls->dwFlags & OLETLS_DISABLE_OLE1DDE)
    {
        //
        // If the DDE implementation of OLE1 is disabled
        // we shouldn't get this far.   This is also a bad place
        // to fail because we this routine is defined to not return
        // an HResult.
        //
        Assert(!"Executing CDdeObject::Create but DDE is Disabled");
        return NULL;
    }
    intrDebugOut((DEB_ITRACE,"CDdeObject::Create(%x,ulObjType=%x)\n",
          pUnkOuter,
          ulObjType));

    CDdeObject * pDdeObject;
    static int iTopic=1;  // used to make topic names unique
    WCHAR szTopic[30];
    Assert (ulObjType==OT_LINK || ulObjType==OT_EMBEDDED);

    Assert (ulObjType != OT_LINK || wIsValidAtom(aTopic));
    if (ppdde)
        *ppdde = NULL;

    if (NULL==(pDdeObject = new CDdeObject (pUnkOuter))
        || NULL == pDdeObject->m_pDataAdvHolder
        || NULL == pDdeObject->m_pOleAdvHolder)
    {
        Assert (!"new CDdeObject failed");
        return NULL;
    }

    pDdeObject->m_refs      = 1;
    pDdeObject->m_clsid     = clsid;
    pDdeObject->m_aClass    = wAtomFromCLSID(clsid);

#ifdef OLE1INTEROP

    pDdeObject->m_fOle1interop = TRUE;

#endif

    if (ulObjType==OT_LINK)
    {

        pDdeObject->m_aTopic = wDupAtom (aTopic);
        pDdeObject->m_aItem  = wGlobalAddAtom (szItem);
        // Never close a linked document
        pDdeObject->m_fNoStdCloseDoc = TRUE;
    }
    else
    {
        // This string may actually be visible in the Window Title Bar for a sec.
        InterlockedIncrement((long *)&iTopic);
        wsprintf (szTopic,OLESTR("Embedded Object #%u"), iTopic);
        Assert (lstrlenW(szTopic) < 30);
        pDdeObject->m_aItem = NULL;
        pDdeObject->m_aTopic = wGlobalAddAtom (szTopic);
    }
    pDdeObject->m_bOldSvr   = wIsOldServer (pDdeObject->m_aClass);
    pDdeObject->m_ulObjType = ulObjType;

    // we can only run if we have a MFI
    pDdeObject->m_aExeName = wGetExeNameAtom(clsid);

    intrDebugOut((DEB_ITRACE,
          "::Create(%x,aTopic=%x,aItem=%x,szItem=%ws,aExeName=%x)\n",
          pDdeObject,
          pDdeObject->m_aTopic,
          pDdeObject->m_aItem,
          szItem?szItem:L"<NULL>",
          pDdeObject->m_aExeName));

    if (ppdde)
        *ppdde = pDdeObject;
    return &pDdeObject->m_Unknown;
}



// Constructor
CDdeObject::CDdeObject (IUnknown * pUnkOuter) :
    m_Unknown(this),
    CONSTRUCT_DEBUG
    m_Data(this),
    m_Ole(this),
    m_PersistStg(this),
    m_ProxyMgr(this),
    m_OleItemContainer(this),
    m_RpcStubBuffer(this)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::CDdeObject(%x)\n",this));
    if (!pUnkOuter)
        pUnkOuter = &m_Unknown;

    m_pUnkOuter = pUnkOuter;
    m_bRunning  = FALSE;
    m_pOleClientSite = NULL;
    m_pstg = NULL;
    m_pSysChannel = NULL;
    m_pDocChannel = NULL;
    m_bInitNew = NULL;
    m_hNative = NULL;
    m_hPict   = NULL;
    m_hExtra  = NULL;
    m_cfExtra = NULL;
    m_cfPict = 0;
    m_aItem = NULL;
    m_iAdvSave = 0;
    m_iAdvClose = 0;
    m_iAdvChange = 0;
    m_fDidAdvNative = FALSE;
    m_pOleAdvHolder = NULL;
    m_pDataAdvHolder = NULL;
    m_fDidSendOnClose = FALSE;
    m_fNoStdCloseDoc = FALSE;
    m_fDidStdCloseDoc = FALSE;
    m_fDidStdOpenDoc = FALSE;
    m_fDidGetObject = FALSE;
    m_fDidLaunchApp = FALSE;
    m_fUpdateOnSave = TRUE;
    m_fVisible = FALSE;
    m_fWasEverVisible = FALSE;
    m_fCalledOnShow = FALSE;
    m_fGotCloseData = FALSE;
    m_cLocks = 1;               // connections are initially locked
    m_chk = chkDdeObj;
    m_ptd = NULL;
    m_fDoingSendOnDataChange = FALSE;
#ifdef _CHICAGO_
    //Note:POSTPPC
    _DelayDelete = NoDelay;
#endif // _CHICAGO_

    CreateOleAdviseHolder (&m_pOleAdvHolder);
    Assert (m_pOleAdvHolder);
    CreateDataAdviseHolder (&m_pDataAdvHolder);
    Assert (m_pDataAdvHolder);

#ifdef OLD
    m_cxContentExtent = 2000;  // 2 centimeters , totally random default
    m_cyContentExtent = 2000;
#endif

    m_wTerminate = Terminate_None;

    DebugOnly (v_cDdeObjects++;)
    Putsi (v_cDdeObjects);
}



CDdeObject::~CDdeObject
    (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::~CDdeObject(%x)\n",this));

    if (m_pDocChannel)
    {
        intrDebugOut((DEB_IWARN , "Abnormal situation: Doc Channel not deleted. Server died?"));
        delete m_pDocChannel;
    }
    if (m_pSysChannel)
    {
        Warn ("Abnormal situation: Sys Channel not deleted. Server died?");
        delete m_pSysChannel;
    }
    if (m_hNative)
    {
        GlobalFree(m_hNative);
    }

    if (m_hPict)
    {
        wFreeData (m_hPict, m_cfPict, TRUE);
    }

    if (m_hExtra)
    {
        wFreeData (m_hExtra, m_cfExtra, TRUE);
    }

    // release all the pointers that we remember

    if (m_pOleClientSite)
    {
        DeclareVisibility (FALSE);
        m_pOleClientSite->Release();
    }

    if (m_pDataAdvHolder)
        m_pDataAdvHolder->Release();

    if (m_pOleAdvHolder)
        m_pOleAdvHolder->Release();

    if (m_pstg)
        m_pstg->Release();

    if (m_aExeName)
        GlobalDeleteAtom (m_aExeName);

    if (m_aClass)
        GlobalDeleteAtom (m_aClass);

    if (m_aTopic)
        GlobalDeleteAtom (m_aTopic);

    if (m_aItem)
        GlobalDeleteAtom (m_aItem);

    if (m_ptd)
        delete m_ptd;

    m_chk = 0;
    DebugOnly (v_cDdeObjects--;)
    Putsi (v_cDdeObjects);
}




//  Handles WM_DDE_ACKs received while in initiate state. If this is the first
//  reply, save its window handle. If multiple replies are received, take the
//  one with the prefered instance, if there is one. Keep a count of
//  WM_DDE_TERMINATEs we send so that we don't shut the window until we get
//  all of the responses for  WM_DDE_TERMINATEs.


INTERNAL_(void) CDdeObject::OnInitAck (LPDDE_CHANNEL pChannel, HWND hwndSvr)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::OnInitAck(%x,hwndSvr=%x)\n",this,hwndSvr));
#ifdef _MAC
#else
    if (!IsWindow (hwndSvr))
    {
        Assert (0);
        return;
    }
    if (pChannel->hwndSvr) { // if we already have a handle
        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::OnInitAck(%x,hwndSvr=%x) Already have hwndSvr=%x\n",
                      this,
                      hwndSvr,
                      pChannel->hwndSvr));
        // just take the very first one. Direct post is OK
        MPostWM_DDE_TERMINATE(hwndSvr,pChannel->hwndCli);
        // Expect an extra WM_DDE_TERMINATE
        ++pChannel->iExtraTerms;
    } else {
        // this is the server we want
        pChannel->hwndSvr = hwndSvr;
        pChannel->iExtraTerms = NULL;

        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::OnInitAck(%x,hwndSvr=%x) Established Connection\n",
                      this,
                      hwndSvr,
                      pChannel->hwndSvr));
    }
#endif _MAC
}

INTERNAL_(BOOL) CDdeObject::OnAck (LPDDE_CHANNEL pChannel, LPARAM lParam)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::OnAck(%x,lParam=%x)\n",this,lParam));

    BOOL    retval = TRUE;
    ATOM    aItem;
    WORD    wStatus;
    HANDLE  hData = NULL;

    if( pChannel->iAwaitAck == AA_EXECUTE)
    {
       wStatus = GET_WM_DDE_EXECACK_STATUS( NULL, lParam );
       hData   = GET_WM_DDE_EXECACK_HDATA( NULL, lParam );
    }
    else
    {
       wStatus = GET_WM_DDE_ACK_STATUS( NULL, lParam );
       aItem = GET_WM_DDE_ACK_ITEM( NULL, lParam );
    }


    // check for busy bit
    if (wStatus & 0x4000)
    {
        // we got busy from the server.
        pChannel->fRejected = TRUE;
        // tell the wait loop that we got a busy ack
        //CoSetAckState(pChannel->pCI , FALSE,TRUE, SERVERCALLEX_RETRYLATER);
        intrDebugOut((DEB_ITRACE,"::OnAck(%x) Busy SetCallState(SERVERCALLEX_RETRYLATER)\n",this));
        pChannel->SetCallState(SERVERCALLEX_RETRYLATER);
        return TRUE;
    }

    // just reset the flag always
    m_wTerminate = Terminate_None;

    intrDebugOut((DEB_ITRACE,
                  "::OnAck(%x)aItem=%x(%ws) wStatus=\n",
                  this,
                  aItem,
                  wAtomName(aItem),
                  wStatus));

    if (pChannel->iAwaitAck == AA_EXECUTE)
    {
        if(hData) GlobalFree (hData);
        pChannel->hCommands = NULL;
    }
    else
    {
        if (hData)
            GlobalDeleteAtom ((ATOM)hData);
    }


    // even if the client got terminate we have to go thru this path.

    if (pChannel->wTimer) {
        KillTimer (pChannel->hwndCli, 1);
        pChannel->wTimer = 0;
    }


    if (pChannel->iAwaitAck == AA_POKE)
        // We have to free the data first. OnAck can trigger
        // another Poke (like pokehostnames)
        wFreePokeData (pChannel, (m_bOldSvr && m_aClass==aMSDraw));


    if (!(wStatus & POSITIVE_ACK))
    {
        intrDebugOut((DEB_ITRACE,"::OnAck(%x) OnAck got an ack with fAck==FALSE.\n",this));

        // A negative ack is OK when doing a temporary advise from
        // IsFormatAvailable().   Also, apps don't seem to positively
        // ack all unadvises.

        // review: johannp : this is the case were have to inform the reply rejected call

        retval = FALSE;
        // we got the ack and can leave the wait loop
        //CoSetAckState(pChannel->pCI, FALSE);

        intrDebugOut((DEB_ITRACE,
                      "::OnAck(%x) ***_ NACK _*** SetCallState(ISHANDLED,RPC_E_DDE_NACK)\n",
                      this));

        pChannel->SetCallState(SERVERCALLEX_ISHANDLED, RPC_E_DDE_NACK);

        // MSDraw frees hOptions even on a NACK, despite official DDE rules.
        if (pChannel->iAwaitAck == AA_ADVISE && m_clsid != CLSID_MSDraw)
        {
           GlobalFree (pChannel->hopt);
           pChannel->bFreedhopt = TRUE;
        }
    }
    else
    {
        // we got the ack and can leave the wait loop
        // CoSetAckState(pChannel->pCI, FALSE);
        intrDebugOut((DEB_ITRACE,
                      "::OnAck(%x) POSITIVE_ACK SetCallState(SERVERCALLEX_ISHANDLED)\n",
                      this));
        pChannel->SetCallState(SERVERCALLEX_ISHANDLED);
    }

    pChannel->hopt = NULL;
    pChannel->iAwaitAck = NULL;
    return retval;

}





INTERNAL_(void) CDdeObject::OnTimer (LPDDE_CHANNEL pChannel)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::OnTimer(%x)\n",this));
    // Since there is only one timer for each client, just
    // repost the message and delete the timer.
#ifdef _MAC
#else
    KillTimer (pChannel->hwndCli, 1);
    pChannel->wTimer = 0;

    if (wPostMessageToServer(pChannel, pChannel->wMsg, pChannel->lParam,FALSE))
        return ;

    // Postmessage failed. We need to getback to the main stream of
    // commands for the object.
    OnAck (pChannel, pChannel->lParam);
#endif _MAC
}



// Called when we get a WM_DDE_DATA message in reponse to
// a DDE_REQUEST we sent to check if a format is available.
//
INTERNAL CDdeObject::OnDataAvailable
    (LPDDE_CHANNEL  pChannel,
    HANDLE          hDdeData,
    ATOM            aItem)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::OnDataAvailable(%x)\n",this));
    CLIPFORMAT cf;
    Assert (AA_REQUESTAVAILABLE == pChannel->iAwaitAck);
    intrAssert( wIsValidAtom(aItem));

    DDEDATA * pDdeData = (DDEDATA *) GlobalLock (hDdeData);
    RetZS (pDdeData, E_OUTOFMEMORY);
    if (!pDdeData->fAckReq && aItem)
    {
            GlobalDeleteAtom (aItem);
    }
    cf = pDdeData->cfFormat;
    GlobalUnlock (hDdeData);

    void* pv = wHandleFromDdeData (hDdeData);
    if(pv) wFreeData (pv, cf);

    return NOERROR;
}



// Called for WM_DDE_DATA message. If data is from an ADVISE-ON-CLOSE and this
// is there are no more outstanding ADVISE-ON-CLOSE requests, close the
// document and end the conversation.


//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::OnData
//
//  Synopsis:   Called when a WM_DDE_DATA message is recieved. If the data
//              is from an ADVISE_ON_CLOSE, and there are no more
//              outstanding ADVISE_ON_CLOSE request, close the document
//              and end the conversation.
//
//  Effects:    The effects of this routine are complex.
//
//  Wow! What else can be said. This routine does alot of stuff in response
//  to an incoming WM_DDE_DATA message. There are basically two flavors of
//  response here. First is when we were expecting to get this result,
//  in which case we know what we wanted to do with the data. Second is
//  when the data just arrives, but we didn't expect it. These cases could
//  indicate that the server is shutting down.
//
//
//  Arguments:  [pChannel] -- The DDE channel recieving the message
//              [hDdeData] -- Handle to the data
//              [aItem] -- Atom to the item
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-16-94   kevinro   Restructured and commented
//
//  Notes:
//
//
//      Be extra careful you change this routine.
//      This is especially neccesary if you are going to exit early. The
//      way that hDdeData is free'd or kept should be understood before
//      changing.
//
//
//----------------------------------------------------------------------------
INTERNAL CDdeObject::OnData
    (LPDDE_CHANNEL  pChannel,
    HANDLE          hDdeData,
    ATOM            aItem)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::OnData(%x,pChannel=%x,hDdeData=%x,aItem=%x(%s)iAwaitAck=%x\n",
          this,
          pChannel,
          hDdeData,
          aItem,
          wAtomNameA(aItem),
          pChannel->iAwaitAck));
#ifdef _MAC
#else
    DDEDATA * lpDdeData = NULL;
    BOOL         fAck = TRUE;
    int          iAdvOpt;
    BOOL         fCallBack;
    HRESULT      hresult = NOERROR;
    BOOL fRequested = FALSE;

    intrAssert(wIsValidAtom(aItem));

    int iAwaitAck = pChannel->iAwaitAck;

    //
    // If we were waiting for this data, then we are sitting in the
    // modal loop. Set the call state on the call control interface
    // to indicate that a response was recieved. Pass NOERROR to indicate
    // that there was success. If an error is determined later, then
    // the state will be set a second time.
    //

    if ((AA_REQUEST == iAwaitAck) || (AA_REQUESTAVAILABLE == iAwaitAck))
    {
        intrDebugOut((DEB_ITRACE,
                      "::OnData(%x) AA_REQUEST/AVAILABLE \n",
                      this));

        //
        // Regardless of the outcome of this call, we have recieved a
        // response. Set the Awaiting Ack state to nothing.
        //
        pChannel->iAwaitAck = AA_NONE;

        //
        // Determine if this channels call data is valid
        //

        if (pChannel->pCD )
        {
            //CoSetAckState(pChannel->pCI, FALSE); // clear waiting flag
            intrDebugOut((DEB_ITRACE,"::OnData(%x) SetCallState(SERVERCALLEX_ISHANDLED)\n",this));
            pChannel->SetCallState(SERVERCALLEX_ISHANDLED);
        }
    }


    //
    // Check the string for aItem, looking for advise options. The variable
    // iAdvOpt will be set to indicate what type of data we just got, such
    // as ON_CHANGE, etc. If the option is invalid, then we won't know
    // what to do with it.
    //

    if ((hresult=wScanItemOptions (aItem, (int *) &iAdvOpt)) != NOERROR)
    {
        intrAssert(!"Item found with unknown advise option\n");
        LPARAM lp;
        if(!wPostMessageToServer (pChannel,
                          WM_DDE_ACK,
                          lp = MAKE_DDE_LPARAM (WM_DDE_ACK,NEGATIVE_ACK, aItem),TRUE))
        {
            hresult = RPC_E_SERVER_DIED;

        }

        //
        // Did we need to free hDdeData here? No, according to the DDE spec, if the
        // receiever responds with a NACK, then the sender is responsible for
        // freeing the data.
        //
        return hresult;
    }

    //
    // If the server sent no data, there ain't much we can do about it.
    //

    if (hDdeData == NULL)
    {
        intrDebugOut((DEB_IERROR,
                      "::OnData(%x)hDdeData is NULL!\n",
                      this));

        return(RPC_E_INVALID_PARAMETER);
    }

    //
    // Lock the data into memory so we can use it. Be careful, the way
    // this routine was written originally, there are places that free
    // and realloc hDdeData. Specifically, the call to KeepData. Carefully
    // evaluate each place where you are returning, to insure the memory
    // isn't leaked. (if you have time, please restructure this routine
    // so it is easier to understand.
    //
    if (!(lpDdeData = (DDEDATA FAR *) GlobalLock(hDdeData)))
    {
        intrDebugOut((DEB_IERROR,
                      "::OnData(%x)GlobalLock on lpDdeData failed\n",
                      this));
        //
        // (KevinRo)Did we need to free hDdeData here? I think
        // we should have if the fRelease flag was set. The old code
        // didn't. Need to research this further (ie you figure it out!)
        // [Probably not - we haven't seen significant leaks in a long time]
        //
        return ResultFromScode (E_OUTOFMEMORY);
    }

    intrDebugOut((INTR_DDE,
              "::OnData(%x) lpDdeData->cfFormat=%x\n",
              this,
              (UINT)lpDdeData->cfFormat));

    //
    // The server will set fAckReq if it wants a response.
    // don't call HIC for call where not acknoewledge is requested
    //
    fAck = lpDdeData->fAckReq;

    if (pChannel->bTerminating) {
        intrDebugOut((INTR_DDE,"::OnData(%x) Got DDE_DATA in terminate sequence\n",this));
        //
        //      this is very dangerous since the pointer on the
        //      hDocWnd does not get deleted and a further will
        //      DDE message will GPF - we need to fix this!!!
        //
        GlobalUnlock (hDdeData);
        GlobalFree (hDdeData);
        goto exitRtn;
    }

    //
    // (KevinRo) Found this comment:
    //
    //  important that we post the acknowledge first. Otherwise the
    //  messages are not in sync.
    //
    // The above comment might be intended to mean that the acknowledge needs to be
    // send now, because we may call one of the advise functions below, which in
    // turn may send another message to the OLE 1.0 server. Therefore, we ACK now,
    // so the messages to the OLE 1.0 server are in the correct order.
    //
    if (fAck)
    {
        LPARAM lp;
        if(!wPostMessageToServer (pChannel,
                          WM_DDE_ACK,
                          lp=MAKE_DDE_LPARAM(WM_DDE_ACK,POSITIVE_ACK, aItem),TRUE))
        {
            return(RPC_E_SERVER_DIED);
        }
    }

    //
    // this call is now an async call and can not be rejected be HandleIncomingMessage
    //

    if ((AA_REQUESTAVAILABLE == pChannel->iAwaitAck) && (lpDdeData->fResponse))
    {
        //
        // For some reasons, OnDataAvailable will be the one to delete this data.
        // I don't understand it, but lets roll with it. (KevinRo)
        //
        GlobalUnlock (hDdeData);
        return OnDataAvailable (pChannel, hDdeData, aItem);
    }

    //
    // If the clipboard format is binary, and the topic is aStdDocName, then this
    // OnData is a RENAME
    //
    if (lpDdeData->cfFormat == (short)g_cfBinary && aItem== aStdDocName)
    {
        // ON_RENAME
        //
        // The data should be the new name, in ANSI.
        //
        ChangeTopic ((LPSTR)lpDdeData->Value);
        GlobalUnlock (hDdeData);
        GlobalFree (hDdeData);
        return(NOERROR);
    }

    //
    // Based on iAdvOpt, determine if we can callback. This one is a little
    // hard to understand. I don't either. CanCallBack appears to return
    // true if the count is 0,1, or 3, but returns FALSE if its 2 or
    // greater than 3. There are no comments in the old code as to why
    // this is. I am leaving it, since it must have been put there for
    // a reason. See CanCallBack in ddeworker.cxx for futher (ie no) details
    //
    switch (iAdvOpt)
    {
        case ON_SAVE:
            fCallBack = CanCallBack(&m_iAdvSave);
                intrDebugOut((INTR_DDE,
                              "::OnData(%x)ON_SAVE m_iAdvSave=%x\n",
                              this,
                              m_iAdvSave));

            break;
        case ON_CLOSE:
            fCallBack = CanCallBack(&m_iAdvClose);
                intrDebugOut((INTR_DDE,
                              "::OnData(%x)ON_CLOSE m_iAdvClose=%x\n",
                              this,
                              m_iAdvClose));
            break;
        case ON_CHANGE:
            fCallBack = TRUE;
                intrDebugOut((INTR_DDE,
                              "::OnData(%x)ON_CHANGE m_iAdvClose=%x\n",
                              this,
                              m_iAdvClose));
            break;
        default:
            intrAssert( !"Unknown iAdvOpt: Somethings really broke");
    }

    // Keep the data in a cache for a future GetData call
    // which may be triggered a few lines later by the
    // SendOnDataChange().

    fRequested = lpDdeData->fResponse;


    // The call  to KeepData will change hDdeData and
    // invalidate lpDdeData. Check out KeepData for details. The net
    // result is that hDdeData is no longer valid

    GlobalUnlock (hDdeData);
    lpDdeData=NULL;

    hresult = KeepData (pChannel, hDdeData);

    //
    // This is unpleasant, but if KeepData fails, we need to
    // call SetCallState again, resetting the error code. This
    // code is such a mess that rearranging it to do
    // it in a rational way is going to be too much work given
    // the amount of time I have until shipping.
    //
    // If you have time, please simplify this code. Thanks
    //
    if (hresult != NOERROR)
    {
        //
        // At this point, hDdeData has been unlocked, and deleted by
        // the KeepData routine. Therefore, the return here doesn't
        // need to be concerned with cleaning up after hDdeData
        //
        intrDebugOut((DEB_ITRACE,
                      "::OnData(%x) KeepData failed %x\n",
                      this,
                      hresult));
        //
        // Reset the error code on the call control
        //
        if ((AA_REQUEST == iAwaitAck) || (AA_REQUESTAVAILABLE == iAwaitAck))
        {
            if (pChannel->pCD )
            {
                pChannel->SetCallState(SERVERCALLEX_ISHANDLED, hresult);
            }
        }
        goto exitRtn;
    }

    if (fRequested)
    {
        // We REQUESTed the data. So, we are no longer waiting.
        // Do NOT call SendOnDataChange because the data hasn't
        // really changed again, we just requested it to satisfy
        // a call to GetData, which was probably called by the
        // real SendOnDataChange.
        intrDebugOut((INTR_DDE,
                      "::OnData(%x) fRequested DATA\n",
                      this));

        iAwaitAck = NULL;
        hresult = NOERROR;
        goto exitRtn;

    }

    //
    // Now we have decided this is data we had not asked for. This makes
    // it a change/close/saved notificiation.
    //
    intrDebugOut((INTR_DDE,"::OnData(%x) Non requested DATA\n",this));
    pChannel->AddReference();
    if (fCallBack && iAdvOpt != ON_CHANGE)
    {
        // ON_CHANGE will be handled by OleCallback, below

        intrDebugOut((INTR_DDE,
                      "::OnData(%x)Dispatching SendOnDataChange\n",
                      this));


        //
        // There are a couple of things to note about the following. First,
        // the iid of the call doesn't matter. Since OLE 1.0 servers don't
        // do nested calls, the original LID (Logical ID) can be any random
        // value. Therefore, we don't initalize it.
        //
        // According to JohannP, the calltype of these calls is supposed
        // to be CALLTYPE_SYNC. I don't fully understand why they are.
        // I am taking is decision on faith.
        //
        // Using the new call control interfaces, we do the following.
        //

        DDEDISPATCHDATA ddedispdata;
        DISPATCHDATA    dispatchdata;
        DWORD           dwFault;

        IUnknown *pUnk = m_pDataAdvHolder;

        //
        // We are about to call method #6 in the IDataAdviseHolder interface,
        // which is SendOnDataChange
        //

        RPCOLEMESSAGE   rpcMsg = {0};
        RPC_SERVER_INTERFACE RpcInterfaceInfo;
        rpcMsg.reserved2[1] = &RpcInterfaceInfo;

        *MSG_TO_IIDPTR(&rpcMsg) = IID_IDataAdviseHolder;


        rpcMsg.Buffer = &dispatchdata;
        rpcMsg.cbBuffer = sizeof(dispatchdata);
        rpcMsg.iMethod = 6;

        dispatchdata.scode = S_OK;
        dispatchdata.pData = (LPVOID) &ddedispdata;

        ddedispdata.pCDdeObject = this;
        ddedispdata.wDispFunc = DDE_DISP_SENDONDATACHANGE;
        ddedispdata.iArg = iAdvOpt;

        // package as RPCMESSAGE and call STAInvoke
        IRpcStubBuffer * pStub = &m_RpcStubBuffer;
        hresult = STAInvoke(&rpcMsg, CALLCAT_SYNCHRONOUS, pStub,
                            pChannel, NULL, NULL, &dwFault );
    }
    if (fCallBack )
    {
        // in 1.0 ON_CLOSE comes with data
        if (iAdvOpt==ON_CLOSE)
        {

            intrDebugOut((INTR_DDE,
                          "::OnData(%x) iAdvOpt == ON_CLOSE, send ON_SAVE\n",
                          this));

            m_fGotCloseData = TRUE;

            hresult = OleCallBack(ON_SAVE,pChannel);
            if (hresult != NOERROR)
            {
                goto errRel;
            }

            //ErrRtnH (DdeHandleIncomingCall(pChannel->hwndSvr, CALLTYPE_TOPLEVEL) );
            //ErrRtnH (OleCallBack (ON_SAVE));
        }

        // check if app can handle this call
        // we do not need to call HIC for SendOnClose

        hresult = OleCallBack (iAdvOpt,pChannel);
    }

errRel:
    // Don't use pChannel after this. It can get deleted. (srinik)
    if (pChannel->ReleaseReference() == 0)
    {
        m_pDocChannel = NULL;
    }

exitRtn:
    if (!fAck && aItem)
    {
        GlobalDeleteAtom (aItem);
    }
  return hresult;
#endif _MAC
}

//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::OleCallBack
//
//  Synopsis:   Send all the right notifications whan a Save or Close happens.
//
//  Effects:    OleCallBack is a double duty function. It is called in two
//              different cases.
//
//              First, is to setup the callback, and call HandleIncomingCall.
//              Second is from DispatchCall() in the CDdeChannelControl.
//
//              The reason for doing it this way is we localize the setup
//              and processing of these calls to one routine. Therefore,
//              we can go to one spot in the code to find all of the call
//              back information.
//
//  Arguments:  [iAdvOpt] -- Which Advise operation to perform
//              [pChannel] -- Which channel is being called back
//
//  Requires:   pChannel == NULL, and the AdviseHolders are called.
//              pChannel != NULL, and the call is setup, and HandleIncomingCall
//                          is setup.
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-23-94   kevinro   Created
//
//  Notes:
//
//  WARNING: this is poor code.  One of the major problems you need
//  to know about is that the CDdeObject may go away as part of the normal
//  processing of some of the below. Be very careful about any processing
//  that might occur after an ON_CLOSE
//
//----------------------------------------------------------------------------
INTERNAL CDdeObject::OleCallBack (int iAdvOpt, LPDDE_CHANNEL pChannel)
{
    HRESULT hresult = NOERROR;
    DDEDISPATCHDATA ddedispdata;
    DISPATCHDATA    dispatchdata;
    RPCOLEMESSAGE   rpcMsg = {0};
    IUnknown        *pUnk;

    RPC_SERVER_INTERFACE RpcInterfaceInfo;
    rpcMsg.reserved2[1] = &RpcInterfaceInfo;

    //
    // If the channel isn't NULL, then setup the data structures for calling
    // off to the call control.
    //
    if (pChannel != NULL)
    {
        //
        // Only do this work if we really have to
        //

        dispatchdata.scode = S_OK;
        dispatchdata.pData = (LPVOID) &ddedispdata;

        ddedispdata.pCDdeObject = this;
        ddedispdata.wDispFunc = DDE_DISP_OLECALLBACK;
        ddedispdata.iArg = iAdvOpt;
    }

    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::OleCallBack(%x,iAdvOpt=%x,pChannel=%x)\n",
                  this,
                  iAdvOpt,
                  pChannel));

    //
    // Determine what needs to be done, based on the iAdvOpt. This should be
    // one of the handled cases below, otherwise its an error.
    //
    switch (iAdvOpt)
    {
    case ON_CLOSE:
        if (pChannel != NULL)
        {
            intrDebugOut((DEB_ITRACE,
                          "::OleCallBack(%x) setup for ON_CLOSE\n",
                          this));

            pUnk = m_pOleAdvHolder;

            *MSG_TO_IIDPTR(&rpcMsg) = IID_IOleAdviseHolder;
            // IOleAdviseHolder::SendOnClose is method 8
            rpcMsg.iMethod = 8;
        }
        else
        {
            intrDebugOut((DEB_ITRACE,"::OleCallBack(%x) ON_CLOSE\n",this));
            DeclareVisibility (FALSE);
            RetZ (!m_fDidSendOnClose); // This SendOnClose should happen 1st
                                      // Don't let OnTerminate() do it too
            hresult = SendOnClose();

            //
            // WARNING WARNING WARNING: SendOnClose() may have caused the
            // destruction of this CDdeObject. Touch nothing on the way
            // out. Actually, if you have time, which I currently don't,
            // see what you can do with reference counting tricks to
            // insure this object doesn't die during this callback.
            // Its a tricky problem, and we are shipping in 2 weeks.
            // (KevinRo 8/6/94)
            //
        }
        break;

    case ON_SAVE:
        if (pChannel != NULL)
        {
            intrDebugOut((DEB_ITRACE,
                          "::OleCallBack(%x) setup for ON_SAVE\n",
                          this));

            if (m_pOleClientSite == NULL)
            {
                pUnk = m_pOleClientSite;
                *MSG_TO_IIDPTR(&rpcMsg) = IID_IOleClientSite;
                // IOleClientSite::SaveObject method 7
                rpcMsg.iMethod = 7;
            }
            else
            {
                // Going to call the IOleAdviseHolder

                pUnk = m_pOleAdvHolder;
                *MSG_TO_IIDPTR(&rpcMsg) = IID_IOleAdviseHolder;
                // IOleAdviseHolder::SendOnSave method 7
                // (Yes, same ordinal as above, I double checked)
                rpcMsg.iMethod = 7;
            }
        }
        else
        {

            intrDebugOut((DEB_ITRACE,"::OleCallBack(%x) ON_SAVE\n",this));
            if (m_pOleClientSite)
            {
                // We just got data from the server, so we don't want to
                // ask him for it again when the container does a save.
                m_fUpdateOnSave = FALSE;

                // Harvard Graphics Access Violates if SaveObject is called on the ClientSite from
                // within OleCreateFromData.
                __try
                {
                    m_pOleClientSite->SaveObject();
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    intrDebugOut((DEB_IWARN ,"Warning: Exception in SaveObject\n"));
                }

                // SendOnSave is called in PS::SaveCompleted
                m_fUpdateOnSave = TRUE;
            }
            else
            {
                // Link case
                RetZS (m_pOleAdvHolder, E_OUTOFMEMORY);
                m_pOleAdvHolder->SendOnSave();
            }
        }
        break;

    case ON_CHANGE:
        if (pChannel != NULL)
        {
                // Going to call the IDataAdviseHolder

                pUnk = m_pDataAdvHolder;
                *MSG_TO_IIDPTR(&rpcMsg) = IID_IDataAdviseHolder;
                // IDataAdviseHolder::SendOnDataChange method 6
                rpcMsg.iMethod = 6;

        }
        else
        {
            RetZS (m_pDataAdvHolder, E_OUTOFMEMORY);
            intrDebugOut((DEB_ITRACE,"::OleCallBack(%x) ON_CHANGE\n",this));
            hresult = SendOnDataChange (ON_CHANGE);
        }
        break;

    default:


        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::OleCallBack(%x,iAdvOpt=%x) UNKNOWN iAdvOpt\n",
                      this,
                      iAdvOpt));
        intrAssert(!"Unexpected iAdvOpt");
        return(E_UNEXPECTED);
        break;
    }

    //
    // There are a couple of things to note about the following. First,
    // the iid of the call doesn't matter. Since OLE 1.0 servers don't
    // do nested calls, the original LID (Logical ID) can be any random
    // value. Therefore, we don't initalize it.
    //
    // According to JohannP, the calltype of these calls is supposed
    // to be CALLTYPE_SYNCHRONOUS. I don't fully understand why they are.
    // I am taking is decision on faith.
    //
    //
    // Its possible that during the handling of this call that this object
    // will get deleted. This is a pain in the butt. This means that anything
    // used after this call MUST be protected. lpCallCont happens to be one of
    // these. We have been having problems with lpCallCont being released as
    // part of the object cleanup. The call control code will access member
    // variables on its way out of the HandleDispatch. We need to bracket
    // the call below so this doesn't happen.
    //
    if (pChannel != NULL)
    {
        // dont have to worry about call control going away.
        // package as RPCMESSAGE and call STAInvoke

        DWORD           dwFault;

        rpcMsg.Buffer = &dispatchdata;
        rpcMsg.cbBuffer = sizeof(dispatchdata);

        IRpcStubBuffer * pStub = &m_RpcStubBuffer;
        hresult = STAInvoke(&rpcMsg, CALLCAT_SYNCHRONOUS, pStub,
                            pChannel, NULL, NULL, &dwFault);
    }

    return hresult;
}


INTERNAL CDdeObject::SendOnDataChange
    (int iAdvOpt)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::SendOnDataChange(%x)\n",this));
    HRESULT hresult;
    RetZS (m_pDataAdvHolder, E_OUTOFMEMORY);
    m_fDoingSendOnDataChange = TRUE;
    hresult = m_pDataAdvHolder->SendOnDataChange (&m_Data,
                                                  DVASPECT_CONTENT,
                                                  0);
    if (ON_CLOSE==iAdvOpt)
    {
        hresult = m_pDataAdvHolder->SendOnDataChange (&m_Data,
                                                      DVASPECT_CONTENT,
                                                      ADVF_DATAONSTOP);
    }
    m_fDoingSendOnDataChange = FALSE;
    return hresult;
}




INTERNAL CDdeObject::SendOnClose
    (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::SendOnClose(%x)\n",this));
    RetZS (m_pOleAdvHolder, E_OUTOFMEMORY);
    m_fDidSendOnClose = TRUE;
    RetErr (m_pOleAdvHolder->SendOnClose() );
    return NOERROR;
}




INTERNAL CDdeObject::OnTerminate
    (LPDDE_CHANNEL pChannel,
    HWND hwndPost)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::OnTerminate(%x,pChannel=%x,hwndPost=%x)\n",
                  this,
                  pChannel,
                  hwndPost));

    //
    // If the hwndPost and hwndSvr are different, then it is one of two
    // cases. We could have recieved more than one Acknowlege during our
    // initiate, in which case the count iExtraTerms would have been
    // incremented, and this terminate is accounted for iExtraTerms.
    //
    // The other case is that we were terminated by a window that was
    // NOT the window we were conversing with.
    //
    if (pChannel->hwndSvr != hwndPost)
    {
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Extra terms is 0x%x \n",
                      this,
                      pChannel->iExtraTerms));

        //
        // iExtraTerms shouldn't go below zero. If it does, something
        // has gone wrong. We have been seeing some problems with the
        // HWND mapping layer in the past. If the following condition
        // ever trips, then it is possible that another mapping
        // problem has been seen.
        //
#if DBG == 1
        if((pChannel->iExtraTerms == 0 ) &&
           ((PtrToUlong (pChannel->hwndSvr)) & (0xffff)) == (PtrToUlong (hwndPost) & (0xffff)))
        {
            intrDebugOut((DEB_ERROR,
                          "*** OnTerminate expected hwnd=%x got hwnd=%x ***\n",
                          pChannel->hwndSvr,hwndPost));

            intrDebugOut((DEB_ERROR,
                          "\n*** Call KevinRo or SanfordS ***\n\n",
                          pChannel->hwndSvr,hwndPost));

        }
#endif
        --pChannel->iExtraTerms;

        intrAssert((pChannel->iExtraTerms >= 0) && "Call KevinRo or SanfordS");
        return NOERROR;
    }
    if (m_wTerminate == Terminate_Detect) {
        // we should only detect the call but not execute the code
        // set the state to Received
        m_wTerminate = Terminate_Received;
        pChannel->iAwaitAck = NULL;
        // Since Excel incorrectly did not send an ACK, we need to
        // delete the handle in the DDE message ourselves.
        if (pChannel->hCommands)
        {
            GlobalFree (pChannel->hCommands);
            pChannel->hCommands = NULL;
        }
        //CoSetAckState(pChannel->pCI, FALSE);
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Terminate_Detect SERVERCALLEX_ISHANDLED\n",
                      this));
        pChannel->SetCallState(SERVERCALLEX_ISHANDLED, RPC_E_SERVER_DIED);
        return NOERROR;
    }

    RetZ (pChannel);
    ChkDR (this);

    if (!pChannel->bTerminating)
    {
        // Got unprompted terminate
        BOOL    bBusy;

        // Necessary safety bracket
        m_pUnkOuter->AddRef();

        bBusy = wClearWaitState (pChannel);

        if (pChannel->iAwaitAck || bBusy)
        {
            pChannel->iAwaitAck = NULL;
            //CoSetAckState(pChannel->pCI, FALSE);
            intrDebugOut((DEB_ITRACE,"::OnTerminate(%x) !bTerminating SERVERCALLEX_ISHANDLED,RPC_E_DDE_UNEXP_MSG\n",this));
            pChannel->SetCallState(SERVERCALLEX_ISHANDLED, RPC_E_DDE_UNEXP_MSG);
        }

        if (!m_fDidSendOnClose)
        {
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) SendOnClose from terminate\n",
                      this));

            BOOL f= m_fNoStdCloseDoc;
            m_fNoStdCloseDoc = TRUE;

            DeclareVisibility (FALSE);
            SendOnClose();

            m_fNoStdCloseDoc = f;
        }
        else
        {
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Already did SendOnClose\n",
                      this));
            Puts ("Already did SendOnClose\n");
        }
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Posting DDE_TERMINATE as reply\n",
                      this));

        wPostMessageToServer (pChannel, WM_DDE_TERMINATE, NULL,FALSE);

        // The terminate that we are sending itself is a reply, so we don't
        // need to do WaitForReply.
        DeleteChannel (pChannel);

        // Necessary safety bracket
        m_pUnkOuter->Release();
    }
    else
    {
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Received DDE_TERMINATE in reply\n",
                      this));

        // We sent the WM_DDE_TERMINATE and we got the acknowledge for it
        pChannel->hwndSvr = NULL;
        pChannel->iExtraTerms = NULL;
        pChannel->iAwaitAck = NULL;
        //CoSetAckState(pChannel->pCI, FALSE);
        intrDebugOut((DEB_ITRACE,"::OnTerminate(%x) bTerminating SERVERCALLEX_ISHANDLED\n",this));
        pChannel->SetCallState(SERVERCALLEX_ISHANDLED);
    }
    Puts ("OnTerminate() done.\n");
    return NOERROR;
}




INTERNAL_(BOOL) CDdeObject::AllocDdeChannel
    (LPDDE_CHANNEL * lplpChannel, BOOL fSysWndProc)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::AllocDdeChannel(%x,fSysWndClass=%x)\n",
          this,
          fSysWndProc));

    // Initialize DDE window class if not already done.
    if (!DDELibMain(NULL, 0, 0, NULL))
    {
        intrAssert(!"CDdeObject::AllocDdeChannel DDELibMain failed");
        return FALSE;
    }

    //
    // Now try to allocate a channel
    //

    if (!(*lplpChannel =  (LPDDE_CHANNEL) new DDE_CHANNEL ))
    {
        //
        // This failed
        //
        intrAssert(*lplpChannel != NULL);
        return FALSE;
    }

    (*lplpChannel)->m_cRefs = 1;
    (*lplpChannel)->hwndSvr         = NULL;
    (*lplpChannel)->bTerminating    = FALSE;
    (*lplpChannel)->wTimer          = NULL;
    (*lplpChannel)->hDdePoke        = NULL;
    (*lplpChannel)->hCommands       = NULL;
    (*lplpChannel)->hopt            = NULL;
    (*lplpChannel)->bFreedhopt      = FALSE;
    (*lplpChannel)->dwStartTickCount= 0;
    (*lplpChannel)->msgFirst        = 0;
    (*lplpChannel)->msgLast         = 0;
    (*lplpChannel)->fRejected       = FALSE;
    (*lplpChannel)->wChannelDeleted = 0;
    //(*lplpChannel)->pCI             = NULL;
    (*lplpChannel)->pCD             = NULL;

    if (!((*lplpChannel)->hwndCli = DdeCreateWindowEx(0,
                                                      gOleDdeWindowClass,
                                                      TEXT("DDE Channel"),
                                                      WS_CHILD,
                                                      0,0,0,0,
                                                      (HWND)TLSGetDdeClientWindow(),
                                                      NULL,
                                                      hinstSO,
                                                      NULL)))
    {
        intrAssert (!"Could not create AllocDdeChannel window");

        //
        // DeleteChannel will give back the CallControl
        //

        DeleteChannel(*lplpChannel);
        *lplpChannel = NULL;
        return FALSE;
    }

    // set the appropriate window procedure
    if (fSysWndProc)
    {
        SetWindowLongPtr ((*lplpChannel)->hwndCli, GWLP_WNDPROC, (LONG_PTR)SysWndProc);
    }
    else
    {
        SetWindowLongPtr ((*lplpChannel)->hwndCli, GWLP_WNDPROC, (LONG_PTR)ClientDocWndProc);
    }

    SetWindowLongPtr ((*lplpChannel)->hwndCli, 0, (LONG_PTR) this);
    return TRUE;
}



INTERNAL_(BOOL) CDdeObject::InitSysConv()
{
    DWORD dwResult;
    intrDebugOut((DEB_ITRACE,"CDdeObject::InitSysConv(%x)\n",this));

    dwResult = wInitiate (m_pSysChannel, m_aClass, aOLE);
    if (!dwResult)
    {
       intrDebugOut((DEB_ITRACE,"\t::InitSysConv(%x) Try aSysTopic\n",this));
       dwResult = wInitiate (m_pSysChannel, m_aClass, aSysTopic);
    }

    if (!dwResult)
    {
       intrDebugOut((DEB_ITRACE,"\t::InitSysConv(%x) is failing\n",this));
    }
    return(dwResult);
}



INTERNAL_(void) CDdeObject::SetTopic(ATOM aTopic)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::SetTopic(%x)\n",this));
    intrAssert(wIsValidAtom(aTopic));
    if (m_aTopic)
        GlobalDeleteAtom (m_aTopic);

    m_aTopic = aTopic;
}



INTERNAL CDdeObject::TermConv
    (LPDDE_CHANNEL pChannel,
    BOOL fWait)     // Default==TRUE.  FALSE only in ProxyManager::Disconnect
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::TermConv(%x,pChannel=%x)\n",
                  this,
                  pChannel));

    HRESULT hres;
    if (!pChannel)
    {
        return NOERROR;
    }

    pChannel->bTerminating = TRUE;

    hres = SendMsgAndWaitForReply(pChannel,
                                 AA_TERMINATE,
                                 WM_DDE_TERMINATE,
                                 0,
                                 FALSE,
                                 /*fStdCloseDoc*/FALSE,
                                 /*fDetectTerminate*/ FALSE,
                                 fWait);
    if (pChannel==m_pDocChannel)
    {
        DeclareVisibility (FALSE);
        if (!m_fDidSendOnClose)
        {
            SendOnClose();
        }
    }

    DeleteChannel (pChannel);
    intrDebugOut((DEB_ITRACE,"::TermConv(%x) returns %x\n",this,hres));
    return hres;
}




INTERNAL_(void) CDdeObject::DeleteChannel (LPDDE_CHANNEL pChannel)
{
    BOOL fDocChannel = FALSE;
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::DeleteChannel(%x,pChannel=%x)\n",
                  this,
                  pChannel));

    if (pChannel == NULL)
    {
        return;
    }

    if (pChannel == m_pDocChannel)
        fDocChannel = TRUE;



    // delete any data if we were in busy mode.
    wClearWaitState (pChannel);

    if (pChannel == m_pDocChannel)
    {
        intrDebugOut((DEB_ITRACE,
                      "::DeleteChannel(%x)Clean up pDocChannel\n",
                      this));

        // Cleanup per-conversation information
        m_fDidSendOnClose = FALSE;
        m_fDidStdCloseDoc = FALSE;
        m_ConnectionTable.Erase();
        m_iAdvSave = 0;
        m_iAdvClose= 0;
        m_fWasEverVisible = FALSE;
        m_fGotCloseData = FALSE;
        if (m_ptd)
        {
            delete m_ptd;
            m_ptd = NULL;
        }
        if (m_pstg)
        {
            m_pstg->Release();
            m_pstg = NULL;
        }
        if (m_pDataAdvHolder)
        {
            Verify (0==m_pDataAdvHolder->Release());
        }
        CreateDataAdviseHolder (&m_pDataAdvHolder);
        if (m_pOleAdvHolder)
        {
            m_pOleAdvHolder->Release(); // may not return 0 if we are
                                        // in a SendOnClose
        }
        CreateOleAdviseHolder (&m_pOleAdvHolder);
    }

    if (pChannel->hwndCli)
    {
        intrDebugOut((DEB_ITRACE,
                      "::DeleteChannel(%x)Destroy hwndCli(%x)\n",
                      this,
                      pChannel->hwndCli));

        Assert (IsWindow (pChannel->hwndCli));
        Assert (this==(CDdeObject *)GetWindowLongPtr (pChannel->hwndCli, 0));
        Verify (SSDestroyWindow (pChannel->hwndCli));
    }

    if (pChannel == m_pDocChannel)
    {
        m_pDocChannel = NULL;
    }
    else
    {
        intrAssert(pChannel == m_pSysChannel);
        m_pSysChannel = NULL;
    }


    // Channel will be deleted in the modallp.cpp
    // if flag is on.

    if (pChannel->wChannelDeleted == Channel_InModalloop)
    {
        intrDebugOut((DEB_ITRACE,
                      "::DeleteChannel(%x) Channel(%x) in Modal Loop\n",
                      this,pChannel));

        pChannel->wChannelDeleted = Channel_DeleteNow;
    }
    else
    {
        if (pChannel->ReleaseReference() == 0)
            pChannel = NULL;
    }

    if (fDocChannel)
        m_pDocChannel = pChannel;
}

const WCHAR  EMB_STR[]= OLESTR(" -Embedding ") ;

INTERNAL_(BOOL) CDdeObject::LaunchApp (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::LaunchApp(%x)\n",this));

    STARTUPINFO startInfo;
    PROCESS_INFORMATION procInfo;
    BOOL        fProcStarted;
    WCHAR       cmdline[MAX_PATH + sizeof(EMB_STR)];
    WCHAR       exeName[MAX_PATH + sizeof(cmdline)];
    //
    // Init all fields of startInfo to zero
    //
    memset((void *)&startInfo,0,sizeof(startInfo));
    startInfo.cb = sizeof(STARTUPINFO);

    //
    // The normal startup is set here.
    //
    startInfo.wShowWindow = SW_NORMAL;
    startInfo.dwFlags = STARTF_USESHOWWINDOW;

    m_fDidLaunchApp = FALSE;


    DWORD dw;

    //
    // Do our best to find the path
    //
    intrAssert(wIsValidAtom(m_aExeName));

    if (m_aExeName == 0)
    {
        //
        // There is no exe name to execute. Can't start it.
        //
        return(FALSE);
    }

    dw = SearchPath(NULL,wAtomName(m_aExeName),NULL,MAX_PATH,exeName, NULL);

    if ((dw == 0) || (dw > MAX_PATH))
    {
        intrDebugOut((DEB_ITRACE,
                      "::LaunchApp(%x) SearchPath failed. Do Default",this));
        //
        // SearchPath failed. Use the default
        //
        GlobalGetAtomName (m_aExeName, exeName, MAX_PATH);
    }

    memcpy(cmdline, EMB_STR,sizeof(EMB_STR));

    if (m_ulObjType == OT_LINK)
    {
        intrAssert(wIsValidAtom(m_aTopic));
       // File name
       Assert (wAtomName (m_aTopic));

       lstrcatW (cmdline, wAtomName (m_aTopic));
    }

    if (m_clsid == CLSID_ExcelWorksheet  // apps that show themselves
        || m_clsid == CLSID_ExcelMacrosheet // when they're not supposed to
        || m_clsid == CLSID_ExcelChart
        || m_clsid == CLSID_PBrush)
    {
       startInfo.wShowWindow = SW_SHOWMINNOACTIVE;
    }

    //
    // According to the spec, the most robust way to start the app is to
    // only use a cmdline that consists of the exe name, followed by the
    // command line arguments.
    //

    lstrcatW(exeName,cmdline);

    Assert((lstrlenW(exeName)+1) < sizeof(exeName));

    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::LaunchApp(%x) Starting '%ws' \n",
                  this,
                  exeName));

    if (IsWOWThread() && IsWOWThreadCallable())
    {
        HRESULT hr;

        hr = g_pOleThunkWOW->WinExec16(exeName, startInfo.wShowWindow);

        fProcStarted = SUCCEEDED(hr);

#if DBG==1
        if (!fProcStarted)
        {
            intrDebugOut((DEB_ITRACE,
                        "::LaunchApp(%x) in Wow FAILED(%x) TO START %ws \n",
                        this,
                        hr,
                        exeName));
        }
#endif
    }
    else
    {
        fProcStarted = CreateProcess(NULL,
                                     exeName,
                                     NULL,
                                     NULL,
                                     FALSE,
                                     0,
                                     NULL,
                                     NULL,
                                     &startInfo,
                                     &procInfo);
        if (fProcStarted)
        {
           //
           // Let's give the server a chance to register itself. On NT,
           // CreateProcess gets the other process going, but returns
           // to let it run asynchronously. This isn't good, since we
           // need some way of knowing when it has started, so we can
           // send the DDE_INITIATES 'after' they create their DDE
           // window.
           //
           // Maximum timeout we want here shall be set at 30 seconds.
           // This should give enough time for even a 16bit WOW app to
           // start. This number was picked by trial and error. Normal
           // apps that go into an InputIdle state will return as soon
           // as they are ready. Therefore, we normally won't wait
           // the full duration.
           //

           ULONG ulTimeoutDuration = 30000L;

           //
           // Now modify this start time to handle classes
           // that have known problems. This list includes:
           //

           switch(WaitForInputIdle(procInfo.hProcess, ulTimeoutDuration))
           {
           case 0:
               intrDebugOut((DEB_ITRACE,
                      "::LaunchApp, %ws started\n",
                      exeName));
                break;
           case WAIT_TIMEOUT:
               intrDebugOut((DEB_ITRACE,
                      "::LaunchApp, %ws wait timeout at %u (dec) ms. Go Anyway\n",
                      exeName,
                  ulTimeoutDuration));
               break;
           default:
               intrDebugOut((DEB_ITRACE,
                      "::LaunchApp, %ws unknown condition (%x)\n",
                      exeName,
                      GetLastError()));
           }
           //
           // We are already done with the Process and Thread handles
           //
           CloseHandle(procInfo.hProcess);
           CloseHandle(procInfo.hThread);
        }
        else
        {
            intrDebugOut((DEB_ITRACE,
                        "::LaunchApp(%x) FAILED(%x) TO START %ws \n",
                        this,
                        GetLastError(),
                        exeName));
        }
    }

    if (fProcStarted)
    {
        // If we ran the server, it should not be visible yet.
        DeclareVisibility (FALSE);
        m_fDidLaunchApp = TRUE;
    }

    return fProcStarted;
}


INTERNAL CDdeObject::MaybeUnlaunchApp (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::MaybeUnlaunchApp(%x)\n",this));
    if (m_fDidLaunchApp
        && !m_fDidGetObject
        && (m_clsid == CLSID_ExcelWorksheet
            || m_clsid == CLSID_ExcelMacrosheet
            || m_clsid == CLSID_ExcelChart))
    {
        return UnlaunchApp();
    }
    return NOERROR;
}




INTERNAL CDdeObject::UnlaunchApp (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::UnlaunchApp(%x)\n",this));
    HANDLE hCommands;
    HRESULT hresult = NOERROR;
    RetZS (AllocDdeChannel (&m_pSysChannel, TRUE), E_OUTOFMEMORY);
    ErrZS (InitSysConv(), E_UNEXPECTED);
    ErrRtnH (PostSysCommand (m_pSysChannel,(LPSTR) &achStdExit, /*bStdNew*/FALSE,
                             /*fWait*/FALSE));
    hCommands = m_pSysChannel->hCommands;
    hresult = TermConv (m_pSysChannel);

    // Since Excel incorrectly did not send an ACK, we need to
    // delete the handle ("[StdExit]") in the DDE message ourselves.
    if (hCommands)
        GlobalFree (hCommands);

    return hresult;

  errRtn:
    DeleteChannel (m_pSysChannel);
    return hresult;
}




INTERNAL CDdeObject::Execute
    (LPDDE_CHANNEL pChannel,
    HANDLE hdata,
    BOOL fStdCloseDoc,
    BOOL fWait,
    BOOL fDetectTerminate)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::Execute(%x,hdata=%x)\n",this,hdata));

    LPARAM lp=MAKE_DDE_LPARAM(WM_DDE_EXECUTE,0, hdata);

    HRESULT hr = SendMsgAndWaitForReply (pChannel,
                                         AA_EXECUTE,
                                         WM_DDE_EXECUTE,
                                         lp,
                                         TRUE,
                                         fStdCloseDoc,
                                         fDetectTerminate,
                                         fWait);
    if (hr == DDE_CHANNEL_DELETED)
    {
        // the channel was deleted already so dont access it!
        return S_OK;
    }

    if (SUCCEEDED(hr))
    {
        if (fStdCloseDoc)
        {
            // Prepare to free the handle if Excel does not send an Ack
            pChannel->hCommands = hdata;
        }
        return hr;
    }

    GlobalFree (hdata);
    return ReportResult(0, RPC_E_DDE_POST, 0, 0);
}




INTERNAL_(HRESULT) CDdeObject::AdviseOn (CLIPFORMAT cfFormat, int iAdvOn)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::AdviseOn(%x,cfFormat=%x,iAdvOn=%x)\n",
                  this,
                  cfFormat,
                  iAdvOn));

    HANDLE          hopt=NULL;
    DDEADVISE *  lpopt=NULL;
    ATOM            aItem=(ATOM)0;
    HRESULT         hresult = ReportResult(0, E_UNEXPECTED, 0, 0);

    RetZ (m_pDocChannel);

    if (NOERROR == m_ConnectionTable.Lookup (cfFormat, NULL))
    {
        // We already got a call to DataObject::Advise on this format.
        intrDebugOut((DEB_ITRACE,
                      "::AdviseOn(%x) Advise had been done on cfFormat=%x\n",
                      this,
                      cfFormat));
        return NOERROR;
    }

    UpdateAdviseCounts (cfFormat, iAdvOn, +1);

    if (m_fDidSendOnClose)
    {
        intrDebugOut((DEB_ITRACE,"::AdviseOn(%x)Ignoring Advise because we are closing\n",this));
        return NOERROR;
    }

    if (!(hopt = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, sizeof(DDEADVISE))))
    {
        intrDebugOut((DEB_ITRACE,"::AdviseOn(%x)GlobalAlloc returned NULL\n",this));
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }


    if (!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
    {
        intrDebugOut((DEB_ITRACE,"::AdviseOn(%x)GlobalLock returned NULL\n",this));
        GlobalFree (hopt);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    lpopt->fAckReq = TRUE;
    lpopt->fDeferUpd = FALSE;
    lpopt->cfFormat = cfFormat;
    m_pDocChannel->hopt = hopt;

    if (iAdvOn == ON_RENAME)
    {
        aItem = wDupAtom (aStdDocName);
        intrAssert(wIsValidAtom(aItem));
    }
    else
    {
        intrAssert(wIsValidAtom(m_aItem));
        aItem = wExtendAtom (m_aItem, iAdvOn);
        intrAssert(wIsValidAtom(aItem));
    }

    intrDebugOut((DEB_ITRACE,
                  "::AdviseOn(%x) lpopt->cfFormat = %x, aItem=%x (%ws)\n",
                  this,
                  lpopt->cfFormat,
                  aItem,
                  wAtomName(aItem)));

    GlobalUnlock (hopt);

    LPARAM lp=MAKE_DDE_LPARAM(WM_DDE_ADVISE,hopt,aItem);
    hresult =SendMsgAndWaitForReply (m_pDocChannel,
                                     AA_ADVISE,
                                     WM_DDE_ADVISE,
                                     lp,
                                     TRUE);
    if ( FAILED(hresult) )
    {
        intrDebugOut((DEB_ITRACE,"::AdviseOn(%x)wPostMessageToServer failed\n",this));
        if (aItem)
            GlobalDeleteAtom (aItem);
        
        if (hopt && !m_pDocChannel->bFreedhopt)
            GlobalFree (hopt);
    
        hresult = (RPC_E_DDE_NACK == hresult) ? DV_E_CLIPFORMAT : hresult;
        intrDebugOut((DEB_ITRACE,
                      "::AdviseOn(%x) errRet, AdviseRejected, returning %x\n",
                      this,hresult));
    }

    return hresult;
}

INTERNAL CDdeObject::UpdateAdviseCounts
    (CLIPFORMAT cf,
    int         iAdvOn,
    signed int  cDelta)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::UpdateAdviseCounts(%x)\n",this));
    if (cf==g_cfBinary)
        return NOERROR;

    // Update m_iAdv* flags
    #define macro(Notif, NOTIF) \
    if (iAdvOn == ON_##NOTIF)   \
       m_iAdv##Notif += cDelta; \
    if (m_iAdv##Notif < 0)      \
        m_iAdv##Notif = 0;      \
    else if (m_iAdv##Notif > 2) \
        m_iAdv##Notif = 2;

    macro (Close, CLOSE)
    macro (Save,  SAVE)
    macro (Change,CHANGE)
    #undef macro

    Assert (m_iAdvClose < 3 && m_iAdvSave < 3 && m_iAdvChange < 3);
    Assert (m_iAdvClose >= 0 && m_iAdvSave >= 0 && m_iAdvChange >= 0);

    if (cf == g_cfNative)
    {
        if (iAdvOn != ON_CHANGE)
            m_fDidAdvNative = (cDelta > 0);
        else
            intrDebugOut((DEB_ITRACE,
                          "::UpdateAdviseCounts(%x)Asked advise on cfNative\n",
                          this));
    }

    return NOERROR;
}




INTERNAL CDdeObject::UnAdviseOn (CLIPFORMAT cfFormat, int iAdvOn)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::UnAdviseOn(%x,cfFormat=%x,iAdvOn=%x)\n",
                  this,cfFormat,iAdvOn));
    HRESULT hr;
    ATOM aItem= (ATOM)0;

    RetZ (m_pDocChannel);
    UpdateAdviseCounts (cfFormat, iAdvOn, -1);
    if (m_fDidSendOnClose)
    {
        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::UnAdviseOn(%x) Ignored because closing\n",
                      this));
        return NOERROR;
    }
    if (wTerminateIsComing (m_pDocChannel))
    {
        // We already did a StdCloseDocument, so the server is not willing
        // to do an unadvise even though the default hanlder asked us to.
        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::UnAdviseOn(%x) Terminate coming\n",
                      this));
        return NOERROR;
    }

    if (iAdvOn == ON_RENAME)
    {
        aItem = wDupAtom (aStdDocName);
        intrAssert(wIsValidAtom(aItem));
    }
    else
    {
        intrAssert(wIsValidAtom(m_aItem));
        aItem = wExtendAtom (m_aItem, iAdvOn);
        intrAssert(wIsValidAtom(aItem));
    }


    // Wait For Reply
    hr = SendMsgAndWaitForReply (m_pDocChannel,
                                 AA_UNADVISE,
                                 WM_DDE_UNADVISE,
                                 MAKE_DDE_LPARAM (WM_DDE_UNADVISE,cfFormat,aItem),
                                 FALSE,
                                 FALSE);
    if (hr != NOERROR && hr != RPC_E_DDE_NACK)
    {
        if (aItem)
            GlobalDeleteAtom (aItem);
        intrDebugOut((DEB_ITRACE,
                      "::UnAdviseOn(%x)WaitForReply returns %x\n",
                      this));
        return hr;
    }


    if (cfFormat==m_cfPict)
    {
        if (m_hPict)
        {
            // Invalidate the cache so when someone explicitly asks for
            // the data, they will get fresh data.
            wFreeData (m_hPict, m_cfPict, TRUE);
            m_hPict = (HANDLE)0;
            m_cfPict = 0;
        }
    }

    // Due to a bug in the OLE1 libraries, unadvising on a presentation
    // format effectively unadvises on native.
    if (cfFormat != g_cfNative && m_fDidAdvNative)
    {
        if (iAdvOn == ON_SAVE)
        {
            // to reflect the fact that the native advise connection was lost
            m_iAdvSave--;
            m_fDidAdvNative = FALSE;
            RetErr (AdviseOn (g_cfNative, ON_SAVE));  // re-establish
        }
        else if (iAdvOn == ON_CLOSE)
        {
            // to reflect the fact that the native advise connection was lost
            m_iAdvClose--;
            m_fDidAdvNative = FALSE;
            RetErr (AdviseOn (g_cfNative, ON_CLOSE));
        }
    }

    return NOERROR;
}


//
// Post a message to a 1.0 server (callee) and wait for the acknowledge
//


INTERNAL CDdeObject::Poke
    (ATOM aItem, HANDLE hDdePoke)
{
    HRESULT hr;

    intrDebugOut((DEB_ITRACE,"CDdeObject::Poke(%x)\n",this));

    ATOM aTmpItem;

    intrAssert(wIsValidAtom(aItem));

    aTmpItem = wDupAtom (aItem);

    intrAssert(wIsValidAtom(aTmpItem));

    m_pDocChannel->hDdePoke = hDdePoke;

    LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_POKE,hDdePoke,aTmpItem);
    hr = SendMsgAndWaitForReply (m_pDocChannel,
                                 AA_POKE,
                                 WM_DDE_POKE,
                                 lp,
                                 TRUE);
    if (S_OK == hr)
    {
        intrDebugOut((DEB_ITRACE,"::Poke(%x) returning %x\n",this,hr));
        return hr;
    }

    intrDebugOut((DEB_ITRACE,"::Poke(%x)wPostMessage failed %x\n",this,hr));
    // Error case
    if (aTmpItem)
        GlobalDeleteAtom (aTmpItem);
    wFreePokeData (m_pDocChannel, m_bOldSvr && m_aClass==aMSDraw);
    hr = RPC_E_DDE_POST;
    intrDebugOut((DEB_ITRACE,"::Poke(%x)wPostMessage returns %x\n",this,hr));
    return hr;

}

INTERNAL CDdeObject::PostSysCommand
    (LPDDE_CHANNEL pChannel,
    LPCSTR szCmd,
    BOOL fStdNew,
    BOOL fWait)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::PostSysCommand(%x,szCmd=%s,fStdNew=%x,fWait=%x)\n",
                  this,
                  szCmd,
                  fStdNew,
                  fWait));

    ULONG    size;
    WORD   len;
    LPSTR  lpdata= NULL;
    HANDLE hdata = NULL;
    HRESULT hresult;


    #define LN_FUDGE        16     // [],(), 3 * 3 (2 double quotes and comma)

    len =  (WORD)strlen (szCmd);

    // for StdNewDocument command add class name
    if (fStdNew)
        len += (WORD) wAtomLenA (m_aClass);

    // Now add the document length.
    len += (WORD) wAtomLenA (m_aTopic);

    // now add the fudge factor for the Quotes etc.
    len += LN_FUDGE;

    // allocate the buffer and set the command.
    if (!(hdata = GlobalAlloc (GMEM_DDESHARE, size = len)))
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);

    if (!(lpdata = (LPSTR)GlobalLock (hdata))) {
        Assert (0);
        GlobalFree (hdata);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    strcpy (lpdata, (LPSTR)"["); // [
    strcat (lpdata, szCmd);      // [StdCmd
    if (strcmp (szCmd, "StdExit"))
    {
        strcat (lpdata, "(\"");      // [StdCmd("

        if (fStdNew)
        {
            len = (WORD)strlen (lpdata);
            GlobalGetAtomNameA (m_aClass, (LPSTR)lpdata + len, size-len);
                                                // [StdCmd("class
            strcat (lpdata, "\",\"");          // [StdCmd("class","
        }

        len = (WORD)strlen (lpdata);
        // now get the topic name.
        GlobalGetAtomNameA (m_aTopic, lpdata + len, (WORD)size - len);
                                                // [StdCmd("class","topic
        strcat (lpdata, "\")");                // [StdCmd("class","topic")
    }
    strcat (lpdata, "]");
    Assert (strlen(lpdata) < size);
    intrDebugOut((DEB_ITRACE,"::PostSysCommand(%x) hData(%s)\n",this,lpdata));
    GlobalUnlock (hdata);

    // return Execute (m_pSysChannel, hdata, /*fStdClose*/FALSE, fWait);
    // REVIEW: this fixed bug 1856 (johannp)
    // JasonFul - does it break something else?

    hresult = Execute (m_pSysChannel,
                       hdata,
                       /*fStdClose*/FALSE,
                       fWait,
                       /*fDetectTerminate*/ TRUE);

    intrDebugOut((DEB_ITRACE,"::PostSysCommand(%x) returns:%x\n",this,hresult));
    return hresult;

}

//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::KeepData
//
//  Synopsis: Given the DDEDATA structure from a WM_DDE_DATA message, extract
//              the real data and keep it till GetData or Save is done.
//
//
//  Effects:
//
//  Arguments:  [pChannel] --
//              [hDdeData] --
//
//  Requires:
//
//  Returns:    E_OUTOFMEMORY or E_HANDLE if failure, NOERROR if success
//
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-14-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDdeObject::KeepData
    (LPDDE_CHANNEL pChannel, HANDLE hDdeData)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::KeepData(%x)\n",this));

    DDEDATA *       lpDdeData = NULL;
    HANDLE          hData     = NULL;
    CLIPFORMAT      cfFormat;



    if (!(lpDdeData = (DDEDATA *) (GlobalLock (hDdeData))))
    {
        return E_OUTOFMEMORY;;
    }


    cfFormat = lpDdeData->cfFormat;
    intrDebugOut((DEB_ITRACE,
                  "::KeepData(%x) Keeping cfFormat=%x\n",
                  this,
                  cfFormat));

    GlobalUnlock (hDdeData);

    // Possible Side effect of wHandleFromDdeData() is the freeing of hDdeData
    if (!(hData = wHandleFromDdeData (hDdeData))
        || !wIsValidHandle (hData, cfFormat) )
    {
        Assert(0);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    if (cfFormat == g_cfNative) {
        if (m_hNative)
            GlobalFree (m_hNative);
        // Keep the native data
        RetErr (wTransferHandle (&m_hNative, &hData, cfFormat));
    }
    else if (cfFormat == CF_METAFILEPICT ||
             cfFormat == CF_BITMAP       ||
             cfFormat == CF_DIB)
    {
        if (m_hPict)
            wFreeData (m_hPict, m_cfPict, TRUE);
        m_cfPict = cfFormat;
        // Keep the presentation data
        RetErr (wTransferHandle (&m_hPict, &hData, cfFormat));

#ifdef OLD
        // Remember size of picture so we can return
        // a reasonable answer for GetExtent
        if (cfFormat == CF_METAFILEPICT)
        {
            LPMETAFILEPICT  lpMfp = (LPMETAFILEPICT) GlobalLock (m_hPict);
            if (NULL==lpMfp)
                return E_HANDLE;
            UpdateExtent (m_cxContentExtent, lpMfp->xExt);
            UpdateExtent (m_cyContentExtent, lpMfp->yExt);
            GlobalUnlock (m_hPict);
        }
        else if (cfFormat==CF_BITMAP)
        {
            BITMAP bm;
            if (0==GetObject (m_hPict, sizeof(BITMAP), (LPVOID) &bm))
                return E_HANDLE;
            UpdateExtent (m_cxContentExtent,
                            wPixelsToHiMetric (bm.bmWidth, giPpliX));
            UpdateExtent (m_cyContentExtent,
                            wPixelsToHiMetric (bm.bmHeight,giPpliY));
        }
        else if (cfFormat==CF_DIB)
        {
            BITMAPINFOHEADER * pbminfohdr;
            pbminfohdr = (BITMAPINFOHEADER *) GlobalLock (m_hPict);
            if (NULL==pbminfohdr)
                return E_HANDLE;
            UpdateExtent (m_cxContentExtent,
                            wPixelsToHiMetric (pbminfohdr->biWidth, giPpliX));
            UpdateExtent (m_cyContentExtent,
                             wPixelsToHiMetric (pbminfohdr->biHeight,giPpliY));
            GlobalUnlock (m_hPict);
        }
#endif

    }
    else
    {
        if (m_hExtra)
            wFreeData (m_hExtra, m_cfExtra, TRUE);
        m_cfExtra = cfFormat;
        wTransferHandle (&m_hExtra, &hData, cfFormat);
    }

    return NOERROR;
}


// IsFormatAvailable
//
// Does a temporary DDE_REQUEST to see if server supports a format
// Returns NOERROR if format is available.
//


INTERNAL CDdeObject::IsFormatAvailable
    (LPFORMATETC pformatetc)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::IsFormatAvailable(%x)\n",this));
    ATOM    aItem=(ATOM)0;
    HRESULT hresult;
    LPARAM lp = 0;

    Puts ("DdeObject::IsFormatAvailable\n");

    if (!HasValidLINDEX(pformatetc))
    {
        intrDebugOut((DEB_IERROR, "\t!HasValidLINDEX(pformatetc)\n"));
        return(DV_E_LINDEX);
    }

    if (0==pformatetc->cfFormat)
        return ResultFromScode (E_INVALIDARG);

    if (pformatetc->dwAspect & DVASPECT_ICON)
    {
        if (pformatetc->cfFormat==CF_METAFILEPICT)
        {
            // This is always available. we get it from the exe.
            return NOERROR;
        }
        // an icon must be a metafile
        return ResultFromScode (S_FALSE);
    }
    if (!(pformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_DOCPRINT)))
    {
        // 1.0 does not support Thumb.
        return ReportResult(0, S_FALSE, 0, 0);
    }

    if (NOERROR == (hresult=m_ConnectionTable.Lookup (pformatetc->cfFormat, NULL)))
    {
        // We already got a call to DataObject::Advise on this format,
        // so it must be available.
        Puts ("DataObject::Advise had been done on this format.\n");
        return NOERROR;
    }
    else
    {
        // Lookup () didn't find this format.
        ErrZ (GetScode(hresult)==S_FALSE);
    }

    intrAssert(wIsValidAtom(m_aItem));
    aItem = wDupAtom (m_aItem);
    intrAssert(wIsValidAtom(aItem));

    lp = MAKE_DDE_LPARAM (WM_DDE_REQUEST,pformatetc->cfFormat,aItem);
    if(NOERROR==SendMsgAndWaitForReply (m_pDocChannel,
                                        AA_REQUESTAVAILABLE,
                                        WM_DDE_REQUEST,
                                        lp,
                                        TRUE))
        return NOERROR;

    // Last ditch effort: Advise
    if (NOERROR== AdviseOn (pformatetc->cfFormat, ON_SAVE))
    {
        // We cannot Unadvise because an OLE 1.0 bug
        // terminates DDE advise connections for ALL formats.
        //// UnAdviseOn (pformatetc->cfFormat, ON_SAVE);
        // Instead, just remember we did this advise.
        m_ConnectionTable.Add (0, pformatetc->cfFormat, ADVFDDE_ONSAVE);
        return NOERROR;
    }
    return ResultFromScode (S_FALSE);

errRtn:
    AssertSz (0, "Error in CDdeObject::IsFormatAvailable");
    Puth (hresult); Putn();
    if (aItem)
        GlobalDeleteAtom (aItem);

    return hresult;
}




INTERNAL CDdeObject::ChangeTopic
    (LPSTR lpszTopic)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::ChangeTopic(%x,lpszTopic=%s)\n",this,lpszTopic));
    HRESULT hresult;
    LPMONIKER pmkFile=NULL;
    LPMONIKER pmkItem=NULL;
    LPMONIKER pmkComp=NULL;
    LPMONIKER pmkNewName=NULL;
    ATOM aTopic = wGlobalAddAtomA (lpszTopic);
    intrAssert(wIsValidAtom(aTopic));

    // Yet-Another-Excel-Hack
    // Excel 4.0 sends StdDocumentName every time it saves,
    // whether or not the file name has actually changed. Bug 2957
    if (aTopic != m_aTopic)
    {
        ErrRtnH (CreateOle1FileMoniker (wAtomName(aTopic), m_clsid, &pmkFile));
        if (m_aItem)
        {
            intrAssert (wIsValidAtom (m_aItem));
            ErrRtnH (CreateItemMoniker (OLESTR("!"), wAtomName (m_aItem), &pmkItem));
            ErrRtnH (CreateGenericComposite (pmkFile, pmkItem, &pmkComp));
            (pmkNewName = pmkComp)->AddRef();
        }
        else
        {
            (pmkNewName = pmkFile)->AddRef();
        }
        RetZS (m_pOleAdvHolder, E_OUTOFMEMORY);
        RetZ (pmkNewName);
        ErrRtnH (m_pOleAdvHolder->SendOnRename (pmkNewName));
    }
    SetTopic (aTopic);
    hresult = NOERROR;

  errRtn:
    if (pmkFile)
        pmkFile->Release();
    if (pmkItem)
        pmkItem->Release();
    if (pmkComp)
        pmkComp->Release();
    if (pmkNewName)
        pmkNewName->Release();
    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::ChangeItem
//
//  Synopsis:   Changes the m_aItem atom, using an Ansi string
//
//  Effects:
//
//  Arguments:  [szItem] -- Ansi string for the new item
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(void) CDdeObject::ChangeItem
    (LPSTR szItem)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::ChangeItem(%x,szItem=%s)\n",this,szItem));
    intrAssert(wIsValidAtom(m_aItem));
    if (m_aItem)
        GlobalDeleteAtom (m_aItem);
    m_aItem = wGlobalAddAtomA (szItem);
    intrAssert(wIsValidAtom(m_aItem));
}




INTERNAL CDdeObject::DeclareVisibility
    (BOOL f,
    BOOL fCallOnShowIfNec)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::DelcareVisibility(%x)\n",this));
    if (f)
        m_fWasEverVisible = TRUE;
    if ((f && (!m_fVisible || !m_fCalledOnShow)) ||
        (!f && m_fVisible))
    {
        if (m_pOleClientSite && fCallOnShowIfNec && m_clsid != CLSID_Package)
        {
            m_pOleClientSite->OnShowWindow (f);
            m_fCalledOnShow = f;
        }
        m_fVisible = f;
    }
    return NOERROR;
}



INTERNAL CDdeObject::Update
    (BOOL fRequirePresentation)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::Update(%x,fRequiredPresentation=%x)\n",
                  this,
                  fRequirePresentation));
    // Get latest data
    // OLE 1.0 spec says servers must supply metafile format.
    HRESULT hresult = RequestData (m_cfPict ? m_cfPict : CF_METAFILEPICT);
    if (fRequirePresentation && hresult!=NOERROR)
        return hresult;
    RetErr (RequestData (g_cfNative));
    SendOnDataChange (ON_CHANGE);
    return NOERROR;
}



INTERNAL CDdeObject::Save
    (LPSTORAGE pstg)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::Save(%x)\n",this));
    VDATEIFACE (pstg);
#ifdef OLE1INTEROP
    RetErr (StSave10NativeData (pstg, m_hNative, m_fOle1interop));
#else
    RetErr (StSave10NativeData (pstg, m_hNative, FALSE));
#endif
    if (m_aItem)
    {
        intrAssert(wIsValidAtom(m_aItem));
        RetErr (StSave10ItemName (pstg, wAtomNameA (m_aItem)));
    }
    RetErr (wWriteFmtUserType (pstg, m_clsid));
    return NOERROR;
}

/*
 *  IMPLEMENTATION of CUnknownImpl
 *
 */



STDMETHODIMP_(ULONG) NC(CDdeObject,CUnknownImpl)::AddRef()
{
    ChkD(m_pDdeObject);

    return InterlockedAddRef(&(m_pDdeObject->m_refs));
}


STDMETHODIMP_(ULONG) NC(CDdeObject,CUnknownImpl)::Release()
{
    ChkD(m_pDdeObject);
    Assert (m_pDdeObject->m_refs != 0);
    ULONG ul;

    if ((ul=InterlockedRelease(&(m_pDdeObject->m_refs))) == 0) {
        m_pDdeObject->m_ProxyMgr.Disconnect();

#ifdef _CHICAGO_
        //Note:POSTPPC
        // the object can not be delete if guarded
        // which is the case if DelayDelete state is 'DelayIt'
        //
        if (m_pDdeObject->_DelayDelete == DelayIt)
        {
            // set the state to ReadyToDelete and
            // the object will be deleted at the
            // UnGuard call
            m_pDdeObject->_DelayDelete = ReadyToDelete;
            intrDebugOut((DEB_IWARN ,"Can not release CDdeObject\n"));
            return 1;
        }
#endif //_CHICAGO_
        delete m_pDdeObject;
        return 0;
    }
    return ul;
}




STDMETHODIMP NC(CDdeObject,CUnknownImpl)::QueryInterface(REFIID iid, LPLPVOID ppv)
{
    ChkD(m_pDdeObject);
    if (iid == IID_IUnknown) {
        *ppv = (void FAR *)&m_pDdeObject->m_Unknown;
        AddRef();
        return NOERROR;
    }
    else if (iid ==  IID_IOleObject)
        *ppv = (void FAR *) &(m_pDdeObject->m_Ole);
    else if (iid ==  IID_IDataObject)
        *ppv = (void FAR *) &(m_pDdeObject->m_Data);
    else if (iid ==  IID_IPersist || iid == IID_IPersistStorage)
        *ppv = (void FAR *) &(m_pDdeObject->m_PersistStg);
    else if (iid == IID_IProxyManager)
        *ppv = (void FAR *) &(m_pDdeObject->m_ProxyMgr);
    else if (iid == IID_IOleItemContainer
             || iid == IID_IOleContainer
             || iid == IID_IParseDisplayName)
        *ppv = (void FAR *) &(m_pDdeObject->m_OleItemContainer);
    else {
        Puts ("INTERFACE NOT FOUND \r\n");
        *ppv = NULL;
        return ReportResult(0, E_NOINTERFACE, 0, 0);
    }

    m_pDdeObject->m_pUnkOuter->AddRef();
    return NOERROR;
}


// implementations of IRpcStubBuffer methods
STDUNKIMPL_FORDERIVED(DdeObject, RpcStubBufferImpl)



STDMETHODIMP NC(CDdeObject,CRpcStubBufferImpl)::Connect
    (IUnknown * pUnkServer )
{
    // do nothing
    return S_OK;
}

STDMETHODIMP_(void) NC(CDdeObject,CRpcStubBufferImpl)::Disconnect
    ()
{
    // do nothing
}

STDMETHODIMP_(IRpcStubBuffer*) NC(CDdeObject,CRpcStubBufferImpl)::IsIIDSupported
    (REFIID riid)
{
    // do nothing
    return NULL;
}


STDMETHODIMP_(ULONG) NC(CDdeObject,CRpcStubBufferImpl)::CountRefs
    ()
{
    // do nothing
    return 1;
}

STDMETHODIMP NC(CDdeObject,CRpcStubBufferImpl)::DebugServerQueryInterface
    (void ** ppv )
{
    // do nothing
    *ppv = NULL;
    return S_OK;
}


STDMETHODIMP_(void) NC(CDdeObject,CRpcStubBufferImpl)::DebugServerRelease
    (void * pv)
{
    // do nothing
}

STDMETHODIMP NC(CDdeObject,CRpcStubBufferImpl)::Invoke
    (RPCOLEMESSAGE *_prpcmsg, IRpcChannelBuffer *_pRpcChannelBuffer)
{
    PDISPATCHDATA pdispdata = (PDISPATCHDATA) _prpcmsg->Buffer;
    return DispatchCall( pdispdata );
}


// implementation of IRpcChannelBuffer methods for DDE_CHANNEL
//

STDMETHODIMP DDE_CHANNEL::QueryInterface ( REFIID riid, LPVOID * ppvObj)
{
    *ppvObj = this;
    return S_OK;
}
STDMETHODIMP_(ULONG) DDE_CHANNEL::AddRef ()
{
    return 1;
}
STDMETHODIMP_(ULONG) DDE_CHANNEL::Release ()
{
    return 1;
}

// Provided IRpcChannelBuffer methods (for callback methods side)
HRESULT  DDE_CHANNEL::GetBuffer(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [in] */ REFIID riid)
{
    return S_OK;
}

HRESULT  DDE_CHANNEL::SendReceive(
/* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [out] */ ULONG __RPC_FAR *pStatus)
{
    return S_OK;
}

HRESULT  DDE_CHANNEL::FreeBuffer(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage)
{
    return S_OK;
}

HRESULT  DDE_CHANNEL::GetDestCtx(
/* [out] */ DWORD __RPC_FAR *pdwDestContext,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext)
{
    *pdwDestContext = MSHCTX_LOCAL;
    return S_OK;
}

HRESULT  DDE_CHANNEL::IsConnected( void)
{
    return S_OK;
}

// Provided IRpcChannelBuffer2 methods
HRESULT  DDE_CHANNEL::GetProtocolVersion(DWORD *pdwVersion)
{
    return S_OK;
}

STDMETHODIMP DDE_CHANNEL::ContextInvoke(
/* [out][in] */ RPCOLEMESSAGE *pMessage,
/* [in] */ IRpcStubBuffer *pStub,
/* [in] */ IPIDEntry *pIPIDEntry,
/* [out] */ DWORD *pdwFault)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN DDE_CHANNEL::ContextInvoke(pMessage=%x,pStub=%x,pdwFault=%x)\n",
                  this,
                  pMessage,
                  pStub,
                  pdwFault));

    HRESULT hr = StubInvoke(pMessage, NULL, pStub, (IRpcChannelBuffer3 *)this, pIPIDEntry, pdwFault);

    intrDebugOut((DEB_ITRACE,
                  "%p _OUT DDE_CHANNEL::ContextInvoke returning hr=0x%x\n",
                  this,
                  hr));
    return(hr);
}

HRESULT  DDE_CHANNEL::GetBuffer2(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [in] */ REFIID riid)
{
    return GetBuffer(pMessage, riid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\ddeworkr.cxx ===
/*++

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeworkr.cpp

Abstract:

    This module contains the code for the worker routines

Author:

    Srini Koppolu   (srinik)    22-June-1992
    Jason Fuller    (jasonful)  24-July-1992

Revision History:
    Kevin Ross	    (KevinRo)   10-May-1994
    	Mostly added comments, and attempted to clean
	it up.

--*/
#include "ddeproxy.h"

ASSERTDATA

/*
 *  WORKER ROUTINES
 *
 */


INTERNAL_(BOOL) wPostMessageToServer(LPDDE_CHANNEL pChannel,
				     WORD wMsg,
				     LPARAM lParam,
				     BOOL fFreeOnError)
{
    int c=0;
    intrDebugOut((DEB_ITRACE,
		  "wPostMessageToServer(pChannel=%x,wMsg=%x,lParam=%x,fFreeOnError=%x\n",
		  pChannel,
		  wMsg,
		  lParam,
		  fFreeOnError));
    if (NULL==pChannel)
    {
        AssertSz (0, "Channel missing");
        return FALSE;
    }
    pChannel->wMsg   = wMsg;
    pChannel->lParam = lParam;
    pChannel->hres   = NOERROR;

    while (TRUE && c<10 )
    {
        if (!IsWindow (pChannel->hwndSvr))
        {
       intrDebugOut((DEB_IWARN,
                  "wPostMessageToServer: invalid window %x\n",
                  pChannel->hwndSvr));
            goto errRet;
        }
        if (wTerminateIsComing (pChannel)
            && wMsg != WM_DDE_ACK
            && wMsg != WM_DDE_TERMINATE)
        {
	    intrDebugOut((DEB_IWARN,"Server sent terminate, cannot post\n"));
	    goto errRet;
        }
        if (!PostMessage (pChannel->hwndSvr, wMsg, (WPARAM) pChannel->hwndCli, lParam))
        {
	    intrDebugOut((DEB_IWARN,
                  "wPostMessageToServer: PostMessageFailed, yielding\n"));
            Yield ();
            c++;
        }
        else
            return TRUE;
    }
    AssertSz (0, "PostMessage failed");

errRet:
    intrDebugOut((DEB_IWARN,"wPostMessageToServer returns FALSE\n"));
    if (fFreeOnError)
    {
	DDEFREE(wMsg,lParam);
    }

    return FALSE;
}


// call Ole1ClassFromCLSID then global add atom; returns NULL if error.
INTERNAL_(ATOM) wAtomFromCLSID(REFCLSID rclsid)
{
    WCHAR szClass[MAX_STR];
    ATOM aCls;

	szClass[0] = 0;

    if (Ole1ClassFromCLSID2(rclsid, szClass, sizeof(szClass)) == 0)
        return NULL;
    aCls = wGlobalAddAtom(szClass);
    intrAssert(wIsValidAtom(aCls));
    return aCls;
}

INTERNAL_(ATOM) wGlobalAddAtom(LPCOLESTR sz)
{
    if (sz==NULL || sz[0] == '\0')
    {
        return NULL;
    }

    ATOM a = GlobalAddAtom(sz);
    intrAssert(wIsValidAtom(a));
    return a;
}

INTERNAL_(ATOM) wGlobalAddAtomA(LPCSTR sz)
{
    if (sz==NULL || sz[0] == '\0')
        return NULL;
    ATOM a = GlobalAddAtomA(sz);
    intrAssert(wIsValidAtom(a));
    return a;
}


INTERNAL_(ATOM) wGetExeNameAtom (REFCLSID rclsid)
{
    LONG    cb = MAX_STR;
    WCHAR    key[MAX_STR];
    ATOM    a;

	key[0] = 0;

    if (Ole1ClassFromCLSID2(rclsid, key, sizeof(key)) == 0)
        return NULL;

    lstrcatW (key, OLESTR("\\protocol\\StdFileEditing\\server"));

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, key, &cb))
    {
        Puts ("ERROR: wGetExeNameAtom failed\n");
        return NULL;
    }
    a = wGlobalAddAtom (key);
    intrAssert(wIsValidAtom(a));
    return a;
}

INTERNAL_(void) wFreeData (HANDLE hData, CLIPFORMAT cfFormat,
                           BOOL fFreeNonGdiHandle)
{
    intrDebugOut((DEB_ITRACE,
		  "wFreeData(hData=%x,cfFormat=%x,FreeNonGDIHandle=%x\n",
		  hData,
		  (USHORT)cfFormat,
		  fFreeNonGdiHandle));

    AssertSz (hData != NULL, "Trying to free NULL handle");
    AssertSz (hData != (HANDLE) LongToHandle(0xcccccccc), "Trying to free handle from a deleted object");

    switch (cfFormat) {
    case CF_METAFILEPICT:
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData))
	{
	    intrDebugOut((DEB_ITRACE,
		          "wFreeData freeing metafile %x\n",
			  lpMfp->hMF));

	    OleDdeDeleteMetaFile(lpMfp->hMF);
            GlobalUnlock (hData);
        }
        GlobalFree (hData);
        break;

    case CF_BITMAP:
    case CF_PALETTE:
        Verify(DeleteObject (hData));
        break;

    case CF_DIB:
        GlobalFree (hData);
        break;

    default:
        if (fFreeNonGdiHandle)
            GlobalFree (hData);
        break;
    }
}



INTERNAL_(BOOL) wInitiate (LPDDE_CHANNEL pChannel, ATOM aLow, ATOM aHigh)
{
    intrDebugOut((DEB_ITRACE,"wInitiate(pChannel=%x,aLow=%x,aHigh=%x)\n",
          pChannel, aLow, aHigh));

    intrAssert(wIsValidAtom(aLow));
    if (aLow == (ATOM)0)
    {
	intrDebugOut((DEB_IERROR,"wInitiate Failed, aLow == 0\n"));
	return FALSE;
    }

    pChannel->iAwaitAck = AA_INITIATE;

    SSSendMessage ((HWND)-1, WM_DDE_INITIATE, (WPARAM) pChannel->hwndCli,
		  MAKE_DDE_LPARAM (WM_DDE_INITIATE, aLow, aHigh));

    pChannel->iAwaitAck = NULL;

    intrDebugOut((DEB_ITRACE,
		  "wInitiate pChannel->hwndSrvr = %x\n",
		  pChannel->hwndSvr));

    return (pChannel->hwndSvr != NULL);
}



INTERNAL_(HRESULT) wScanItemOptions (ATOM aItem, int FAR* lpoptions)
{
    ATOM    aModifier;
    LPOLESTR   lpbuf;
    WCHAR    buf[MAX_STR];

    *lpoptions = ON_CHANGE; // default

    if (!aItem) {
        // NULL item with no modifier means ON_CHANGE for NULL item
        return NOERROR;
    }

    intrAssert(wIsValidAtom(aItem));
    GlobalGetAtomName (aItem, buf, MAX_STR);
    lpbuf = buf;

    while ( *lpbuf && *lpbuf != '/')
           IncLpch (lpbuf);

    // no modifier same as /change

    if (*lpbuf == NULL)
        return NOERROR;

    *lpbuf++ = NULL;        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
    {
        Puts ("ERROR: wScanItemOptions found non-atom modifier\n");
        return ReportResult(0, RPC_E_DDE_SYNTAX_ITEM, 0, 0);
    }

    intrAssert(wIsValidAtom(aModifier));

    if (aModifier == aChange)
        return NOERROR;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = ON_SAVE;
        return  NOERROR;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = ON_CLOSE;
        return NOERROR;
    }

    // unknown modifier
    Puts ("ERROR: wScanItemOptions found bad modifier\n");
    return ReportResult(0, RPC_E_DDE_SYNTAX_ITEM, 0, 0);
}


INTERNAL_(BOOL) wClearWaitState (LPDDE_CHANNEL pChannel)
{
    Assert (pChannel);
    // kill if any timer active.
    if (pChannel->wTimer) {
        KillTimer (pChannel->hwndCli, 1);
        pChannel->wTimer = 0;

        if (pChannel->hDdePoke) {
            GlobalFree (pChannel->hDdePoke);
            pChannel->hDdePoke = NULL;
        }

        if (pChannel->hopt) {
            GlobalFree (pChannel->hopt);
            pChannel->hopt = NULL;
        }

	//
	// If the channel is waiting on an Ack, and there is an
	// lParam, then we may need to cleanup the data.

        if (pChannel->iAwaitAck && (pChannel->lParam)) {
            if (pChannel->iAwaitAck == AA_EXECUTE)
	    {
		//
		// KevinRo: Found the following comment in the code.
		// ; // get hData from GET_WM_DDE_EXECUTE_HADATA ??
		// It appears, by looking at what the 16-bit code does,
		// that the goal is to free the handle that was passed as
		// part of the EXECUTE message. Judging by what the 16-bit
		// code did, I have determined that this is correct.
		//
		// The macro used below wanted two parameters. The first was
		// the WPARAM, the second the LPARAM. We don't have the WPARAM.
		// However, it isn't actually used by the macro, so I have
		// cheated and provided 0 as a default
		//
		GlobalFree(GET_WM_DDE_EXECUTE_HDATA(0,pChannel->lParam));

#ifdef KEVINRO_HERE_IS_THE_16_BIT_CODE
                GlobalFree (HIWORD (pChannel->lParam));
#endif
	    }
            else
	    {
		//
		// All of the other DDE messages pass an Atom in the high word.
		// Therefore, we should delete the atom.
		//
		//
		ATOM aTmp;

		aTmp = (ATOM) MGetDDElParamHi(pChannel->wMsg,pChannel->lParam);

		intrAssert(wIsValidAtom(aTmp));
                if (aTmp)
		{
                    GlobalDeleteAtom (aTmp);
		}
            }
	    DDEFREE(pChannel->wMsg,pChannel->lParam);

            // we want to wipe out the lParam
            pChannel->lParam = 0x0;
        }

        return TRUE;
    }

    return FALSE;
}



// wNewHandle (LPSTR, DWORD)
//
// Copy cb bytes from lpstr into a new memory block and return a handle to it.
// If lpstr is an ASCIIZ string, cb must include 1 for the null terminator.
//

INTERNAL_(HANDLE) wNewHandle (LPSTR lpstr, DWORD cb)
{

    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    hdata = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, cb);
    if (hdata == NULL || (lpdata = (LPSTR) GlobalLock (hdata)) == NULL)
        goto errRtn;

    memcpy (lpdata, lpstr, cb);
    GlobalUnlock (hdata);
    return hdata;

errRtn:
    Puts ("ERROR: wNewHandle\n");
    Assert (0);
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    return NULL;
}



// wDupData
//
// Copy data from handle h into a new handle which is returned as *ph.
//

INTERNAL wDupData (LPHANDLE ph, HANDLE h, CLIPFORMAT cf)
{
    Assert (ph);
    RetZ (wIsValidHandle(h, cf));
    *ph = OleDuplicateData (h, cf, GMEM_DDESHARE | GMEM_MOVEABLE);
    RetZ (wIsValidHandle (*ph, cf));
    return NOERROR;
}


// wTransferHandle
//
//
INTERNAL wTransferHandle
    (LPHANDLE phDst,
    LPHANDLE phSrc,
    CLIPFORMAT cf)
{
    RetErr (wDupData (phDst, *phSrc, cf));
    wFreeData (*phSrc, cf, TRUE);
    *phSrc = (HANDLE)0;
    return NOERROR;
}


// wHandleCopy
//
// copy data from hSrc to hDst.
// Both handles must already have memory allocated to them.
//

INTERNAL wHandleCopy (HANDLE hDst, HANDLE hSrc)
{
    LPSTR lpDst, lpSrc;
    DWORD dwSrc;

    if (NULL==hDst || NULL==hSrc)
        return ResultFromScode (E_INVALIDARG);
    if (GlobalSize(hDst) < (dwSrc= (DWORD) GlobalSize(hSrc)))
    {
        HANDLE hDstNew = GlobalReAlloc (hDst, dwSrc, GMEM_DDESHARE | GMEM_MOVEABLE);
        if (hDstNew != hDst)
            return ResultFromScode (E_OUTOFMEMORY);
    }
    if (!(lpDst = (LPSTR) GlobalLock(hDst)))
    {
        intrAssert(!"ERROR: wHandleCopy hDst");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    if (!(lpSrc = (LPSTR) GlobalLock(hSrc)))
    {
   GlobalUnlock(hDst);
        intrAssert (!"ERROR: wHandleCopy hSrc");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    memcpy (lpDst, lpSrc, dwSrc);
    GlobalUnlock(hDst);
    GlobalUnlock(hSrc);
    return NOERROR;
}


// ExtendAtom: Create a new atom, which is the old one plus extension

INTERNAL_(ATOM) wExtendAtom (ATOM aItem, int iAdvOn)
{
    WCHAR    buffer[MAX_STR+1];
    LPOLESTR   lpext;

    buffer[0] = 0;
    // aItem==NULL for embedded objects.
    // If so, there is no item name before the slash.
    if (aItem)
        GlobalGetAtomName (aItem, buffer, MAX_STR);

    switch (iAdvOn) {
        case ON_CHANGE:
            lpext = OLESTR("");
            break;

        case ON_SAVE:
            lpext = OLESTR("/Save");
            break;

        case ON_CLOSE:
            lpext = OLESTR("/Close");
            break;

        default:
            AssertSz (FALSE, "Unknown Advise option");
            break;

    }

    lstrcatW (buffer, lpext);
    if (buffer[0])
        return wGlobalAddAtom (buffer);
    else
        return NULL;
        // not an error. For embedded object on-change, aItem==NULL
}




INTERNAL_(ATOM) wDupAtom (ATOM a)
{
    WCHAR sz[MAX_STR];

    if (!a)
        return NULL;

    Assert (wIsValidAtom (a));
    GlobalGetAtomName (a, sz, MAX_STR);
    return wGlobalAddAtom (sz);
}



//+---------------------------------------------------------------------------
//
//  Function:   wAtomLen
//
//  Synopsis:   Return the length, in characters, of the atom name.
//      The length includes the NULL. This function returns the
//      length of the UNICODE version of the atom.
//
//  Effects:
//
//  Arguments:  [atom] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(int) wAtomLen (ATOM atom)
{
    WCHAR    buf[MAX_STR];

    if (!atom)
        return NULL;

    return (GlobalGetAtomName (atom, buf, MAX_STR));
}

//+---------------------------------------------------------------------------
//
//  Function:   wAtomLenA
//
//  Synopsis:   Return the length, in characters, of the atom name.
//      The length includes the NULL This function returns the
//      length of the ANSI version of the atom,
//
//  Effects:
//
//  Arguments:  [atom] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(int) wAtomLenA (ATOM atom)
{
    char    buf[MAX_STR];

    if (!atom)
        return NULL;

    return (GlobalGetAtomNameA (atom, (LPSTR)buf, MAX_STR));
}



// NOTE: returns address of static buffer.  Use return value immediately.
//


//+---------------------------------------------------------------------------
//
//  Function:   wAtomName
//
//  Synopsis:   Returns a STATIC BUFFER that holds the string name of the
//      atom.
//
//  Effects:
//
//  Arguments:  [atom] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Commented
//
//  Notes:
//
//  WARNING:    This uses a static buffer, so don't depend on the pointer for
//      very long.
//
//----------------------------------------------------------------------------
INTERNAL_(LPOLESTR) wAtomName (ATOM atom)
{
    static WCHAR buf[MAX_STR];

    if (!atom)
        return NULL;

    if (0==GlobalGetAtomName (atom, buf, MAX_STR))
        return NULL;

    return buf;
}

//+---------------------------------------------------------------------------
//
//  Function:   wAtomName
//
//  Synopsis:   Returns a STATIC BUFFER that holds the string name of the
//      atom.
//
//  Effects:
//
//  Arguments:  [atom] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Commented
//
//  Notes:
//
//  WARNING:    This uses a static buffer, so don't depend on the pointer for
//      very long.
//
//----------------------------------------------------------------------------
INTERNAL_(LPSTR) wAtomNameA (ATOM atom)
{
    static char buf[MAX_STR];

    if (!atom)
        return NULL;

    if (0==GlobalGetAtomNameA (atom, (LPSTR)buf, MAX_STR))
        return NULL;

    return buf;
}




//+---------------------------------------------------------------------------
//
//  Function:   wHandleFromDdeData
//
//  Synopsis:   Return a handle from the DDEDATA passed in.
//
//  Effects:    This function will return the correct data from the
//		DDEDATA that is referenced by the handle passed in.
//
//		DDEDATA is a small structure that is used in DDE to
//		specify the data type of the buffer, its release
//		semantics, and the actual data.
//
//		In the case of a known format, the handle to the
//		data is extracted from the DDEDATA structure, and
//		the hDdeData is released.
//
//		If its a Native format, the data is either moved
//		within the memory block allocated, or is copied to
//		another block, depending on the fRelease flag in
//		the hDdeData.
//
//  Arguments:  [hDdeData] -- Handle to DDEDATA
//
//  Requires:
//
//  Returns:	A handle to the data. hDdeData will be invalidated
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-13-94   kevinro   Commented
//
//  Notes:
//
// 	hDdeData is invalid after calling this function
//
//----------------------------------------------------------------------------


INTERNAL_(HANDLE) wHandleFromDdeData
    (HANDLE hDdeData)
{
    intrDebugOut((DEB_ITRACE,"wHandleFromDdeData(%x)\n",hDdeData));
    BOOL fRelease;
    HGLOBAL h = NULL; // return value

    DDEDATA FAR* lpDdeData = (DDEDATA FAR *) GlobalLock (hDdeData);

    //
    // If the handle is invalid, then the lpDdeData will be NULL
    //
    if (!lpDdeData)
    {
   intrDebugOut((DEB_ITRACE,
              "\twHandleFromDdeData(%x) invalid handle\n",
              hDdeData));
        return NULL;
    }


    //
    // The header section of a DDEDATA consists of 2 shorts.
    // That makes it 4 bytes. Due to the new packing values,
    // it turns out that doing a sizeof(DDEDATA) won't work,
    // because the size gets rounded up to a multple of 2
    //
    // We will just hard code the 4 here, since it cannot change
    // for all time anyway.
    //
    #define cbHeader 4
    Assert (cbHeader==4);

    //
    // If the cfFormat is BITMAP or METAFILEPICT, then the
    // handle will be retrieved from the first DWORD of the
    // buffer
    //
    if (lpDdeData->cfFormat == CF_BITMAP ||
        lpDdeData->cfFormat == CF_METAFILEPICT)
    {
       //
       // The alignment here should be fine, since the Value
       // field is DWORD aligned. So, we trust this cast
       //
#ifdef _WIN64
        if (lpDdeData->cfFormat == CF_METAFILEPICT)
            h = *(void* __unaligned*)lpDdeData->Value;
    	else
#endif
           h = LongToHandle(*(LONG*)lpDdeData->Value);

       Assert (GlobalFlags(h) != GMEM_INVALID_HANDLE);
       fRelease = lpDdeData->fRelease;
       GlobalUnlock (hDdeData);
       if (fRelease)
       {
	   GlobalFree (hDdeData);
       }

       return h;
    }
    else if (lpDdeData->cfFormat == CF_DIB)
    {
       //
       // The alignment here should be fine, since the Value
       // field is DWORD aligned.
       //
       // This changes the memory from fixed to moveable.
       //
        h = GlobalReAlloc (*(LPHANDLE)lpDdeData->Value, 0L,
                              GMEM_MODIFY|GMEM_MOVEABLE);
        Assert (GlobalFlags(h) != GMEM_INVALID_HANDLE);
        fRelease = lpDdeData->fRelease;
        GlobalUnlock (hDdeData);
        if (fRelease)
            GlobalFree (hDdeData);
        return h;
    }


    // Native and other data case
    // dwSize = size of Value array, ie, size of the data itself
    const DWORD dwSize = (DWORD) (GlobalSize (hDdeData) - cbHeader);

    if (lpDdeData->fRelease)
    {
        // Move the Value data up over the DDE_DATA header flags.
        memcpy ((LPSTR)lpDdeData, ((LPSTR)lpDdeData)+cbHeader, dwSize);
        GlobalUnlock (hDdeData);
   h = GlobalReAlloc (hDdeData, dwSize, GMEM_MOVEABLE);
        Assert (GlobalFlags(h) != GMEM_INVALID_HANDLE);
        return h;
    }
    else
    {
        // Duplicate the data because the server will free the original.
        h = wNewHandle (((LPSTR)lpDdeData)+cbHeader, dwSize);
        Assert (GlobalFlags(h) != GMEM_INVALID_HANDLE);
        GlobalUnlock (hDdeData);
        return h;
    }
}





//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::CanCallBack
//
//  Synopsis:   This routine apparently was supposed to determine if a
// 		call back could be made. However, the PeekMessage stuff
//		was commented out.
//
//		So, it returns TRUE if 0 or 1, FALSE but increments lpCount
//		if 2, returns true but decrements lpCount if > 3. Why?
//		Dunno. Need to ask JasonFul
//
//  Effects:
//
//  Arguments:  [lpCount] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-16-94   kevinro   Commented, confused, and disgusted
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL) CDdeObject::CanCallBack (LPINT lpCount)
{
    switch (*lpCount) {
        case 0:
        case 1:
            return TRUE;

        case 2:
        {
//     MSG msg;
            if (0)
                //!PeekMessage (&msg, m_pDocChannel->hwndCli,0,0, PM_NOREMOVE) ||
               //   msg.message != WM_DDE_DATA)
            {
                Puts ("Server only sent one format (hopefully presentation)\n");
                return TRUE;
            }
            else
            {
                ++(*lpCount);
                return FALSE;
            }
        }

        case 3:
            --(*lpCount);
            return TRUE;

        default:
            AssertSz (FALSE, "012345" + *lpCount);
            return FALSE;
    }
}


INTERNAL_(BOOL) wIsOldServer (ATOM aClass)
{
    LONG    cb = MAX_STR;
    WCHAR    key[MAX_STR];
    int     len;

    if (aClass==(ATOM)0)
        return FALSE;

    if (!GlobalGetAtomName (aClass, key, sizeof(key)))
        return TRUE;

    lstrcatW (key, OLESTR("\\protocol\\StdFileEditing\\verb\\"));
    len = lstrlenW (key);
    key [len++] = (char) ('0');
    key [len++] = 0;

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, key, &cb))
        return TRUE; // no verbs registered

    return FALSE;
}




INTERNAL_(void) wFreePokeData
    (LPDDE_CHANNEL pChannel,
     BOOL fMSDrawBug)
{
    DDEPOKE FAR * lpdde;

    if (!pChannel )
        return;

    if (!pChannel->hDdePoke)
        return;

    if (lpdde = (DDEPOKE FAR *) GlobalLock (pChannel->hDdePoke)) {

        // The old version of MSDraw expects the _contents_ of METAFILEPICT
        // structure, rather than the handle to it, to be part of DDEPOKE.

        if (fMSDrawBug && lpdde->cfFormat==CF_METAFILEPICT) {
	    intrDebugOut((DEB_ITRACE,
			  "wFreePokeData is accomodating MSDraw bug\n"));
            //
	    // This meta file was created in 32-bits, and was not passed
	    // into us by DDE. Therefore, this metafile should not need to
	    // call WOW to be free'd.
	    //
	    
	    LPMETAFILEPICT lpmfp = (LPMETAFILEPICT)*(void* _unaligned*)&lpdde->Value;
#ifdef _WIN64
            DeleteMetaFile(lpmfp->hMF);
#else
            DeleteMetaFile(lpmfp->hMF);
#endif
        }
        // If there is a normal metafile handle in the Value field,
        // it will be freed (if necessary) by the ReleaseStgMedium()
        // in DO::SetData
        GlobalUnlock (pChannel->hDdePoke);
    }
    GlobalFree (pChannel->hDdePoke);
    pChannel->hDdePoke = NULL;
}




INTERNAL_(HANDLE) wPreparePokeBlock
    (HANDLE hData, CLIPFORMAT cfFormat, ATOM aClass, BOOL bOldSvr)
{
    HANDLE  hDdePoke = NULL;
    LPSTR   lpBuf;

    if (!hData)
        return NULL;

    // The old version of MSDraw expects the contents of METAFILEPICT
    // structure to be part of DDEPOKE, rather than the handle to it.
    if ((cfFormat==CF_METAFILEPICT && !(aClass==aMSDraw && bOldSvr))
        || (cfFormat == CF_DIB)
        || (cfFormat == CF_BITMAP)) {

        Verify (lpBuf = wAllocDdePokeBlock (4, cfFormat, &hDdePoke));
		if (!lpBuf)
			return NULL;
        *((HANDLE FAR*)lpBuf) = hData;

    }
    else {
        // Handle the non-metafile case and the MS-Draw bug
        DWORD dwSize = (DWORD) GlobalSize (hData);

	if ((aClass == aMSDraw) && bOldSvr)
	{
	    intrDebugOut((DEB_ITRACE,
			  "wPreparePokeBlock is accomodating MSDraw bug\n"));
	}

        if (lpBuf = wAllocDdePokeBlock (dwSize, cfFormat, &hDdePoke)) {
            memcpy (lpBuf, GlobalLock(hData), dwSize);
            GlobalUnlock (hData);
        }
    }

    if (hDdePoke)
        GlobalUnlock (hDdePoke);
    return hDdePoke;
}


// wAllocDdePokeBlock
// The caller must unlock *phDdePoke when it is done using the return value
// of this function but before a DDe message is sent using *phDdePoke.
//

INTERNAL_(LPSTR) wAllocDdePokeBlock
    (DWORD dwSize, CLIPFORMAT cfFormat, LPHANDLE phDdePoke)
{
    HANDLE      hdde = NULL;
    DDEPOKE FAR * lpdde = NULL;

    if (!(hdde = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT,
                 (dwSize + sizeof(DDEPOKE) - sizeof(BYTE) ))))
        return NULL;

    if (!(lpdde = (DDEPOKE FAR*)GlobalLock (hdde))) {
        GlobalFree (hdde);
        return NULL;
    }
    // hdde will be UnLock'ed in wPreparePokeBlock and Free'd in wFreePokeData
    lpdde->fRelease = FALSE;
    lpdde->cfFormat = cfFormat;
    *phDdePoke = hdde;
    return (LPSTR) &(lpdde->Value);
}


#ifdef OLD
INTERNAL_(ULONG) wPixelsToHiMetric
    (ULONG cPixels,
    ULONG cPixelsPerInch)
{
    return cPixels * HIMETRIC_PER_INCH / cPixelsPerInch;
}
#endif

// Can ask for icon based on either CLSID or filename
//

INTERNAL GetDefaultIcon (REFCLSID clsidIn, LPCOLESTR szFile, HANDLE FAR* phmfp)
{
    if (!(*phmfp = OleGetIconOfClass(clsidIn, NULL, TRUE)))
        return ResultFromScode(E_OUTOFMEMORY);

    return NOERROR;
}

#ifdef OLD
    VDATEPTROUT (phmfp, HICON);
    VDATEPTRIN (szFile, char);
    WCHAR szExe[MAX_STR];
    HICON hicon;
    HDC   hdc;
    METAFILEPICT FAR* pmfp=NULL;
    HRESULT hresult;
    static int cxIcon = 0;
    static int cyIcon = 0;
    static int cxIconHiMetric = 0;
    static int cyIconHiMetric = 0;

    *phmfp = NULL;
    CLSID clsid;
    if (clsidIn != CLSID_NULL)
    {
        clsid = clsidIn;
    }
    else
    {
        RetErr (GetClassFile (szFile, &clsid));
    }
    ATOM aExe = wGetExeNameAtom (clsid);
    if (0==GlobalGetAtomName (aExe, szExe, MAX_STR))
    {
        Assert (0);
        return ReportResult(0, E_UNEXPECTED, 0, 0);
    }
    hicon = ExtractIcon (hmodOLE2, szExe, 0/*first icon*/);
    if (((HICON) 1)==hicon || NULL==hicon)
    {
        // ExtractIcon failed, so we can't support DVASPECT_ICON
        return ResultFromScode (DV_E_DVASPECT);
    }
    *phmfp = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, sizeof(METAFILEPICT));
    ErrZS (*phmfp, E_OUTOFMEMORY);
    pmfp = (METAFILEPICT FAR*) GlobalLock (*phmfp);
    ErrZS (pmfp, E_OUTOFMEMORY);
    if (0==cxIcon)
    {
        // In units of pixels
        Verify (cxIcon = GetSystemMetrics (SM_CXICON));
        Verify (cyIcon = GetSystemMetrics (SM_CYICON));
        // In units of .01 millimeter
        cxIconHiMetric = (int)(long)wPixelsToHiMetric (cxIcon, giPpliX) ;
        cyIconHiMetric = (int)(long)wPixelsToHiMetric (cyIcon, giPpliY) ;
    }
    pmfp->mm   = MM_ANISOTROPIC;
    pmfp->xExt = cxIconHiMetric;
    pmfp->yExt = cyIconHiMetric;
    hdc = CreateMetaFile (NULL);
    SetWindowOrg (hdc, 0, 0);
    SetWindowExt (hdc, cxIcon, cyIcon);
    DrawIcon (hdc, 0, 0, hicon);
    pmfp->hMF = CloseMetaFile (hdc);
    ErrZ (pmfp->hMF);
    Assert (wIsValidHandle (pmfp->hMF, NULL));
    GlobalUnlock (*phmfp);
    Assert (wIsValidHandle (*phmfp, CF_METAFILEPICT));
    return NOERROR;

  errRtn:
    if (pmfp)
        GlobalUnlock (*phmfp);
    if (*phmfp)
        GlobalFree (*phmfp);
    return hresult;
}
#endif

#define DWTIMEOUT 1000L

INTERNAL wTimedGetMessage
    (LPMSG pmsg,
    HWND hwnd,
    WORD wFirst,
    WORD wLast)
{
    DWORD dwStartTickCount = GetTickCount();
    while (!SSPeekMessage (pmsg, hwnd, wFirst, wLast, PM_REMOVE))
    {
        if (GetTickCount() - dwStartTickCount > DWTIMEOUT)
        {
            if (!IsWindow (hwnd))
                return ResultFromScode (RPC_E_CONNECTION_LOST);
            else
                return ResultFromScode (RPC_E_SERVER_DIED);
        }
    }
    return NOERROR;
}


INTERNAL wNormalize
    (LPFORMATETC pformatetcIn,
    LPFORMATETC  pformatetcOut)
{
    if (pformatetcIn->cfFormat == 0
        && pformatetcIn->ptd == NULL            // Is WildCard
        && pformatetcIn->dwAspect == -1L
        && pformatetcIn->lindex == -1L
        && pformatetcIn->tymed == -1L)
    {
        pformatetcOut->cfFormat = CF_METAFILEPICT;
        pformatetcOut->ptd      = NULL;
        pformatetcOut->dwAspect = DVASPECT_CONTENT;
        pformatetcOut->lindex = DEF_LINDEX;
        pformatetcOut->tymed = TYMED_MFPICT;
    }
    else
    {
        memcpy (pformatetcOut, pformatetcIn, sizeof(FORMATETC));
    }
    return NOERROR;
}



INTERNAL wVerifyFormatEtc
    (LPFORMATETC pformatetc)
{
    intrDebugOut((DEB_ITRACE,
          "wVerifyFormatEtc(pformatetc=%x)\n",
          pformatetc));

    VDATEPTRIN  (pformatetc, FORMATETC);
    if (!HasValidLINDEX(pformatetc))
    {
        intrDebugOut((DEB_IERROR, "\t!HasValidLINDEX(pformatetc)\n"));
        return(DV_E_LINDEX);
    }

    if (0==(pformatetc->tymed & (TYMED_HGLOBAL | TYMED_MFPICT | TYMED_GDI)))
    {
   intrDebugOut((DEB_IERROR,
              "\t0==(pformatetc->tymed & (TYMED_HGLOBAL | TYMED_MFPICT | TYMED_GDI))\n"));
   return ResultFromScode (DV_E_TYMED);
    }
    if (0==(UtFormatToTymed (pformatetc->cfFormat) & pformatetc->tymed))
    {
   intrDebugOut((DEB_IERROR,
              "\t0==(UtFormatToTymed (pformatetc->cfFormat) & pformatetc->tymed)\n"));
        return ResultFromScode (DV_E_TYMED);
    }
    if (0==(pformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_ICON)))
    {
   intrDebugOut((DEB_IERROR,
              "\t0==(pformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_ICON))\n"));

        return ResultFromScode (DV_E_DVASPECT);
    }
    if (pformatetc->dwAspect & DVASPECT_ICON)
    {
        if (CF_METAFILEPICT != pformatetc->cfFormat)
   {
   intrDebugOut((DEB_IERROR,
              "\tCF_METAFILEPICT != pformatetc->cfFormat\n"));
            return ResultFromScode (DV_E_CLIPFORMAT);
   }

        if (0==(pformatetc->tymed & TYMED_MFPICT))
   {
   intrDebugOut((DEB_IERROR,
              "\t0==(pformatetc->tymed & TYMED_MFPICT)\n"));
            return ResultFromScode (DV_E_TYMED);
   }
    }
    if (pformatetc->ptd)
    {
        if (!IsValidReadPtrIn (pformatetc->ptd, sizeof (DWORD))
            || !IsValidReadPtrIn (pformatetc->ptd, (size_t)pformatetc->ptd->tdSize))
        {
       intrDebugOut((DEB_IERROR,"\tDV_E_DVTARGETDEVICE\n"));

            return ResultFromScode (DV_E_DVTARGETDEVICE);
        }
    }
    return NOERROR;
}



INTERNAL wClassesMatch
    (REFCLSID clsidIn,
    LPOLESTR szFile)
{
    CLSID clsid;
    if (NOERROR==GetClassFile (szFile, &clsid))
    {
        return clsid==clsidIn ? NOERROR : ResultFromScode (S_FALSE);
    }
    else
    {
        // If we can't determine the class of the file (because it's
        // not a real file) then OK.  Bug 3937.
        return NOERROR;
    }
}



#ifdef KEVINRO_DUPLICATECODE

This routine also appears in ole1.lib in the OLE232\OLE1 directory

INTERNAL wWriteFmtUserType
    (LPSTORAGE pstg,
    REFCLSID   clsid)
{
    HRESULT hresult    = NOERROR;
    LPOLESTR   szProgID   = NULL;
    LPOLESTR   szUserType = NULL;

    ErrRtnH (ProgIDFromCLSID (clsid, &szProgID));
    ErrRtnH (OleRegGetUserType (clsid, USERCLASSTYPE_FULL, &szUserType));
    ErrRtnH (WriteFmtUserTypeStg (pstg, RegisterClipboardFormat (szProgID),
                                    szUserType));
  errRtn:
    delete szProgID;
    delete szUserType;
    return hresult;
}
#endif

#if DBG == 1

INTERNAL_(BOOL) wIsValidHandle
    (HANDLE h,
    CLIPFORMAT cf)    // cf==NULL means normal memory
{
    LPVOID p;
    if (CF_BITMAP == cf)
    {
        BITMAP bm;
        return (0 != GetObject (h, sizeof(BITMAP), (LPVOID) &bm));
    }
    if (CF_PALETTE == cf)
    {
        WORD w;
        return (0 != GetObject (h, sizeof(w), (LPVOID) &w));
    }
    if (!(p=GlobalLock(h)))
    {
        Puts ("Invalid handle");
        Puth (h);
        Putn();
        return FALSE;
    }
    if (!IsValidReadPtrIn (p, (UINT) min (UINT_MAX, GlobalSize(h))))
    {
        GlobalUnlock (h);
        return FALSE;
    }
    GlobalUnlock (h);
    return TRUE;
}
INTERNAL_(BOOL) wIsValidAtom (ATOM a)
{
    WCHAR sz[MAX_STR];
    if (a==0)
        return TRUE;
    if (a < 0xC000)
        return FALSE;
    if (0==GlobalGetAtomName (a, sz, MAX_STR))
        return FALSE;
    if ('\0'==sz[0])
        return FALSE;
    return TRUE;
}


// A "gentle" assert used in reterr.h
//


INTERNAL_(void) wWarn
    (LPSTR sz,
    LPSTR szFile,
    int iLine)
{
    intrDebugOut((DEB_WARN,
		  "Warning: %s:%u %s\n",
		  szFile,iLine,sz));
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\packmnkr.cxx ===
/*
    PackMnkr.cpp
    PackageMoniker

    This module implements the CPackagerMoniker class and
    CreatePackagerMoniker()

    Author:
    Jason Fuller    jasonful    Nov-2-1992

    Copyright (c) 1992  Microsoft Corporation
*/

#include <ole2int.h>
#include "packmnkr.h"
#include "..\server\ddedebug.h"
#include <ole1cls.h>
#include <winerror.h>

ASSERTDATA


STDMETHODIMP CPackagerMoniker::QueryInterface
    (REFIID riid, LPVOID * ppvObj)
{
    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT (ppvObj, LPVOID);

    if ((riid == IID_IMoniker)       || (riid == IID_IUnknown) ||
        (riid == IID_IPersistStream) || (riid == IID_IInternalMoniker))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    AssertSz (0, "Could not find interface\r\n");
    *ppvObj = NULL;
    return ReportResult(0, E_NOINTERFACE, 0, 0);
}

STDMETHODIMP_(ULONG) CPackagerMoniker::AddRef()
{
    M_PROLOG(this);
    return InterlockedIncrement((LONG *)&m_refs);
}

STDMETHODIMP_(ULONG) CPackagerMoniker::Release()
{
    M_PROLOG(this);
    Assert (m_refs > 0);
    ULONG cRefs = InterlockedDecrement((LONG *)&m_refs);
    if (0 == cRefs)
    {
        if (m_pmk)
        {
            m_pmk->Release();
        }

        if (m_szFile)
        {
            delete m_szFile;
        }

        delete this;
        return 0;
    }
    return cRefs;
}

STDMETHODIMP CPackagerMoniker::GetClassID (THIS_ LPCLSID lpClassID)
{
    M_PROLOG(this);
    *lpClassID = CLSID_PackagerMoniker;
    return NOERROR;
}

const CLSID CLSID_Ole2Package = {0xF20DA720, 0xC02F, 0x11CE, {0x92, 0x7B, 0x08, 0x00, 0x09, 0x5A, 0xE3, 0x40}};


STDMETHODIMP CPackagerMoniker::BindToObject (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riidResult, LPVOID * ppvResult)
{
    M_PROLOG(this);
    WIN32_FIND_DATA fd;
    HRESULT hr;

    COleTls Tls;
    if( Tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
    {
        // If this app doesn't want or can tolerate having a DDE
        // window then currently it can't use OLE1 classes because
        // they are implemented using DDE windows.
        //
        return CO_E_OLE1DDE_DISABLED;
    }

    // The following code ensures that the file exists before we try to bind it.
    HANDLE hFind = FindFirstFile(m_szFile, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
    
        hr = CoCreateInstance(CLSID_Ole2Package, NULL, CLSCTX_INPROC_SERVER, riidResult, ppvResult);
        
        if (SUCCEEDED(hr))        
        {   
            IPersistFile *pPersistFile;

            hr = ((IUnknown *)*ppvResult)->QueryInterface(IID_IPersistFile, (void **)&pPersistFile);
            
            if (SUCCEEDED(hr))            
            {
                hr = pPersistFile->Load(m_szFile, 0);             
                pPersistFile->Release();
            }
            else
                ((IUnknown *)*ppvResult)->Release();                
        }
	
        if (FAILED(hr))
            hr = DdeBindToObject (m_szFile, CLSID_Package, m_fLink, riidResult, ppvResult);        

        FindClose(hFind);
    }
    else
        hr = MK_E_CANTOPENFILE;
    return hr;
}

STDMETHODIMP CPackagerMoniker::IsRunning (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
                      LPMONIKER pmkNewlyRunning)
{
  M_PROLOG(this);
  VDATEIFACE (pbc);

  if (pmkToLeft)
    VDATEIFACE (pmkToLeft);
  if (pmkNewlyRunning)
    VDATEIFACE (pmkNewlyRunning);

  // There is no way to tell if a packaged object is running
  return ReportResult (0, S_FALSE, 0, 0);
}



STDAPI CreatePackagerMoniker(LPOLESTR szFile,LPMONIKER *ppmk,BOOL fLink)
{
    return CPackagerMoniker::Create (szFile,NULL,fLink,ppmk);
}

STDAPI CreatePackagerMonikerEx(LPOLESTR szFile,LPMONIKER lpFileMoniker,BOOL fLink,LPMONIKER * ppmk)
{
    return CPackagerMoniker::Create (szFile,lpFileMoniker,fLink,ppmk);
}

HRESULT CPackagerMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    Win4Assert(pUnkOuter == NULL);
    Win4Assert(*ppv == NULL);

    IMoniker *pmk = NULL;
    HRESULT hr = CreatePackagerMoniker (OLESTR(""), &pmk, FALSE);
    if (SUCCEEDED(hr))
    {
        *ppv = (void *)pmk;
    }
    return hr;
}

HRESULT CPackagerMoniker::Create(LPOLESTR szFile,LPMONIKER lpFileMoniker, BOOL fLink, LPMONIKER * ppmk)
{
HRESULT hresult = E_OUTOFMEMORY;
CPackagerMoniker *pmkPack = NULL;

    VDATEPTROUT (ppmk, LPMONIKER);
    *ppmk = NULL;

    if (NULL == szFile)
    {
        return MK_E_SYNTAX;
    }

    pmkPack = new CPackagerMoniker;
    if (NULL != pmkPack)
    {
        pmkPack->m_fLink = fLink;
        pmkPack->m_refs  = 1;

        // an exception could be caused by szFile being bogus
        __try
        {
            pmkPack->m_szFile = new  WCHAR [lstrlenW(szFile)+1];
            if (NULL != pmkPack->m_szFile)
            {
                lstrcpyW (pmkPack->m_szFile, szFile);

                // If we weren't given a FileMoniker try to create one now, else just hold on to the one given.
                if (NULL == lpFileMoniker)
                {
                    if (NOERROR == (hresult = CreateFileMoniker (szFile, &(pmkPack->m_pmk))))
                    {
                        *ppmk = pmkPack;
                    }
                }
                else
                {
                    pmkPack->m_pmk = lpFileMoniker;
                    pmkPack->m_pmk->AddRef();
                    *ppmk = pmkPack;
                    hresult = NOERROR;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            hresult = MK_E_SYNTAX;
        }

    }

    if ((NOERROR != hresult) && pmkPack)
    {
        Assert(0);
        pmkPack->Release();
    }

    return hresult;
}



/////////////////////////////////////////////////////////////////////
// The rest of these methods just delegate to m_pmk
// or return some error code.


STDMETHODIMP CPackagerMoniker::IsDirty (THIS)
{
    M_PROLOG(this);
    return ReportResult(0, S_FALSE, 0, 0);
    //  monikers are immutable so they are either always dirty or never dirty.
    //
}

STDMETHODIMP CPackagerMoniker::Load (THIS_ LPSTREAM pStm)
{
    M_PROLOG(this);
    return m_pmk->Load(pStm);
}


STDMETHODIMP CPackagerMoniker::Save (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty)
{
    M_PROLOG(this);
    return m_pmk->Save(pStm, fClearDirty);
}


STDMETHODIMP CPackagerMoniker::GetSizeMax (THIS_ ULARGE_INTEGER  * pcbSize)
{
    M_PROLOG(this);
    return m_pmk->GetSizeMax (pcbSize);
}

    // *** IMoniker methods ***
STDMETHODIMP CPackagerMoniker::BindToStorage (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID * ppvObj)
{
    M_PROLOG(this);
    *ppvObj = NULL;
    return ReportResult(0, E_NOTIMPL, 0, 0);
}

STDMETHODIMP CPackagerMoniker::Reduce (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER *
        ppmkToLeft, LPMONIKER  * ppmkReduced)
{
    M_PROLOG(this);
    return m_pmk->Reduce (pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced);
}

STDMETHODIMP CPackagerMoniker::ComposeWith (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
        LPMONIKER * ppmkComposite)
{
    M_PROLOG(this);
    return m_pmk->ComposeWith (pmkRight, fOnlyIfNotGeneric, ppmkComposite);
}

STDMETHODIMP CPackagerMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER * ppenumMoniker)
{
    M_PROLOG(this);
    return m_pmk->Enum (fForward, ppenumMoniker);
}

STDMETHODIMP CPackagerMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    M_PROLOG(this);
    return m_pmk->IsEqual (pmkOtherMoniker);
}

STDMETHODIMP CPackagerMoniker::Hash (THIS_ LPDWORD pdwHash)
{
    M_PROLOG(this);
    return m_pmk->Hash (pdwHash);
}

STDMETHODIMP CPackagerMoniker::GetTimeOfLastChange (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME * pfiletime)
{
    M_PROLOG(this);
    return m_pmk->GetTimeOfLastChange (pbc, pmkToLeft, pfiletime);
}

STDMETHODIMP CPackagerMoniker::Inverse (THIS_ LPMONIKER * ppmk)
{
    M_PROLOG(this);
    return m_pmk->Inverse (ppmk);
}

STDMETHODIMP CPackagerMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER *
        ppmkPrefix)
{
    M_PROLOG(this);
    return m_pmk->CommonPrefixWith (pmkOther, ppmkPrefix);
}

STDMETHODIMP CPackagerMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther, LPMONIKER *
        ppmkRelPath)
{
    M_PROLOG(this);
    return m_pmk->RelativePathTo (pmkOther, ppmkRelPath);
}

STDMETHODIMP CPackagerMoniker::GetDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPOLESTR * lplpszDisplayName)
{
    M_PROLOG(this);
    return m_pmk->GetDisplayName (pbc, pmkToLeft, lplpszDisplayName);
}

STDMETHODIMP CPackagerMoniker::ParseDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPOLESTR lpszDisplayName, ULONG * pchEaten,
        LPMONIKER * ppmkOut)
{
    M_PROLOG(this);
    return m_pmk->ParseDisplayName (pbc, pmkToLeft, lpszDisplayName, pchEaten,
                                     ppmkOut);
}


STDMETHODIMP CPackagerMoniker::IsSystemMoniker (THIS_ LPDWORD pdwMksys)
{
  M_PROLOG(this);
  VDATEPTROUT (pdwMksys, DWORD);

  *pdwMksys = MKSYS_NONE;
  return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddeatoms.h ===
/* ddeatoms.h */

//This is here because the file is #included by both client and server files
#define fDdeCodeInOle2Dll 1

// These atoms are defined in srvrmain.cpp 
extern ATOM aEditItems;
extern ATOM aFormats;
extern ATOM aOLE;
extern ATOM aProtocols;
extern ATOM aStatus;
extern ATOM aStdClose;
extern ATOM aStdCreate;
extern ATOM aStdCreateFromTemplate;
extern ATOM aStdEdit;
extern ATOM aStdExit;
extern ATOM aStdOpen;
extern ATOM aStdShowItem;
extern ATOM aSysTopic;
extern ATOM aTopics;

// defined in ddewnd.cpp
extern ATOM aChange;
extern ATOM aClose;
extern ATOM	aMSDraw;
extern ATOM aNullArg;
extern ATOM aOle;
extern ATOM	aSave;
extern ATOM aStdColorScheme;
extern ATOM aStdDocDimensions;
extern ATOM aStdDocName;
extern ATOM	aStdHostNames;
extern ATOM aStdTargetDevice ;
extern ATOM aSystem;

// defined in ddewnd.cpp
extern CLIPFORMAT cfBinary;             // "Binary format"
extern CLIPFORMAT cfNative;             // "NativeFormat"

// defined in srvrmain.cpp
extern CLIPFORMAT cfLink;               // "ObjectLink"
extern CLIPFORMAT cfOwnerLink;          // "Ownerlink"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   ddecli
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES = ..\..\server;..\..\..\..\common\$(DEST_TREE);..\..\..\..\ih
INCLUDES = $(INCLUDES);..\..\..\dcomrem;..\..\..\inc
INCLUDES = $(INCLUDES);..\..\..\class;..\..\..\objact
INCLUDES = $(INCLUDES);..\..\..\..\ole232\inc
INCLUDES = $(INCLUDES);..\..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);..\..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);..\..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);$(BASE_INC_PATH)

C_DEFINES= -DOLE_DDE_NO_GLOBAL_TRACKING=1\
           $(C_DEFINES)

SOURCES=      \
    ..\cnct_tbl.cxx \
    ..\ddedo.cxx    \
    ..\ddeioc.cxx   \
    ..\ddemnker.cxx \
    ..\ddeoo.cxx    \
    ..\ddeproxy.cxx \
    ..\ddechc.cxx   \
    ..\ddestg.cxx   \
    ..\ddewnd.cxx   \
    ..\ddeworkr.cxx \
    ..\modallp.cxx  \
    ..\packmnkr.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\modallp.cxx ===
/*

copyright (c) 1992  Microsoft Corporation

Module Name:

    modallp.cpp

Abstract:

    This module contains the code to wait for reply on a remote call.

Author:
    Johann Posch    (johannp)   01-March-1993 modified to use CoRunModalLoop

*/

#include "ddeproxy.h"


#define DebWarn(x)
#define DebError(x)
#define DebAction(x)
#if DBG==1
static unsigned iCounter=0;
#endif
//
// Called after posting a message (call) to a server
//
#pragma SEG(CDdeObject_WaitForReply)



INTERNAL CDdeObject::SendMsgAndWaitForReply
    (LPDDE_CHANNEL pChannel,
     int iAwaitAck,
     WORD wMsg,
     LPARAM lparam,
     BOOL fFreeOnError,
     BOOL fStdCloseDoc,
     BOOL fDetectTerminate,
     BOOL fWait )
{
#ifdef _MAC
#else
    DDECALLDATA DdeCD;
    BOOL    fPending;
    HRESULT hres;
    ULONG status = 0;



#if DBG == 1
    unsigned iAutoCounter;
    intrDebugOut((INTR_DDE,
		  "DdeObject::WaitForReply(%x) Call#(%x) awaiting %x\n",
		  this,
		  iAutoCounter=++iCounter,
		  iAwaitAck));
#endif

    // make sure we have a call control. if OLE2 stuff has never been run,
    // then we might not yet have a call control (since
    // ChannelThreadInitialize may not have been be called).

    COleTls tls;
    CAptCallCtrl *pCallCtrl = tls->pCallCtrl;

    if (pCallCtrl == NULL)
    {
	// OLE2 stuff has never been run and we dont yet have a CallCtrl
	// for this thread. Go create one now. ctor adds it to the tls.

	pCallCtrl = new CAptCallCtrl;
	if (pCallCtrl == NULL)
	{
	    intrDebugOut((DEB_ERROR,"SendRecieve2 couldn't alloc CallCtrl\n"));
	    return RPC_E_OUT_OF_RESOURCES;
	}
    }

    // see if we can send the message, and then send it...

    CALLCATEGORY  CallCat = fWait ? CALLCAT_SYNCHRONOUS : CALLCAT_ASYNC;

    if (pChannel->pCD != NULL)
    {
	// a DDE call is already in progress, dont let another DDE call out.
	hres =	E_UNEXPECTED;
    }
    else
    {
	// we dont know what interface is being called on, but we do
	// know it is NOT IRemUnknown (IRundown) so it does not matter
	// what we pass here as long as it is not IRemUnknown (IRundown).
	hres = CanMakeOutCall(CallCat, IID_IUnknown, NULL);
    }

    if ( FAILED(hres) )
    {
	intrDebugOut((INTR_DDE, "CanMakeOutCall failed:%x\n", hres));
	return hres;
    }

    // Note:  this is to detect a premature DDE_TERMINATE
    // here we care about if we receive a WM_DDE_TERMINATE instead ACK
    // the next call to WaitForReply will detect this state and return
    // since the terminate was send prematurly (Excel is one)
    //
    if ( fDetectTerminate ) {
        Assert(m_wTerminate == Terminate_None);
        // if this flag is on terminate should not execute the default code
        // in the window procedure
        m_wTerminate = Terminate_Detect;
    }


    pChannel->iAwaitAck = iAwaitAck;
    pChannel->dwStartTickCount = GetTickCount();

    // start looking only for dde messages first
    pChannel->msgFirst = WM_DDE_FIRST;
    pChannel->msgLast  = WM_DDE_LAST;
    pChannel->msghwnd  = pChannel->hwndCli;

    pChannel->fRejected = FALSE;
    // see if there is a thread window for lrpc communication
    // if so we have to dispatch this messages as well
    fPending = FALSE;

    intrDebugOut((DEB_ITRACE,
		  "+++ Waiting for reply: server: %x, client %x Call#(%x) +++\n",
		  pChannel->hwndSvr,
		  pChannel->hwndCli,
		  iAutoCounter));

    // prepare and enter the modal loop
    DdeCD.hwndSvr = pChannel->hwndSvr;
    DdeCD.hwndCli = pChannel->hwndCli;
    DdeCD.wMsg = wMsg;
    DdeCD.wParam = (WPARAM) pChannel->hwndCli,
    DdeCD.lParam = lparam;
    DdeCD.fDone = FALSE;
    DdeCD.fFreeOnError = fFreeOnError;
    DdeCD.pChannel = pChannel;

    pChannel->pCD = &DdeCD;

    //
    // Setting this value tells DeleteChannel NOT to delete itself.
    // If the value changes to Channel_DeleteNow while we are in
    // the modal loop, this routine will delete the channel
    //
    pChannel->wChannelDeleted = Channel_InModalloop;

    //
    // hres will be the return code from the message
    // handlers, or from the channel itself. The return
    // code comes from calls to SetCallState. Most of the
    // time, it will be things like RPC_E_DDE_NACK. However,
    // it may also return OUTOFMEMORY, or other ModalLoop
    // problems.
    //

    RPCOLEMESSAGE	 RpcOleMsg;
    RpcOleMsg.Buffer = &DdeCD;

    // Figure out the call category of this call by looking at the bit
    // values in the rpc message flags.

    DWORD dwMsgQInputFlag = gMsgQInputFlagTbl[CallCat];

    // Now construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.

    CCliModalLoop CML(0, dwMsgQInputFlag, 0);

    do
    {
	hres = CML.SendReceive(&RpcOleMsg, &status, pChannel);

    }  while (hres == RPC_E_SERVERCALL_RETRYLATER);


    if (hres != NOERROR)
    {
	intrDebugOut((DEB_ITRACE,
		      "**************** CallRunModalLoop returns %x ***\n",
		      hres));
    }

    if (m_wTerminate == Terminate_Received) {
        intrAssert(fDetectTerminate);
	//
	// There really wasn't an error, its just that the server decided
	// to terminate. If we return an error here, the app may decide
	// that things have gone awry. Excel, for example, will decide
	// that the object could not be activated, even though it has
	// already updated its cache information.
	//
	hres = NOERROR;
	intrDebugOut((DEB_ITRACE,
	    	      "::WaitForReply setting hres=%x\n",
		      hres));
	intrDebugOut((DEB_ITRACE,
	    	      "::WaitForReply posting TERMINATE to self hwnd=%x\n",
		      DdeCD.hwndCli));
        // set state to normal and repost message
        Verify (PostMessage (DdeCD.hwndCli, WM_DDE_TERMINATE,
                             (WPARAM)DdeCD.hwndSvr, (LPARAM)0));
    }
    m_wTerminate = Terminate_None;

    //
    // If the channel is to be deleted, then do it now. This flag would
    // have been set in the DeleteChannel routine.
    //
    if (pChannel->wChannelDeleted == Channel_DeleteNow)
    {
	intrDebugOut((INTR_DDE,
		  "::WaitForReply(%x) Channel_DeleteNow pChannel(%x)\n",
		  pChannel));

        // If the channel is closed then its pointer in the DdeChannel must
        // be NULL.  This assumes that the passed in "pChannel" is always
        // equal to either the "Doc" or "Sys" member channels.
        // This code fragment is patterned after a code fragment
        // found in CDdechannel::DeleteChannel().

        if(0 == pChannel->ReleaseReference())
        {
            if(pChannel == m_pDocChannel)
            {
                m_pDocChannel = NULL;
            }
            else
            {
                Assert(pChannel == m_pSysChannel);
                m_pSysChannel = NULL;
            }
        }

        // Excel will send TERMINATE before sending an ACK to StdCloseDoc
	return ResultFromScode (fStdCloseDoc ? DDE_CHANNEL_DELETED : RPC_E_DDE_POST);
    }
    pChannel->wChannelDeleted = 0;

    pChannel->iAwaitAck = 0;
    pChannel->pCD = NULL;

    intrDebugOut((DEB_ITRACE,
		  "### Waiting for reply done: server: %x, client %x hres(%x)###\n",
		  pChannel->hwndSvr,
		  pChannel->hwndCli,
		  hres));

    return hres;
#endif _MAC
}

// Provided IRpcChannelBuffer2 methods
HRESULT DDE_CHANNEL::SendReceive2(
	           /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
	           /* [out] */ ULONG __RPC_FAR *pStatus)
{
    pCD = (DDECALLDATA *) pMessage->Buffer;

    if(!wPostMessageToServer(pCD->pChannel,
                             pCD->wMsg,
                             pCD->lParam,
                             pCD->fFreeOnError))
    {
	intrDebugOut((DEB_ITRACE, "SendRecieve2(%x)wPostMessageToServer failed", this));
        return RPC_E_SERVER_DIED;
    }


    CAptCallCtrl *pCallCtrl = GetAptCallCtrl();

    CCliModalLoop *pCML = pCallCtrl->GetTopCML();

    hres = S_OK;
    BOOL fWait = !pCD->fDone;

    while (fWait)
    {
	HRESULT hr = OleModalLoopBlockFn(NULL, pCML, NULL);

	if (pCD->fDone)
	{
	    fWait = FALSE;
	}
	else if (hr != RPC_S_CALLPENDING)
	{
	    fWait = FALSE;
	    hres = hr;		// return result from OleModalLoopBlockFn()
	}
    }

    if (FAILED(hres))
    {
	intrDebugOut((DEB_ITRACE, "**** CallRunModalLoop returns %x ***\n", hres));
    }
    return hres;
}


void DDE_CHANNEL::SetCallState(SERVERCALLEX ServerCall, HRESULT hr)
{
    CallState = ServerCall;
    hres = hr;
    Win4Assert(pCD);
    pCD->fDone = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddeadv.cxx ===
// ddeadv.cpp
//
// Mapping from DDE advise to/from OLE 2.0 advises
//
// Author:
//      Jason Fuller    jasonful    8-16-92
//
// Copyright (c) 1992  Microsoft Corporation

#include "ole2int.h"
#include "srvr.h"
#include "ddedebug.h"
ASSERTDATA


INTERNAL CDefClient::DoOle20Advise
    (OLE_NOTIFICATION   options,
    CLIPFORMAT  	cf)
{
    HRESULT hresult = NOERROR;
    FORMATETC formatetc;
    formatetc.cfFormat  = cf;
    formatetc.ptd       = m_ptd;
    formatetc.lindex    = DEF_LINDEX;
    formatetc.dwAspect  = DVASPECT_CONTENT;
			  // only types 1.0 client wants
    formatetc.tymed     = TYMED_HGLOBAL | TYMED_MFPICT | TYMED_GDI;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::DoOle20Advise(options=%x,cf=%x)\n",
		  this,
		  options,
		  (ULONG)cf));
    ChkC(this);
    switch (options)
    {
	case OLE_CHANGED:
#ifdef UPDATE
	case OLE_SAVED:
#endif
	    if (0 == m_dwConnectionDataObj)
	    {
		Assert (m_lpdataObj);
		RetErr (m_lpdataObj->DAdvise  (&formatetc,0/* ADVF_PRIMEFIRST*/,
					    &m_AdviseSink,
					    &m_dwConnectionDataObj));
		Assert (m_dwConnectionDataObj != 0);
	    }
	    // Fall through:
	    // Even for OLE_CHANGED do an Ole Advise so we get OnClose
	    // notifications for linked objects.

#ifndef UPDATE
	case OLE_SAVED:
#endif
	case OLE_RENAMED: // Link case
	case OLE_CLOSED:
	    Assert (m_lpoleObj);
	    // Only do one OleObject::Advise even if 1.0 client asks
	    // for two advises for two different formats and two events,
	    // i.e., native and metafile, save and close.
	    if (m_lpoleObj && 0==m_dwConnectionOleObj)
	    {
		Puts ("Calling OleObject::Advise\r\n");
		Assert (m_dwConnectionOleObj == 0L);
		hresult = m_lpoleObj->Advise (&m_AdviseSink, &m_dwConnectionOleObj);
		if (hresult != NOERROR)
		{
		    goto errRtn;
		}
	    }
	    Assert (m_dwConnectionOleObj != 0);
	    break;

	default:
	    Assert(0);
	    break;
    }

errRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::DoOle20Advise hresult=%x\n",
		  this,hresult));


    return NOERROR;
}




INTERNAL CDefClient::DoOle20UnAdviseAll
    (void)
{
    HRESULT hr;
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::DoOle20UnAdviseAll\n",
		  this));

    ChkC(this);
    if (m_dwConnectionOleObj != 0L)
    {
	if (m_lpoleObj)
	{
	    intrDebugOut((DEB_ITRACE,
			  "%x ::DoOle20UnAdviseAll unadvise OLE obj\n",
			  this));
	    Puts ("Unadvising ole obj\r\n");
	    hr = m_lpoleObj->Unadvise (m_dwConnectionOleObj);
	    intrAssert(hr == NOERROR);
	    m_dwConnectionOleObj = 0L;
	}
    }
    if (m_dwConnectionDataObj != 0L)
    {
	if (m_lpdataObj)
	{
	    intrDebugOut((DEB_ITRACE,
			  "%x ::DoOle20UnAdviseAll unadvise DATA obj\n",
			  this));
	    Puts ("Unadvising data obj\r\n");
	    hr = m_lpdataObj->DUnadvise (m_dwConnectionDataObj);
	    intrAssert(hr == NOERROR);
	    m_dwConnectionDataObj = 0L;
	}
    }
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::DoOle20UnAdviseAll\n",
		  this));

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\trgt_dev.h ===
// trgt_dev.h

// OLE 1.0 Target Device

typedef struct _OLETARGETDEVICE
{
    USHORT otdDeviceNameOffset;
    USHORT otdDriverNameOffset;
    USHORT otdPortNameOffset;
    USHORT otdExtDevmodeOffset;
    USHORT otdExtDevmodeSize;
    USHORT otdEnvironmentOffset;
    USHORT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;

typedef OLETARGETDEVICE const FAR* LPCOLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\client\packmnkr.h ===
/*
	packmnkr.h
*/

class  CPackagerMoniker : public IMoniker
{
  public:
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) ( REFIID riid, LPVOID * ppvObj) ;
	STDMETHOD_(ULONG,AddRef) ()  ;
	STDMETHOD_(ULONG,Release) () ;

	// *** IPersist methods ***
	STDMETHOD(GetClassID) ( LPCLSID lpClassID) ;

	// *** IPersistStream methods ***
	STDMETHOD(IsDirty) () ;
	STDMETHOD(Load) ( LPSTREAM pStm) ;
	STDMETHOD(Save) ( LPSTREAM pStm,
					BOOL fClearDirty) ;
	STDMETHOD(GetSizeMax) ( ULARGE_INTEGER  * pcbSize) ;

	// *** IMoniker methods ***
	STDMETHOD(BindToObject) ( LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riidResult, LPVOID * ppvResult) ;
	STDMETHOD(BindToStorage) ( LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riid, LPVOID * ppvObj) ;
	STDMETHOD(Reduce) ( LPBC pbc, DWORD dwReduceHowFar, LPMONIKER *
		ppmkToLeft, LPMONIKER  * ppmkReduced) ;
	STDMETHOD(ComposeWith) ( LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
		LPMONIKER * ppmkComposite) ;
	STDMETHOD(Enum) ( BOOL fForward, LPENUMMONIKER * ppenumMoniker)
		;
	STDMETHOD(IsEqual) ( LPMONIKER pmkOtherMoniker) ;
	STDMETHOD(Hash) ( LPDWORD pdwHash) ;
	STDMETHOD(IsRunning) ( LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
		pmkNewlyRunning) ;
	STDMETHOD(GetTimeOfLastChange) ( LPBC pbc, LPMONIKER pmkToLeft,
		FILETIME * pfiletime) ;
	STDMETHOD(Inverse) ( LPMONIKER * ppmk) ;
	STDMETHOD(CommonPrefixWith) ( LPMONIKER pmkOther, LPMONIKER *
		ppmkPrefix) ;
	STDMETHOD(RelativePathTo) ( LPMONIKER pmkOther, LPMONIKER *
		ppmkRelPath) ;
	STDMETHOD(GetDisplayName) ( LPBC pbc, LPMONIKER pmkToLeft,
		LPOLESTR * lplpszDisplayName) ;
	STDMETHOD(ParseDisplayName) ( LPBC pbc, LPMONIKER pmkToLeft,
		LPOLESTR lpszDisplayName, ULONG * pchEaten,
		LPMONIKER * ppmkOut) ;
	STDMETHOD(IsSystemMoniker) ( LPDWORD pdwMksys) ;

	static HRESULT Create ( LPOLESTR szFile,LPMONIKER lpFileMoniker,BOOL fLink,LPMONIKER * ppmk) ;

  private:

	ULONG 	 		m_refs;
	LPOLESTR		m_szFile;
	LPMONIKER 		m_pmk;
	BOOL		 	m_fLink;


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddedebug.h ===
// ddeDebug.h
//
// Generic debug routines
//
// Author:
//		Jason Fuller	jasonful	8-16-92
//

#ifndef fDdedebug_h
#define fDdedebug_h

#define INTR_DDE 	0x00010000
#define INTR_CHNL 	0x00020000
#define INTR_PARAM 	0x00040000

//#define fDebugOutput
#define WIDECHECK(x) (x?x:L"<NULL>")
#define ANSICHECK(x) (x?x:"<NULL>")

#if DBG == 1
#define DEBUG_GUIDSTR(name,guid) WCHAR name [48]; StringFromGUID2( *guid , name , sizeof( name ) / sizeof(WCHAR));
#else
#define DEBUG_GUIDSTR(name,guid)
#endif
#ifdef _DEBUG

	// defined in clientddeworkr.cpp
	BOOL wIsValidHandle (HANDLE, CLIPFORMAT);
	BOOL wIsValidAtom (ATOM);

	#define DebugOnly(x) x
	#define ChkC(p) 			Assert (p && p->m_chk==chkDefClient)
	#define ChkS(p) 			Assert (p && p->m_chk==chkDdeSrvr)
	#define ChkD(p) 			Assert ((p) && (p)->m_chk==chkDdeObj)
	#define AssertIsDoc(p) 	Assert ((p) && (p)->m_pdoc==(p) && (p)->m_bContainer)
	
	#define ChkCR(p) 			RetZ (p && p->m_chk==chkDefClient)
	#define ChkSR(p) 			RetZ (p && p->m_chk==chkDdeSrvr)
	#define ChkDR(p) 			RetZ ((p) && (p)->m_chk==chkDdeObj)
	#define AssertIsDocR(p)	RetZ ((p) && (p)->m_pdoc==(p) && (p)->m_bContainer)

	#ifdef fDebugOutput
	
		#define Puti(i) do {char sz[50]; wsprintf(sz, " %lu ", (unsigned long) (i)); Puts(sz);} while(0)
		#define Puth(i) do {char sz[50]; wsprintf(sz, " 0x%lx ", (unsigned long) (i)); Puts(sz);} while(0)
		#define Puta(a) do {char sz[50]="NULL"; if (a) GlobalGetAtomName(a,sz,50); \
									Puth(a); Puts("\""); Puts(sz); Puts("\" "); } while(0)
		#define Putsi(i) do { Puts(#i " = "); Puti(i); Puts("\n");} while (0)
		#define Putn() Puts("\r\n")
	
	#else
	
		#undef  Puts
		#define Puts(i)  ((void)0)
		#define Puti(i)  ((void)0)
		#define Puth(i)  ((void)0)
		#define Puta(a)  ((void)0)
		#define Putsi(i) ((void)0)
		#define Putn()   ((void)0)
		
	#endif // fDebugOutput
	#define DEBUG_OUT(a,b) OutputDebugStringA(a);
#else
	#define DEBUG_OUT(a,b)
	#define Puti(i)  ((void)0)
	#define Puth(i)  ((void)0)
	#define Puta(a)  ((void)0)
	#define Putsi(i) ((void)0)
	#define Putn()   ((void)0)
	#define wIsValidHandle(h,cf) (TRUE)
	#define wIsValidAtom(a) (TRUE)
	#define DebugOnly(x)
	#define ChkC(p)
	#define ChkS(p)
	#define ChkD(p)
	#define AssertIsDoc(p)
	#define ChkCR(p)
	#define ChkSR(p)
	#define ChkDR(p)
	#define AssertIsDocR(p)
	
#endif // _DEBUG


// Stuff common to both client and server directories
	
#define POSITIVE_ACK (0x8000)
#define NEGATIVE_ACK (0x0000)

#include <reterr.h>

INTERNAL_(LPOLESTR) wAtomName (ATOM atom);
INTERNAL_(LPSTR) wAtomNameA (ATOM atom);
INTERNAL_(ATOM)	wDupAtom (ATOM aSrc);

INTERNAL wClassesMatch (REFCLSID clsid, LPOLESTR szFile);
INTERNAL wWriteFmtUserType (LPSTORAGE, REFCLSID);

#endif // fDdedebug_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddesite.cxx ===
// ddesite.cpp
//
// Methods for CDefClient::COleClientSiteImpl
//
// Author:
//      Jason Fuller    jasonful    8-16-92
//
// Copyright (c) 1990, 1991  Microsoft Corporation


#include <ole2int.h>
#include "srvr.h"
#include "ddedebug.h"

ASSERTDATA

STDUNKIMPL_FORDERIVED (DefClient, OleClientSiteImpl)


STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::SaveObject
    (void)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SaveObject\n",
		  this));

    ChkC(m_pDefClient);

    if (!m_pDefClient->m_fGotStdCloseDoc)
	m_pDefClient->ItemCallBack (OLE_SAVED);

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SaveObject\n",
		  this));
    return NOERROR;
}



STDMETHODIMP  NC(CDefClient,COleClientSiteImpl)::GetContainer
    (LPOLECONTAINER  FAR * lplpContainer)
{
    VDATEPTROUT( lplpContainer, LPOLECONTAINER);
    *lplpContainer = NULL;

    ChkC(m_pDefClient);
    return ResultFromScode (E_NOTIMPL);
}



STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::GetMoniker
    (DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    VDATEPTROUT( ppmk, LPMONIKER);
    *ppmk = NULL;

    ChkC(m_pDefClient);
    // OLE 1.0 does not support linking to embeddings
    return ReportResult(0, E_NOTIMPL, 0, 0);
}

STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::ShowObject
    (void)
{
    ChkC(m_pDefClient);
    Puts ("OleClientSite::ShowObject\r\n");
    // REVIEW:  what are we supposed do?
    return ResultFromScode (E_NOTIMPL);
}

STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::OnShowWindow
    (BOOL fShow)
{
    ChkC(m_pDefClient);
    Puts ("OleClientSite::OnShowWindow\r\n");
    // REVIEW: what are we supposed do?
    return NOERROR;
}

STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::RequestNewObjectLayout(void)
{
    ChkC(m_pDefClient);
    Puts ("OleClientSite::RequestNewObjectLayout\r\n");
    return ReportResult(0, S_FALSE, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddepack.h ===
#ifdef WIN32
extern "C"
{
#include <port1632.h>
}

#define MAKE_DDE_LPARAM(msg,lo,hi) PackDDElParam(msg,(UINT_PTR)lo,(UINT_PTR)hi)

#else

#define GET_WM_DDE_EXECUTE_HDATA(wParam,lParam) ((HANDLE) HIWORD(lParam))
#define GET_WM_DDE_DATA_HDATA(wParam,lParam) ((HANDLE) LOWORD(lParam))
#define GET_WM_DDE_REQUEST_ITEM(wParam,lParam) ((ATOM) HIWORD(lParam))
#define GET_WM_DDE_DATA_ITEM(wParam,lParam) ((ATOM) HIWORD(lParam))
#define MAKE_DDE_LPARAM(msg,lo,hi) MAKELONG(lo,hi)
#define DDEFREE(msg,lParam)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddeint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ddeint.h
//
//  Contents:   This file contains shared macros/state between the server
//		and client directories
//  Classes:
//
//  Functions:
//
//  History:    5-04-94   kevinro Commented/cleaned
//
//----------------------------------------------------------------------------

#define DEB_DDE_INIT	(DEB_ITRACE|DEB_USER1)

// global DDE class used to create windows in DDE.
extern LPTSTR  gOleDdeWindowClass;
extern HINSTANCE g_hinst;

// names of the DDE window classes
#ifdef _CHICAGO_
// Note: we have to create a unique string so that we
// register a unique class for each 16 bit app.
// The class space is global on chicago.
//

extern LPSTR szOLE_CLASSA;
extern LPSTR szSYS_CLASSA;
extern LPSTR szSRVR_CLASSA;


#define OLE_CLASSA	szOLE_CLASSA
#define SRVR_CLASSA	szSRVR_CLASSA
#define SRVR_CLASS 	szSRVR_CLASSA

#define DDEWNDCLASS  WNDCLASSA
#define DdeRegisterClass RegisterClassA
#define DdeUnregisterClass UnregisterClassA
#define DdeCreateWindowEx SSCreateWindowExA

#else

#define OLE_CLASS	   L"Ole2WndClass"
#define OLE_CLASSA	    "Ole2WndClass"

#define SRVR_CLASS	    (OLESTR("SrvrWndClass"))
#define SRVR_CLASSA         ("SrvrWndClass")

#define DDEWNDCLASS  WNDCLASS
#define DdeRegisterClass RegisterClass
#define DdeUnregisterClass UnregisterClass
#define DdeCreateWindowEx CreateWindowEx

#endif // !_CHICAGO_

STDAPI_(LRESULT) DocWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
STDAPI_(LRESULT) SrvrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
STDAPI_(LRESULT) SysWndProc (HWND hwnd, UINT  message, WPARAM wParam, LPARAM lParam);
STDAPI_(LRESULT) ClientDocWndProc (HWND hwnd,   UINT  message, WPARAM wParam, LPARAM lParam);
STDAPI_(LRESULT) DdeCommonWndProc (HWND hwnd,   UINT  message, WPARAM wParam, LPARAM lParam);

BOOL SendMsgToChildren (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


#define SIZEOF_DVTARGETDEVICE_HEADER (sizeof(DWORD) + (sizeof(WORD) * 4))

// forward declarations
class       CDefClient;
typedef     CDefClient FAR *LPCLIENT;

class       CDDEServer;
typedef     CDDEServer FAR   *LPSRVR;
typedef     CDDEServer FAR   *HDDE;  // used by ClassFactory table


typedef struct tagDISPATCHDATA
{
    SCODE       scode;                  // might be no necessary
    LPVOID      pData;                  // pointer to channel data
} DISPATCHDATA, *PDISPATCHDATA;


// SERVERCALLEX is an extension of SERVERCALL and represents the set of
// valid responses from IMessageFilter::HandleIncoming Call.

typedef enum tagSERVERCALLEX
{
    SERVERCALLEX_ISHANDLED      = 0,    // server can handle the call now
    SERVERCALLEX_REJECTED       = 1,    // server can not handle the call
    SERVERCALLEX_RETRYLATER     = 2,    // server suggests trying again later
    SERVERCALLEX_ERROR          = 3,    // error?
    SERVERCALLEX_CANCELED       = 5     // client suggests canceling
} SERVERCALLEX;




//
// The wire representation of STDDOCDIMENSIONS is a 16-bit
// format. This means instead of 4 longs, there are
// 4 shorts. This structure is used below to pick the data
// from the wire representation.
// backward compatible is the name of the game.
//
typedef struct tagRECT16
{
  SHORT left;
  SHORT top;
  SHORT right;
  SHORT bottom;

} RECT16, *LPRECT16;

//+---------------------------------------------------------------------------
//
//  Function:   ConvertToFullHWND
//
//  Synopsis:	This function is used to convert a 16-bit HWND into a 32-bit
//		hwnd
//
//  Effects:	When running in a VDM, depending on who dispatches the message
//		we can end up with either a 16 or 32 bit window message. This
//		routine is used to make sure we always deal with a 32bit
//		HWND. Otherwise, some of our comparisions are incorrect.
//
//  Arguments:  [hwnd] -- HWND to convert. 16 or 32 bit is fine
//
//  Returns:	Always returns a 32 bit HWND
//
//  History:    8-03-94   kevinro   Created
//
//  Notes:
//	This routine calls a private function given to use by OLETHK32
//
//----------------------------------------------------------------------------
inline
HWND ConvertToFullHWND(HWND hwnd)
{
    if (IsWOWThreadCallable() &&
       ((((UINT_PTR)hwnd & (UINT_PTR)~0xFFFF) == 0) ||
        (((UINT_PTR)hwnd & (UINT_PTR)~0xFFFF) == (UINT_PTR)~0xFFFF)))
    {
	return(g_pOleThunkWOW->ConvertHwndToFullHwnd(hwnd));
    }
    return(hwnd);
}

inline
void OleDdeDeleteMetaFile(HANDLE hmf)
{
    intrDebugOut((DEB_ITRACE,
		  "OleDdeDeleteMetaFile(%x)\n",
		  hmf));
    if (IsWOWThreadCallable())
    {
	intrDebugOut((DEB_ITRACE,
	    	      "InWow: calling WOWFreeMetafile(%x)\n",
		      hmf));

        if (!g_pOleThunkWOW->FreeMetaFile(hmf))
	{
	    return;
	}
	intrDebugOut((DEB_ITRACE,
	    	      "WOWFreeMetafile(%x) FAILED\n",
		      hmf));
    }
    intrDebugOut((DEB_ITRACE,
		  "Calling DeleteMetaFile(%x)\n",
		  hmf));

    DeleteMetaFile((HMETAFILE)hmf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddeerr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ddeerr.h
//
//  Contents:   Error codes from the previous release
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-94   kevinro Commented/cleaned
//
// This is actually the contents from ole2anac.h, with some parts removed.
// Specifically, including ole2anac.h renamed DAdvise and friends, which
// is bad.
//----------------------------------------------------------------------------
#if !defined( _OLE2ANAC_H_ )
#define _OLE2ANAC_H_

typedef enum tagSTGSTATE
{
    STGSTATE_DOC         = 1,
    STGSTATE_CONVERT     = 2,
    STGSTATE_FILESTGSAME = 4
} STGSTATE;


#define MK_E_EXCEEDED_DEADLINE      MK_E_EXCEEDEDDEADLINE
#define MK_E_NEED_GENERIC           MK_E_NEEDGENERIC
#define MK_E_INVALID_EXTENSION      MK_E_INVALIDEXTENSION
#define MK_E_INTERMEDIATE_INTERFACE_NOT_SUPPORTED \
    MK_E_INTERMEDIATEINTERFACENONOT_SUPPORTED
#define MK_E_NOT_BINDABLE           MK_E_NOTBINDABLE
#define S_TRUE                      S_OK

#define E_BLANK             OLE_E_BLANK
#define E_STATIC            OLE_E_STATIC
#define E_NOTRUNNING        OLE_E_NOTRUNNING
#define E_FORMAT            DV_E_CLIPFORMAT
#define OLE_E_CLSID         REGDB_E_CLASSNOTREG
#define OLE_E_NOTSUPPORTED  E_NOTIMPL
#define OLE_E_REGDB_KEY     REGDB_E_KEYMISSING
#define OLE_E_REGDB_FMT     REGDB_E_INVALIDVALUE


#define OLEVERB_PRIMARY     OLEIVERB_PRIMARY
#define OLEVERB_SHOW        OLEIVERB_SHOW

// these DDE error codes are not returned anymore; these definitions are
// here just to make existing code compile without changes.
#define RPC_E_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x000)
#define RPC_E_DDE_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x100)

#define RPC_E_DDE_BUSY              (RPC_E_DDE_FIRST + 0x0)
#define RPC_E_DDE_CANT_UPDATE       (RPC_E_DDE_FIRST + 0x1)
#define RPC_E_DDE_INIT              (RPC_E_DDE_FIRST + 0x2)
#define RPC_E_DDE_NACK              E_FAIL
#define RPC_E_DDE_LAUNCH            CO_E_APPNOTFOUND
#define RPC_E_DDE_POST              RPC_E_SERVER_DIED
#define RPC_E_DDE_PROTOCOL          (RPC_E_DDE_FIRST + 0x6)
#define RPC_E_DDE_REVOKE            (RPC_E_DDE_FIRST + 0x7)
#define RPC_E_DDE_SYNTAX_EXECUTE    RPC_E_INVALID_PARAMETER
#define RPC_E_DDE_SYNTAX_ITEM       RPC_E_INVALID_PARAMETER
#define RPC_E_DDE_UNEXP_MSG     	(RPC_E_DDE_FIRST + 0xa)
#define RPC_E_DDE_DATA              RPC_E_INVALID_PARAMETER


#define RPC_E_CONNECTION_LOST           (RPC_E_FIRST + 0x6)
#define RPC_E_BUSY                      (RPC_E_FIRST + 0x0)
#define RPC_E_MSG_REJECTED              (RPC_E_FIRST + 0x1)
#define RPC_E_CANCELLED                 (RPC_E_FIRST + 0x2)
#define RPC_E_DISPATCH_ASYNCCALL        (RPC_E_FIRST + 0x4)


#endif // _OLE2ANAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddesink.cxx ===
// ddesink.cpp
//
// Methods for CDefClient::CAdviseSinkImpl
//
// Author:
//      Jason Fuller    jasonful    8-16-92
//
// Copyright (c) 1990, 1991  Microsoft Corporation


#include <ole2int.h>
#include "srvr.h"
#include "ddedebug.h"


ASSERTDATA

STDUNKIMPL_FORDERIVED (DefClient, AdviseSinkImpl)

 BOOL PeekOneMessage
	(MSG FAR* pmsg,
	HWND hwnd,
	UINT message)
{
	// We have to verify pmsg->message because PeekMessage will return
	// WM_QUIT even if you didn't ask for it.

	if (SSPeekMessage (pmsg, hwnd, message, message, PM_REMOVE))
	{
		if (pmsg->message==message)
			return TRUE;
		else
		{
			AssertSz (pmsg->message == WM_QUIT, "Unexpected message");
			if (WM_QUIT==pmsg->message)
			{
				// Put message back
				PostQuitMessage ((int) pmsg->wParam);
			}
			return FALSE;
		}
	}
	else
		return FALSE;
}
		
	




STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnClose
    (void)
{
	MSG			msg;
	intrDebugOut((DEB_ITRACE,
		      "%x _IN CDefClient::OnClose\n",
		      this));

	ChkC(m_pDefClient);

	m_pDefClient->m_fInOnClose = TRUE;
	// AddRef/Release safety bracket.  Do not remove.
	m_pDefClient->m_pUnkOuter->AddRef();

	#ifdef _DEBUG
	if (m_pDefClient->m_bContainer)
	{
		if (NOERROR != m_pDefClient->NoItemConnections())
			Warn ("OnClose called on document before item");
	}
	#endif

	if (m_pDefClient->m_ExecuteAck.f)
	{
		// in case the server closes in the middle of a DoVerb, send the ACK
		// for the EXECUTE now to keep the messages in order.
		m_pDefClient->SendExecuteAck (NOERROR);
	}

	if (!m_pDefClient->m_fGotStdCloseDoc)
	{
		// if client sent us StdCloseDocument, then he certainly
		// is not in a state to receive callbacks
	    m_pDefClient->ItemCallBack (OLE_CLOSED);
	}

	// We have to check the message field because PeekMessage will return
	// WM_QUIT even if you didn't ask for it.
	if (PeekOneMessage (&msg, m_pDefClient->m_hwnd, WM_DDE_EXECUTE))
	{
	    LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,POSITIVE_ACK,
			  GET_WM_DDE_EXECUTE_HDATA(msg.wParam,msg.lParam));

            intrDebugOut((DEB_ITRACE,
		          "0x%p ::OnClose found StdCloseDocument in queue\n",
			  this));

	    if(!PostMessageToClient ((HWND)msg.wParam,
				     WM_DDE_ACK,
				     (WPARAM) m_pDefClient->m_hwnd,
				     lp))
	    {
		DDEFREE(WM_DDE_ACK,lp);
	    }

	}


	ChkC (m_pDefClient);

	if (m_pDefClient->m_bContainer)
	{
		// If the document (container) is closing, then we
		// should send a TERMINATE to the client windows.
		// We don't do this for items because a client window
		// may still be connected to another item.
		// Items within one document share one window.

		m_pDefClient->SendTerminateMsg ();
		ChkC (m_pDefClient);
		AssertIsDoc (m_pDefClient);
		m_pDefClient->ReleaseAllItems();
	}
	else
	{
		m_pDefClient->RemoveItemFromItemList ();
	}

	// If item was deleted in client app, m_lpoleObj could be NULL
  	m_pDefClient->ReleaseObjPtrs ();

	// If "this" is an item, get the doc that contains this item
	LPCLIENT pdoc = m_pDefClient->m_pdoc;
	Assert (pdoc);
	
	Assert (pdoc->m_chk==chkDefClient);
	if (pdoc->m_chk==chkDefClient && pdoc->m_fRunningInSDI)
	if (pdoc->m_fRunningInSDI)
	{
		Puts ("Running in SDI\r\n");
		// The server app never registered a class factory, so no
		// RevokeClassFactory will trigger the destruction of the
		// CDdeServer, so we do it here if there are no other clients
		// connected to that CDdeServer
		if (pdoc->m_psrvrParent->QueryRevokeClassFactory())
		{
			// Assert (No sibling documents)
			Verify (NOERROR==pdoc->m_psrvrParent->Revoke());	
			pdoc->m_psrvrParent = NULL;
		}
	}
	m_pDefClient->m_fInOnClose = FALSE;

	// AddRef/Release safety bracket.  Do not remove.
	// Do not use m_pDefClient after this Release.
	m_pDefClient->m_pUnkOuter->Release();

	intrDebugOut((DEB_ITRACE,
		      "%x _OUT CDefClient::OnClose\n",
		      this));
}




STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnSave
    (THIS)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::OnSave\n",
		  this));

    ChkC(m_pDefClient);
    if (!m_pDefClient->m_fInOleSave)
    {
	// If we called OleSave to get the native data, then of course
	// we will get an OnSave notification.
	m_pDefClient->ItemCallBack (OLE_SAVED);
    }
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::OnSave\n",
		  this));
}



STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnDataChange
    (THIS_ FORMATETC FAR* pFormatetc,
    STGMEDIUM FAR* pStgmed)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::OnDataChange pFormatetc=%x\n",
		  this,
		  pFormatetc));
    // note we are ignoring both the pformatetc and the pStgMed.
    // ItemCallBack will ask (using GetData) for the data the client wants.
    // We are treating a call to this function as a simple Ping.

    ChkC(m_pDefClient);
    m_pDefClient->ItemCallBack (OLE_CHANGED);
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::OnDataChange\n",
		  this));
}



STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnRename
    (THIS_ LPMONIKER pmk)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::OnRename pmk=%x\n",
		  this,pmk));

    LPOLESTR szFile=NULL;

    ChkC(m_pDefClient);
    if (Ole10_ParseMoniker (pmk, &szFile, NULL) != NOERROR)
    {
	// Wrong type of moniker
	intrDebugOut((DEB_IERROR,
		      "%x ::OnRename pmk=%x wrong moniker\n",
		      this,pmk));
    }
    else
    {
	intrDebugOut((DEB_ITRACE,
		      "%x ::OnRename pmk=%x pmk.Name=(%ws)\n",
		      this,
		      pmk,
		      WIDECHECK(szFile)));
	// Notify client
	m_pDefClient->ItemCallBack (OLE_RENAMED, szFile);
	CoTaskMemFree(szFile);
    }

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::OnRename\n",
		  this));
}



STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnViewChange
    (THIS_ DWORD aspects, LONG lindex)
{
    // Response to IViewObjectAdvise::Advise, which we do not do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddesrvr.h ===
/*
	ddesrvr.h
	Header file for ddesrvr.cpp
	
	Author:
		Jason Fuller	jasonful		8-11-92
*/

#ifndef fDdesrvr_h
#define fDdesrvr_h

// Defined in cftable.cpp
STDAPI RemGetInfoForCid
	(REFCLSID 				clsid,
	LPDWORD 					pgrf,
	LPCLASSFACTORY FAR* 	ppCF,
	LPHANDLE FAR* 			pphwndDde,
	BOOL FAR* FAR* 		ppfAvail,
	BOOL						fEvenIfHidden=FALSE);

INTERNAL DestroyDdeSrvrWindow	(HWND hwnd,	ATOM aClass);
INTERNAL CreateCommonDdeWindow (void);
INTERNAL DestroyCommonDdeWindow (void);

INTERNAL IsRunningInThisTask	(LPOLESTR szFile, BOOL FAR* pf);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddesrvr.cxx ===
/*
    ddesrvr.cpp

    Author:
    Jason Fuller    jasonful    8-11-92
*/

#include <ole2int.h>
#include <dde.h>
#include <olerem.h>
#include "srvr.h"
#include "ddeatoms.h"
#include "ddesrvr.h"
#include "ddedebug.h"
#include "map_up.h"

#include "map_dwp.h"

ASSERTDATA

// Dde Common Window stuff

UINT         cCommonWindows = 0;

#ifdef _CHICAGO_
// Note: we have to create a unique string so that get
// register a unique class for each 16 bit app.
// The class space is global on chicago.
//
LPSTR szOLE_CLASSA              = "Ole2WndClass 0x########  ";
LPSTR szSRVR_CLASSA             = "SrvrWndClass 0x######## ";

LPSTR szDdeServerWindow = "DDE Server Window";
#define szDdeCommonWindowClass szCOMMONCLASSA
// void LazyFinishDDECoRegisterClassObject(REFCLSID rclsid); // com\objact\sobjact.cxx
#else
const LPOLESTR szDdeServerWindow = OLESTR("DDE Server Window");
const LPOLESTR szDdeCommonWindowClass = OLESTR("DdeCommonWindowClass");
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CreateDdeSrvrWindow
//
//  Synopsis:   When CoRegisterClassObject is called, this function
//              is called to create a DDE window to listen for DDE messages
//              from a 1.0 client.
//
//  Effects:
//
//  Arguments:  [clsid] --
//              [aClass] --
//              [phwnd] --
//              [fIsRunning] --
//              [aOriginalClass] --
//              [cnvtyp] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-27-94   kevinro Commented/cleaned
//             13-Jul-94  BruceMa   Make register/unregister dde window class
//                                    thread safe
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CreateDdeSrvrWindow
    (REFCLSID clsid,
    ATOM      aClass,
    HWND FAR* phwnd,        // optional out parm: created window
    BOOL      fIsRunning,   // Is the item atom a file in the ROT?
    ATOM      aOriginalClass,   // for TreatAs/ConvertTo case
    CNVTYP    cnvtyp)
{
    intrDebugOut((DEB_DDE_INIT,"0 _IN CreateDdeSrvrWindow\n"));

    VDATEHEAP();
    HWND                hwnd    = NULL;

    HRESULT             hresult = NOERROR;

    DdeClassInfo        ddeClassInfo;

    ddeClassInfo.dwContextMask = CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER;
    ddeClassInfo.fClaimFactory = FALSE;

    // Null out parameter in case of error
    if (phwnd)
    {
        *phwnd = NULL;
    }

    intrAssert (wIsValidAtom (aClass));

    //
    // See if this process is registered as a class server for
    // the requested class. If it isn't, then check for a running
    // object.
    //
    if (CCGetClassInformationForDde(clsid,&ddeClassInfo) == FALSE)
    {
        intrDebugOut((DEB_DDE_INIT,
                      "CreateDdeSrvrWindow No class information available\n"));

        //
        // The ClassObject was not found in the table.
        //

        if (fIsRunning)
        {
            // Link case.
            // An SDI app was launched by the user (without "-Embedding").
            // It did not register its class factory. (It never does.)
            // Meanwhile, a DDE_INIT with a filename as an item atom was
            // broadcasted.
            // We are in the task of the SDI app that loaded that filename,
            // so this function was called.
            // So we need to create the window even though no class factory
            // was registered.
            // Call CDDEServer::Create with a lot of NULLs.
            // Once the DDE_INIT is passed along to the server window, it
            // should immediately cause a doc window to be created.
            // Must be SDI or we wouldn't have this problem.
            //
            // This works because we are going to attempt to 'bind' to the
            // object which is the subject of the link. If the link object
            // was registered as running, we will find it. Otherwise, the
            // attempt to create via the class factory will fail, since the
            // class factory doesn't exist.
            //

            intrDebugOut((DEB_DDE_INIT,
                      "::CreateDdeServerWindow fIsRunning - override dwFlags\n"));

            //
            // NULL out the entire structure, then set only the flags
            //
            memset(&ddeClassInfo,0,sizeof(ddeClassInfo));
            ddeClassInfo.dwFlags = REGCLS_SINGLEUSE;


        }
        else
        {
            intrDebugOut((DEB_DDE_INIT,
                          "CreateDdeServerWindow Returning FALSE\n"));

            hresult = S_FALSE;
            goto errRtn;
        }
    }
    intrDebugOut((DEB_DDE_INIT,
                  "::CreateDdeServerWindow found class\n"));
    // Create() does the real work: creates a CDDEServer and the window.
    WCHAR szClass[MAX_STR];
    lstrcpyW (szClass, wAtomName (aClass));
    Assert (szClass[0]);

    hresult = CDDEServer::Create(szClass,
                                 clsid,
                                 &ddeClassInfo,
                                 &hwnd,
                                 aOriginalClass,
                                 cnvtyp);
    if (hresult != NOERROR)
    {
        intrDebugOut((DEB_IERROR,
                      "CreateDdeServerWindow CDDEServer::Create returns %x\n",
                      hresult));
        goto errRtn;
    }

    Assert (IsWindowValid(hwnd));

    // Fill in out parameter
    if (phwnd)
    {
        *phwnd = hwnd;
    }


errRtn:
    VDATEHEAP();
    intrDebugOut((DEB_DDE_INIT,
                  "0 _OUT CreateDdeSrvrWindow %x\n",
                  hresult));
    return hresult;

}



//+---------------------------------------------------------------------------
//
//  Function:   DestroyDdeSrvrWindow
//
//  Synopsis:   Destroy a DDE server window
//
//  Effects:
//
//  Arguments:  [hwnd] -- Window to destroy
//              [aClass] -- Class for server
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-24-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL DestroyDdeSrvrWindow
    (HWND hwnd,
    ATOM aClass)
{
    intrDebugOut((DEB_ITRACE,
                  "0 _IN DestroyDdeSrvrWindow\n"));
    VDATEHEAP();
    Assert (IsAtom (aClass));

    // Make sure it is a server window
    RetZ (IsWindowValid (hwnd));
    RetZ (GetWindowWord (hwnd, WW_LE) == WC_LE);


    // Get the Common window for this task.

    HWND hwndCommonServer = (HWND)TLSGetDdeServer();

    if (hwndCommonServer == NULL)
    {
        intrDebugOut((DEB_IERROR,"hwndCommonServer != NULL\n"));
        return(E_UNEXPECTED);
    }
    if (!IsWindow(hwndCommonServer))
    {
        intrAssert(IsWindow(hwndCommonServer));
        return(E_UNEXPECTED);
    }

    // Get the map from the common window
    CMapUintPtr FAR *pmapClassToHwnd;
    Assert (sizeof (CMapUintPtr FAR *)==sizeof(LONG));
    pmapClassToHwnd = (CMapUintPtr FAR *) GetWindowLongPtr (hwndCommonServer, 0);
    Assert (pmapClassToHwnd);

    // Make sure the window we're deleting is the server window for this class
    void *hwndSrvr = NULL;    // COM+ 22885
    RetZ (pmapClassToHwnd->Lookup (aClass,hwndSrvr) && hwndSrvr == hwnd);

    RetZ (SSDestroyWindow (hwnd));

    // Remove this window from the map
    pmapClassToHwnd->RemoveKey (aClass);

    VDATEHEAP();
    intrDebugOut((DEB_ITRACE,
                  "0 _OUT DestroyDdeSrvrWindow\n"));

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   DdeCommonWndProc
//
//  Synopsis:   Window proc for the common dde server window that
//              listens for all WM_DDE_INITIATEs
//
//  Effects:    When a DDE_INITIATE comes in, this routine will determine
//              the class of the object being requested. If the class is
//              served by this thread, then it will create a window to
//              converse with the server.
//
//  Arguments:  [hWnd] --  hWnd of Common DDE
//              [wMsg] --  msg
//              [wParam] --  Return Window to converse with
//              [lParam] --  HIWORD(aItem) LOWORD(aClass)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-27-94   kevinro Commented/cleaned
//
//  Notes:
//
//  When running in a VDM, it is possible that this window was dispatched
//  without having a full window handle. This happens when the getmessage
//  was dispatched from 16-bit. Therefore, we need to convert the hwnd to
//  a full hwnd before doing any comparision functions.
//
//----------------------------------------------------------------------------
STDAPI_(LRESULT)
DdeCommonWndProc(HWND hwndIn, UINT wMsg, WPARAM wParam, LPARAM lParam)
{

    switch (wMsg)
    {
    case WM_DDE_INITIATE:
    {
        VDATEHEAP();
        ATOM aClass = LOWORD(lParam);
        ATOM aItem  = HIWORD(lParam);
        HWND hwnd;

        CNVTYP cnvtyp = cnvtypNone;

        BOOL fIsFile= FALSE;       // Must initialize
        BOOL fIsRunning= FALSE;    // Must initialize
        BOOL fUnsavedDoc = FALSE;  // Is the "file" really an unsaved doc
        HWND hwndServer;
        HRESULT hresult;


        //
        // From this point forward, we need to insure we are using a
        // FULL hwnd.
        //
        hwnd = ConvertToFullHWND(hwndIn);

        //
        // The following should already be initialized
        //
        intrAssert (aOLE != NULL);
        intrAssert (aSysTopic != NULL);

        if (aItem==aOLE || aItem==aSysTopic
            || (fIsFile=IsFile (aItem, &fUnsavedDoc)))
        {


            intrDebugOut((DEB_DDE_INIT,
                          "DdeCommonWndProc:hWnd(%x) DDE_INITIATE cls(%ws)\n",
                          hwnd,
                          wAtomName(aClass)));

            //
            // Get the ClassToHwnd map for this thread
            //
            CMapUintPtr FAR *pmapClassToHwnd;
            
            pmapClassToHwnd = (CMapUintPtr FAR *) GetWindowLongPtr (hwnd, 0);
            Assert (pmapClassToHwnd);


            // Convert atom to CLSID, taking into account
            // TreatAs and AutoConvert.
            CLSID clsid;
            ATOM aOriginalClass = aClass;

            if (CLSIDFromAtomWithTreatAs (&aClass, &clsid, &cnvtyp) != NOERROR)
            {
                intrDebugOut((DEB_IERROR,"Could not get clsid for this class\n"));
                return 0L;
            }

            void *pServerTmp;
            if (TRUE == pmapClassToHwnd->Lookup (aClass, pServerTmp))
            {
                //
                // Since a server window for this class already exists, but is a child window
                // of ours, we will send it this message directly.
                //

                intrDebugOut((DEB_DDE_INIT,
                              "DdeCommonWndProc Server cls exists. Forwarding to %x\n",
                              pServerTmp));

                return SSSendMessage ((HWND)pServerTmp, WM_DDE_INITIATE, wParam,lParam);

            }

            if (CoIsOle1Class (clsid))
            {
                // We have no business intercepting Initiates sent
                // to 1.0 servers
                intrDebugOut((DEB_DDE_INIT,
                              "DdeCommonWndProc: Its a OLE 1.0 class\n"));
                return 0L;
            }

#if 0 // ifdef _CHICAGO_
            // On Win95 we complete the CoRegisterClassObject lazily.  When the first
            // CoGetClassObject is issued for any class registered in an apartment we
            // complete the registration for all classes in that apartment.  This must
            // also happen if the first CoGetClassObject happens implicitly due to a
            // WM_DDE_INITIATE request from an OLE1 client.
            LazyFinishDDECoRegisterClassObject(clsid);
#endif // _CHICAGO_

            if (fIsFile)
            {
                // Link case
                WCHAR szFile[MAX_STR];

                WORD cb= (WORD) GlobalGetAtomName (aItem, szFile, MAX_STR);
                Assert (cb>0 && cb < MAX_STR-1);
                intrDebugOut((DEB_DDE_INIT,
                              "Looking for file %ws\n",szFile));

                IsRunningInThisTask (szFile, &fIsRunning);
            }

            // If it's not a file, it can't be running, obviously.
            intrAssert (fIsFile || !fIsRunning);

            if (NOERROR == (hresult=(CreateDdeSrvrWindow (clsid,
                                                          aClass,
                                                          &hwndServer,
                                                          fIsRunning,
                                                          aOriginalClass,
                                                          cnvtyp))))
            {

                    // Indicate that we have created a server window
                    // for this class.  We could have used any value in
                    // place of hwndServer_.  It's just a flag.
                    // REVIEW jasonful: how to handle OOM?

                    pmapClassToHwnd->SetAt (wDupAtom(aClass), hwndServer);

#if DBG == 1
                            // Verify the SetAt we just did.
                            void FAR* pv;
                            Verify (pmapClassToHwnd->Lookup(aClass, pv));
                            Assert (pv == hwndServer);
#endif
                    // Pass the INITIATE along to the real,
                    // newly-created server window and forge
                    // the sender's hwnd to be whoever called
                    // the common server window.
                    // SendMessage should return 1L is doc is running,
                    // indicating an ACK was sent.
                    Assert (IsWindowValid (hwndServer));
                    SSSendMessage (hwndServer, WM_DDE_INITIATE, wParam,lParam);
                    intrDebugOut((DEB_DDE_INIT,
                                  "DdeCommonWndProc:hWnd(%x) DDE_INITIATE complete(%ws)\n",
                                  hwnd,
                                  wAtomName(aClass)));
                    VDATEHEAP();
            }
            else
            {
                if (S_FALSE!=GetScode(hresult))
                {
                    intrDebugOut((DEB_IERROR,
                                  "DCWP: CreateDdeSrvrWindow failed %x\n",
                                  hresult));
                }
            }
        }
        else
        {
            //
            // We have a DDE_INITIATE message that needs to be forwarded to our
            // child window.
            //
            return SendMsgToChildren(hwnd,wMsg,wParam,lParam);
        }
    return 0L;
    }
    break;

    case WM_DESTROY:
    {
        //
        // When this window is destroyed, we cleanup the
        // windows attached data.
        //

        CMapUintPtr FAR *pmapClassToHwnd;
        pmapClassToHwnd = (CMapUintPtr FAR *) GetWindowLongPtr (hwndIn, 0);

        //
        // Make sure there are no server windows
        // created by this common window still extant. If there are, print out
        // a message on a debug build. Otherwise, there really isn't much we
        // can do about it. We are already closing down. The DDE emulation layer
        // will send appropriate terminate messages.
        //

    #if DBG == 1
        if (pmapClassToHwnd && !pmapClassToHwnd->IsEmpty())
        {
            intrDebugOut((DEB_ERROR,
                          "DCDW Leaking active OLE 1.0 clients\n"));
            intrDebugOut((DEB_ERROR,
                          "There were active OLE 1.0 connections at shutdown\n"));
        }
    #endif
        delete pmapClassToHwnd;
        return(0);
    }



    default:
        return SSDefWindowProc (hwndIn, wMsg, wParam, lParam);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   CreateCommonDdeWindow
//
//  Synopsis:   Creates a DDE window for initiating conversations with this
//              threads objects.
//
//  Effects:    Creates a window that responds to DDE_INITIATE messages, and
//              determines if it needs to respond to the INITIATE. This
//              routine is called by OleInitializeEx()
//
//              The handle to the created window is placed in the TLS
//              structure.
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-27-94   kevinro   Converted to OLE32
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CreateCommonDdeWindow
    (void)
{
    intrDebugOut((DEB_ITRACE,"%p _IN CreateCommonDdeWindow\n",0));

    HRESULT hr = NOERROR;
    HWND hwndDdeServer;
    COleTls tls;

#if DBG==1
    if (tls->dwFlags & OLETLS_DISABLE_OLE1DDE)
    {
        // If DDE use is disabled we shouldn't have gotten here.
        Assert(!"Executing CreateCommonDdeWindow when DDE is disabled");
    }

    if (tls->hwndDdeServer != NULL || tls->cOleInits == 0)
    {
        // A DdeServer window better not already exist and OLE better
        // already be initialized.
        Assert(!"Executing CreateCommonDdeWindow when window already exists or OLE not initialized");
    }
#endif

    if (!(hwndDdeServer = DdeCreateWindowEx(0, gOleDdeWindowClass,
                                        szDdeServerWindow,
                                        WS_POPUP,0,0,0,0,
                                        NULL,NULL,
                                        g_hmodOLE2, NULL)))
    {
        intrDebugOut((DEB_IERROR,
                      "CreateCommonDocWindow() has failed %x\n",
                      GetLastError()));

        hr =  E_OUTOFMEMORY;
        goto exitRtn;
    }

    intrDebugOut((DEB_ITRACE,
                  "CreateCommonDocWindow() hwndDdeServer=%x\n",
                  hwndDdeServer));

    // Give the common window a map from classes to server windows

    CMapUintPtr FAR *pmapClassToHwnd;

    if ((pmapClassToHwnd = new CMapUintPtr) == NULL)
    {
        intrDebugOut((DEB_ERROR,"pmapClassToHwnd != NULL\n"));
        hr =  E_OUTOFMEMORY;
        goto errRtn;
    }

    SetWindowLongPtr (hwndDdeServer, 0, (LONG_PTR)pmapClassToHwnd);
    //
    // Set the pointer to the server in the TLS data
    //

    tls->hwndDdeServer = hwndDdeServer;

exitRtn:

    intrDebugOut((DEB_ITRACE,"%p _OUT CreateCommonDocWindow (%x)\n",0,hr));

    return(hr);

    //
    // In the error case, if the hwnDdeServer != NULL, then destroy it
    //
errRtn:
    if (hwndDdeServer != NULL)
    {
        SSDestroyWindow(hwndDdeServer);
    }

    goto exitRtn;
}





//+---------------------------------------------------------------------------
//
//  Function:   DestroyCommonDdeWindow
//
//  Synopsis:   Destroys the common DDE Server window
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-27-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL DestroyCommonDdeWindow
    (void)
{
    intrDebugOut((DEB_ITRACE,"%p _IN DestroyCommonDdeWindow\n",0));

    HRESULT hr = S_OK;
    COleTls tls;

    HWND hwndDdeServer = tls->hwndDdeServer;

    if (hwndDdeServer == NULL)
    {
        goto errRtn;
    }


    //
    // The map from the common window got deleted in DdeCommonWndProc
    //

    //
    // If destroying this window fails, there isn't much we can
    // do about it.
    //
    if(!SSDestroyWindow (hwndDdeServer))
    {
        hr = E_UNEXPECTED;
    }

    // NULL out the TLS
    tls->hwndDdeServer = NULL;

errRtn:
    intrDebugOut((DEB_ITRACE,"%p _OUT DestroyCommonDdeWindow %x\n",0,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsRunningInThisTask
//
//  Synopsis:   Determine if the given file is running in the current task
//
//  Effects:    Calls a special function in the ROT to determine if the
//              file szFile is loaded as a moniker in the current task
//
//  Arguments:  [szFile] -- Filename
//              [pf] -- Points to a BOOL. Returned TRUE if running
//
//  History:    6-29-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL IsRunningInThisTask(LPOLESTR szFileIn,BOOL FAR* pf)  // out parm
{
    HRESULT hresult;

    intrDebugOut((DEB_DDE_INIT,
                  "IsRunninginThisTask szFileIn=%ws\n",
                  WIDECHECK(szFileIn)));

    //
    // The RunningObjectTable always stores LONG filenames, therefore we
    // need to convert this name to the long name for the lookup.
    //

    WCHAR szFile[MAX_PATH];
    if ((lstrlenW(szFileIn) == 0) || (InternalGetLongPathNameW(szFileIn,szFile,MAX_PATH) == 0))
    {
        //
        // Unable to determine a long path for this object. Use whatever we were
        // handed.
        //
        intrDebugOut((DEB_DDE_INIT,"No conversion to long path. Copy szFileIn\n"));
        lstrcpyW(szFile,szFileIn);
    }

    intrDebugOut((DEB_DDE_INIT,"Long file szFile(%ws)\n",szFile));

    hresult = GetLocalRunningObjectForDde(szFile,NULL);

    *pf = (hresult == S_OK);

    intrDebugOut((DEB_DDE_INIT,
                  "IsRunninginThisTask szFile=%ws returns %s\n",
                  WIDECHECK(szFile),
                  *pf?"TRUE":"FALSE"));
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\itemutil.h ===
// itemutil.h
//
// Corresponds to itemutil.cpp

void ChangeOwner (HANDLE hmfp);
INTERNAL ScanItemOptions (LPSTR   lpbuf, int far *lpoptions);
INTERNAL_(BOOL) MakeDDEData (HANDLE hdata, int format, LPHANDLE lph, BOOL fResponse);
INTERNAL_(BOOL)     IsAdviseStdItems (ATOM aItem);
INTERNAL_(int)  GetStdItemIndex (ATOM aItem);
void ChangeOwner (HANDLE hmfp);
INTERNAL_(HANDLE)  MakeItemData (DDEPOKE FAR *lpPoke, HANDLE hPoke, CLIPFORMAT cfFormat);
INTERNAL_(HANDLE)  DuplicateMetaFile (HANDLE hSrcData);
INTERNAL_(HBITMAP)  DuplicateBitmap (HBITMAP hold);
INTERNAL wSetTymed (LPFORMATETC pformatetc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\doc.cxx ===
/***************************************************************************\
* Module Name: Doc.c Document Main module
*
* Purpose: Includes All the document level object communication related.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded (modified for 2.0)
*
\***************************************************************************/

#include "ole2int.h"
//#include "cmacs.h"
#include <dde.h>

#include "srvr.h"
#include "ddedebug.h"
#include "valid.h"
ASSERTDATA

extern  ATOM     aStdClose;
extern  ATOM     aStdShowItem;
extern  ATOM     aStdDoVerbItem;
extern  ATOM     aStdDocName;
extern  ATOM     aTrue;
extern  ATOM     aFalse;

extern  HANDLE   hddeRename;
extern  HWND     hwndRename;

#ifdef _CHICAGO_
#define szDDEViewObj "DDE ViewObj"
#else
#define szDDEViewObj L"DDE ViewObj"
#endif


// HRESULT DdeHandleIncomingCall(HWND hwndCli, WORD wCallType);

//
// Call CoHandleIncomingCall which will call the message filter
// Note: only call this functions with:
//  -  CALLTYPE_TOPLEVEL  ... for synchranous calls
//  -  CALLTYPE_ASYNC     ... for async calls
//
HRESULT DdeHandleIncomingCall(HWND hwndCli, WORD wCallType)
{

    Assert(!"DdeHandleIncomingCall not implemented");

    return(RPC_E_CALL_REJECTED);

    // Review: bug: get the correcr hwnd
    switch ( /* CoHandleIncomingCall(hwndCli, wCallType, NULL) */ wCallType) {
    default:
    case SERVERCALL_ISHANDLED:  // call can be proccesed
        return NOERROR;

    case SERVERCALL_REJECTED:       // call rejected
        return  ResultFromScode(RPC_E_CALL_REJECTED);

    case SERVERCALL_RETRYLATER: // call should be retried later
        return  ResultFromScode(RPC_E_DDE_BUSY);
    }
}


INTERNAL CDefClient::Create
(
    LPSRVR      lhOLESERVER,
    LPUNKNOWN   lpunkObj,
    LPOLESTR       lpdocName,
    const BOOL  fSetClientSite,
    const BOOL  fDoAdvise,
    const BOOL  fRunningInSDI,  // optional
    HWND FAR*   phwnd           // optional
)
{
    LPSRVR      lpsrvr   = NULL;
    LPCLIENT    lpclient = NULL;
    HANDLE      hclient  = NULL;
    HRESULT     hresult  = NOERROR;

    intrDebugOut((DEB_ITRACE,
                  "0 _IN CDefClient::Create(lpsrvr=%x,lpdocName=%ws)\n",
                  lhOLESERVER,WIDECHECK(lpdocName)));

    // REVIEW: server's termination has already started. Are
    // we going to see this condition in the synchronous mode.
    lpsrvr = (LPSRVR)lhOLESERVER;
    if (lpsrvr && lpsrvr->m_bTerminate)
    {
        Assert(0);
        return ReportResult(0, RPC_E_DDE_REVOKE, 0, 0);
    }

#ifdef FIREWALLS
    PROBE_READ(lpunkObj);
    PROBE_READ(lpmkObj);
    PROBE_WRITE(lplhobj);
#endif

    lpclient = new CDefClient (/*pUnkOuter==*/NULL);;

    Assert(lpclient->m_pUnkOuter);

    lpclient->m_aItem         = wGlobalAddAtom (/*lpszObjName*/lpdocName);
    lpclient->m_fRunningInSDI = fRunningInSDI;
    lpclient->m_psrvrParent   = lpsrvr;
    // A doc has itself as its containing document
    lpclient->m_pdoc          = lpclient;

    ErrRtnH (lpunkObj->QueryInterface (IID_IOleObject,
                                        (LPLPVOID) &lpclient->m_lpoleObj));

    ErrRtnH (lpunkObj->QueryInterface (IID_IDataObject,
                                        (LPLPVOID) &lpclient->m_lpdataObj));

    // Lock object; do after the QI so that ReleaseObjPtrs will unlock correctly
    lpclient->m_fLocked =
                (NOERROR==CoLockObjectExternal (lpunkObj, TRUE, /*dont care*/ FALSE));

    if (!(lpclient->m_hwnd = DdeCreateWindowEx(0, gOleDdeWindowClass,szDDEViewObj,
          WS_CHILD,0,0,0,0,lpsrvr->m_hwnd,NULL, g_hinst, NULL)))
    {
        intrDebugOut((DEB_ITRACE,"CDefClient::Create() couldn't create window\n"));
        goto errRtn;
    }

    // fix up the WindowProc entry point.
    SetWindowLongPtr(lpclient->m_hwnd, GWLP_WNDPROC, (LONG_PTR)DocWndProc);

    if (fDoAdvise)
    {
        // This is for Packager, in particular, and manual links.
        // If client does not advise on any data, we still need
        // to do an OLE advise so we can get OnClose notifications.
        ErrRtnH (lpclient->DoOle20Advise (OLE_CLOSED, (CLIPFORMAT)0));
    }

    intrDebugOut((DEB_ITRACE,"  Doc window %x created\n",lpclient->m_hwnd));

    // Set out parm (window)
    if (phwnd != NULL)
    {
        *phwnd = lpclient->m_hwnd;
    }

    if (fSetClientSite)
    {
        // Should not set the client site if the object has not been
        // initialized yet, by BindMoniker (i.e. PersistFile::Load)
        // or PersistStorage::Load
        if (lpclient->SetClientSite() != NOERROR)
        {
            goto errRtn;
        }
    }

    Putsi(lpclient->m_cRef);

    SetWindowLongPtr (lpclient->m_hwnd, 0, (LONG_PTR)lpclient);
    SetWindowLongPtr (lpclient->m_hwnd, WW_LE, WC_LE);
    SetWindowLongPtr (lpclient->m_hwnd,WW_HANDLE,
                   (GetWindowLongPtr (lpsrvr->m_hwnd, WW_HANDLE)));

    hresult = NOERROR;

exitRtn:

    intrDebugOut((DEB_ITRACE,
                  "0 _OUT CDefClient::Create(lpsrvr=%x,lpdocName=%ws) hr=%x\n",
                  lhOLESERVER,
                  WIDECHECK(lpdocName),
                  hresult));


    return(hresult);
errRtn:
    intrDebugOut((DEB_ITRACE,"CDefClient::Create() in error handling routine\n"));
    if (lpclient)
    {
        if (lpclient->m_hwnd)
            SSDestroyWindow (lpclient->m_hwnd);

        if (lpclient->m_aItem)
            GlobalDeleteAtom (lpclient->m_aItem);
        delete lpclient;
    }
    hresult = E_OUTOFMEMORY;
    goto exitRtn;
}



INTERNAL CDefClient::Revoke (BOOL fRelease)
{
    Puts ("DefClient::Revoke "); Puth(this); Puta(m_aItem); Putn();

    ChkC(this);


    ReleaseObjPtrs();

    // We are done with this CDefClient but someone may still have a reference
    // to an instance of one of our nested classes.  In particular, an advise
    // holder may be holding on to our sink, or an item may have a pointer
    // to us if we are its parent document.  So we cannot actually do a
    // "delete this".
    // The corresponding AddRef is in CDefClient::Create
    // or CDefClient::RegisterItem

    m_pUnkOuter->Release();

    Puts ("DefClient::Revoke done\r\n");
    return NOERROR;
}



INTERNAL CDefClient::ReleaseObjPtrs
    (void)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDefClient::ReleaseObjPtrs\n",
                  this));

    ULONG ulResult;

    if (m_lpoleObj && m_fLocked)
    {
        // Unlock object.  Set m_fLocked to FALSE first to prevent reentrant
        // problems (unlock causes close which causes this routine to be called)

                m_fLocked = FALSE;
                CoLockObjectExternal(m_lpoleObj, FALSE, TRUE);
    }
    if (m_lpoleObj)
    {
        if (m_fDidSetClientSite)
            m_lpoleObj->SetClientSite(NULL);
        DoOle20UnAdviseAll();
        Assert (m_lpoleObj);
        if (m_lpoleObj)
        {
            ulResult = m_lpoleObj->Release();
            m_lpoleObj = NULL;
        }
        intrDebugOut((DEB_ITRACE,
                      "%p _OUT ::ReleaseObjPtrs lpoleObj ulResult=%x\n",
                              this,ulResult));
    }
    if (m_lpdataObj)
    {
        // Must do it this way because the Release can cause recursion
        LPDATAOBJECT pdata = m_lpdataObj;
        m_lpdataObj = NULL;
        ulResult = pdata->Release();
        intrDebugOut((DEB_ITRACE,
                      "%p _OUT ::ReleaseObjPtrs pdata ulResult=%x\n",
                      this,ulResult));
    }

    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDefClient::ReleaseObjPtrs\n",
                  this));
    return NOERROR;
}
#if 000
//RevokeAllDocs : revokes all the doc objects attached to a given
//server.

INTERNAL_(HRESULT) CDDEServer::RevokeAllDocObjs ()
{

    HWND    hwnd;
    HWND    hwndnext;
    LPCLIENT    lpclient;
    Puts ("RevokeAllDocObjs\r\n");
    ChkS(this);

    hwnd = GetWindow (m_hwnd, GW_CHILD);

    // Go thru each of the child windows and revoke the corresponding
    // document. Doc windows are child windows for the server window.

    while (hwnd){
        // sequence is important
        hwndnext = GetWindow (hwnd, GW_HWNDNEXT);
        lpclient = ((LPCLIENT)GetWindowLongPtr (hwnd, 0));
        lpclient->Revoke();
        hwnd =  hwndnext;
    }
    return NOERROR;
}
#endif

// FindDoc: Given a doc obj, searches for the doc obj
// in the given class factory tree. returns true if the
// doc obj is available.


INTERNAL_(LPCLIENT)  CDDEServer::FindDocObj
(
LPSTR   lpdocname
)
{
    ATOM        aItem;
    HWND        hwnd;
    LPCLIENT    lpclient;

    ChkS(this);
    aItem = (ATOM)GlobalFindAtomA (lpdocname);
    Assert (IsWindowValid (m_hwnd));
    hwnd = GetWindow (m_hwnd, GW_CHILD);
    Assert (NULL==hwnd || IsWindowValid (hwnd));

    while (hwnd)
    {
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);
        if (lpclient->m_aItem == aItem)
        {
            intrDebugOut((DEB_ITRACE,
                          "FindDocObj found %s lpclient=%x\n",
                          lpdocname,
                          lpclient));
            return lpclient;
        }
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return NULL;
}

BOOL PostAckToClient(HWND hwndClient,HWND hwndServer,ATOM aItem,DWORD retval)
{
    BOOL fResult = TRUE;
    intrDebugOut((DEB_ITRACE,
                  "0 _IN PostAckToClient(hwndClient=%x,hwndServer=%x,aItem=%x(%ws)\n",
                  hwndClient,
                  hwndServer,
                  aItem,
                  wAtomName(aItem)));

    DWORD status = 0;
    SET_MSG_STATUS (retval, status);

    LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

    if (!PostMessageToClient (hwndClient,
                              WM_DDE_ACK,
                              (WPARAM)hwndServer,
                              lp))
    {
                DDEFREE(WM_DDE_ACK,lp);
                fResult = FALSE;
    }
    intrDebugOut((DEB_ITRACE,
                  "0 _OUT PostAckToClient returns %x\n",
                  fResult));

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   DocHandleIncomingCall
//
//  Synopsis:   Setup and call the CallControl to dispatch a call to the doc
//
//  Effects:    A call has been made from the client that requires us to call
//              into our server. This must be routed through the call control.
//              This routine sets up the appropriate data structures, and
//              calls into the CallControl. The CallControl will in turn
//              call DocDispatchIncomingCall to actually process the call.
//
//              This routine should only be called by the DocWndProc
//
//
//  Arguments:  [pDocData] -- Points to DOCDISPATCHDATA for this call
//                            This contains all required information for
//                            handling the message.
//
//  Requires:
//
//  Returns:    If an error is returned, it is assumed that the Dispatch
//              routine was not reached. DocDispatchIncomingCall() should
//              not be returning an error.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//  This is a co-routine with DocDispatchIncomingCall. See that routine
//  for more details
//
//----------------------------------------------------------------------------
INTERNAL DocHandleIncomingCall(PDOCDISPATCHDATA pDocData)
{
    HRESULT hresult = NOERROR;
    DISPATCHDATA dispatchdata;
    DWORD callcat;

    intrAssert(pDocData != NULL);

    intrDebugOut((DEB_ITRACE,
                  "0 _IN DocHandleIncomingCall lpclient=%x pDocData=%x\n",
                  pDocData->lpclient,
                  pDocData));

    //
    // TERMINATE messages must always be handled ASYNC, and cannot
    // be rejected.
    //
    if (pDocData->msg == WM_DDE_TERMINATE)
    {
        callcat = CALLCAT_ASYNC;
    }
    else
    {
        callcat = CALLCAT_SYNCHRONOUS;
    }

    dispatchdata.pData = (LPVOID) pDocData;
    pDocData->wDispFunc = DDE_DISP_DOCWNDPROC;

    RPCOLEMESSAGE        rpcMsg = {0};
    RPC_SERVER_INTERFACE RpcInterfaceInfo;
    DWORD                dwFault;

    rpcMsg.iMethod = 0;
    rpcMsg.Buffer = &dispatchdata;
    rpcMsg.cbBuffer = sizeof(dispatchdata);
    rpcMsg.reserved2[1] = &RpcInterfaceInfo;
    *MSG_TO_IIDPTR(&rpcMsg) = GUID_NULL;


    IRpcStubBuffer * pStub = &(pDocData->lpclient->m_pCallMgr);
    IInternalChannelBuffer * pChannel = &(pDocData->lpclient->m_pCallMgr);
    hresult = STAInvoke(&rpcMsg, callcat, pStub, pChannel, NULL, NULL, &dwFault);

    intrDebugOut((DEB_ITRACE,
                  "0 _OUT DocHandleIncomingCall hresult=%x\n",
                  hresult));

    return(hresult);
}

//+---------------------------------------------------------------------------
//
//  Function:   DocDispatchIncomingCall
//
//  Synopsis:   Dispatch a call into the client.
//
//  Effects:    This is a co-routine to DocHandleIncomingCall. This routine
//              is called to implement functions that call into the CDefClient
//              object. It is dispatched by the call control stuff, and helps
//              to insure the server is ready to accept these calls.
//
//              This routine is coded as a continuation of the DocWndProc.
//              There is a switch on the message. Each message does slightly
//              different things. The code to handle each message was snatched
//              from the original DocWndProc, before it was converted to the
//              new call control mechanism.
//
//
//  Arguments:  [pDocData] --   Points to Doc Dispatch Data, which are the
//                              parameters to DocWndProc which need processing
//
//  Requires:
//              pDocData cannot be NULL
//
//  Returns:
//              This routine will always return NOERROR. There are no useful
//              error returns to be made from here. If you decide to return
//              an error, check the DocHandleIncomingCall and DocWndProc to be
//              sure the error paths are correctly handled. Some of the
//              cases do additional error processing in the DocWndProc on
//              error.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL DocDispatchIncomingCall(PDOCDISPATCHDATA pDocData)
{
    LPCLIENT            lpclient = pDocData->lpclient;
    BOOL                fack;
    HANDLE              hdata =  pDocData->hdata;
    ATOM                aItem =  pDocData->aItem;
    WPARAM              wParam = pDocData->wParam;
    HWND                hwnd =   pDocData->hwnd;
    HRESULT             retval;



    intrDebugOut((DEB_ITRACE,
                  "0 _IN DocDispatchIncomingCall pDocData(%x)\n",
                  pDocData));

    intrAssert(pDocData);

    //
    // This switch statement is intended to continue the functionality found
    // in the DocWndProc. These routines are directly interrelated to the
    // same cases in DocWndProc, and need special care before changing.
    //
    switch (pDocData->msg)
    {
    case WM_DDE_TERMINATE:
        {
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_TERMINATE hwnd=%x \n",
                          pDocData->hwnd));

            //
            // Here is a fine hack for you. 32-bit applications appear to shut
            // down slightly differently than 16-bit applications. There is a
            // problem with Lotus Notes interacting with 32-bit OFFICE apps.
            // When notes has done an OleCreateFromFile, it starts the
            // 32-bit hidden, and does a normal DDE conversation. However,
            // on termination, the 32-bit Doc Window was going away during
            // this routine. Since the world is now multi-tasking, Lotus
            // Notes was seeing its server window die because we get
            // pre-empted during DeleteItemsFromList giving the 16-bit app a
            // chance to run. Since Lotus is in the
            // standard OleQueryReleaseStatus() loop, it will detect that the
            // server has shutdown BEFORE it gets the terminate message.
            // Go figure. So, insure that we post the reply DDE_TERMINATE
            // before destroying our window, or the 16-bit applications
            // won't like us.
            //
            PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE,
                            (WPARAM) hwnd, NULL);

            // Client initiated the termination. So, we should remove
            // his window from any of our doc or items' lists.
            lpclient->DeleteFromItemsList ((HWND)wParam
                                            /*, lpclient->m_fEmbed*/);

            ChkC (lpclient);


            // REVIEW: If the termination is sent from the client side,
            // lpoleObj will not be NULL.
            if (lpclient->m_cClients == 0 && lpclient->m_fEmbed)
            {
                Assert (lpclient->m_chk==chkDefClient);
                lpclient->ReleaseAllItems ();
                Assert (lpclient->m_chk==chkDefClient);
                Assert (NULL==lpclient->m_lpoleObj &&
                        NULL==lpclient->m_lpdataObj) ;

            }
            break;
        }

    case WM_DDE_EXECUTE:
        {

            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_EXECUTE hwnd=%x hdata=%x\n",
                          pDocData->hwnd,
                          pDocData->hdata));

            //
            // The following state variables appear to be used by
            // the execute code.
            //
            lpclient->m_ExecuteAck.f        = TRUE;  // assume we will need to
            lpclient->m_ExecuteAck.hdata    = hdata;
            lpclient->m_ExecuteAck.hwndFrom = (HWND)wParam;
            lpclient->m_ExecuteAck.hwndTo   = hwnd;

            //
            // In the event that the command is a StdClose, we need
            // to force the client to stay around for the duration of
            // the call.
            //
            lpclient->m_pUnkOuter->AddRef();

            retval = lpclient->DocExecute (hdata);

            if (lpclient->m_ExecuteAck.f)
            {
                lpclient->SendExecuteAck (retval);
            }

            lpclient->m_pUnkOuter->Release();
            break;

        }
    case WM_DDE_POKE:
        {
            int iStdItem;
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_POKE hwnd=%x aItem=%x(%ws) hdata=%x\n",
                          hwnd,
                          aItem,
                          wAtomName(aItem),
                          hdata));

            if (iStdItem = GetStdItemIndex (aItem))
            {
                retval = lpclient->PokeStdItems ((HWND)wParam,
                                                 aItem,
                                                 hdata,
                                                 iStdItem);
            }
            else
            {
                retval = lpclient->PokeData ((HWND)wParam,
                                             aItem,
                                             hdata);
                    // This is allowed to fail.  PowerPoint tries to poke
                    // data with cfFormat=="StdSave" and "StdFont"
            }

            if (!PostAckToClient((HWND)wParam,hwnd,aItem,retval))
            {
                goto errRtn;
            }
            break;
        }
    case WM_DDE_ADVISE:
        {
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_ADVISE hwnd=%x aItem=%x(%ws) hdata=%x\n",
                          hwnd,
                          aItem,
                          wAtomName(aItem),
                          hdata));

            if (IsAdviseStdItems (aItem))
            {
                retval = lpclient->AdviseStdItems ((HWND)wParam,
                                                   aItem,
                                                   hdata,
                                                   (BOOL FAR *)&fack);
            }
            else
            {
                retval = lpclient->AdviseData ((HWND)wParam,
                                               aItem,
                                               hdata,
                                               (BOOL FAR *)&fack);
            }

            if (fack)
            {
                if (!PostAckToClient(