lldownStructure);

    PAGED_CODE();

    ASSERT( pSrvCall );
    ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

    // Dispatch the request to a system thread.
    Status = RxDispatchToWorkerThread(
                 MRxSmbDeviceObject,
                 DelayedWorkQueue,
                 SmbCeCreateSrvCall,
                 pCallbackContext);

    if (Status == STATUS_SUCCESS) {
        // Map the return value since the wrapper expects PENDING.
        Status = STATUS_PENDING;
    } else {
        // There was an error in dispatching the SmbCeCreateSrvCall method to
        // a worker thread. Complete the request and return STATUS_PENDING.

        SCCBC->Status = Status;
        SrvCalldownStructure->CallBack(SCCBC);
        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
MRxSmbFinalizeSrvCall(
    PMRX_SRV_CALL pSrvCall,
    BOOLEAN       Force)
/*++

Routine Description:

   This routine destroys a given server call instance

Arguments:

    pSrvCall  - the server call instance to be disconnected.

    Force     - TRUE if a disconnection is to be enforced immediately.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS              Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    // if the server entry is not filled in, then there's nothing to do. this occurs
    // on a srvcall that we never successfuly hooked up to........
    if (pSrvCall->Context == NULL) {
        return(Status);
    }


    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    if (pServerEntry != NULL) {
        InterlockedCompareExchangePointer(
            &pServerEntry->pRdbssSrvCall,
            NULL,
            pSrvCall);
        SmbCeDereferenceServerEntry(pServerEntry);
    }

    pSrvCall->Context = NULL;

    return Status;
}

NTSTATUS
MRxSmbSrvCallWinnerNotify(
    IN PMRX_SRV_CALL  pSrvCall,
    IN BOOLEAN        ThisMinirdrIsTheWinner,
    IN OUT PVOID      pSrvCallContext)
/*++

Routine Description:

   This routine finalizes the mini rdr context associated with an RDBSS Server call instance

Arguments:

    pSrvCall               - the Server Call

    ThisMinirdrIsTheWinner - TRUE if this mini rdr is the choosen one.

    pSrvCallContext  - the server call context created by the mini redirector.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The two phase construction protocol for Server calls is required because of parallel
    initiation of a number of mini redirectors. The RDBSS finalizes the particular mini
    redirector to be used in communicating with a given server based on quality of
    service criterion.

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pSrvCallContext;

    if (!ThisMinirdrIsTheWinner) {

        //
        // Some other mini rdr has been choosen to connect to the server. Destroy
        // the data structures created for this mini redirector.
        //
        SmbCeUpdateServerEntryState(pServerEntry,SMBCEDB_MARKED_FOR_DELETION);
        SmbCeDereferenceServerEntry(pServerEntry);
        return STATUS_SUCCESS;
    }

    pSrvCall->Context  = pServerEntry;

    pSrvCall->Flags   |= SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS |
                         SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES;

    pSrvCall->MaximumNumberOfCloseDelayedFiles = MRxSmbConfiguration.DormantFileLimit + 1;

    return STATUS_SUCCESS;
}

extern GUID CachedServerGuid;

NTSTATUS
MRxSmbCheckForLoopBack(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

   This routine checks for loop back case and set the flag accordingly

Arguments:

    pServerEntry - the Server Entry

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    pServerEntry->Server.IsLoopBack = FALSE;

    //
    // Check for loopback.  NT5 servers support extended security, and return a
    //  GUID in the negotiate response. We also know that the NT5 server stores
    //  its GUID in the registry.  So we compare the registry value on this machine
    //  to the GUID value returned from the server to which we just connected.  If
    //  they match, then we are looping back to ourselves!
    //
    // The Server registry entry is now cached to prevent deadlock.
    //
    if( BooleanFlagOn( pServerEntry->Server.DialectFlags, DF_EXTENDED_SECURITY ) ) {

	if( RtlCompareMemory( &CachedServerGuid,
			      &pServerEntry->Server.NtServer.ServerGuid,
			      sizeof( GUID ) ) == sizeof( GUID ) ) {

	    //
	    // The GUID in the registry (cached) matches the GUID we got back from the
	    //  server!  We must be looping back to ourselves!
	    //
	    pServerEntry->Server.IsLoopBack = TRUE;
	}

    }

    return STATUS_SUCCESS;
}

//
// The following type defines and data structures are used for parsing negotiate SMB
// responses.
//

#include "protocol.h"

//superceded in smbxchng.h
//#define MRXSMB_PROCESS_ID 0xCAFE

typedef enum _SMB_NEGOTIATE_TYPE_ {
    SMB_CORE_NEGOTIATE,
    SMB_EXTENDED_NEGOTIATE,
    SMB_NT_NEGOTIATE
} SMB_NEGOTIATE_TYPE, *PSMB_NEGOTIATE_TYPE;

typedef struct _SMB_DIALECTS_ {
    SMB_NEGOTIATE_TYPE   NegotiateType;
    USHORT               DispatchVectorIndex;
} SMB_DIALECTS, *PSMB_DIALECTS;

SMBCE_SERVER_DISPATCH_VECTOR
s_SmbServerDispatchVectors[] = {
    {BuildSessionSetupSmb,CoreBuildTreeConnectSmb},
    {BuildSessionSetupSmb,LmBuildTreeConnectSmb},
    {BuildSessionSetupSmb,NtBuildTreeConnectSmb},
    {BuildSessionSetupSmb,NtBuildTreeConnectSmb}
    };

//CODE.IMPROVEMENT since, in fact, we may never implement XENIXCORE and MSNET13
// we should hack them out. however, there is an enum in smbce.h that must be kept
// sync with these arrays.

SMB_DIALECTS
s_SmbDialects[] = {
    { SMB_CORE_NEGOTIATE, 0},
    //{ SMB_CORE_NEGOTIATE, 0 },
    //{ SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_NT_NEGOTIATE, 2 },
    { SMB_NT_NEGOTIATE, 3}
};

CHAR s_DialectNames[] = {
    "\2"  PCNET1 "\0"
    //\2notyet"  XENIXCORE "\0"
    //\2notyet"  MSNET103 "\0"
    "\2"  LANMAN10 "\0"
    "\2"  WFW10 "\0"
    "\2"  LANMAN12 "\0"
    "\2"  LANMAN21
    "\0\2"  NTLANMAN
    };

#define __second(a,b) (b)
ULONG
MRxSmbDialectFlags[] = {
    __second( PCNET1,    DF_CORE ),

    //__second( XENIXCORE, DF_CORE | DF_MIXEDCASEPW | DF_MIXEDCASE ),

    //__second( MSNET103,  DF_CORE | DF_OLDRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT ),

    __second( LANMAN10,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 ),

    __second( WFW10,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 | DF_WFW),

    __second( LANMAN12,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 | DF_LANMAN20 |
                    DF_MIXEDCASE | DF_LONGNAME | DF_SUPPORTEA ),

    __second( LANMAN21,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 | DF_LANMAN20 |
                    DF_MIXEDCASE | DF_LONGNAME | DF_SUPPORTEA |
                    DF_LANMAN21),

    __second( NTLANMAN,  DF_CORE | DF_NEWRAWIO |
                    DF_NTPROTOCOL | DF_NTNEGOTIATE |
                    DF_MIXEDCASEPW | DF_LANMAN10 | DF_LANMAN20 |
                    DF_LANMAN21 | DF_MIXEDCASE | DF_LONGNAME |
                    DF_SUPPORTEA | DF_TIME_IS_UTC )
};

ULONG s_NumberOfDialects = sizeof(s_SmbDialects) / sizeof(s_SmbDialects[0]);

PBYTE s_pNegotiateSmb =  NULL;
PBYTE s_pNegotiateSmbRemoteBoot =  NULL;
ULONG s_NegotiateSmbLength = 0;

PBYTE s_pEchoSmb  = NULL;
BYTE  s_EchoData[] = "JlJmIhClBsr";

#define SMB_ECHO_COUNT (1)

// Number of ticks 100ns ticks in a day.
LARGE_INTEGER s_MaxTimeZoneBias;

extern NTSTATUS
GetNTSecurityParameters(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange,
    PSMBCE_SERVER       pServer,
    PUNICODE_STRING     pDomainName,
    PRESP_NT_NEGOTIATE  pNtNegotiateResponse,
    ULONG               BytesIndicated,
    ULONG               BytesAvailable,
    PULONG              pBytesTaken,
    PMDL                *pDataBufferPointer,
    PULONG              pDataSize);

extern NTSTATUS
GetLanmanSecurityParameters(
    PSMBCE_SERVER    pServer,
    PRESP_NEGOTIATE  pNegotiateResponse);

extern VOID
GetLanmanTimeBias(
    PSMBCE_SERVER   pServer,
    PRESP_NEGOTIATE pNegotiateResponse);

// Number of 100 ns ticks in one minute
#define ONE_MINUTE_IN_TIME (60 * 1000 * 10000)

NTSTATUS
MRxSmbInitializeEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext)
/*++

Routine Description:

    This routine builds the echo SMB

Return Value:

    STATUS_SUCCESS if construction of an ECHO smb was successful

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       DialectIndex;

    PSMB_HEADER    pSmbHeader = NULL;
    PREQ_ECHO      pReqEcho   = NULL;

    PAGED_CODE();

    pEchoProbeContext->EchoSmbLength = sizeof(SMB_HEADER) +
                                     FIELD_OFFSET(REQ_ECHO,Buffer) +
                                     sizeof(s_EchoData);

    pEchoProbeContext->pEchoSmb = (PBYTE)RxAllocatePoolWithTag(
                                           NonPagedPool,
                                           pEchoProbeContext->EchoSmbLength,
                                           MRXSMB_ECHO_POOLTAG);

    if (pEchoProbeContext->pEchoSmb != NULL) {
        pSmbHeader = (PSMB_HEADER)pEchoProbeContext->pEchoSmb;
        pReqEcho   = (PREQ_ECHO)((PBYTE)pEchoProbeContext->pEchoSmb + sizeof(SMB_HEADER));

        // Fill in the header
        RtlZeroMemory( pSmbHeader, sizeof( SMB_HEADER ) );

        *(PULONG)(&pSmbHeader->Protocol) = (ULONG)SMB_HEADER_PROTOCOL;

        // By default, paths in SMBs are marked as case insensitive and
        // canonicalized.
        pSmbHeader->Flags =
            SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS;

        // Get the flags2 field out of the SmbContext
        SmbPutAlignedUshort(
            &pSmbHeader->Flags2,
            (SMB_FLAGS2_KNOWS_LONG_NAMES |
             SMB_FLAGS2_KNOWS_EAS        |
             SMB_FLAGS2_IS_LONG_NAME     |
             SMB_FLAGS2_NT_STATUS        |
             SMB_FLAGS2_UNICODE));

        // Fill in the process id.
        SmbPutUshort(&pSmbHeader->Pid, MRXSMB_PROCESS_ID );
        SmbPutUshort(&pSmbHeader->Tid,0xffff); // Invalid TID

        // Lastly, fill in the smb command code.
        pSmbHeader->Command = (UCHAR) SMB_COM_ECHO;

        pReqEcho->WordCount = 1;

        RtlMoveMemory( pReqEcho->Buffer, s_EchoData, sizeof( s_EchoData ) );

        SmbPutUshort(&pReqEcho->EchoCount, SMB_ECHO_COUNT);
        SmbPutUshort(&pReqEcho->ByteCount, (USHORT) sizeof( s_EchoData ) );
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

VOID
MRxSmbTearDownEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext)
/*++

Routine Description:

    This routine tears down the echo processing context

--*/
{
    PAGED_CODE();

    if (pEchoProbeContext->pEchoSmb != NULL) {
        RxFreePool(pEchoProbeContext->pEchoSmb);
        pEchoProbeContext->pEchoSmb = NULL;
    }
}

ULONG MRxSmbNegotiateMask = 6;  //controls which protocols are not negotiated

//#define MRXSMB_ALLOW_NEGOTIATE_MASKING
#ifdef MRXSMB_ALLOW_NEGOTIATE_MASKING
ULONG MRxSmbCapturedNegotiateMask = 0;  //indicates which protocols are currently defeated
CHAR MRxSmbDefeatString[] = "xyz";

VOID
MRxSmbMaskNegotiateSmb ()
/*++

Routine Description:

    This routine masks the negotiate buffer to reduce the number of dialects that are
    negotiated.

Arguments:

   none

Return Value:

    NA

--*/
{
    PREQ_NEGOTIATE pReqNegotiate;
    PUCHAR p,pshadow,q;
    ULONG i,numberofdialects,negotiatemask;

    PAGED_CODE();

    if ((MRxSmbNegotiateMask == MRxSmbCapturedNegotiateMask)
            || (s_pNegotiateSmb == NULL) ){
        return;
    }

    pReqNegotiate = (PREQ_NEGOTIATE)(s_pNegotiateSmb + sizeof(SMB_HEADER));

    p = pReqNegotiate->Buffer;
    pshadow = s_DialectNames;
    negotiatemask = MRxSmbNegotiateMask;
    numberofdialects = sizeof(MRxSmbDialectFlags)/sizeof(MRxSmbDialectFlags[0]);

    DbgPrint("Build Negotiate mask=%x\n",negotiatemask);

    for (i=0;;) {

        ASSERT(*p == '\2');
        ASSERT(*pshadow == '\2');
        p++; pshadow++;
        DbgPrint("Considering Protocol %s\n",pshadow);
        if (negotiatemask&1) {
            DbgPrint("Protocol to fffff %s\n",pshadow);
        }

        //for each protocol, either copy in characters from the defeat string
        //or from the original source depending on the mask. here, pshadow points
        //to the original, q points to the defeat string and p points to the actual
        //bits in the SMB_COM_NEGOTIATE

        for (q=MRxSmbDefeatString;;) {
            if (*p=='\2') break;
            if (*q==0) break;
            if (negotiatemask&1) {
                *p = *q;
            } else {
                *p = *pshadow;
            }
            p++; q++; pshadow++;
        }

        i++;
        if (i>=numberofdialects) break;

        negotiatemask>>=1;
        //if(negotiate_mask==0)break;

        DbgPrint("moving up to i=%d\n",i);
        for (;*p!='\2';) {
            p++; pshadow++;
        }

    }

    MRxSmbCapturedNegotiateMask = MRxSmbNegotiateMask;

}
#else
#define MRxSmbMaskNegotiateSmb()
#endif

NTSTATUS
BuildNegotiateSmb(
    PVOID    *pSmbBufferPointer,
    PULONG   pSmbBufferLength,
    BOOLEAN  RemoteBootSession)
/*++

Routine Description:

    This routine builds the negotiate SMB

Arguments:

    pSmbBufferPointer    - a placeholder for the smb buffer

    pNegotiateSmbLength  - the smb buffer size

    RemoteBootServer     - is this for connection to a remote boot server

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       DialectIndex;
    PSMB_HEADER    pSmbHeader    = NULL;
    PREQ_NEGOTIATE pReqNegotiate = NULL;

    PAGED_CODE();

    if (s_pNegotiateSmb == NULL) {
        s_NegotiateSmbLength = sizeof(SMB_HEADER) +
                               FIELD_OFFSET(REQ_NEGOTIATE,Buffer) +
                               sizeof(s_DialectNames);

        s_pNegotiateSmb = (PBYTE)RxAllocatePoolWithTag(
                                     PagedPool,
                                     s_NegotiateSmbLength + TRANSPORT_HEADER_SIZE,
                                     MRXSMB_ADMIN_POOLTAG);

        if (s_pNegotiateSmb != NULL) {

            s_pNegotiateSmb += TRANSPORT_HEADER_SIZE;

            pSmbHeader = (PSMB_HEADER)s_pNegotiateSmb;
            pReqNegotiate = (PREQ_NEGOTIATE)(s_pNegotiateSmb + sizeof(SMB_HEADER));

            // Fill in the header
            RtlZeroMemory( pSmbHeader, sizeof( SMB_HEADER ) );

            *(PULONG)(&pSmbHeader->Protocol) = (ULONG)SMB_HEADER_PROTOCOL;

            // By default, paths in SMBs are marked as case insensitive and
            // canonicalized.
            pSmbHeader->Flags =
                SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS;

            // Put our flags2 field. The Ox10 is a temporary flag for SLM
            // corruption detection
            SmbPutAlignedUshort(
                &pSmbHeader->Flags2,
                (SMB_FLAGS2_KNOWS_LONG_NAMES
                     | SMB_FLAGS2_KNOWS_EAS
                     | SMB_FLAGS2_IS_LONG_NAME
                     | SMB_FLAGS2_NT_STATUS
                     | SMB_FLAGS2_UNICODE
                     | SMB_FLAGS2_EXTENDED_SECURITY
                     | 0x10
                 ));

            // Fill in the process id.
            SmbPutUshort( &pSmbHeader->Pid, MRXSMB_PROCESS_ID );

            // Lastly, fill in the smb command code.
            pSmbHeader->Command = (UCHAR) SMB_COM_NEGOTIATE;

            pReqNegotiate->WordCount = 0;

            RtlMoveMemory(
                pReqNegotiate->Buffer,
                s_DialectNames,
                sizeof( s_DialectNames ) );

            SmbPutUshort(
                &pReqNegotiate->ByteCount,
                (USHORT) sizeof( s_DialectNames ) );

            // Initialize the maximum time zone bias used in negotiate response parsing.
            s_MaxTimeZoneBias.QuadPart = Int32x32To64(24*60*60,1000*10000);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (MRxSmbBootedRemotely && s_pNegotiateSmbRemoteBoot == NULL) {
        s_pNegotiateSmbRemoteBoot = (PBYTE)RxAllocatePoolWithTag(
                                             PagedPool,
                                             s_NegotiateSmbLength + TRANSPORT_HEADER_SIZE,
                                             MRXSMB_ADMIN_POOLTAG);

        if (s_pNegotiateSmbRemoteBoot != NULL) {
            USHORT RemoteBootFlags2;

            //
            // Now that s_pNegotiateSmb has been filled in, copy it to
            // s_pNegotiateSmbRemoteBoot and modify as needed. We don't
            // worry about masking s_pNegotiateSmbRemoteBoot.
            //

            s_pNegotiateSmbRemoteBoot += TRANSPORT_HEADER_SIZE;
            RtlCopyMemory(s_pNegotiateSmbRemoteBoot,
                          s_pNegotiateSmb,
                          s_NegotiateSmbLength);

            pSmbHeader = (PSMB_HEADER)s_pNegotiateSmbRemoteBoot;

            //
            // Turn off the SMB_FLAGS2_EXTENDED_SECURITY bit.
            //

            RemoteBootFlags2 = SmbGetAlignedUshort(&pSmbHeader->Flags2);
            RemoteBootFlags2 &= ~SMB_FLAGS2_EXTENDED_SECURITY;
            SmbPutAlignedUshort(&pSmbHeader->Flags2,
                                RemoteBootFlags2);
        } else {
            RxFreePool(s_pNegotiateSmb - TRANSPORT_HEADER_SIZE);
                Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(Status)) {
        *pSmbBufferLength  = s_NegotiateSmbLength;
        if (RemoteBootSession) {
            *pSmbBufferPointer = s_pNegotiateSmbRemoteBoot;
        } else {
            *pSmbBufferPointer = s_pNegotiateSmb;
        }
    }

    MRxSmbMaskNegotiateSmb();

    return Status;
}


ULONG MRxSmbSrvWriteBufSize = 0xffff; //use the negotiated size

NTSTATUS
ParseNegotiateResponse(
    IN OUT PSMB_ADMIN_EXCHANGE pSmbAdminExchange,
    IN     ULONG               BytesIndicated,
    IN     ULONG               BytesAvailable,
       OUT PULONG              pBytesTaken,
    IN     PSMB_HEADER         pSmbHeader,
       OUT PMDL                *pDataBufferPointer,
       OUT PULONG              pDataSize)
/*++

Routine Description:

    This routine parses the response from the server

Arguments:

    pServer            - the server instance

    pDomainName        - the domain name string to be extracted from the response

    pSmbHeader         - the response SMB

    BytesAvailable     - length of the response

    pBytesTaken        - response consumed

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    The SMB servers can speak a variety of dialects of the SMB protocol. The initial
    negotiate response can come in one of three possible flavours. Either we get the
    NT negotiate response SMB from a NT server or the extended response from DOS and
    OS/2 servers or the CORE response from other servers.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY pServerEntry;
    PSMBCE_SERVER         pServer;
    PUNICODE_STRING       pDomainName;

    USHORT          DialectIndex;
    PRESP_NEGOTIATE pNegotiateResponse;
    ULONG           NegotiateSmbLength;

    ASSERT( pSmbHeader != NULL );

    pServerEntry = SmbCeGetExchangeServerEntry(pSmbAdminExchange);
    pServer = &pServerEntry->Server;

    pDomainName = &pSmbAdminExchange->Negotiate.DomainName;

    pNegotiateResponse = (PRESP_NEGOTIATE) (pSmbHeader + 1);
    NegotiateSmbLength = sizeof(SMB_HEADER);
    *pBytesTaken       = NegotiateSmbLength;

    // Assume that the indicated response is sufficient. The only cases in which this
    // will not be TRUE is for the EXTENDED NEGOITIATE in which the security blob
    // is passed back. In all other cases the TDI imposed minimum of 128 bytes
    // subsumes the negotiate response.

    *pDataBufferPointer = NULL;
    *pDataSize          = 0;

    DialectIndex = SmbGetUshort( &pNegotiateResponse->DialectIndex );
    if (DialectIndex == (USHORT) -1) {
        // means server cannot accept any requests from
        *pBytesTaken = BytesAvailable;
        pServerEntry->ServerStatus = STATUS_REQUEST_NOT_ACCEPTED;

        return Status;
    }

    if (pNegotiateResponse->WordCount < 1 || DialectIndex > s_NumberOfDialects) {
        *pBytesTaken = BytesAvailable;
        pServerEntry->ServerStatus = STATUS_INVALID_NETWORK_RESPONSE;
        return Status;
    }

    // set the domain name length to zero ( default initialization )
    pDomainName->Length = 0;

    // Fix up the dialect type and the corresponding dispatch vector.
    pServer->Dialect        = (SMB_DIALECT)DialectIndex;
    pServer->DialectFlags   = MRxSmbDialectFlags[DialectIndex];
    pServer->pDispatch      = &s_SmbServerDispatchVectors[s_SmbDialects[DialectIndex].DispatchVectorIndex];

    // Parse the response based upon the type of negotiate response expected.

    switch (s_SmbDialects[DialectIndex].NegotiateType) {
    case SMB_NT_NEGOTIATE:
        {
            ULONG              NegotiateResponseLength;
            LARGE_INTEGER      ZeroTime;
            LARGE_INTEGER      LocalTimeBias;
            LARGE_INTEGER      ServerTimeBias;
            PRESP_NT_NEGOTIATE pNtNegotiateResponse = (PRESP_NT_NEGOTIATE) pNegotiateResponse;

            ASSERT(BytesAvailable > sizeof(RESP_NT_NEGOTIATE));

            if (pNtNegotiateResponse->WordCount != 17) {
                *pBytesTaken = BytesAvailable;
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            } else {
                // parse and map the capabilities.
                ULONG NtCapabilities;

                NegotiateResponseLength = FIELD_OFFSET(RESP_NT_NEGOTIATE,Buffer) +
                                          SmbGetUshort(&pNtNegotiateResponse->ByteCount);
                NegotiateSmbLength += NegotiateResponseLength;

                //Start with a clean slate
                pServer->Capabilities = 0;

                // Initialize server based constants
                pServer->MaximumRequests   = SmbGetUshort( &pNtNegotiateResponse->MaxMpxCount );
                pServer->MaximumVCs        = SmbGetUshort( &pNtNegotiateResponse->MaxNumberVcs );
                pServer->MaximumBufferSize = SmbGetUlong( &pNtNegotiateResponse->MaxBufferSize );

                NtCapabilities = pServer->NtServer.NtCapabilities = SmbGetUlong(&pNtNegotiateResponse->Capabilities);
                if (NtCapabilities & CAP_RAW_MODE) {
                    pServer->Capabilities |= (RAW_READ_CAPABILITY | RAW_WRITE_CAPABILITY);
                }

                if ((NtCapabilities & CAP_COMPRESSED_DATA) &&
                    MRxSmbEnableCompression) {
                    pServer->Capabilities |= COMPRESSED_DATA_CAPABILITY;
                }

                if (NtCapabilities & CAP_DFS) {
                    pServer->Capabilities |= CAP_DFS;
                }

                //copy other nt capabilities into the dialog flags

                if (NtCapabilities & CAP_UNICODE) {
                    pServer->DialectFlags |= DF_UNICODE;
                }

                if (NtCapabilities & CAP_LARGE_FILES) {
                    pServer->DialectFlags |= DF_LARGE_FILES;
                }

                if (NtCapabilities & CAP_NT_SMBS) {
                    pServer->DialectFlags |= DF_NT_SMBS | DF_NT_FIND;
                }

                if (NtCapabilities & CAP_NT_FIND) {
                    pServer->DialectFlags |= DF_NT_FIND;
                }

                if (NtCapabilities & CAP_RPC_REMOTE_APIS) {
                    pServer->DialectFlags |= DF_RPC_REMOTE;
                }

                if (NtCapabilities & CAP_NT_STATUS) {
                    pServer->DialectFlags |= DF_NT_STATUS;
                }

                if (NtCapabilities & CAP_LEVEL_II_OPLOCKS) {
                    pServer->DialectFlags |= DF_OPLOCK_LVL2;
                }

                if (NtCapabilities & CAP_LOCK_AND_READ) {
                    pServer->DialectFlags |= DF_LOCKREAD;
                }

                if (NtCapabilities & CAP_EXTENDED_SECURITY) {
                    pServer->DialectFlags |= DF_EXTENDED_SECURITY;
                }

                if (NtCapabilities & CAP_INFOLEVEL_PASSTHRU) {
                    pServer->DialectFlags |= DF_NT_INFO_PASSTHROUGH;
                }

                // For non disk files the LARGE_READX capability is not useful.
                pServer->MaximumNonDiskFileReadBufferSize =
                    pServer->MaximumBufferSize -
                    QuadAlign(
                        sizeof(SMB_HEADER) +
                        FIELD_OFFSET(
                            REQ_NT_READ_ANDX,
                            Buffer[0]));

                if (NtCapabilities & CAP_LARGE_READX) {
                    if (NtCapabilities & CAP_LARGE_WRITEX) {
                        pServer->MaximumDiskFileReadBufferSize = 60*1024;
                    } else {
                        // The maximum size for reads to servers which support
                        // large read and x is constrained by the USHORT to record
                        // lengths in the SMB. Thus the maximum length that can be used
                        // is (65536 - 1) . This length should accomodate the header as
                        // well as the rest of the SMB. Actually, tho, we cut back to 60K.
                        pServer->MaximumDiskFileReadBufferSize = 60*1024;
                    }
                } else {
                    pServer->MaximumDiskFileReadBufferSize = pServer->MaximumNonDiskFileReadBufferSize;
                }

                // Specifying a zero local time will give you the time zone bias
                ZeroTime.HighPart = ZeroTime.LowPart = 0;
                ExLocalTimeToSystemTime( &ZeroTime, &LocalTimeBias );

                ServerTimeBias = RtlEnlargedIntegerMultiply(
                                    (LONG)SmbGetUshort(
                                        &pNtNegotiateResponse->ServerTimeZone),
                                    ONE_MINUTE_IN_TIME );

                pServer->TimeZoneBias.QuadPart = ServerTimeBias.QuadPart -
                                                 LocalTimeBias.QuadPart;

                if (!FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
                    //sigh...........
                    pServer->DialectFlags &= ~(DF_MIXEDCASEPW);
                    pServer->DialectFlags |= DF_W95;
                }

                Status = GetNTSecurityParameters(
                             pSmbAdminExchange,
                             pServer,
                             pDomainName,
                             pNtNegotiateResponse,
                             BytesIndicated,
                             BytesAvailable,
                             pBytesTaken,
                             pDataBufferPointer,
                             pDataSize);

                pServer->MaximumNonDiskFileWriteBufferSize =
                    min(
                        MRxSmbSrvWriteBufSize,
                        pServer->MaximumBufferSize -
                        QuadAlign(
                            sizeof(SMB_HEADER) +
                            FIELD_OFFSET(
                                REQ_NT_WRITE_ANDX,
                                Buffer[0])));
                
                if (NtCapabilities & CAP_LARGE_WRITEX &&
                    !(MRxSmbSecuritySignaturesEnabled && pServer->SecuritySignaturesEnabled)) {
                    pServer->DialectFlags |= DF_LARGE_WRITEX;
                    pServer->MaximumDiskFileWriteBufferSize = 0x10000;
                } else {
                    pServer->MaximumDiskFileWriteBufferSize =
                        pServer->MaximumNonDiskFileWriteBufferSize;
                }
            }
        }
        break;

    case SMB_EXTENDED_NEGOTIATE :
        {
            // An SMB_EXTENDED_NEGOTIATE response is never partially indicated. The response
            // length is ithin the TDI minimum for indication.

            USHORT RawMode;

            // DOS or OS2 server
            if (pNegotiateResponse->WordCount != 13 &&
                pNegotiateResponse->WordCount != 10 &&  // some downlevel server returns invalid WordCount
                pNegotiateResponse->WordCount != 8) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            } else {
                NegotiateSmbLength += FIELD_OFFSET(RESP_NEGOTIATE,Buffer) +
                                      SmbGetUshort(&pNegotiateResponse->ByteCount);

                ASSERT(
                    (BytesIndicated >= NegotiateSmbLength) &&
                    (BytesIndicated == BytesAvailable));

                RawMode = SmbGetUshort( &pNegotiateResponse->RawMode );
                pServer->Capabilities |= ((RawMode & 0x1) != 0
                                          ? RAW_READ_CAPABILITY : 0);
                pServer->Capabilities |= ((RawMode & 0x2) != 0
                                          ? RAW_WRITE_CAPABILITY : 0);

                if (pSmbHeader->Flags & SMB_FLAGS_LOCK_AND_READ_OK) {
                    pServer->DialectFlags |= DF_LOCKREAD;
                }

                pServer->EncryptPasswords = FALSE;
                pServer->MaximumVCs       = 1;

                pServer->MaximumBufferSize     = SmbGetUshort( &pNegotiateResponse->MaxBufferSize );
                pServer->MaximumDiskFileReadBufferSize =
                    pServer->MaximumBufferSize -
                    QuadAlign(
                        sizeof(SMB_HEADER) +
                        FIELD_OFFSET(
                            RESP_READ_ANDX,
                            Buffer[0]));

                pServer->MaximumNonDiskFileReadBufferSize  = pServer->MaximumDiskFileReadBufferSize;
                pServer->MaximumDiskFileWriteBufferSize    = pServer->MaximumDiskFileReadBufferSize;
                pServer->MaximumNonDiskFileWriteBufferSize = pServer->MaximumDiskFileReadBufferSize;

                pServer->MaximumRequests  = SmbGetUshort(
                                                &pNegotiateResponse->MaxMpxCount );
                pServer->MaximumVCs       = SmbGetUshort(
                                                &pNegotiateResponse->MaxNumberVcs );

                if (pNegotiateResponse->WordCount == 13) {
                    //CODE.IMPROVEMENT use the DF_bit for this
                    switch (pServer->Dialect) {
                    case LANMAN10_DIALECT:
                    case WFW10_DIALECT:
                    case LANMAN12_DIALECT:
                    case LANMAN21_DIALECT:
                        GetLanmanTimeBias( pServer,pNegotiateResponse );
                        break;
                    }

                    Status = GetLanmanSecurityParameters( pServer,pNegotiateResponse );
                }
            }

            *pBytesTaken = BytesAvailable;
        }
        break;

    case SMB_CORE_NEGOTIATE :
    default :
        {
            // An SMB_CORE_NEGOTIATE response is never partially indicated. The response
            // length is ithin the TDI minimum for indication.

            pServer->SecurityMode = SECURITY_MODE_SHARE_LEVEL;
            pServer->EncryptPasswords = FALSE;
            pServer->MaximumBufferSize = 0;
            pServer->MaximumRequests = 1;
            pServer->MaximumVCs = 1;
            pServer->SessionKey = 0;

            if (pSmbHeader->Flags & SMB_FLAGS_OPLOCK) {
                pServer->DialectFlags |= DF_OPLOCK;
            }
            
            *pBytesTaken = BytesAvailable;
            ASSERT(BytesIndicated == BytesAvailable);
        }
    }

    if (pServer->MaximumRequests == 0) {
        //
        // If this is a Lanman 1.0 or better server, this is a invalid negotiate
        // response. For others it would have been set to 1.
        //
        Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    if ((Status == STATUS_SUCCESS) ||
        (Status == STATUS_MORE_PROCESSING_REQUIRED)) {
        // Note that this code relies on the minimum incication size covering
        // the negotiate response header.
        //  Check to make sure that the time zone bias isn't more than +-24
        //  hours.
        //
#ifndef WIN9X
        if ((pServer->TimeZoneBias.QuadPart > s_MaxTimeZoneBias.QuadPart) ||
            (-pServer->TimeZoneBias.QuadPart > s_MaxTimeZoneBias.QuadPart)) {
#else
        if ((pServer->TimeZoneBias.HighPart > s_MaxTimeZoneBias.HighPart) ||
            (-pServer->TimeZoneBias.HighPart > s_MaxTimeZoneBias.HighPart)) {
#endif

            //  Set the bias to 0 - assume local time zone.
            pServer->TimeZoneBias.LowPart = pServer->TimeZoneBias.HighPart = 0;
        }

        //  Do not allow negotiated buffersize to exceed the size of a USHORT.
        //  Remove 4096 bytes to avoid overrun and make it easier to handle
        //  than 0xffff

        pServer->MaximumBufferSize =
            (pServer->MaximumBufferSize < 0x00010000) ? pServer->MaximumBufferSize :
                                             0x00010000 - 4096;
    } else {
        pServerEntry->ServerStatus = Status;
        *pBytesTaken = BytesAvailable;
        Status = STATUS_SUCCESS;
    }

    if ((pServer->DialectFlags & DF_NTNEGOTIATE)!=0) {

        InterlockedIncrement(&MRxSmbStatistics.LanmanNtConnects);

    } else if ((pServer->DialectFlags & DF_LANMAN21)!=0) {

        InterlockedIncrement(&MRxSmbStatistics.Lanman21Connects);

    } else if ((pServer->DialectFlags & DF_LANMAN20)!=0) {

        InterlockedIncrement(&MRxSmbStatistics.Lanman20Connects);

    } else {

        InterlockedIncrement(&MRxSmbStatistics.CoreConnects);

    }

    if (pServer->MaximumRequests > (USHORT)MRxSmbConfiguration.MaximumNumberOfCommands) {
        pServer->MaximumRequests = (USHORT)MRxSmbConfiguration.MaximumNumberOfCommands; 
    }

    if (MRxSmbSecuritySignaturesRequired &&
        !pServer->SecuritySignaturesEnabled &&
        pServerEntry->ServerStatus == STATUS_SUCCESS ) {
        // the client refuses to connect to a server that doesn't support security
        // signature which is required by the client.
        pServerEntry->ServerStatus = STATUS_LOGIN_WKSTA_RESTRICTION;
    }

    return Status;
}

NTSTATUS
GetNTSecurityParameters(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange,
    PSMBCE_SERVER       pServer,
    PUNICODE_STRING     pDomainName,
    PRESP_NT_NEGOTIATE  pNtNegotiateResponse,
    ULONG               BytesIndicated,
    ULONG               BytesAvailable,
    PULONG              pBytesTaken,
    PMDL                *pDataBufferPointer,
    PULONG              pDataSize)
/*++

Routine Description:

    This routine extracts the security parameters from an NT server

Arguments:

    pServer                 - the server

    pDomainName             - the domain name

    pNtNegotiateResponse    - the response

    NegotiateResponseLength - size of the negotiate response

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS   Status = STATUS_SUCCESS;
    USHORT     ByteCount;
    PUSHORT    pByteCountInSmb =
               ((PUSHORT)((PUCHAR) pNtNegotiateResponse + 1)) +
               pNtNegotiateResponse->WordCount;
    PUCHAR     pBuffer = (PUCHAR)(pByteCountInSmb + 1);

    *pBytesTaken += FIELD_OFFSET(RESP_NT_NEGOTIATE,Buffer);

    ByteCount = SmbGetUshort(pByteCountInSmb);

    pServer->SecurityMode = (((pNtNegotiateResponse->SecurityMode & NEGOTIATE_USER_SECURITY) != 0)
                             ? SECURITY_MODE_USER_LEVEL
                             : SECURITY_MODE_SHARE_LEVEL);

    pServer->EncryptPasswords = ((pNtNegotiateResponse->SecurityMode & NEGOTIATE_ENCRYPT_PASSWORDS) != 0);
    pServer->EncryptionKeyLength = 0;

    pServer->SecuritySignaturesEnabled = ((pNtNegotiateResponse->SecurityMode &
                                           NEGOTIATE_SECURITY_SIGNATURES_ENABLED) != 0);
    pServer->SecuritySignaturesRequired = ((pNtNegotiateResponse->SecurityMode &
                                            NEGOTIATE_SECURITY_SIGNATURES_REQUIRED) != 0);

    if (BooleanFlagOn(pServer->NtServer.NtCapabilities,CAP_EXTENDED_SECURITY)) {
        ULONG SecurityBlobLength;

        // The server supports the new security validation scheme. In such cases
        // the BLOB to be passed to the local security package is shipped as
        // part of the negotiate response.

        ASSERT(
            (ByteCount >= sizeof(GUID)) &&
            ((*pBytesTaken + sizeof(GUID)) <= BytesIndicated));

        // Extract the Server GUID
        RtlCopyMemory(
            &pServer->NtServer.ServerGuid,
            pBuffer,
            sizeof(GUID));

        *pBytesTaken += sizeof(GUID);

        if (pServer->NtServer.pSecurityBlob != NULL) {
            RxFreePool(pServer->NtServer.pSecurityBlob);
            pServer->NtServer.pSecurityBlob = NULL;
            pServer->NtServer.SecurityBlobLength = 0;
        }

        // Allocate the Blob and copy the security Blob from the response
        if ((SecurityBlobLength = ByteCount - sizeof(GUID)) > 0) {
            pServer->NtServer.pSecurityBlob = RxAllocatePoolWithTag(
                                                  NonPagedPool,
                                                  SecurityBlobLength,
                                                  MRXSMB_ADMIN_POOLTAG);

            if (pServer->NtServer.pSecurityBlob != NULL) {
                pServer->NtServer.SecurityBlobLength = SecurityBlobLength;

                // If the Blob has been completely indicated it can be copied directly.
                // On the other hand if it is not completely indicated an MDl needs to
                // be setup to allow the underlying TDI layer to complete the copy
                // into the allocated buffer. This entails allocating an MDL of the
                // appropriate size and setting it up.

                if ((*pBytesTaken + SecurityBlobLength) <= BytesIndicated) {
                    RtlCopyMemory(
                        pServer->NtServer.pSecurityBlob,
                        (pBuffer + sizeof(GUID)),
                        SecurityBlobLength);

                    *pBytesTaken += SecurityBlobLength;

                    ASSERT(*pBytesTaken == BytesAvailable);
                } else {
                    if ((*pBytesTaken + SecurityBlobLength) <= BytesAvailable) {
                        // In this case the blob was not indicated completely.
                        *pDataBufferPointer = RxAllocateMdl(
                                                  pServer->NtServer.pSecurityBlob,
                                                  SecurityBlobLength);

                        if (*pDataBufferPointer == NULL) {
                            RxFreePool(pServer->NtServer.pSecurityBlob);
                            pServer->NtServer.pSecurityBlob = NULL;
                            pServer->NtServer.SecurityBlobLength = 0;
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                        } else {
                            MmBuildMdlForNonPagedPool(*pDataBufferPointer);
                            *pDataSize = SecurityBlobLength;
                            Status = STATUS_MORE_PROCESSING_REQUIRED;
                        }
                    } else {
                        *pBytesTaken = BytesAvailable;
                        Status = STATUS_SUCCESS;
                        pSmbAdminExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                    }
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    } else {
        *pBytesTaken = BytesAvailable;

        pServer->SessionKey   = SmbGetUlong( &pNtNegotiateResponse->SessionKey );

        if (pServer->EncryptPasswords) {
            pServer->EncryptionKeyLength = pNtNegotiateResponse->EncryptionKeyLength;

            if (pServer->EncryptionKeyLength != 0) {

                ASSERT( CRYPT_TXT_LEN == MSV1_0_CHALLENGE_LENGTH );

                if (pServer->EncryptionKeyLength != CRYPT_TXT_LEN) {
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                } else {

                    RtlCopyMemory(
                        pServer->EncryptionKey,
                        pBuffer,
                        pServer->EncryptionKeyLength );

                    if (ByteCount - pServer->EncryptionKeyLength > 0) {
                        ASSERT((pDomainName->Buffer != NULL) &&
                               (pDomainName->MaximumLength >= (ByteCount - pServer->EncryptionKeyLength)));

                        pBuffer = pBuffer + pServer->EncryptionKeyLength;
                        pDomainName->Length = ByteCount - pServer->EncryptionKeyLength;

                        if (pDomainName->Length & 1) {
                            // The remainder of the length is odd. This implies that the server did
                            // some alignment.
                            pBuffer++;
                            pDomainName->Length -= 1;
                        }

                        RtlCopyMemory(
                            pDomainName->Buffer,
                            pBuffer,
                            pDomainName->Length);
                    }
                }
            }         
        }
    }

    return Status;
}

NTSTATUS
GetLanmanSecurityParameters(
    PSMBCE_SERVER    pServer,
    PRESP_NEGOTIATE  pNegotiateResponse)
/*++

Routine Description:

    This routine extracts the security parameters from a LANMAN server

Arguments:

    pServer              - the server

    pNtNegotiateResponse - the response

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{

    USHORT i;
    USHORT SecurityMode;

    pServer->SessionKey = SmbGetUlong( &pNegotiateResponse->SessionKey );

    SecurityMode = SmbGetUshort( &pNegotiateResponse->SecurityMode );
    pServer->SecurityMode = (((SecurityMode & 1) != 0)
                             ? SECURITY_MODE_USER_LEVEL
                             : SECURITY_MODE_SHARE_LEVEL);
    pServer->EncryptPasswords = ((SecurityMode & 2) != 0);

    if (pServer->EncryptPasswords) {
        if (pServer->Dialect == LANMAN21_DIALECT) {
            pServer->EncryptionKeyLength = SmbGetUshort(&pNegotiateResponse->EncryptionKeyLength);
        } else {
            pServer->EncryptionKeyLength = SmbGetUshort(&pNegotiateResponse->ByteCount);
        }

        if (pServer->EncryptionKeyLength != 0) {
            if (pServer->EncryptionKeyLength > CRYPT_TXT_LEN) {
                return( STATUS_INVALID_NETWORK_RESPONSE );
            }

            for (i = 0; i < pServer->EncryptionKeyLength; i++) {
                pServer->EncryptionKey[i] = pNegotiateResponse->Buffer[i];
            }
        }
    }

    return( STATUS_SUCCESS );
}

LARGE_INTEGER
ConvertSmbTimeToTime (
    IN SMB_TIME Time,
    IN SMB_DATE Date
    )
/*++

Routine Description:

    This routine converts an SMB time to an NT time structure.

Arguments:

    IN SMB_TIME Time - Supplies the time of day to convert
    IN SMB_DATE Date - Supplies the day of the year to convert
    IN PSERVERLISTENTRY Server - if supplied, supplies the server for tz bias.

Return Value:

    LARGE_INTEGER - Time structure describing input time.


--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;

    //
    // This routine cannot be paged because it is called from both the
    // RdrFileDiscardableSection and the RdrVCDiscardableSection.
    //

    if (SmbIsTimeZero(&Date) && SmbIsTimeZero(&Time)) {
        OutputTime.LowPart = OutputTime.HighPart = 0;
    } else {
        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the SMB are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }
        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }
        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;

        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {
            OutputTime.HighPart = 0;
            OutputTime.LowPart = 0;

            return OutputTime;
        }

        ExLocalTimeToSystemTime(&OutputTime, &OutputTime);

    }

    return OutputTime;

}

VOID
GetLanmanTimeBias(
    PSMBCE_SERVER   pServer,
    PRESP_NEGOTIATE pNegotiateResponse)
/*++

Routine Description:

    This routine extracts the time bias from a Lanman server

Arguments:

    pServer              - the server

    pNtNegotiateResponse - the response

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{
    //  If this is a LM 1.0 or 2.0 server (ie a non NT server), we
    //  remember the timezone and bias our time based on this value.
    //
    //  The redirector assumes that all times from these servers are
    //  local time for the server, and converts them to local time
    //  using this bias. It then tells the user the local time for
    //  the file on the server.
    LARGE_INTEGER Workspace, ServerTime, CurrentTime;
    BOOLEAN Negated = FALSE;
    SMB_TIME SmbServerTime;
    SMB_DATE SmbServerDate;

    SmbMoveTime(&SmbServerTime, &pNegotiateResponse->ServerTime);

    SmbMoveDate(&SmbServerDate, &pNegotiateResponse->ServerDate);

    ServerTime = ConvertSmbTimeToTime(SmbServerTime, SmbServerDate);

    KeQuerySystemTime(&CurrentTime);

#ifndef WIN9X
    Workspace.QuadPart = CurrentTime.QuadPart - ServerTime.QuadPart;
#else
    RxLiSubLi(&Workspace.QuadPart, &CurrentTime.QuadPart, &ServerTime.QuadPart);
#endif

    if ( Workspace.HighPart < 0) {
        //  avoid using -ve large integers to routines that accept only unsigned
#ifndef WIN9X
        Workspace.QuadPart = -Workspace.QuadPart;
#else
        Workspace.HighPart = -Workspace.HighPart;
        Workspace.LowPart = -Workspace.LowPart;
#endif
        Negated = TRUE;
    }

    //
    //  Workspace has the exact difference in 100ns intervals
    //  between the server and redirector times. To remove the minor
    //  difference between the time settings on the two machines we
    //  round the Bias to the nearest 30 minutes.
    //
    //  Calculate ((exact bias+15minutes)/30minutes)* 30minutes
    //  then convert back to the bias time.
    //

#ifndef WIN9X
    Workspace.QuadPart += ((LONGLONG) ONE_MINUTE_IN_TIME) * 15;

    //  Workspace is now  exact bias + 15 minutes in 100ns units

    Workspace.QuadPart /= ((LONGLONG) ONE_MINUTE_IN_TIME) * 30;

    pServer->TimeZoneBias.QuadPart = Workspace.QuadPart * ((LONGLONG) ONE_MINUTE_IN_TIME) * 30;
#else
    pServer->TimeZoneBias.HighPart = Workspace.HighPart;
    pServer->TimeZoneBias.LowPart = Workspace.LowPart;
#endif

    if ( Negated == TRUE ) {
#ifndef WIN9X
        pServer->TimeZoneBias.QuadPart = -pServer->TimeZoneBias.QuadPart;
#else
        pServer->TimeZoneBias.HighPart = -pServer->TimeZoneBias.HighPart;
        pServer->TimeZoneBias.LowPart = -pServer->TimeZoneBias.LowPart;
#endif
    }
}

NTSTATUS
MRxSmbCheckTransportName(
    IN  PIRP                  Irp,
    OUT PSMBCEDB_SERVER_ENTRY *ppServerEntry)
/*++

Routine Description:

    This routine implements the transport name checking on existing connection the server.

    If the tranport name is provided on the Irp, we have 3 cases:

     1. There is no connection to the the server requested;
     2. There is an existing connection to the server and the transport used by the connection has
        the same name as provided;
     3. There is an existing connection to the server and the transport used by the connection has
        the different name as provided.

    This routine will force to tear down the connection on case 3 and let the server reconnected
    on the new transport.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_FULL_EA_INFORMATION pEaEntry;

    pEaEntry = (PFILE_FULL_EA_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    if ((pEaEntry != NULL) && (Irp->Flags & IRP_CREATE_OPERATION)) {
        if (IrpSp->Parameters.Create.Options & FILE_CREATE_TREE_CONNECTION) {
            for(;;) {
                if (strcmp(pEaEntry->EaName, EA_NAME_TRANSPORT) == 0) {
                    if (pEaEntry->EaValueLength > 0) {
                        RXCE_TRANSPORT  RxCeTransport;
                        USHORT          NameLength;
                        PUNICODE_STRING ServerName = &IrpSp->FileObject->FileName;
                        PUNICODE_STRING TransportName = NULL;

                        if (pEaEntry->EaValueLength > 0) {
                            TransportName = RxAllocatePoolWithTag(
                                                NonPagedPool,
                                                (sizeof(UNICODE_STRING) + pEaEntry->EaValueLength),
                                                MRXSMB_MISC_POOLTAG);
                        } else {
                            break;
                        }

                        if (TransportName != NULL) {
                            TransportName->Length        = pEaEntry->EaValueLength;
                            TransportName->MaximumLength = pEaEntry->EaValueLength;

                            TransportName->Buffer = (PWCHAR)((PCHAR)TransportName + sizeof(UNICODE_STRING));
                            RtlCopyMemory(
                                TransportName->Buffer,
                                pEaEntry->EaName + pEaEntry->EaNameLength + 1,
                                TransportName->Length);
                        } else {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }

                        NameLength = ServerName->Length;

                        SmbCeAcquireResource();
                        pServerEntry = SmbCeGetFirstServerEntry();

                        while (pServerEntry != NULL) {
                            if ((NameLength > pServerEntry->Name.Length) &&
                                (ServerName->Buffer[pServerEntry->Name.Length/2] == OBJ_NAME_PATH_SEPARATOR)) {

                                ServerName->Length = pServerEntry->Name.Length;

                                if (RtlEqualUnicodeString(
                                    &pServerEntry->Name,
                                    ServerName,
                                    TRUE)) {

                                    if (pServerEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS) {
                                        pServerEntry = NULL;
                                        Status = STATUS_CONNECTION_ACTIVE;

                                        break;
                                    }

                                    SmbCeReferenceServerEntry(pServerEntry);

                                    if (pServerEntry->pTransport != NULL) {
                                        RxCeTransport = pServerEntry->pTransport->pTransport->RxCeTransport;

                                        if (!RtlEqualUnicodeString(
                                            &RxCeTransport.Name,
                                            TransportName,
                                            TRUE)) {
                                            PSMBCE_TRANSPORT PreferredTransport;


                                            if (!MRxSmbBootedRemotely &&
                                                IsListEmpty(&pServerEntry->ActiveExchanges) &&
                                                (pServerEntry->Server.NumberOfSrvOpens == 0) && //needs to be fixed
                                                (InterlockedCompareExchange(&(pServerEntry->TransportSpecifiedByUser),1,0) == 0) &&
                                                ((PreferredTransport = SmbCeFindTransport(TransportName)) != NULL)) {

                                                if (pServerEntry->Server.NumberOfSrvOpens > 0) {
                                                    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry  = NULL;

                                                    pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
                                                    while (pNetRootEntry != NULL) {
                                                        RxFinalizeNetRoot((PNET_ROOT)pNetRootEntry->pRdbssNetRoot,TRUE,FALSE);
                                                        pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
                                                    }
                                                }

                                                RxDbgTrace(0, Dbg, ("Force tear down connection over Transport: %wZ\n", &RxCeTransport.Name));
                                                SmbCeTransportDisconnectIndicated(pServerEntry);
                                                RxDbgTrace(0, Dbg, ("Build connection over Transport: %wZ\n", TransportName));

                                                if (pServerEntry->PreferredTransport != NULL) {
                                                    SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
                                                }

                                                pServerEntry->PreferredTransport = PreferredTransport;
                                            } else {
                                                SmbCeDereferenceServerEntry(pServerEntry);
                                                pServerEntry = NULL;
                                                Status = STATUS_CONNECTION_ACTIVE;
                                            }
                                        }
                                    }

                                    break;
                                }
                            }

                            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
                        }

                        SmbCeReleaseResource();

                        RxFreePool(TransportName);
                        ServerName->Length = NameLength;
                    }

                    break;
                } else {
                    if (pEaEntry->NextEntryOffset == 0) {
                        break;
                    } else
                        pEaEntry = (PFILE_FULL_EA_INFORMATION)
                                   ((PCHAR) pEaEntry + pEaEntry->NextEntryOffset);
                }
            }
        }
    }

    *ppServerEntry = pServerEntry;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbxchng.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcxchng.h

Abstract:

    This is the include file that defines all constants and types for
    SMB exchange implementation.

Author:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:

    An exchange is the core abstarction on which the SMB connection engine and
    the mini RDR are implemented. It encapsulates the notion of sending an SMB to
    the server and receiving the associated response, i.e, exchanging an SMB and
    hence the name.

    The exchange of an SMB with the server involves the following steps ....

         1) Submitting the formatted SMB buffer for transmission.
         2) Processing a send complete indication which ensures that at the
            transport level the SMB has been sent to the server.
         3) Processing the receive indication which contains all/part of the
            response sent by the server.
         4) Copying additional data not indicated by the transport

    There are a number of variations on this theme. For example there are certain
    SMB's for which no response is expected, e.g., write mailslots and there are
    certain SMB's which are inherently multi part in nature, TRANSACT smb's.

    In addition the steps outlined above will not always happen in that order. The
    precise sequence of events is dictated by the underlying transport chosen and
    the network conditions. It is this dependency that makes the implementation
    of exchanges challenging.

    The two primary goals that the current implementation was designed for are (1)
    performance and (2) encapsulation of transport dependencies. Goal(1) is
    important because this constitutes an integral part of the code path for
    exchanging any packet with the server. Goal (2) is important to ensure
    customization of the Rdr for different transports. This encapsulation provides
    a convenient vehicle for isolating SMB protocol level decisions from transport
    level decisons as much as possible.

    In addition the following goals were used to guide the implementation process ...

         1) The exchange implementation must be able to handle asynchronous
         operations and synchronous operations well. The trade offs were made in
         favour of asynchronous operations as and when required.

         2) Sufficient infrastructure support must be provided so as to ease the
         implementation of different flavours of exchanges.

    The SMB_EXCHANGE consists of a dispatch vector with the following functions

         1) Start                 -- to initiate the exchange
         2) Receive               -- to handle response indications from the server
         3) CopyDataHandler       -- to handle portions of the response not indicated
         4) SendCompletionHandler -- to handle send complete indications from the transport.
         5) QuiescentStateHandler -- to handle transitions to a quiescent state, i.e., no
                                     SMB connection engine operations are outstanding.

         Most kinds of exchange use the QuiescentStateHandler to finalize the
         operation and discard the exchange. However, certain kinds of exchanges
         which implement the notion of a macro exchange, i.e., exchange multiple
         SMB's use this to delineate different phases of the multiple exchange,
         e.g., ORDINARY_EXCHANGE which implements most file io operations.

    In addition to the dispatch vector the vanilla exchange consists of state
    information to record the current state of the exchange, sufficient context
    for resumption and context for handling SMB protocol related operations. The
    SMB protocol requires that each SMB sent to the server be stamped with a MID
    ( multiplex id. ) in order to distinguish between concurrent SMB exchanges.
    The connection engine provides this service.

    The exchange also encapsulates a SMBCE_EXCHANGE_CONTEXT instance which
    encapsulates all the information required for building a SMB_HEADER.

--*/

#ifndef _SMBXCHNG_H_
#define _SMBXCHNG_H_

typedef enum _SMBCE_STATE_ {
    SMBCE_START_IN_PROGRESS,
    SMBCE_STARTED,
    SMBCE_STOP_IN_PROGRESS,
    SMBCE_STOPPED
} SMBCE_STATE, *PSMBCE_STATE;

typedef struct _SMBCE_STARTSTOP_CONTEXT_ {
    SMBCE_STATE  State;
    LONG         ActiveExchanges;
    KEVENT       StopEvent;
    PKEVENT      pServerEntryTearDownEvent;
    LIST_ENTRY   SessionSetupRequests;
} SMBCE_STARTSTOP_CONTEXT, *PSMBCE_STARTSTOP_CONTEXT;

extern SMBCE_STARTSTOP_CONTEXT SmbCeStartStopContext;

//
// SMB_PROTOCOL_EXCHANGE dispatch vector function prototypes ..
//

// the initiator or the start routine
typedef
NTSTATUS
(*PSMB_EXCHANGE_START)(
    IN struct _SMB_EXCHANGE *pExchange);

// The SMB receive handler
typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_RECEIVE)(
    IN struct       _SMB_EXCHANGE *pExchange, // The exchange instance
    IN ULONG        BytesIndicated,
    IN ULONG        BytesAvailable,
    OUT ULONG       *BytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,      // buffer to copy unindicated data
    OUT PULONG      pDataSize,                // buffer size
    IN ULONG        ReceiveFlags
    );

// the SMB xmit callback
typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_SEND_CALLBACK)(
    IN struct _SMB_EXCHANGE     *pExchange,    // The exchange instance
    IN PMDL                   pDataBuffer,
    IN NTSTATUS               SendCompletionStatus
    );

// the copy data callback for fetching large data
typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_COPY_DATA_CALLBACK)(
    IN struct _SMB_EXCHANGE     *pExchange,      // the exchange instance
    IN PMDL                    pCopyDataBuffer, // the buffer
    IN ULONG                   CopyDataSize     // amount of data copied
    );

// the finalization routine
// This particular routine has a signature that is NT specific the IRQL
// parameter that is passed in and the notion of posting. This helps consolidate
// the NT transport driver model of indications at DPC level in SmbCeFinalizeExchange.
// On WIN95 the lease restrictive value of IRQL can be passed in.

typedef
NTSTATUS
(*PSMB_EXCHANGE_FINALIZE)(
   IN OUT struct _SMB_EXCHANGE *pExchange,
   OUT    BOOLEAN              *pPostRequest);

typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_ASSOCIATED_EXCHANGES_COMPLETION)(
    IN OUT struct _SMB_EXCHANGE *pExchange,
    OUT    BOOLEAN              *pPostRequest);

// The Exchange dispatch vector definition

typedef struct _SMB_EXCHANGE_DISPATCH_VECTOR_ {
    PSMB_EXCHANGE_START                                 Start;
    PSMB_EXCHANGE_IND_RECEIVE                           Receive;
    PSMB_EXCHANGE_IND_COPY_DATA_CALLBACK                CopyDataHandler;
    PSMB_EXCHANGE_IND_SEND_CALLBACK                     SendCompletionHandler;
    PSMB_EXCHANGE_FINALIZE                              Finalize;
    PSMB_EXCHANGE_IND_ASSOCIATED_EXCHANGES_COMPLETION   AssociatedExchangesCompletionHandler;
} SMB_EXCHANGE_DISPATCH_VECTOR, *PSMB_EXCHANGE_DISPATCH_VECTOR;

// An enumerated type listing the type of exchanges

typedef enum _SMB_EXCHANGE_TYPE_ {
    CONSTRUCT_NETROOT_EXCHANGE,
    ORDINARY_EXCHANGE,
    TRANSACT_EXCHANGE,
    EXTENDED_SESSION_SETUP_EXCHANGE,
    ADMIN_EXCHANGE,
    SENTINEL_EXCHANGE
} SMB_EXCHANGE_TYPE, *PSMB_EXCHANGE_TYPE;

// known exchange type dispatch vectors

extern SMB_EXCHANGE_DISPATCH_VECTOR ConstructNetRootExchangeDispatch;
extern SMB_EXCHANGE_DISPATCH_VECTOR OrdinaryExchangeDispatch;
extern SMB_EXCHANGE_DISPATCH_VECTOR TransactExchangeDispatch;

// The various states of the exchange. Each exchange transitions from
// the SMBCE_EXCHANGE_INITIALIZATION_START to SMBCE_EXCHANGE_INITIATED  or
// SMBCE_EXCHANGE_ABORTED state.

typedef enum _SMBCE_EXCHANGE_STATE_ {
    SMBCE_EXCHANGE_INITIALIZATION_START,
    SMBCE_EXCHANGE_SERVER_INITIALIZED,
    SMBCE_EXCHANGE_SESSION_INITIALIZED,
    SMBCE_EXCHANGE_NETROOT_INITIALIZED,
    SMBCE_EXCHANGE_SECURITYBUFFER_INITIALIZED,
    SMBCE_EXCHANGE_INITIATED,
    SMBCE_EXCHANGE_ABORTED
} SMBCE_EXCHANGE_STATE, *PSMBCE_EXCHANGE_STATE;

// The exchange encapsulates the transport information from the clients. The
// Exchange engine is sandwiched between the protocol selection engine in the
// mini redirector on one side and the various transports on the other side.
// The transport information encapsulates the various categories of transport
// the exchange engine understands.

typedef struct SMBCE_EXCHANGE_TRANSPORT_INFORMATION {
    union {
        struct {
            struct _SMBCE_VC *pVc;
        } Vcs;
        struct {
             ULONG Dummy;
        } Datagrams;
        struct {
             ULONG Dummy;
        } Hybrid;
     };
} SMBCE_EXCHANGE_TRANSPORT_CONTEXT,
  *PSMBCE_EXCHANGE_TRANSPORT_CONTEXT;

typedef struct _SMBCE_EXCHANGE_CONTEXT_ {
    PMRX_V_NET_ROOT                      pVNetRoot;
    PSMBCEDB_SERVER_ENTRY                pServerEntry;
    PSMBCE_V_NET_ROOT_CONTEXT            pVNetRootContext;
    SMBCE_EXCHANGE_TRANSPORT_CONTEXT     TransportContext;
} SMBCE_EXCHANGE_CONTEXT,*PSMBCE_EXCHANGE_CONTEXT;

//
// Similar to the subclassing of SMB net roots the SMB_EXCHANGE will be subclassed
// further to deal with various types of SMB exchanges. SMB exchanges can be roughly
// classified into the following types based on the interactions involved ...
//
// The SMB's that need to be exchanged need to be augmented with some admin SMB's which
// are required for the maintenance of SMB's in the connection engine.

#define SMBCE_EXCHANGE_MID_VALID                    (0x00000001)
#define SMBCE_EXCHANGE_REUSE_MID                    (0x00000002)
#define SMBCE_EXCHANGE_RETAIN_MID                   (SMBCE_EXCHANGE_REUSE_MID)
#define SMBCE_EXCHANGE_MULTIPLE_SENDS_POSSIBLE      (0x00000004)
#define SMBCE_EXCHANGE_FINALIZED                    (0x00000008)

#define SMBCE_EXCHANGE_ATTEMPT_RECONNECTS           (0x00000010)
#define SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE (0x00000020)
#define SMBCE_EXCHANGE_MAILSLOT_OPERATION           (0x00000040)

#define SMBCE_EXCHANGE_SESSION_CONSTRUCTOR          (0x00000100)
#define SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR          (0x00000200)
#define SMBCE_EXCHANGE_NOT_FROM_POOL                (0x00000800)

#define SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION      (0x00001000)
#define SMBCE_EXCHANGE_TIMEDOUT                     (0x00002000)
#define SMBCE_EXCHANGE_FULL_PROCESSID_SPECIFIED     (0x00004000)
#define SMBCE_EXCHANGE_SMBCE_STOPPED                (0x00008000)

#define SMBCE_EXCHANGE_SIGNATURE_BUFFER_ALLOCATED   (0x01000000)
#define SMBCE_EXCHANGE_DEBUG_SYSCACHE               (0x02000000)

#define SMBCE_ASSOCIATED_EXCHANGE                   (0x80000000)
#define SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED (0x40000000)

#define SMBCE_EXCHANGE_FLAGS_TO_PRESERVE           (SMBCE_EXCHANGE_NOT_FROM_POOL)

#define SMBCE_OPLOCK_RESPONSE_MID    (0xffff)
#define SMBCE_MAILSLOT_OPERATION_MID (0xffff)
#define SMBCE_ECHO_PROBE_MID         (0xfffe)

//
// The cancellation status is defined as a PVOID instead of a BOOLEAN to allow
// us the use of Interlocked manipulation instructions
// There are only two states SMBCE_EXCHANGE_CANCELLED, SMBCE_EXCHANGE_ACTIVE
//

#define SMBCE_EXCHANGE_CANCELLED     (0xcccccccc)
#define SMBCE_EXCHANGE_NOT_CANCELLED (0xaaaaaaaa)

// The Exchange definition

typedef struct _SMB_EXCHANGE {
    union {
        UCHAR                     Type;
        struct {
            NODE_TYPE_CODE        NodeTypeCode;     // node type.
            NODE_BYTE_SIZE        NodeByteSize;     // node size.
            LONG                  ReferenceCount;
        };
    };

    LIST_ENTRY                    SmbMmInUseListEntry;

    PRX_CONTEXT                   RxContext;            //use of these two fields is advisory
    PVOID                         LastExecutingThread;  //OE and Xact will use them

    union {
        NTSTATUS                  SmbStatus;
        PMRX_SMB_SRV_OPEN         SmbSrvOpen;
    };
    NTSTATUS                      Status;

    ULONG                         ServerVersion;
    SMB_EXCHANGE_ID               Id;

    USHORT                        SmbCeState;

    USHORT                        MidCookie;
    SMB_MPX_ID                    Mid;

    LONG                          CancellationStatus;

    ULONG                         SmbCeFlags;
    SMBCE_EXCHANGE_CONTEXT        SmbCeContext;

    LONG                          SendCompletePendingOperations;
    LONG                          CopyDataPendingOperations;
    LONG                          ReceivePendingOperations;
    LONG                          LocalPendingOperations;

    PKEVENT                       pSmbCeSynchronizationEvent;

    LIST_ENTRY                    ExchangeList;
    LARGE_INTEGER                 ExpiryTime;

    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector;

    union {
        struct {
            struct _SMB_EXCHANGE  *pMasterExchange;
            SINGLE_LIST_ENTRY     NextAssociatedExchange;
        } Associated;
        struct {
            SINGLE_LIST_ENTRY     AssociatedExchangesToBeFinalized;
            LONG                  PendingAssociatedExchanges;
        } Master;
    };

    RX_WORK_QUEUE_ITEM            WorkQueueItem;

    PVOID                         BufferForServerResponse;  //For Security Signature verification
    PMDL                          MdlForServerResponse;  //temporarily hold the entire message for security
                                                         //signature checking.
    ULONG                         SmbSecuritySignatureIndex;
    ULONG                         ExchangeTransportInitialized;
    NTSTATUS                      SessionSetupStatus;
    BOOLEAN                       IsOffLineFile;
    BOOLEAN                       IsSecuritySignatureEnabled;
    BOOLEAN                       SecuritySignatureReturned;
    UCHAR                         SmbCommand;
    LIST_ENTRY                    CancelledList;
} SMB_EXCHANGE, *PSMB_EXCHANGE;


INLINE PSMBCEDB_SERVER_ENTRY
SmbCeGetExchangeServerEntry(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    ASSERT(pSmbExchange->SmbCeContext.pServerEntry != NULL);

    return pSmbExchange->SmbCeContext.pServerEntry;
}

INLINE PSMBCE_SERVER
SmbCeGetExchangeServer(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    return &(pSmbExchange->SmbCeContext.pServerEntry->Server);
}

INLINE PSMBCEDB_SESSION_ENTRY
SmbCeGetExchangeSessionEntry(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    if (pSmbExchange->SmbCeContext.pVNetRootContext != NULL) {
        return pSmbExchange->SmbCeContext.pVNetRootContext->pSessionEntry;
    } else {
        return NULL;
    }
}

INLINE PSMBCE_SESSION
SmbCeGetExchangeSession(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    if (pSmbExchange->SmbCeContext.pVNetRootContext != NULL) {
        return &(pSmbExchange->SmbCeContext.pVNetRootContext->pSessionEntry->Session);
    } else {
        return NULL;
    }
}

INLINE PSMBCEDB_NET_ROOT_ENTRY
SmbCeGetExchangeNetRootEntry(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    if (pSmbExchange->SmbCeContext.pVNetRootContext != NULL) {
        return pSmbExchange->SmbCeContext.pVNetRootContext->pNetRootEntry;
    } else {
        return NULL;
    }
}

INLINE PSMBCE_NET_ROOT
SmbCeGetExchangeNetRoot(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    if (pSmbExchange->SmbCeContext.pVNetRootContext != NULL) {
        return &(pSmbExchange->SmbCeContext.pVNetRootContext->pNetRootEntry->NetRoot);
    } else {
        return NULL;
    }
}

INLINE  PMRX_V_NET_ROOT
SmbCeGetExchangeVNetRoot(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    return pSmbExchange->SmbCeContext.pVNetRoot;
}

INLINE PSMBCE_V_NET_ROOT_CONTEXT
SmbCeGetExchangeVNetRootContext(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    return pSmbExchange->SmbCeContext.pVNetRootContext;
}

extern ULONG SmbCeTraceExchangeReferenceCount;

// The following functions ( inline, macros and otherwise ) are defined
// to manipulate the exchanges

// The reset exchange macro provides a mechanism for forcing the exchange
// instance to a well known start state. This is used by the protocol
// selection engine to transceive different SMB's. A note of caution --
// ensure that the conditions are O.K for initialization. There is no well
// known mechanism in the exchange engine to prevent overwriting an
// exchange instance while in use.

#define SmbCeResetExchange(pExchange)                                   \
        (pExchange)->SmbCeFlags &= ~SMBCE_EXCHANGE_FINALIZED;           \
        (pExchange)->ReceivePendingOperations = 0;                      \
        (pExchange)->CopyDataPendingOperations = 0;                     \
        (pExchange)->SendCompletePendingOperations = 0;                 \
        (pExchange)->LocalPendingOperations = 0;                        \
        (pExchange)->Status = STATUS_SUCCESS;                           \
        (pExchange)->SmbStatus = STATUS_SUCCESS

// The following macros provide a mechanism for referencing and dereferencing
// the exchange. The reference count provides a mechanism for detecting
// when an exchange instance can be safely discarded. The reference count
// differs from the pending operations count maintained in the exchange
// which are used to detect when a quiescent state is reached.

#define SmbCeReferenceExchange(pExchange)                               \
        InterlockedIncrement(&(pExchange)->ReferenceCount);             \
        if (SmbCeTraceExchangeReferenceCount) {                         \
           DbgPrint("Reference Exchange %lx Type(%ld) %s %ld %ld\n",    \
                     (pExchange),                                       \
                     (pExchange)->Type,                                 \
                      __FILE__,                                         \
                      __LINE__,                                         \
                      (pExchange)->ReferenceCount);                     \
        }

#define SmbCeDereferenceExchange(pExchange)                             \
        InterlockedDecrement(&(pExchange)->ReferenceCount);             \
        if (SmbCeTraceExchangeReferenceCount) {                         \
           DbgPrint("Dereference Exchange %lx Type(%ld) %s %ld %ld\n",  \
                     (pExchange),                                       \
                     (pExchange)->Type,                                 \
                     __FILE__,                                          \
                     __LINE__,                                          \
                     (pExchange)->ReferenceCount);                      \
        }


#define SmbCeDereferenceAndDiscardExchange(pExchange)                    \
        if (InterlockedDecrement(&(pExchange)->ReferenceCount) == 0) {   \
            SmbCeDiscardExchange(pExchange);                             \
        }                                                                \
        if (SmbCeTraceExchangeReferenceCount) {                          \
            DbgPrint("Dereference Exchange %lx Type(%ld) %s %ld %ld\n",  \
                 (pExchange),                                            \
                 (pExchange)->Type,                                      \
                 __FILE__,                                               \
                 __LINE__,                                               \
                 (pExchange)->ReferenceCount);                           \
        }

// Macros to hide the syntactic details of dereferencing and calling a
// routine in a dispatch vector. These macros are purely intended for
// use in the connection engine only and is not meant for use by
// other modules.

#define SMB_EXCHANGE_DISPATCH(pExchange,Routine,Arguments)        \
      (*((pExchange)->pDispatchVector->Routine))##Arguments

#define SMB_EXCHANGE_POST(pExchange,Routine)                          \
         RxPostToWorkerThread(&(pExchange)->WorkItem.WorkQueueItem,   \
                              (pExchange)->pDispatchVector->Routine,  \
                              (pExchange))

// The following enum type defines the result of invoking the finalization routine
// on an exchange instance.

typedef enum _SMBCE_EXCHANGE_STATUS_ {
    SmbCeExchangeAlreadyFinalized,
    SmbCeExchangeFinalized,
    SmbCeExchangeNotFinalized
} SMBCE_EXCHANGE_STATUS, *PSMBCE_EXCHANGE_STATUS;

// The pending operations associated with an exchange are classified into four kinds
// Receive operations, Copy Data Operations, Send Complete and Local operations.
// These need to be incremented under the protection of a spinlock. However they
// are decremented in the absence of a spinlock ( with the respective assert ).


#define SMBCE_LOCAL_OPERATION         0x1
#define SMBCE_SEND_COMPLETE_OPERATION 0x2
#define SMBCE_COPY_DATA_OPERATION     0x4
#define SMBCE_RECEIVE_OPERATION       0x8

extern NTSTATUS
SmbCeIncrementPendingOperations(
    PSMB_EXCHANGE  pExchange,
    ULONG          PendingOperationsMask,
    PVOID          FileName,
    ULONG          FileLine);

extern NTSTATUS
SmbCeDecrementPendingOperations(
    PSMB_EXCHANGE  pExchange,
    ULONG          PendingOperationsMask,
    PVOID          FileName,
    ULONG          FileLine);

extern SMBCE_EXCHANGE_STATUS
SmbCeDecrementPendingOperationsAndFinalize(
    PSMB_EXCHANGE  pExchange,
    ULONG          PendingOperationsMask,
    PVOID          FileName,
    ULONG          FileLine);

// the pending operations increment routines

#define SmbCeIncrementPendingReceiveOperations(pExchange)           \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_RECEIVE_OPERATION),__FILE__,__LINE__)

#define SmbCeIncrementPendingSendCompleteOperations(pExchange)      \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_SEND_COMPLETE_OPERATION),__FILE__,__LINE__)

#define SmbCeIncrementPendingCopyDataOperations(pExchange)         \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_COPY_DATA_OPERATION),__FILE__,__LINE__)

#define SmbCeIncrementPendingLocalOperations(pExchange)                \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_LOCAL_OPERATION),__FILE__,__LINE__)

// The pending operations decrement routines
// Note the special casing of ReceivePendingOperations since it is the only one
// that can be forced by a disconnect indication. There are two variations in
// the decrement macros. The first flavour is to be used when it can be
// guaranteed that the decrement operation will not lead to the finalization
// of the exchange and the second is to be used when we cannot ensure the criterion
// for the first. The difference between the two is that it eliminates
// acquisition/release of a spinlock.

#define SmbCeDecrementPendingReceiveOperations(pExchange)                  \
        SmbCeDecrementPendingOperations(pExchange,(SMBCE_RECEIVE_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingSendCompleteOperations(pExchange)              \
        SmbCeDecrementPendingOperations(pExchange,(SMBCE_SEND_COMPLETE_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingCopyDataOperations(pExchange)              \
        SmbCeDecrementPendingOperations(pExchange,(SMBCE_COPY_DATA_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingLocalOperations(pExchange)                  \
        SmbCeDecrementPendingOperations(pExchange,(SMBCE_LOCAL_OPERATION),__FILE__,__LINE__)

// The pending operations decrement routines

#define SmbCeDecrementPendingReceiveOperationsAndFinalize(pExchange)          \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_RECEIVE_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingSendCompleteOperationsAndFinalize(pExchange)     \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_SEND_COMPLETE_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingCopyDataOperationsAndFinalize(pExchange)         \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_COPY_DATA_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange)            \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_LOCAL_OPERATION),__FILE__,__LINE__)

//
// This is the pid that will be used by the rdr; rdr1 used 0xcafe.
// only this pid is ever sent except for nt<-->nt creates. in these cases,
// we have to send the full 32bit process id for RPC. actually, we only have to do
// for pipes but we do it all the time instead.
//

#define MRXSMB_PROCESS_ID (0xfeff)

INLINE VOID
SmbCeSetFullProcessIdInHeader(
    PSMB_EXCHANGE  pExchange,
    ULONG          ProcessId,
    PNT_SMB_HEADER pNtSmbHeader)
{
    pExchange->SmbCeFlags |= SMBCE_EXCHANGE_FULL_PROCESSID_SPECIFIED;
    SmbPutUshort(&pNtSmbHeader->Pid, (USHORT)((ProcessId) & 0xFFFF));
    SmbPutUshort(&pNtSmbHeader->PidHigh, (USHORT)((ProcessId) >> 16));
}

// The exchange engine API, for creation and manipulation of exchange instances

// Initialization/Creation of an exchange instance

extern NTSTATUS
SmbCepInitializeExchange(
    PSMB_EXCHANGE                 *pExchangePointer,
    PRX_CONTEXT                   pRxContext,
    PSMBCEDB_SERVER_ENTRY         pServerEntry,
    PMRX_V_NET_ROOT               pVNetRoot,
    SMB_EXCHANGE_TYPE             ExchangeType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);


INLINE NTSTATUS
SmbCeInitializeExchange(
    PSMB_EXCHANGE                   *pExchangePointer,
    PRX_CONTEXT                     pRxContext,
    PMRX_V_NET_ROOT                 pVNetRoot,
    SMB_EXCHANGE_TYPE               ExchangeType,
    PSMB_EXCHANGE_DISPATCH_VECTOR   pDispatchVector)
{
    return SmbCepInitializeExchange(
               pExchangePointer,
               pRxContext,
               NULL,
               pVNetRoot,
               ExchangeType,
               pDispatchVector);
}

INLINE NTSTATUS
SmbCeInitializeExchange2(
    PSMB_EXCHANGE                   *pExchangePointer,
    PRX_CONTEXT                     pRxContext,
    PSMBCEDB_SERVER_ENTRY           pServerEntry,
    SMB_EXCHANGE_TYPE               ExchangeType,
    PSMB_EXCHANGE_DISPATCH_VECTOR   pDispatchVector)
{
    return SmbCepInitializeExchange(
               pExchangePointer,
               pRxContext,
               pServerEntry,
               NULL,
               ExchangeType,
               pDispatchVector);
}


extern NTSTATUS
SmbCeInitializeAssociatedExchange(
    PSMB_EXCHANGE                 *pAssociatedExchangePointer,
    PSMB_EXCHANGE                 pMasterExchange,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

// converting one type of exchange to another

extern NTSTATUS
SmbCeTransformExchange(
    PSMB_EXCHANGE                 pExchange,
    SMB_EXCHANGE_TYPE             NewType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

// Initiating an exchange

extern NTSTATUS
SmbCeInitiateExchange(PSMB_EXCHANGE pExchange);

extern NTSTATUS
SmbCeInitiateAssociatedExchange(
    PSMB_EXCHANGE   pAssociatedExchange,
    BOOLEAN         EnableCompletionHandlerInMasterExchange);

// Resuming an exchange

extern NTSTATUS
SmbCeResumeExchange(PSMB_EXCHANGE pExchange);

// aborting an initiated exchange

extern NTSTATUS
SmbCeAbortExchange(PSMB_EXCHANGE pExchange);

// discarding an exchnge instance

extern VOID
SmbCeDiscardExchange(PVOID pExchange);

// In addition to providing a flexible mechanism for exchanging packets with
// the server the exchange engine also provides a mechanism for building and
// parsing SMB_HEADER's. This functionality is built into the connection
// engine because the meta data in the headers is used to update the connection
// engine database.

// building SMB headers

extern NTSTATUS
SmbCeBuildSmbHeader(
    IN OUT PSMB_EXCHANGE    pExchange,
    IN OUT PVOID            pBuffer,
    IN     ULONG            BufferLength,
    OUT    PULONG           pRemainingBuffer,
    OUT    PUCHAR           pLastCommandInHeader,
    OUT    PUCHAR           *pNextCommand);

// parsing SMB headers.

extern NTSTATUS
SmbCeParseSmbHeader(
    PSMB_EXCHANGE     pExchange,
    PSMB_HEADER       pSmbHeader,
    PGENERIC_ANDX     pCommandToProcess,
    NTSTATUS          *pSmbResponseStatus,
    ULONG             BytesAvailable,
    ULONG             BytesIndicated,
    PULONG            pBytesConsumed);


// The following routines are intended for use in the connection engine only.

extern NTSTATUS
MRxSmbInitializeSmbCe();

extern NTSTATUS
MRxSmbTearDownSmbCe();

extern NTSTATUS
SmbCePrepareExchangeForReuse(PSMB_EXCHANGE pExchange);

extern PVOID
SmbCeMapSendBufferToCompletionContext(
    PSMB_EXCHANGE                 pExchange,
    PVOID                         pBuffer);

extern PVOID
SmbCeMapSendCompletionContextToBuffer(
    PSMB_EXCHANGE                 pExchange,
    PVOID                         pContext);


extern SMBCE_EXCHANGE_STATUS
SmbCeFinalizeExchange(PSMB_EXCHANGE pExchange);

extern VOID
SmbCeFinalizeExchangeOnDisconnect(
    PSMB_EXCHANGE pExchange);

extern NTSTATUS
SmbCeReferenceServer(
    PSMB_EXCHANGE  pExchange);


extern NTSTATUS
SmbCeIncrementActiveExchangeCount();

extern VOID
SmbCeDecrementActiveExchangeCount();

extern VOID
SmbCeSetExpiryTime(
    PSMB_EXCHANGE pExchange);

extern BOOLEAN
SmbCeDetectExpiredExchanges(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCepFinalizeAssociatedExchange(
    PSMB_EXCHANGE pExchange);

extern NTSTATUS
SmbCeCancelExchange(
    PRX_CONTEXT pRxContext);

typedef struct _SMB_CONSTRUCT_NETROOT_EXCHANGE_ {
    union {
        SMB_EXCHANGE;
        SMB_EXCHANGE Exchange;
    };
    SMB_TREE_ID                 TreeId;
    SMB_USER_ID                 UserId;
    BOOLEAN                     fUpdateDefaultSessionEntry;
    BOOLEAN                     fInitializeNetRoot;
    PMRX_NETROOT_CALLBACK       NetRootCallback;
    PMDL                        pSmbRequestMdl;
    PMDL                        pSmbResponseMdl;
    PVOID                       pSmbActualBuffer;              // Originally allocated buffer
    PVOID                       pSmbBuffer;                    // Start of header
    PMRX_CREATENETROOT_CONTEXT  pCreateNetRootContext;
    CSC_SHARE_HANDLE  hShare;
} SMB_CONSTRUCT_NETROOT_EXCHANGE, *PSMB_CONSTRUCT_NETROOT_EXCHANGE;

extern
NTSTATUS
GetSmbResponseNtStatus(
    IN PSMB_HEADER      pSmbHeader,
    IN PSMB_EXCHANGE    pExchange
    );

extern CHAR InitialSecuritySignature[];

#endif // _SMBXCHNG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\stfftest.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StffTest.c

Abstract:


Author:

    Joe Linn     [JoeLinn]    3-20-95

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbSetFixedStufferStateFields)
#pragma alloc_text(PAGE, SMBStuffHexDump)
#pragma alloc_text(PAGE, MRxSmbFakeUpAnMdl)
#pragma alloc_text(PAGE, MRxSmbStfTestReadAndWrite)
#pragma alloc_text(PAGE, MRxSmbStfTestSessionStuff)
#pragma alloc_text(PAGE, MRxSmbStfTestMoreOpenStuff)
#pragma alloc_text(PAGE, MRxSmbStufferDebug)
#pragma alloc_text(PAGE, MRxSmbBuildSmbHeaderTestSurrogate)
#endif

//
//  The local debug trace level
//

RXDT_DefineCategory(STFFTEST);
#define Dbg                              (DEBUG_TRACE_STFFTEST)

#define SET_INITIAL_SMB_DBGS 'FCX'

VOID
MRxSmbSetFixedStufferStateFields (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN PMDL Mdl,
    IN PSMB_EXCHANGE     pExchange,
    IN PRX_CONTEXT RxContext,
    IN PBYTE ActualBufferBase,
    IN PBYTE BufferBase,
    IN PBYTE BufferLimit
    )
{
    PAGED_CODE();

    StufferState->HeaderMdl = Mdl;
    StufferState->Exchange = pExchange;
    StufferState->RxContext = RxContext;
    StufferState->ActualBufferBase =  ActualBufferBase;
    StufferState->BufferBase =  BufferBase;
    StufferState->BufferLimit =  BufferLimit;

    return;
}


#ifndef WIN9X
#define ULONGS_PER_LINE 8
VOID SMBStuffHexDump(
    IN PBYTE Base,
    IN PBYTE Limit,
    IN ULONG  AddressOffset
    )
{
    PBYTE i;
    char TextBuffer[128];
    char sBuffer[8];

    PAGED_CODE();

    for (i = Base;i<Limit;){
        ULONG j,k;
        PBYTE txt=TextBuffer + ULONGS_PER_LINE*9 + 4;
        PBYTE hex=TextBuffer + 3;
        RxSprintf(TextBuffer,"%03x%120c",i- Base+AddressOffset,' ');
        //RxDbgTrace(0, Dbg,("0-   %s\n",TextBuffer));
        for (j=0;j<ULONGS_PER_LINE;j++) {
            if (i>=Limit) break;
            *txt++ = *hex++ = ' ';
            RxSprintf(hex,"%02lx%02lx%02lx%02lx",*(i+3),*(i+2),*(i+1),*i);
            hex+= 8;
            *hex = ' ';  //intermediate
            for (k=0;k<sizeof(ULONG);k++) {
                CHAR c = *i++;
                // use <= here because we already incremented
                if (i<=Limit) {
                    *txt++ = (  ((c>32)&&(c<127))
                                ?c
                                :'.'
                             );
                } else {
                    *txt++ = ' ';
                }
                *txt = 0;
            }
            //RxDbgTrace(0, Dbg,("1-   %s\n",TextBuffer));
        }
        *txt = 0;
        RxDbgTrace(0,(DEBUG_TRACE_ALWAYS), ("    %s\n",TextBuffer));
    }
}
#endif

#if DBG
VOID
MRxSmbDumpStufferState (
    IN ULONG PrintLevel,
    IN PSZ Msg,
    IN PSMBSTUFFER_BUFFER_STATE StufferState      //IN OUT for debug
    )
{
#ifndef WIN9X
    PBYTE i;
    ULONG CurrentSize = (ULONG)(StufferState->CurrentPosition - StufferState->BufferBase);

    RxDbgTraceLV__norx_reverseaction(0,StufferState->ControlPoint,PrintLevel,return);

    RxDbgTrace(0,(DEBUG_TRACE_ALWAYS),("%s Current size = %lx (%ld)\n", Msg, CurrentSize, CurrentSize));
    SMBStuffHexDump(StufferState->BufferBase,StufferState->CurrentPosition,0);
    if (StufferState->DataSize) {
        ULONG AmtToDump;
        PMDL Mdl = StufferState->DataMdl;
        //CODE.IMPROVEMENT the result of this is that you have to lock down BEFORE you
        //                 call stufferdump....maybe we should have a flag in stffstate that signals this
        //                 and lets you get the base the old way (startva+offset)
        PBYTE Base = (PBYTE)(Mdl->MappedSystemVa);
#ifndef WIN9X
        ASSERT( Mdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));
#endif
        RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("-----------Data size = %lx (%ld)\n", StufferState->DataSize, StufferState->DataSize));
        AmtToDump = min(48,Mdl->ByteCount);
        SMBStuffHexDump(Base,Base+AmtToDump,CurrentSize);
        //CODE.IMPROVEMENT someday we'll have to handle a chain of MDLs
    }
#endif // WIN9X
}
#endif // DBG

SMBSTUFFER_BUFFER_STATE SmbStufferState;

VOID
MRxSmbFakeUpAnMdl(
    IN OUT PMDL Mdl,
    IN PBYTE Base,
    IN ULONG Length
    )
{
#ifndef WIN9X
    Mdl->StartVa = (PVOID)(((ULONG_PTR)Base) & ~(PAGE_SIZE - 1));
    Mdl->ByteOffset = (ULONG)(((ULONG_PTR)Base) &(PAGE_SIZE - 1));
    Mdl->MappedSystemVa = Base;
#ifndef WIN9X
    Mdl->MdlFlags = MDL_SOURCE_IS_NONPAGED_POOL;
#else
    Mdl->MdlFlags = 0;
#endif
    Mdl->ByteCount = Length;
#endif //win9x
}


VOID MRxSmbStfTestReadAndWrite(){
    CHAR Smb[512];
    NTSTATUS Status;
    //SMBbuf_STATUS SMBbufStatus;
    //Try some read&X and write&X operations...............
    char smallwritedata[] = "01234567012345670123456701234567";

    PAGED_CODE();

    MRxSmbSetFixedStufferStateFields(
        &SmbStufferState,
        NULL, NULL, NULL,
        &Smb[0],
        &Smb[0],
        &Smb[sizeof(Smb)]
        );

    RtlZeroMemory(SmbStufferState.BufferBase,
                  SmbStufferState.BufferLimit - SmbStufferState.BufferBase
                 );

    MRxSmbSetInitialSMB( &SmbStufferState  STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS) );

    MRxSmbDumpStufferState (1,"Initial SMB",&SmbStufferState);
    Status = (( //qweee
                            MRxSmbStartSMBCommand (&SmbStufferState, SetInitialSMB_Never, SMB_COM_READ_ANDX,
                            SMB_REQUEST_SIZE(NT_READ_ANDX),
                            NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                            0,0,0,0 STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS))
                      )
    );
    RxDbgTrace(0, Dbg,("First readcommand status = %lu\n",Status));
    MRxSmbDumpStufferState (1,"SMB w/ NTREAD&X before stuffing",&SmbStufferState);

    //first, a nt_read_andx
    MRxSmbStuffSMB (&SmbStufferState,
                         "XwdwWdW",
                                     'dF', //Fid
                                     'tsfO', //offset
                                     'xM', //maxcnt
                                     SMB_OFFSET_CHECK(READ_ANDX,MinCount)
                                     // for debugging SMB_OFFSET_CHECK(READ_ANDX,MaxCount)
                                     'nM', //mincnt
                                     'tuoT', //timeout
                                     SMB_OFFSET_CHECK(READ_ANDX,Remaining)
                                     'tC', //countleft
                          StufferCondition(TRUE),"d",
                                     'hgiH', //NT high offset
                          STUFFER_CTL_NORMAL, "B!",
                                     SMB_WCT_CHECK(12)
                                     0
                                     );
    MRxSmbDumpStufferState (1,"SMB w/ NTREAD&X after stuffing",&SmbStufferState);
    Status = (( //qweee
                            MRxSmbStartSMBCommand (&SmbStufferState,SetInitialSMB_Never, SMB_COM_READ_ANDX,
                                                    SMB_REQUEST_SIZE(NT_READ_ANDX),
                                                    NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                                    0,0,0,0 STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS))
                      )
    );
    RxDbgTrace(0, Dbg,("Second readcommand status = %lu\n",Status));
    MRxSmbDumpStufferState (1,"SMB w/ notNTREAD&X before stuffing",&SmbStufferState);

    //next a read_andx....not NT
    MRxSmbStuffSMB (&SmbStufferState,
                         "XwdwWdW",
                                     'dF', //Fid
                                     'tsfO', //offset
                                     'xM', //maxcnt
                                     SMB_OFFSET_CHECK(READ_ANDX,MinCount)
                                     // for debugging SMB_OFFSET_CHECK(READ_ANDX,MaxCount)
                                     'nM', //mincnt
                                     'tuoT', //timeout
                                     SMB_OFFSET_CHECK(READ_ANDX,Remaining)
                                     'tC', //countleft
                          StufferCondition(FALSE),"d",
                                     'hgiH', //NT high offset
                          STUFFER_CTL_NORMAL, "B!",
                                     SMB_WCT_CHECK(10)
                                     0
                                     );
    MRxSmbDumpStufferState (1,"SMB w/ notNTREAD&X after stuffing",&SmbStufferState);
    Status = (( //qweee
                            MRxSmbStartSMBCommand (&SmbStufferState, SetInitialSMB_Never,SMB_COM_WRITE_ANDX,
                                    SMB_REQUEST_SIZE(NT_WRITE_ANDX),
                                    NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS))
                      )
    );
    RxDbgTrace(0, Dbg,("Third readcommand status = %lu\n",Status));
    MRxSmbDumpStufferState (1,"SMB w/ NTWRITE&X before stuffing",&SmbStufferState);

    //next a NT_write_andX
    MRxSmbStuffSMB (&SmbStufferState,
                         "XwddwWwwq",
                                     'dF', //Fid
                                     'tsfO', //offset
                                     'tuoT', //timeout
                                     'dM', //writemode
                                     SMB_OFFSET_CHECK(WRITE_ANDX,Remaining)
                                     'tC', //countleft (remaining)
                                     '--', //reserved
                                     sizeof(smallwritedata), //dsize
                                     //doffset is the 'q'
                          StufferCondition(TRUE),"d",
                                     'hgiH', //NT high offset
                          STUFFER_CTL_NORMAL, "BSc5!",
                                     SMB_WCT_CHECK(14)
                                     sizeof(smallwritedata),smallwritedata,
                                     0
                                     );
    MRxSmbDumpStufferState (1,"SMB w/ NTWRITE&X after stuffing",&SmbStufferState);
    //RxDbgTrace(0, Dbg,("Here in stuffer debug\n"));
}

VOID MRxSmbStfTestSessionStuff(){
    CHAR Smb[512];
    NTSTATUS Status;
    //SMBbuf_STATUS SMBbufStatus;
    char AsciiPassword[] = "AsciiPassword"; //this causes a pad to word boundary
                                            // before unicode strings
    UNICODE_STRING Password,AccountName,PrimaryDomain,NativeOS,NativeLanMan,FileToOpen;
    USHORT SSandX_Flags2 = 0;
    BOOLEAN NTstyle = TRUE;
    NET_ROOT MyNetRoot;

    PAGED_CODE();

    MRxSmbSetFixedStufferStateFields(
        &SmbStufferState,
        NULL, NULL, NULL,
        &Smb[0],
        &Smb[0],
        &Smb[sizeof(Smb)]
        );

    //Try some SS&X and TC&X operations...............
    RtlZeroMemory(SmbStufferState.BufferBase,
                  SmbStufferState.BufferLimit-SmbStufferState.BufferBase
                 );
    RtlInitUnicodeString(&Password, L"Password");
    RtlInitUnicodeString(&AccountName, L"AccountName");
    RtlInitUnicodeString(&PrimaryDomain, L"PrimaryDomain");
    RtlInitUnicodeString(&NativeOS, L"NativeOS");
    RtlInitUnicodeString(&NativeLanMan, L"NativeLanMan");
    RtlInitUnicodeString(&FileToOpen, L"FileToOpen");


    ZeroAndInitializeNodeType(&MyNetRoot, RDBSS_NTC_NETROOT, (NODE_BYTE_SIZE) sizeof(MyNetRoot));
    RtlInitUnicodeString(&MyNetRoot.PrefixEntry.Prefix, L"\\SERver\\SHare");



    MRxSmbSetInitialSMB( &SmbStufferState STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS));


    MRxSmbDumpStufferState (1,"Initial SMB",&SmbStufferState);
    Status = (( //qweee
                            MRxSmbStartSMBCommand (&SmbStufferState, SetInitialSMB_Never,
                                                    SMB_COM_SESSION_SETUP_ANDX, SMB_REQUEST_SIZE(NT_SESSION_SETUP_ANDX),
                                                    NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                                    0,0,
                                                    SMB_FLAGS2_UNICODE,SMB_FLAGS2_UNICODE  STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS))
                      )
                );
    RxDbgTrace(0, Dbg,("First SS&X command status = %lu\n",Status));
    MRxSmbDumpStufferState (1,"SMB w/ NTSESSSS&X before stuffing",&SmbStufferState);
    RxDbgTrace(0, Dbg, ("APsize=%lx, UPsize=%lx\n",sizeof(AsciiPassword),Password.Length));

    //first, a nt_SS_andx
    MRxSmbStuffSMB (&SmbStufferState,
                         "XwwwDw",
                                     'fB', //Bufsize
                                     'xM', //mpxmax
                                     'cV', //vc_num
                                     SMB_OFFSET_CHECK(SESSION_SETUP_ANDX,SessionKey)
                                     // for debugging SMB_OFFSET_CHECK(READ_ANDX,MaxCount)
                                     'sseS', //SessionKey
                                     sizeof(AsciiPassword), //apasslen
                          StufferCondition(NTstyle),"wddBcczzzz",
                                     Password.Length,  //upasslen
                                     'dvsR', //reserved
                                     'spaC', //capabilities
                                     SMB_WCT_CHECK(13)
                                     sizeof(AsciiPassword),AsciiPassword,
                                     Password.Length,Password.Buffer,
                                     &AccountName,&PrimaryDomain,&NativeOS,&NativeLanMan,
                          STUFFER_CTL_NORMAL, "!",
                                     0
                                     );
    MRxSmbDumpStufferState (1,"SMB w/ NTSESSSS&X after stuffing",&SmbStufferState);

    Status = (( //qweee
                            MRxSmbStartSMBCommand (&SmbStufferState,SetInitialSMB_Never,
                                SMB_COM_TREE_CONNECT_ANDX,SMB_REQUEST_SIZE(TREE_CONNECT_ANDX),
                                NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,
                                SMB_FLAGS2_UNICODE,SMB_FLAGS2_UNICODE  STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS)
                                )
                      )
    );
    RxDbgTrace(0, Dbg,("TC&X command status = %lu\n",Status));
    MRxSmbDumpStufferState (1,"SMB w/ TREECON&X before stuffing",&SmbStufferState);

    MRxSmbStuffSMB (&SmbStufferState,
                         "XwwBana!",
                             'gF', //Flags
                             1, //spaslen
                             SMB_WCT_CHECK(4)
                             "",
                             &MyNetRoot,
                             "A:",
                             0
                             );
    MRxSmbDumpStufferState (1,"SMB w/ TREECON&X after stuffing",&SmbStufferState);


    Status = (( //qweee
                            MRxSmbStartSMBCommand (&SmbStufferState,SetInitialSMB_Never,SMB_COM_NT_CREATE_ANDX,
                                                    SMB_REQUEST_SIZE(NT_CREATE_ANDX),
                                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                                    0,0,0,0 STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS))
                      )
    );
    RxDbgTrace(0, Dbg,("Third readcommand status = %lu\n",Status));
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X before stuffing",&SmbStufferState);

    MRxSmbStuffSMB (&SmbStufferState,
                         "XmwdddDdddDddyB",
                                 FileToOpen.Length, //NameLength
                                 'sglF', //Flags
                                 'difD', //root directory fid
                                 'ksaM', //Mask
                                 SMB_OFFSET_CHECK(NT_CREATE_ANDX,AllocationSize)
                                 ' woL','hgiH', //alloc size
                                 'brtA', //Attributes
                                 'ccAS', //share Access
                                 SMB_OFFSET_CHECK(NT_CREATE_ANDX,CreateDisposition)
                                 'psiD', //CreateDisposition
                                 'ntpO', //CreateOptions
                                 'lvlI', //ImpersonationLevel
                                 0xdd, //SecurityFlags (just a byte)
                                 SMB_WCT_CHECK(24)
                                 0
                                     );
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X midway into stuffing",&SmbStufferState);
    {ULONG i;
    for (i=0;i<1100;i+=128){
        RxDbgTrace(0,Dbg,("Testing for fit: %lu %s\n",
                                  i,(MrxSMBWillThisFit(&SmbStufferState,4,i)?"Fits":"Doesn't Fit")
                   ));
    }}
    //proceed with the stuff because we know here that the name fits
    MRxSmbStuffSMB (&SmbStufferState,
                         "v!", &FileToOpen);
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X after stuffing",&SmbStufferState);

}

VOID MRxSmbStfTestMoreOpenStuff(){
    CHAR Smb[512];
    NTSTATUS Status;
    //SMBbuf_STATUS SMBbufStatus;
    BOOLEAN NTstyle = TRUE;
    UNICODE_STRING FileToOpen,FileToOpen3;
    PBYTE RegionPtr;
    MDL FakeMdlForFileName;

    PAGED_CODE();

    MRxSmbSetFixedStufferStateFields(
        &SmbStufferState,
        NULL, NULL, NULL,
        &Smb[0],
        &Smb[0],
        &Smb[sizeof(Smb)]
        );


    RtlZeroMemory(SmbStufferState.BufferBase,
                  SmbStufferState.BufferLimit-SmbStufferState.BufferBase
                 );
    RtlInitUnicodeString(&FileToOpen,  L"FileToOpen2");
    RtlInitUnicodeString(&FileToOpen3, L"FFFFToOpen3");
    MRxSmbFakeUpAnMdl(&FakeMdlForFileName,(PBYTE)FileToOpen.Buffer,FileToOpen.Length);

    MRxSmbSetInitialSMB( &SmbStufferState STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS));


    MRxSmbDumpStufferState (1,"Initial SMB",&SmbStufferState);
    Status = (( //qweee
                        MRxSmbStartSMBCommand (&SmbStufferState,SetInitialSMB_Never,SMB_COM_NT_CREATE_ANDX,
                            SMB_REQUEST_SIZE(NT_CREATE_ANDX),
                            NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                            0,0,0,0 STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS))
                      )
    );
    RxDbgTrace(0, Dbg,("Initial NTCREATE&X status = %lu\n",Status));
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X before stuffing",&SmbStufferState);

    MRxSmbStuffSMB (&SmbStufferState,
                         "XmwdddDdddDddyB",
                                 FileToOpen.Length, //NameLength
                                 'sglF', //Flags
                                 'difD', //root directory fid
                                 'ksaM', //Mask
                                 SMB_OFFSET_CHECK(NT_CREATE_ANDX,AllocationSize)
                                 ' woL','hgiH', //alloc size
                                 'brtA', //Attributes
                                 'ccAS', //share Access
                                 SMB_OFFSET_CHECK(NT_CREATE_ANDX,CreateDisposition)
                                 'psiD', //CreateDisposition
                                 'ntpO', //CreateOptions
                                 'lvlI', //ImpesonationLevel
                                 0xdd, //SecurityFlags (just a byte)
                                 SMB_WCT_CHECK(24)
                                 0
                                     );
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X midway into stuffing",&SmbStufferState);
    {ULONG i;
    for (i=0;i<1100;i+=128){
        RxDbgTrace(0,Dbg,("Testing for fit: %lu %s\n",
                                  i,(MrxSMBWillThisFit(&SmbStufferState,4,i)?"Fits":"Doesn't Fit")
                   ));
    }}
    //proceed with the stuff because we know here that the name fits
    MRxSmbStuffSMB (&SmbStufferState,
                         "rv!",
                         &RegionPtr,0,
                         &FileToOpen);
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X after stuffing",&SmbStufferState);
    if(((ULONG_PTR)RegionPtr)&1) RegionPtr++;
    RtlCopyMemory(RegionPtr,FileToOpen3.Buffer,FileToOpen3.Length);
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X after filename replacement",&SmbStufferState);

    Status = (( //qweee
                        MRxSmbStartSMBCommand (&SmbStufferState,SetInitialSMB_Never,SMB_COM_NT_CREATE_ANDX,
                                                SMB_REQUEST_SIZE(NT_CREATE_ANDX),
                                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                                0,0,0,0 STUFFERTRACE(Dbg,SET_INITIAL_SMB_DBGS))
                      )
    );
    RxDbgTrace(0, Dbg,("Another NTCREATE&X status = %lu\n",Status));
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X before stuffing",&SmbStufferState);

    MRxSmbStuffSMB (&SmbStufferState,
                         "XmwdddDdddDddyB",
                                 FileToOpen.Length, //NameLength
                                 'sglF', //Flags
                                 'difD', //root directory fid
                                 'ksaM', //Mask
                                 SMB_OFFSET_CHECK(NT_CREATE_ANDX,AllocationSize)
                                 ' woL','hgiH', //alloc size
                                 'brtA', //Attributes
                                 'ccAS', //share Access
                                 SMB_OFFSET_CHECK(NT_CREATE_ANDX,CreateDisposition)
                                 'psiD', //CreateDisposition
                                 'ntpO', //CreateOptions
                                 'lvlI', //ImpesonationLevel
                                 0xdd, //SecurityFlags (just a byte)
                                 SMB_WCT_CHECK(24)
                                 0
                                     );
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X midway into stuffing",&SmbStufferState);
    MRxSmbStuffSMB (&SmbStufferState,
                         "s?", 2, 0);
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X after alignment",&SmbStufferState);
    MRxSmbStuffAppendRawData(&SmbStufferState,&FakeMdlForFileName);
    MRxSmbStuffSetByteCount(&SmbStufferState);
    MRxSmbDumpStufferState (1,"SMB w/ NTOPEN&X after filename replacement",&SmbStufferState);

}

#include "fsctlbuf.h"
NTSTATUS
MRxSmbStufferDebug(
    IN PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PSZ ControlString = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;
    ULONG i;


    PAGED_CODE();

    RxDbgTrace(0, Dbg,("Here in stuffer debug %s, obl = %08lx\n",ControlString, OutputBufferLength));

    MRxSmbStfTestReadAndWrite();
    MRxSmbStfTestSessionStuff();
    MRxSmbStfTestMoreOpenStuff();

    //return an obvious string to make sure that darryl is copying the results out correctly
    //need to check the lengths i.e. need outputl<=inputl

    for (i=0;i<InputBufferLength;i++) {
        UCHAR c = ControlString[i];
        if (c==0) { break; }
        if ((i&3)==2) {
            ControlString[i] = '@';
        }
    }

    RxContext->InformationToReturn = i+1;
    return(Status);
}

NTSTATUS
MRxSmbBuildSmbHeaderTestSurrogate(
      PSMB_EXCHANGE     pExchange,
      PVOID             pBuffer,
      ULONG             BufferLength,
      PULONG            pBufferConsumed,
      PUCHAR            pLastCommandInHeader,
      PUCHAR            *pNextCommandPtr)
{
    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)pBuffer;

    PAGED_CODE();

    RtlZeroMemory(NtSmbHeader,sizeof(NT_SMB_HEADER));
    *(PULONG)(&NtSmbHeader->Protocol) = SMB_HEADER_PROTOCOL;
    NtSmbHeader->Command = SMB_COM_NO_ANDX_COMMAND;
    SmbPutUshort (&NtSmbHeader->Pid, MRXSMB_PROCESS_ID_ZERO);
    SmbPutUshort (&NtSmbHeader->Mid, MRXSMB_MULTIPLX_ID_ZERO);
    SmbPutUshort (&NtSmbHeader->Uid, MRXSMB_USER_ID_ZERO);
    SmbPutUshort (&NtSmbHeader->Tid, MRXSMB_TREE_ID_ZERO);

    *pLastCommandInHeader = SMB_COM_NO_ANDX_COMMAND;
    *pNextCommandPtr = &NtSmbHeader->Command;
    *pBufferConsumed = sizeof(SMB_HEADER);
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\stuffer.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Stuffer.c

Abstract:

    This module implements the SMBstuffer formating primitives. the following controlstring
    characters are defined for the stuffer: (** means nyi...**d means downlevel part not implemented)

      0     placeholder for the wct
      1     pad to word boundary
      X     placeholderfor&X
      W,w   format a word from the next parameter
      D,d   format the next parameter as a Dword
      Y,y   format the next parameter as a byte
      L,l   the next parameter is a PLARGE_INTEGER; format it in
      M,m   format a zero byte
  **  2     the next parameter points to a tagged dialect ASCIZI string to be copied in
  **  3     the next parameter points to a tagged devicename ASCIIZ string
      4     the next parameter is either 04-tagged ASCIIZ or UNICODEZ as determined by flags2
      >     the next parameters is ASCIIZ or UNICODEZ as determined by flags2; it is to be appended
                              to the previous 04-tagged item by backing up over the previous null.
      A,a   the next parameter is an ASCIIZ string
      U,u   the next parameter is a UNICODEZ string
      V,v   the next parameter is a UNICODEnoZ string
      z     the next parameter is a PUNICODE_STRING to be stringed as ASCIZI
            or UNICODEZ as determined by flags2
      N,n   the next parameter is a PNET_ROOT whose name is to be stringed as ASCIIZ
            or UNICODEZ as determined by flags2
      R,r   the next 2 parameters are a PBYTE* and a size; reserve the region and store the pointer
      Q,q   the current position is the data offset WORD...remember it
      5     the current position is the start of the data; fill in the data pointer
      P,p   the current position is the parameter offset WORD...remember it
      6     the current position is the start of the parameters; fill in the param pointer
      B,b   the current position is the Bcc WORD...remember it; also, fill in wct
      s     the next parameter has the alignment information....pad accordingly
      S     pad to DWORD
      c     the next 2 parameters are count/addr...copy in the data.
      !     End of this protocol; fill in the bcc field
      ?     next parameter is BOOLEAN_ULONG; 0=>immediate return
      .     NOOP

    For controls with a upper/lowercase pair, the uppercase version indicates that a position tag
    is supplied in the checked version.

Author:

    Joe Linn 3-3-95

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include <stdio.h>
#include <stdarg.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbStuffWrapRtlAssert)
#pragma alloc_text(PAGE, SmbMrxInitializeStufferFacilities)
#pragma alloc_text(PAGE, SmbMrxFinalizeStufferFacilities)
#pragma alloc_text(PAGE, MRxSmbSetInitialSMB)
#pragma alloc_text(PAGE, MRxSmbStartSMBCommand)
#pragma alloc_text(PAGE, MrxSMBWillThisFit)
#pragma alloc_text(PAGE, MRxSmbStuffSMB)
#pragma alloc_text(PAGE, MRxSmbStuffAppendRawData)
#pragma alloc_text(PAGE, MRxSmbStuffAppendSmbData)
#pragma alloc_text(PAGE, MRxSmbStuffSetByteCount)
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ALWAYS)


#define MRXSMB_INITIAL_WCT  (0xcc)
#define MRXSMB_INITIAL_BCC  (0xface)
#define MRXSMB_INITIAL_DATAOFFSET  (0xd0ff)
#define MRXSMB_INITIAL_PARAMOFFSET (0xb0ff)
#define MRXSMB_INITIAL_ANDX (0xdede00ff)

#if 0
//this is old...........
#if DBG

// a little presto-changeo to get assert messages in user mode
// the key is that MRxSmbRxImports->pRxNetNameTable will not be NULL...
// it will point to the netnametable. this
// seems like a small enough price to pay on the way to an rtl assert!

VOID
SmbStuffWrapRtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )

{
    char STARS[] = "**************************************";

    PAGED_CODE();

    if (MRxSmbRxImports->pRxNetNameTable == NULL){
        // do our own thing
        RxDbgTrace(0,Dbg,("%s\n%s\n",STARS,STARS));
        RxDbgTrace (0,Dbg,("Failed Assertion %s\n",FailedAssertion));
        RxDbgTrace(0,Dbg,("%s at line %lu\n",FileName,LineNumber));
        if (Message) {
            RxDbgTrace (0,Dbg,("%s\n",Message));
        }
        RxDbgTrace(0,Dbg,("%s\n%s\n",STARS,STARS));
    } else RtlAssert(FailedAssertion,FileName,LineNumber,Message);
}

#ifdef RtlAssert
#undef RtlAssert
#endif //ifdef RtlAssert
#define RtlAssert SmbStuffWrapRtlAssert

#endif
#endif //if 0


NTSTATUS
SmbMrxInitializeStufferFacilities(
    void
    )
/*++
Routine Description:

     This routine initializes things for the SMB minirdr. we will allocate enough stuff
     to get us going. right now....we do nothing.

Arguments:

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    return(RX_MAP_STATUS(SUCCESS));
}

NTSTATUS
SmbMrxFinalizeStufferFacilities(
    void
    )
/*++
Routine Description:

     This routine finalizes things for the SMB minirdr. we give back everything that
     we have allocated. right now....we do nothing.

Arguments:

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    return(RX_MAP_STATUS(SUCCESS));
}
#if DBG
#define BUILD_HEADER_ROUTINE BuildHeaderRoutine
typedef
NTSTATUS
(NTAPI *PMRXSMB_BUILD_HEADER_ROUTINE) (
      PSMB_EXCHANGE     pExchange,
      PVOID             pBuffer,
      ULONG             BufferLength,
      PULONG            pBufferConsumed,
      PUCHAR            pLastCommandInHeader,
      PUCHAR            *pNextCommandPtr
    );
#else
#define BUILD_HEADER_ROUTINE SmbCeBuildSmbHeader
#endif

NTSTATUS
MRxSmbSetInitialSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    STUFFERTRACE_CONTROLPOINT_ARGS
    )
{
    NTSTATUS       Status;
    PNT_SMB_HEADER NtSmbHeader;
    ULONG          BufferConsumed;
    PBYTE          ScanPosition;
    PUCHAR         pCommand;

#if DBG
    PMRXSMB_BUILD_HEADER_ROUTINE BUILD_HEADER_ROUTINE = SmbCeBuildSmbHeader;
#endif //if DBG

    PAGED_CODE();

    ASSERT ( StufferState != NULL );      //CODE.IMPROVEMENT shouldn't we have a nodetype??
    ASSERT ( sizeof(NT_SMB_HEADER) == sizeof(SMB_HEADER) );
    //RxDbgTrace(0, Dbg, ("MrxSMBSetInitialSMB  base=%08lx,limit=%08lx\n",
    //                                StufferState->BufferBase,StufferState->BufferLimit));
    ASSERT ( (StufferState->BufferLimit - StufferState->BufferBase) > sizeof(SMB_HEADER));
    NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);
    RtlZeroMemory(NtSmbHeader,sizeof(NT_SMB_HEADER));

    //this stuff is reinitialized
    StufferState->DataMdl = NULL; //note that this is not finalized or anything
    StufferState->DataSize = 0;
    StufferState->CurrentWct = NULL;
    StufferState->PreviousCommand = SMB_COM_NO_ANDX_COMMAND;
    StufferState->CurrentCommand = SMB_COM_NO_ANDX_COMMAND;
    StufferState->FlagsCopy = 0;
    StufferState->Flags2Copy = 0;
    StufferState->CurrentPosition = ((PBYTE)NtSmbHeader);

    RxDbgTraceDoit(
            StufferState->ControlPoint = ControlPoint;
            StufferState->PrintCLoop = FALSE;
            StufferState->PrintFLoop = FALSE;
            while (EnablePrints) {
                ULONG c = EnablePrints & 0xff;
                EnablePrints >>= 8;
                if (c=='C') StufferState->PrintCLoop = TRUE;
                if (c=='F') StufferState->PrintFLoop = TRUE;
                if (c=='X') BUILD_HEADER_ROUTINE = MRxSmbBuildSmbHeaderTestSurrogate;
            }
    )

    Status = BUILD_HEADER_ROUTINE(
                  StufferState->Exchange,
                  NtSmbHeader,
                  (ULONG)(StufferState->BufferLimit - StufferState->BufferBase),
                  &BufferConsumed,
                  &StufferState->PreviousCommand,
                  &pCommand);

    if (Status!=RX_MAP_STATUS(SUCCESS)) {
        RxDbgTrace(0, Dbg, ("MrxSMBSetInitialSMB  buildhdr failure st=%08lx\n",Status));
        RxLog(("BuildHdr failed %lx %lx",StufferState->Exchange,Status));
        SmbLog(LOG,
               MRxSmbSetInitialSMB,
               LOGPTR(StufferState->Exchange)
               LOGULONG(Status));
        return Status;
    }

    //copy the flags
    StufferState->FlagsCopy = NtSmbHeader->Flags;
    StufferState->Flags2Copy = SmbGetAlignedUshort(&NtSmbHeader->Flags2);
    if (StufferState->Exchange->Type == ORDINARY_EXCHANGE) {
       PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
       if (BooleanFlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_TURNON_DFS_FLAG)) {
          StufferState->Flags2Copy |= SMB_FLAGS2_DFS;
          SmbPutUshort(&NtSmbHeader->Flags2,(USHORT)StufferState->Flags2Copy);
       }
    }

    StufferState->CurrentPosition += BufferConsumed;

    if (BufferConsumed > sizeof(SMB_HEADER)) {
        if (pCommand != NULL) {
            *pCommand = SMB_COM_NO_ANDX_COMMAND;
        }

        StufferState->CurrentWct = StufferState->CurrentPosition;
    }

    return Status;
}

#define RETURN_A_START_PROBLEM(xxyy) {\
        RxDbgTrace(0,Dbg,("MRxSmbStartSMBCommand gotta problem= %lu\n",xxyy));   \
        StufferState->SpecificProblem = xxyy;       \
        return(RX_MAP_STATUS(INVALID_PARAMETER));        \
}
NTSTATUS
MRxSmbStartSMBCommand (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     INITIAL_SMBBUG_DISPOSITION InitialSMBDisposition,
    IN UCHAR Command, //joejoe this next four params could come from a table...2offset and you're smaller
    IN ULONG MaximumBufferUsed,
    IN ULONG MaximumSize,
    IN ULONG InitialAlignment,
    IN ULONG MaximumResponseHeader,
    IN UCHAR Flags,
    IN UCHAR FlagsMask,
    IN USHORT Flags2,
    IN USHORT Flags2Mask
    STUFFERTRACE_CONTROLPOINT_ARGS
    )
/*++

Routine Description:

    The routine checks to see if the condition is stable. If not, it
    goes into a wait loop alternately getting the resource and then
    waiting on the event.


Arguments:
joejoe review this
     StufferState - the header buffer being used
     InitialSMBDisposition tells when/if to reinit the stuffer state
     Command - the smb command being set up
     MaximumBufferUsed - the amount of the header buffer that will be used (as opposed to the data)
                         this has to be conjured up in advance. if you're not willing to do this, then
                         just push out the current smb. this value should include any data pads!
     MaximumSize - the size of the data. this is to keep from overrunning the srv's smbbuf
     InitialAlignment - a compound argument (i.e. you get it from a constant) the top half
                        tells the alignment unit and the bottom gives the spacing within
     MaximumResponseHeader - how much of the srv's response buffer this will use up
     Flags - the required flags settings
     FlagsMask - which bits of the flags are important
     Flags2 - the required flags2 settings
     Flags2Mask - which flags2 bits are important

Return Value:

    none.

--*/
{
    UCHAR NewFlags;
    USHORT NewFlags2;
    PBYTE *CurrentPosition = &(StufferState->CurrentPosition);
    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);
    ULONG AlignmentUnit = InitialAlignment >> 16;
    ULONG StufferStateRequirement = MaximumBufferUsed + AlignmentUnit;
#if DBG
    PBYTE OriginalPosition = *CurrentPosition;
#endif

    PAGED_CODE();

    if (StufferState->DataSize) {
        StufferState->SpecificProblem = xSMBbufSTATUS_CANT_COMPOUND;
        return(RX_MAP_STATUS(INVALID_PARAMETER));
    }

    if ((InitialSMBDisposition==SetInitialSMB_yyUnconditionally)
        || ((InitialSMBDisposition==SetInitialSMB_ForReuse)&&(StufferState->Started))) {
        MRxSmbSetInitialSMB( StufferState STUFFERTRACE_NOPREFIX(ControlPoint,EnablePrints) );
    }

    StufferState->Started = TRUE;

    //joejoe temporary hack
    switch (StufferState->CurrentCommand) {
    case SMB_COM_LOCKING_ANDX:
    case SMB_COM_OPEN_ANDX:
    case SMB_COM_READ_ANDX:
    case SMB_COM_WRITE_ANDX:
    case SMB_COM_SESSION_SETUP_ANDX:
    //case SMB_COM_LOGOFF_ANDX:
    case SMB_COM_TREE_CONNECT_ANDX:
    case SMB_COM_NT_CREATE_ANDX:
    case SMB_COM_NO_ANDX_COMMAND:
        break;
    default:
        StufferState->SpecificProblem = xSMBbufSTATUS_CANT_COMPOUND;
        return(RX_MAP_STATUS(INVALID_PARAMETER));
    }

    if (*CurrentPosition+StufferStateRequirement >= StufferState->BufferLimit ) {
        StufferState->SpecificProblem = xSMBbufSTATUS_CANT_COMPOUND;
        return(RX_MAP_STATUS(INVALID_PARAMETER));
    }

    if (StufferState->RxContext) {
        PRX_CONTEXT RxContext = StufferState->RxContext;
        PMRX_SRV_CALL SrvCall;
        ULONG CurrentOffset;
        if (RxContext->MajorFunction != IRP_MJ_CREATE) {
            SrvCall = RxContext->pFcb->pNetRoot->pSrvCall; //joejoe cache it?
        } else {
            SrvCall = RxContext->Create.pSrvCall;
        }
        ASSERT(SrvCall);
        CurrentOffset = (ULONG)(*CurrentPosition - StufferState->BufferBase);
        if (CurrentOffset+StufferStateRequirement+MaximumSize
                    > GetServerMaximumBufferSize(SrvCall) ) {
            StufferState->SpecificProblem = xSMBbufSTATUS_SERVER_OVERRUN;
            return(RX_MAP_STATUS(INVALID_PARAMETER));
        }
    }

    NewFlags = Flags | (UCHAR)(StufferState->FlagsCopy);
    NewFlags2 = Flags2 | (USHORT)(StufferState->Flags2Copy);
    if ( ((NewFlags&FlagsMask)!=Flags) ||
         ((NewFlags2&Flags2Mask)!=Flags2) ) {
        StufferState->SpecificProblem = xSMBbufSTATUS_FLAGS_CONFLICT;
        return(RX_MAP_STATUS(INVALID_PARAMETER));
    }
    StufferState->FlagsCopy = NtSmbHeader->Flags = NewFlags;
    StufferState->Flags2Copy = NewFlags2;
    SmbPutAlignedUshort(&NtSmbHeader->Flags2, NewFlags2);

    if (!StufferState->CurrentWct) {
        NtSmbHeader->Command = Command;
    } else {
        PGENERIC_ANDX GenericAndX = (PGENERIC_ANDX)StufferState->CurrentWct;
        if (AlignmentUnit) {
            ULONG AlignmentMask = (AlignmentUnit-1);
            ULONG AlignmentResidue = InitialAlignment&AlignmentMask;
            RxDbgTrace(0, Dbg, ("Aligning start of smb cp&m,m,r=%08lx %08lx %08lx\n",
                                 ((ULONG)(ULONG_PTR)(*CurrentPosition))&AlignmentMask,
                                 AlignmentMask, AlignmentResidue)
                       );
            for (;(((ULONG_PTR)(*CurrentPosition))&AlignmentMask)!=AlignmentResidue;) {
                **CurrentPosition = ',';
                *CurrentPosition += 1;
            }
        }
        GenericAndX->AndXCommand = Command;
        GenericAndX->AndXReserved = 0;
        SmbPutUshort (&GenericAndX->AndXOffset,
                      (USHORT)(*CurrentPosition - StufferState->BufferBase));
    }
    StufferState->CurrentWct = *CurrentPosition;
    StufferState->CurrentCommand = Command;
    StufferState->CurrentDataOffset = 0;
    return RX_MAP_STATUS(SUCCESS);
}

BOOLEAN
MrxSMBWillThisFit(
    IN PSMBSTUFFER_BUFFER_STATE StufferState,
    IN ULONG AlignmentUnit,
    IN ULONG DataSize
    )
{
    //joejoe actually some stuff will fit that this says no...........
    return(StufferState->CurrentPosition+AlignmentUnit+DataSize<StufferState->BufferLimit);
}

#if RDBSSTRACE
#define StufferFLoopTrace(Z) { if (StufferState->PrintFLoop) {RxDbgTraceLV__norx(0,StufferState->ControlPoint,900,Z);}}
#define StufferCLoopTrace(Z) { if (StufferState->PrintCLoop) {RxDbgTraceLV__norx(0,StufferState->ControlPoint,800,Z);}}
#else // DBG
#define StufferFLoopTrace(Z)
#define StufferCLoopTrace(Z)
#endif // DBG

NTSTATUS
MRxSmbStuffSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    ...
    )
{
    va_list AP;
    PBYTE BufferBase = (StufferState->BufferBase);
    PBYTE *CurrentPosition = &(StufferState->CurrentPosition);
    PBYTE *CurrentWct = &(StufferState->CurrentWct);
    PBYTE *CurrentBcc = &(StufferState->CurrentBcc);
    PBYTE *CurrentDataOffset = &(StufferState->CurrentDataOffset);
    PBYTE *CurrentParamOffset = &(StufferState->CurrentParamOffset);
    SMB_STUFFER_CONTROLS CurrentStufferControl = STUFFER_CTL_NORMAL;
    PSMB_HEADER SmbHeader = (PSMB_HEADER)BufferBase;
    PSZ CurrentFormatString = NULL;
    ULONG arg;
    UCHAR WordCount;
    USHORT ByteCount;
//joejoe change this to zero later.....apparently some servers croak on nonzero pad
#define PADBYTE ((UCHAR)0xee)
    PBYTE CopyPtr; ULONG CopyCount,EarlyReturn;
    PBYTE *RegionPtr;
    PUNICODE_STRING Zstring;
    PSZ Astring;
    PNET_ROOT NetRoot;
    PLARGE_INTEGER LargeInteger;
    PBYTE PreviousPosition;
#if DBG
    ULONG offset, required_WCT;
    ULONG CurrentOffset_tmp;
#endif

    PAGED_CODE();

    va_start(AP,StufferState);
    for (;;) {
        switch (CurrentStufferControl) {
        case STUFFER_CTL_SKIP:
        case STUFFER_CTL_NORMAL:
            CurrentFormatString = va_arg(AP,PSZ);
            StufferCLoopTrace(("StufferAC = %s\n",CurrentFormatString));
            ASSERT (CurrentFormatString);
            for (;*CurrentFormatString;CurrentFormatString++) {
                char CurrentFormatChar = *CurrentFormatString;
#if DBG
                { char msgbuf[80];
                switch (CurrentFormatChar) {
                case 'W': case 'w':
                case 'D': case 'd':
                case 'Y': case 'y':
                case 'M': case 'm':
                case 'L': case 'l':
                case 'c': case '4': case '>':
                case '!':
                    //this guys are skipable
                    break;
                default:
                    if (CurrentStufferControl != STUFFER_CTL_SKIP) break;
                    DbgPrint("Bad skip char '%c'\n",*CurrentFormatString);
                    //DbgBreakPoint();
                }}
                //these are the ones that we do the offset check for
                { char msgbuf[80];
#ifndef WIN9X
                RxSprintf(msgbuf,"control char '%c'\n",*CurrentFormatString);
#endif
                switch (CurrentFormatChar) {
                case 'W': case 'D': case 'Y': case 'M': case 'B':
                case 'Q': case 'A': case 'U': case 'V':
                case 'N':
                case 'L':
                case 'R':
                case 'P':
                    offset = va_arg(AP,ULONG);
                    required_WCT = offset>>16;
                    offset = offset & 0xffff;
                    CurrentOffset_tmp = (ULONG)(*CurrentPosition-*CurrentWct);
                    if (offset && (offset != CurrentOffset_tmp)){
                        DbgPrint("Bad offset %d; should be %d\n",offset,CurrentOffset_tmp);
                        //DbgBreakPoint();
                    }
                    break;
                default:
                    break;
                }}
#endif
                switch (CurrentFormatChar) {
                case '0':
                    StufferFLoopTrace(("  StufferFloop '0'\n",0));
                    //just do the wct field...
                    **CurrentPosition = (UCHAR)MRXSMB_INITIAL_WCT;
                    *CurrentPosition+=1;
                    break;
                case 'X':
                    StufferFLoopTrace(("  StufferFloop 'X'\n",0));
                    //do the wct field and the &x
                    **CurrentPosition = (UCHAR)MRXSMB_INITIAL_WCT;
                    *CurrentPosition+=1;
                    SmbPutUlong (*CurrentPosition, (ULONG)MRXSMB_INITIAL_ANDX);
                    *CurrentPosition+=sizeof(ULONG);
                    break;
                case 'W':
                case 'w':
                    arg = va_arg(AP,ULONG);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'w' arg=%lu\n",arg));
                    SmbPutUshort (*CurrentPosition, (USHORT)arg);
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case 'Y':
                case 'y':
                    arg = va_arg(AP,UCHAR);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'y' arg=%lu\n",arg));
                    **CurrentPosition =  (UCHAR)arg;
                    *CurrentPosition+=sizeof(UCHAR);
                    break;
                case 'M':
                case 'm':
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'm'\n",0));
                    **CurrentPosition =  0;
                    *CurrentPosition+=sizeof(UCHAR);
                    break;
                case 'D':
                case 'd':
                    arg = va_arg(AP,ULONG);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'd' arg=%lu\n",arg));
                    SmbPutUlong (*CurrentPosition, arg);
                    *CurrentPosition+=sizeof(ULONG);
                    break;
                case 'L':
                case 'l':
                    LargeInteger = va_arg(AP,PLARGE_INTEGER);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'l' arg=%0lx %0lx\n",
                            LargeInteger->HighPart, LargeInteger->LowPart));
                    SmbPutUlong (*CurrentPosition, LargeInteger->LowPart);
                    SmbPutUlong (*CurrentPosition, LargeInteger->HighPart);
                    *CurrentPosition+=2*sizeof(ULONG);
                    break;
                case 'B':
                case 'b':
                    ASSERT (**CurrentWct == MRXSMB_INITIAL_WCT);
                    WordCount = (UCHAR)((*CurrentPosition-*CurrentWct)>>1); //the one gets shifted off
                    StufferFLoopTrace(("  StufferFloop 'b' Wct=%lu\n",WordCount));
                    DbgDoit( ASSERT(!required_WCT || (WordCount == (required_WCT&0x7fff)));  )
                    **CurrentWct = (UCHAR)WordCount;
                    SmbPutUshort (*CurrentPosition, (USHORT)MRXSMB_INITIAL_BCC);
                    *CurrentBcc = *CurrentPosition;
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case 'Q':
                case 'q':
                    StufferFLoopTrace(("  StufferFloop 'q' \n",0));
                    SmbPutUshort (*CurrentPosition, (USHORT)MRXSMB_INITIAL_DATAOFFSET);
                    *CurrentDataOffset = *CurrentPosition;
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case '5':
                    //fill in the data offset
                    ASSERT (SmbGetUshort (*CurrentDataOffset) == MRXSMB_INITIAL_DATAOFFSET);
                    ByteCount = (USHORT)(*CurrentPosition-BufferBase);
                    StufferFLoopTrace(("  StufferFloop '5' offset=%lu\n",ByteCount));
                    SmbPutUshort (*CurrentDataOffset, (USHORT)ByteCount);
                    break;
                case 'P':
                case 'p':
                    StufferFLoopTrace(("  StufferFloop 'p' \n",0));
                    SmbPutUshort (*CurrentPosition, (USHORT)MRXSMB_INITIAL_PARAMOFFSET);
                    *CurrentParamOffset = *CurrentPosition;
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case '6':
                    //fill in the data offset
                    ASSERT (SmbGetUshort (*CurrentParamOffset) == MRXSMB_INITIAL_PARAMOFFSET);
                    ByteCount = (USHORT)(*CurrentPosition-BufferBase);
                    StufferFLoopTrace(("  StufferFloop '6' offset=%lu\n",ByteCount));
                    SmbPutUshort (*CurrentParamOffset, (USHORT)ByteCount);
                    break;
                case 'S':
                    // pad to ULONG; we loop behind instead of adding so we can clear
                    // out behind ourselves; apparently, some server croak on nonzero padding
                    StufferFLoopTrace(("  StufferFloop 'S' \n",0));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition = (PBYTE)QuadAlignPtr(*CurrentPosition);
                    for (;PreviousPosition!=*CurrentPosition;) {
                        //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = PADBYTE;
                    }
                    break;
                case 's':
                    // pad to arg; we loop behind instead of adding so we can clear
                    // out behind ourselves; apparently, some server croak on nonzero padding
                    arg = va_arg(AP,ULONG);
                    StufferFLoopTrace(("  StufferFloop 's' arg=\n",arg));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += arg-1;
                    *CurrentPosition = (PBYTE)( ((ULONG_PTR)(*CurrentPosition)) & ~((LONG)(arg-1)) );
                    for (;PreviousPosition!=*CurrentPosition;) {
                        //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = PADBYTE;
                    }
                    break;
                case '1':
                    // pad to USHORT; we loop behind instead of adding so we can clear
                    // out behind ourselves; apparently, some server croak on nonzero padding
                    StufferFLoopTrace(("  StufferFloop '1' Curr=%08lx \n",*CurrentPosition));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += sizeof(USHORT)-1;
                    StufferFLoopTrace(("                   Curr=%08lx \n",*CurrentPosition));
                    *CurrentPosition = (PBYTE)( ((ULONG_PTR)(*CurrentPosition)) & ~((LONG)(sizeof(USHORT)-1)) );
                    StufferFLoopTrace(("                   Curr=%08lx \n",*CurrentPosition));
                    for (;PreviousPosition!=*CurrentPosition;) {
                        StufferFLoopTrace(("      StufferFloop '1' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = PADBYTE;
                    }
                    break;
                case 'c':
                    // copy in the bytes....used a lot in transact
                    CopyCount = va_arg(AP,ULONG);
                    CopyPtr = va_arg(AP,PBYTE);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'c' copycount = %lu\n", CopyCount));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += CopyCount;
                    for (;PreviousPosition!=*CurrentPosition;) {
                        //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = *CopyPtr++;
                    }
                    break;
                case 'R':
                case 'r':
                    // copy in the bytes....used a lot in transact
                    RegionPtr = va_arg(AP,PBYTE*);
                    CopyCount = va_arg(AP,ULONG);
                    StufferFLoopTrace(("  StufferFloop 'r' regionsize = %lu\n", CopyCount));
                    *RegionPtr = *CurrentPosition;
                    *CurrentPosition += CopyCount;
                    IF_DEBUG {
                        PreviousPosition = *RegionPtr;
                        for (;PreviousPosition!=*CurrentPosition;) {
                            //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                            *PreviousPosition++ = '-';
                        }
                    }
                    break;
                case 'A':
                case 'a':
                    //copy byte from an asciiz including the trailing NULL
                    Astring = va_arg(AP,PSZ);
                    StufferFLoopTrace(("  StufferFloop 'a' stringing = %s\n", Astring));
                    CopyCount = strlen(Astring)+1;
                    //if (((ULONG)(*CurrentPosition))&1) {
                    //    StufferFLoopTrace(("  StufferFloop 'a' aligning\n", 0));
                    //    *CurrentPosition+=1;
                    //}
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += CopyCount;
                    if (*CurrentPosition >= StufferState->BufferLimit) {
                        StufferFLoopTrace(("  StufferFloop 'a' bufferoverrun\n", 0));
                        ASSERT(!"BufferOverrun");
                        return(RX_MAP_STATUS(BUFFER_OVERFLOW));
                    }
                    RtlCopyMemory(PreviousPosition,Astring,CopyCount);
                    break;
                case 'z':
                case '4':
                case '>':
                    Zstring = va_arg(AP,PUNICODE_STRING);
                    StufferFLoopTrace(("  StufferFloop '4/z/>' stringing = %wZ, cp=\n", Zstring,*CurrentPosition ));
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    if (CurrentFormatChar=='4') {
                        //first lay down a x'04' and then copy either a asciiz or a unicodez depending on the flags setting
                        **CurrentPosition = (UCHAR)4; //ascii marker
                        *CurrentPosition+=1;
                    } else if (CurrentFormatChar=='>'){
                        //back up over the previous NULL
                        //
                        *CurrentPosition-=(FlagOn(SmbHeader->Flags2,SMB_FLAGS2_UNICODE)?sizeof(WCHAR):sizeof(char));
                        StufferFLoopTrace(("  StufferFloop '4/z/>' afterroolback, cp=\n", *CurrentPosition ));
                    }
                    if (FlagOn(SmbHeader->Flags2,SMB_FLAGS2_UNICODE)){

                        if (((ULONG_PTR)(*CurrentPosition))&1) {
                            StufferFLoopTrace(("  StufferFloop '4/z/>' aligning\n", 0));
                            *CurrentPosition+=1;
                        }
                        PreviousPosition = *CurrentPosition;
                        *CurrentPosition += (Zstring->Length + sizeof(WCHAR));
                        if (*CurrentPosition >= StufferState->BufferLimit) {
                            StufferFLoopTrace(("  StufferFloop '4/z/>' bufferoverrun\n", 0));
                            ASSERT(!"BufferOverrun");
                            return(RX_MAP_STATUS(BUFFER_OVERFLOW));
                        }
                        RtlCopyMemory(PreviousPosition,Zstring->Buffer,Zstring->Length);
                        *(((PWCHAR)(*CurrentPosition))-1) = 0;

                    } else {

                        NTSTATUS Status;
                        OEM_STRING OemString;

                        OemString.Length =
                             OemString.MaximumLength =
                                 (USHORT)( StufferState->BufferLimit - *CurrentPosition  - sizeof(CHAR));
                        OemString.Buffer = *CurrentPosition;

                        if (FlagOn(SmbHeader->Flags,SMB_FLAGS_CASE_INSENSITIVE) &&
                            !FlagOn(SmbHeader->Flags2,SMB_FLAGS2_KNOWS_LONG_NAMES)) {
                            Status = RtlUpcaseUnicodeStringToOemString(
                                             &OemString,
                                             Zstring,
                                             FALSE);
                        } else {
                            Status = RtlUnicodeStringToOemString(
                                             &OemString,
                                             Zstring,
                                             FALSE);
                        }

                        if (!NT_SUCCESS(Status)) {
                            StufferFLoopTrace(("  StufferFloop '4/z/>' bufferoverrun(ascii)\n", 0));
                            ASSERT(!"BufferOverrun");
                            return(RX_MAP_STATUS(BUFFER_OVERFLOW));
                        }

                        *CurrentPosition += OemString.Length + 1;
                        *(*CurrentPosition-1) = 0;

                    }
                    break;
                case 'U':
                case 'u':
                    //copy bytes from an UNICODE string including a trailing NULL
                    Zstring = va_arg(AP,PUNICODE_STRING);
                    StufferFLoopTrace(("  StufferFloop 'u' stringing = %wZ\n", Zstring));
                    if (((ULONG_PTR)(*CurrentPosition))&1) {
                        StufferFLoopTrace(("  StufferFloop 'u' aligning\n", 0));
                        *CurrentPosition+=1;
                    }
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += (Zstring->Length + sizeof(WCHAR));
                    if (*CurrentPosition >= StufferState->BufferLimit) {
                        StufferFLoopTrace(("  StufferFloop 'u' bufferoverrun\n", 0));
                        return(RX_MAP_STATUS(BUFFER_OVERFLOW));
                    }
                    RtlCopyMemory(PreviousPosition,Zstring->Buffer,Zstring->Length);
                    *(((PWCHAR)(*CurrentPosition))-1) = 0;
                    break;
                case 'V':
                case 'v':
                    //copy bytes from an UNICODE string no trailing NUL
                    Zstring = va_arg(AP,PUNICODE_STRING);
                    StufferFLoopTrace(("  StufferFloop 'v' stringing = %wZ\n", Zstring));
                    if (((ULONG_PTR)(*CurrentPosition))&1) {
                        StufferFLoopTrace(("  StufferFloop 'v' aligning\n", 0));
                        *CurrentPosition+=1;
                    }
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += Zstring->Length;
                    if (*CurrentPosition >= StufferState->BufferLimit) {
                        StufferFLoopTrace(("  StufferFloop 'v' bufferoverrun\n", 0));
                        ASSERT(!"BufferOverrun");
                        return(RX_MAP_STATUS(BUFFER_OVERFLOW));
                    }
                    RtlCopyMemory(PreviousPosition,Zstring->Buffer,Zstring->Length);
                    break;
                case 'N':
                case 'n':
                    //copy bytes from a NetRoot name....w null
                    //joejoe we need to do the # thing here
                    NetRoot = va_arg(AP,PNET_ROOT);
                    ASSERT(NodeType(NetRoot)==RDBSS_NTC_NETROOT);
                    Zstring = &NetRoot->PrefixEntry.Prefix;
                    StufferFLoopTrace(("  StufferFloop 'n' stringing = %wZ\n", Zstring));
                    if (StufferState->Flags2Copy&SMB_FLAGS2_UNICODE) {
                        if (((ULONG_PTR)(*CurrentPosition))&1) {
                            StufferFLoopTrace(("  StufferFloop 'n' aligning\n", 0));
                            *CurrentPosition+=1;
                        }
                        PreviousPosition = *CurrentPosition;
                        *CurrentPosition += (Zstring->Length + 2 * sizeof(WCHAR));  //extra \ plus a nul
                        if (*CurrentPosition >= StufferState->BufferLimit) {
                            StufferFLoopTrace(("  StufferFloop 'n' bufferoverrun\n", 0));
                            ASSERT(!"BufferOverrun");
                            return(RX_MAP_STATUS(BUFFER_OVERFLOW));
                        }
                        *((PWCHAR)PreviousPosition) = '\\';
                        RtlCopyMemory(PreviousPosition+sizeof(WCHAR),Zstring->Buffer,Zstring->Length);
                        *(((PWCHAR)(*CurrentPosition))-1) = 0;
                    }
                    break;
                case '?':
                    //early out....used in transact to do the setup
                    EarlyReturn = va_arg(AP,ULONG);
                    StufferFLoopTrace(("  StufferFloop '?' out if 0==%08lx\n",EarlyReturn));
                    if (EarlyReturn==0) return RX_MAP_STATUS(SUCCESS);
                    break;
                case '.':
                    //noop...used to reenter without a real formatting string
                    StufferFLoopTrace(("  StufferFloop '.'\n",0));
                    break;
                case '!':
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    ASSERT (SmbGetUshort (*CurrentBcc) == MRXSMB_INITIAL_BCC);
                    ByteCount = (USHORT)(*CurrentPosition-*CurrentBcc-sizeof(USHORT));
                    StufferFLoopTrace(("  StufferFloop '!' arg=%lu\n",ByteCount));
                    SmbPutUshort (*CurrentBcc, (USHORT)ByteCount);
                    return RX_MAP_STATUS(SUCCESS);
                default:
                    StufferFLoopTrace(("  StufferFloop '%c' BADBADBAD\n",*CurrentFormatString));
                    ASSERT(!"Illegal Controlstring character\n");
                } //switch
            }//for
            break;
        case 0:
            return RX_MAP_STATUS(SUCCESS);
        default:
            StufferCLoopTrace(("  StufferCloop %u BADBADBAD\n",CurrentStufferControl));
            ASSERT(!"IllegalStufferControl\n");
        }//switch

        CurrentStufferControl = va_arg(AP,SMB_STUFFER_CONTROLS);
        StufferCLoopTrace(("  StufferCloop NewStufferControl=%u \n",CurrentStufferControl));

    } //for

    return RX_MAP_STATUS(SUCCESS);
}

VOID
MRxSmbStuffAppendRawData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    )
{
    PMDL pMdl;

    PAGED_CODE();

    ASSERT(!StufferState->DataMdl);
    pMdl = StufferState->DataMdl = Mdl;
    StufferState->DataSize = 0;

    while (pMdl != NULL) {
        StufferState->DataSize += pMdl->ByteCount;
        pMdl = pMdl->Next;
    }

    return;
}

VOID
MRxSmbStuffAppendSmbData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    )
{
    ULONG Offset;

    PAGED_CODE();

    ASSERT(!StufferState->DataMdl);
    StufferState->DataMdl = Mdl;
    StufferState->DataSize = Mdl->ByteCount;
    //now reach back into the buffer and set the SMB data offset; if it is already set...just get out
    if (SmbGetUshort (StufferState->CurrentDataOffset) == MRXSMB_INITIAL_DATAOFFSET){
        Offset = (ULONG)(StufferState->CurrentPosition - StufferState->BufferBase);
        RxDbgTrace(0, Dbg,("MRxSmbStuffAppendSmbData offset=%lu\n",Offset));
        SmbPutUshort (StufferState->CurrentDataOffset, (USHORT)Offset);
    }
    return;
}

VOID
MRxSmbStuffSetByteCount(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    )
{
    ULONG ByteCount;

    PAGED_CODE();

    ASSERT (SmbGetUshort (StufferState->CurrentBcc) == MRXSMB_INITIAL_BCC);
    ByteCount = (ULONG)(StufferState->CurrentPosition
                        - StufferState->CurrentBcc
                        - sizeof(USHORT)
                        + StufferState->DataSize);
    RxDbgTrace(0, Dbg,("MRxSmbStuffSetByteCount ByteCount=%lu\n",ByteCount));
    SmbPutUshort (StufferState->CurrentBcc, (USHORT)ByteCount);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\stuffer.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    Stuffer.h

Abstract:

    Prototypes for the SMBstuffer formating primitives

Author:

    Joe Linn 3-3-95

Revision History:

--*/

#ifndef _SMBSTUFFER_INCLUDED_
#define _SMBSTUFFER_INCLUDED_

//CODE.IMPROVEMENT (sweeping) all the routines in here that are defined as MRxSmb.... should be MRxSmb....

IMPORTANT_STRUCTURE(SMBSTUFFER_BUFFER_STATE);

#define COVERED_CALL(x) {\
    Status = x;                         \
    if (Status != RX_MAP_STATUS(SUCCESS)) {  \
        RxDbgTrace(0, Dbg,("nonSUCCESS covered status = %lx\n",Status));    \
        goto FINALLY;                   \
    }                                   \
    ASSERT (StufferState->SpecificProblem == 0); \
}

#define MRXSMB_PROCESS_ID_ZERO (MRXSMB_PROCESS_ID - 1)
#define MRXSMB_MULTIPLX_ID_ZERO (0xdead)
#define MRXSMB_USER_ID_ZERO ((USHORT)'jj')
#define MRXSMB_TREE_ID_ZERO (0xbaba)

#define GetServerMaximumBufferSize(SRVCALL) 4356

#define SMB_REQUEST_SIZE(___x) (FIELD_OFFSET(REQ_##___x,Buffer[0]))
#if DBG
#define SMB_OFFSET_CHECK(___x,___y) (FIELD_OFFSET(REQ_##___x,___y)),
#define SMB_WCTBCC_CHECK(___x,___y) ( ((0x8000|(___z))<<16)+(FIELD_OFFSET(REQ_##___x,ByteCount)) ),
#define SMB_WCT_CHECK(___z) ((0x8000|(___z))<<16),
#else
#define SMB_OFFSET_CHECK(___x,___y)
#define SMB_WCTBCC_CHECK(___x,___y,___z)
#define SMB_WCT_CHECK(___z)
#endif

typedef enum _SMBbuf_STATUS_DETAIL {
    xSMBbufSTATUS_OK,
    xSMBbufSTATUS_CANT_COMPOUND,
    xSMBbufSTATUS_HEADER_OVERRUN,
    xSMBbufSTATUS_BUFFER_OVERRUN,
    xSMBbufSTATUS_SERVER_OVERRUN,
    xSMBbufSTATUS_FLAGS_CONFLICT,
    xSMBbufSTATUS_MAXIMUM
} SMBbuf_STATUS_DETAIL;

//#define STUFFER_STATE_SIGNATURE ('fftS')
typedef struct _SMBSTUFFER_BUFFER_STATE {
    NODE_TYPE_CODE        NodeTypeCode;     // node type.
    NODE_BYTE_SIZE        NodeByteSize;     // node size.
    // this stuff is fixed
    PMDL HeaderMdl;
    PMDL HeaderPartialMdl; //used for breaking up writes to avoid reallocation
    PBYTE ActualBufferBase;
    PBYTE BufferBase;
    PBYTE BufferLimit;
    //this stuff is reinitialized
    PRX_CONTEXT RxContext;
    PSMB_EXCHANGE Exchange;
    PMDL DataMdl;
    ULONG DataSize;
    //PRXCE_DATA_BUFFER FinalMdl; //for later with no chain-send rule
    PBYTE CurrentPosition;
    PBYTE CurrentWct;
    PBYTE CurrentBcc;
    PBYTE CurrentDataOffset;
    PBYTE CurrentParamOffset;
    UCHAR  PreviousCommand;
    UCHAR  CurrentCommand;
    UCHAR  SpecificProblem;  //SMBbuf_STATUS_DETAIL this is set to pass back what happened
    BOOLEAN Started;
    ULONG FlagsCopy;
    ULONG Flags2Copy;
    //ULONG FlagsMask;
    //ULONG Flags2Mask;
#if DBG
    ULONG Signature;
    PDEBUG_TRACE_CONTROLPOINT ControlPoint;
    BOOLEAN PrintFLoop;
    BOOLEAN PrintCLoop;
#endif
} SMBSTUFFER_BUFFER_STATE;


typedef enum _SMB_STUFFER_CONTROLS {
    STUFFER_CTL_NORMAL=1,
    STUFFER_CTL_SKIP, // only w,d,b can be in a skip string
    STUFFER_CTL_NOBYTES,
    STUFFER_CTL_ENDOFARGUMENTS,
    STUFFER_CTL_MAXIMUM
} SMB_STUFFER_CONTROLS;

#define StufferCondition(___c) ((___c)?STUFFER_CTL_NORMAL:STUFFER_CTL_SKIP)

#if DBG
NTSTATUS
MRxSmbStufferDebug(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbBuildSmbHeaderTestSurrogate(
      PSMB_EXCHANGE     pExchange,
      PVOID             pBuffer,
      ULONG             BufferLength,
      PULONG            pBufferConsumed,
      PUCHAR            pLastCommandInHeader,
      PUCHAR            *pCommandPtr
      );

#endif //if DBG



NTSTATUS
SmbMrxInitializeStufferFacilities(
    void
    );

NTSTATUS
SmbMrxFinalizeStufferFacilities(
    void
    );

#ifdef RDBSSTRACE

#define STUFFERTRACE(CONTROLPOINT,__b__) ,(&RxDTPrefixRx CONTROLPOINT),(__b__)
#define STUFFERTRACE_NOPREFIX(CONTROLPOINT,__b__) ,(CONTROLPOINT),(__b__)
#define STUFFERTRACE_CONTROLPOINT_ARGS \
    ,IN PDEBUG_TRACE_CONTROLPOINT ControlPoint,IN ULONG EnablePrints

#else

#define STUFFERTRACE(__a__,__b__)
#define STUFFERTRACE_NOPREFIX(__a__,__b__)
#define STUFFERTRACE_CONTROLPOINT_ARGS

#endif

NTSTATUS
MRxSmbSetInitialSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

#define NO_EXTRA_DATA 0
#define SMB_BEST_ALIGNMENT(__x,__y) ((__x<<16)|__y)
#define NO_SPECIAL_ALIGNMENT 0
#define RESPONSE_HEADER_SIZE_NOT_SPECIFIED 0

typedef enum _INITIAL_SMBBUF_DISPOSITION {
    SetInitialSMB_yyUnconditionally,  //no one should be using this right now!
    SetInitialSMB_ForReuse,
    SetInitialSMB_Never
} INITIAL_SMBBUG_DISPOSITION;

NTSTATUS
MRxSmbStartSMBCommand (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     INITIAL_SMBBUG_DISPOSITION InitialSMBDisposition,
    IN UCHAR Command, //joejoe this next four params could come from a table...2offset and you're smaller
    IN ULONG MaximumBufferUsed,
    IN ULONG MaximumSize,
    IN ULONG InitialAlignment,
    IN ULONG MaximumResponseHeader,
    IN UCHAR Flags,
    IN UCHAR FlagsMask,
    IN USHORT Flags2,
    IN USHORT Flags2Mask
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

NTSTATUS
MRxSmbStuffSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    ...
    );

VOID
MRxSmbStuffAppendRawData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffAppendSmbData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffSetByteCount(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    );

BOOLEAN
MrxSMBWillThisFit(
    IN PSMBSTUFFER_BUFFER_STATE StufferState,
    IN ULONG AlignmentUnit,
    IN ULONG DataSize
    );

#if DBG
VOID
MRxSmbDumpStufferState (
    IN ULONG PrintLevel,
    IN PSZ Msg,
    IN PSMBSTUFFER_BUFFER_STATE StufferState    //IN OUT for debug
    );
#else
#define MRxSmbDumpStufferState(a,b,c)
#endif
#endif   // ifndef _SMBSTUFFER_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\transact.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    transact.c

Abstract:

    This file conatins the implementation of the transact exchange.

Author:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Revision:

    Joe Linn (JoeLi)    -- Revise multiple packet implementation

--*/

#include "precomp.h"
#pragma hdrstop

#include "align.h"
#pragma warning(error:4100)   // Unreferenced formal parameter

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeInitializeTransactionParameters)
#pragma alloc_text(PAGE, SmbCeUninitializeTransactionParameters)
#pragma alloc_text(PAGE, SmbCeDiscardTransactExchange)
#pragma alloc_text(PAGE, SmbCeSubmitTransactionRequest)
#pragma alloc_text(PAGE, _SmbCeTransact)
#pragma alloc_text(PAGE, SmbTransactBuildHeader)
#pragma alloc_text(PAGE, SmbTransactExchangeStart)
#pragma alloc_text(PAGE, SmbTransactExchangeAbort)
#pragma alloc_text(PAGE, SmbTransactExchangeErrorHandler)
#pragma alloc_text(PAGE, SmbTransactExchangeSendCallbackHandler)
#pragma alloc_text(PAGE, SmbCeInitializeTransactExchange)
#pragma alloc_text(PAGE, SendSecondaryRequests)
#endif

//#define SET_DONTSUBSUME_PARAMS
#ifdef SET_DONTSUBSUME_PARAMS
ULONG MRxSmbDontSubsumeParams = 1;
#else
ULONG MRxSmbDontSubsumeParams = 0;
#endif
#if DBG
#define DONTSUBSUME_PARAMS MRxSmbDontSubsumeParams
#else
#define DONTSUBSUME_PARAMS FALSE
#endif

SMB_TRANSACTION_OPTIONS RxDefaultTransactionOptions = DEFAULT_TRANSACTION_OPTIONS;

RXDT_DefineCategory(TRANSACT);
#define Dbg        (DEBUG_TRACE_TRANSACT)

#define MIN(x,y)  ((x) < (y) ? (x) : (y))

#define SMB_TRANSACT_MAXIMUM_PARAMETER_SIZE (0xffff)
#define SMB_TRANSACT_MAXIMUM_DATA_SIZE      (0xffff)

typedef struct _SMB_TRANSACT_RESP_FORMAT_DESCRIPTION {
    ULONG WordCount;
    ULONG TotalParameterCount;
    ULONG TotalDataCount;
    ULONG ParameterCount;
    ULONG ParameterOffset;
    ULONG ParameterDisplacement;
    ULONG DataCount;
    ULONG DataOffset;
    ULONG DataDisplacement;
    ULONG ByteCount;
    ULONG ApparentMsgLength;
} SMB_TRANSACT_RESP_FORMAT_DESCRIPTION, *PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION;

NTSTATUS
SmbTransactAccrueAndValidateFormatData(
    IN struct _SMB_TRANSACT_EXCHANGE *pTransactExchange,    // The exchange instance
    IN  PSMB_HEADER pSmbHeader,
    IN  ULONG        BytesIndicated,
    OUT PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format
    );

extern NTSTATUS
SmbTransactExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize);

extern NTSTATUS
ParseTransactResponse(
    IN struct _SMB_TRANSACT_EXCHANGE *pTransactExchange,    // The exchange instance
    IN PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format,
    IN ULONG        BytesIndicated,
    IN ULONG        BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pCopyRequestMdlPointer,
    OUT PULONG      pCopyRequestSize);


extern NTSTATUS
SendSecondaryRequests(PVOID pContext);

extern NTSTATUS
SmbCeInitializeTransactExchange(
    PSMB_TRANSACT_EXCHANGE              pTransactExchange,
    PRX_CONTEXT                         RxContext,
    PSMB_TRANSACTION_OPTIONS            pOptions,
    PSMB_TRANSACTION_SEND_PARAMETERS    pSendParameters,
    PSMB_TRANSACTION_RECEIVE_PARAMETERS pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext);

NTSTATUS
SmbCeInitializeTransactionParameters(
   PVOID  pSetup,
   USHORT SetupLength,
   PVOID  pParam,
   ULONG  ParamLength,
   PVOID  pData,
   ULONG  DataLength,
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters
)
/*++

Routine Description:

    This routine initializes the transaction parameters

Arguments:

    pSetup             - the setup buffer

    SetupLength        - the setup buffer length

    pParam             - the param buffer

    ParamLength        - the param buffer length

    pData              - the data buffer

    DataLength         - the data buffer length

    pTransactionParameters - the transaction parameters instance

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The TRANSACTION parameters come in two flavours -- the send parameters for the data
    that is to be sent to the server and the receive parameters for receiving the data
    from the server. There is one subtle difference in the way in which the parameters are
    stored and referenced in these two cases. In the send case the Setup buffer is stored
    as a pointer itself while in the receive case it is stored in the form of a MDL.

    This is because the SMB protocol requires that the Header + setup information for a
    transaction request cannot be greated then the maximum SMB buffer size, i.e., setup
    information cannot spill to a secondary request. The buffer that is allocated for the
    header is made sufficiently large enough to hold the setup data as well. On the other
    hand the receives are handled in a two phase manner, -- the indication at the DPC
    level followed by a copy data request if required. In order to avoid having to transition
    between DPC level and a worker thread the MDL's for the buffers are eagerly evaluated.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PMDL     pSetupMdl = NULL;
    PMDL     pParamMdl = NULL;
    PMDL     pDataMdl  = NULL;

    PAGED_CODE();

    if (pTransactionParameters->Flags & TRANSACTION_RECEIVE_PARAMETERS_FLAG) {
        if ((pSetup != NULL) && (SetupLength > 0)) {
            pSetupMdl = RxAllocateMdl(pSetup,SetupLength);
            if (pSetupMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxProbeAndLockPages(pSetupMdl,KernelMode,IoModifyAccess,Status);
                if ((Status != RX_MAP_STATUS(SUCCESS))) {
                    IoFreeMdl(pSetupMdl);
                    pSetupMdl = NULL;
                } else {
                    if (MmGetSystemAddressForMdlSafe(pSetupMdl,LowPagePriority) == NULL) { //this maps the Mdl
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }
        }

        if ((Status == RX_MAP_STATUS(SUCCESS)) && (pParam != NULL) && (ParamLength > 0)) {
            pParamMdl = RxAllocateMdl(pParam,ParamLength);
            if (pParamMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxProbeAndLockPages(pParamMdl,KernelMode,IoModifyAccess,Status);
                if ((Status != RX_MAP_STATUS(SUCCESS))) {
                    IoFreeMdl(pParamMdl);
                    pParamMdl = NULL;
                } else {
                    if (MmGetSystemAddressForMdlSafe(pParamMdl,LowPagePriority) == NULL) { //this maps the Mdl
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }
        }

        pTransactionParameters->SetupLength = SetupLength;
        pTransactionParameters->ParamLength = ParamLength;
        pTransactionParameters->pParamMdl = pParamMdl;
        pTransactionParameters->pSetupMdl = pSetupMdl;
    } else {
        pTransactionParameters->SetupLength = SetupLength;
        pTransactionParameters->pSetup      = pSetup;
        pTransactionParameters->ParamLength = ParamLength;
        pTransactionParameters->pParam      = pParam;
        pTransactionParameters->pParamMdl = NULL;
    }

    ASSERT( !((pData == NULL)&&(DataLength!=0)) );
    if ((Status == RX_MAP_STATUS(SUCCESS)) && (pData != NULL) && (DataLength > 0)) {
        pDataMdl = RxAllocateMdl(pData,DataLength);
        if (pDataMdl == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RxProbeAndLockPages(pDataMdl,KernelMode,IoModifyAccess,Status);
            if ((Status != RX_MAP_STATUS(SUCCESS))) {
                IoFreeMdl(pDataMdl);
                pDataMdl = NULL;
            } else {
                if (MmGetSystemAddressForMdlSafe(pDataMdl,LowPagePriority) == NULL) { //this maps the Mdl
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
    }

    pTransactionParameters->pDataMdl  = pDataMdl;
    pTransactionParameters->DataLength  = DataLength;
    ASSERT((Status != RX_MAP_STATUS(SUCCESS)) || (DataLength == 0) || (pDataMdl != NULL));

    if ((Status != RX_MAP_STATUS(SUCCESS))) {
        if (pTransactionParameters->Flags & TRANSACTION_RECEIVE_PARAMETERS_FLAG) {
            if (pSetupMdl != NULL) {
                MmUnlockPages(pSetupMdl);  //this unmaps as well
                IoFreeMdl(pSetupMdl);
            }

            if (pParamMdl != NULL) {
                MmUnlockPages(pParamMdl);
                IoFreeMdl(pParamMdl);
            }
        }

        if (pDataMdl != NULL) {
            MmUnlockPages(pDataMdl);
            IoFreeMdl(pDataMdl);
        }
    }

    return Status;
}

VOID
SmbCeUninitializeTransactionParameters(
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters
)
/*++

Routine Description:

    This routine uninitializes the transaction parameters, i.e., free the associated MDL's

Arguments:

    pTransactionParameters - the parameter instance for uninitialization

--*/
{
    PAGED_CODE();

    if (pTransactionParameters->Flags & TRANSACTION_RECEIVE_PARAMETERS_FLAG) {
        if (pTransactionParameters->pSetupMdl != NULL) {
            MmUnlockPages(pTransactionParameters->pSetupMdl);
            IoFreeMdl(pTransactionParameters->pSetupMdl);
        }
    }

    if (pTransactionParameters->pParamMdl != NULL) {
         MmUnlockPages(pTransactionParameters->pParamMdl);
        IoFreeMdl(pTransactionParameters->pParamMdl);
    }

    if (pTransactionParameters->pDataMdl != NULL
        && !BooleanFlagOn(pTransactionParameters->Flags,SMB_XACT_FLAGS_CALLERS_SENDDATAMDL)) {
        MmUnlockPages(pTransactionParameters->pDataMdl);
        IoFreeMdl(pTransactionParameters->pDataMdl);
    }
}

VOID
SmbCeDiscardTransactExchange(PSMB_TRANSACT_EXCHANGE pTransactExchange)
/*++

Routine Description:

    This routine discards a transact exchange

Arguments:

    pExchange - the exchange instance

--*/
{
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext;

    PAGED_CODE();

    // Deallocate any transact exchange specfic allocations ...
    if (pTransactExchange->pActualPrimaryRequestSmbHeader != NULL) {
        RxFreePool(pTransactExchange->pActualPrimaryRequestSmbHeader);
    }

    if (pTransactExchange->pReceiveSetupMdl != NULL) {
        MmUnlockPages(pTransactExchange->pReceiveSetupMdl);
        IoFreeMdl(pTransactExchange->pReceiveSetupMdl);
    }

    if (pTransactExchange->pReceiveParamMdl != NULL) {
        MmUnlockPages(pTransactExchange->pReceiveParamMdl);
        IoFreeMdl(pTransactExchange->pReceiveParamMdl);
    }

    if (pTransactExchange->pReceiveDataMdl != NULL) {
        MmUnlockPages(pTransactExchange->pReceiveDataMdl);
        IoFreeMdl(pTransactExchange->pReceiveDataMdl);
    }

    if (pTransactExchange->pSendSetupMdl != NULL) {
        MmUnlockPages(pTransactExchange->pSendSetupMdl);
        IoFreeMdl(pTransactExchange->pSendSetupMdl);
    }

    if ((pTransactExchange->pSendDataMdl != NULL) &&
         !BooleanFlagOn(pTransactExchange->Flags,SMB_XACT_FLAGS_CALLERS_SENDDATAMDL)) {
        MmUnlockPages(pTransactExchange->pSendDataMdl);
        IoFreeMdl(pTransactExchange->pSendDataMdl);
    }

    if (pTransactExchange->pSendParamMdl != NULL) {
        MmUnlockPages(pTransactExchange->pSendParamMdl);
        IoFreeMdl(pTransactExchange->pSendParamMdl);
    }

    if ((pResumptionContext = pTransactExchange->pResumptionContext) != NULL) {
        NTSTATUS FinalStatus;
        PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry((PSMB_EXCHANGE)pTransactExchange);

        RxDbgTrace(0, Dbg,
                 ("SmbCeTransactExchangeFinalize: everythings is good! parambytes (%ld) databytes (%ld)\n",
                  pTransactExchange->ParamBytesReceived, pTransactExchange->DataBytesReceived
                ));

        FinalStatus = pTransactExchange->Status;

        if (pTransactExchange->Status != STATUS_SUCCESS) {
            FinalStatus = CscTransitionVNetRootForDisconnectedOperation(
                              pTransactExchange->RxContext,
                              SmbCeGetExchangeVNetRoot(pTransactExchange),
                              pTransactExchange->Status);
        }
        else if (pTransactExchange->SmbStatus != STATUS_SUCCESS)
        {
            FinalStatus = CscTransitionVNetRootForDisconnectedOperation(
                              pTransactExchange->RxContext,
                              SmbCeGetExchangeVNetRoot(pTransactExchange),
                              pTransactExchange->SmbStatus);

        }

        if (pServerEntry->ServerStatus != STATUS_SUCCESS &&
            !SmbCeIsServerInDisconnectedMode(pServerEntry) &&
            !FlagOn(pTransactExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
            // If the server entry is in error state, the transact cannot receive a response from server.
            // In this case, we return the server status.
            pResumptionContext->FinalStatusFromServer = pServerEntry->ServerStatus;
        } else {
            // If the server entry is in good or disconnected state, we return the smb status.
            pResumptionContext->FinalStatusFromServer = pTransactExchange->SmbStatus;
        }

        if ((FinalStatus == STATUS_SUCCESS)||
            (FinalStatus == STATUS_MORE_PROCESSING_REQUIRED)) {

            FinalStatus = pResumptionContext->FinalStatusFromServer;
        }

        pResumptionContext->SmbCeResumptionContext.Status = FinalStatus;
        pResumptionContext->SetupBytesReceived = pTransactExchange->SetupBytesReceived;
        pResumptionContext->DataBytesReceived = pTransactExchange->DataBytesReceived;
        pResumptionContext->ParameterBytesReceived = pTransactExchange->ParamBytesReceived;
        pResumptionContext->ServerVersion = pTransactExchange->ServerVersion;

        SmbCeResume(&pResumptionContext->SmbCeResumptionContext);
    }

    SmbCeDereferenceAndDiscardExchange((PSMB_EXCHANGE)pTransactExchange);
}

NTSTATUS
SmbCeSubmitTransactionRequest(
    PRX_CONTEXT                           RxContext,
    PSMB_TRANSACTION_OPTIONS              pOptions,
    PSMB_TRANSACTION_PARAMETERS           pSendParameters,
    PSMB_TRANSACTION_PARAMETERS           pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT   pResumptionContext )
/*++

Routine Description:

    This routine submits a transaction request, i.e., allocates/initializes a transaction
    exchange, sets up the completion information and initiates it

Arguments:

    pNetRoot           - the netroot for which the transaction request is intended

    pOptions           - the transaction options

    pSendParameters    - the transaction parameters to be sent to the server

    pReceiveParameters - the transaction results from the server

    pResumptionContext - the context for resuming the local activity on completion of the
                         transaction

Return Value:

    RXSTATUS - The return status for the operation
      STATUS_PENDING -- if the transcation was initiated successfully
      Other error codes if the request could not be submitted successfully

Notes:

    Whenever a status of STATUS_PENDING is returned it implies that the transact
    exchange has assumed ownership of the MDLs passed in as receive and send
    parameters. They will be released on completion of the exchange.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_V_NET_ROOT pVNetRoot = NULL;

    PSMB_TRANSACT_EXCHANGE pTransactExchange;
    PSMB_EXCHANGE          pExchange = NULL;

    PAGED_CODE();

    if (capFobx == NULL) {
        if (RxContext->MajorFunction == IRP_MJ_CREATE) {
            pVNetRoot = RxContext->Create.pVNetRoot;
        }
    } else {
        // These are the root objects which are associated with the device FCB. In
        // such cases

        pVNetRoot = (PMRX_V_NET_ROOT)capFobx;

        if (NodeType(pVNetRoot) != RDBSS_NTC_V_NETROOT) {
            pVNetRoot = capFobx->pSrvOpen->pVNetRoot;
        }
    }

    if (pVNetRoot == NULL) {
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

        // Allocate and initialize an exchange for the given net root.
        Status = SmbCeInitializeExchange2(
                    &pExchange,
                    RxContext,
                    pServerEntry,
                    TRANSACT_EXCHANGE,
                    &TransactExchangeDispatch);
    } else {
        // Allocate and initialize an exchange for the given net root.
        Status = SmbCeInitializeExchange(
                    &pExchange,
                    RxContext,
                    pVNetRoot,
                    TRANSACT_EXCHANGE,
                    &TransactExchangeDispatch);
    }

    if (Status == STATUS_SUCCESS) {
        // Initialize the transact exchange
        pTransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

        Status = SmbCeInitializeTransactExchange(
                     pTransactExchange,
                     RxContext,
                     pOptions,
                     pSendParameters,
                     pReceiveParameters,
                     pResumptionContext);

        if (Status == STATUS_SUCCESS) {
            // The transact exchange can be either asynchronous or synchronous. In
            // the asynchronous case an additional reference is taken which is
            // passed onto the caller alongwith the exchange squirelled away in the
            // RX_CONTEXT if STATUS_PENDING is being returned. This enables the
            // caller to control when the exchange is discarded. This works
            // especially well in dealing with cancellation of asynchronous
            // exchanges.

            // This reference will be accounted for by the finalization routine
            // of the transact exchange.
            SmbCeReferenceExchange((PSMB_EXCHANGE)pTransactExchange);

            if (BooleanFlagOn(pOptions->Flags,SMB_XACT_FLAGS_ASYNCHRONOUS)) {
                // The corresponding dereference is the callers responsibility
                SmbCeReferenceExchange((PSMB_EXCHANGE)pTransactExchange);
            }

            if (pTransactExchange->Flags & SMB_XACT_FLAGS_MAILSLOT_OPERATION) {
                pTransactExchange->SmbCeFlags |= SMBCE_EXCHANGE_MAILSLOT_OPERATION;
            }

            pResumptionContext->pTransactExchange = pTransactExchange;
            pResumptionContext->SmbCeResumptionContext.Status = STATUS_SUCCESS;

            SmbCeIncrementPendingLocalOperations(pExchange);

            // Initiate the exchange
            Status = SmbCeInitiateExchange(pExchange);

            if (Status != STATUS_PENDING) {
                pExchange->Status = Status;

                if (pExchange->SmbStatus == STATUS_SUCCESS) {
                    pExchange->SmbStatus = Status;
                }

                if (BooleanFlagOn(pOptions->Flags,SMB_XACT_FLAGS_ASYNCHRONOUS)) {
                    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

                    pMRxSmbContext->pExchange     = NULL;

                    // Since the exchange has already been completed there is no
                    // point in returning the additional reference to the caller
                    SmbCeDereferenceExchange((PSMB_EXCHANGE)pTransactExchange);
                }
            }

            SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

            // Map the status to STATUS_PENDING so that continuation routines
            // do not attempt to finalize.
            Status = STATUS_PENDING;
        } else {
            PMRXSMB_RX_CONTEXT MRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

            ASSERT(MRxSmbContext->pExchange == pExchange);
            MRxSmbContext->pExchange = NULL;

            SmbCeDiscardExchange(pExchange);
        }
    }

    return Status;
}

NTSTATUS
_SmbCeTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferLength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext)
/*++

Routine Description:

    This routine implements a standardized mechanism of submitting transaction requests,
    and synchronizing with their completion. This does not provide the smae amount of control
    that SmbCeSubmitTransactRequest provides. Nevertheless, this implements a common mechanism
    that should satisfy most needs

Arguments:

    RxContext               - the context for the transaction

    pOptions                - the transaction options

    pSetupBuffer            - the transaction setup buffer

    SetupBufferlength       - the setup buffer length

    pInputParamBuffer       - the Input param buffer

    InputParamBufferLength  - the input param buffer length

    pOutputParamBuffer      - the output param buffer

    OutputParamBufferlength - the output param buffer length

    pInputDataBuffer        - the Input data buffer

    InputDataBufferLength   - the input data buffer length

    pOutputDataBuffer       - the output data buffer

    OutputDataBufferlength  - the output data buffer length

    pResumptionContext       - the transaction resumption context

Return Value:

    RXSTATUS - The return status for the operation
      STATUS_SUCCESS if successfull.
      Other error codes if the request could not be submitted successfully

Notes:

    In the case of asynchronous exchanges if STATUS_PENDING is returned the
    Exchange instance is squirelled away in the minirdr context associated with
    the given RX_CONTEXT instance. This exchange will not be discarded without
    the callers intervention. It is the callers responsibility to invoke
    SmbCeDereferenceAndDiscardExchange to discard the exchange

--*/
{
    NTSTATUS Status;

    SMB_TRANSACTION_SEND_PARAMETERS     SendParameters;
    SMB_TRANSACTION_RECEIVE_PARAMETERS  ReceiveParameters;
    BOOLEAN                             fAsynchronous;

    PAGED_CODE();

    fAsynchronous = BooleanFlagOn(pOptions->Flags,SMB_XACT_FLAGS_ASYNCHRONOUS);

    Status = SmbCeInitializeTransactionSendParameters(
                 pInputSetupBuffer,
                 (USHORT)InputSetupBufferLength,
                 pInputParamBuffer,
                 InputParamBufferLength,
                 pInputDataBuffer,
                 InputDataBufferLength,
                 &SendParameters);

    if (Status == STATUS_SUCCESS) {
        Status = SmbCeInitializeTransactionReceiveParameters(
                     pOutputSetupBuffer,        // the setup information expected in return
                     (USHORT)OutputSetupBufferLength,   // the length of the setup information
                     pOutputParamBuffer,        // the buffer for the param information
                     OutputParamBufferLength,   // the length of the param buffer
                     pOutputDataBuffer,         // the buffer for data
                     OutputDataBufferLength,    // the length of the buffer
                     &ReceiveParameters);

        if (Status != STATUS_SUCCESS) {
            SmbCeUninitializeTransactionSendParameters(&SendParameters);
        }
    }

    if (Status == STATUS_SUCCESS) {
        Status = SmbCeSubmitTransactionRequest(
                     RxContext,                    // the RXContext for the transaction
                     pOptions,                     // transaction options
                     &SendParameters,              // input parameters
                     &ReceiveParameters,           // expected results
                     pResumptionContext            // the context for resumption.
                     );

        if ((Status != STATUS_SUCCESS) &&
            (Status != STATUS_PENDING)) {
            SmbCeUninitializeTransactionReceiveParameters(&ReceiveParameters);
            SmbCeUninitializeTransactionSendParameters(&SendParameters);
        } else {
            if (!fAsynchronous) {
                if (Status == STATUS_PENDING) {
                    SmbCeWaitOnTransactionResumptionContext(pResumptionContext);
                    Status = pResumptionContext->SmbCeResumptionContext.Status;
                    if (Status != STATUS_SUCCESS) {
                        RxDbgTrace(0,Dbg,("SmbCeTransact: Transaction Request Completion Status %lx\n",Status));
                    }
                } else if (Status != STATUS_SUCCESS) {
                    RxDbgTrace(0,Dbg,("SmbCeTransact: SmbCeSubmitTransactRequest returned %lx\n",Status));
                } else {
                    Status = pResumptionContext->SmbCeResumptionContext.Status;
                }
            }
        }
    }

    ASSERT(fAsynchronous || (Status != STATUS_PENDING));

    if (fAsynchronous && (Status != STATUS_PENDING)) {
        pResumptionContext->SmbCeResumptionContext.Status = Status;
        pResumptionContext->FinalStatusFromServer = Status;
        SmbCeResume(&pResumptionContext->SmbCeResumptionContext);
        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
SmbTransactBuildHeader(
    PSMB_TRANSACT_EXCHANGE  pTransactExchange,
    UCHAR                   SmbCommand,
    PSMB_HEADER             pHeader)
/*++

Routine Description:

    This routine builds the SMB header for transact exchanges

Arguments:

    pTransactExchange  - the exchange instance

    SmbCommand - the SMB command

    pHeader    - the SMB buffer header

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;
    ULONG    BufferConsumed;

    UCHAR    LastCommandInHeader;
    PUCHAR   pCommand;

    PAGED_CODE();

    // Initialize the SMB header  ...
    Status = SmbCeBuildSmbHeader(
                 (PSMB_EXCHANGE)pTransactExchange,
                 pHeader,
                 sizeof(SMB_HEADER),
                 &BufferConsumed,
                 &LastCommandInHeader,
                 &pCommand);

    if (Status == STATUS_SUCCESS) {
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);
        *pCommand = SmbCommand;

        pServerEntry = SmbCeGetExchangeServerEntry(pTransactExchange);

        if (FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
            // for NT servers, we have to set the pid/pidhigh fields so that RPC will work. unless this is a
            // mailslot write.
            if (!(pTransactExchange->Flags & SMB_XACT_FLAGS_MAILSLOT_OPERATION)) {
                SmbCeSetFullProcessIdInHeader(
                    (PSMB_EXCHANGE)pTransactExchange,
                    RxGetRequestorProcessId(pTransactExchange->RxContext),
                    ((PNT_SMB_HEADER)pHeader));
            }
        }

        if (pTransactExchange->Flags & SMB_XACT_FLAGS_MAILSLOT_OPERATION) {
            pHeader->Flags2 &= ~(SMB_FLAGS2_NT_STATUS);
        }

        if (pTransactExchange->Flags & SMB_XACT_FLAGS_DFS_AWARE) {
            pHeader->Flags2 |= SMB_FLAGS2_DFS;
        }
    }

    return Status;
}


NTSTATUS
SmbTransactExchangeStart(
      PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for transact exchanges. This initiates the construction of the
    appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_TRANSACT_EXCHANGE pTransactExchange;
    PVOID                  pActualPrimaryRequestSmbHeader;
    PSMB_HEADER            pPrimaryRequestSmbHeader;

    // The MDL's used in sending the primary request associated with the TRANSACT SMB
    PMDL  pPartialDataMdl       = NULL;
    PMDL  pPartialParamMdl      = NULL;
    PMDL  pPaddingMdl           = NULL;
    PMDL  pPrimaryRequestSmbMdl = NULL;
    PMDL  pLastMdlInChain       = NULL;

    ULONG   MaximumSmbBufferSize;
    ULONG   PrimaryRequestSmbSize = 0;
    ULONG   PaddingLength = 0;
    BOOLEAN QuadwordAlignmentRequired = FALSE;

    ULONG ParamBytesToBeSent = 0;
    ULONG DataBytesToBeSent = 0;

    ULONG ParamOffset,DataOffset;
    ULONG SmbLength;
    ULONG BccOffset;
    ULONG MdlLength;

    USHORT *pBcc;

    PAGED_CODE();

    pTransactExchange        = (PSMB_TRANSACT_EXCHANGE)pExchange;

    pActualPrimaryRequestSmbHeader = pTransactExchange->pActualPrimaryRequestSmbHeader;
    pPrimaryRequestSmbHeader = pTransactExchange->pPrimaryRequestSmbHeader;

    ASSERT(pActualPrimaryRequestSmbHeader != NULL);
    ASSERT(pPrimaryRequestSmbHeader != NULL);

    ASSERT(!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) &&
           !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR));

    // Initialize the SMB header  ...
    Status = SmbTransactBuildHeader(
                 pTransactExchange,
                 pTransactExchange->TransactSmbCommand,
                 pPrimaryRequestSmbHeader);

    if ((Status != RX_MAP_STATUS(SUCCESS))) {
        // Finalize the exchange.
        pExchange->Status = Status;
        return Status;
    }

    PrimaryRequestSmbSize = sizeof(SMB_HEADER);

    // Compute the BccOffset and the ParamOffset which is in turn used in computing the
    // param and data bytes to be sent as part of the primary request.
    switch (pTransactExchange->TransactSmbCommand) {
    case SMB_COM_TRANSACTION:
    case SMB_COM_TRANSACTION2:
        {
            PREQ_TRANSACTION pTransactRequest = (PREQ_TRANSACTION)
                                             (pPrimaryRequestSmbHeader + 1);
            USHORT SetupLength = pTransactRequest->SetupCount * sizeof(WORD);

            BccOffset = sizeof(SMB_HEADER) +
                        FIELD_OFFSET(REQ_TRANSACTION,Buffer) +
                        SetupLength;

            ParamOffset = ROUND_UP_COUNT(
                              (BccOffset +
                              pTransactExchange->TransactionNameLength +
                              sizeof(USHORT)),
                              ALIGN_DWORD);

            pBcc = (PUSHORT)((PBYTE)pPrimaryRequestSmbHeader + BccOffset);
        }
        break;

    case SMB_COM_NT_TRANSACT:
        {
            PREQ_NT_TRANSACTION pNtTransactRequest = (PREQ_NT_TRANSACTION)
                                                  (pPrimaryRequestSmbHeader + 1);
            USHORT SetupLength = pNtTransactRequest->SetupCount * sizeof(WORD);

            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeSTAAT1: init for NT_T (p,d,mp,md) %d %d %d %d\n",
                         pNtTransactRequest->TotalParameterCount, pNtTransactRequest->TotalDataCount,
                         pNtTransactRequest->MaxParameterCount, pNtTransactRequest->MaxDataCount));
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeSTAyuk: init for NT_T (s,ms) %d %d \n",
                         pNtTransactRequest->SetupCount,  pNtTransactRequest->MaxSetupCount));


            BccOffset = sizeof(SMB_HEADER) +
                        FIELD_OFFSET(REQ_NT_TRANSACTION,Buffer[0]) +
                        SetupLength;

            ParamOffset = ROUND_UP_COUNT(
                              (BccOffset + sizeof(USHORT)),
                              ALIGN_DWORD);

            pBcc = (PUSHORT)((PBYTE)pPrimaryRequestSmbHeader + BccOffset);

            if (pTransactExchange->NtTransactFunction == NT_TRANSACT_SET_QUOTA) {
                QuadwordAlignmentRequired = TRUE;
            }
       }
       break;

    default:
        ASSERT(!"Valid Smb Command for initiating Transaction");
        return STATUS_INVALID_PARAMETER;
    }

    // Compute the data/param bytes that can be sent as part of the primary request
    MaximumSmbBufferSize = pTransactExchange->MaximumTransmitSmbBufferSize;

    ParamBytesToBeSent = MIN(
                             (MaximumSmbBufferSize - ParamOffset),
                             pTransactExchange->SendParamBufferSize);
    if (!QuadwordAlignmentRequired) {
        DataOffset = ROUND_UP_COUNT(ParamOffset + ParamBytesToBeSent, ALIGN_DWORD);
    } else {
        DataOffset = ROUND_UP_COUNT(ParamOffset + ParamBytesToBeSent, ALIGN_QUAD);
    }

    if (DataOffset < MaximumSmbBufferSize) {
        DataBytesToBeSent = MIN((MaximumSmbBufferSize - DataOffset),
                                pTransactExchange->SendDataBufferSize);
        PaddingLength = DataOffset - (ParamOffset + ParamBytesToBeSent);
    } else {
        DataBytesToBeSent = 0;
    }

    if ( DataBytesToBeSent == 0) {
        DataOffset = PaddingLength = 0;
    }

    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: params,padding,data=%d,%d,%d\n",
                           ParamBytesToBeSent,PaddingLength,DataBytesToBeSent  ));
    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: paramsoffset,dataoffset=%d,%d\n",
                           ParamOffset,DataOffset  ));
    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: phdr,pbcc=%08lx,%08lx\n",
                           pPrimaryRequestSmbHeader,pBcc  ));

    // Update the primary request buffer with the final sizes of the data/parameter etc.
    switch (pTransactExchange->TransactSmbCommand) {
    case SMB_COM_TRANSACTION:
    case SMB_COM_TRANSACTION2:
        {
            PREQ_TRANSACTION pTransactRequest = (PREQ_TRANSACTION)
                                             (pPrimaryRequestSmbHeader + 1);

            RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: TRANSACTION/TRANSACTION2\n"));

            SmbPutUshort( &pTransactRequest->ParameterCount, (USHORT)ParamBytesToBeSent );
            SmbPutUshort( &pTransactRequest->ParameterOffset, (USHORT)ParamOffset);
            SmbPutUshort( &pTransactRequest->DataCount, (USHORT)DataBytesToBeSent);
            SmbPutUshort( &pTransactRequest->DataOffset, (USHORT)DataOffset);
        }
        break;

   case SMB_COM_NT_TRANSACT:
        {
            PREQ_NT_TRANSACTION pNtTransactRequest = (PREQ_NT_TRANSACTION)
                                                  (pPrimaryRequestSmbHeader + 1);

            RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: NT transacton\n"));
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeSTAAT2: init for NT_T (p,d,mp,md) %d %d %d %d\n",
                         pNtTransactRequest->TotalParameterCount, pNtTransactRequest->TotalDataCount,
                         pNtTransactRequest->MaxParameterCount, pNtTransactRequest->MaxDataCount));


            SmbPutUlong( &pNtTransactRequest->ParameterCount, ParamBytesToBeSent);
            SmbPutUlong( &pNtTransactRequest->ParameterOffset, ParamOffset);
            SmbPutUlong( &pNtTransactRequest->DataCount, DataBytesToBeSent);
            SmbPutUlong( &pNtTransactRequest->DataOffset, DataOffset);
        }
        break;

    default:
        ASSERT(!"Valid Smb Command for initiating Transaction");
        return STATUS_INVALID_PARAMETER;
    }

    // Update the Bcc field in the SMB and compute the SMB length
    SmbPutUshort(
        pBcc,
        (USHORT)((ParamOffset - BccOffset - sizeof(USHORT)) +
                 ParamBytesToBeSent +
                 PaddingLength +
                 DataBytesToBeSent)
        );

    SmbLength = ParamOffset +
                ParamBytesToBeSent +
                PaddingLength +
                DataBytesToBeSent;

    // The primary request buffer should be locked down for transmission. In order to
    // preclude race conditions while freeing this routine assumes ownership of the buffer.
    // There are two reasons why this model has to be adopted ...
    // 1) Inititaiting a transaction request can possibly involve a reconnection attempt
    // which will involve network traffic. Consequently the transmission of the primary
    // request can potentially occur in a worker thread which is different from the one
    // initializing the exchange. This problem can be worked around by carrying all the
    // possible context around and actually constructing the header as part of this routine.
    // But this would imply that those requests which could have been filtered out easily
    // because of error conditions etc. will be handled very late.

    pTransactExchange->pActualPrimaryRequestSmbHeader = NULL;
    pTransactExchange->pPrimaryRequestSmbHeader = NULL;

    // Ensure that the MDL's have been probed & locked. The new MDL's have been allocated.
    // The partial MDL's are allocated to be large enough to span the maximum buffer
    // length possible.

    MdlLength = ParamOffset;
    if (pTransactExchange->fParamsSubsumedInPrimaryRequest) {
        MdlLength += ParamBytesToBeSent + PaddingLength;
    }

    RxAllocateHeaderMdl(
        pPrimaryRequestSmbHeader,
        MdlLength,
        pPrimaryRequestSmbMdl
        );

    if (pPrimaryRequestSmbMdl != NULL) {
        Status = STATUS_SUCCESS;
    } else {
        RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: Insuffcient resources for MDL's\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((DataBytesToBeSent > 0) &&
       (Status == RX_MAP_STATUS(SUCCESS))) {
        pPartialDataMdl = RxAllocateMdl(
                              0,
                              (MIN(pTransactExchange->SendDataBufferSize,MaximumSmbBufferSize) +
                               PAGE_SIZE - 1)
                              );

        if (pPartialDataMdl != NULL) {
            Status = STATUS_SUCCESS;
        } else {
            RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: Insuffcient resources for MDL's\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if ((ParamBytesToBeSent > 0) &&
        !pTransactExchange->fParamsSubsumedInPrimaryRequest &&
        (Status == RX_MAP_STATUS(SUCCESS))) {

        pPartialParamMdl = RxAllocateMdl(
                               pTransactExchange->pSendParamBuffer,
                               ParamBytesToBeSent);

        if (PaddingLength!= 0) {
            pPaddingMdl = RxAllocateMdl(0,(sizeof(DWORD) + PAGE_SIZE - 1));
        } else {
            pPaddingMdl = NULL;
        }

        if ((pPartialParamMdl != NULL) &&
            ((pPaddingMdl != NULL)||(PaddingLength==0))) {
            Status = STATUS_SUCCESS;
        } else {
            RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: no param/pad MDLs %08lx %08lx\n",
               pPartialParamMdl,pPaddingMdl));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // At this point the validity of all the parameters will have been ascertained. The trivial
    // cases have been filtered out. Start the transact exchange.

    // Implementation Note: The Transact exchange implementation relies upon chaining the
    // MDL's together to build the relevant request buffers that need be sent. This ensures
    // that redundant copying of data is avoided altogether. Depending upon the parameters
    // specified the composite MDL that is sent is composed of the following MDL's.
    // TRANSACT2 and NT TRANSACT exchanges ...
    //          The composite buffer is made up off atmost four MDL's that are chained together. These
    //           are the header buffer, the setup buffer, parameter buffer and the data buffer.
    //          All the secondary requests are made up off atmost three MDL's that are chained together.
    //          These are the header buffer, the parameter buffer and the data buffer.
    // TRANSACT exchanges ....
    //          The composite buffer is made up off atmost three MDL's that are chained together. These are
    //          the header buffer ( includes the name and the setup information) , the parameter buffer
    //          and the data buffer.
    // All the secondary requests are made up off atmost three MDL's that are chained together.
    // These are the header buffer, the parameter buffer and the data buffer.
    // In all of these cases the number of MDL's can go up by 1 if a padding MDL is required
    // between the parameter buffer and the data buffer to ensure that all alignment requirements
    // are satisfied.

    if ((Status == RX_MAP_STATUS(SUCCESS))) {

        RxProbeAndLockHeaderPages(pPrimaryRequestSmbMdl,KernelMode,IoModifyAccess,Status);
        if ((Status != RX_MAP_STATUS(SUCCESS))) {  //do this now. the code below will try to unlock
            IoFreeMdl(pPrimaryRequestSmbMdl);
            pPrimaryRequestSmbMdl = NULL;
        } else {
            if (MmGetSystemAddressForMdlSafe(pPrimaryRequestSmbMdl,LowPagePriority) == NULL) { //map it
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if ((Status == RX_MAP_STATUS(SUCCESS))) {
        pLastMdlInChain = pPrimaryRequestSmbMdl;

        if (ParamBytesToBeSent > 0) {
            RxDbgTrace(
                0,
                Dbg,
                ("SmbCeTransactExchangeStart: Sending Param bytes %ld at offset %ld\n",
                 ParamBytesToBeSent,
                 ParamOffset)
                );
            pTransactExchange->ParamBytesSent = ParamBytesToBeSent;

            if (!pTransactExchange->fParamsSubsumedInPrimaryRequest) {
                IoBuildPartialMdl(
                    pTransactExchange->pSendParamMdl,
                    pPartialParamMdl,
                    (PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pSendParamMdl),
                    ParamBytesToBeSent);

                // Chain the MDL's together
                pLastMdlInChain->Next = pPartialParamMdl;
                pLastMdlInChain       = pPartialParamMdl;
            }
        }

        // Link the data buffer or portions of it if the size constraints are satisfied
        // If padding is required between the parameter and data portions in the
        // primary request include the padding MDL, otherwise chain the data MDL
        // directly.
        if (DataBytesToBeSent > 0) {
            if (!pTransactExchange->fParamsSubsumedInPrimaryRequest &&
                (PaddingLength > 0)) {
                RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: Padding Length %ld\n",PaddingLength));

                RxBuildPaddingPartialMdl(pPaddingMdl,PaddingLength);
                pLastMdlInChain->Next = pPaddingMdl;
                pLastMdlInChain = pPaddingMdl;
            }

            RxDbgTrace( 0, Dbg,("SmbCeTransactExchangeStart: Sending Data bytes %ld at offset %ld\n",
                 DataBytesToBeSent, DataOffset) );

            pTransactExchange->DataBytesSent = DataBytesToBeSent;

            IoBuildPartialMdl(
                pTransactExchange->pSendDataMdl,
                pPartialDataMdl,
                (PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pSendDataMdl),
                DataBytesToBeSent);

            pLastMdlInChain->Next = pPartialDataMdl;
            pLastMdlInChain       = pPartialDataMdl;
        }

        if ((Status == RX_MAP_STATUS(SUCCESS))) {

            if (FlagOn(pTransactExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
                pTransactExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
                pTransactExchange->Mid        = SMBCE_MAILSLOT_OPERATION_MID;
            }

            // There are cases in which the transaction exchange can be completed by merely sending
            // the primary request SMB. This should be distinguished from those cases in which either
            // a response is expected or a number of secondary requests need to be issued based upon
            // the parameter buffer length, data buffer length and the flags specified.
            if ((pTransactExchange->Flags & SMB_TRANSACTION_NO_RESPONSE ) &&
                (pTransactExchange->SendDataBufferSize == DataBytesToBeSent) &&
                (pTransactExchange->SendParamBufferSize == ParamBytesToBeSent)) {
                // No response is expected in this case. Therefore Send should suffice instead of
                // Tranceive

                // since we don't expect to do any more here, set the exchange status to success
                pExchange->Status = STATUS_SUCCESS;
                pTransactExchange->pResumptionContext->FinalStatusFromServer = STATUS_SUCCESS;

                RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: SmbCeSend(No Response expected)\n"));
                Status = SmbCeSend(
                             pExchange,
                             RXCE_SEND_SYNCHRONOUS,
                             pPrimaryRequestSmbMdl,
                             SmbLength);

                if ((Status != RX_MAP_STATUS(SUCCESS))) {
                    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: SmbCeSend returned %lx\n",Status));
                }
            } else {
                // This transaction involves ttansmit/receive of multiple SMB's. A tranceive is in
                // order.

                if ((pTransactExchange->SendDataBufferSize == DataBytesToBeSent) &&
                    (pTransactExchange->SendParamBufferSize == ParamBytesToBeSent)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: No Secondary Requests\n"));
                    pTransactExchange->State = TRANSACT_EXCHANGE_TRANSMITTED_SECONDARY_REQUESTS;
                } else {
                    pTransactExchange->State = TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST;
                }

                RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: SmbCeTranceive(Response expected)\n"));
                //CODE.IMPROVEMENT send.sync????.........yeeeeech.
                Status = SmbCeTranceive(
                             pExchange,
                             RXCE_SEND_SYNCHRONOUS,
                             pPrimaryRequestSmbMdl,
                             SmbLength);

                if ((Status != RX_MAP_STATUS(SUCCESS))) {
                    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: SmbCeTranceive returned %lx\n",Status));
                }
            }
        }
    }

    if (pPartialParamMdl != NULL) {
        IoFreeMdl(pPartialParamMdl);
    }

    if (pPartialDataMdl != NULL) {
        IoFreeMdl(pPartialDataMdl);
    }

    if (pPaddingMdl != NULL) {
        IoFreeMdl(pPaddingMdl);
    }

    if (pPrimaryRequestSmbMdl != NULL) {
        if (RxMdlIsLocked(pPrimaryRequestSmbMdl))
        {
            RxUnlockHeaderPages(pPrimaryRequestSmbMdl);
        }
        IoFreeMdl(pPrimaryRequestSmbMdl);
    }

    RxFreePool(pActualPrimaryRequestSmbHeader);

    if (Status != STATUS_PENDING) {
        pExchange->Status = Status;
    }

    return Status;
}

NTSTATUS
SmbTransactExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG          BytesIndicated,
    IN ULONG          BytesAvailable,
    OUT ULONG        *pBytesTaken,
    IN  PSMB_HEADER   pSmbHeader,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG        pDataSize,
    IN ULONG          ReceiveFlags)
/*++

Routine Description:

    This is the recieve indication handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS Status;
    PNTSTATUS pFinalSmbStatus;

    BOOLEAN fError = FALSE;
    BOOLEAN fIndicationNotSufficient = FALSE;
    BOOLEAN fMoreParsingRequired     = FALSE;
    BOOLEAN fDoErrorProcessing       = FALSE; //this is a hack CODE.IMPROVEMENT

    SMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format;

    GENERIC_ANDX  CommandToProcess;

    ULONG TransactResponseSize       = 0;
    ULONG SetupBytesOffsetInResponse = 0;
    ULONG SetupBytesInResponse       = 0;
    ULONG CopyDataSize               = 0;

    PMDL  pSetupMdl       = NULL;
    PMDL  pCopyRequestMdl = NULL;

    PSMB_TRANSACT_EXCHANGE pTransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

    RxDbgTrace( 0, Dbg,
               ("SmbTransactExchangeReceive: Entering w/ Bytes Available (%ld) Bytes Indicated (%ld) State (%ld)\n",
                BytesAvailable,
                BytesIndicated,
                pTransactExchange->State
               ));
    RxDbgTrace( 0, Dbg,
               ("SmbTransactExchangeReceive: Buffer %08lx Consumed (%ld) MDL (%08lx)\n",
                pSmbHeader,
                *pBytesTaken,
                *pDataBufferPointer
               ));

    pFinalSmbStatus = &pTransactExchange->SmbStatus;
    Status = SmbCeParseSmbHeader(
                 pExchange,
                 pSmbHeader,
                 &CommandToProcess,
                 pFinalSmbStatus,
                 BytesAvailable,
                 BytesIndicated,
                 pBytesTaken);

    if (Status != STATUS_SUCCESS) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    //this need some explanation. parseheader is written so as to take some extra smbs off the from
    //of the packet...specifically, stuff like sessionsetup&X and TC&X. since no transact is a valid followon
    //it would not make since if (a) not enough were indicated or (b) an early command had an error. so
    //we must have success. CODE.REVIEW.JOELINN you should look in parseheader and (1) remove the *taken=avail and
    //(b) look for asserts that the server sends stuff back correctly. these must be changed into BAD_RESPONSE_AND_DISCARDs
    //the "Status = STATUS_SUCCESS" is to try to get the compiler to optimize.

    if (*((PBYTE)(pSmbHeader+1)) == 0 && (pTransactExchange->State!=TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST)) {
        RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: FinalSmbStatus = %lx\n", *pFinalSmbStatus));

        if (NT_SUCCESS(*pFinalSmbStatus)) {
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            goto FINALLY;
        }
    }

    //we know that status is SUCCESS from the assert above. but we will still continue to check so as
    //to be more resilient when we don't have msg boundaries. we have the following cases depending on the
    //characteristics of the smbresponse
    //
    //   non-error:   get the data and then return the stored responsestatus. the process of getting the data
    //                causes us to update the param and data counts so that we know when we have reached the
    //                end of the data. the parse routine re-ups the receive if needed.
    //   error:       there are main cases:
    //                    a) the server has sent no data. here we discard the packet and we can just get out. the
    //                       finalize routine will pickup the status correctly.
    //                    b) here, we have to discard the packet AND update the byte counts AND re-up the receive
    //                       if necessary. to discard the packet, we must either compute the apparent msg length from
    //                       the WC and BC parameters (best) OR use our maximum buffer size

    fMoreParsingRequired = FALSE;

    if ((Status == RX_MAP_STATUS(SUCCESS))) {
        if (TRUE) { //maybe sometimes we wont copy!
            if (CommandToProcess.WordCount > 0) {
                ULONG TransactResponseSize = 0;

                // Ensure that at the very least enough bytes have been indicated to determine
                // the length of the setup, parameters and data for the transaction.

                //CODE.IMPROVEMENT.ASHAMED this is very clumsy....we should have computed this earlier.
                // and saved it in the exchange. at a minimum move it to the validateformat routine
                switch (CommandToProcess.AndXCommand) {
                case SMB_COM_NT_TRANSACT:
                case SMB_COM_NT_TRANSACT_SECONDARY:
                    TransactResponseSize = FIELD_OFFSET(RESP_NT_TRANSACTION,Buffer);
                    break;

                case SMB_COM_TRANSACTION:
                case SMB_COM_TRANSACTION2:
                case SMB_COM_TRANSACTION_SECONDARY:
                case SMB_COM_TRANSACTION2_SECONDARY:
                    TransactResponseSize = FIELD_OFFSET(RESP_TRANSACTION,Buffer);
                    break;

                default:
                    TransactResponseSize = 0xffffffff;
                    Status = RX_MAP_STATUS(INVALID_NETWORK_RESPONSE);
                    break;
                }

                if (BytesIndicated >= (sizeof(SMB_HEADER) + TransactResponseSize)) {
                    fMoreParsingRequired = TRUE;
                } else {
                    fIndicationNotSufficient = TRUE;
                    *pFinalSmbStatus = STATUS_INVALID_NETWORK_RESPONSE;
                }
            } else {
                // allow a response with wordcount==0 to go thru if we're the right state
                fMoreParsingRequired = (pTransactExchange->State==TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST);
            }
        }
    }

    if (fMoreParsingRequired) {
        // The header was successfully parsed and the SMB response did not contain any errors
        // The stage is set for processing the transaction response.

        switch (pTransactExchange->State) {
        case TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST:
            {
                // The primary request for the transaction has been sent and there are
                // secondary requests to be sent.
                // The only response expected at this time is an interim response. Any
                // other response will be treated as an error.
                PRESP_TRANSACTION_INTERIM pInterimResponse;

                RxDbgTrace(0,Dbg,("SmbCeTransactExchangeReceive: Processing interim response\n"));

                if ((*pBytesTaken + FIELD_OFFSET(RESP_TRANSACTION_INTERIM,Buffer)) <= BytesIndicated) {
                    pInterimResponse = (PRESP_TRANSACTION_INTERIM)((PBYTE)pSmbHeader + *pBytesTaken);
                    if ((NT_SUCCESS(pExchange->SmbStatus)) &&
                        (pSmbHeader->Command == pTransactExchange->TransactSmbCommand) &&
                        (SmbGetUshort(&pInterimResponse->WordCount) == 0) &&
                        (SmbGetUshort(&pInterimResponse->ByteCount) == 0)) {

                        // The interim response was valid. Transition the state of the exchange
                        // and transmit the secondary requests.
                        *pBytesTaken += FIELD_OFFSET(RESP_TRANSACTION_INTERIM,Buffer);
                        //CODE.IMPROVEMENT that only works if the server doesn't send extra crap
                        pTransactExchange->State = TRANSACT_EXCHANGE_RECEIVED_INTERIM_RESPONSE;

                        // Determine if any secondary transaction requests need to be sent. if none are
                        // required then modify the state
                        ASSERT((pTransactExchange->ParamBytesSent < pTransactExchange->SendParamBufferSize) ||
                               (pTransactExchange->DataBytesSent < pTransactExchange->SendDataBufferSize));
                        ASSERT((pTransactExchange->ParamBytesSent <= pTransactExchange->SendParamBufferSize) &&
                               (pTransactExchange->DataBytesSent <= pTransactExchange->SendDataBufferSize));

                        if (!(pTransactExchange->Flags & SMB_TRANSACTION_NO_RESPONSE )) {
                            Status = SmbCeReceive(pExchange);
                        }

                        if ((Status != RX_MAP_STATUS(SUCCESS))) {
                            pExchange->Status = Status;
                        } else {
                            Status = STATUS_SUCCESS;
                            SmbCeIncrementPendingLocalOperations(pExchange);
                            RxPostToWorkerThread(
                                MRxSmbDeviceObject,
                                CriticalWorkQueue,
                                &pExchange->WorkQueueItem,
                                SendSecondaryRequests,
                                pExchange);
                        }
                    } else if( !NT_SUCCESS(pExchange->SmbStatus) ) {
                        RxDbgTrace(0,Dbg,("SmbCeTransactExchangeReceive: Error on Response\n"));
                        Status = pExchange->SmbStatus;
                    } else {
                        RxDbgTrace(0,Dbg,("SmbCeTransactExchangeReceive: Invalid interim response\n"));
                        Status = STATUS_INVALID_NETWORK_RESPONSE;
                    }
                } else {
                    fIndicationNotSufficient = TRUE;
                    Status = RX_MAP_STATUS(MORE_PROCESSING_REQUIRED);
                }
            }
            break;

        case TRANSACT_EXCHANGE_RECEIVED_INTERIM_RESPONSE:
            RxDbgTrace(0,Dbg,("SmbCeTransactExchangeReceive: received again while in interim response\n"));
          //no break: this is okay
        case TRANSACT_EXCHANGE_TRANSMITTED_SECONDARY_REQUESTS:
        case TRANSACT_EXCHANGE_RECEIVED_PRIMARY_RESPONSE:
            {
                BOOLEAN fPrimaryResponse = FALSE;
                PRESP_TRANSACTION    pTransactResponse;
                PRESP_NT_TRANSACTION pNtTransactResponse;
                ULONG TotalParamBytesInResponse;
                ULONG TotalDataBytesInResponse;

                RxDbgTrace(0,Dbg,("SmbCeTransactExchangeReceive: Processing Primary/Secondary response\n"));

                //do this here so there's only one copy if the code
                pTransactResponse = (PRESP_TRANSACTION)((PBYTE)pSmbHeader +
                                              SmbGetUshort(&CommandToProcess.AndXOffset));

                // All the requests ( both primary and secondary have been sent ). The
                // only responses expected in this state are (1) a primary response and (2) a
                // secondary response. Any other response is an error.
                if (pSmbHeader->Command == pTransactExchange->TransactSmbCommand) {
                    switch (pSmbHeader->Command) {
                    case SMB_COM_TRANSACTION:
                    case SMB_COM_TRANSACTION2:
                        //pTransactResponse = (PRESP_TRANSACTION)((PBYTE)pSmbHeader +
                        //                                        SmbGetUshort(&CommandToProcess.AndXOffset));
                        fPrimaryResponse = TRUE;
                        SetupBytesOffsetInResponse = FIELD_OFFSET(RESP_TRANSACTION,Buffer);
                        SetupBytesInResponse = sizeof(USHORT) * pTransactResponse->SetupCount;

                        // Initialize the total count of data and param bytes that will be received from
                        // the server during the course ofthe transaction response.
                        TotalParamBytesInResponse = SmbGetUshort(&pTransactResponse->TotalParameterCount);
                        TotalDataBytesInResponse  = SmbGetUshort(&pTransactResponse->TotalDataCount);

                    // fall through
                    case SMB_COM_TRANSACTION_SECONDARY:
                    case SMB_COM_TRANSACTION2_SECONDARY:
                        TransactResponseSize = FIELD_OFFSET(RESP_TRANSACTION,Buffer);
                        break;
                    case SMB_COM_NT_TRANSACT:
                        //pNtTransactResponse = (PRESP_NT_TRANSACTION)((PBYTE)pSmbHeader +
                        //                                        SmbGetUshort(&CommandToProcess.AndXOffset));
                        pNtTransactResponse = (PRESP_NT_TRANSACTION)pTransactResponse;
                        fPrimaryResponse = TRUE;
                        SetupBytesOffsetInResponse = FIELD_OFFSET(RESP_NT_TRANSACTION,Buffer);
                        SetupBytesInResponse = sizeof(USHORT) * pNtTransactResponse->SetupCount;

                        // Initialize the total count of data and param bytes that will be received from
                        // the server during the course ofthe transaction response.
                        TotalParamBytesInResponse = SmbGetUshort(&pNtTransactResponse->TotalParameterCount);
                        TotalDataBytesInResponse  = SmbGetUshort(&pNtTransactResponse->TotalDataCount);

                        // fall through ..
                    case SMB_COM_NT_TRANSACT_SECONDARY:
                        TransactResponseSize = FIELD_OFFSET(RESP_NT_TRANSACTION,Buffer);
                        break;

                    default:
                        // Abort the exchange. An unexpected response was received during the
                        // course of the transaction.
                        ASSERT(!"Valid network response");
                        Status = STATUS_INVALID_NETWORK_RESPONSE;
                    }

                    if ((Status == RX_MAP_STATUS(SUCCESS))) {
                        if (fPrimaryResponse) {
                            RxDbgTrace( 0,
                                 Dbg,
                                 ("SmbTransactExchangeReceive: Primary Response Setup Bytes(%ld) Param Bytes (%ld) Data Bytes (%ld)\n",
                                  SetupBytesInResponse,
                                  TotalParamBytesInResponse,
                                  TotalDataBytesInResponse
                                 )
                               );

                            if ((TotalParamBytesInResponse > pTransactExchange->ReceiveParamBufferSize) ||
                                (TotalDataBytesInResponse > pTransactExchange->ReceiveDataBufferSize)) {
                                Status = STATUS_INVALID_NETWORK_RESPONSE;
                                goto FINALLY;
                            } else {
                                pTransactExchange->ReceiveParamBufferSize = TotalParamBytesInResponse;
                                pTransactExchange->ReceiveDataBufferSize  = TotalDataBytesInResponse;
                            }
                        }

                        if (Status == STATUS_SUCCESS &&
                            TransactResponseSize + *pBytesTaken <= BytesIndicated) {
                            if (fPrimaryResponse &&
                                (SetupBytesInResponse > 0)) {

                                PBYTE pSetupStartAddress;
                                ULONG SetupBytesIndicated = MIN(SetupBytesInResponse,
                                                            BytesIndicated - SetupBytesOffsetInResponse);

                                if( pTransactExchange->pReceiveSetupMdl ) {
                                    pSetupStartAddress = (PBYTE)MmGetSystemAddressForMdlSafe(
                                                                pTransactExchange->pReceiveSetupMdl,
                                                                LowPagePriority
                                                                );

                                    if( pSetupStartAddress == NULL ) {
                                        Status = STATUS_INSUFFICIENT_RESOURCES;
                                    } else {
                                        if (SetupBytesInResponse == SetupBytesIndicated) {
                                            RtlCopyMemory(
                                                pSetupStartAddress,
                                                ((PBYTE)pSmbHeader + SetupBytesOffsetInResponse),
                                                SetupBytesIndicated);

                                            pSetupStartAddress += SetupBytesIndicated;
                                            SetupBytesInResponse -= SetupBytesIndicated;
                                            SetupBytesOffsetInResponse += SetupBytesIndicated;
                                            pTransactExchange->SetupBytesReceived = SetupBytesInResponse;
                                        } else {
                                            // NTRAID-87018-2/10/2000 yunlin we do a indication_not_sufficient
                                            ASSERT(!"this code doesn't work");
                                            RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Setup Bytes Partially Indicated\n"));
                                            // Some setup bytes have not been indicated. An MDL needs to be
                                            // created for copying the data. This MDL should also include the padding
                                            // MDL for copying the padding bytes ...
                                            pSetupMdl = RxAllocateMdl(pSetupStartAddress,SetupBytesInResponse);

                                            if ( pSetupMdl != NULL ) {
                                                IoBuildPartialMdl(
                                                     pTransactExchange->pReceiveSetupMdl,
                                                     pSetupMdl,
                                                     pSetupStartAddress,
                                                     SetupBytesInResponse);
                                            } else {
                                                Status = STATUS_INSUFFICIENT_RESOURCES;
                                            }
                                        }
                                    }
                                }

                                RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Setup Bytes Indicated (%ld)\n",SetupBytesIndicated));
                            }

                            if (Status == STATUS_SUCCESS) {
                                // from here, we cannot go back and redo the header....so we have to change state so
                                //that the copy routine doesn't try to reparse
                                pTransactExchange->State = TRANSACT_EXCHANGE_RECEIVED_PRIMARY_RESPONSE;

                                Status = SmbTransactAccrueAndValidateFormatData(
                                             pTransactExchange,
                                             pSmbHeader,
                                             BytesIndicated,
                                             &Format);

                                if (Status != STATUS_SUCCESS) {
                                    goto FINALLY;
                                }

                                Status = ParseTransactResponse(
                                             pTransactExchange,&Format,
                                             BytesIndicated,
                                             BytesAvailable,
                                             pBytesTaken,
                                             pSmbHeader,
                                             &pCopyRequestMdl,
                                             &CopyDataSize);

                                if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                                    // Link the setup MDL with the MDL returned
                                    if (pSetupMdl != NULL) {
                                        if (pCopyRequestMdl != NULL) {
                                            pSetupMdl->Next = pCopyRequestMdl;
                                        }

                                        pCopyRequestMdl = pSetupMdl;
                                        CopyDataSize += SetupBytesInResponse;
                                    }
                                }

                                //check if the server has sent extra bytes.....
                                // ---------------------------------------------------------------------------------------------
                                {
                                    ULONG ApparentMsgLength = max(BytesAvailable,Format.ApparentMsgLength);
                                    ULONG DeficitBytes = ApparentMsgLength - (*pBytesTaken+CopyDataSize);

                                    if (ApparentMsgLength < *pBytesTaken+CopyDataSize) {
                                        Status = STATUS_INVALID_NETWORK_RESPONSE;
                                        goto FINALLY;
                                    }

                                    if (DeficitBytes > 0) {
                                        RxLog(("XtraBytes %lx %lx",pTransactExchange,DeficitBytes));
                                        SmbLog(LOG,
                                               SmbTransactExchangeReceive_1,
                                               LOGPTR(pTransactExchange)
                                               LOGULONG(DeficitBytes));

                                        if (CopyDataSize==0) {
                                            if (*pBytesTaken > BytesAvailable) {
                                                Status = STATUS_INVALID_NETWORK_RESPONSE;
                                                goto FINALLY;
                                            }

                                            RxLog(("Extra Bytes were sent and copydatasize==0........\n"));
                                            SmbLog(LOG,
                                                   SmbTransactExchangeReceive_2,
                                                   LOGULONG(CopyDataSize));
                                            *pBytesTaken = BytesAvailable; //cant take more than this
                                        } else {
                                            PMDL LastMdl,TrailingBytesMdl;

                                            if ( DeficitBytes > TRAILING_BYTES_BUFFERSIZE) {
                                                Status = STATUS_INVALID_NETWORK_RESPONSE;
                                                goto FINALLY;
                                            }

                                            TrailingBytesMdl = &pTransactExchange->TrailingBytesMdl;

                                            MmInitializeMdl(
                                                TrailingBytesMdl,
                                                &pTransactExchange->TrailingBytesBuffer.Bytes[0],
                                                DeficitBytes
                                                );
                                            MmBuildMdlForNonPagedPool(TrailingBytesMdl);
                                            LastMdl = pCopyRequestMdl;
                                            ASSERT(LastMdl != NULL);
                                            for (;LastMdl->Next!=NULL;LastMdl=LastMdl->Next) ;
                                            ASSERT(LastMdl != NULL);
                                            ASSERT(LastMdl->Next == NULL);
                                            LastMdl->Next = TrailingBytesMdl;
                                            CopyDataSize += DeficitBytes;
                                        }
                                    }
                                }
                                // ---------------------------------------------------------------------------------------------


                                RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: ParseTransactResponse returned %lx\n",Status));
                            }

                            *pDataBufferPointer = pCopyRequestMdl;
                            *pDataSize          = CopyDataSize;
                        } else {
                            RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Indication not sufficient: trsz %08lx bytestakn %08lx \n",
                                         TransactResponseSize, *pBytesTaken));
                            fIndicationNotSufficient = TRUE;

                            if (Status == STATUS_SUCCESS) {
                                Status = STATUS_MORE_PROCESSING_REQUIRED;
                            }
                        }
                    }
                } else {
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                }
            }
            break;

        default:
            {
                ASSERT(!"Valid Transact Exchange State for receiving responses");
                RxDbgTrace( 0, Dbg, ("SmbTransactExchangeReceive: Aborting Exchange -- invalid state\n"));
            }
            break;
        }
    } else {
        // We get here if either the status or the smbstatus is not success.
        // If sufficient bytes were not indicated for processing the header a copy data request
        // needs to be posted. this occurs if status is status_more_processing_required
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeReceive: bad status(es) from parseheadr %08lx %08lx\n",
                            Status,*pFinalSmbStatus));
        fDoErrorProcessing       = TRUE;
    }

    if ((Status == RX_MAP_STATUS(SUCCESS)) &&
        (pTransactExchange->ParamBytesReceived == pTransactExchange->ReceiveParamBufferSize) &&
        (pTransactExchange->DataBytesReceived  == pTransactExchange->ReceiveDataBufferSize) &&
        (pTransactExchange->PendingCopyRequests == 0)) {

        NOTHING;

    } else if (fDoErrorProcessing) {
        BOOLEAN DoItTheShortWay = TRUE;
        ULONG ApparentMsgLength;
        RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Error processing response %lx .. Exchange aborted\n",Status));

        if (BytesAvailable > BytesIndicated ||
            !FlagOn(ReceiveFlags,TDI_RECEIVE_ENTIRE_MESSAGE)) {

            Status = SmbTransactAccrueAndValidateFormatData(
                         pTransactExchange,
                         pSmbHeader,
                         BytesIndicated,
                         &Format);

            if (Status != STATUS_SUCCESS) {
                goto FINALLY;
            }

            ApparentMsgLength = max(BytesAvailable,Format.ApparentMsgLength);

            //if wordcount!=0 then the server is sending us bytes.....we have to continue doing
            //receives until we have seen all the bytes
            if ((pTransactExchange->ParameterBytesSeen<Format.ParameterCount) ||
                (pTransactExchange->DataBytesSeen<Format.DataCount)) {
                NTSTATUS ReceiveStatus;

                // The exchange has been successfully completed. Finalize it.
                RxDbgTrace(0,Dbg,("ParseTransactResponse: Register for more error responses\n"));
                RxLog(("TxErr: %lx %lx %lx",pTransactExchange,
                       pTransactExchange->ParameterBytesSeen,pTransactExchange->DataBytesSeen));
                SmbLog(LOG,
                       SmbTransactExchangeReceive_3,
                       LOGPTR(pTransactExchange)
                       LOGULONG(pTransactExchange->ParameterBytesSeen)
                       LOGULONG(pTransactExchange->DataBytesSeen));
                ReceiveStatus = SmbCeReceive((PSMB_EXCHANGE)pTransactExchange);
                if (ReceiveStatus != STATUS_SUCCESS) {
                    // There was an error in registering the receive. Abandon the transaction.
                    Status = ReceiveStatus;
                    RxLog(("TxErrAbandon %lx",pTransactExchange));
                    SmbLog(LOG,
                           SmbTransactExchangeReceive_4,
                           LOGPTR(pTransactExchange)
                           LOGULONG(Status));
                    //Make it fail the next two tests.....
                    ApparentMsgLength = 0; DoItTheShortWay = FALSE; //CODE.IMPROVEMENT bad coding...use some escape
                }
            }

            //netbt will not allow us to discard the packet by setting taken=available. so, check for
            //available>indicated. if true, take the bytes by conjuring up a buffer

            if (ApparentMsgLength>BytesIndicated) {
                //we'll have to lay down a buffer for this so that NetBT won't blow the session away
                //CODE.IMPROVEMENT we should put this code into OE a well.......
                //CODE.IMPROVEMENT if we had an smbbuf (as suggested above) we could use that
                //                 to do the copy
                ASSERT(pTransactExchange->Status == STATUS_MORE_PROCESSING_REQUIRED);
                pTransactExchange->DiscardBuffer = RxAllocatePoolWithTag(
                                                       NonPagedPool,
                                                       ApparentMsgLength,
                                                       MRXSMB_XACT_POOLTAG);
                if (pTransactExchange->DiscardBuffer!=NULL) {
                    *pBytesTaken = 0;
                    *pDataSize = ApparentMsgLength;
                    *pDataBufferPointer = &pTransactExchange->TrailingBytesMdl;
                    MmInitializeMdl(*pDataBufferPointer,
                        pTransactExchange->DiscardBuffer,
                        ApparentMsgLength
                        );

                    MmBuildMdlForNonPagedPool(*pDataBufferPointer);
                    pTransactExchange->SaveTheRealStatus = Status;
                    RxLog(("XRtakebytes %lx %lx\n",pTransactExchange,Status));
                    SmbLog(LOG,
                           SmbTransactExchangeReceive_5,
                           LOGPTR(pTransactExchange)
                           LOGULONG(Status));
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                    DoItTheShortWay = FALSE;
                }
            }
        }

        if (DoItTheShortWay) {
            goto FINALLY;
        }
    }

    RxDbgTrace( 0, Dbg,
               ("SmbTransactExchangeReceiveExit: Bytes Consumed (%ld) Status (%08lx) MDL (%08lx) size(%08lx)\n",
                *pBytesTaken, Status, *pDataBufferPointer, *pDataSize
               ));

    if ((Status == STATUS_SUCCESS) ||
        (Status == STATUS_MORE_PROCESSING_REQUIRED)) {
        return Status;
    }

FINALLY:
    *pBytesTaken = BytesAvailable;
    *pDataBufferPointer = NULL;

    // Abort the exchange
    pTransactExchange->Status = Status;
    Status = STATUS_SUCCESS;

    RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Exchange aborted.\n",Status));

    return Status;

    UNREFERENCED_PARAMETER(ReceiveFlags);
}

NTSTATUS
SmbTransactExchangeAbort(
      PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the abort routine for transact exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    // The SMB exchange completed with an error. Invoke the RDBSS callback routine
    // and scavenge the exchange instance.

    pExchange->Status = STATUS_REQUEST_ABORTED;

    return STATUS_SUCCESS;
}

NTSTATUS
SmbTransactExchangeErrorHandler(
    IN PSMB_EXCHANGE pExchange)     // the SMB exchange instance
/*++

Routine Description:

    This is the error indication handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    // The SMB exchange completed with an error. Invoke the RDBSS callback routine
    // and scavenge the exchange instance.
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pExchange);
}

NTSTATUS
SmbTransactExchangeSendCallbackHandler(
    IN PSMB_EXCHANGE    pExchange,    // The exchange instance
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus)
/*++

Routine Description:

    This is the send call back indication handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(pExchange);
    UNREFERENCED_PARAMETER(pXmitBuffer);
    UNREFERENCED_PARAMETER(SendCompletionStatus);
}

NTSTATUS
SmbTransactExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,    // The exchange instance
    IN PMDL             pDataBuffer,  // the buffer
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

    pDataBuffer - the buffer

    DataSize    - the amount of data returned

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMB_TRANSACT_EXCHANGE pTransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

    PMDL  pCopyRequestMdl = NULL;
    PMDL  pCurMdl = NULL;
    ULONG CopyRequestSize = 0;
    PMDL TrailingBytesMdl = &pTransactExchange->TrailingBytesMdl;

    ULONG BytesConsumed;

    RxDbgTrace(+1,Dbg,("SmbTransactExchangeCopyDataHandler: Entered\n"));

    if (pTransactExchange->DiscardBuffer!=NULL) {
        //we just copied to get rid of the buffer....
        //free the buffer, set the status and get out
        RxFreePool(pTransactExchange->DiscardBuffer);
        Status = pTransactExchange->SaveTheRealStatus;
        RxDbgTrace(-1,Dbg,("SmbTransactExchangeCopyDataHandler: Discard Exit, status =%08lx\n"));
        DbgPrint("copyHandlerDiscard, st=%08lx\n",Status);
        return Status;
    }

    switch (pTransactExchange->State) {
    case TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST :
    case TRANSACT_EXCHANGE_TRANSMITTED_SECONDARY_REQUESTS :
        {
            PSMB_HEADER pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(pDataBuffer,LowPagePriority);

            RxDbgTrace(0,Dbg,("SmbTransactExchangeCopyDataHandler: Reparsing response\n"));

            if (pSmbHeader == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                // The response could not be parsed with the indicated bytes. Invoke
                // the receive method to resume parsing of the complete SMB
                Status = SmbTransactExchangeReceive(
                             pExchange,
                             DataSize,
                             DataSize,
                             &BytesConsumed,
                             pSmbHeader,
                             &pCopyRequestMdl,
                             &CopyRequestSize,
                             TDI_RECEIVE_ENTIRE_MESSAGE);
            }

            if ((Status == RX_MAP_STATUS(SUCCESS))) {
                ASSERT(BytesConsumed == DataSize);
                ASSERT(pCopyRequestMdl == NULL);
                ASSERT(CopyRequestSize == 0);
            }
        }
        break;

    case TRANSACT_EXCHANGE_RECEIVED_PRIMARY_RESPONSE :
        {
            RxDbgTrace(0,Dbg,("SmbTransactExchangeCopyDataHandler: Completing secondary response processing\n"));

            // In this state only secondary responses will be received. All the secondary
            // responses can be parsed from the indication. Therefore it is sufficient to
            // merely free the MDL's and re-register with the connection engine for
            // receiving subsequent requests.
            InterlockedDecrement(&pTransactExchange->PendingCopyRequests);

            if ((pTransactExchange->ParamBytesReceived == pTransactExchange->ReceiveParamBufferSize) &&
                (pTransactExchange->DataBytesReceived  == pTransactExchange->ReceiveDataBufferSize) &&
                (pTransactExchange->PendingCopyRequests == 0)) {
                // The exchange has been successfully completed. Finalize it.
                RxDbgTrace(0,Dbg,("SmbTransactExchangeCopyDataHandler: Processed last secondary response successfully\n"));
                pExchange->Status = STATUS_SUCCESS;
            }
        }
        break;

    default:
        {
            ASSERT(!"Valid State fore receiving copy data completion indication");
            pExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        }
        break;
    }

    // Free up the data buffers.
    pCurMdl = pDataBuffer;

    while (pCurMdl != NULL) {
        PMDL pPrevMdl = pCurMdl;
        pCurMdl = pCurMdl->Next;
        if (pPrevMdl!=TrailingBytesMdl) {
            IoFreeMdl(pPrevMdl);
        }
    }

    RxDbgTrace(-1,Dbg,("SmbTransactExchangeCopyDataHandler: Exit\n"));
    return Status;
}

NTSTATUS
SmbCeInitializeTransactExchange(
    PSMB_TRANSACT_EXCHANGE              pTransactExchange,
    PRX_CONTEXT                         RxContext,
    PSMB_TRANSACTION_OPTIONS            pOptions,
    PSMB_TRANSACTION_SEND_PARAMETERS    pSendParameters,
    PSMB_TRANSACTION_RECEIVE_PARAMETERS pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext)
/*++

Routine Description:

    This routine initializes a transact exchange instance

Arguments:

    pTransactExchange - the exchange instance

    RxContext         - RDBSS context for the file involved in the transaction.

    pOptions          - the transaction options

    pSendParameters   - the parameters to be sent to the server

    pReceiveParameters - the results from the server

    pResumptionContext   - the resumption context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFobx;

    UCHAR SmbCommand;

    PMDL pSendDataMdl;
    PMDL pSendParamMdl; //used if we can't subsume
    PMDL pReceiveDataMdl;
    PMDL pReceiveParamMdl;

    PVOID pSendSetupBuffer;
    ULONG SendSetupBufferSize;

    PMDL  pReceiveSetupMdl;
    ULONG ReceiveSetupBufferSize;

    ULONG SendDataBufferSize;
    ULONG ReceiveDataBufferSize;

    PVOID pSendParamBuffer;
    ULONG SendParamBufferSize;
    ULONG ReceiveParamBufferSize;

    ULONG MaxSmbBufferSize = 0;
    ULONG PrimaryRequestSmbSize = 0;

    // The fields in theSMB request that are dialect independent and need to be filled in
    PUSHORT pBcc;    // the byte count field
    PUSHORT pSetup;  // the setup data
    PBYTE   pParam;  // the param data

    BOOLEAN fTransactionNameInUnicode = FALSE;

    PSMB_EXCHANGE pExchange = (PSMB_EXCHANGE)pTransactExchange;

    PVOID         pActualPrimaryRequestSmbHeader;
    PSMB_HEADER   pPrimaryRequestSmbHeader;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    ASSERT(pTransactExchange->Type == TRANSACT_EXCHANGE);

    pTransactExchange->RxContext = RxContext;
    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    {
        PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);
        pMRxSmbContext->pExchange     = (PSMB_EXCHANGE)pTransactExchange;
    }

    ASSERT(pSendParameters != NULL);
    if (pSendParameters != NULL) {
        pSendDataMdl        = pSendParameters->pDataMdl;
        pSendParamBuffer    = pSendParameters->pParam;
        SendParamBufferSize = pSendParameters->ParamLength;
        pSendParamMdl       = pSendParameters->pParamMdl;
        pSendSetupBuffer    = pSendParameters->pSetup;
        SendSetupBufferSize = pSendParameters->SetupLength;
        SendDataBufferSize  = pSendParameters->DataLength;
        ASSERT( !((pSendDataMdl == NULL)&&(SendDataBufferSize!=0)) );
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: at the top pbuf/psize/dsize=%08lx/%08lx\n"
                                 ,pSendParamBuffer,SendParamBufferSize,SendDataBufferSize));
    } else {
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Invalid Parameters\n",Status));
        return Status;
    }

    if (pReceiveParameters != NULL) {
        pReceiveDataMdl  = pReceiveParameters->pDataMdl;
        pReceiveParamMdl = pReceiveParameters->pParamMdl;
        pReceiveSetupMdl = pReceiveParameters->pSetupMdl;

        ReceiveDataBufferSize  = ((pReceiveDataMdl != NULL) ? MmGetMdlByteCount(pReceiveDataMdl) : 0);
        ASSERT (ReceiveDataBufferSize==pReceiveParameters->DataLength);
        ReceiveParamBufferSize = ((pReceiveParamMdl != NULL) ? MmGetMdlByteCount(pReceiveParamMdl) : 0);
        ReceiveSetupBufferSize = ((pReceiveSetupMdl != NULL) ? MmGetMdlByteCount(pReceiveSetupMdl) : 0);
    } else {
        pReceiveDataMdl = pReceiveParamMdl = pReceiveSetupMdl = NULL;
        ReceiveDataBufferSize = ReceiveParamBufferSize = ReceiveDataBufferSize = 0;
    }

    MaxSmbBufferSize = MIN (pServerEntry->Server.MaximumBufferSize,
                           pOptions->MaximumTransmitSmbBufferSize);
    pTransactExchange->MaximumTransmitSmbBufferSize = MaxSmbBufferSize;

    //CODE.IMPROVEMENT this switch should be replace by four ifs each testing for the right df-flag....

    // Ensure that the SMB dialect supports the exchange capability.
    switch (pServerEntry->Server.Dialect) {
    case NTLANMAN_DIALECT:
        {
            if (!FlagOn(pOptions->Flags,SMB_XACT_FLAGS_MAILSLOT_OPERATION) &&
                FlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE)) {
                fTransactionNameInUnicode = TRUE;
            }
        }
        break;

    case LANMAN10_DIALECT:
    case WFW10_DIALECT:
        {
            // these guys only support transact...not T2 or NT. look for the name.....
            if (pOptions->pTransactionName == NULL) {
                RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Server Dialect does not support nameless transactions\n"));
                return STATUS_NOT_SUPPORTED;
            }
        }
       //no break intentional........
    case LANMAN12_DIALECT:
    case LANMAN21_DIALECT:
        {
            //  The NT_TRANSACT SMB is supported by NT servers only. Ensure that no attempt is being made
            //  to send an NT_TRANSACT SMB to a non NT server aka downlevel
            if (pOptions->NtTransactFunction != 0) {
                RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Server Dialect does not support transactions\n"));
                return STATUS_NOT_SUPPORTED;
            }

            fTransactionNameInUnicode = FALSE;
        }
        break;
    default:
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Server Dialect does not support transactions\n"));
        return STATUS_NOT_SUPPORTED;
    }

    PrimaryRequestSmbSize = sizeof(SMB_HEADER) + SendSetupBufferSize;

    // Ensure that the parameter sizes are all valid. The parameter and the data buffer
    // must be less than the maximum size to begin with.
    if ( pOptions->NtTransactFunction == 0) {
        if ((SendParamBufferSize > SMB_TRANSACT_MAXIMUM_PARAMETER_SIZE) ||
            (ReceiveParamBufferSize > SMB_TRANSACT_MAXIMUM_PARAMETER_SIZE) ||
            (SendDataBufferSize > SMB_TRANSACT_MAXIMUM_DATA_SIZE) ||
            (ReceiveDataBufferSize  > SMB_TRANSACT_MAXIMUM_DATA_SIZE)) {
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Parameters exceed maximum value\n"));
            return STATUS_INVALID_PARAMETER;
        }

        PrimaryRequestSmbSize += sizeof(REQ_TRANSACTION);

        // In all cases the name is sent as a UNICODE string if the appropriate capability is
        // supported. The only exception to this rule is for mail slots for which the name is
        // always transmitted as an ANSI string. Account for the null character as well in the
        // transaction name length.
        if (pOptions->pTransactionName != NULL) {
            if (!fTransactionNameInUnicode) {
                pTransactExchange->TransactionNameLength = RtlUnicodeStringToAnsiSize(pOptions->pTransactionName);
            } else {
                pTransactExchange->TransactionNameLength = pOptions->pTransactionName->Length + sizeof(WCHAR);

                PrimaryRequestSmbSize += (ULONG)((PBYTE)ALIGN_SMB_WSTR(PrimaryRequestSmbSize)
                                      - (PBYTE)(ULONG_PTR)PrimaryRequestSmbSize);
            }

            SmbCommand = SMB_COM_TRANSACTION;
        } else {
            // SMB protocol requires that a single NULL byte be sent as part of all
            // TRANSACT2 transactions.
            pTransactExchange->TransactionNameLength = 1;

            SmbCommand = SMB_COM_TRANSACTION2;
        }

        PrimaryRequestSmbSize += pTransactExchange->TransactionNameLength;
    } else {
        PrimaryRequestSmbSize += sizeof(REQ_NT_TRANSACTION);
        SmbCommand = SMB_COM_NT_TRANSACT;
        pTransactExchange->TransactionNameLength = 0;
    }

    // The header, setup bytes and the name if specified must be part of the primary
    // request SMB for a transaction to be successful. The secondary requests have no
    // provision for sending setup/name.
    if (PrimaryRequestSmbSize > MaxSmbBufferSize) {
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Primary request + setup exceeds maximum buffer size\n"));
        return STATUS_INVALID_PARAMETER;
    }

    // Include the byte count size and then align the size to a DWORD boundary.
    PrimaryRequestSmbSize = ROUND_UP_COUNT(PrimaryRequestSmbSize+sizeof(USHORT),ALIGN_DWORD);

    // Try to allocate for the param buffer as well if possible.    The additional DWORD
    // takes into account the worst case of alignment padding required.
    //if ( (PrimaryRequestSmbSize + SendParamBufferSize + sizeof(DWORD)) > MaxSmbBufferSize)
    if ((SendParamBufferSize!=0)
         && (((PrimaryRequestSmbSize + SendParamBufferSize) > MaxSmbBufferSize)
              || (DONTSUBSUME_PARAMS))    ){
        // The param will spill over to a secondary request. Do not attempt to over
        // allocate the primary request. if we can't subsume the params, then we'll need an MDL
        // to partial from.

        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: cannot subsume params\n"));
        pTransactExchange->fParamsSubsumedInPrimaryRequest = FALSE;
        pSendParamMdl = RxAllocateMdl(pSendParamBuffer,SendParamBufferSize);
        if (pSendParamMdl == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: BIGPARAMMDL %08lx\n",pSendParamMdl));
            RxProbeAndLockPages(pSendParamMdl,KernelMode,IoModifyAccess,Status);
            if ((Status != RX_MAP_STATUS(SUCCESS))) {
                IoFreeMdl(pSendParamMdl);
            } else {
                if (MmGetSystemAddressForMdlSafe(pSendParamMdl,LowPagePriority) == NULL) { //map it
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                pSendParameters->pParamMdl = pSendParamMdl; // save it away
            }
        }
    } else {
        PrimaryRequestSmbSize = ROUND_UP_COUNT(PrimaryRequestSmbSize+SendParamBufferSize,ALIGN_DWORD);

        // Update the transact exchange to reflect the fact that no separate param MDL is
        // required.
        pTransactExchange->fParamsSubsumedInPrimaryRequest = TRUE;
    }

    //CODE.IMPROVEMENT this should be replaced by a call to get a smbbuf as in OrdExchg

    pActualPrimaryRequestSmbHeader = (PSMB_HEADER)RxAllocatePoolWithTag(
                                                PagedPool,
                               (PrimaryRequestSmbSize + 4 + TRANSPORT_HEADER_SIZE),
                                                MRXSMB_XACT_POOLTAG); //up to 4 pad bytes

    if (pActualPrimaryRequestSmbHeader == NULL) {
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Cannot allocate primary request SMB\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        (PCHAR) pPrimaryRequestSmbHeader =
            (PCHAR) pActualPrimaryRequestSmbHeader + TRANSPORT_HEADER_SIZE;
    }

    if (Status == STATUS_SUCCESS) {
        switch (SmbCommand) {
        case SMB_COM_TRANSACTION :
        case SMB_COM_TRANSACTION2:
            {
                PREQ_TRANSACTION pTransactRequest;

                pTransactRequest  = (PREQ_TRANSACTION)(pPrimaryRequestSmbHeader + 1);
                pTransactRequest->WordCount = (UCHAR)(14 + (SendSetupBufferSize/sizeof(USHORT)));
                SmbPutUshort(
                    &pTransactRequest->TotalParameterCount,
                    (USHORT)SendParamBufferSize);
                SmbPutUshort(
                    &pTransactRequest->TotalDataCount,
                    (USHORT)SendDataBufferSize);
                SmbPutUshort(
                    &pTransactRequest->MaxParameterCount,
                    (USHORT)ReceiveParamBufferSize);
                SmbPutUshort(
                    &pTransactRequest->MaxDataCount,
                    (USHORT)ReceiveDataBufferSize);

                pTransactRequest->MaxSetupCount = (UCHAR)(ReceiveSetupBufferSize/sizeof(USHORT));

                pTransactRequest->Reserved = 0;
                pTransactRequest->Reserved3 = 0;
                SmbPutUshort(&pTransactRequest->Reserved2, 0);

                SmbPutUshort( &pTransactRequest->Flags, pOptions->Flags&~SMB_XACT_INTERNAL_FLAGS_MASK );
                pTransactRequest->SetupCount = (UCHAR)(SendSetupBufferSize/sizeof(USHORT));
                SmbPutUlong(&pTransactRequest->Timeout, pOptions->TimeoutIntervalInMilliSeconds);
                pSetup = (PUSHORT)pTransactRequest->Buffer;

                // Copy the transact name and align the buffer if required.
                if (pOptions->pTransactionName != NULL) {
                    PBYTE pName;
                    ULONG TransactionNameLength = pTransactExchange->TransactionNameLength;

                    // Set the name field in the SMB.
                    pName = (PBYTE)pSetup +
                            SendSetupBufferSize +
                            sizeof(USHORT);          // account for the bcc field

                    ASSERT(SmbCommand == SMB_COM_TRANSACTION);
                    RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: TransactionName(Length %ld) %ws\n",
                                    TransactionNameLength,
                                    pOptions->pTransactionName->Buffer));

                    if (fTransactionNameInUnicode) {
                        pName = ALIGN_SMB_WSTR(pName);
                        Status = SmbPutUnicodeString(&pName,
                                     pOptions->pTransactionName,
                                     &TransactionNameLength);
                    } else {
                        Status = SmbPutUnicodeStringAsOemString(&pName,
                                     pOptions->pTransactionName,
                                     &TransactionNameLength);
                    }
                }

                pParam = (PBYTE)pSetup +
                         SendSetupBufferSize +
                         sizeof(USHORT) +                          // the bcc field
                         pTransactExchange->TransactionNameLength;
                pParam = ROUND_UP_POINTER(pParam, ALIGN_DWORD);
            }
            break;

        case SMB_COM_NT_TRANSACT:
            {
                PREQ_NT_TRANSACTION pNtTransactRequest;

                pNtTransactRequest = (PREQ_NT_TRANSACTION)(pPrimaryRequestSmbHeader + 1);
                pNtTransactRequest->WordCount = (UCHAR)(19 + (SendSetupBufferSize/sizeof(USHORT)));

                SmbPutUlong( &pNtTransactRequest->TotalParameterCount, SendParamBufferSize);
                SmbPutUlong( &pNtTransactRequest->TotalDataCount, SendDataBufferSize);
                SmbPutUlong( &pNtTransactRequest->MaxParameterCount, ReceiveParamBufferSize);
                SmbPutUlong( &pNtTransactRequest->MaxDataCount, ReceiveDataBufferSize);
                RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: init for NT_T (p,d,mp,md) %d %d %d %d\n",
                           pNtTransactRequest->TotalParameterCount, pNtTransactRequest->TotalDataCount,
                           pNtTransactRequest->MaxParameterCount, pNtTransactRequest->MaxDataCount));

                pNtTransactRequest->MaxSetupCount = (UCHAR)(ReceiveSetupBufferSize / sizeof(USHORT));
                SmbPutUshort( &pNtTransactRequest->Flags, pOptions->Flags&~SMB_XACT_INTERNAL_FLAGS_MASK );
                SmbPutUshort( &pNtTransactRequest->Function, pOptions->NtTransactFunction );
                pNtTransactRequest->SetupCount = (UCHAR)(SendSetupBufferSize/sizeof(USHORT));
                pSetup = (PUSHORT)pNtTransactRequest->Buffer;
                pParam = (PBYTE)pSetup +
                         SendSetupBufferSize +
                         sizeof(USHORT);                          // the bcc field
                pParam = ROUND_UP_POINTER(pParam, ALIGN_DWORD);
            }
            break;

        default:
            ASSERT(!"Valid Smb Command Type for Transact exchange");
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if (Status == STATUS_SUCCESS) {
        // All related initialization of a transaction exchange has been
        // completed. At this point the transact exchange assumes ownership
        // of the various buffers ( specified as MDLs ) in the receive and
        // send parameters. It will get rid of them during finalization
        // of the exchange. In order to ensure that the caller does not
        // attempt to free any of these buffers they are reset in the
        // receive/send parameters.

        // Copy the setup data
        RtlCopyMemory(pSetup,pSendSetupBuffer,SendSetupBufferSize);

        if (pTransactExchange->fParamsSubsumedInPrimaryRequest) {
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: subsuming where/size=%08lx/%08lx\n"
                                 ,pSendParamBuffer,SendParamBufferSize));
            RtlCopyMemory(pParam,pSendParamBuffer,SendParamBufferSize);
        }

        // Initialize the transact exchange.
        pTransactExchange->Status = STATUS_MORE_PROCESSING_REQUIRED;

        pTransactExchange->Mid = 0;
        pTransactExchange->TransactSmbCommand = SmbCommand;
        pTransactExchange->pActualPrimaryRequestSmbHeader = pActualPrimaryRequestSmbHeader;
        pTransactExchange->pPrimaryRequestSmbHeader = pPrimaryRequestSmbHeader;
        pTransactExchange->PrimaryRequestSmbSize    = PrimaryRequestSmbSize;

        pTransactExchange->pSendDataMdl = pSendDataMdl;
        pTransactExchange->SendDataBufferSize = SendDataBufferSize;
        pTransactExchange->pReceiveDataMdl  = pReceiveDataMdl;
        pTransactExchange->ReceiveDataBufferSize = ReceiveDataBufferSize;
        pTransactExchange->DataBytesSent = 0;
        pTransactExchange->DataBytesReceived = 0;

        pTransactExchange->pSendParamBuffer = pSendParamBuffer;
        pTransactExchange->SendParamBufferSize = SendParamBufferSize;
        pTransactExchange->pSendParamMdl  = pSendParamMdl;
        pTransactExchange->pReceiveParamMdl  = pReceiveParamMdl;
        pTransactExchange->ReceiveParamBufferSize = ReceiveParamBufferSize;
        pTransactExchange->ParamBytesSent = 0;
        pTransactExchange->ParamBytesReceived = 0;

        pTransactExchange->pReceiveSetupMdl       = pReceiveSetupMdl;
        pTransactExchange->ReceiveSetupBufferSize = ReceiveSetupBufferSize;
        pTransactExchange->SetupBytesReceived = 0;

        pTransactExchange->NtTransactFunction  = pOptions->NtTransactFunction;
        pTransactExchange->Flags               = pOptions->Flags;

        if ((capFobx != NULL) &&
            BooleanFlagOn(capFobx->Flags,FOBX_FLAG_DFS_OPEN)) {
            pTransactExchange->Flags |= SMB_XACT_FLAGS_DFS_AWARE;
        } else if (RxContext->MajorFunction == IRP_MJ_CREATE) {
            PMRX_NET_ROOT pNetRoot = RxContext->pFcb->pNetRoot;

            if (FlagOn(pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT) &&
                RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT)) {
                    pTransactExchange->Flags |= SMB_XACT_FLAGS_DFS_AWARE;
            }
        }

        pTransactExchange->pResumptionContext  = pResumptionContext;

        // Reset the Send and Receive parameter data structures to transfer
        // the ownership of the MDLs to the exchange.

        if (pSendParameters->Flags & SMB_XACT_FLAGS_CALLERS_SENDDATAMDL) {
            pTransactExchange->Flags |= SMB_XACT_FLAGS_CALLERS_SENDDATAMDL;
        }

        RtlZeroMemory(
            pSendParameters,
            sizeof(SMB_TRANSACTION_SEND_PARAMETERS));

        RtlZeroMemory(
            pReceiveParameters,
            sizeof(SMB_TRANSACTION_RECEIVE_PARAMETERS));
    }

    if (Status != STATUS_SUCCESS) {
        // Clean up the memory allocated in an effort to initialize the transact exchange
        if (pActualPrimaryRequestSmbHeader) {

            RxFreePool(pActualPrimaryRequestSmbHeader);
        }
    } else {
        PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

        pMRxSmbContext->pExchange = (PSMB_EXCHANGE)pTransactExchange;

        if (!FlagOn(pTransactExchange->Flags,SMB_XACT_FLAGS_MAILSLOT_OPERATION)) {
            // No reconnection attempts are allowed in transact exchanges except mailslot
            pTransactExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_ATTEMPT_RECONNECTS;
        }

        if (pOptions->Flags & SMB_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE ) {
            pTransactExchange->SmbCeFlags |= SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE;
        }
    }

    return Status;
}

NTSTATUS
SmbTransactExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalizes the transact exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the interrupt request level

    pPostFinalize - set to TRUE if the request is to be posted

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_TRANSACT_EXCHANGE               pTransactExchange;
    PSMB_TRANSACTION_RESUMPTION_CONTEXT  pResumptionContext;
    LONG                                 References;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    ASSERT(pExchange->Type == TRANSACT_EXCHANGE);

    pTransactExchange  = (PSMB_TRANSACT_EXCHANGE)pExchange;

    RxLog((">>>XE %lx",pTransactExchange));
    SmbLog(LOG,
           SmbTransactExchangeFinalize,
           LOGPTR(pTransactExchange));

    // Disassociate the MID associated with the exchange
    if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
        SmbCeDissociateMidFromExchange(pExchange->SmbCeContext.pServerEntry,pExchange);
    }

    if ((pTransactExchange->ReceiveParamBufferSize > 0) &&
        (pTransactExchange->ReceiveParamBufferSize !=
        pTransactExchange->ParamBytesReceived)) {
        RxDbgTrace(0, Dbg,
                 ("SmbCeTransactExchangeFinalize: Param Bytes Receive error ... expected(%ld) received(%ld)\n",
                  pTransactExchange->ReceiveParamBufferSize, pTransactExchange->ParamBytesReceived
                ));
    }

    if ((pTransactExchange->ReceiveDataBufferSize > 0) &&
        (pTransactExchange->ReceiveDataBufferSize !=
        pTransactExchange->DataBytesReceived)) {
        RxDbgTrace(0, Dbg,
                 ("SmbCeTransactExchangeFinalize: Data Bytes Receive error ... expected(%ld) received(%ld)\n",
                  pTransactExchange->ReceiveDataBufferSize, pTransactExchange->DataBytesReceived
                 ));
    }

    if (RxShouldPostCompletion()) {
        RxPostToWorkerThread(
            MRxSmbDeviceObject,
            CriticalWorkQueue,
            &pExchange->WorkQueueItem,
            SmbCeDiscardTransactExchange,
            pTransactExchange);
    } else {
        SmbCeDiscardTransactExchange(pTransactExchange);
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pPostFinalize);
}

NTSTATUS
SmbTransactAccrueAndValidateFormatData(
    IN struct _SMB_TRANSACT_EXCHANGE *pTransactExchange,    // The exchange instance
    IN  PSMB_HEADER                  pSmbHeader,
    IN  ULONG                        BytesIndicated,
    OUT PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format
    )
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:


Return Value:

    RXSTATUS - The return status for the operation
          STATUS_SUCCESS -- all the data was indicated and it was valid
          STATUS_INVALID_NETWORK_RESPONSE -- something about the format parameters is untoward.

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PRESP_TRANSACTION pTransactResponse = (PRESP_TRANSACTION)(pSmbHeader+1);
    PBYTE WordCountPtr;
    UCHAR WordCount;
    PBYTE ByteCountPtr;
    USHORT ByteCount;

    RtlZeroMemory(Format,sizeof(*Format));

    Format->WordCount = WordCount = pTransactResponse->WordCount;
    ByteCountPtr = (&pTransactResponse->WordCount)+1+(sizeof(USHORT)*WordCount);

    if (((ULONG)(ByteCountPtr+sizeof(USHORT)-((PBYTE)pSmbHeader)))>BytesIndicated) {
        ByteCount = SmbGetUshort(ByteCountPtr);
        DbgPrint("ExtraTransactBytes wc,bcp,bc,smbh %lx,%lx,%lx,%lx\n",
                 WordCount,ByteCountPtr,ByteCount,pSmbHeader);
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    Format->ByteCount = ByteCount = SmbGetUshort(ByteCountPtr);
    Format->ApparentMsgLength = (ULONG)((ByteCountPtr+sizeof(USHORT)-((PBYTE)pSmbHeader))+ByteCount);

    if (WordCount==0) {
        return(STATUS_SUCCESS);
    }

#if 0
    ULONG WordCount;
    ULONG TotalParameterCount;
    ULONG TotalDataCount;
    ULONG ParameterCount;
    ULONG ParameterOffset;
    ULONG ParameterDisplacement;
    ULONG DataCount;
    ULONG DataOffset;
    ULONG DataDisplacement;
    ULONG ByteCount;
    ULONG ApparentMsgLength;
#endif

    // where is the validation: stuff that should be checked is
    //    a) that the values fit in the params and data spcified
    //    b) that we are not over the limit on bytes received
    //    c) that the response that we are receiving is valid for the command that we sent
    // we didn't compute ApparentMsgLength.......
    // The validation has not been done here. We rely on Transact Receive routine to detect the invalid response.

    //CODE.IMPROVEMENT  we could save some space with an unstuffer here........... but
    //   we'd have to amortize the cost over a lot more places. we should look on RISC machines to see if they turn it
    //   into a single copy.

    switch (pSmbHeader->Command) {
    case SMB_COM_TRANSACTION2:
    case SMB_COM_TRANSACTION:
    case SMB_COM_TRANSACTION_SECONDARY:
    case SMB_COM_TRANSACTION2_SECONDARY:
        {
            Format->TotalParameterCount    = SmbGetUshort(&pTransactResponse->TotalParameterCount);
            Format->TotalDataCount         = SmbGetUshort(&pTransactResponse->TotalDataCount);

            Format->ParameterCount          = SmbGetUshort(&pTransactResponse->ParameterCount);
            Format->ParameterOffset         = SmbGetUshort(&pTransactResponse->ParameterOffset);
            Format->ParameterDisplacement   = SmbGetUshort(&pTransactResponse->ParameterDisplacement);

            Format->DataCount         = SmbGetUshort(&pTransactResponse->DataCount);
            Format->DataOffset        = SmbGetUshort(&pTransactResponse->DataOffset);
            Format->DataDisplacement  = SmbGetUshort(&pTransactResponse->DataDisplacement);
        }
        break;

    case SMB_COM_NT_TRANSACT:
    case SMB_COM_NT_TRANSACT_SECONDARY:
        {
            PRESP_NT_TRANSACTION pNtTransactResponse;

            pNtTransactResponse = (PRESP_NT_TRANSACTION)(pTransactResponse);

            Format->TotalParameterCount  = SmbGetUlong(&pNtTransactResponse->TotalParameterCount);
            Format->TotalDataCount = SmbGetUlong(&pNtTransactResponse->TotalDataCount);

            Format->ParameterCount  = SmbGetUlong(&pNtTransactResponse->ParameterCount);
            Format->ParameterOffset = SmbGetUlong(&pNtTransactResponse->ParameterOffset);
            Format->ParameterDisplacement = SmbGetUlong(&pNtTransactResponse->ParameterDisplacement);

            Format->DataCount   = SmbGetUlong(&pNtTransactResponse->DataCount);
            Format->DataOffset  = SmbGetUlong(&pNtTransactResponse->DataOffset);
            Format->DataDisplacement  = SmbGetUlong(&pNtTransactResponse->DataDisplacement);
        }
        break;

    default:
        // Bug Check
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    //do this here so we can use it as validation criterion
    pTransactExchange->ParameterBytesSeen += Format->ParameterCount;
    pTransactExchange->DataBytesSeen += Format->DataCount;

    return Status;
}

NTSTATUS
ParseTransactResponse(
    IN struct _SMB_TRANSACT_EXCHANGE *pTransactExchange,    // The exchange instance
    IN PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format,
    IN ULONG        BytesIndicated,
    IN ULONG        BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pCopyRequestMdlPointer,
    OUT PULONG      pCopyRequestSize)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pTransactExchange - the exchange instance

    BytesIndicated    - the number of bytes indicated

    Bytes Available   - the number of bytes available

    pBytesTaken       - the number of bytes consumed

    pSmbHeader        - the byte buffer

    pCopyRequestMdlPointer - the buffer into which the remaining data is to be copied.

    pCopyRequestSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation
          STATUS_MORE_PROCESSING_REQUIRED -- if a copy of the data needs to be done before
          processing can be completed. This occurs because all the data was not indicated
          STATUS_SUCCESS -- all the data was indicated and it was valid
          STATUS_* -- They indicate an error which would normally leads to the abortion of the
          exchange.

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG ParamBytesInResponse  = 0;
    ULONG ParamOffsetInResponse = 0;
    ULONG DataBytesInResponse   = 0;
    ULONG DataOffsetInResponse  = 0;

    ULONG PaddingLength = 0;

    PMDL  pFirstMdlInCopyDataRequestChain = NULL;
    PMDL  pLastMdlInCopyDataRequestChain = NULL;
    PMDL  pParamMdl = NULL;
    PMDL  pPaddingMdl = NULL;
    PMDL  pDataMdl  = NULL;

    PBYTE pParamStartAddress;
    PBYTE pDataStartAddress;
    PBYTE pSmbBuffer = (PBYTE)pSmbHeader;

    switch (pSmbHeader->Command) {
    case SMB_COM_TRANSACTION2:
    case SMB_COM_TRANSACTION:
    case SMB_COM_TRANSACTION_SECONDARY:
    case SMB_COM_TRANSACTION2_SECONDARY:
        {
            PRESP_TRANSACTION pTransactResponse;

            pTransactResponse = (PRESP_TRANSACTION)(pSmbBuffer + *pBytesTaken);
            *pBytesTaken = *pBytesTaken + sizeof(RESP_TRANSACTION);
        }
        break;
    case SMB_COM_NT_TRANSACT:
    case SMB_COM_NT_TRANSACT_SECONDARY:
        {
            PRESP_NT_TRANSACTION pNtTransactResponse;

            pNtTransactResponse = (PRESP_NT_TRANSACTION)(pSmbBuffer + *pBytesTaken);
            *pBytesTaken = *pBytesTaken + sizeof(RESP_NT_TRANSACTION);
        }
        break;
    default:
        // Bug Check
        ASSERT(!"Valid SMB command in Transaction response");
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

#if 0
    ULONG WordCount;
    ULONG TotalParameterCount;
    ULONG TotalDataCount;
    ULONG ParameterCount;
    ULONG ParameterOffset;
    ULONG ParameterDisplacement;
    ULONG DataCount;
    ULONG DataOffset;
    ULONG DataDisplacement;
    ULONG ByteCount;
    ULONG ApparentMsgLength;
#endif
    ParamBytesInResponse  = Format->ParameterCount;
    ParamOffsetInResponse = Format->ParameterOffset;
    DataBytesInResponse   = Format->DataCount;
    DataOffsetInResponse  = Format->DataOffset;

    if (ParamBytesInResponse > 0) {
        ASSERT(pTransactExchange->pReceiveParamMdl != NULL);
        pParamStartAddress = (PBYTE)MmGetSystemAddressForMdlSafe(pTransactExchange->pReceiveParamMdl,LowPagePriority);

        if (pParamStartAddress == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            pParamStartAddress += Format->ParameterDisplacement;
        }
    } else {
        pParamStartAddress = NULL;
    }

    if (DataBytesInResponse > 0) {
        ASSERT(pTransactExchange->pReceiveDataMdl != NULL);
        pDataStartAddress  = (PBYTE)MmGetSystemAddressForMdlSafe(pTransactExchange->pReceiveDataMdl,LowPagePriority);

        if (pDataStartAddress == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            pDataStartAddress  += Format->DataDisplacement;
        }
    } else {
        pDataStartAddress = NULL;
    }

    RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Param Bytes(%ld) Param Offset (%ld) Data Bytes (%ld) Data Offset(%ld)\n",
                        ParamBytesInResponse,
                        ParamOffsetInResponse,
                        DataBytesInResponse,
                        DataOffsetInResponse));

    // If either the param bytes or the data bytes have already been indicated, copy
    // them into the respective buffers and trim the size of the MDL for the copy
    // data request.

    if (ParamOffsetInResponse <= BytesIndicated) {
        *pBytesTaken = ParamOffsetInResponse;
        if (ParamBytesInResponse > 0) {
            ULONG ParamBytesIndicated = MIN(
                                            ParamBytesInResponse,
                                            BytesIndicated - ParamOffsetInResponse);

            RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Param Bytes indicated %ld\n",ParamBytesIndicated));
            RtlCopyMemory(
                pParamStartAddress,
                (pSmbBuffer + ParamOffsetInResponse),
                ParamBytesIndicated);

            *pBytesTaken = *pBytesTaken + ParamBytesIndicated;
            pParamStartAddress += ParamBytesIndicated;
            ParamBytesInResponse -= ParamBytesIndicated;
            ParamOffsetInResponse += ParamBytesIndicated;
            pTransactExchange->ParamBytesReceived  += ParamBytesIndicated;
        }
    }

    if ( (DataOffsetInResponse <= BytesIndicated) &&
         (DataOffsetInResponse > 0) ) {
        *pBytesTaken = DataOffsetInResponse;  //you have to move up EVEN IF NO BYTES!!!!!
        if (DataBytesInResponse > 0) {
            ULONG DataBytesIndicated = MIN(
                                           DataBytesInResponse,
                                           BytesIndicated - DataOffsetInResponse);

            RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Data Bytes indicated %ld\n",DataBytesIndicated));
            RtlCopyMemory(
                pDataStartAddress,
                (pSmbBuffer + DataOffsetInResponse),
                DataBytesIndicated);

            *pBytesTaken = *pBytesTaken + DataBytesIndicated;
            pDataStartAddress += DataBytesIndicated;
            DataBytesInResponse -= DataBytesIndicated;
            DataOffsetInResponse += DataBytesIndicated;
            pTransactExchange->DataBytesReceived  += DataBytesIndicated;
        }
    }

    RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Made it past the copies......... \n"));

    if (ParamBytesInResponse > 0) {
        // There are more param bytes that have not been indicated. Set up an MDL
        // to copy them over.

        RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Posting Copy request for Param Bytes %ld\n",ParamBytesInResponse));
        pParamMdl = RxAllocateMdl(
                        ((PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pReceiveParamMdl)
                        + pTransactExchange->ParamBytesReceived),
                        ParamBytesInResponse);

        if (pParamMdl != NULL) {
            IoBuildPartialMdl(
                pTransactExchange->pReceiveParamMdl,
                pParamMdl,
                ((PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pReceiveParamMdl)
                 + pTransactExchange->ParamBytesReceived),
                ParamBytesInResponse);
            pFirstMdlInCopyDataRequestChain = pParamMdl;
            pLastMdlInCopyDataRequestChain  = pParamMdl;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        pTransactExchange->ParamBytesReceived += ParamBytesInResponse;
    }

    if ((Status == RX_MAP_STATUS(SUCCESS)) &&
        (DataBytesInResponse > 0)) {

        RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Posting Copy request for Data Bytes %ld\n",DataBytesInResponse));

        // In certain cases a padding MDL needs to be inserted between the param and data portions
        // of the response to consume the padding bytes sent by the server.
        if ((ParamBytesInResponse > 0) &&
            ((PaddingLength = DataOffsetInResponse -
                           (ParamBytesInResponse + ParamOffsetInResponse)) > 0)) {
            RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Posting Copy request for padding bytes %ld\n",PaddingLength));
            // There are some padding bytes present. Construct an MDL to consume them
            //pPaddingMdl = RxAllocateMdl(&MRxSmb_pPaddingData,PaddingLength);
            ASSERT(!"this doesn't work");
            if (pPaddingMdl != NULL) {
                if (pLastMdlInCopyDataRequestChain != NULL) {
                    pLastMdlInCopyDataRequestChain->Next = pPaddingMdl;
                } else {
                    pFirstMdlInCopyDataRequestChain = pPaddingMdl;
                }
                pLastMdlInCopyDataRequestChain = pPaddingMdl;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        // There are more data bytes which have not been indicated. Set up an MDL
        // to copy them over.
        if ((Status == RX_MAP_STATUS(SUCCESS))) {
            if (pTransactExchange->pReceiveDataMdl->ByteCount >= DataBytesInResponse) {
                pDataMdl = RxAllocateMdl(
                               ((PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pReceiveDataMdl)
                                + pTransactExchange->DataBytesReceived),
                               DataBytesInResponse);

                if (pDataMdl != NULL) {
                    IoBuildPartialMdl(
                        pTransactExchange->pReceiveDataMdl,
                        pDataMdl,
                        ((PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pReceiveDataMdl)
                         + pTransactExchange->DataBytesReceived),
                        DataBytesInResponse);

                    if (pLastMdlInCopyDataRequestChain != NULL) {
                        pLastMdlInCopyDataRequestChain->Next = pDataMdl;
                    } else {
                        pFirstMdlInCopyDataRequestChain = pDataMdl;
                    }

                    pLastMdlInCopyDataRequestChain = pDataMdl;
                    pTransactExchange->DataBytesReceived += DataBytesInResponse;
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }
        }
    }

    if ((Status != RX_MAP_STATUS(SUCCESS))) {
        if (pDataMdl != NULL) {
            IoFreeMdl(pDataMdl);
        }

        if (pPaddingMdl != NULL) {
            IoFreeMdl(pPaddingMdl);
        }

        if (pParamMdl != NULL) {
            IoFreeMdl(pParamMdl);
        }
    } else {
        if (pFirstMdlInCopyDataRequestChain != NULL) {
            ULONG MdlLength = ParamBytesInResponse+PaddingLength+DataBytesInResponse;
            *pCopyRequestMdlPointer = pFirstMdlInCopyDataRequestChain;
            *pCopyRequestSize = MdlLength;
            RxDbgTrace( 0, Dbg, ("ParseTransactResponse: final mdl and copy size %08lx %08lx(%ld)\n",
                              pFirstMdlInCopyDataRequestChain,MdlLength,MdlLength));
            IF_DEBUG {
                PMDL imdl = pFirstMdlInCopyDataRequestChain;
                ULONG mdllength = MdlLength;
                mdllength -= MmGetMdlByteCount(imdl);
                for (;;) {
                    if (!(imdl=imdl->Next)) break;
                    mdllength -= MmGetMdlByteCount(imdl);
                }
                ASSERT(mdllength==0);
            }

            InterlockedIncrement(&pTransactExchange->PendingCopyRequests);
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }

        if ((pTransactExchange->ParamBytesReceived < pTransactExchange->ReceiveParamBufferSize) ||
            (pTransactExchange->DataBytesReceived  < pTransactExchange->ReceiveDataBufferSize)) {
            NTSTATUS ReceiveStatus;

            // The exchange has been successfully completed. Finalize it.
            RxDbgTrace(0,Dbg,("ParseTransactResponse: Register for more responses\n"));
            ReceiveStatus = SmbCeReceive((PSMB_EXCHANGE)pTransactExchange);
            if (ReceiveStatus != STATUS_SUCCESS) {
                // There was an error in registering the receive. Abandon the
                // transaction.
                Status = ReceiveStatus;
            }
        }
    }

    return Status;

    UNREFERENCED_PARAMETER(BytesAvailable);

}

#if DBG
ULONG SmbSendBadSecondary = 0;
#endif
NTSTATUS
SendSecondaryRequests(PVOID pContext)
/*++

Routine Description:

    This routine sends all the secondary requests associated with the transaction

Arguments:

    pTransactExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    PSMB_EXCHANGE pExchange = (PSMB_EXCHANGE)pContext;
    PSMB_TRANSACT_EXCHANGE pTransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

    NTSTATUS Status = STATUS_SUCCESS;

    ULONG MaximumSmbBufferSize;

    // The MDL's used in sending the primary request associated with the TRANSACT SMB
    PMDL  pPartialDataMdl         = NULL;
    PMDL  pPartialParamMdl        = NULL;
    PMDL  pPaddingMdl             = NULL;
    PMDL  pSecondaryRequestSmbMdl = NULL;
    PMDL  pLastMdlInChain         = NULL;

    ULONG SecondaryRequestSmbSize = 0;
    ULONG SmbLength;
    ULONG PaddingLength;

    ULONG ParamOffset,ParamDisplacement;
    ULONG DataOffset,DataDisplacement;
    ULONG ByteCountOffset;
    USHORT ByteCount;
    PUSHORT pByteCount;

    ULONG ParamBytesToBeSent;        // Param bytes to be sent per request
    ULONG DataBytesToBeSent;         // data bytes to be sent per request
    ULONG SendParamBufferSize;       // Total param bytes to be sent in secondary requests
    ULONG SendDataBufferSize;        // Total data bytes to be sent in secondary requests
    PBYTE pSendParamStartAddress = NULL;
    PBYTE pSendDataStartAddress  = NULL;
    PBYTE pOriginalParamBuffer = NULL;
    PBYTE pOriginalDataBuffer = NULL;
    ULONG TotalParamBytes,TotalDataBytes;

    BOOLEAN ParamPartialMdlAlreadyUsed = FALSE;
    BOOLEAN DataPartialMdlAlreadyUsed = FALSE;

    PVOID pActualSecondaryRequestSmbHeader = NULL;
    PSMB_HEADER pSecondaryRequestSmbHeader = NULL;

    PAGED_CODE();

    ASSERT(pTransactExchange->State == TRANSACT_EXCHANGE_RECEIVED_INTERIM_RESPONSE);


    TotalParamBytes = pTransactExchange->SendParamBufferSize;
    SendParamBufferSize = TotalParamBytes - pTransactExchange->ParamBytesSent;

    TotalDataBytes = pTransactExchange->SendDataBufferSize;
    SendDataBufferSize = TotalDataBytes - pTransactExchange->DataBytesSent;

    ASSERT((SendParamBufferSize > 0) || (SendDataBufferSize > 0));

    switch (pTransactExchange->TransactSmbCommand) {
    case SMB_COM_TRANSACTION:
        SecondaryRequestSmbSize = sizeof(SMB_HEADER) +
            FIELD_OFFSET(REQ_TRANSACTION_SECONDARY,Buffer);
        break;

    case SMB_COM_TRANSACTION2:
        //CODE.IMPROVEMENT.ASHAMED smb.h should containa REQ_TRANSACTION2_SECONDARY instead
        //        of this bogus comment about how the server can ignore it
        SecondaryRequestSmbSize = sizeof(SMB_HEADER) +
            FIELD_OFFSET(REQ_TRANSACTION_SECONDARY,Buffer)
            + sizeof(USHORT);  //add in the extra word
        break;

    case SMB_COM_NT_TRANSACT:
        SecondaryRequestSmbSize = sizeof(SMB_HEADER) +
            FIELD_OFFSET(REQ_NT_TRANSACTION_SECONDARY,Buffer);
        break;

    default:
        ASSERT(!"Valid Smb Command in transaction exchange");
        Status = STATUS_TRANSACTION_ABORTED;
    }

    SecondaryRequestSmbSize = QuadAlign(SecondaryRequestSmbSize); //pad to quadword boundary

    //CODE.IMPROVEMENT we could overallocate here....sometimes the copy would be faster
    pActualSecondaryRequestSmbHeader = (PSMB_HEADER)
                                 RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     SecondaryRequestSmbSize + TRANSPORT_HEADER_SIZE,
                                     MRXSMB_XACT_POOLTAG);

    if ((Status == RX_MAP_STATUS(SUCCESS)) && pActualSecondaryRequestSmbHeader != NULL) {

        (PCHAR) pSecondaryRequestSmbHeader =
            (PCHAR) pActualSecondaryRequestSmbHeader + TRANSPORT_HEADER_SIZE;

        // Initialize the SMB header  ...

        ASSERT(
                 ((SMB_COM_TRANSACTION+1) == SMB_COM_TRANSACTION_SECONDARY)
               &&((SMB_COM_TRANSACTION2+1)== SMB_COM_TRANSACTION2_SECONDARY)
               &&((SMB_COM_NT_TRANSACT+1) == SMB_COM_NT_TRANSACT_SECONDARY)
             );

        Status = SmbTransactBuildHeader(
                     pTransactExchange,                        // the exchange instance
                     (UCHAR)(pTransactExchange->TransactSmbCommand+1), // the SMB command ..see the asserts above
                     pSecondaryRequestSmbHeader);              // the SMB buffer

        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: SmbCeBuildSmbHeader returned %lx\n",Status));
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((Status == RX_MAP_STATUS(SUCCESS))) {
        MaximumSmbBufferSize = pTransactExchange->MaximumTransmitSmbBufferSize;

        // Ensure that the MDL's have been probed & locked. The new MDL's have been allocated.
        // The partial MDL's are allocated to be large enough to span the maximum buffer
        // length possible.

        // Initialize the data related MDL's for the secondary request
        if (SendDataBufferSize > 0) {
            RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Data Bytes remaining %ld\n",SendDataBufferSize));

            pOriginalDataBuffer = (PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pSendDataMdl);
            pSendDataStartAddress = pOriginalDataBuffer + pTransactExchange->DataBytesSent;

            pPartialDataMdl = RxAllocateMdl(
                                  0,
                                  (MIN(pTransactExchange->SendDataBufferSize,
                                       MaximumSmbBufferSize) +
                                       PAGE_SIZE - 1));

            if (pPartialDataMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        // Initialize the parameter related MDL's for the secondary request
        if ((SendParamBufferSize > 0) && (Status == RX_MAP_STATUS(SUCCESS))) {
            RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Param Bytes remaining %ld\n",SendParamBufferSize));
            pOriginalParamBuffer = (PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pSendParamMdl);
            pSendParamStartAddress = pOriginalParamBuffer + pTransactExchange->ParamBytesSent;

            pPartialParamMdl  = RxAllocateMdl(
                                    0,
                                    (MIN(pTransactExchange->SendParamBufferSize,
                                         MaximumSmbBufferSize) +
                                         PAGE_SIZE - 1));

            //CODE.IMPROVEMENT we shouldn't allocate this if datasize==0
            pPaddingMdl       = RxAllocateMdl(0,(sizeof(DWORD) + PAGE_SIZE - 1));

            if ((pPartialParamMdl == NULL) ||
                (pPaddingMdl == NULL)) {
                RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Error allocating param MDLS\n"));
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        // Initialize the secondary request SMB MDL
        if ((Status == RX_MAP_STATUS(SUCCESS))) {

            RxAllocateHeaderMdl(
                pSecondaryRequestSmbHeader,
                SecondaryRequestSmbSize,
                pSecondaryRequestSmbMdl
                );

            if (pSecondaryRequestSmbMdl != NULL) {

                RxProbeAndLockHeaderPages(
                    pSecondaryRequestSmbMdl,
                    KernelMode,
                    IoModifyAccess,
                    Status);

                if ((Status != RX_MAP_STATUS(SUCCESS))) {
                    IoFreeMdl(pSecondaryRequestSmbMdl);
                    pSecondaryRequestSmbMdl = NULL;
                } else {
                    if (MmGetSystemAddressForMdlSafe(pSecondaryRequestSmbMdl,LowPagePriority) == NULL) { //map it
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            } else {
                RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Error allocating 2ndsmb MDL\n"));
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    while ((Status == RX_MAP_STATUS(SUCCESS)) &&
           ((SendParamBufferSize > 0) || (SendDataBufferSize > 0))) {
        PaddingLength      = 0;
        DataBytesToBeSent  = 0;
        ParamBytesToBeSent = 0;
        ParamDisplacement = 0;
        pLastMdlInChain    = pSecondaryRequestSmbMdl;

        ParamOffset = DataOffset = SecondaryRequestSmbSize;

        ParamBytesToBeSent = MIN((MaximumSmbBufferSize - ParamOffset),
                               SendParamBufferSize);

        if (ParamBytesToBeSent > 0) {
            // Form a MDL for the portion of the parameter buffer being transmitted
            if (ParamPartialMdlAlreadyUsed) {
                MmPrepareMdlForReuse(pPartialParamMdl);
            }

            ParamPartialMdlAlreadyUsed = TRUE;
            IoBuildPartialMdl(
                pTransactExchange->pSendParamMdl,
                pPartialParamMdl,
                pSendParamStartAddress,
                ParamBytesToBeSent);

            ParamDisplacement  = (ULONG)(pSendParamStartAddress - pOriginalParamBuffer);
            pSendParamStartAddress  += ParamBytesToBeSent;
            SendParamBufferSize     -= ParamBytesToBeSent;
            DataOffset              += QuadAlign(ParamBytesToBeSent);

            pLastMdlInChain->Next = pPartialParamMdl;
            pLastMdlInChain = pPartialParamMdl;
        } else {
            // don't do this! the padding stuff uses it. you can set it later
            // ParamOffset = 0;
        }

        if ((DataOffset < MaximumSmbBufferSize) && (SendDataBufferSize > 0) ) {
            // There is room for data bytes to be sent
            // Check if we need a padding MDL ....
            PaddingLength = DataOffset - (ParamOffset + ParamBytesToBeSent);

            if (PaddingLength > 0) {
                RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: Padding Length %ld\n",PaddingLength));
                RxBuildPaddingPartialMdl(pPaddingMdl,PaddingLength);
                pLastMdlInChain->Next = pPaddingMdl;
                pLastMdlInChain = pPaddingMdl;
            }

            // Link the data buffer or portions of it if the size constraints are satisfied
            DataBytesToBeSent = MIN((MaximumSmbBufferSize - DataOffset),
                                  SendDataBufferSize);
            ASSERT (DataBytesToBeSent > 0);

            // Form a MDL for the portions of the data buffer being sent
            if (DataPartialMdlAlreadyUsed) {
                MmPrepareMdlForReuse(pPartialDataMdl);
            }

            DataPartialMdlAlreadyUsed = TRUE;
            IoBuildPartialMdl(
                pTransactExchange->pSendDataMdl,
                pPartialDataMdl,
                pSendDataStartAddress,
                DataBytesToBeSent);

            //  chain the data MDL
            pLastMdlInChain->Next = pPartialDataMdl;
            pLastMdlInChain = pPartialDataMdl;

            DataDisplacement  = (ULONG)(pSendDataStartAddress - pOriginalDataBuffer);
            pSendDataStartAddress   += DataBytesToBeSent;
            SendDataBufferSize      -= DataBytesToBeSent;
        } else {
            DataOffset = DataDisplacement  = 0;
            DbgDoit(if (SmbSendBadSecondary){DataOffset = QuadAlign(ParamOffset + ParamBytesToBeSent);});
        }

        if (ParamBytesToBeSent == 0) {
            ParamOffset = 0;
        }

        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Secondary Request Param(%ld) padding(%ld) Data(%ld)\n",
                            ParamBytesToBeSent,
                            PaddingLength,
                            DataBytesToBeSent));
        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests:  ParamO(%ld) DataO(%ld)\n",ParamOffset,DataOffset));
        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests:  ParamD(%ld) DataD(%ld)\n",ParamDisplacement,DataDisplacement));
        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests:  TotParam(%ld) TotData(%ld)\n",TotalParamBytes,TotalDataBytes));

        // Update the secondary request buffer with the final sizes of the data/parameter etc.
        switch (pTransactExchange->TransactSmbCommand) {
        case SMB_COM_TRANSACTION:
        case SMB_COM_TRANSACTION2:
            {
                PREQ_TRANSACTION_SECONDARY pTransactRequest;

                //ASSERT(!"this has not been tested");

                pTransactRequest = (PREQ_TRANSACTION_SECONDARY)(pSecondaryRequestSmbHeader + 1);

                pTransactRequest->WordCount = 8;                                     // Count of parameter words = 8
                SmbPutUshort(&pTransactRequest->TotalParameterCount, (USHORT)TotalParamBytes); // Total parameter bytes being sent
                SmbPutUshort(&pTransactRequest->TotalDataCount, (USHORT)TotalDataBytes);      // Total data bytes being sent
                SmbPutUshort(&pTransactRequest->ParameterCount, (USHORT)ParamBytesToBeSent);   // Parameter bytes sent this buffer
                SmbPutUshort(&pTransactRequest->ParameterOffset, (USHORT)ParamOffset);          // Offset (from header start) to params
                SmbPutUshort(&pTransactRequest->ParameterDisplacement, (USHORT)ParamDisplacement);    // Displacement of these param bytes
                SmbPutUshort(&pTransactRequest->DataCount, (USHORT)DataBytesToBeSent);   // Parameter bytes sent this buffer
                SmbPutUshort(&pTransactRequest->DataOffset, (USHORT)DataOffset);               // Offset (from header start) to Datas
                SmbPutUshort(&pTransactRequest->DataDisplacement, (USHORT)DataDisplacement);   // Displacement of these Data bytes
                ByteCountOffset = FIELD_OFFSET(REQ_TRANSACTION_SECONDARY,ByteCount);
                if (pTransactExchange->TransactSmbCommand == SMB_COM_TRANSACTION2 ) {
                    //see CODE.IMPROVEMENT.ASHAMED above.......
                    ByteCountOffset += sizeof(USHORT);
                    pTransactRequest->WordCount++;  //one extra word
                    SmbPutUshort((&pTransactRequest->DataDisplacement)+1, 0); //the +1 is to move up 1 USHORT
                }
            }
            break;

        case SMB_COM_NT_TRANSACT:
            {
                PREQ_NT_TRANSACTION_SECONDARY pNtTransactRequest;

                pNtTransactRequest= (PREQ_NT_TRANSACTION_SECONDARY)(pSecondaryRequestSmbHeader + 1);

                //CODE.IMPROVEMENT this should be stufferized.....the whole thing should be.
                //                 (6/15 there are unimplemented things in the stuffer that'd make it hard

                //CODE.IMPROVEMENT move the constant things to the top
                //CODE.IMPROVEMENT you don't need the macros here because things are alinged.....put in asserts
                //                 actually, use the aligned stuff
                pNtTransactRequest->WordCount = 18;                                     // Count of parameter words = 18
                pNtTransactRequest->Reserved1 = 0;                                      // MBZ
                SmbPutUshort(&pNtTransactRequest->Reserved2, 0);                        // MBZ
                SmbPutUlong(&pNtTransactRequest->TotalParameterCount, TotalParamBytes); // Total parameter bytes being sent
                SmbPutUlong(&pNtTransactRequest->TotalDataCount, TotalDataBytes);      // Total data bytes being sent
                SmbPutUlong(&pNtTransactRequest->ParameterCount, ParamBytesToBeSent);   // Parameter bytes sent this buffer
                SmbPutUlong(&pNtTransactRequest->ParameterOffset, ParamOffset);          // Offset (from header start) to params
                SmbPutUlong(&pNtTransactRequest->ParameterDisplacement, ParamDisplacement);    // Displacement of these param bytes
                SmbPutUlong(&pNtTransactRequest->DataCount, DataBytesToBeSent);   // Parameter bytes sent this buffer
                SmbPutUlong(&pNtTransactRequest->DataOffset, DataOffset);               // Offset (from header start) to Datas
                SmbPutUlong(&pNtTransactRequest->DataDisplacement, DataDisplacement);   // Displacement of these Data bytes
                pNtTransactRequest->Reserved3 = 0;                                      // MBZ

                ByteCountOffset = FIELD_OFFSET(REQ_NT_TRANSACTION_SECONDARY,ByteCount);
            }
            break;

        default:
            ASSERT(!"Valid Smb Command for initiating Transaction");
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        // Send the secondary SMB
        SmbLength = SecondaryRequestSmbSize +
                    ParamBytesToBeSent +
                    PaddingLength +
                    DataBytesToBeSent;

        ByteCount = (USHORT)(SmbLength-(sizeof(SMB_HEADER)+ByteCountOffset+sizeof(USHORT)));
        pByteCount = (PUSHORT)((PBYTE)pSecondaryRequestSmbHeader+sizeof(SMB_HEADER)+ByteCountOffset);
        SmbPutUshort(pByteCount,ByteCount);

        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: len %d bytecount %d(%x)\n", SmbLength, ByteCount, ByteCount));
        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: msgmdl=%08lx\n", pSecondaryRequestSmbHeader));

        RxLog(("2nd: %lx %lx %lx %lx %lx %lx",ParamOffset,ParamDisplacement,TotalParamBytes,DataOffset,DataDisplacement,TotalDataBytes));
        RxLog(("2nd:: %lx %lx",ByteCount,SmbLength));
        SmbLog(LOG,
               SendSecondaryRequests,
               LOGULONG(ParamOffset)
               LOGULONG(ParamDisplacement)
               LOGULONG(TotalParamBytes)
               LOGULONG(DataOffset)
               LOGULONG(DataDisplacement)
               LOGULONG(TotalDataBytes)
               LOGXSHORT(ByteCount)
               LOGULONG(SmbLength));

        Status = SmbCeSend(
                     pExchange,
                     RXCE_SEND_SYNCHRONOUS,
                     pSecondaryRequestSmbMdl,
                     SmbLength);

        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: SmbCeSend returned %lx\n",Status));
        if ((Status != RX_MAP_STATUS(PENDING)) && (Status != RX_MAP_STATUS(SUCCESS))) {
            RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: SmbCeSend returned bad status %lx\n",Status));
            //here we should just get out
            goto FINALLY;    //yes we cold have said break....but that's not what we're doing
        } else {
            Status = RX_MAP_STATUS(SUCCESS);
        }
    }

FINALLY:
    if (pPartialDataMdl != NULL) {
        IoFreeMdl(pPartialDataMdl);
    }

    if (pActualSecondaryRequestSmbHeader != NULL) {
        RxFreePool(pActualSecondaryRequestSmbHeader);
    }

    if (pPartialParamMdl != NULL) {
        IoFreeMdl(pPartialParamMdl);
    }

    if (pPaddingMdl != NULL) {
        IoFreeMdl(pPaddingMdl);
    }

    if (pSecondaryRequestSmbMdl != NULL) {
        RxUnlockHeaderPages(pSecondaryRequestSmbMdl);
        IoFreeMdl(pSecondaryRequestSmbMdl);
    }

    //we always finalize......but we only set the status if there's an error or
    //                        we expect no response
    if ((Status != RX_MAP_STATUS(SUCCESS)) || (pTransactExchange->Flags & SMB_TRANSACTION_NO_RESPONSE )) {
        pExchange->Status = Status;

        if (!(pTransactExchange->Flags & SMB_TRANSACTION_NO_RESPONSE)) {
            SmbCeDecrementPendingReceiveOperations(pExchange);
        }
    }

    SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

    return Status;
}




SMB_EXCHANGE_DISPATCH_VECTOR
TransactExchangeDispatch = {
                            SmbTransactExchangeStart,
                            SmbTransactExchangeReceive,
                            SmbTransactExchangeCopyDataHandler,
                            NULL,                                  // SmbTransactExchangeSendCallbackHandler
                            SmbTransactExchangeFinalize,
                            NULL
                           };



#ifndef RX_NO_DBGFIELD_HLPRS

#define DECLARE_FIELD_HLPR(x) ULONG SmbPseTxeField_##x = FIELD_OFFSET(SMB_TRANSACT_EXCHANGE,x);
#define DECLARE_FIELD_HLPR2(x,y) ULONG SmbPseTxeField_##x##y = FIELD_OFFSET(SMB_TRANSACT_EXCHANGE,x.y);

DECLARE_FIELD_HLPR(RxContext);
DECLARE_FIELD_HLPR(ReferenceCount);
DECLARE_FIELD_HLPR(State);
DECLARE_FIELD_HLPR(pSendDataMdl);
DECLARE_FIELD_HLPR(pReceiveDataMdl);
DECLARE_FIELD_HLPR(pSendParamMdl);
DECLARE_FIELD_HLPR(pReceiveParamMdl);
DECLARE_FIELD_HLPR(pSendSetupMdl);
DECLARE_FIELD_HLPR(pReceiveSetupMdl);
DECLARE_FIELD_HLPR(PrimaryRequestSmbSize);
DECLARE_FIELD_HLPR(SmbCommand);
DECLARE_FIELD_HLPR(NtTransactFunction);
DECLARE_FIELD_HLPR(Flags);
DECLARE_FIELD_HLPR(Fid);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\transprt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    transport.c

Abstract:

    This module implements all transport related functions in the SMB connection engine

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995
    Will Lees (wlees) 08-Sep-1997     Initialize MoTcp Device

Notes:


--*/

#include "precomp.h"
#include <nbtioctl.h>
#pragma hdrstop

#include "ntddbrow.h"
#include "tdikrnl.h"
#include "dfsfsctl.h"

NTSTATUS
SmbCeIsServerAvailable(
    PUNICODE_STRING Name
);

VOID
SmbCeServerIsUnavailable(
    PUNICODE_STRING Name,
    NTSTATUS Status
);

VOID
SmbCeDiscardUnavailableServerList( );

VOID
MRxSmbpOverrideBindingPriority(
    PUNICODE_STRING pTransportName,
    PULONG pPriority
    );

VOID
MRxSmbPnPBindingHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pTransportName,
    IN PWSTR            BindingList
    );

NTSTATUS
MRxSmbPnPPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
);

VOID
SmbMRxNotifyChangesToNetBt(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeFindTransport)
#pragma alloc_text(PAGE, SmbCepInitializeServerTransport)
#pragma alloc_text(PAGE, SmbCeInitializeExchangeTransport)
#pragma alloc_text(PAGE, SmbCeUninitializeExchangeTransport)
#pragma alloc_text(PAGE, SmbCepDereferenceTransport)
#pragma alloc_text(PAGE, MRxSmbpBindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbpBindTransportWorkerThreadRoutine)
#pragma alloc_text(PAGE, MRxSmbBindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbUnbindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbRegisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxSmbDeregisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxSmbpBindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbpBindTransportWorkerThreadRoutine)
#pragma alloc_text(PAGE, MRxSmbpUnbindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbpOverrideBindingPriority)
#pragma alloc_text(PAGE, MRxSmbPnPBindingHandler)
#pragma alloc_text(PAGE, MRxSmbRegisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxSmbDeregisterForPnpNotifications)
#pragma alloc_text(PAGE, SmbCePnpBindBrowser)
#pragma alloc_text(PAGE, SmbCeDereferenceTransportArray)
#pragma alloc_text(PAGE, SmbCeIsServerAvailable)
#pragma alloc_text(PAGE, SmbCeServerIsUnavailable)
#pragma alloc_text(PAGE, SmbCeDiscardUnavailableServerList)
#endif

SMBCE_TRANSPORTS MRxSmbTransports;

//
// The head of the list of servers that are currently unavailable
//
LIST_ENTRY UnavailableServerList = { &UnavailableServerList, &UnavailableServerList };

//
// Each entry in the UnavailableServerList is one of these:
//
typedef struct {
    LIST_ENTRY ListEntry;
    UNICODE_STRING Name;        // Name of server that is unavailable
    NTSTATUS Status;            // Status received when we tried to connect to it
    LARGE_INTEGER Time;         // Time when we last attempted to connect
} *PUNAVAILABLE_SERVER;

//
// Protects UnavailableServerList
//
ERESOURCE  UnavailableServerListResource = {0};

//
// Time (seconds) that we keep an entry in the UnavailableServerList.
// We will not retry a connection attempt to a server
//  for UNAVAILABLE_SERVER_TIME seconds
//
#define UNAVAILABLE_SERVER_TIME 10

RXDT_DefineCategory(TRANSPRT);
#define Dbg        (DEBUG_TRACE_TRANSPRT)

extern NTSTATUS
SmbCePnpBindBrowser(
    PUNICODE_STRING pTransportName,
    BOOLEAN         IsBind);


NTSTATUS
MRxSmbInitializeTransport()
/*++

Routine Description:

    This routine initializes the transport related data structures

Returns:

    STATUS_SUCCESS if the transport data structures was successfully initialized

Notes:

--*/
{
    KeInitializeSpinLock(&MRxSmbTransports.Lock);

    MRxSmbTransports.pTransportArray = NULL;

    ExInitializeResource( &UnavailableServerListResource );

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbUninitializeTransport()
/*++

Routine Description:

    This routine uninitializes the transport related data structures

Notes:

--*/
{
    PSMBCE_TRANSPORT pTransport;
    KIRQL            SavedIrql;
    ULONG            TransportCount = 0;
    PSMBCE_TRANSPORT_ARRAY pTransportArray = NULL;

    KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

    if (MRxSmbTransports.pTransportArray != NULL) {
        pTransportArray = MRxSmbTransports.pTransportArray;
        MRxSmbTransports.pTransportArray = NULL;
    }

    KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

    if (pTransportArray != NULL) {
        SmbCeDereferenceTransportArray(pTransportArray);
    }

    SmbCeDiscardUnavailableServerList();

    ExDeleteResource( &UnavailableServerListResource );

    return STATUS_SUCCESS;
}


NTSTATUS
SmbCeAddTransport(
    PSMBCE_TRANSPORT pNewTransport)
/*++

Routine Description:

    This routine adds a new instance to the known list of transports

Parameters:

    pNewTransport -- the transport instance to be added

Notes:

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    KIRQL                   SavedIrql;

    LONG                    Count;
    PSMBCE_TRANSPORT_ARRAY  pNewTransportArray = NULL;
    PSMBCE_TRANSPORT_ARRAY  pOldTransportArray;
    PSMBCE_TRANSPORT        *pTransports = NULL;
    PRXCE_ADDRESS           *LocalAddresses = NULL;
    BOOLEAN                 SignalCscAgent = FALSE;

    SmbCeAcquireResource();

    pOldTransportArray = SmbCeReferenceTransportArray();

    if (pOldTransportArray != NULL)
        Count = pOldTransportArray->Count + 1;
    else
        Count = 1;

    pNewTransportArray = (PSMBCE_TRANSPORT_ARRAY)RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(SMBCE_TRANSPORT_ARRAY),
                                MRXSMB_TRANSPORT_POOLTAG);
    if (pNewTransportArray == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        pTransports = (PSMBCE_TRANSPORT *)RxAllocatePoolWithTag(
                             NonPagedPool,
                             Count * sizeof(PSMBCE_TRANSPORT),
                             MRXSMB_TRANSPORT_POOLTAG);
        if (pTransports == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    if (Status == STATUS_SUCCESS) {
        LocalAddresses = (PRXCE_ADDRESS *)RxAllocatePoolWithTag(
                             NonPagedPool,
                             Count * sizeof(PRXCE_ADDRESS),
                             MRXSMB_TRANSPORT_POOLTAG);
        if (LocalAddresses == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (Status == STATUS_SUCCESS) {
        LONG  i;

        if (Count > 1) {
            PSMBCE_TRANSPORT *pOldTransports;

            pOldTransports = pOldTransportArray->SmbCeTransports;

            for (i=0;i<Count-1;i++) {
                if (pNewTransport->Priority < pOldTransports[i]->Priority) { // The lower number, the higher priority
                    break;
                }
                pTransports[i] = pOldTransports[i];
                LocalAddresses[i] = &pOldTransports[i]->RxCeAddress;
            }
            pTransports[i] = pNewTransport;
            LocalAddresses[i] = &pNewTransport->RxCeAddress;
            for (;i<Count-1;i++) {
                pTransports[i+1] = pOldTransports[i];
                LocalAddresses[i+1] = &pOldTransports[i]->RxCeAddress;
            }

        } else {
            pTransports[0] = pNewTransport;
            LocalAddresses[0] = &pNewTransport->RxCeAddress;
        }

        for(i=0;i<Count;i++)
            SmbCeReferenceTransport(pTransports[i]);

        pNewTransportArray->ReferenceCount = 1;
        pNewTransportArray->Count = Count;
        pNewTransportArray->SmbCeTransports = &pTransports[0];
        pNewTransportArray->LocalAddresses = &LocalAddresses[0];

        // signal the CSC agent if this is the first transport
        SignalCscAgent = (pNewTransportArray->Count == 1);

        KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);
        MRxSmbTransports.pTransportArray = pNewTransportArray;
        KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

        // Double dereferencing is necessary to ensure that
        // the old transport array is destroyed.

        SmbCeDereferenceTransportArray(pOldTransportArray);
    }

    SmbCeDereferenceTransportArray(pOldTransportArray);

    SmbCeReleaseResource();

    MRxSmbCscSignalNetStatus(TRUE, SignalCscAgent);

    if (Status != STATUS_SUCCESS) {
        if (pNewTransportArray != NULL) {
            RxFreePool(pNewTransportArray);
        }
        if (pTransports != NULL) {
            RxFreePool(pTransports);
        }
        if (LocalAddresses != NULL) {
            RxFreePool(LocalAddresses);
        }
    }

    SmbCeDiscardUnavailableServerList();

    return Status;
}

NTSTATUS
SmbCeRemoveTransport(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine removes a transport from the list of known transports

Parameters:

    pTransport - the transport instance to be removed.

Notes:

--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    KIRQL                   SavedIrql;

    LONG                    Count;
    PSMBCE_TRANSPORT_ARRAY  pTransportArray = NULL;
    PSMBCE_TRANSPORT_ARRAY  pOldTransportArray = NULL;
    PSMBCE_TRANSPORT        *pTransports = NULL;
    PRXCE_ADDRESS           *pLocalAddresses = NULL;

    BOOLEAN                 SignalCscAgent = FALSE, fReportRemovalToCSC=FALSE;

    SmbCeAcquireResource();

    pOldTransportArray = SmbCeReferenceTransportArray();

    if (pOldTransportArray != NULL) {
        LONG                Index;
        BOOLEAN             Found = FALSE;
        PSMBCE_TRANSPORT    *pOldTransports;

        // Establish the fact that the given transport is part of the array.
        // if it is not then no further action is necessary

        pOldTransports = pOldTransportArray->SmbCeTransports;

        for (Index = 0; Index < (LONG)pOldTransportArray->Count; Index++) {
            if (pTransport == pOldTransports[Index]) {
                Found = TRUE;
            }
        }

        if (Found) {
            Count = pOldTransportArray->Count - 1;
            fReportRemovalToCSC = (pOldTransportArray->Count != 0);

            if (Count > 0) {


                pTransportArray = (PSMBCE_TRANSPORT_ARRAY)RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     sizeof(SMBCE_TRANSPORT_ARRAY),
                                     MRXSMB_TRANSPORT_POOLTAG);
                if (pTransportArray == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                if (Status == STATUS_SUCCESS) {
                    pTransports = (PSMBCE_TRANSPORT *)RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     Count * sizeof(PSMBCE_TRANSPORT),
                                     MRXSMB_TRANSPORT_POOLTAG);
                    if (pTransports == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (Status == STATUS_SUCCESS) {
                    pLocalAddresses = (PRXCE_ADDRESS *)RxAllocatePoolWithTag(
                                         NonPagedPool,
                                         Count * sizeof(PRXCE_ADDRESS),
                                         MRXSMB_TRANSPORT_POOLTAG);
                    if (pLocalAddresses == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (Status == STATUS_SUCCESS) {
                    LONG i, j;

                    for (i=0, j=0;i<Count+1;i++) {
                        if (pTransport != pOldTransports[i]) {
                            pTransports[j] = pOldTransports[i];
                            pLocalAddresses[j] = &pOldTransports[i]->RxCeAddress;
                            j++;
                        }
                    }

                    for(i=0;i<Count;i++)
                        SmbCeReferenceTransport(pTransports[i]);

                    pTransportArray->ReferenceCount = 1;
                    pTransportArray->Count = Count;
                    pTransportArray->SmbCeTransports = &pTransports[0];
                    pTransportArray->LocalAddresses = &pLocalAddresses[0];
                }
            }

            if (Status == STATUS_SUCCESS) {
                // signal the CSC agent if this is the last transport
                SignalCscAgent = (pTransportArray == NULL);

                KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);
                MRxSmbTransports.pTransportArray = pTransportArray;
                KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

                // Double dereferencing is necessary to ensure that
                // the old transport array is destroyed.

                SmbCeDereferenceTransportArray(pOldTransportArray);
            } else {
                if (pTransportArray != NULL) {
                    RxFreePool(pTransportArray);
                }

                if (pTransports != NULL) {
                    RxFreePool(pTransports);
                }

                if (pLocalAddresses != NULL) {
                    RxFreePool(pLocalAddresses);
                }
            }
        }

        SmbCeDereferenceTransportArray(pOldTransportArray);
    }

    SmbCeReleaseResource();

    if (fReportRemovalToCSC)
    {
        MRxSmbCscSignalNetStatus(FALSE, SignalCscAgent);
    }

    SmbCeDiscardUnavailableServerList();

    return Status;
}


PSMBCE_TRANSPORT
SmbCeFindTransport(
    PUNICODE_STRING pTransportName)
/*++

Routine Description:

    This routine maps a transport name to the appropriate
    PSMBCE_TRANSPORT instance

Arguments:

    pTransportName - the transport name

Return Value:

    a valid PSMBCE_TRANSPORT if one exists otherwise NULL

Notes:

--*/
{
    KIRQL                   SavedIrql;
    PLIST_ENTRY             pEntry;
    PSMBCE_TRANSPORT        pTransport;
    BOOLEAN                 Found = FALSE;
    PSMBCE_TRANSPORT_ARRAY  pTransportArray;

    PAGED_CODE();

    pTransportArray = SmbCeReferenceTransportArray();

    if (pTransportArray == NULL) {
        RxDbgTrace(0, Dbg, ("SmbCeFindTransport : Transport not available.\n"));
        return NULL;
    }

    if (pTransportArray != NULL) {
        ULONG i;

        for (i=0;i<pTransportArray->Count;i++) {
            pTransport = pTransportArray->SmbCeTransports[i];

            if (RtlEqualUnicodeString(
                    &pTransport->RxCeTransport.Name,
                    pTransportName,
                    TRUE)) {
                SmbCeReferenceTransport(pTransport);
                Found = TRUE;
                break;
            }
        }
    }

    if (!Found) {
        pTransport = NULL;
    }

    SmbCeDereferenceTransportArray(pTransportArray);

    return pTransport;
}


VOID
SmbCepTearDownServerTransport(
    PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine uninitializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Notes:


--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SMBCEDB_SERVER_TYPE     ServerType   = SmbCeGetServerType(pServerEntry);

    BOOLEAN WaitForMailSlotTransportRundown = FALSE;
    BOOLEAN WaitForTransportRundown = FALSE;
    BOOLEAN TearDown = FALSE;

    SmbCeAcquireSpinLock();

    if (!pServerEntry->IsTransportDereferenced) {

        // ServerEntry takes only one reference count of transport, which should only be
        // dereferenced once when it comes to tear down transport. Multiple dereference called
        // from construct server transport and PNP unbind transport needs to be prevented.
        pServerEntry->IsTransportDereferenced = TRUE;
        TearDown = TRUE;

        KeInitializeEvent(&pServerEntry->MailSlotTransportRundownEvent,NotificationEvent,FALSE);
        KeInitializeEvent(&pServerEntry->TransportRundownEvent,NotificationEvent,FALSE);

        if (pServerEntry->pTransport != NULL) {
            pServerEntry->pTransport->State = SMBCEDB_MARKED_FOR_DELETION;
            pServerEntry->pTransport->pRundownEvent = &pServerEntry->TransportRundownEvent;

            WaitForTransportRundown = TRUE;
        }

        if (pServerEntry->pMailSlotTransport != NULL) {
            pServerEntry->pMailSlotTransport->State = SMBCEDB_MARKED_FOR_DELETION;
            pServerEntry->pMailSlotTransport->pRundownEvent = &pServerEntry->MailSlotTransportRundownEvent;

            WaitForMailSlotTransportRundown = TRUE;
        }
    } else {
        if (pServerEntry->pTransport != NULL) {
            WaitForTransportRundown = TRUE;
        }

        if (pServerEntry->pMailSlotTransport != NULL) {
            WaitForMailSlotTransportRundown = TRUE;
        }
    }

    SmbCeReleaseSpinLock();

    if (TearDown) {
        if (pServerEntry->pTransport != NULL) {
            SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
        }

        if (pServerEntry->pMailSlotTransport != NULL) {
            SmbCeDereferenceServerTransport(&pServerEntry->pMailSlotTransport);
        }
    }

    if (WaitForTransportRundown) {
        KeWaitForSingleObject(
            &pServerEntry->TransportRundownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL );
    }

    if (WaitForMailSlotTransportRundown) {
        KeWaitForSingleObject(
            &pServerEntry->MailSlotTransportRundownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL );
    }
}

VOID
SmbCeTearDownServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine tears down the server transport instance

Arguments:

    pContext - the server transport construction context

Notes:


--*/
{
    SmbCepTearDownServerTransport(pContext->pServerEntry);

    if (pContext->pCompletionEvent != NULL) {
        ASSERT(pContext->pCallbackContext == NULL);
        ASSERT(pContext->pCompletionRoutine == NULL);
        KeSetEvent(
            pContext->pCompletionEvent,
            0,
            FALSE );
    } else if (pContext->pCallbackContext != NULL) {
        ASSERT(pContext->pCompletionEvent == NULL);
        (pContext->pCompletionRoutine)(pContext->pCallbackContext);
    }

    RxFreePool(pContext);
}

VOID
SmbCepUpdateTransportConstructionState(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
{
    SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE State;

    if (pContext->Status == STATUS_SUCCESS) {
        if (pContext->TransportsToBeConstructed & SMBCE_STT_MAILSLOT) {
            pContext->TransportsToBeConstructed &= ~SMBCE_STT_MAILSLOT;
            State = SmbCeServerMailSlotTransportConstructionBegin;
        } else if (pContext->TransportsToBeConstructed & SMBCE_STT_VC) {
            pContext->TransportsToBeConstructed &= ~SMBCE_STT_VC;
            State = SmbCeServerVcTransportConstructionBegin;
        } else {
            State = SmbCeServerTransportConstructionEnd;
        }
    } else {
        State = SmbCeServerTransportConstructionEnd;
    }

    pContext->State = State;
}

VOID
SmbCeConstructServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine constructs the server transport instance

Arguments:

    pContext - the server transport construction context

Notes:


--*/
{
    NTSTATUS               Status;
    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    SMBCEDB_SERVER_TYPE    ServerType;

    BOOLEAN  ContinueConstruction = TRUE;
    BOOLEAN  UpdateUnavailableServerlist = TRUE;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pServerEntry = pContext->pServerEntry;
    ServerType   = SmbCeGetServerType(pServerEntry);

    do {
        switch (pContext->State) {
        case  SmbCeServerTransportConstructionBegin :
            {
                if ((pServerEntry->pTransport != NULL) ||
                    (pServerEntry->pMailSlotTransport != NULL)) {
                    SmbCepTearDownServerTransport(pServerEntry);
                }

                ASSERT((pServerEntry->pTransport == NULL) &&
                       (pServerEntry->pMailSlotTransport == NULL));

                pContext->Status = STATUS_SUCCESS;

                // See if we have any reason to believe this server is unavailable
                pContext->Status = SmbCeIsServerAvailable( &pServerEntry->Name );

                if (pContext->Status != STATUS_SUCCESS) {
                    UpdateUnavailableServerlist = FALSE;
                }

                SmbCepUpdateTransportConstructionState(pContext);
            }
            break;

        case SmbCeServerMailSlotTransportConstructionBegin:
            {
                Status = MsInstantiateServerTransport(
                            pContext);

                if (Status == STATUS_PENDING) {
                    ContinueConstruction = FALSE;
                    break;
                }

                ASSERT(pContext->State == SmbCeServerMailSlotTransportConstructionEnd);
            }
            // lack of break intentional

        case SmbCeServerMailSlotTransportConstructionEnd:
            {
                SmbCepUpdateTransportConstructionState(pContext);
            }
            break;

        case SmbCeServerVcTransportConstructionBegin:
            {
                Status = VctInstantiateServerTransport(
                            pContext);

                if (Status == STATUS_PENDING) {
                    ContinueConstruction = FALSE;
                    break;
                }

                ASSERT(pContext->State == SmbCeServerVcTransportConstructionEnd);
            }
            // lack of break intentional

        case SmbCeServerVcTransportConstructionEnd:
            {
                SmbCepUpdateTransportConstructionState(pContext);
            }
            break;

        case SmbCeServerTransportConstructionEnd:
            {
                pServerEntry->ServerStatus = pContext->Status;

                if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                    SmbCeAcquireSpinLock();

                    ASSERT(pContext->pMailSlotTransport != NULL);
                    pContext->pMailSlotTransport->SwizzleCount = 1;

                    if (pContext->pTransport != NULL) {
                        pContext->pTransport->SwizzleCount = 1;
                    }

                    pServerEntry->pTransport         = pContext->pTransport;
                    pServerEntry->pMailSlotTransport = pContext->pMailSlotTransport;

                    pContext->pTransport = NULL;
                    pContext->pMailSlotTransport = NULL;

                    if (pContext->pCallbackContext != NULL) {
                        pContext->pCallbackContext->Status = STATUS_SUCCESS;
                    }

                    pServerEntry->IsTransportDereferenced = FALSE;
                    pServerEntry->SecuritySignaturesActive = FALSE;
                    pServerEntry->SecuritySignaturesEnabled = FALSE;

                    SmbCeReleaseSpinLock();
                } else {
                    PRX_CONTEXT pRxContext =  NULL;

                    if (UpdateUnavailableServerlist &&
                        !pServerEntry->Server.IsRemoteBootServer &&
                        (pServerEntry->PreferredTransport == NULL)) {
                        // In remote boot or specific transport cases, we don't add it to
                        // the list so that no negative caching is introduced.
                        SmbCeServerIsUnavailable( &pServerEntry->Name, pServerEntry->ServerStatus );
                    }

                    if (pContext->pMailSlotTransport != NULL) {
                        pContext->pMailSlotTransport->pDispatchVector->TearDown(
                            pContext->pMailSlotTransport);
                    }

                    if (pContext->pTransport != NULL) {
                        pContext->pTransport->pDispatchVector->TearDown(
                            pContext->pTransport);
                    }

                    pContext->pTransport = NULL;
                    pContext->pMailSlotTransport = NULL;

                    pServerEntry->pTransport         = NULL;
                    pServerEntry->pMailSlotTransport = NULL;

                    if ((pContext->pCallbackContext) &&
                        (pContext->pCallbackContext->SrvCalldownStructure)) {
                        pRxContext =
                            pContext->pCallbackContext->SrvCalldownStructure->RxContext;
                    }

                    Status = CscTransitionServerEntryForDisconnectedOperation(
                                 pServerEntry,
                                 pRxContext,
                                 pServerEntry->ServerStatus,
                                 TRUE   // to autodial or not to autodial
                                );

                    if (pContext->pCallbackContext != NULL) {
                        pContext->pCallbackContext->Status = Status;
                    }

                    if (SmbCeIsServerInDisconnectedMode(pServerEntry)) {
                        pServerEntry->ServerStatus = STATUS_SUCCESS;
                    }
                    else
                    {
                        pServerEntry->ServerStatus = Status;
                    }
                }

                if (pContext->pCompletionEvent != NULL) {
                    ASSERT(pContext->pCallbackContext == NULL);
                    ASSERT(pContext->pCompletionRoutine == NULL);
                    KeSetEvent(
                        pContext->pCompletionEvent,
                        0,
                        FALSE );
                } else if (pContext->pCallbackContext != NULL) {
                    ASSERT(pContext->pCompletionEvent == NULL);

                    (pContext->pCompletionRoutine)(pContext->pCallbackContext);
                } else {
                    ASSERT(!"ill formed transport initialization context");
                }

                if (pContext->WorkQueueItem.List.Flink != NULL) {
                    //DbgBreakPoint();
                }

                // pServerEntry->ConstructionContext = NULL;
                RxFreePool(pContext);

                ContinueConstruction = FALSE;
            }
        }
    } while (ContinueConstruction);
}

NTSTATUS
SmbCepInitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                         pServerEntry,
    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK pCallbackRoutine,
    PMRX_SRVCALL_CALLBACK_CONTEXT                 pCallbackContext,
    ULONG                                         TransportsToBeConstructed)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

    pCallbackRoutine - the callback routine

    pCallbackContext - the callback context

    TransportsToBeConstructed -- the transports to be constructed

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Currently, only connection oriented transports are handled.

--*/
{
    NTSTATUS Status;

    BOOLEAN  CompleteConstruction;

    PAGED_CODE();

    if ((pServerEntry->ServerStatus == STATUS_SUCCESS) &&
        (pServerEntry->pTransport != NULL) &&
        (pServerEntry->pMailSlotTransport != NULL)) {
        Status = STATUS_SUCCESS;
        CompleteConstruction = TRUE;
    } else {
        PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext;

        pContext = RxAllocatePoolWithTag(
                       NonPagedPool,
                       sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT),
                       MRXSMB_TRANSPORT_POOLTAG);

        CompleteConstruction = (pContext == NULL);

        if (pContext != NULL) {
            KEVENT  CompletionEvent;

            RtlZeroMemory(
                pContext,
                sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT));

            pContext->Status             = STATUS_SUCCESS;
            pContext->pServerEntry       = pServerEntry;
            pContext->State              = SmbCeServerTransportConstructionBegin;
            pContext->TransportsToBeConstructed = TransportsToBeConstructed;

            if (pCallbackContext == NULL) {
                KeInitializeEvent(
                    &CompletionEvent,
                    NotificationEvent,
                    FALSE);

                pContext->pCompletionEvent = &CompletionEvent;
            } else {
                pContext->pCallbackContext   = pCallbackContext;
                pContext->pCompletionRoutine = pCallbackRoutine;
            }

            pServerEntry->ConstructionContext = (PVOID)pContext;

            Status = STATUS_PENDING;

            // always post to a worker thread. This is to avaoid the problem of
            // a thread in system process that is impersonating for a non-admin user
            // When this happens, the thread gets access denied while opening a transport
            // handle

            Status = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         &pContext->WorkQueueItem,
                         SmbCeConstructServerTransport,
                         pContext);

            if (Status == STATUS_SUCCESS) {
                Status = STATUS_PENDING;
            } else {
                pServerEntry->ConstructionContext = NULL;
                RxFreePool(pContext);
                CompleteConstruction = TRUE;
            }

            if ((Status == STATUS_PENDING) && (pCallbackContext == NULL)) {
                KeWaitForSingleObject(
                    &CompletionEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL );

                Status = pServerEntry->ServerStatus;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (CompleteConstruction) {
        pServerEntry->ServerStatus = Status;

        if (pCallbackRoutine != NULL) {
            pCallbackContext->Status = Status;

            (pCallbackRoutine)(pCallbackContext);

            Status = STATUS_PENDING;
        }
    }

    return Status;
}

NTSTATUS
SmbCeUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                        pServerEntry,
    PSMBCE_SERVER_TRANSPORT_DESTRUCTION_CALLBACK pCallbackRoutine,
    PVOID                                        pCallbackContext)
/*++

Routine Description:

    This routine uninitializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Returns:

    STATUS_SUCCESS if successful

Notes:

    Currently, only connection oriented transports are handled.

    In order to handle async. operations the uninitialization has to be coordinated
    with the referencing mechanism. It is for this reason that this routine sets up
    a rundown event and waits for it to be set.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if (pCallbackRoutine == NULL &&
        IoGetCurrentProcess() == RxGetRDBSSProcess()) {
        SmbCepTearDownServerTransport(pServerEntry);
    } else {
        PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext;

        pContext = RxAllocatePoolWithTag(
                       NonPagedPool,
                       sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT),
                       MRXSMB_TRANSPORT_POOLTAG);

        if (pContext != NULL) {
            KEVENT  CompletionEvent;

            RtlZeroMemory(
                pContext,
                sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT));

            pContext->Status = STATUS_SUCCESS;
            pContext->pServerEntry = pServerEntry;

            if (pCallbackRoutine == NULL) {
                KeInitializeEvent(
                    &CompletionEvent,
                    NotificationEvent,
                    FALSE);

                pContext->pCompletionEvent = &CompletionEvent;
            } else {
                pContext->pCallbackContext   = pCallbackContext;
                pContext->pCompletionRoutine = pCallbackRoutine;
            }

            if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                SmbCeTearDownServerTransport(pContext);
            } else {
                Status = RxPostToWorkerThread(
                             MRxSmbDeviceObject,
                             CriticalWorkQueue,
                             &pContext->WorkQueueItem,
                             SmbCeTearDownServerTransport,
                             pContext);
            }

            if (Status == STATUS_SUCCESS) {
                if (pCallbackRoutine == NULL) {
                    KeWaitForSingleObject(
                        &CompletionEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL );
                } else {
                    Status = STATUS_PENDING;
                }
            } else {
                RxFreePool(pContext);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return Status;
}

VOID
SmbCeCompleteUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
    // in case of async uninitialize server transport, an additional reference count of
    // server entry should be taken so that uninitialize server transport will not be
    // called once again from tear down server entry if its reference count comes to 0
    // before uninitialize server transport is done.
    SmbCeDereferenceServerEntry(pServerEntry);
}

NTSTATUS
SmbCeInitiateDisconnect(
    PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine initiates the TDI disconnect

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMBCE_SERVER_TRANSPORT pTransport;
    PSMBCE_SERVER_TRANSPORT pMailSlotTransport;

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    Status = SmbCeReferenceServerTransport(&pServerEntry->pTransport);

    if (Status == STATUS_SUCCESS) {
        Status = (pServerEntry->pTransport->pDispatchVector->InitiateDisconnect)(
                    pServerEntry->pTransport);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("SmbCeInitiateDisconnect : Status %lx\n",Status));
        }

        SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
    }

    Status = SmbCeReferenceServerTransport(&pServerEntry->pMailSlotTransport);

    if (Status == STATUS_SUCCESS) {
        Status = (pServerEntry->pMailSlotTransport->pDispatchVector->InitiateDisconnect)(
                    pServerEntry->pMailSlotTransport);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("SmbCeInitiateDisconnect MS : Status %lx\n",Status));
        }

        SmbCeDereferenceServerTransport(&pServerEntry->pMailSlotTransport);
    }

    return STATUS_SUCCESS;
}

LONG Initializes[SENTINEL_EXCHANGE] = {0,0,0,0,0};
LONG Uninitializes[SENTINEL_EXCHANGE] = {0,0,0,0,0};

NTSTATUS
SmbCeInitializeExchangeTransport(
   PSMB_EXCHANGE         pExchange)
/*++

Routine Description:

    This routine initializes the transport associated with the exchange

Arguments:

    pExchange - the exchange to be initialized

Return Value:

    STATUS_SUCCESS - the exchange transport initialization has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    Status = pExchange->SmbStatus;
    if (Status == STATUS_SUCCESS) {
        PSMBCE_SERVER_TRANSPORT *pTransportPointer;

        if (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
            pTransportPointer = &pServerEntry->pMailSlotTransport;
        } else {
            pTransportPointer = &pServerEntry->pTransport;
        }

        if (*pTransportPointer != NULL) {
            Status = SmbCeReferenceServerTransport(pTransportPointer);

            if (Status == STATUS_SUCCESS) {
                Status = ((*pTransportPointer)->pDispatchVector->InitializeExchange)(
                             *pTransportPointer,
                             pExchange);

                if (Status == STATUS_SUCCESS) {
                    ULONG TransportInitialized;

                    InterlockedIncrement(&Initializes[pExchange->Type]);
                    TransportInitialized = InterlockedExchange(&pExchange->ExchangeTransportInitialized,1);
                    ASSERT(TransportInitialized == 0);
                } else {
                    SmbCeDereferenceServerTransport(pTransportPointer);
                }
            }
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
   }

   return Status;
}

NTSTATUS
SmbCeUninitializeExchangeTransport(
   PSMB_EXCHANGE         pExchange)
/*++

Routine Description:

    This routine uniinitializes the transport associated with the exchange

Arguments:

    pExchange - the exchange to be initialized

Return Value:

    STATUS_SUCCESS - the exchange transport initialization has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    if (InterlockedExchange(&pExchange->ExchangeTransportInitialized,0)==1) {
        PSMBCE_SERVER_TRANSPORT *pTransportPointer;

        if (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
            pTransportPointer = &pServerEntry->pMailSlotTransport;
        } else {
            pTransportPointer = &pServerEntry->pTransport;
        }

        if (*pTransportPointer != NULL) {
            Status = ((*pTransportPointer)->pDispatchVector->UninitializeExchange)(
                        *pTransportPointer,
                        pExchange);

            SmbCeDereferenceServerTransport(pTransportPointer);
            InterlockedIncrement(&Uninitializes[pExchange->Type]);

            return Status;
        } else {
            return STATUS_CONNECTION_DISCONNECTED;
        }
    } else {
        return pExchange->SmbStatus;
    }
}

NTSTATUS
SmbCepReferenceServerTransport(
    PSMBCE_SERVER_TRANSPORT *pServerTransportPointer)
/*++

Routine Description:

    This routine references the transport associated with a server entry

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport was successfully referenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SmbCeAcquireSpinLock();

    if (*pServerTransportPointer != NULL &&
        (*pServerTransportPointer)->State == SMBCEDB_ACTIVE) {
        InterlockedIncrement(&(*pServerTransportPointer)->SwizzleCount);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    SmbCeReleaseSpinLock();

    return Status;
}

NTSTATUS
SmbCepDereferenceServerTransport(
    PSMBCE_SERVER_TRANSPORT *pServerTransportPointer)
/*++

Routine Description:

    This routine dereferences the transport associated with a server entry

Arguments:

    pServerTransportPointer - the server entry transport instance pointer

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

    On finalization this routine sets the event to enable the process awaiting
    tear down to restart. It also tears down the associated server transport
    instance.

    As a side effect the pointer value is set to NULL under the protection of a
    spin lock.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SmbCeAcquireSpinLock();

    if (*pServerTransportPointer != NULL) {
        LONG    FinalRefCount;
        PKEVENT pRundownEvent;
        PSMBCE_SERVER_TRANSPORT pServerTransport;

        pServerTransport = *pServerTransportPointer;

        FinalRefCount = InterlockedDecrement(&pServerTransport->SwizzleCount);

        if (FinalRefCount == 0) {
            pServerTransport->State = SMBCEDB_INVALID;

            // transport is set to NULL before the spinlock is release so that no
            // exchange should reference it after it's been torn down
            *pServerTransportPointer = NULL;
            pRundownEvent = pServerTransport->pRundownEvent;
        }

        SmbCeReleaseSpinLock();

        if (FinalRefCount == 0) {
            if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                pServerTransport->pDispatchVector->TearDown(pServerTransport);
            } else {
                Status = RxDispatchToWorkerThread(
                             MRxSmbDeviceObject,
                             CriticalWorkQueue,
                             pServerTransport->pDispatchVector->TearDown,
                             pServerTransport);
            }
        }
    } else {
        SmbCeReleaseSpinLock();
        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    return Status;
}


NTSTATUS
SmbCepReferenceTransport(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine references the transport instance

Arguments:

    pTransport - the transport instance

Return Value:

    STATUS_SUCCESS - the server transport was successfully referenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (pTransport != NULL) {
        SmbCeAcquireSpinLock();

        if (pTransport->Active) {
            InterlockedIncrement(&pTransport->SwizzleCount);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        SmbCeReleaseSpinLock();
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
SmbCepDereferenceTransport(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine dereferences the transport

Arguments:

    pTransport - the transport instance

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AttachToSystemProcess = FALSE;
    KAPC_STATE ApcState;

    PAGED_CODE();

    if (pTransport != NULL) {
        LONG FinalRefCount;

        FinalRefCount = InterlockedDecrement(&pTransport->SwizzleCount);

        if (FinalRefCount == 0) {
            SmbCeRemoveTransport(pTransport);

            if (IoGetCurrentProcess() != RxGetRDBSSProcess()) {
                KeStackAttachProcess(RxGetRDBSSProcess(),&ApcState);
                AttachToSystemProcess = TRUE;
            }

            RxCeTearDownAddress(&pTransport->RxCeAddress);

            RxCeTearDownTransport(&pTransport->RxCeTransport);

            if (AttachToSystemProcess) {
                KeUnstackDetachProcess(&ApcState);
            }

            RxFreePool(pTransport);
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

#ifndef MRXSMB_PNP_POWER5

HANDLE MRxSmbTdiNotificationHandle = NULL;

VOID
MRxSmbpBindTransportCallback(
    IN PUNICODE_STRING pTransportName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport creates a new device object.

Arguments:

    DeviceName - the name of the newly created device object

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCE_TRANSPORT   pTransport;

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

    ULONG   Priority;
    BOOLEAN fBindToTransport = FALSE;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    // if this is one of the transports that is of interest to the SMB
    // mini rdr then register the address with it, otherwise skip it.

    if (SmbCeContext.Transports.Length != 0) {
        PWSTR          pSmbMRxTransports = (PWSTR)SmbCeContext.Transports.Buffer;
        UNICODE_STRING SmbMRxTransport;

        Priority = 1;
        while (*pSmbMRxTransports) {
            SmbMRxTransport.Length = wcslen(pSmbMRxTransports) * sizeof(WCHAR);

            if (SmbMRxTransport.Length == pTransportName->Length) {
                SmbMRxTransport.MaximumLength = SmbMRxTransport.Length;
                SmbMRxTransport.Buffer = pSmbMRxTransports;

                if (RtlCompareUnicodeString(
                       &SmbMRxTransport,
                       pTransportName,
                       TRUE) == 0) {
                    fBindToTransport = TRUE;
                    break;
                }
            }

            pSmbMRxTransports += (SmbMRxTransport.Length / sizeof(WCHAR) + 1);
            Priority++;
        }
    }

    if (!fBindToTransport) {
        return;
    }

    pTransport = RxAllocatePoolWithTag(
                     NonPagedPool,
                     sizeof(SMBCE_TRANSPORT),
                     MRXSMB_TRANSPORT_POOLTAG);

    if (pTransport != NULL) {
        Status = RxCeBuildTransport(
                     &pTransport->RxCeTransport,
                     pTransportName,
                     0xffff);

        if (Status == STATUS_SUCCESS) {
            PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

            pProviderInfo = pTransport->RxCeTransport.pProviderInfo;

            if (!(pProviderInfo->ServiceFlags & TDI_SERVICE_CONNECTION_MODE) ||
                !(pProviderInfo->ServiceFlags & TDI_SERVICE_ERROR_FREE_DELIVERY)) {
                RxCeTearDownTransport(
                    &pTransport->RxCeTransport);

                Status = STATUS_PROTOCOL_UNREACHABLE;

                RxFreePool(pTransport);
            }
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        // The connection capabilities match the capabilities required by the
        // SMB mini redirector. Attempt to register the local address with the
        // transport and if successful update the local transport list to include
        // this transport for future connection considerations.

        OEM_STRING   OemServerName;
        CHAR  TransportAddressBuffer[TDI_TRANSPORT_ADDRESS_LENGTH +
                          TDI_ADDRESS_LENGTH_NETBIOS];
        PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)TransportAddressBuffer;
        PTDI_ADDRESS_NETBIOS pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)pTransportAddress->Address[0].Address;

        pTransportAddress->TAAddressCount = 1;
        pTransportAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
        pTransportAddress->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
        pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        OemServerName.MaximumLength = NETBIOS_NAME_LEN;
        OemServerName.Buffer        = pNetbiosAddress->NetbiosName;

        Status = RtlUpcaseUnicodeStringToOemString(
                     &OemServerName,
                     &SmbCeContext.ComputerName,
                     FALSE);

        if (NT_SUCCESS(Status)) {
            // Ensure that the name is always of the desired length by padding
            // white space to the end.
            RtlCopyMemory(
                &OemServerName.Buffer[OemServerName.Length],
                "                ",
                NETBIOS_NAME_LEN - OemServerName.Length);

            OemServerName.Buffer[NETBIOS_NAME_LEN - 1] = '\0';

            // Register the Transport address for this mini redirector with the connection
            // engine.

            Status = RxCeBuildAddress(
                        &pTransport->RxCeAddress,
                        &pTransport->RxCeTransport,
                        pTransportAddress,
                        &MRxSmbVctAddressEventHandler,
                        &SmbCeContext);

            if (Status == STATUS_SUCCESS) {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Adding new transport\n"));

                pTransport->Active       = TRUE;
                pTransport->Priority     = Priority;
                pTransport->SwizzleCount = 0;

                pTransport->ObjectCategory = SMB_SERVER_TRANSPORT_CATEGORY;
                pTransport->ObjectType     = SMBCEDB_OT_TRANSPORT;
                pTransport->State          = 0;
                pTransport->Flags          = 0;

                // notify the browser about the transport
                Status = SmbCePnpBindBrowser(pTransportName, TRUE);

                // Add the transport to the list of transports
                if (Status == STATUS_SUCCESS) {
                    SmbCeAddTransport(pTransport);
                } else {
                    RxCeTearDownAddress(&pTransport->RxCeAddress);

                    MRxSmbLogTransportError(pTransportName,
                                            &SmbCeContext.DomainName,
                                            Status,
                                            EVENT_RDR_CANT_BIND_TRANSPORT);
                    SmbLogError(Status,
                                LOG,
                                MRxSmbpBindTransportCallback_1,
                                LOGULONG(Status)
                                LOGUSTR(*pTransportName));

                }
            } else {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Address registration failed %lx\n",Status));
                MRxSmbLogTransportError(pTransportName,
                                         &SmbCeContext.DomainName,
                                         Status,
                                         EVENT_RDR_CANT_REGISTER_ADDRESS);
                SmbLogError(Status,
                            LOG,
                            MRxSmbpBindTransportCallback_2,
                            LOGUSTR(*pTransportName));
            }
        }

        if (Status != STATUS_SUCCESS) {
            RxCeTearDownTransport(
                &pTransport->RxCeTransport);

            Status = STATUS_PROTOCOL_UNREACHABLE;
            RxFreePool(pTransport);
        }
    }
}

VOID
MRxSmbpBindTransportWorkerThreadRoutine(
    IN PUNICODE_STRING pTransportName)
{
    PAGED_CODE();

    MRxSmbpBindTransportCallback(pTransportName);

    RxFreePool(pTransportName);
}

VOID
MRxSmbBindTransportCallback(
    IN PUNICODE_STRING pTransportName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport creates a device object

Arguments:

    TransportName = the name of the deleted device object

--*/
{
    PAGED_CODE();

    if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
        MRxSmbpBindTransportCallback(pTransportName);
    } else {
        PUNICODE_STRING pNewTransportName;
        NTSTATUS Status;

        pNewTransportName = RxAllocatePoolWithTag(
                                PagedPool,
                                sizeof(UNICODE_STRING) + pTransportName->Length,
                                MRXSMB_TRANSPORT_POOLTAG);

        if (pNewTransportName != NULL) {
            pNewTransportName->MaximumLength = pTransportName->MaximumLength;
            pNewTransportName->Length = pTransportName->Length;
            pNewTransportName->Buffer = (PWCHAR)((PBYTE)pNewTransportName +
                                                  sizeof(UNICODE_STRING));

            RtlCopyMemory(
                pNewTransportName->Buffer,
                pTransportName->Buffer,
                pNewTransportName->Length);

            Status = RxDispatchToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         MRxSmbpBindTransportWorkerThreadRoutine,
                         pNewTransportName);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Status != RX_MAP_STATUS(SUCCESS)) {
            RxLog(("SmbCe Tdi Bind .Error %lx\n", Status));

            MRxSmbLogTransportError(pTransportName,
                                     &SmbCeContext.DomainName,
                                     Status,
                                     EVENT_RDR_CANT_BIND_TRANSPORT);
        }
    }
}

VOID
MRxSmbUnbindTransportCallback(
    IN PUNICODE_STRING pTransportName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport deletes a device object

Arguments:

    TransportName = the name of the deleted device object

--*/
{
    PSMBCE_TRANSPORT pTransport;

    PAGED_CODE();

    pTransport = SmbCeFindTransport(pTransportName);

    if (pTransport != NULL) {
        // notify the browser about the transport
        SmbCePnpBindBrowser(pTransportName, FALSE);

        // Remove this transport from the list of transports under consideration
        // in the mini redirector.
        SmbCeRemoveTransport(pTransport);

        // Enumerate the servers and mark those servers utilizing this transport
        // as having an invalid transport.
        SmbCeHandleTransportInvalidation(pTransport);

        // dereference the transport
        SmbCeDereferenceTransport(pTransport);
    }
}

NTSTATUS
MRxSmbRegisterForPnpNotifications()
/*++

Routine Description:

    This routine registers with TDI for receiving transport notifications

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(MRxSmbTdiNotificationHandle == NULL ) {
        Status = TdiRegisterNotificationHandler (
                     MRxSmbBindTransportCallback,
                     MRxSmbUnbindTransportCallback,
                     &MRxSmbTdiNotificationHandle );
    }

    return Status;
}

NTSTATUS
MRxSmbDeregisterForPnpNotifications()
/*++

Routine Description:

    This routine deregisters the TDI notification mechanism

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if( MRxSmbTdiNotificationHandle != NULL ) {
        Status = TdiDeregisterNotificationHandler( MRxSmbTdiNotificationHandle );

        if( NT_SUCCESS( Status ) ) {
            MRxSmbTdiNotificationHandle = NULL;
        }
    }

    return Status;
}

#else

HANDLE MRxSmbTdiNotificationHandle = NULL;

KEVENT TdiNetStartupCompletionEvent;

LONG   TdiBindRequestsActive = 0;

BOOLEAN TdiPnpNetReadyEventReceived = FALSE;

// The TRANSPORT_BIND_CONTEXT contains the result of the priority determination
// as well as the name. The priority is used to order the transports in the order
// in which connection attempts will be made

typedef struct _TRANSPORT_BIND_CONTEXT_ {
    ULONG           Priority;
    UNICODE_STRING  TransportName;
} TRANSPORT_BIND_CONTEXT, *PTRANSPORT_BIND_CONTEXT;

VOID
SmbCeSignalNetReadyEvent()
/*++

Routine Description:

    The routine signals the net ready event if all the bind requests
    have been completed and if the net ready event has been received from TDI

Arguments:

--*/
{
    BOOLEAN SignalNetReadyEvent = FALSE;

    SmbCeAcquireSpinLock();

    if (TdiPnpNetReadyEventReceived &&
        TdiBindRequestsActive == 0) {
        SignalNetReadyEvent = TRUE;
    }

    SmbCeReleaseSpinLock();

    if (SignalNetReadyEvent) {
        KeSetEvent(
            &TdiNetStartupCompletionEvent,
            IO_NETWORK_INCREMENT,
            FALSE);
    }
}

VOID
MRxSmbpBindTransportCallback(
    IN PTRANSPORT_BIND_CONTEXT pTransportContext)
/*++

Routine Description:

    TDI calls this routine whenever a transport creates a new device object.

Arguments:

    TransportName - the name of the newly created device object

    TransportBindings - the transport bindings ( multi sz)

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCE_TRANSPORT   pTransport;

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

    PUNICODE_STRING pTransportName;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pTransportName = &pTransportContext->TransportName;

    RxDbgTrace( 0, Dbg, ("MrxSmbpBindTransportCallback, Transport Name = %wZ\n", pTransportName ));

    pTransport = RxAllocatePoolWithTag(
                     NonPagedPool,
                     sizeof(SMBCE_TRANSPORT),
                     MRXSMB_TRANSPORT_POOLTAG);

    if (pTransport != NULL) {
        Status = RxCeBuildTransport(
                     &pTransport->RxCeTransport,
                     pTransportName,
                     0xffff);

        if (Status == STATUS_SUCCESS) {
            PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

            pProviderInfo = pTransport->RxCeTransport.pProviderInfo;

            if (!(pProviderInfo->ServiceFlags & TDI_SERVICE_CONNECTION_MODE) ||
                !(pProviderInfo->ServiceFlags & TDI_SERVICE_ERROR_FREE_DELIVERY)) {
                RxCeTearDownTransport(
                    &pTransport->RxCeTransport);

                Status = STATUS_PROTOCOL_UNREACHABLE;

                RxFreePool(pTransport);
            }
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        // The connection capabilities match the capabilities required by the
        // SMB mini redirector. Attempt to register the local address with the
        // transport and if successful update the local transport list to include
        // this transport for future connection considerations.

        OEM_STRING   OemServerName;
        CHAR  TransportAddressBuffer[TDI_TRANSPORT_ADDRESS_LENGTH +
                          TDI_ADDRESS_LENGTH_NETBIOS];
        PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)TransportAddressBuffer;
        PTDI_ADDRESS_NETBIOS pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)pTransportAddress->Address[0].Address;

        pTransportAddress->TAAddressCount = 1;
        pTransportAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
        pTransportAddress->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
        pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        OemServerName.MaximumLength = NETBIOS_NAME_LEN;
        OemServerName.Buffer        = pNetbiosAddress->NetbiosName;

        Status = RtlUpcaseUnicodeStringToOemString(
                     &OemServerName,
                     &SmbCeContext.ComputerName,
                     FALSE);

        if (NT_SUCCESS(Status)) {
            // Ensure that the name is always of the desired length by padding
            // white space to the end.
            RtlCopyMemory(
                &OemServerName.Buffer[OemServerName.Length],
                "                ",
                NETBIOS_NAME_LEN - OemServerName.Length);

            OemServerName.Buffer[NETBIOS_NAME_LEN - 1] = '\0';

            // Register the Transport address for this mini redirector with the connection
            // engine.

            Status = RxCeBuildAddress(
                        &pTransport->RxCeAddress,
                        &pTransport->RxCeTransport,
                        pTransportAddress,
                        &MRxSmbVctAddressEventHandler,
                        &SmbCeContext);

            if (Status == STATUS_SUCCESS) {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Adding new transport\n"));

                pTransport->Active       = TRUE;
                pTransport->Priority     = pTransportContext->Priority;
                pTransport->SwizzleCount = 0;

                pTransport->ObjectCategory = SMB_SERVER_TRANSPORT_CATEGORY;
                pTransport->ObjectType     = SMBCEDB_OT_TRANSPORT;
                pTransport->State          = 0;
                pTransport->Flags          = 0;

                // notify the browser about the transport
                Status = SmbCePnpBindBrowser(pTransportName, TRUE);

                if (MRxSmbBootedRemotely && (Status == STATUS_REDIRECTOR_NOT_STARTED)) {

                    //
                    // Ignore failures here, because when starting during
                    // textmode setup in remote boot, the browser is not around.
                    //

                    Status = STATUS_SUCCESS;
                }

                // Add the transport to the list of transports
                if (Status == STATUS_SUCCESS) {
                    SmbCeAddTransport(pTransport);
                    RxDbgTrace( 0, Dbg, ("MrxSmbpBindTransportCallback, Transport %wZ added\n", pTransportName ));
                } else {
                    RxCeTearDownAddress(&pTransport->RxCeAddress);

                    MRxSmbLogTransportError(pTransportName,
                                             &SmbCeContext.DomainName,
                                             Status,
                                             EVENT_RDR_CANT_BIND_TRANSPORT);
                    SmbLogError(Status,
                                LOG,
                                MRxSmbpBindTransportCallback_1,
                                LOGULONG(Status)
                                LOGUSTR(*pTransportName));
                }
            } else {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Address registration failed %lx\n",Status));
                MRxSmbLogTransportError(pTransportName,
                                         &SmbCeContext.DomainName,
                                         Status,
                                         EVENT_RDR_CANT_REGISTER_ADDRESS);
                SmbLogError(Status,
                            LOG,
                            MRxSmbpBindTransportCallback_2,
                            LOGULONG(Status)
                            LOGUSTR(*pTransportName));
            }
        }

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace( 0, Dbg, ("MrxSmbpBindTransportCallback, Transport %wZ unreachable 0x%x\n",
                                 pTransportName, Status ));
            RxCeTearDownTransport(
                &pTransport->RxCeTransport);

            Status = STATUS_PROTOCOL_UNREACHABLE;
            RxFreePool(pTransport);
        }
    }

    InterlockedDecrement(&TdiBindRequestsActive);
    SmbCeSignalNetReadyEvent();
}

VOID
MRxSmbpBindTransportWorkerThreadRoutine(
    IN PTRANSPORT_BIND_CONTEXT pTransportContext)
/*++

Routine Description:

    The TDI callbacks always do not occur in the context of the FSP process.
    Since there are a few TDi interfaces that accept handles we need to ensure
    that such calls always gets funnelled back to the FSP.

Arguments:

    pTransportContext - the transport binding context

--*/
{
    PAGED_CODE();

    MRxSmbpBindTransportCallback(pTransportContext);

    RxFreePool(pTransportContext);
}

VOID
MRxSmbpUnbindTransportCallback(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    The Unbind callback routine which is always executed in the context of the
    RDR process so that handles can be closed correctly

Arguments:

    pTransport - the transport for which the PNP_OP_DEL was received

Notes:

    On entry to this routine the appropriate transport must have been referenced
    This routine will dereference it and invalidate the existing exchanges using
    this transport.

--*/
{
    PAGED_CODE();

    // notify the browser about the transport
    SmbCePnpBindBrowser(&pTransport->RxCeTransport.Name, FALSE);

    // Remove this transport from the list of transports under consideration
    // in the mini redirector.

    SmbCeRemoveTransport(pTransport);

    // Enumerate the servers and mark those servers utilizing this transport
    // as having an invalid transport.
    SmbCeHandleTransportInvalidation(pTransport);

    // dereference the transport
    SmbCeDereferenceTransport(pTransport);
}


VOID
MRxSmbpOverrideBindingPriority(
    PUNICODE_STRING pTransportName,
    PULONG pPriority
    )

/*++

Routine Description:

This function obtains a overriding priority value from the registry for a given
transport.

The priority of a transport controls the order in which connections are accepted.  It is
sometimes useful for a customer to control which transport is used first in the redirector.

The priority is usually determined by the order of the transports in the binding list.  With
the new Connections UI model for network setup, it will no longer be possible to adjust
the order of the bindings in the binding list.  Thus, another mechanism is needed when the
user wants to override the priority assigned to a given binding.

Arguments:

    pTransportName - pointer to UNICODE_STRING descriptor for transport string, for example
        "\Device\Netbt_tcpip_{guid}"
    pPriority - pointer to LONG to receive new priority on success, otherwise not touched

Return Value:

    None

--*/

{
    WCHAR valueBuffer[128];
    UNICODE_STRING path, value, key;
    USHORT length,ulength;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    HANDLE parametersHandle;
    ULONG temp;

    PAGED_CODE();

    // Validate input

    if (pTransportName->Length == 0) {
        return;
    }

    // Open parameters key

    RtlInitUnicodeString( &path, SMBMRX_MINIRDR_PARAMETERS );

    InitializeObjectAttributes(
        &objectAttributes,
        &path,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey (&parametersHandle, KEY_READ, &objectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Construct value name = "BindingPriority" + transportname
    // First, find the last slash.  Then form the value from the prefix and
    // the remainder of the transport name.
    ulength = pTransportName->Length / sizeof(WCHAR);
    for( length = ulength - 1; length != 0; length-- ) {
        if (pTransportName->Buffer[length] == L'\\') {
            break;
        }
    }

    length++;
    key.Buffer = pTransportName->Buffer + length;
    key.Length = (ulength - length) * sizeof(WCHAR);

    value.Buffer = valueBuffer;
    value.MaximumLength = 128 * sizeof(WCHAR);
    value.Length = 0;

    RtlAppendUnicodeToString( &value, L"BindingPriority" );
    RtlAppendUnicodeStringToString( &value, &key );

    // Check if the value is present.  If so, replace priority
    // A value of zero is valid and indicates do not bind this one

    status = MRxSmbGetUlongRegistryParameter(
                 parametersHandle,
                 value.Buffer,
                 (PULONG)&temp,
                 FALSE );

    if (NT_SUCCESS(status)) {
        *pPriority = temp;
    }

    ZwClose(parametersHandle);
}

VOID
MRxSmbPnPBindingHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pTransportName,
    IN PWSTR            BindingList)
/*++

Routine Description:

    The TDI callbacks routine for binding changes

Arguments:

    PnPOpcode - the PNP op code

    pTransportName - the transport name

    BindingList - the binding order

--*/
{
    ULONG Priority;

    PAGED_CODE();

    switch (PnPOpcode) {
    case TDI_PNP_OP_ADD:
        {
            BOOLEAN        fBindToTransport = FALSE;
            PWSTR          pSmbMRxTransports;
            UNICODE_STRING SmbMRxTransport;
            NTSTATUS       Status;

            Status = SmbCeGetConfigurationInformation();

            if (Status != STATUS_SUCCESS) {
                return;
            }

            pSmbMRxTransports = (PWSTR)SmbCeContext.Transports.Buffer;
            Priority = 1;
            while (*pSmbMRxTransports) {
                SmbMRxTransport.Length = wcslen(pSmbMRxTransports) * sizeof(WCHAR);

                if (SmbMRxTransport.Length == pTransportName->Length) {
                    SmbMRxTransport.MaximumLength = SmbMRxTransport.Length;
                    SmbMRxTransport.Buffer = pSmbMRxTransports;

                    if (RtlCompareUnicodeString(
                           &SmbMRxTransport,
                           pTransportName,
                           TRUE) == 0) {
                        fBindToTransport = TRUE;
                        break;
                    }
                }

                pSmbMRxTransports += (SmbMRxTransport.Length / sizeof(WCHAR) + 1);
                Priority++;
            }

            // Provide a local registry means to alter binding priority
            if (fBindToTransport) {
                MRxSmbpOverrideBindingPriority( pTransportName, &Priority );
                fBindToTransport = (Priority != 0);
            }

            if (fBindToTransport) {
                InterlockedIncrement(&TdiBindRequestsActive);

                if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                    TRANSPORT_BIND_CONTEXT TransportContext;

                    TransportContext.Priority = Priority;
                    TransportContext.TransportName = *pTransportName;
                    MRxSmbpBindTransportCallback(&TransportContext);
                } else {
                    PTRANSPORT_BIND_CONTEXT pNewTransportContext;

                    NTSTATUS Status;

                    pNewTransportContext = RxAllocatePoolWithTag(
                                               PagedPool,
                                               sizeof(TRANSPORT_BIND_CONTEXT) + pTransportName->Length,
                                               MRXSMB_TRANSPORT_POOLTAG);

                    if (pNewTransportContext != NULL) {
                        pNewTransportContext->Priority = Priority;
                        pNewTransportContext->TransportName.MaximumLength = pTransportName->MaximumLength;
                        pNewTransportContext->TransportName.Length = pTransportName->Length;
                        pNewTransportContext->TransportName.Buffer = (PWCHAR)((PBYTE)pNewTransportContext +
                                                                      sizeof(TRANSPORT_BIND_CONTEXT));

                        RtlCopyMemory(
                            pNewTransportContext->TransportName.Buffer,
                            pTransportName->Buffer,
                            pTransportName->Length);

                        Status = RxDispatchToWorkerThread(
                                     MRxSmbDeviceObject,
                                     CriticalWorkQueue,
                                     MRxSmbpBindTransportWorkerThreadRoutine,
                                     pNewTransportContext);
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }

                    if (Status != STATUS_SUCCESS) {
                        InterlockedDecrement(&TdiBindRequestsActive);
                        SmbCeSignalNetReadyEvent();
                    }
                }
            }
        }
        break;

    case TDI_PNP_OP_DEL:
        {
            PSMBCE_TRANSPORT pTransport;

            pTransport = SmbCeFindTransport(pTransportName);

            if (pTransport != NULL) {
                if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                    MRxSmbpUnbindTransportCallback(pTransport);
                } else {
                    NTSTATUS Status;

                    Status = RxDispatchToWorkerThread(
                                 MRxSmbDeviceObject,
                                 CriticalWorkQueue,
                                 MRxSmbpUnbindTransportCallback,
                                 pTransport);
                }
            }
        }
        break;

    case TDI_PNP_OP_UPDATE:
        {
        }
        break;

    case  TDI_PNP_OP_NETREADY:
        {
            TdiPnpNetReadyEventReceived = TRUE;
            SmbCeSignalNetReadyEvent();
        }
        break;

    default:
        break;
    }

    if( PnPOpcode != TDI_PNP_OP_NETREADY )
    {
        SmbMRxNotifyChangesToNetBt( PnPOpcode, pTransportName, BindingList );
    }
}

NTSTATUS
MRxSmbPnPPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
)
/*++

Routine Description:

    This routine deals with power changes

Notes:

    The implementation needs to be completed

--*/
{
    NTSTATUS Status;
    LONG     NumberOfActiveOpens;

    Status = STATUS_SUCCESS;

    FsRtlEnterFileSystem();

    RxPurgeAllFobxs(MRxSmbDeviceObject);

    RxScavengeAllFobxs(MRxSmbDeviceObject);
    NumberOfActiveOpens = MRxSmbNumberOfSrvOpens;

    switch (PowerEvent->NetEvent) {
    case NetEventQueryPower:
        {
            // If the redirector were to return an error on this request there
            // is no underlying support to tell the user about the files that
            // are open. There are two approaches to doing this.. either the RDR
            // rolls its own UI or the PNP manager provides the infra structure.
            // The problem with the former is that hibernation becomes a painstaking
            // process wherein the user has to contend with a variety of UI.
            // Till this is resolved the decision was to use the power mgmt. API
            // to manage system initiated hibernate requests and succeed user
            // initiated requests after appropriate purging/scavenging.

            Status = STATUS_SUCCESS;
        }
        break;

    case NetEventQueryRemoveDevice:
        {
            PSMBCEDB_SERVER_ENTRY pServerEntry;
            ULONG                 NumberOfFilesOpen = 0;
            PSMBCE_TRANSPORT      pTransport = NULL;

            pTransport = SmbCeFindTransport(DeviceName);

            if (pTransport != NULL) {
                SmbCeAcquireSpinLock();

                pServerEntry = SmbCeGetFirstServerEntry();

                while (pServerEntry != NULL) {
                    if ((pServerEntry->pTransport != NULL) &&
                        (pTransport == pServerEntry->pTransport->pTransport)) {
                        NumberOfFilesOpen += pServerEntry->Server.NumberOfSrvOpens;
                    }

                    pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
                }

                SmbCeReleaseSpinLock();

                SmbCeDereferenceTransport(pTransport);
            }
        }
        break;

    default:
        break;
    }

    FsRtlExitFileSystem();

    return Status;
}

NTSTATUS
MRxSmbRegisterForPnpNotifications()
/*++

Routine Description:

    This routine registers with TDI for receiving transport notifications

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(MRxSmbTdiNotificationHandle == NULL ) {
        UNICODE_STRING ClientName;

        TDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo;

        RtlInitUnicodeString(&ClientName,L"LanmanWorkStation");

        ClientInterfaceInfo.MajorTdiVersion = 2;
        ClientInterfaceInfo.MinorTdiVersion = 0;

        ClientInterfaceInfo.Unused = 0;
        ClientInterfaceInfo.ClientName = &ClientName;

        ClientInterfaceInfo.BindingHandler = MRxSmbPnPBindingHandler;
        ClientInterfaceInfo.AddAddressHandler = NULL;
        ClientInterfaceInfo.DelAddressHandler = NULL;
        ClientInterfaceInfo.PnPPowerHandler = MRxSmbPnPPowerHandler;

        KeInitializeEvent(
            &TdiNetStartupCompletionEvent,
            NotificationEvent,
            FALSE);

        Status = TdiRegisterPnPHandlers (
                     &ClientInterfaceInfo,
                     sizeof(ClientInterfaceInfo),
                     &MRxSmbTdiNotificationHandle );

        if (Status == STATUS_SUCCESS) {
            LARGE_INTEGER WaitInterval;

            WaitInterval.QuadPart = -( 10000 * 2 * 60 * 1000 );

            Status = KeWaitForSingleObject(
                         &TdiNetStartupCompletionEvent,
                         Executive,
                         KernelMode,
                         FALSE,
                         &WaitInterval);

            if (Status != STATUS_SUCCESS) {
                DbgPrint("MRxSmb Finishes waiting on TDI_PNP_OP_NETREADY %lx\n",Status);
            }
        }
    }

    return Status;
}

NTSTATUS
MRxSmbDeregisterForPnpNotifications()
/*++

Routine Description:

    This routine deregisters the TDI notification mechanism

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if( MRxSmbTdiNotificationHandle != NULL ) {
        Status = TdiDeregisterPnPHandlers( MRxSmbTdiNotificationHandle );

        if( NT_SUCCESS( Status ) ) {
            MRxSmbTdiNotificationHandle = NULL;
        }
    }

    return Status;
}

#endif

NTSTATUS
SmbCePnpBindBrowser( PUNICODE_STRING pTransportName, BOOLEAN IsBind)
/*++

Routine Description:

    This routine binds the browser with the specified transport

Arguments:

    pTransportName - the name of the transport

Notes:

--*/
{
    NTSTATUS             Status;
    HANDLE               BrowserHandle;
    PLMDR_REQUEST_PACKET pLmdrRequestPacket;
    IO_STATUS_BLOCK      IoStatusBlock;
    OBJECT_ATTRIBUTES    ObjectAttributes;
    UNICODE_STRING       BrowserDeviceName;
    ULONG                LmdrRequestPacketSize;

    PAGED_CODE();

    //
    // Open up a handle to the browser
    //
    RtlInitUnicodeString( &BrowserDeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &BrowserDeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = IoCreateFile(
                &BrowserHandle,                 // FileHandle
                SYNCHRONIZE,                    // DesiredAccess
                &ObjectAttributes,              // ObjectAttributes
                &IoStatusBlock,                 // IoStatusBlock
                NULL,                           // AllocationSize
                0L,                             // FileAttributes
                FILE_SHARE_VALID_FLAGS,         // ShareAccess
                FILE_OPEN,                      // Disposition
                FILE_SYNCHRONOUS_IO_NONALERT,   // CreateOptions
                NULL,                           // EaBuffer
                0,                              // EaLength
                CreateFileTypeNone,             // CreateFileType
                NULL,                           // ExtraCreateParameters
                0                               // Options
            );

    if( NT_SUCCESS( Status ) ) {
        Status = IoStatusBlock.Status;
    }

    if( !NT_SUCCESS(Status ) ) {
        return Status;
    }

    // The browser requires that the computer name and the domain name be
    // concatenated to the transport name and passed on. Since no length
    // fields are provided to supply the length of these two names the
    // NULL delimiter needs to be attached. This accounts for the two
    // additional characters in the calculation

    LmdrRequestPacketSize = sizeof(*pLmdrRequestPacket) +
                            pTransportName->Length +
                            SmbCeContext.DomainName.Length + sizeof(WCHAR) +
                            SmbCeContext.ComputerName.Length + sizeof(WCHAR);

    pLmdrRequestPacket = RxAllocatePoolWithTag(
                              NonPagedPool,
                              LmdrRequestPacketSize,
                              MRXSMB_TRANSPORT_POOLTAG);

    if (pLmdrRequestPacket != NULL) {
        ULONG BufferOffset = 0;
        PVOID pBuffer;
        WCHAR NullChar = L'\0';
        ULONG BindMode;

        //
        // Tell the browser to bind to this new transport
        //

        RtlZeroMemory( pLmdrRequestPacket, sizeof(LMDR_REQUEST_PACKET));
        pLmdrRequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
        pLmdrRequestPacket->Parameters.Bind.TransportNameLength = pTransportName->Length;

        pBuffer = pLmdrRequestPacket->Parameters.Bind.TransportName;

        RtlCopyMemory(
            pBuffer,
            pTransportName->Buffer,
            pTransportName->Length);
        BufferOffset = pTransportName->Length;

        // Tell the browser our computer name.
        pLmdrRequestPacket->Level = TRUE; // Emulated computer name follows transport name.
        RtlCopyMemory(
            ((PBYTE)pBuffer + BufferOffset),
            SmbCeContext.ComputerName.Buffer,
            SmbCeContext.ComputerName.Length);
        BufferOffset += SmbCeContext.ComputerName.Length;

        RtlCopyMemory(
            ((PBYTE)pBuffer + BufferOffset),
            &NullChar,
            sizeof(WCHAR));
        BufferOffset += sizeof(WCHAR);


        // Tell the browser our domain name.
        pLmdrRequestPacket->EmulatedDomainName.Buffer = (LPWSTR)
                ((PBYTE)pBuffer + BufferOffset);
        pLmdrRequestPacket->EmulatedDomainName.MaximumLength =
                pLmdrRequestPacket->EmulatedDomainName.Length =
                SmbCeContext.DomainName.Length;
        RtlCopyMemory(
            ((PBYTE)pBuffer + BufferOffset),
            SmbCeContext.DomainName.Buffer,
            SmbCeContext.DomainName.Length);
        BufferOffset += SmbCeContext.DomainName.Length;

        RtlCopyMemory(
            ((PBYTE)pBuffer + BufferOffset),
            &NullChar,
            sizeof(WCHAR));
        BufferOffset += sizeof(WCHAR);

        BindMode = IsBind?
                   IOCTL_LMDR_BIND_TO_TRANSPORT_DOM:
                   IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM;

        Status = NtDeviceIoControlFile(
                     BrowserHandle,                  // FileHandle
                     NULL,                           // Event
                     NULL,                           // ApcRoutine
                     NULL,                           // ApcContext
                     &IoStatusBlock,                 // IoStatusBlock
                     BindMode,                       // IoControlCode
                     pLmdrRequestPacket,             // InputBuffer
                     LmdrRequestPacketSize,          // InputBufferLength
                     NULL,                           // OutputBuffer
                     0                               // OutputBufferLength
                     );

        RxFreePool(pLmdrRequestPacket);

        if( NT_SUCCESS(Status ) ) {
            Status = IoStatusBlock.Status;
        }
    }

    ZwClose( BrowserHandle );

    return Status;
}

PSMBCE_TRANSPORT_ARRAY
SmbCeReferenceTransportArray(VOID)
/*++

Routine Description:

    This routine references and returns the current transport array instance

Return Value:

    PSMBCE_TRANSPORT_ARRAY - the pointer of the current transport array instance

Notes:

--*/
{
    KIRQL                  SavedIrql;
    PSMBCE_TRANSPORT_ARRAY pTransportArray;

    KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

    pTransportArray = MRxSmbTransports.pTransportArray;

    if (pTransportArray != NULL) {
        InterlockedIncrement(&pTransportArray->ReferenceCount);
    }

    KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

    return pTransportArray;
}

NTSTATUS
SmbCeDereferenceTransportArray(
    PSMBCE_TRANSPORT_ARRAY pTransportArray)
/*++

Routine Description:

    This routine dereferences the transport array instance

Arguments:

    pTransportArray - the transport array instance

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    KIRQL    SavedIrql;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if (pTransportArray != NULL) {
        ASSERT( pTransportArray->ReferenceCount > 0 );

        if(InterlockedDecrement(&pTransportArray->ReferenceCount)==0) {
            ULONG i;

            for(i=0;i<pTransportArray->Count;i++) {
                SmbCeDereferenceTransport(pTransportArray->SmbCeTransports[i]);
            }

            RxFreePool(pTransportArray->SmbCeTransports);
            RxFreePool(pTransportArray->LocalAddresses);
            RxFreePool(pTransportArray);
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
SmbCeIsServerAvailable(
    PUNICODE_STRING Name
)
/*++

Routine Description:

    This routine scans the list of "unreachable" servers and returns the status
    of the last failed connection attempt.

Return:
    STATUS_SUCCESS -> we have no reason to believe this server is unreachable
    other -> server is unreachable for this reason
--*/
{
    PUNAVAILABLE_SERVER server;
    LARGE_INTEGER now;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    KeQueryTickCount( &now );

    ExAcquireResourceExclusive( &UnavailableServerListResource, TRUE );

    for( server  = (PUNAVAILABLE_SERVER)UnavailableServerList.Flink;
         server != (PUNAVAILABLE_SERVER)&UnavailableServerList;
         server  = (PUNAVAILABLE_SERVER)server->ListEntry.Flink ) {

        //
        // If this entry has timed out, remove it.
        //
        if( now.QuadPart > server->Time.QuadPart ) {
            PUNAVAILABLE_SERVER tmp;
            //
            // Unlink this entry from the list and discard it
            //
            tmp = (PUNAVAILABLE_SERVER)(server->ListEntry.Blink);
            RemoveEntryList( &server->ListEntry );
            RxFreePool( server );
            server = tmp;
            continue;
        }

        //
        // See if this entry is the one we want
        //
        if( RtlCompareUnicodeString( &server->Name, Name, TRUE ) == 0 ) {

            status = server->Status;

            RxDbgTrace(0, Dbg, ("SmbCeIsServerAvailable: Found %wZ %X\n",
                        &server->Name, status ));
        }
    }

    ExReleaseResource( &UnavailableServerListResource );

    return status;
}

VOID
SmbCeServerIsUnavailable(
    PUNICODE_STRING Name,
    NTSTATUS Status
)
{
    PUNAVAILABLE_SERVER server;

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ExpiryTimeInTicks;

    PAGED_CODE();

    server = (PUNAVAILABLE_SERVER)RxAllocatePoolWithTag(
                                        PagedPool,
                                        sizeof( *server ) + Name->Length,
                                        MRXSMB_TRANSPORT_POOLTAG
                                        );

    if( server == NULL ) {
        return;
    }

    RxDbgTrace(0, Dbg, ("SmbCeServerIsUnavailable: Add %wZ %X\n", Name, Status ));

    server->Name.Buffer = (PUSHORT)(server + 1);
    server->Name.MaximumLength = Name->Length;
    RtlCopyUnicodeString( &server->Name, Name );

    KeQueryTickCount( &CurrentTime );

    ExpiryTimeInTicks.QuadPart = (1000 * 1000 * 10) / KeQueryTimeIncrement();

    ExpiryTimeInTicks.QuadPart = UNAVAILABLE_SERVER_TIME * ExpiryTimeInTicks.QuadPart;

    server->Time.QuadPart = CurrentTime.QuadPart + ExpiryTimeInTicks.QuadPart;

    server->Status = Status;

    ExAcquireResourceExclusive( &UnavailableServerListResource, TRUE );
    InsertHeadList( &UnavailableServerList, &server->ListEntry );
    ExReleaseResource( &UnavailableServerListResource );
}

VOID
SmbCeDiscardUnavailableServerList(
)
{
    PUNAVAILABLE_SERVER server;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("SmbCeDiscardUnavailableServerList\n" ));

    ExAcquireResourceExclusive( &UnavailableServerListResource, TRUE );

    while( UnavailableServerList.Flink != &UnavailableServerList ) {
        server  = (PUNAVAILABLE_SERVER)UnavailableServerList.Flink;
        RemoveEntryList( &server->ListEntry );
        RxFreePool( server );
    }

    ExReleaseResource( &UnavailableServerListResource );
}

extern BOOLEAN SetupInProgress;

VOID
MRxSmbLogTransportError(
    PUNICODE_STRING pTransportName,
    PUNICODE_STRING pDomainName,
    NTSTATUS        ErrorStatus,
    IN ULONG        Id)
/*++

Routine Description:

    This routine reports the error that occurs at binding the browser with the specified transport

Arguments:

    pTransportName - the name of the transport

    Status - the NT status of the error occured

Notes:

--*/
{
    NTSTATUS Status;
    USHORT RemainingLength = ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET) - 3*sizeof(UNICODE_NULL);
    UNICODE_STRING ErrorLog[3];
    UNICODE_STRING UnicodeStatus;
    UNICODE_STRING TempUnicode;
    ULONG DosError;

    // strip of the "\device\" at the beginning of transport name to reduce the message length
    pTransportName->Length -= 8*sizeof(UNICODE_NULL);

    // assume the dos error code won't be larger than 10 digits
    UnicodeStatus.Length = 12 * sizeof(UNICODE_NULL);
    UnicodeStatus.MaximumLength = UnicodeStatus.Length;
    UnicodeStatus.Buffer = RxAllocatePoolWithTag(NonPagedPool,
                                              UnicodeStatus.Length,
                                              MRXSMB_TRANSPORT_POOLTAG);
    if (UnicodeStatus.Buffer == NULL) {
        goto FINALY;
    }

    // use the dos error code to display the status on the event message
    UnicodeStatus.Buffer[0] = L'%';
    UnicodeStatus.Buffer[1] = L'%';

    DosError = RtlNtStatusToDosError(ErrorStatus);

    TempUnicode.Length = UnicodeStatus.Length - 2*sizeof(UNICODE_NULL);
    TempUnicode.MaximumLength = UnicodeStatus.MaximumLength - 2*sizeof(UNICODE_NULL);
    TempUnicode.Buffer = &UnicodeStatus.Buffer[2];

    Status = RtlIntegerToUnicodeString(
                 DosError,
                 0,
                 &TempUnicode);

    if (Status != STATUS_SUCCESS) {
        goto FINALY;
    }

    ErrorLog[2].Length = TempUnicode.Length + 2*sizeof(UNICODE_NULL);
    ErrorLog[2].MaximumLength = ErrorLog[2].Length;
    ErrorLog[2].Buffer = UnicodeStatus.Buffer;

    RemainingLength -= ErrorLog[2].Length;

    if (pDomainName->Length + pTransportName->Length > RemainingLength) {
        // the length error log message is limited by the ERROR_LOG_MAXIMUM_SIZE. This restriction can be
        // enfored by truncating the doamin and transport names so that both of them can get chance to be
        // displayed on the EvenLog.

        ErrorLog[0].Length = pDomainName->Length < RemainingLength / 2 ?
                             pDomainName->Length :
                             RemainingLength / 2;

        RemainingLength -= ErrorLog[0].Length;

        ErrorLog[1].Length = pTransportName->Length < RemainingLength ?
                             pTransportName->Length :
                             RemainingLength;
    } else {
        ErrorLog[0].Length = pDomainName->Length;
        ErrorLog[1].Length = pTransportName->Length;
    }

    ErrorLog[0].MaximumLength = ErrorLog[0].Length;
    ErrorLog[1].MaximumLength = ErrorLog[1].Length;

    ErrorLog[0].Buffer = pDomainName->Buffer;

    // strip of the "\device\" at the beginning of transport name
    ErrorLog[1].Buffer = &pTransportName->Buffer[8];

    RxLogEventWithAnnotation (
        MRxSmbDeviceObject,
        Id,
        ErrorStatus,
        NULL,
        0,
        ErrorLog,
        3
        );

FINALY:

    // restore the length with "\device\" at the beginning of transport name
    pTransportName->Length += 8*sizeof(UNICODE_NULL);

    if (UnicodeStatus.Buffer != NULL) {
        RxFreePool(UnicodeStatus.Buffer);
    }

    if (!SetupInProgress && ErrorStatus == STATUS_DUPLICATE_NAME) {
        IoRaiseInformationalHardError(ErrorStatus, NULL, NULL);
    }
}


VOID
SmbMRxNotifyChangesToNetBt(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList)

/*++

Routine Description:

    This routine should not be part of rdr. It has been introduced into this
    component to overcome current limitations in NetBt. The NetBt transport
    exposes two  kinds of devices -- the traditional NetBt device and the
    new non Netbios device which make use of the NetBt framing code without the
    name resolution aspects of it. The current implementation in NetBt exposes
    the former devices on a per adapter basis while the second category of device
    is exposed on a global basis ( one for all the adapters ). This poses
    problems in disabling/enabling srv on a given adapter.

    The correct solution is to expose the second category of devices on a per
    adapter basis. Till it is done this workaround is reqd. With this workaround
    whenever the server is notified of any changes to the binding string it turns
    around and notifies the NetBt transport about these changes.

    This routine is based upon the following assumptions ...

        1) The notification from TDI is not done at raised IRQL.

        2) The thread on which this notification occurs has enough access rights.

        3) The notification to NetBt is done asynchronously with srv's reaction
        to the change. The srv handles the PNP notification by passing it off to
        user mode and have it come through the server service.

Arguments:

    PNPOpcode - the PNP opcode

    DeviceName - the transport for which this opcode is intended

    MultiSZBindList - the binding list

Return Value:

    None.

--*/
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE            NetbioslessSmbHandle;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    NetbioslessSmbName = {36,36, L"\\device\\NetbiosSmb"};

    InitializeObjectAttributes(
        &ObjectAttributes,
        &NetbioslessSmbName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    Status = ZwCreateFile (
                 &NetbioslessSmbHandle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                 &ObjectAttributes,     // object attributes
                 &IoStatusBlock,        // returned status information
                 NULL,                  // block size (unused)
                 0,                     // file attributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                 FILE_CREATE,           // create disposition
                 0,                     // create options
                 NULL,                  // EA buffer
                 0                      // EA length
                 );

    if ( NT_SUCCESS(Status) ) {
        NETBT_SMB_BIND_REQUEST      NetBtNotificationParameters;

        NetBtNotificationParameters.RequestType = SMB_CLIENT;
        NetBtNotificationParameters.PnPOpCode   = PnPOpcode;
        NetBtNotificationParameters.pDeviceName = DeviceName;
        NetBtNotificationParameters.MultiSZBindList = MultiSZBindList;

        Status = ZwDeviceIoControlFile(
                     NetbioslessSmbHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     IOCTL_NETBT_SET_SMBDEVICE_BIND_INFO,
                     &NetBtNotificationParameters,
                     sizeof(NetBtNotificationParameters),
                     NULL,
                     0);

        Status = ZwClose(NetbioslessSmbHandle);
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\transact.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcxchng.h

Abstract:

    This is the include file that defines all constants and types for
    SMB exchange implementation.

Author:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

--*/

#ifndef _TRANSACT_H_
#define _TRANSACT_H_

typedef enum _TRANSACT_EXCHANGE_STATE_ {
   TRANSACT_EXCHANGE_START,
   TRANSACT_EXCHANGE_ERROR,
   TRANSACT_EXCHANGE_SUCCESS,
   TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST,
   TRANSACT_EXCHANGE_RECEIVED_INTERIM_RESPONSE,
   TRANSACT_EXCHANGE_TRANSMITTED_SECONDARY_REQUESTS,
   TRANSACT_EXCHANGE_RECEIVED_PRIMARY_RESPONSE
} TRANSACT_EXCHANGE_STATE, *PTRANSACT_EXCHANGE_STATE;

typedef struct _SMB_TRANSACTION_RESUMPTION_CONTEXT{
    struct _SMB_TRANSACT_EXCHANGE *pTransactExchange;
    SMBCE_RESUMPTION_CONTEXT SmbCeResumptionContext;
    ULONG SetupBytesReceived;
    ULONG DataBytesReceived;
    ULONG ParameterBytesReceived;
    NTSTATUS FinalStatusFromServer;
    ULONG ServerVersion;
} SMB_TRANSACTION_RESUMPTION_CONTEXT, *PSMB_TRANSACTION_RESUMPTION_CONTEXT;

#define TRAILING_BYTES_BUFFERSIZE 8
typedef struct _SMB_TRANSACT_EXCHANGE {
    SMB_EXCHANGE;

    TRANSACT_EXCHANGE_STATE State;

    // Client supplied parameters for the transact exchange
    //PRX_CONTEXT             RxContext;
    PMDL            pSendDataMdl;
    ULONG                   SendDataBufferSize;
    ULONG                   DataBytesSent;
    PMDL            pReceiveDataMdl;
    ULONG                   ReceiveDataBufferSize;
    ULONG                   DataBytesReceived;
    PMDL            pSendParamMdl; //used if we cannot subsume
    PVOID                   pSendParamBuffer;
    ULONG                   SendParamBufferSize;
    ULONG                   ParamBytesSent;
    PMDL            pReceiveParamMdl;
    ULONG                   ReceiveParamBufferSize;
    ULONG                   ParamBytesReceived;
    PVOID                   pSendSetupMdl;
    ULONG                   SendSetupBufferSize;
    PMDL            pReceiveSetupMdl;
    ULONG                   ReceiveSetupBufferSize;
    ULONG                   SetupBytesReceived;

    // Transact exchange intrinsic fields
    ULONG                     PrimaryRequestSmbSize;
    PVOID                     pActualPrimaryRequestSmbHeader;     // Original buffer allocated
    PSMB_HEADER               pPrimaryRequestSmbHeader;           // Start of header
    ULONG                     ParameterBytesSeen;
    ULONG                     DataBytesSeen;
    LONG                      PendingCopyRequests;    //CODE.IMPROVEMENT this field is useless
    BOOLEAN                   fParamsSubsumedInPrimaryRequest;
    UCHAR                     TransactSmbCommand;
    USHORT                    Flags;
    USHORT                    NtTransactFunction;
    SMB_FILE_ID               Fid;           //CODE.IMPROVEMENT is this used?
    ULONG                     TransactionNameLength;
    ULONG                     MaximumTransmitSmbBufferSize;
                                 //used to cache value and also to force
                                 //smaller value for testing
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext;

    struct {
        MDL  TrailingBytesMdl;
        ULONG Pages[3]; //you need 2...one pad; this must cover an smbbuf
    };
    NTSTATUS SaveTheRealStatus;
    PVOID    DiscardBuffer;
    struct {
        ULONG Bytes[TRAILING_BYTES_BUFFERSIZE/sizeof(ULONG)];
    } TrailingBytesBuffer;
} SMB_TRANSACT_EXCHANGE, *PSMB_TRANSACT_EXCHANGE;

typedef struct SMB_TRANSACTION_PARAMETERS {
   USHORT Flags;
   USHORT SetupLength;      // the steup buffer length
   union {
      PVOID pSetup;         // the setup buffer
      PMDL  pSetupMdl;      // the MDL version of the buffer
   };
   ULONG ParamLength;
   PVOID pParam;            //you need the bufptr is you're subsuming
   PMDL  pParamMdl;         //you need the MDL is you can't subsume
   PMDL  pDataMdl;          // the data buffer
   ULONG DataLength;        // this is total length...not the length
                            // of the 1st mdl in the chain
} SMB_TRANSACTION_PARAMETERS, *PSMB_TRANSACTION_PARAMETERS;

typedef SMB_TRANSACTION_PARAMETERS          SMB_TRANSACTION_SEND_PARAMETERS;
typedef SMB_TRANSACTION_SEND_PARAMETERS*    PSMB_TRANSACTION_SEND_PARAMETERS;
typedef SMB_TRANSACTION_PARAMETERS          SMB_TRANSACTION_RECEIVE_PARAMETERS;
typedef SMB_TRANSACTION_RECEIVE_PARAMETERS* PSMB_TRANSACTION_RECEIVE_PARAMETERS;

#define SMBCE_DEFAULT_TRANSACTION_TIMEOUT (0xffffffff)
#define SMBCE_TRANSACTION_TIMEOUT_NOT_USED (0x0)

typedef struct SMB_TRANSACTION_OPTIONS {
   USHORT     NtTransactFunction;
   USHORT     Flags;
   PUNICODE_STRING pTransactionName;
   ULONG      TimeoutIntervalInMilliSeconds;
   ULONG      MaximumTransmitSmbBufferSize;
} SMB_TRANSACTION_OPTIONS, *PSMB_TRANSACTION_OPTIONS;

#define DEFAULT_TRANSACTION_OPTIONS {0,0,NULL,SMBCE_TRANSACTION_TIMEOUT_NOT_USED,0xffff}
extern SMB_TRANSACTION_OPTIONS RxDefaultTransactionOptions;

#define TRANSACTION_SEND_PARAMETERS_FLAG    (0x1)
#define TRANSACTION_RECEIVE_PARAMETERS_FLAG (0x2)

// xact and xact_options have the same flags so we have to be careful to strip off these bits
// when we format up the smb ( the flags field is a USHORT)
#define SMB_XACT_FLAGS_REPARSE                      (0x8000)
#define SMB_XACT_FLAGS_FID_NOT_NEEDED               (0x4000)
#define SMB_XACT_FLAGS_CALLERS_SENDDATAMDL          (0x2000)
#define SMB_XACT_FLAGS_TID_FOR_FID                  (0x1000)
#define SMB_XACT_FLAGS_MAILSLOT_OPERATION           (0x0800)
#define SMB_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE (0x0400)
#define SMB_XACT_FLAGS_DFS_AWARE                    (0x0200)
#define SMB_XACT_FLAGS_ASYNCHRONOUS                 (0x0100)
//#define SMB_XACT_FLAGS_COPY_ON_ERROR                (0x080)

#define SMB_XACT_INTERNAL_FLAGS_MASK               \
            ( SMB_XACT_FLAGS_REPARSE               \
              | SMB_XACT_FLAGS_FID_NOT_NEEDED      \
              | SMB_XACT_FLAGS_CALLERS_SENDDATAMDL \
              | SMB_XACT_FLAGS_TID_FOR_FID         \
              | SMB_XACT_FLAGS_MAILSLOT_OPERATION  \
              | SMB_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE \
              | SMB_XACT_FLAGS_DFS_AWARE                    \
              | SMB_XACT_FLAGS_ASYNCHRONOUS                 \
            )
#if 0
//CODE.IMROVEMENT.POSTPDC the constant SMB_TRANSACTION_VALID_FLAGS should be
//in smb.h. SMB_TRANSACTION_RECONNECTING and SMB_TRANSACTION_DFSFILE should NOT
//be in SMB.h. here is what's there now
#define SMB_TRANSACTION_DISCONNECT 1
#define SMB_TRANSACTION_NO_RESPONSE 2
#define SMB_TRANSACTION_RECONNECTING 4
#define SMB_TRANSACTION_DFSFILE 8
#endif

#define SMB_TRANSACTION_VALID_FLAGS (\
        SMB_TRANSACTION_DISCONNECT   \
     |  SMB_TRANSACTION_NO_RESPONSE  \
   )

#if ((SMB_XACT_INTERNAL_FLAGS_MASK & SMB_TRANSACTION_VALID_FLAGS) != 0)
#error SMB_XACT_INTERNAL_FLAGS_MASK has overrun the transact flags
#endif

extern NTSTATUS
SmbCeInitializeTransactionParameters(
   PVOID  pSetup,
   USHORT SetupLength,
   PVOID  pParam,
   ULONG  ParamLength,
   PVOID  pData,
   ULONG  DataLength,
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters);

#define SmbCeProvideTransactionDataAsMdl(pTransactionParameters,pMdl,Length) { \
          ASSERT( (pTransactionParameters)->DataLength == 0 );                   \
          ASSERT( (pTransactionParameters)->pDataMdl == NULL );                  \
          ASSERT( FlagOn((pTransactionParameters)->Flags,TRANSACTION_SEND_PARAMETERS_FLAG) ); \
          (pTransactionParameters)->DataLength = Length;                         \
          (pTransactionParameters)->pDataMdl = pMdl;                             \
          (pTransactionParameters)->Flags |= SMB_XACT_FLAGS_CALLERS_SENDDATAMDL;    \
  }

extern VOID
SmbCeUninitializeTransactionParameters(
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters);

extern VOID
SmbCeDiscardTransactExchange(PSMB_TRANSACT_EXCHANGE pTransactExchange);

INLINE NTSTATUS
SmbCeInitializeTransactionSendParameters(
      PVOID  pSetup,
      USHORT SetupLength,
      PVOID  pParam,
      ULONG  ParamLength,
      PVOID  pData,
      ULONG  DataLength,
      PSMB_TRANSACTION_SEND_PARAMETERS pSendParameters)
{
   ((PSMB_TRANSACTION_PARAMETERS)pSendParameters)->Flags = TRANSACTION_SEND_PARAMETERS_FLAG;
   return SmbCeInitializeTransactionParameters(
                pSetup,SetupLength,pParam,ParamLength,pData,DataLength,pSendParameters);

}

INLINE NTSTATUS
SmbCeInitializeTransactionReceiveParameters(
      PVOID  pSetup,
      USHORT SetupLength,
      PVOID  pParam,
      ULONG  ParamLength,
      PVOID  pData,
      ULONG  DataLength,
      PSMB_TRANSACTION_RECEIVE_PARAMETERS pReceiveParameters)
{
   ((PSMB_TRANSACTION_PARAMETERS)pReceiveParameters)->Flags = TRANSACTION_RECEIVE_PARAMETERS_FLAG;
   return SmbCeInitializeTransactionParameters(
                pSetup,SetupLength,pParam,ParamLength,pData,DataLength,pReceiveParameters);

}

#define SmbCeUninitializeTransactionSendParameters(pSendParameters)  \
        ASSERT((pSendParameters)->Flags & TRANSACTION_SEND_PARAMETERS_FLAG); \
        SmbCeUninitializeTransactionParameters(pSendParameters);

#define SmbCeUninitializeTransactionReceiveParameters(pReceiveParameters)  \
        ASSERT((pReceiveParameters)->Flags & TRANSACTION_RECEIVE_PARAMETERS_FLAG); \
        SmbCeUninitializeTransactionParameters(pReceiveParameters)

INLINE VOID
SmbCeInitializeTransactionResumptionContext(
   PSMB_TRANSACTION_RESUMPTION_CONTEXT ptResumptionContext)
{
   SmbCeInitializeResumptionContext(&(ptResumptionContext)->SmbCeResumptionContext);
   ptResumptionContext->SetupBytesReceived = 0;
   ptResumptionContext->DataBytesReceived = 0;
   ptResumptionContext->ParameterBytesReceived = 0;
   ptResumptionContext->FinalStatusFromServer = (STATUS_SUCCESS);
}

INLINE VOID
SmbCeInitializeAsynchronousTransactionResumptionContext(
   PSMB_TRANSACTION_RESUMPTION_CONTEXT ptResumptionContext,
   PRX_WORKERTHREAD_ROUTINE            pResumptionRoutine,
   PVOID                               pResumptionRoutineParam)
{
   SmbCeInitializeAsynchronousResumptionContext(
        &ptResumptionContext->SmbCeResumptionContext,
        pResumptionRoutine,
        pResumptionRoutineParam);

   ptResumptionContext->SetupBytesReceived     = 0;
   ptResumptionContext->DataBytesReceived      = 0;
   ptResumptionContext->ParameterBytesReceived = 0;
   ptResumptionContext->FinalStatusFromServer  = (STATUS_SUCCESS);
}

INLINE VOID
SmbCeWaitOnTransactionResumptionContext(
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pTransactionResumptionContext)
{
   SmbCeSuspend(&pTransactionResumptionContext->SmbCeResumptionContext);
}


extern UNICODE_STRING s_NamedPipeTransactionName;
extern UNICODE_STRING s_MailSlotTransactionName;

extern NTSTATUS
SmbCeSubmitTransactionRequest(
   PRX_CONTEXT                 RxContext,
   PSMB_TRANSACTION_OPTIONS    pOptions,
   PSMB_TRANSACTION_PARAMETERS pSendParameters,
   PSMB_TRANSACTION_PARAMETERS pReceiveParameters,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT   pResumptionContext );

extern NTSTATUS
_SmbCeTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferlength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext);


INLINE NTSTATUS
SmbCeTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferlength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext)
{
   SmbCeInitializeTransactionResumptionContext(pResumptionContext);

   return _SmbCeTransact(
               RxContext,
               pOptions,
               pInputSetupBuffer,
               InputSetupBufferlength,
               pOutputSetupBuffer,
               OutputSetupBufferLength,
               pInputParamBuffer,
               InputParamBufferLength,
               pOutputParamBuffer,
               OutputParamBufferLength,
               pInputDataBuffer,
               InputDataBufferLength,
               pOutputDataBuffer,
               OutputDataBufferLength,
               pResumptionContext);
}

INLINE NTSTATUS
SmbCeAsynchronousTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferlength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext)
{
    pOptions->Flags |= SMB_XACT_FLAGS_ASYNCHRONOUS;
    return _SmbCeTransact(
               RxContext,
               pOptions,
               pInputSetupBuffer,
               InputSetupBufferlength,
               pOutputSetupBuffer,
               OutputSetupBufferLength,
               pInputParamBuffer,
               InputParamBufferLength,
               pOutputParamBuffer,
               OutputParamBufferLength,
               pInputDataBuffer,
               InputDataBufferLength,
               pOutputDataBuffer,
               OutputDataBufferLength,
               pResumptionContext);
}

#endif // _TRANSACT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\usrcnnct.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    NtConnct.h

Abstract:

    This module defines the prototypes and structures for the nt version of the high level routines dealing
    with connections including both the routines for establishing connections and the winnet connection apis.


Author:

    Joe Linn     [JoeLinn]   1-mar-95

Revision History:

--*/

#ifndef _CONNECTHIGH_STUFF_DEFINED_
#define _CONNECTHIGH_STUFF_DEFINED_


extern NTSTATUS
MRxEnumerateTransports(
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

extern NTSTATUS
MRxSmbEnumerateConnections (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

extern NTSTATUS
MRxSmbGetConnectionInfo (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

extern NTSTATUS
MRxSmbDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

#if 0
//this structure is used to store information about a connection that must be obtained under server/session reference.
typedef struct _GETCONNECTINFO_STOVEPIPE {
    //PMRX_V_NET_ROOT VNetRoot;
    PVOID           ConnectionInfo;
    USHORT          Level;
    PUNICODE_STRING UserName;
    PUNICODE_STRING TransportName;
   //i have just copied this from SMBCE.h
   //ULONG                   Dialect;                // the SMB dialect
   ULONG                         SessionKey;             // the session key
   //USHORT                        MaximumRequests;        // Maximum number of multiplexed requests
   //USHORT                                    MaximumVCs;             // Maximum number of VC's
   //USHORT                        Capabilities;           // Server Capabilities
   ULONG                         DialectFlags;           // More Server Capabilities
   ULONG                             SecurityMode;           // Security mode supported on the server
   //ULONG                                       MaximumBufferSize;      // Maximum negotiated buffer size.
   LARGE_INTEGER                 TimeZoneBias;           // Time zone bias for conversion.
   BOOLEAN                       EncryptPasswords;       // encrypt passwords

   //ULONG         NtCapabilities;
} GETCONNECTINFO_STOVEPIPE, *PGETCONNECTINFO_STOVEPIPE;
#endif //if 0

#endif // _CONNECTHIGH_STUFF_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\transprt.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    transprt.h

Abstract:

    This module implements all transport related functions in the SMB connection
    engine

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

Notes:


--*/

#ifndef _TRANSPRT_H_
#define _TRANSPRT_H_

// The SMBCE_TRANSPORT data structure encapsulates all the information w.r.t a
// particular transport for the connection engine. All the transports that are
// of interest to the SMB mini redirector are maintained in a doubly linked list
//
// The connection engine tries all the transports in this list when trying to
// establish a connection to a server. Currently only connection oriented
// transports are handled.

typedef struct _SMBCE_TRANSPORT_ {
   SMBCE_OBJECT_HEADER;

   RXCE_TRANSPORT   RxCeTransport;
   RXCE_ADDRESS     RxCeAddress;

   ULONG            Priority;       // the priority in the binding list.

   BOOLEAN          Active;

   // Additional information regarding quality of service and other selection
   // criterion for a transport will be included here.

} SMBCE_TRANSPORT, *PSMBCE_TRANSPORT;

typedef struct _SMBCE_TRANSPORT_ARRAY_ {
    ULONG               ReferenceCount;
    ULONG               Count;
    PSMBCE_TRANSPORT    *SmbCeTransports;
    PRXCE_ADDRESS       *LocalAddresses;
} SMBCE_TRANSPORT_ARRAY, *PSMBCE_TRANSPORT_ARRAY;


typedef struct _SMBCE_TRANSPORTS_ {
   RX_SPIN_LOCK             Lock;
   PSMBCE_TRANSPORT_ARRAY   pTransportArray;
} SMBCE_TRANSPORTS, *PSMBCE_TRANSPORTS;

extern SMBCE_TRANSPORTS MRxSmbTransports;


// Transport entries are added to the list of known transports upon receipt of
// PnP notifications. Currently the list is static since transport disabling
// notifications are not handled by the underlying TDI/PnP layer.
// The following routines provide the ability for adding/deleting entries to
// this list.

extern
PSMBCE_TRANSPORT_ARRAY
SmbCeReferenceTransportArray(VOID);

extern NTSTATUS
SmbCeDereferenceTransportArray(PSMBCE_TRANSPORT_ARRAY pTransportArray);

extern NTSTATUS
SmbCeAddTransport(PSMBCE_TRANSPORT pTransport);

extern NTSTATUS
SmbCeRemoveTransport(PSMBCE_TRANSPORT pTransport);

#define SmbCeGetAvailableTransportCount()   \
        (MRxSmbTransports.Count)

// The connection engine maintains a reference count associated with each transport
// which indicates the number of servers that are using the transport. This will
// eventually provide the mechanism for disabling/enabling transport on receipt
// of PnP notifications.

#define SmbCeReferenceTransport(pTransport)                                   \
        SmbCepReferenceTransport(pTransport)

#define SmbCeDereferenceTransport(pTransport)                                 \
        SmbCepDereferenceTransport(pTransport)

// The server transport types encapsulate the various usages of the underlying
// transport to communicate with a server. For example the type of interactions
// with a mailslot server ( primarily datagrams ) is very different from the
// interactions with a FILE SERVER ( connection oriented send/receives). The
// type of interactions can be further classified by the underlying connection
// characterstics, e.g., connecting to a FILE_SERVER over a RAS connection as
// opposed to connecting to a file server over EtherNet.
//
// The interactions are currently classified into four types, MAILSOT, Virtual
// Circuit, Datagram and Htbrid ( VC + Datagram ).
//
// The type chosen will depend upon the characterstics of the available
// connection. Each type is associated with its own dispatch vector which
// encapsulates the interaction between the connection engine and the transport.
//
// This includes Send,Receive, Receive Ind. etc. These are modelled after the
// TDI interfaces.


typedef enum _SMBCE_SERVER_TRANSPORT_TYPE_ {
    SMBCE_STT_MAILSLOT = 1,
    SMBCE_STT_VC       = 2,
    SMBCE_STT_DATAGRAM = 4,
    SMBCE_STT_HYBRID   = 8
} SMBCE_SERVER_TRANSPORT_TYPE, *PSMBCE_SERVER_TRANSPORT_TYPE;

typedef struct SMBCE_SERVER_TRANSPORT {
   SMBCE_OBJECT_HEADER;

   struct TRANSPORT_DISPATCH_VECTOR *pDispatchVector;
   struct _SMBCE_TRANSPORT_         *pTransport;

   PKEVENT                          pRundownEvent;      // used for finalization.

   ULONG                            MaximumSendSize;    // max data size
} SMBCE_SERVER_TRANSPORT, *PSMBCE_SERVER_TRANSPORT;

// The SMBCE_SERVER_TRANSPORT instances are reference counted. The following
// routines provide the referencing mechanism. Defining them as macros also
// provides us with a easy debugging capability, i.e., it can be easily modified
// to include a FILE/LINE number each time an instance is referenced and
// dereferenced

#define SmbCeReferenceServerTransport(pServerTransportPointer)                    \
        SmbCepReferenceServerTransport(pServerTransportPointer)

#define SmbCeDereferenceServerTransport(pServerTransportPointer)           \
        SmbCepDereferenceServerTransport(pServerTransportPointer)

// The server transport establishment mechanism requires a callback mechanism
// to handle the asynchronous connection establishment cases.

typedef
VOID
(*PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK)(
    PVOID   pContext);

typedef
VOID
(*PSMBCE_SERVER_TRANSPORT_DESTRUCTION_CALLBACK)(
    PVOID   pContext);

typedef enum _SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE {
    SmbCeServerTransportConstructionBegin,
    SmbCeServerMailSlotTransportConstructionBegin,
    SmbCeServerMailSlotTransportConstructionEnd,
    SmbCeServerVcTransportConstructionBegin,
    SmbCeServerVcTransportConstructionEnd,
    SmbCeServerTransportConstructionEnd
} SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE,
  *PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE;

typedef struct _SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT {
    NTSTATUS                      Status;

    SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE State;

    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK pCompletionRoutine;
    PMRX_SRVCALL_CALLBACK_CONTEXT                 pCallbackContext;

    PKEVENT                       pCompletionEvent;

    PSMBCEDB_SERVER_ENTRY         pServerEntry;
    ULONG                         TransportsToBeConstructed;

    PSMBCE_SERVER_TRANSPORT pMailSlotTransport;
    PSMBCE_SERVER_TRANSPORT pTransport;

    RX_WORK_QUEUE_ITEM    WorkQueueItem;
} SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT,
  *PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT;

// The SERVER transport dispatch vector prototypes

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_SEND)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_SEND_DATAGRAM)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_TRANCEIVE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_RECEIVE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_INITIALIZE_EXCHANGE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE         pExchange);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_UNINITIALIZE_EXCHANGE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE         pExchange);

typedef
VOID
(*PTRANSPORT_DISPATCH_TEARDOWN)(
    PSMBCE_SERVER_TRANSPORT    pTransport);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_INITIATE_DISCONNECT)(
    PSMBCE_SERVER_TRANSPORT    pTransport);

typedef struct TRANSPORT_DISPATCH_VECTOR {
   PTRANSPORT_DISPATCH_SEND                  Send;
   PTRANSPORT_DISPATCH_SEND_DATAGRAM         SendDatagram;
   PTRANSPORT_DISPATCH_TRANCEIVE             Tranceive;
   PTRANSPORT_DISPATCH_RECEIVE               Receive;
   PRX_WORKERTHREAD_ROUTINE                  TimerEventHandler;
   PTRANSPORT_DISPATCH_INITIALIZE_EXCHANGE   InitializeExchange;
   PTRANSPORT_DISPATCH_UNINITIALIZE_EXCHANGE UninitializeExchange;
   PTRANSPORT_DISPATCH_TEARDOWN              TearDown;
   PTRANSPORT_DISPATCH_INITIATE_DISCONNECT   InitiateDisconnect;
} TRANSPORT_DISPATCH_VECTOR, *PTRANSPORT_DISPATCH_VECTOR;

// A macro for invoking a routine through the SMBCE_SERVER_TRANSPORT
// dispatch vector.

#define SMBCE_TRANSPORT_DISPATCH(pServerEntry,Routine,Arguments)        \
      (*((pServerEntry)->pTransport->pDispatchVector->Routine))##Arguments

// The currently known transport type dispatch vectors and the mechanisms
// for instanting an instance.

extern TRANSPORT_DISPATCH_VECTOR MRxSmbVctTransportDispatch;
extern TRANSPORT_DISPATCH_VECTOR MRxSmbMsTransportDispatch;

extern NTSTATUS
MsInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext);

extern NTSTATUS
VctInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext);

extern VOID
SmbCeConstructServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext);

// The following routines constitute the interface by which the clients of
// the connection engine initialize/send/receive/uninitialize data to the
// remote servers

extern NTSTATUS
SmbCeInitializeExchangeTransport(
    PSMB_EXCHANGE         pExchange);

extern NTSTATUS
SmbCeUninitializeExchangeTransport(
    PSMB_EXCHANGE         pExchange);

extern NTSTATUS
SmbCeInitiateDisconnect(
    IN OUT PSMBCEDB_SERVER_ENTRY pServerEntry);


// The routines for constructing the transports provide the flexibility to
// construct certain combination of transports. This is provided by the
// SmbCepInitializeServerTransport routine and the different flavours of
// construction routines provided

#define SMBCE_CONSTRUCT_ALL_TRANSPORTS \
            (SMBCE_STT_MAILSLOT | SMBCE_STT_VC)

extern NTSTATUS
SmbCepInitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                         pServerEntry,
    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK pCallbackRoutine,
    PMRX_SRVCALL_CALLBACK_CONTEXT                 pCallbackContext,
    ULONG                                         TransportsToBeConsstructed);


#define SmbCeInitializeServerTransport(pServerEntry,pCallbackRoutine,pCallbackContext) \
        SmbCepInitializeServerTransport(                                               \
            (pServerEntry),                                                            \
            (pCallbackRoutine),                                                        \
            (pCallbackContext),                                                        \
            SMBCE_CONSTRUCT_ALL_TRANSPORTS)

#define SmbCeInitializeServerMailSlotTransport(pServerEntry,pCallbackRoutine,pCallbackContext) \
        SmbCepInitializeServerTransport(                                               \
            (pServerEntry),                                                            \
            (pCallbackRoutine),                                                        \
            (pCallbackContext),                                                        \
            SMBCE_STT_MAILSLOT)


extern NTSTATUS
SmbCeUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                        pServerEntry,
    PSMBCE_SERVER_TRANSPORT_DESTRUCTION_CALLBACK pCallbackRoutine,
    PVOID                                        pCallbackContext);

extern VOID
SmbCeCompleteUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

extern NTSTATUS
SmbCepReferenceTransport(
    IN OUT PSMBCE_TRANSPORT pTransport);

extern NTSTATUS
SmbCepDereferenceTransport(
    IN OUT PSMBCE_TRANSPORT pTransport);

extern PSMBCE_TRANSPORT
SmbCeFindTransport(
    PUNICODE_STRING pTransportName);

extern NTSTATUS
SmbCepReferenceServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT *pTransportPointer);

extern NTSTATUS
SmbCepDereferenceServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT *pTransportPointer);

extern PFILE_OBJECT
SmbCepReferenceEndpointFileObject(
    IN PSMBCE_SERVER_TRANSPORT pTransport);

extern NTSTATUS
SmbCeSend(
    PSMB_EXCHANGE         pExchange,
    ULONG                 SendOptions,
    PMDL            pSmbMdl,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeSendToServer(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    ULONG                 SendOptions,
    PMDL            pSmbMdl,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeSendDatagram(
    PSMB_EXCHANGE         pExchange,
    ULONG                 SendOptions,
    PMDL            pSmbMdl,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeTranceive(
    PSMB_EXCHANGE         pExchange,
    ULONG                 SendOptions,
    PMDL            pRxCeDataBuffer,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeReceive(
    PSMB_EXCHANGE         pExchange);


//
// Call ups from the transport to the connection engine
//

extern NTSTATUS
SmbCeReceiveInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN ULONG                 BytesIndicated,
    IN ULONG                 BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN PVOID                 pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL                 *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG               pDataBufferSize,        // amount of data to copy
    IN ULONG                 ReceiveFlags
    );

extern NTSTATUS
SmbCeDataReadyInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN PMDL            pBuffer,
    IN ULONG                 DataSize,
    IN NTSTATUS              DataReadyStatus
    );

extern NTSTATUS
SmbCeErrorInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN NTSTATUS              IndicatedStatus
    );

extern NTSTATUS
SmbCeSendCompleteInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN PVOID                 pCompletionContext,
    IN NTSTATUS              SendCompletionStatus
    );

extern VOID
MRxSmbLogTransportError(
    PUNICODE_STRING pTransportName,
    PUNICODE_STRING pDomainName,
    NTSTATUS        Status,
    ULONG           Id);


#endif // _TRANSPRT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\vcsndrcv.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    vcsndrcv.h

Abstract:

    This is the include file that defines all constants and types for VC
    (Virtual Circuit) related Send/Receive/INitialization etc.

Revision History:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

Notes:

--*/

#ifndef _VCSNDRCV_H_
#define _VCSNDRCV_H_

// The connection oriented transport to a server can utilize multiple VC's to
// acheive better throughput to a server. It is for this reason that the
// VC transport data structure is built around multiple VC's. Howvever this
// feature is not utilized currently.
//
// Though the SMB protocol permits multiple number of VC's to be associated with
// a particular connection to a share, the data transfer of data is done in the
// raw mode. In this mode of operation the SMB protocol does not permit multiple
// outstanding requests. In the SMB protocol a number of requests can be multiplexed
// along a connection to the server There are certain kind of requests which can
// be completed on the client, i.e., no acknowledgement is neither expected nor
// received. In these cases the send call is completed synchronoulsy. On the
// other hand there is a second class of sends which cannot be resumed locally
// till the appropriate acknowledgement is recieved from the server. In such
// cases a list of requests is built up with each VC. On receipt of the appropriate
// acknowledgement these requests are resumed.
//

typedef enum _SMBCE_VC_STATE_ {
    SMBCE_VC_STATE_MULTIPLEXED,
    SMBCE_VC_STATE_RAW,
    SMBCE_VC_STATE_DISCONNECTED,
} SMBCE_VC_STATE, *PSMBCE_VC_STATE;

typedef struct _SMBCE_VC {
    SMBCE_OBJECT_HEADER;                // the struct header

    RXCE_VC     RxCeVc;

    NTSTATUS    Status;      // Status of the VC.
} SMBCE_VC, *PSMBCE_VC;

typedef struct SMBCE_SERVER_VC_TRANSPORT {
    SMBCE_SERVER_TRANSPORT;     // Anonymous struct for common fields

    RXCE_CONNECTION RxCeConnection;     // the connection handle
    LARGE_INTEGER   Delay;           // the estimated delay on the connection
    ULONG           MaximumNumberOfVCs;

    SMBCE_VC                    Vcs[1];          // Vcs associated with the connection.
} SMBCE_SERVER_VC_TRANSPORT, *PSMBCE_SERVER_VC_TRANSPORT;


#define VctReferenceVc(pVc)                           \
            InterlockedIncrement(&(pVc)->SwizzleCount)

#define VctReferenceVcLite(pVc)                       \
            ASSERT(SmbCeSpinLockAcquired());                    \
            (pVc)->SwizzleCount++


#define VctDereferenceVc(pVc)                           \
            InterlockedDecrement(&(pVc)->SwizzleCount)

#define VctDereferenceVcLite(pVc)                       \
            ASSERT(SmbCeSpinLockAcquired());                    \
            (pVc)->SwizzleCount--

#endif // _VCSNDRCV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\usrcnnct.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NtConnct.c

Abstract:

    This module implements the nt version of the high level routines dealing with
    connections including both the routines for establishing connections and the
    winnet connection apis.

Author:

    Joe Linn     [JoeLinn]   1-mar-95

Revision History:

    Balan Sethu Raman [SethuR] --

--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs2.h>
#include <ntddmup.h>
#include "fsctlbuf.h"
#include "prefix.h"
#include <lmuse.h>    //need the lm constants here......because of wkssvc
#include "usrcnnct.h" //just to get the stovepipe definition
#include "secext.h"
#include "nb30.h"     // to get ADAPTER_STATUS definition
#include "vcsndrcv.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_NTCONNCT)

//
//  The local trace mask for this part of the module
//

#define Dbg                              (DEBUG_TRACE_CONNECT)

VOID
MRxSmbGetConnectInfoLevel3Fields(
    IN OUT PLMR_CONNECTION_INFO_3 ConnectionInfo,
    IN  PSMBCEDB_SERVER_ENTRY  pServerEntry,
    IN  BOOL    fAgentCall
    );

extern NTSTATUS
MRxEnumerateTransportBindings(
    IN PLMR_REQUEST_PACKET pLmrRequestPacket,
    IN ULONG               LmrRequestPacketLength,
    OUT PVOID              pBindingBuffer,
    IN OUT ULONG           BindingBufferLength);

BOOLEAN
MRxSmbShowConnection(
    IN LUID LogonId,
    IN PV_NET_ROOT VNetRoot
    );

#ifdef _WIN64
typedef struct _UNICODE_STRING_32 {
    USHORT Length;
    USHORT MaximumLength;
    WCHAR * POINTER_32 Buffer;
} UNICODE_STRING_32, *PUNICODE_STRING_32;

typedef struct _LMR_CONNECTION_INFO_0_32 {
    UNICODE_STRING_32 UNCName;                          // Name of UNC connection
    ULONG ResumeKey;                    // Resume key for this entry.
}  LMR_CONNECTION_INFO_0_32, *PLMR_CONNECTION_INFO_0_32;

typedef struct _LMR_CONNECTION_INFO_1_32 {
    UNICODE_STRING_32 UNCName;                          // Name of UNC connection
    ULONG ResumeKey;                    // Resume key for this entry.

    DEVICE_TYPE SharedResourceType;     // Type of shared resource
    ULONG ConnectionStatus;             // Status of the connection
    ULONG NumberFilesOpen;              // Number of opened files
} LMR_CONNECTION_INFO_1_32, *PLMR_CONNECTION_INFO_1_32;

typedef struct _LMR_CONNECTION_INFO_2_32 {
    UNICODE_STRING_32 UNCName;                          // Name of UNC connection
    ULONG ResumeKey;                    // Resume key for this entry.
    DEVICE_TYPE SharedResourceType;     // Type of shared resource
    ULONG ConnectionStatus;             // Status of the connection
    ULONG NumberFilesOpen;              // Number of opened files

    UNICODE_STRING_32 UserName;                         // User who created connection.
    UNICODE_STRING_32 DomainName;                       // Domain of user who created connection.
    ULONG Capabilities;                 // Bit mask of remote abilities.
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH]; // User session key
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH]; // Lanman session key
}  LMR_CONNECTION_INFO_2_32, *PLMR_CONNECTION_INFO_2_32;

typedef struct _LMR_CONNECTION_INFO_3_32 {
    UNICODE_STRING_32 UNCName;                          // Name of UNC connection
    ULONG ResumeKey;                    // Resume key for this entry.
    DEVICE_TYPE SharedResourceType;     // Type of shared resource
    ULONG ConnectionStatus;             // Status of the connection
    ULONG NumberFilesOpen;              // Number of opened files

    UNICODE_STRING_32 UserName;                         // User who created connection.
    UNICODE_STRING_32 DomainName;                       // Domain of user who created connection.
    ULONG Capabilities;                 // Bit mask of remote abilities.
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH]; // User session key
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH]; // Lanman session key
    UNICODE_STRING_32 TransportName;                    // Transport connection is active on
    ULONG   Throughput;                 // Throughput of connection.
    ULONG   Delay;                      // Small packet overhead.
    LARGE_INTEGER TimeZoneBias;         // Time zone delta in 100ns units.
    BOOL    IsSpecialIpcConnection;     // True IFF there is a special IPC connection active.
    BOOL    Reliable;                   // True iff the connection is reliable
    BOOL    ReadAhead;                  // True iff readahead is active on connection.
    BOOL    Core;
    BOOL    MsNet103;
    BOOL    Lanman10;
    BOOL    WindowsForWorkgroups;
    BOOL    Lanman20;
    BOOL    Lanman21;
    BOOL    WindowsNt;
    BOOL    MixedCasePasswords;
    BOOL    MixedCaseFiles;
    BOOL    LongNames;
    BOOL    ExtendedNegotiateResponse;
    BOOL    LockAndRead;
    BOOL    NtSecurity;
    BOOL    SupportsEa;
    BOOL    NtNegotiateResponse;
    BOOL    CancelSupport;
    BOOL    UnicodeStrings;
    BOOL    LargeFiles;
    BOOL    NtSmbs;
    BOOL    RpcRemoteAdmin;
    BOOL    NtStatusCodes;
    BOOL    LevelIIOplock;
    BOOL    UtcTime;
    BOOL    UserSecurity;
    BOOL    EncryptsPasswords;
}  LMR_CONNECTION_INFO_3_32, *PLMR_CONNECTION_INFO_3_32;

VOID
MRxSmbGetConnectInfoLevel3FieldsThunked(
    IN OUT PLMR_CONNECTION_INFO_3_32 ConnectionInfo,
    IN     PSMBCEDB_SERVER_ENTRY     pServerEntry,
    BOOL   fAgentCall
    );

BOOLEAN
MRxSmbPackStringIntoConnectInfoThunked(
    IN     PUNICODE_STRING_32 String,
    IN     PUNICODE_STRING    Source,
    IN OUT PCHAR * BufferStart,
    IN OUT PCHAR * BufferEnd,
    IN     ULONG   BufferDisplacement,
    IN OUT PULONG TotalBytes
    );

BOOLEAN
MRxSmbPackConnectEntryThunked (
    IN OUT PRX_CONTEXT RxContext,
    IN     ULONG Level,
    IN OUT PCHAR *BufferStart,
    IN OUT PCHAR *BufferEnd,
    IN     PV_NET_ROOT VNetRoot,
    IN OUT ULONG BufferDisplacement,
       OUT PULONG TotalBytesNeeded
    );
#endif

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbPackStringIntoConnectInfo)
#pragma alloc_text(PAGE, MRxSmbPackConnectEntry)
#pragma alloc_text(PAGE, MRxSmbGetConnectInfoLevel3Fields)
#pragma alloc_text(PAGE, MRxSmbEnumerateConnections)
#pragma alloc_text(PAGE, MRxSmbGetConnectionInfo)
#pragma alloc_text(PAGE, MRxSmbDeleteConnection)
#pragma alloc_text(PAGE, MRxEnumerateTransports)
#pragma alloc_text(PAGE, MRxEnumerateTransportBindings)
#ifdef _WIN64
#pragma alloc_text(PAGE, MRxSmbGetConnectInfoLevel3FieldsThunked)
#pragma alloc_text(PAGE, MRxSmbPackStringIntoConnectInfoThunked)
#pragma alloc_text(PAGE, MRxSmbPackConnectEntryThunked)
#endif
#endif

BOOLEAN
MRxSmbPackStringIntoConnectInfo(
    IN     PUNICODE_STRING String,
    IN     PUNICODE_STRING Source,
    IN OUT PCHAR * BufferStart,
    IN OUT PCHAR * BufferEnd,
    IN     ULONG   BufferDisplacement,
    IN OUT PULONG TotalBytes
    )
/*

Routine Description:

    This code copies a string to the end of the buffer IF THERE'S ROOM. the buffer
    displacement is used to map the buffer back into the user's space in case we
    have posted.

Arguments:

Return Value:

*/
{
    LONG size;

    PAGED_CODE();

    ASSERT (*BufferStart <= *BufferEnd);

    //
    //  is there room for the string?
    //

    size = Source->Length;

    if ((*BufferEnd - *BufferStart) < size) {
        String->Length = 0;
        return(FALSE);
    } else {
        String->Length = Source->Length;
        String->MaximumLength = Source->Length;

        *BufferEnd -= size;
        if (TotalBytes!=NULL) {  *TotalBytes += size; }
        RtlCopyMemory(*BufferEnd, Source->Buffer, size);
        (PCHAR )(String->Buffer) = *BufferEnd;
        (PCHAR )(String->Buffer) -= BufferDisplacement;
        return(TRUE);
    }
}

#ifdef _WIN64
BOOLEAN
MRxSmbPackStringIntoConnectInfoThunked(
    IN     PUNICODE_STRING_32 String,
    IN     PUNICODE_STRING    Source,
    IN OUT PCHAR * BufferStart,
    IN OUT PCHAR * BufferEnd,
    IN     ULONG   BufferDisplacement,
    IN OUT PULONG TotalBytes
    )
/*

Routine Description:

    This code copies a string to the end of the buffer IF THERE'S ROOM. the buffer
    displacement is used to map the buffer back into the user's space in case we
    have posted.

Arguments:

Return Value:

*/
{
    LONG size;

    PAGED_CODE();

    ASSERT (*BufferStart <= *BufferEnd);

    //
    //  is there room for the string?
    //

    size = Source->Length;

    if ((*BufferEnd - *BufferStart) < size) {
        String->Length = 0;
        return(FALSE);
    } else {
        String->Length = Source->Length;
        String->MaximumLength = Source->Length;

        *BufferEnd -= size;
        if (TotalBytes!=NULL) {  *TotalBytes += size; }
        RtlCopyMemory(*BufferEnd, Source->Buffer, size);
        (WCHAR * POINTER_32)(String->Buffer) = (WCHAR * POINTER_32)(*BufferEnd);
        (WCHAR * POINTER_32)(String->Buffer) -= BufferDisplacement;
        return(TRUE);
    }
}
#endif

UNICODE_STRING MRxSmbPackConnectNull = {0,0,NULL};

BOOLEAN
MRxSmbPackConnectEntry (
    IN OUT PRX_CONTEXT RxContext,
    IN     ULONG Level,
    IN OUT PCHAR *BufferStart,
    IN OUT PCHAR *BufferEnd,
    IN     PV_NET_ROOT VNetRoot,
    IN OUT ULONG   BufferDisplacement,
       OUT PULONG TotalBytesNeeded
    )
/*++

Routine Description:

    This routine packs a connectlistentry into the buffer provided updating
    all relevant pointers. The way that this works is that constant length stuff is
    copied to the front of the buffer and variable length stuff to the end. The
    "start and end" pointers are updated. You have to calculate the totalbytes correctly
    no matter what but a last can be setup incompletely as long as you return false.

    the way that this works is that it calls down into the minirdr on the devfcb
    interface. it calls down twice and passes a structure back and forth thru the
    context to maintain state.

Arguments:

    IN ULONG Level - Level of information requested.

    IN OUT PCHAR *BufferStart - Supplies the output buffer.
                                            Updated to point to the next buffer
    IN OUT PCHAR *BufferEnd - Supplies the end of the buffer.  Updated to
                                            point before the start of the
                                            strings being packed.
    IN PNET_ROOT NetRoot - Supplies the NetRoot to enumerate.

    IN OUT PULONG TotalBytesNeeded - Updated to account for the length of this
                                        entry

Return Value:

    BOOLEAN - True if the entry was successfully packed into the buffer.


--*/
{
    NTSTATUS Status;
    BOOLEAN ReturnValue = TRUE;

    //PWCHAR ConnectName;          // Buffer to hold the packed name
    UNICODE_STRING ConnectName;  // Buffer to hold the packed name
    //ULONG NameLength;
    ULONG BufferSize;
    PLMR_CONNECTION_INFO_3 ConnectionInfo = (PLMR_CONNECTION_INFO_3)*BufferStart;
    PNET_ROOT NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    PSMBCEDB_SESSION_ENTRY pSessionEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = SmbCeGetAssociatedVNetRootContext((PMRX_V_NET_ROOT)VNetRoot);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("PackC\n"));
    
    switch (Level) {
    case 0:
        BufferSize = sizeof(LMR_CONNECTION_INFO_0);
        break;
    case 1:
        BufferSize = sizeof(LMR_CONNECTION_INFO_1);
        break;
    case 2:
        BufferSize = sizeof(LMR_CONNECTION_INFO_2);
        break;
    case 3:
        BufferSize = sizeof(LMR_CONNECTION_INFO_3);
        break;
    default:
        return FALSE;
    }

    if (pVNetRootContext == NULL) {
        return TRUE;
    }

    ConnectName.Buffer = RxAllocatePoolWithTag(NonPagedPool, MAX_PATH * sizeof(WCHAR), 'mNxR');

    if( ConnectName.Buffer == NULL ) {
        return FALSE;
    }

    try {
        pServerEntry  = pVNetRootContext->pServerEntry;
        pSessionEntry = pVNetRootContext->pSessionEntry;

        ASSERT((pServerEntry != NULL) && (pSessionEntry != NULL));

        *BufferStart = ((PUCHAR)*BufferStart) + BufferSize;
        *TotalBytesNeeded += BufferSize;

        //
        //  Initialize the name to "\" then add in the rest
        //

        ConnectName.Buffer[0] = L'\\';

        RtlCopyMemory(&ConnectName.Buffer[1], NetRoot->PrefixEntry.Prefix.Buffer, NetRoot->PrefixEntry.Prefix.Length);

        ConnectName.Length = (sizeof(WCHAR)) + NetRoot->PrefixEntry.Prefix.Length;
        ConnectName.MaximumLength = ConnectName.Length;

        //
        //  Update the total number of bytes needed for this structure.
        //

        *TotalBytesNeeded += ConnectName.Length;

        if (*BufferStart > *BufferEnd) {
            try_return( ReturnValue = FALSE);
        }

        ConnectionInfo->ResumeKey = NetRoot->SerialNumberForEnum;

        if (Level > 0) {
            ULONG ConnectionStatus = 0;

            ConnectionInfo->SharedResourceType = NetRoot->DeviceType;

            RxDbgTrace(0, Dbg, ("PackC data---> netroot netrootcondifiton  %08lx %08lx\n",
                                      NetRoot,NetRoot->Condition));

            MRxSmbUpdateNetRootState((PMRX_NET_ROOT)NetRoot);

            ConnectionInfo->ConnectionStatus = NetRoot->MRxNetRootState;

            ConnectionInfo->NumberFilesOpen = NetRoot->NumberOfSrvOpens;
            RxDbgTrace(0, Dbg, ("PackC data---> length restype resumek connstatus numfiles  %08lx %08lx %08lx %08lx %08lx\n",
                            ConnectionInfo->UNCName.Length,
                            ConnectionInfo->SharedResourceType,
                            ConnectionInfo->ResumeKey,
                            ConnectionInfo->ConnectionStatus,
                            ConnectionInfo->NumberFilesOpen));
        }

        if (Level > 1) {

            ULONG DialectFlags = pServerEntry->Server.DialectFlags;

            if (!BooleanFlagOn(
                    pSessionEntry->Session.Flags,
                    SMBCE_SESSION_FLAGS_LANMAN_SESSION_KEY_USED)) {
                RtlCopyMemory(
                    ConnectionInfo->UserSessionKey,
                    pSessionEntry->Session.UserSessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH);
            } else {
                ASSERT(MSV1_0_USER_SESSION_KEY_LENGTH >= MSV1_0_LANMAN_SESSION_KEY_LENGTH);

                RtlZeroMemory(
                    ConnectionInfo->UserSessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH);

                RtlCopyMemory(
                    ConnectionInfo->UserSessionKey,
                    pSessionEntry->Session.LanmanSessionKey,
                    MSV1_0_LANMAN_SESSION_KEY_LENGTH);
            }

            RtlCopyMemory(
                ConnectionInfo->LanmanSessionKey,
                pSessionEntry->Session.LanmanSessionKey,
                MSV1_0_LANMAN_SESSION_KEY_LENGTH);

            ConnectionInfo->Capabilities = 0;

            if (DialectFlags & DF_UNICODE) {
                ConnectionInfo->Capabilities |= CAPABILITY_UNICODE;
            }

            if (DialectFlags & DF_RPC_REMOTE) {
                ConnectionInfo->Capabilities |= CAPABILITY_RPC;
            }

            if ((DialectFlags & DF_NT_SMBS) && (DialectFlags & DF_RPC_REMOTE)) {
                ConnectionInfo->Capabilities |= CAPABILITY_SAM_PROTOCOL;
            }

            if (DialectFlags & DF_MIXEDCASE) {
                ConnectionInfo->Capabilities |= CAPABILITY_CASE_SENSITIVE_PASSWDS;
            }

            if (DialectFlags & DF_LANMAN10) {
                ConnectionInfo->Capabilities |= CAPABILITY_REMOTE_ADMIN_PROTOCOL;
            }

            ASSERT (!RxContext->PostRequest);
            RxDbgTrace(0, Dbg, ("PackC data---> capabilities  %08lx \n",  ConnectionInfo->Capabilities));
        }

        if (!MRxSmbPackStringIntoConnectInfo(
                &ConnectionInfo->UNCName,
                &ConnectName,
                BufferStart,
                BufferEnd,
                BufferDisplacement,
                NULL)) {
            if (Level > 1) {
                ConnectionInfo->UserName.Length = 0;
                ConnectionInfo->UserName.Buffer = NULL;
            }

            try_return( ReturnValue = FALSE);
        }

        if (Level > 1) {
            WCHAR UserNameBuffer[UNLEN + 1];
            WCHAR UserDomainNameBuffer[UNLEN + 1];

            UNICODE_STRING UserName,UserDomainName;

            UserName.Length = UserName.MaximumLength = UNLEN * sizeof(WCHAR);
            UserName.Buffer = UserNameBuffer;
            UserDomainName.Length = UserDomainName.MaximumLength = UNLEN * sizeof(WCHAR);
            UserDomainName.Buffer = UserDomainNameBuffer;

            Status = SmbCeGetUserNameAndDomainName(
                         pSessionEntry,
                         &UserName,
                         &UserDomainName);

            if (NT_SUCCESS(Status)) {
               if (!MRxSmbPackStringIntoConnectInfo(
                       &ConnectionInfo->UserName,
                       &UserName,
                       BufferStart,
                       BufferEnd,
                       BufferDisplacement,
                       TotalBytesNeeded)) {
                   try_return( ReturnValue = FALSE);
               }

               if (!MRxSmbPackStringIntoConnectInfo(
                        &ConnectionInfo->DomainName,
                        &UserDomainName,
                        BufferStart,
                        BufferEnd,
                        BufferDisplacement,
                        TotalBytesNeeded)) {
                   try_return( ReturnValue = FALSE);
               }
            } else {
               try_return( ReturnValue = FALSE);
            }
        }

        if (Level > 2) {
            WCHAR TransportNameBuffer[MAX_PATH + 1];
            UNICODE_STRING TransportName;

            MRxSmbGetConnectInfoLevel3Fields(ConnectionInfo,pServerEntry, FALSE);

            TransportName.Length = 0;
            TransportName.MaximumLength = UNLEN * sizeof(WCHAR);
            TransportName.Buffer = TransportNameBuffer;

            if ((pServerEntry->pTransport != NULL) &&
                !SmbCeIsServerInDisconnectedMode(pServerEntry)) {

                NTSTATUS RefTransportStatus;

                RefTransportStatus = SmbCeReferenceServerTransport(&pServerEntry->pTransport);

                if (RefTransportStatus == STATUS_SUCCESS) {
                    PUNICODE_STRING RxCeTransportName =
                                 &pServerEntry->pTransport->pTransport->RxCeTransport.Name;

                    TransportName.Length = RxCeTransportName->Length;

                    if (TransportName.Length <= TransportName.MaximumLength) {
                        RtlCopyMemory(
                            TransportName.Buffer,
                            RxCeTransportName->Buffer,
                            TransportName.Length);
                    } else {
                        Status = STATUS_BUFFER_OVERFLOW;
                    }

                    SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
                }
            }

            if (Status == STATUS_SUCCESS) {
                if (!MRxSmbPackStringIntoConnectInfo(
                        &ConnectionInfo->TransportName,
                        &TransportName,
                        BufferStart, BufferEnd,
                        BufferDisplacement,
                        TotalBytesNeeded)) {
                    try_return( ReturnValue = FALSE);
                }
            }
        }

    try_exit:
        NOTHING;

    } finally {
        RxFreePool(ConnectName.Buffer);
    }
    RxDbgTrace(-1, Dbg, ("PackC...%08lx\n",ReturnValue));

    return ReturnValue;
}

#ifdef _WIN64
BOOLEAN
MRxSmbPackConnectEntryThunked (
    IN OUT PRX_CONTEXT RxContext,
    IN     ULONG Level,
    IN OUT PCHAR *BufferStart,
    IN OUT PCHAR *BufferEnd,
    IN     PV_NET_ROOT VNetRoot,
    IN OUT ULONG  BufferDisplacement,
       OUT PULONG TotalBytesNeeded
    )
/*++

Routine Description:

    This routine packs a connectlistentry into the buffer provided updating
    all relevant pointers. The way that this works is that constant length stuff is
    copied to the front of the buffer and variable length stuff to the end. The
    "start and end" pointers are updated. You have to calculate the totalbytes correctly
    no matter what but a last can be setup incompletely as long as you return false.

    the way that this works is that it calls down into the minirdr on the devfcb
    interface. it calls down twice and passes a structure back and forth thru the
    context to maintain state.

Arguments:

    IN ULONG Level - Level of information requested.

    IN OUT PCHAR *BufferStart - Supplies the output buffer.
                                            Updated to point to the next buffer
    IN OUT PCHAR *BufferEnd - Supplies the end of the buffer.  Updated to
                                            point before the start of the
                                            strings being packed.
    IN PNET_ROOT NetRoot - Supplies the NetRoot to enumerate.

    IN OUT PULONG TotalBytesNeeded - Updated to account for the length of this
                                        entry

Return Value:

    BOOLEAN - True if the entry was successfully packed into the buffer.


--*/
{
    NTSTATUS Status;
    BOOLEAN ReturnValue = TRUE;

    //PWCHAR ConnectName;          // Buffer to hold the packed name
    UNICODE_STRING ConnectName;  // Buffer to hold the packed name
    //ULONG NameLength;
    ULONG BufferSize;
    PLMR_CONNECTION_INFO_3_32 ConnectionInfo = (PLMR_CONNECTION_INFO_3_32)*BufferStart;
    PNET_ROOT NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    PSMBCEDB_SESSION_ENTRY pSessionEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = SmbCeGetAssociatedVNetRootContext((PMRX_V_NET_ROOT)VNetRoot);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("PackC\n"));
    
    switch (Level) {
    case 0:
        BufferSize = sizeof(LMR_CONNECTION_INFO_0_32);
        break;
    case 1:
        BufferSize = sizeof(LMR_CONNECTION_INFO_1_32);
        break;
    case 2:
        BufferSize = sizeof(LMR_CONNECTION_INFO_2_32);
        break;
    case 3:
        BufferSize = sizeof(LMR_CONNECTION_INFO_3_32);
        break;
    default:
        return FALSE;
    }

    if (pVNetRootContext == NULL) {
        return TRUE;
    }

    ConnectName.Buffer = RxAllocatePoolWithTag(NonPagedPool, MAX_PATH * sizeof(WCHAR), 'mNxR');

    if( ConnectName.Buffer == NULL ) {
        return FALSE;
    }

    try {
        pServerEntry  = pVNetRootContext->pServerEntry;
        pSessionEntry = pVNetRootContext->pSessionEntry;

        ASSERT((pServerEntry != NULL) && (pSessionEntry != NULL));

        *BufferStart = ((PUCHAR)*BufferStart) + BufferSize;
        *TotalBytesNeeded += BufferSize;

        //
        //  Initialize the name to "\" then add in the rest
        //

        ConnectName.Buffer[0] = L'\\';

        RtlCopyMemory(&ConnectName.Buffer[1], NetRoot->PrefixEntry.Prefix.Buffer, NetRoot->PrefixEntry.Prefix.Length);

        ConnectName.Length = (sizeof(WCHAR)) + NetRoot->PrefixEntry.Prefix.Length;
        ConnectName.MaximumLength = ConnectName.Length;

        //
        //  Update the total number of bytes needed for this structure.
        //

        *TotalBytesNeeded += ConnectName.Length;

        if (*BufferStart > *BufferEnd) {
            try_return( ReturnValue = FALSE);
        }

        ConnectionInfo->ResumeKey = NetRoot->SerialNumberForEnum;

        if (Level > 0) {
            ULONG ConnectionStatus = 0;

            ConnectionInfo->SharedResourceType = NetRoot->DeviceType;

            RxDbgTrace(0, Dbg, ("PackC data---> netroot netrootcondifiton  %08lx %08lx\n",
                                      NetRoot,NetRoot->Condition));

            MRxSmbUpdateNetRootState((PMRX_NET_ROOT)NetRoot);

            ConnectionInfo->ConnectionStatus = NetRoot->MRxNetRootState;

            ConnectionInfo->NumberFilesOpen = NetRoot->NumberOfSrvOpens;
            RxDbgTrace(0, Dbg, ("PackC data---> length restype resumek connstatus numfiles  %08lx %08lx %08lx %08lx %08lx\n",
                            ConnectionInfo->UNCName.Length,
                            ConnectionInfo->SharedResourceType,
                            ConnectionInfo->ResumeKey,
                            ConnectionInfo->ConnectionStatus,
                            ConnectionInfo->NumberFilesOpen));
        }

        if (Level > 1) {

            ULONG DialectFlags = pServerEntry->Server.DialectFlags;

            if (!BooleanFlagOn(
                    pSessionEntry->Session.Flags,
                    SMBCE_SESSION_FLAGS_LANMAN_SESSION_KEY_USED)) {
                RtlCopyMemory(
                    ConnectionInfo->UserSessionKey,
                    pSessionEntry->Session.UserSessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH);
            } else {
                ASSERT(MSV1_0_USER_SESSION_KEY_LENGTH >= MSV1_0_LANMAN_SESSION_KEY_LENGTH);

                RtlZeroMemory(
                    ConnectionInfo->UserSessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH);

                RtlCopyMemory(
                    ConnectionInfo->UserSessionKey,
                    pSessionEntry->Session.LanmanSessionKey,
                    MSV1_0_LANMAN_SESSION_KEY_LENGTH);
            }

            RtlCopyMemory(
                ConnectionInfo->LanmanSessionKey,
                pSessionEntry->Session.LanmanSessionKey,
                MSV1_0_LANMAN_SESSION_KEY_LENGTH);

            ConnectionInfo->Capabilities = 0;

            if (DialectFlags & DF_UNICODE) {
                ConnectionInfo->Capabilities |= CAPABILITY_UNICODE;
            }

            if (DialectFlags & DF_RPC_REMOTE) {
                ConnectionInfo->Capabilities |= CAPABILITY_RPC;
            }

            if ((DialectFlags & DF_NT_SMBS) && (DialectFlags & DF_RPC_REMOTE)) {
                ConnectionInfo->Capabilities |= CAPABILITY_SAM_PROTOCOL;
            }

            if (DialectFlags & DF_MIXEDCASE) {
                ConnectionInfo->Capabilities |= CAPABILITY_CASE_SENSITIVE_PASSWDS;
            }

            if (DialectFlags & DF_LANMAN10) {
                ConnectionInfo->Capabilities |= CAPABILITY_REMOTE_ADMIN_PROTOCOL;
            }

            ASSERT (!RxContext->PostRequest);
            RxDbgTrace(0, Dbg, ("PackC data---> capabilities  %08lx \n",  ConnectionInfo->Capabilities));
        }

        if (!MRxSmbPackStringIntoConnectInfoThunked(
                &ConnectionInfo->UNCName,
                &ConnectName,
                BufferStart,
                BufferEnd,
                BufferDisplacement,
                NULL)) {
            if (Level > 1) {
                ConnectionInfo->UserName.Length = 0;
                ConnectionInfo->UserName.Buffer = NULL;
            }

            try_return( ReturnValue = FALSE);
        }

        if (Level > 1) {
            WCHAR UserNameBuffer[UNLEN + 1];
            WCHAR UserDomainNameBuffer[UNLEN + 1];

            UNICODE_STRING UserName,UserDomainName;

            UserName.Length = UserName.MaximumLength = UNLEN * sizeof(WCHAR);
            UserName.Buffer = UserNameBuffer;
            UserDomainName.Length = UserDomainName.MaximumLength = UNLEN * sizeof(WCHAR);
            UserDomainName.Buffer = UserDomainNameBuffer;

            Status = SmbCeGetUserNameAndDomainName(
                         pSessionEntry,
                         &UserName,
                         &UserDomainName);

            if (NT_SUCCESS(Status)) {
               if (!MRxSmbPackStringIntoConnectInfoThunked(
                       &ConnectionInfo->UserName,
                       &UserName,
                       BufferStart,
                       BufferEnd,
                       BufferDisplacement,
                       TotalBytesNeeded)) {
                   try_return( ReturnValue = FALSE);
               }

               if (!MRxSmbPackStringIntoConnectInfoThunked(
                        &ConnectionInfo->DomainName,
                        &UserDomainName,
                        BufferStart,
                        BufferEnd,
                        BufferDisplacement,
                        TotalBytesNeeded)) {
                   try_return( ReturnValue = FALSE);
               }
            } else {
               try_return( ReturnValue = FALSE);
            }
        }

        if (Level > 2) {
            WCHAR TransportNameBuffer[MAX_PATH + 1];
            UNICODE_STRING TransportName;

            MRxSmbGetConnectInfoLevel3FieldsThunked(ConnectionInfo,pServerEntry, FALSE);

            TransportName.Length = 0;
            TransportName.MaximumLength = UNLEN * sizeof(WCHAR);
            TransportName.Buffer = TransportNameBuffer;

            if ((pServerEntry->pTransport != NULL) &&
                !SmbCeIsServerInDisconnectedMode(pServerEntry)) {

                NTSTATUS RefTransportStatus;

                RefTransportStatus = SmbCeReferenceServerTransport(&pServerEntry->pTransport);

                if (RefTransportStatus == STATUS_SUCCESS) {
                    PUNICODE_STRING RxCeTransportName =
                                 &pServerEntry->pTransport->pTransport->RxCeTransport.Name;

                    TransportName.Length = RxCeTransportName->Length;

                    if (TransportName.Length <= TransportName.MaximumLength) {
                        RtlCopyMemory(
                            TransportName.Buffer,
                            RxCeTransportName->Buffer,
                            TransportName.Length);
                    } else {
                        Status = STATUS_BUFFER_OVERFLOW;
                    }

                    SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
                }
            }

            if (Status == STATUS_SUCCESS) {
                if (!MRxSmbPackStringIntoConnectInfoThunked(
                        &ConnectionInfo->TransportName,
                        &TransportName,
                        BufferStart, BufferEnd,
                        BufferDisplacement,
                        TotalBytesNeeded)) {
                    try_return( ReturnValue = FALSE);
                }
            }
        }

    try_exit:
        NOTHING;

    } finally {
        RxFreePool(ConnectName.Buffer);
    }
    RxDbgTrace(-1, Dbg, ("PackC...%08lx\n",ReturnValue));

    return ReturnValue;
}
#endif

VOID
MRxSmbGetConnectInfoLevel3Fields(
    IN OUT PLMR_CONNECTION_INFO_3 ConnectionInfo,
    IN     PSMBCEDB_SERVER_ENTRY  pServerEntry,
    BOOL   fAgentCall
    )
{
    ULONG DialectFlags = pServerEntry->Server.DialectFlags;

    NTSTATUS Status;
    RXCE_CONNECTION_INFO        QueryConnectionInfo;
    PSMBCE_SERVER_VC_TRANSPORT  pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;
    PSMBCE_VC                   pVc;

    PAGED_CODE();

    ConnectionInfo->Throughput = 0;
    ConnectionInfo->Delay = 0;
    ConnectionInfo->Reliable = FALSE;
    ConnectionInfo->ReadAhead = TRUE;
    ConnectionInfo->IsSpecialIpcConnection = FALSE;

    if ((pServerEntry->Header.State == SMBCEDB_ACTIVE) &&
        (pVcTransport != NULL) &&
        (!SmbCeIsServerInDisconnectedMode(pServerEntry)||fAgentCall)) {
        pVc = &pVcTransport->Vcs[0];

        Status = RxCeQueryInformation(
                 &pVc->RxCeVc,
                 RxCeConnectionEndpointInformation,
                 &QueryConnectionInfo,
                 sizeof(QueryConnectionInfo));

        if (NT_SUCCESS(Status)) {
            ConnectionInfo->Reliable = !QueryConnectionInfo.Unreliable;

            if (QueryConnectionInfo.Delay.QuadPart != 0) {
                if (QueryConnectionInfo.Delay.QuadPart == -1) {
                    ConnectionInfo->Delay = 0;
                } else if (QueryConnectionInfo.Delay.HighPart != 0xffffffff) {
                    ConnectionInfo->Delay = 0xffffffff;
                } else {
                    ConnectionInfo->Delay = -1 * QueryConnectionInfo.Delay.LowPart;
                }
            } else {
                ConnectionInfo->Delay = 0;
            }

            if (QueryConnectionInfo.Throughput.QuadPart == -1) {
                ConnectionInfo->Throughput = 0;
            } else if (QueryConnectionInfo.Throughput.HighPart != 0) {
                ConnectionInfo->Throughput = 0xffffffff;
            } else {
                ConnectionInfo->Throughput = QueryConnectionInfo.Throughput.LowPart;
            }
        }
    }

    ConnectionInfo->TimeZoneBias = pServerEntry->Server.TimeZoneBias;
    ConnectionInfo->Core = (DialectFlags & DF_CORE) != 0;
    ConnectionInfo->MsNet103 = (DialectFlags & DF_OLDRAWIO) != 0;
    ConnectionInfo->Lanman10 = (DialectFlags & DF_LANMAN10) != 0;
    ConnectionInfo->WindowsForWorkgroups = (DialectFlags & DF_WFW) != 0;
    ConnectionInfo->Lanman20 = (DialectFlags & DF_LANMAN20) != 0;
    ConnectionInfo->Lanman21 = (DialectFlags & DF_LANMAN21) != 0;
    ConnectionInfo->WindowsNt = (DialectFlags & DF_NTPROTOCOL) != 0;
    ConnectionInfo->MixedCasePasswords = (DialectFlags & DF_MIXEDCASEPW) != 0;
    ConnectionInfo->MixedCaseFiles = (DialectFlags & DF_MIXEDCASE) != 0;
    ConnectionInfo->LongNames = (DialectFlags & DF_LONGNAME) != 0;
    ConnectionInfo->ExtendedNegotiateResponse = (DialectFlags & DF_EXTENDNEGOT) != 0;
    ConnectionInfo->LockAndRead = (DialectFlags & DF_LOCKREAD) != 0;
    ConnectionInfo->NtSecurity = (DialectFlags & DF_SECURITY) != 0;
    ConnectionInfo->SupportsEa = (DialectFlags & DF_SUPPORTEA) != 0;
    ConnectionInfo->NtNegotiateResponse = (DialectFlags & DF_NTNEGOTIATE) != 0;
    ConnectionInfo->CancelSupport = (DialectFlags & DF_CANCEL) != 0;
    ConnectionInfo->UnicodeStrings = (DialectFlags & DF_UNICODE) != 0;
    ConnectionInfo->LargeFiles = (DialectFlags & DF_LARGE_FILES) != 0;
    ConnectionInfo->NtSmbs = (DialectFlags & DF_NT_SMBS) != 0;
    ConnectionInfo->RpcRemoteAdmin = (DialectFlags & DF_RPC_REMOTE) != 0;
    ConnectionInfo->NtStatusCodes = (DialectFlags & DF_NT_STATUS) != 0;
    ConnectionInfo->LevelIIOplock = (DialectFlags & DF_OPLOCK_LVL2) != 0;
    ConnectionInfo->UtcTime = (DialectFlags & DF_TIME_IS_UTC) != 0;
    ConnectionInfo->UserSecurity = (pServerEntry->Server.SecurityMode==SECURITY_MODE_USER_LEVEL);
    ConnectionInfo->EncryptsPasswords = pServerEntry->Server.EncryptPasswords;

    return;
}

#ifdef _WIN64
VOID
MRxSmbGetConnectInfoLevel3FieldsThunked(
    IN OUT PLMR_CONNECTION_INFO_3_32 ConnectionInfo,
    IN     PSMBCEDB_SERVER_ENTRY     pServerEntry,
    BOOL   fAgentCall
    )
{
    ULONG DialectFlags = pServerEntry->Server.DialectFlags;

    NTSTATUS Status;
    RXCE_CONNECTION_INFO        QueryConnectionInfo;
    PSMBCE_SERVER_VC_TRANSPORT  pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;
    PSMBCE_VC                   pVc;

    PAGED_CODE();

    ConnectionInfo->Throughput = 0;
    ConnectionInfo->Delay = 0;
    ConnectionInfo->Reliable = FALSE;
    ConnectionInfo->ReadAhead = TRUE;
    ConnectionInfo->IsSpecialIpcConnection = FALSE;

    if ((pServerEntry->Header.State == SMBCEDB_ACTIVE) &&
        (pVcTransport != NULL) &&
        (!SmbCeIsServerInDisconnectedMode(pServerEntry)||fAgentCall)) {
        pVc = &pVcTransport->Vcs[0];

        Status = RxCeQueryInformation(
                 &pVc->RxCeVc,
                 RxCeConnectionEndpointInformation,
                 &QueryConnectionInfo,
                 sizeof(QueryConnectionInfo));

        if (NT_SUCCESS(Status)) {
            ConnectionInfo->Reliable = !QueryConnectionInfo.Unreliable;

            if (QueryConnectionInfo.Delay.QuadPart != 0) {
                if (QueryConnectionInfo.Delay.QuadPart == -1) {
                    ConnectionInfo->Delay = 0;
                } else if (QueryConnectionInfo.Delay.HighPart != 0xffffffff) {
                    ConnectionInfo->Delay = 0xffffffff;
                } else {
                    ConnectionInfo->Delay = -1 * QueryConnectionInfo.Delay.LowPart;
                }
            } else {
                ConnectionInfo->Delay = 0;
            }

            if (QueryConnectionInfo.Throughput.QuadPart == -1) {
                ConnectionInfo->Throughput = 0;
            } else if (QueryConnectionInfo.Throughput.HighPart != 0) {
                ConnectionInfo->Throughput = 0xffffffff;
            } else {
                ConnectionInfo->Throughput = QueryConnectionInfo.Throughput.LowPart;
            }
        }
    }

    ConnectionInfo->TimeZoneBias = pServerEntry->Server.TimeZoneBias;
    ConnectionInfo->Core = (DialectFlags & DF_CORE) != 0;
    ConnectionInfo->MsNet103 = (DialectFlags & DF_OLDRAWIO) != 0;
    ConnectionInfo->Lanman10 = (DialectFlags & DF_LANMAN10) != 0;
    ConnectionInfo->WindowsForWorkgroups = (DialectFlags & DF_WFW) != 0;
    ConnectionInfo->Lanman20 = (DialectFlags & DF_LANMAN20) != 0;
    ConnectionInfo->Lanman21 = (DialectFlags & DF_LANMAN21) != 0;
    ConnectionInfo->WindowsNt = (DialectFlags & DF_NTPROTOCOL) != 0;
    ConnectionInfo->MixedCasePasswords = (DialectFlags & DF_MIXEDCASEPW) != 0;
    ConnectionInfo->MixedCaseFiles = (DialectFlags & DF_MIXEDCASE) != 0;
    ConnectionInfo->LongNames = (DialectFlags & DF_LONGNAME) != 0;
    ConnectionInfo->ExtendedNegotiateResponse = (DialectFlags & DF_EXTENDNEGOT) != 0;
    ConnectionInfo->LockAndRead = (DialectFlags & DF_LOCKREAD) != 0;
    ConnectionInfo->NtSecurity = (DialectFlags & DF_SECURITY) != 0;
    ConnectionInfo->SupportsEa = (DialectFlags & DF_SUPPORTEA) != 0;
    ConnectionInfo->NtNegotiateResponse = (DialectFlags & DF_NTNEGOTIATE) != 0;
    ConnectionInfo->CancelSupport = (DialectFlags & DF_CANCEL) != 0;
    ConnectionInfo->UnicodeStrings = (DialectFlags & DF_UNICODE) != 0;
    ConnectionInfo->LargeFiles = (DialectFlags & DF_LARGE_FILES) != 0;
    ConnectionInfo->NtSmbs = (DialectFlags & DF_NT_SMBS) != 0;
    ConnectionInfo->RpcRemoteAdmin = (DialectFlags & DF_RPC_REMOTE) != 0;
    ConnectionInfo->NtStatusCodes = (DialectFlags & DF_NT_STATUS) != 0;
    ConnectionInfo->LevelIIOplock = (DialectFlags & DF_OPLOCK_LVL2) != 0;
    ConnectionInfo->UtcTime = (DialectFlags & DF_TIME_IS_UTC) != 0;
    ConnectionInfo->UserSecurity = (pServerEntry->Server.SecurityMode==SECURITY_MODE_USER_LEVEL);
    ConnectionInfo->EncryptsPasswords = pServerEntry->Server.EncryptPasswords;

    return;
}
#endif

NTSTATUS
MRxSmbEnumerateConnections (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine enumerates the connections on all minirdrs. we may have to do
    it by minirdr.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

NTSTATUS

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET InputBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PUCHAR OriginalOutputBuffer = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    PUCHAR OutputBuffer;
    ULONG  BufferDisplacement;

    ULONG  Level, ResumeHandle;

    PCHAR BufferStart;
    PCHAR BufferEnd;
    PCHAR PreviousBufferStart;

    PLIST_ENTRY ListEntry;
    LUID LogonId;
    BOOLEAN TableLockHeld = FALSE;
    ULONG TotalBytesNeeded = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbEnumerateConnections [Start] -> %08lx\n", 0));

    OutputBuffer = RxNewMapUserBuffer(RxContext);
    BufferDisplacement = (ULONG)(OutputBuffer - OriginalOutputBuffer);
    BufferStart = OutputBuffer;
    BufferEnd = OutputBuffer+OutputBufferLength;

    if (InFSD && RxContext->CurrentIrp->RequestorMode != KernelMode) {
        ASSERT(BufferDisplacement==0);

        try {
            ProbeForWrite(InputBuffer,InputBufferLength,sizeof(UCHAR));
            ProbeForWrite(OutputBuffer,OutputBufferLength,sizeof(UCHAR));
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    try {
        try {
            if (InputBufferLength < sizeof(LMR_REQUEST_PACKET)) {
                try_return(Status = STATUS_BUFFER_TOO_SMALL);
            }

            if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
                try_return(Status = STATUS_INVALID_PARAMETER);
            }

            Level = InputBuffer->Level;
            ResumeHandle = InputBuffer->Parameters.Get.ResumeHandle;
            LogonId = InputBuffer->LogonId;
            RxDbgTrace(0, Dbg, ("MRxSmbEnumerateConnections Level -> %08lx\n", Level));

#ifdef _WIN64
            if (IoIs32bitProcess(RxContext->CurrentIrp)) {
                switch (Level) {
                case 0:
                    if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 1:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 2:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 3:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                default:
                    try_return(Status = STATUS_INVALID_INFO_CLASS);
                }
            } else {
                switch (Level) {
                case 0:
                    if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 1:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 2:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 3:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                default:
                    try_return(Status = STATUS_INVALID_INFO_CLASS);
                }
            }
#else
            switch (Level) {
            case 0:
                if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 1:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 2:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 3:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            default:
                try_return(Status = STATUS_INVALID_INFO_CLASS);
            }
#endif            
            InputBuffer->Parameters.Get.EntriesRead = 0;
            InputBuffer->Parameters.Get.TotalEntries = 0;

            RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);
            TableLockHeld = TRUE;

            if (IsListEmpty( &RxNetNameTable.MemberQueue )) {
                try_return(Status = RX_MAP_STATUS(SUCCESS));
            }

            //must do the list forwards!!!!!
            ListEntry = RxNetNameTable.MemberQueue.Flink;
            for (;ListEntry != &RxNetNameTable.MemberQueue;) {
                PVOID Container;
                PRX_PREFIX_ENTRY PrefixEntry;
                PNET_ROOT NetRoot;
                PV_NET_ROOT VNetRoot;
                PUNICODE_STRING VNetRootName;

                PrefixEntry = CONTAINING_RECORD( ListEntry, RX_PREFIX_ENTRY, MemberQLinks );
                ListEntry = ListEntry->Flink;
                ASSERT (NodeType(PrefixEntry) == RDBSS_NTC_PREFIX_ENTRY);
                Container = PrefixEntry->ContainingRecord;
                RxDbgTrace(0, Dbg, ("---> ListE PfxE Container Name  %08lx %08lx %08lx %wZ\n",
                                ListEntry, PrefixEntry, Container, &PrefixEntry->Prefix));

                switch (NodeType(Container)) {
                case RDBSS_NTC_NETROOT :
                    continue;

                case RDBSS_NTC_SRVCALL :
                    continue;

                case RDBSS_NTC_V_NETROOT :
                    VNetRoot = (PV_NET_ROOT)Container;
                    NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
                    VNetRootName = &VNetRoot->PrefixEntry.Prefix;

                    if ((VNetRoot->SerialNumberForEnum >= ResumeHandle) &&
                        (VNetRootName->Buffer[1] != L';') &&
                        (VNetRoot->Condition == Condition_Good) &&
                        MRxSmbShowConnection(LogonId,VNetRoot) &&
                        VNetRoot->IsExplicitConnection) {
                        break;
                    } else {
                        continue;
                    }

                default:
                    continue;
                }

                RxDbgTrace(0, Dbg, ("      ImplicitConnectionFound!!!\n"));

                InputBuffer->Parameters.Get.TotalEntries ++ ;

                PreviousBufferStart = BufferStart;
#ifdef _WIN64
                if (IoIs32bitProcess(RxContext->CurrentIrp)) {
                    if (MRxSmbPackConnectEntryThunked(RxContext,Level,
                                  &BufferStart,
                                  &BufferEnd,
                                  VNetRoot,
                                  BufferDisplacement,
                                  &TotalBytesNeeded)) {
                        InputBuffer->Parameters.Get.EntriesRead ++ ;
                        RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                       &((PLMR_CONNECTION_INFO_0)PreviousBufferStart)->UNCName
                                            ));
                    } else {
                        break;
                    }
                } else {
                    if (MRxSmbPackConnectEntry(RxContext,Level,
                                  &BufferStart,
                                  &BufferEnd,
                                  VNetRoot,
                                  BufferDisplacement,
                                  &TotalBytesNeeded)) {
                        InputBuffer->Parameters.Get.EntriesRead ++ ;
                        RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                       &((PLMR_CONNECTION_INFO_0)PreviousBufferStart)->UNCName
                                            ));
                    } else {
                        break;
                    }
                }
#else
                if (MRxSmbPackConnectEntry(RxContext,Level,
                              &BufferStart,
                              &BufferEnd,
                              VNetRoot,
                              BufferDisplacement,
                              &TotalBytesNeeded)) {
                    InputBuffer->Parameters.Get.EntriesRead ++ ;
                    RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                   &((PLMR_CONNECTION_INFO_0)PreviousBufferStart)->UNCName
                                        ));
                } else {
                    break;
                }
#endif
            }

            InputBuffer->Parameters.Get.TotalBytesNeeded = TotalBytesNeeded;
            RxContext->InformationToReturn = sizeof(LMR_REQUEST_PACKET);

            try_return(Status = RX_MAP_STATUS(SUCCESS));

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }

try_exit:NOTHING;

    } finally {

        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }

        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}

NTSTATUS
MRxSmbGetConnectionInfo (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine gets the connection info for a single vnetroot.

    There is some happiness here about the output buffer. What happens is that we
    pick up the output buffer in the usual way. However, there are all sorts of
    pointers in the return structure and these pointers must obviously be in terms
    of the original process. so, if we post then we have to apply a fixup!

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

   STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET InputBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PUCHAR OriginalOutputBuffer = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    PUCHAR OutputBuffer;
    ULONG  BufferDisplacement;

    ULONG Level;

    PCHAR BufferStart;
    PCHAR OriginalBufferStart;
    PCHAR BufferEnd;

    BOOLEAN TableLockHeld = FALSE;

    PNET_ROOT   NetRoot;
    PV_NET_ROOT VNetRoot;

    ULONG TotalBytesNeeded = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbGetConnectionInfo [Start] -> %08lx\n", 0));

    OutputBuffer = RxNewMapUserBuffer(RxContext);
    BufferDisplacement = (ULONG)(OutputBuffer - OriginalOutputBuffer);
    BufferStart = OutputBuffer;
    OriginalBufferStart = BufferStart;
    BufferEnd = OutputBuffer+OutputBufferLength;

    if (InFSD && RxContext->CurrentIrp->RequestorMode != KernelMode) {
        ASSERT(BufferDisplacement==0);

        try {
            ProbeForWrite(InputBuffer,InputBufferLength,sizeof(UCHAR));
            ProbeForWrite(OutputBuffer,OutputBufferLength,sizeof(UCHAR));
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    try {
        try {
            ASSERT (NodeType(capFobx)==RDBSS_NTC_V_NETROOT);
            VNetRoot = (PV_NET_ROOT)capFobx;
            NetRoot = (PNET_ROOT)(VNetRoot->NetRoot);

            if (NetRoot == NULL) {
                try_return(Status = STATUS_ALREADY_DISCONNECTED);
            }

            if (InputBufferLength < sizeof(LMR_REQUEST_PACKET)) {
                try_return(Status = STATUS_BUFFER_TOO_SMALL);
            }

            if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
                try_return(Status = STATUS_INVALID_PARAMETER);
            }

            Level = InputBuffer->Level;
            RxDbgTrace(0, Dbg, ("MRxSmbGetConnectionInfo Level -> %08lx\n", Level));

#ifdef _WIN64
            if (IoIs32bitProcess(RxContext->CurrentIrp)) {
                switch (Level) {
                case 0:
                    if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 1:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 2:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 3:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                default:
                    try_return(Status = STATUS_INVALID_INFO_CLASS);
                }
            } else {
                switch (Level) {
                case 0:
                    if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 1:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 2:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 3:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                default:
                    try_return(Status = STATUS_INVALID_INFO_CLASS);
                }
            }
#else
            switch (Level) {
            case 0:
                if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 1:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 2:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 3:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            default:
                try_return(Status = STATUS_INVALID_INFO_CLASS);
            }
#endif            

            InputBuffer->Parameters.Get.TotalEntries = 1;

            RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);
            TableLockHeld = TRUE;

#ifdef _WIN64
            if (IoIs32bitProcess(RxContext->CurrentIrp)) {
                if (MRxSmbPackConnectEntryThunked(RxContext,Level,
                                  &BufferStart,
                                  &BufferEnd,
                                  VNetRoot,
                                  BufferDisplacement,
                                  &TotalBytesNeeded)) {

                    InputBuffer->Parameters.Get.EntriesRead = 1;
                    RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                   &((PLMR_CONNECTION_INFO_0)OriginalBufferStart)->UNCName
                                        ));
                }
            } else {
                if (MRxSmbPackConnectEntry(RxContext,Level,
                                  &BufferStart,
                                  &BufferEnd,
                                  VNetRoot,
                                  BufferDisplacement,
                                  &TotalBytesNeeded)) {

                    InputBuffer->Parameters.Get.EntriesRead = 1;
                    RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                   &((PLMR_CONNECTION_INFO_0)OriginalBufferStart)->UNCName
                                        ));
                }
            }
#else
            if (MRxSmbPackConnectEntry(RxContext,Level,
                              &BufferStart,
                              &BufferEnd,
                              VNetRoot,
                              BufferDisplacement,
                              &TotalBytesNeeded)) {

                InputBuffer->Parameters.Get.EntriesRead = 1;
                RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                               &((PLMR_CONNECTION_INFO_0)OriginalBufferStart)->UNCName
                                    ));
            }
#endif

            InputBuffer->Parameters.Get.TotalBytesNeeded = TotalBytesNeeded;
            RxContext->InformationToReturn = InputBuffer->Parameters.Get.TotalBytesNeeded;
            try_return(Status = RX_MAP_STATUS(SUCCESS));

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }

try_exit:NOTHING;

    } finally {
        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}

NTSTATUS
MRxSmbDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine deletes a single vnetroot. joejoe

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET InputBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    ULONG Level;

    //PLIST_ENTRY ListEntry;
    BOOLEAN TableLockHeld = FALSE;

    PMRX_NET_ROOT NetRoot = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;
    PSMBCE_V_NET_ROOT_CONTEXT VNetRootContext = NULL;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbDeleteConnection Fobx %08lx\n", capFobx));
    ASSERT( (FSCTL_LMR_DELETE_CONNECTION&3)==METHOD_BUFFERED );
    //no probing for buffered!

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(RX_MAP_STATUS(PENDING));
    }

    try {

        if (NodeType(capFobx)==RDBSS_NTC_V_NETROOT) {
            VNetRoot = (PMRX_V_NET_ROOT)capFobx;
            VNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)VNetRoot->Context;
            NetRoot = (PMRX_NET_ROOT)VNetRoot->pNetRoot;
        } else {
            ASSERT(FALSE);
            try_return(Status = STATUS_INVALID_DEVICE_REQUEST);
            NetRoot = (PMRX_NET_ROOT)capFobx;
            VNetRoot = NULL;
        }

        if (InputBufferLength < sizeof(LMR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        Level = InputBuffer->Level;
        RxDbgTrace(0, Dbg, ("MRxSmbDeleteConnection Level(ofForce) -> %08lx\n", Level));

        if (Level <= USE_LOTS_OF_FORCE) {
            if (Level == USE_LOTS_OF_FORCE) {
                //SmbCeFinalizeAllExchangesForNetRoot(VNetRoot->pNetRoot);
            }
            
            if (VNetRootContext != NULL && Level == USE_LOTS_OF_FORCE) {
                // Prevent any new connection from reusing the session if this is the last connection on
                // this session right now
                SmbCeDecrementNumberOfActiveVNetRootOnSession(VNetRootContext);

                // Recover the count which will be taken away when VNetRoot is finalized
                InterlockedIncrement(&VNetRootContext->pSessionEntry->Session.NumberOfActiveVNetRoot);
            }

            // The boolean ForceFilesClosed is now a tristate. If the state is 0xff then
            // we take off the extra reference on vnetroot made during xxx_CONNECT
            Status = RxFinalizeConnection(
                         (PNET_ROOT)NetRoot,
                         (PV_NET_ROOT)VNetRoot,
                         (Level==USE_LOTS_OF_FORCE)?TRUE:
                            ((Level==USE_NOFORCE)?FALSE:0xff));
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }

        try_return(Status);

try_exit:NOTHING;

    } finally {

        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }

        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}


NTSTATUS
MRxEnumerateTransports(
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN   pPostToFsp)
/*++

Routine Description:

    This routine invokes the underlying connection engine method to bind to a transport
    or unbind from it in the context of FSP.

Arguments:

    RxContext - the  context

    pPostToFsp - set to TRUE if the routine cannot be completed in the context of the FSD.

Return Value:

     returns RxStatus(PENDING) if invoked in FSD.
     returns the status value from the connection engine if invoked in FSP.

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET pLmrRequestBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PUCHAR pTransportEnumerationBuffer = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    ULONG  EnumerationBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG  LmrRequestBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("RxEnumerateTransports [Start] ->\n"));

   //
   // This routine is invoked as part of ioinit on a remote boot client.
   // In that case, previous mode is kernel and the buffers are in kernel
   // space, so we can't probe the buffers.
   //

   if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
       try {
           ProbeForWrite(pLmrRequestBuffer,LmrRequestBufferLength,sizeof(UCHAR));
           ProbeForWrite(pTransportEnumerationBuffer,EnumerationBufferLength,sizeof(UCHAR));
       } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_ACCESS_VIOLATION;
       }
   }

   try {
       try {
           if (LmrRequestBufferLength < sizeof(LMR_REQUEST_PACKET)) {
               try_return(Status = STATUS_BUFFER_TOO_SMALL);
           }

           if (pLmrRequestBuffer->Version != REQUEST_PACKET_VERSION) {
               try_return(Status = STATUS_INVALID_PARAMETER);
           }

           Status = MRxEnumerateTransportBindings(
                        pLmrRequestBuffer,
                        LmrRequestBufferLength,
                        pTransportEnumerationBuffer,
                        EnumerationBufferLength);

           RxContext->InformationToReturn = sizeof(LMR_REQUEST_PACKET);
       } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_ACCESS_VIOLATION;
       }

try_exit:NOTHING;

   } finally {
       RxDbgTraceUnIndent(-1,Dbg);
   }

   return Status;
}

#define ADAPTER_STATUS_LENGTH_IN_BYTES (26)
UNICODE_STRING NullAdapterStatus = {
        ADAPTER_STATUS_LENGTH_IN_BYTES,
        ADAPTER_STATUS_LENGTH_IN_BYTES,
        L"000000000000\0"};

#define HexDigit(a) ((CHAR)( (a) > 9 ? ((a) + 'A' - 0xA) : ((a) + '0') ))

NTSTATUS
MRxEnumerateTransportBindings(
    IN PLMR_REQUEST_PACKET pLmrRequestPacket,
    IN ULONG               LmrRequestPacketLength,
    OUT PVOID              pBindingBuffer,
    IN OUT ULONG           BindingBufferLength)
/*++

Routine Description:

    This routine enables the specified transport.

Arguments:

    pLmrRequestPacket - the LM Request Packet for enumerating bindings to transports.

    LmrRequestPacketLength - length of the LM request.

    pBindingBuffer - the buffer for returning transport bindings

    BindingBufferLength -- length of the buffer in which bindings are returned.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

    The workstation service and other clients of LMR_FSCTL's expect the variable length
    data to be packed in a specific way, i.e., the variable length data is copied from
    the end while the fixed length data is copied from the left. Any changes to the format
    in which the data is packed should be accompanied by the corresponding changes for
    unpacking in these services.

--*/
{
    NTSTATUS         ReturnStatus = STATUS_SUCCESS;
    NTSTATUS         Status;
    PSMBCE_TRANSPORT pTransport;
    ULONG            TransportsPreviouslyReturned;
    PVOID            pVariableLengthInfo;
    ULONG            VariableLengthInfoOffset;
    PSMBCE_TRANSPORT_ARRAY pTransportArray;

    PAGED_CODE();

    try {
        // Ensure that the buffer can hold atleast one entry
        if (BindingBufferLength < sizeof(WKSTA_TRANSPORT_INFO_0)) {
            try_return(ReturnStatus = STATUS_BUFFER_TOO_SMALL);
        }

        VariableLengthInfoOffset = BindingBufferLength;
        TransportsPreviouslyReturned = pLmrRequestPacket->Parameters.Get.ResumeHandle;
        pLmrRequestPacket->Parameters.Get.EntriesRead = 0;

        // Skip the transports that were previously returned
        pTransportArray = SmbCeReferenceTransportArray();

        if (pTransportArray == NULL || pTransportArray->Count == 0) {
            if (pTransportArray != NULL) {
                SmbCeDereferenceTransportArray(pTransportArray);
            }

            RxDbgTrace(0, Dbg, ("MRxEnumerateTransportBindings : Transport not available.\n"));
            try_return(ReturnStatus = STATUS_NETWORK_UNREACHABLE);
        }

        if (TransportsPreviouslyReturned < pTransportArray->Count) {
            // The subsequent entries have not been returned. Obtain the information
            // for them.
            WKSTA_TRANSPORT_INFO_0 UNALIGNED *pTransportInfo = (WKSTA_TRANSPORT_INFO_0 UNALIGNED *)pBindingBuffer;

            LONG   RemainingLength = (LONG)BindingBufferLength;
            PCHAR  pBufferEnd      = (PCHAR)pBindingBuffer + BindingBufferLength;
            PCHAR  pBufferStart    = (PCHAR)pBindingBuffer;
            ULONG  Length;
            ULONG  TransportsPacked = 0;
            ULONG  CurrentTransport;
            ULONG  LengthRequired  = 0;

            CurrentTransport = TransportsPreviouslyReturned;

            while(CurrentTransport < pTransportArray->Count) {
                RXCE_TRANSPORT_INFORMATION TransportInformation;

                pTransport = pTransportArray->SmbCeTransports[CurrentTransport++];

                Status = RxCeQueryTransportInformation(
                             &pTransport->RxCeTransport,
                             &TransportInformation);

                if (Status == STATUS_SUCCESS) {
                    ULONG BufferSize;

                    if (pTransport->RxCeTransport.Name.Length > UNLEN * sizeof(WCHAR)) {
                        Status = STATUS_BUFFER_OVERFLOW;
                    }

                    BufferSize = sizeof(WKSTA_TRANSPORT_INFO_0) +
                                 ADAPTER_STATUS_LENGTH_IN_BYTES +
                                 (pTransport->RxCeTransport.Name.Length + sizeof(WCHAR));

                    RemainingLength -= BufferSize;
                    LengthRequired  += BufferSize;

                    if (Status == STATUS_SUCCESS && RemainingLength >= 0) {
                        PCHAR           pName;
                        PWCHAR          pAdapter;
                        ADAPTER_STATUS  AdapterStatus;

                        // Copy the values for the current binding into the output buffer.
                        pTransportInfo->wkti0_quality_of_service =
                            TransportInformation.QualityOfService;
    
                        pTransportInfo->wkti0_wan_ish =
                            TransportInformation.ServiceFlags & TDI_SERVICE_ROUTE_DIRECTED;
    
                        pTransportInfo->wkti0_number_of_vcs = TransportInformation.ConnectionCount;

                        VariableLengthInfoOffset -= (pTransport->RxCeTransport.Name.Length + sizeof(WCHAR));

                        pName = ((PCHAR)pBindingBuffer + VariableLengthInfoOffset);

                        pTransportInfo->wkti0_transport_name = (LPWSTR)pName;

                        // Copy the variable length data, i.e. the transport name and in the case of
                        // NETBIOS provides the adapter address
                        RtlCopyMemory(
                            pName,
                            pTransport->RxCeTransport.Name.Buffer,
                            pTransport->RxCeTransport.Name.Length);

                        pName += pTransport->RxCeTransport.Name.Length;
                        *((PWCHAR)pName) = L'\0';
                        
                        VariableLengthInfoOffset -= ADAPTER_STATUS_LENGTH_IN_BYTES;

                        pAdapter = (PWCHAR)((PCHAR)pBindingBuffer + VariableLengthInfoOffset);
                        pTransportInfo->wkti0_transport_address = pAdapter;

                        Status = RxCeQueryAdapterStatus(
                                     &pTransport->RxCeTransport,
                                     &AdapterStatus);

                        if (NT_SUCCESS(Status) ||
                            (Status == STATUS_BUFFER_OVERFLOW)) {
                            ULONG i;

                            for (i = 0; i < 6; i++) {
                                *pAdapter++ = HexDigit((AdapterStatus.adapter_address[i] >> 4) & 0x0F);
                                *pAdapter++ = HexDigit(AdapterStatus.adapter_address[i] & 0x0F);
                            }

                            *pAdapter = L'\0';
                        } else {
                            RtlCopyMemory(
                                pAdapter,
                                NullAdapterStatus.Buffer,
                                ADAPTER_STATUS_LENGTH_IN_BYTES);
                        }

                        // Increment the number of transports that have been returned.
                        pLmrRequestPacket->Parameters.Get.ResumeHandle++;
                        pLmrRequestPacket->Parameters.Get.EntriesRead++;
                        pTransportInfo++;
                    } else {
                        pTransportInfo->wkti0_transport_name = NULL;
                        pTransportInfo->wkti0_transport_address = NULL;
                    }
                }
            }

            if (RemainingLength < 0) {
                ReturnStatus = STATUS_MORE_ENTRIES;
                pLmrRequestPacket->Parameters.Get.TotalBytesNeeded = LengthRequired;
            }
        } else {
            ReturnStatus = STATUS_NO_MORE_FILES;
        }

       SmbCeDereferenceTransportArray(pTransportArray);

try_exit:NOTHING;

   } finally {
       RxDbgTraceUnIndent(-1,Dbg);
   }

   return ReturnStatus;
}

BOOLEAN
MRxSmbShowConnection(
    IN LUID LogonId,
    IN PV_NET_ROOT VNetRoot
    )
/*++

Routine Description:

    Returns whether the given V_NET_ROOT should be returned
    from an LMR_ENUMERATE_CONNECTIONS call.

Arguments:

    IN LUID LogonId - LogonId of caller asking for enumeration of connections

    IN PVNET_ROOT VNetRoot - Supplies the NetRoot to enumerate.

Return Value:

    BOOLEAN - True if the entry should be returned to the caller


--*/
{
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = SmbCeGetAssociatedVNetRootContext((PMRX_V_NET_ROOT)VNetRoot);

    // If no Context, not session specific
    if( pVNetRootContext == NULL ) {
        return TRUE;
    }

    if( RtlEqualLuid( &LogonId, &pVNetRootContext->pSessionEntry->Session.LogonId ) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\vcsndrcv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    vcsndrcv.c

Abstract:

    This module implements all functions related to transmitting and recieving SMB's on a
    connection based transport.

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

Notes:


--*/

#include "precomp.h"
#pragma hdrstop

#include "vcsndrcv.h"
#include "nbtioctl.h"

//
// Forward declarations
//

NTSTATUS
VctTranceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

NTSTATUS
VctReceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
VctSend(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

NTSTATUS
VctSendDatagram(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

struct _SMBCE_VC *
VctSelectVc(
    struct SMBCE_SERVER_VC_TRANSPORT *pVcTransport,
    BOOLEAN                    fMultiplexed);

NTSTATUS
VctInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
VctUninitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
VctIndReceive(
    IN PVOID              pEventContext,
    IN PRXCE_VC           pVc,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *pBytesTaken,
    IN PVOID              pTsdu,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG            pDataBufferSize
    );

NTSTATUS
VctIndDataReady(
    IN PVOID        pEventContext,
    IN PMDL         pBuffer,
    IN ULONG        DataSize,
    IN NTSTATUS     CopyDataStatus
    );

NTSTATUS
VctIndEndpointError(
    IN PVOID          pEventContext,
    IN NTSTATUS       IndicatedStatus
    );

NTSTATUS
VctIndSendPossible(
    IN PVOID          pEventContext,
    IN PRXCE_VC       pRxCeVc,
    IN ULONG          BytesAvailable
    );

NTSTATUS
VctIndReceiveDatagram(
    IN PVOID   pRxCeEventContext,
    IN int     SourceAddressLength,
    IN PVOID   SourceAddress,
    IN int     OptionsLength,
    IN PVOID   Options,
    IN ULONG   ReceiveDatagramFlags,
    IN ULONG   BytesIndicated,
    IN ULONG   BytesAvailable,
    OUT ULONG  *BytesTaken,
    IN PVOID   Tsdu,
    OUT PMDL   *pDataBufferPointer,
    OUT PULONG pDataBufferSize
    );

NTSTATUS
VctIndSendComplete(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pRxCeVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       SendCompletionStatus
   );

NTSTATUS
VctCompleteInitialization(
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    PSMBCE_TRANSPORT           pTransport,
    struct SMBCE_SERVER_VC_TRANSPORT *pVcTransport);

NTSTATUS
VctUninitialize(
    PVOID pTransport);

NTSTATUS
VctpTranslateNetbiosNameToIpAddress(
    IN  OEM_STRING *pName,
    OUT ULONG      *pIpAddress
    );

ULONG
VctComputeTransportAddressSize(
   IN PUNICODE_STRING pServerName);

NTSTATUS
VctBuildTransportAddress (
    IN  PTRANSPORT_ADDRESS pTransportAddress,
    IN  ULONG              TransportAddressLength,
    IN  PUNICODE_STRING    pServerName,
    OUT PULONG             pServerIpAddress
    );

NTSTATUS
VctpCreateConnection(
    IN PSMBCEDB_SERVER_ENTRY    pServerEntry,
    IN PTRANSPORT_ADDRESS       pTransportAddress,
    IN ULONG                    TransportAddressLength,
    IN PUNICODE_STRING          pServerName,
    OUT PSMBCE_TRANSPORT        *pTransportPtr,
    IN OUT PRXCE_CONNECTION     pRxCeConnection,
    IN OUT PRXCE_VC             pRxCeVc);

VOID
VctpInitializeServerTransport(
    struct _RXCE_VC_CONNECT_CONTEXT *pRxCeConnectContext);

NTSTATUS
VctpInvokeTransportFunction(
    struct _RXCE_VC_CONNECT_CONTEXT *pRxCeConnectContext);

VOID
VctpUninitializeServerTransport(
    struct _RXCE_VC_CONNECT_CONTEXT *pRxCeConnectContext);

NTSTATUS
VctTearDownServerTransport(
   PSMBCE_SERVER_TRANSPORT pServerTransport);

NTSTATUS
VctInitiateDisconnect(
    PSMBCE_SERVER_TRANSPORT pServerTransport);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, VctTranceive)
#pragma alloc_text(PAGE, VctReceive)
#pragma alloc_text(PAGE, VctSend)
#pragma alloc_text(PAGE, VctSendDatagram)
#pragma alloc_text(PAGE, VctSelectVc)
#pragma alloc_text(PAGE, VctInitializeExchange)
#pragma alloc_text(PAGE, VctUninitializeExchange)
#pragma alloc_text(PAGE, VctIndEndpointError)
#pragma alloc_text(PAGE, VctIndSendPossible)
#pragma alloc_text(PAGE, VctCompleteInitialization)
#pragma alloc_text(PAGE, VctUninitialize)
#pragma alloc_text(PAGE, VctpTranslateNetbiosNameToIpAddress)
#pragma alloc_text(PAGE, VctComputeTransportAddressSize)
#pragma alloc_text(PAGE, VctBuildTransportAddress)
#pragma alloc_text(PAGE, VctpCreateConnection)
#pragma alloc_text(PAGE, VctpInitializeServerTransport)
#pragma alloc_text(PAGE, VctpUninitializeServerTransport)
#pragma alloc_text(PAGE, VctpInvokeTransportFunction)
#pragma alloc_text(PAGE, VctInstantiateServerTransport)
#pragma alloc_text(PAGE, VctTearDownServerTransport)
#pragma alloc_text(PAGE, VctInitiateDisconnect)
#endif

RXDT_DefineCategory(VCSNDRCV);
#define Dbg        (DEBUG_TRACE_VCSNDRCV)

// Move this def to a common .h file.
#define MAX_SMB_PACKET_SIZE (65536)

#define MIN(a,b) ((a) < (b) ? (a) : (b))

//
// Forward references of functions ....
//

extern NTSTATUS
VctTearDownServerTransport(
    PSMBCE_SERVER_TRANSPORT pTransport);

extern NTSTATUS
VctInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE            pExchange);

extern PSMBCE_VC
VctSelectVc(
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport,
    BOOLEAN                    fMultiplexed);

extern NTSTATUS
SmbCeReceiveIndWithSecuritySignature(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN ULONG                 BytesIndicated,
    IN ULONG                 BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN PVOID                 pTsdu,
    OUT PMDL                 *pDataBufferPointer,
    OUT PULONG               pDataBufferSize,
    IN ULONG                 ReceiveFlags
    );

extern NTSTATUS
SmbCeDataReadyIndWithSecuritySignature(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PMDL                  pBuffer,
   IN ULONG                 DataSize,
   IN NTSTATUS              CopyDataStatus);

#define SmbMmInitializeVcEntry(pVcEntry)                      \
         SmbMmInitializeHeader((pVcEntry));

#define SmbMmUninitializeVcEntry(pVcEntry)    \
         ASSERT(IsListEmpty(&(pVcEntry)->Requests.ListHead))

#define VctSelectMultiplexedVcEntry(pVcTransport)  VctSelectVc(pVcTransport,TRUE)
#define VctSelectRawVcEntry(pVcTransport)          VctSelectVc(pVcTransport,FALSE)

//
// Inline functions to update the state of a VC.
//

INLINE BOOLEAN
VctUpdateVcStateLite(
    PSMBCE_VC       pVc,
    SMBCE_VC_STATE  NewState)
{
    BOOLEAN Result = TRUE;

    ASSERT(SmbCeSpinLockAcquired());

    if (NewState == SMBCE_VC_STATE_RAW) {
        if (pVc->SwizzleCount != 0) {
            Result = FALSE;
        } else {
            pVc->State = NewState;
        }
    } else {
        pVc->State = NewState;
    }

    return Result;
}

INLINE BOOLEAN
VctUpdateVcState(
    PSMBCE_VC       pVc,
    SMBCE_VC_STATE  NewState)
{
    BOOLEAN Result = TRUE;

    SmbCeAcquireSpinLock();

    Result = VctUpdateVcStateLite(pVc,NewState);

    SmbCeReleaseSpinLock();

    return Result;
}

NTSTATUS
VctTranceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pTransport    - the transport

    pServerEntry  - the server entry

    pExchange     - the exchange instance issuing this SMB.

    SendOptions   - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

    pSendCompletionContext - the send completion context

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS                   Status = STATUS_SUCCESS;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;
    PSMB_HEADER                pSmbHeader = MmGetSystemAddressForMdlSafe(pSmbMdl,LowPagePriority);
    USHORT                     Mid;
    BOOLEAN                    fInvokeSendCompleteHandler = TRUE;

    PAGED_CODE();

    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    if (pSmbHeader == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

        // Ensure that the connection is still active before satisfying the request.
        if (SmbCeIsEntryInUse(&pServerEntry->Header)) {
            pVc = pExchange->SmbCeContext.TransportContext.Vcs.pVc;
            if (pVc == NULL) {
                Status = STATUS_CONNECTION_DISCONNECTED;
            }

            if ((Status == STATUS_SUCCESS) &&
                (pVc->State == SMBCE_VC_STATE_MULTIPLEXED)) {
                Status = RxCeSend(
                             &pVc->RxCeVc,
                             SendOptions,
                             pSmbMdl,
                             SendLength,
                             pSendCompletionContext);

                if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
                    Status = STATUS_PENDING;
                    // The underlying connection engine assumes the responsibility of
                    // invoking the send complete handler from this point.
                    fInvokeSendCompleteHandler = FALSE;
                }
            } else {
                RxDbgTrace(0, Dbg, ("VctTranceive: Disconnected connection detected\n"));
                Status = STATUS_CONNECTION_DISCONNECTED;
            }
        } else {
            // The server entry is not valid ...
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
    }

    if (Status != STATUS_PENDING) {
        RxDbgTrace(0, Dbg, ("VctTranceive: Return Status %lx\n",Status));
    }

    // There are instances in which the send was aborted even before the underlying
    // transport was invoked. In such cases the appropriate send complete handler
    // needs to be called so that the associated exchange can be finalized.

    if (fInvokeSendCompleteHandler) {
        NTSTATUS LocalStatus;

        LocalStatus = SmbCeSendCompleteInd(
                          pServerEntry,
                          pSendCompletionContext,
                          Status);

        RxDbgTrace(0, Dbg, ("VctTranceive: Send Complete Handler Return Status %lx\n",LocalStatus));
    }

    return Status;
}


NTSTATUS
VctReceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pTransport   - the server transport

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

Return Value:

    STATUS_PENDING - the request has been queued

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS                   Status = STATUS_SUCCESS;
    PSMBCEDB_NET_ROOT_ENTRY    pNetRootEntry;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

    PAGED_CODE();

    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
    pVc          = pExchange->SmbCeContext.TransportContext.Vcs.pVc;

    // Ensure that the connection is still active before satisfying the request.
    if (SmbCeIsEntryInUse(&pServerEntry->Header) &&
        (pVc != NULL)) {
        Status = STATUS_SUCCESS;
    } else {
        // The server entry is not valid ...
        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    return Status;
}

NTSTATUS
VctSend(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pTransport - the server transport

    pServer    - the recepient server

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be sent

    pSendCompletionContext - the send completion context

Return Value:

    STATUS_SUCCESS - the send was successful.

    STATUS_PENDING - the send has been queued

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS                   Status = STATUS_CONNECTION_DISCONNECTED;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;
    BOOLEAN                    fInvokeSendCompleteHandler = TRUE;

    PAGED_CODE();

    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
    pVc = VctSelectMultiplexedVcEntry(pVcTransport);

    if  (pVc != NULL) {
        if (pVc->State == SMBCE_VC_STATE_MULTIPLEXED) {
            Status = RxCeSend(
                         &pVc->RxCeVc,
                         SendOptions,
                         pSmbMdl,
                         SendLength,
                         pSendCompletionContext);

            if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
                // The underlying connection engine assumes the responsibility of
                // invoking the send complete handler from this point.
                fInvokeSendCompleteHandler = FALSE;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace(0, Dbg, ("VctSend: RxCeSend returned %lx\n",Status));
    }

    // There are instances in which the send was aborted even before the underlying
    // transport was invoked. In such cases the appropriate send complete handler
    // needs to be called so that the associated exchange can be finalized.

    if (fInvokeSendCompleteHandler) {
        NTSTATUS LocalStatus;

        LocalStatus = SmbCeSendCompleteInd(
                          pServerEntry,
                          pSendCompletionContext,
                          Status);

        RxDbgTrace(0, Dbg, ("VctTranceive: Send Complete Handler Return Status %lx\n",LocalStatus));
    }

    return Status;
}

NTSTATUS
VctSendDatagram(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pTransport - the server transport

    pServer    - the recepient server

    SendOptions - options for send

    pSmbMdl     - the SMB that needs to be sent.

    SendLength  - length of data to be sent

    pSendCompletionContext - the send completion context

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}

PSMBCE_VC
VctSelectVc(
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport,
    BOOLEAN                    fMultiplexed)
/*++

Routine Description:

    This routine embodies the logic for the selection of a VC on which the SMB exchange
    will transpire

Arguments:

    pVcTransport  - the transport structure

    fMultiplexed  - the desired mode

Return Value:

    a referenced VC entry if successful otherwise NULL

--*/
{
    NTSTATUS        Status;
    PSMBCE_VC       pVc = NULL;
    ULONG           VcIndex,NumberOfActiveVcs = 0;
    SMBCE_VC_STATE  DesiredState;

    PAGED_CODE();

    if (fMultiplexed) {
        RxDbgTrace(0, Dbg, ("VctSelectVc: Referencing Multiplexed entry\n"));
        DesiredState = SMBCE_VC_STATE_MULTIPLEXED;
    } else {
        RxDbgTrace(0, Dbg, ("VctSelectVc: Referencing Raw entry\n"));
        DesiredState = SMBCE_VC_STATE_RAW;
    }

    // Acquire the resource
    SmbCeAcquireResource();

    // Choose the first VC that can support multiplexed requests
    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        PSMBCE_VC pTempVc = &pVcTransport->Vcs[VcIndex];

        NumberOfActiveVcs++;

        if (pTempVc->State == SMBCE_VC_STATE_MULTIPLEXED) {
            if (DesiredState == SMBCE_VC_STATE_MULTIPLEXED) {
                pVc = pTempVc;
                break;
            } else {
                // If the current number of active references to a VC is zero, it can
                // be transformed into the raw mode.
                if (VctUpdateVcState(pTempVc,SMBCE_VC_STATE_RAW)) {
                    pVc = pTempVc;
                    break;
                } else {
                    NumberOfActiveVcs++;
                }
            }
        }
    }

    if (pVc == NULL) {
        // Check if it is O.K. to add VCs to this connection. Currently the server
        // implementation supports only one VC per connection. Therefore if an
        // active VC exists which has been grabbed for raw mode use an error is returned.
        // Subsequently when the server is upgraded to handle multiple VCs the logic
        // for adding a new VC will be implemented as part of this routine.
    }

    if (pVc != NULL) {
        VctReferenceVc(pVc);
    }

    // release the resource
    SmbCeReleaseResource();

    return pVc;
}

NTSTATUS
VctInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine initializes the transport information pertinent to a exchange

Arguments:

    pTransport         - the transport structure

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    PSMBCEDB_SERVER_ENTRY      pServerEntry;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

    PAGED_CODE();

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

    ASSERT(pExchange->SmbCeContext.TransportContext.Vcs.pVc == NULL);

    pExchange->SmbCeContext.TransportContext.Vcs.pVc
                     = VctSelectMultiplexedVcEntry(pVcTransport);

    if (pExchange->SmbCeContext.TransportContext.Vcs.pVc == NULL) {
        RxDbgTrace(0, Dbg, ("VctInitializeExchange: Unsuccessful\n"));
        return STATUS_CONNECTION_DISCONNECTED;
    } else {
        RxDbgTrace(0, Dbg, ("VctInitializeExchange: Successful\n"));
        return STATUS_SUCCESS;
    }
}

NTSTATUS
VctUninitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine uninitializes the transport information pertinent to a exchange

Arguments:

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

    PAGED_CODE();

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

    RxDbgTrace(0, Dbg, ("VctUninitializeExchange: Successful\n"));

    if (pExchange->SmbCeContext.TransportContext.Vcs.pVc != NULL) {
        VctDereferenceVc(pExchange->SmbCeContext.TransportContext.Vcs.pVc);
    }

    pExchange->SmbCeContext.TransportContext.Vcs.pVc = NULL;

    return STATUS_SUCCESS;
}


NTSTATUS
VctIndReceive(
    IN PVOID              pEventContext,
    IN PRXCE_VC           pVc,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *pBytesTaken,
    IN PVOID              pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL              *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG            pDataBufferSize         // amount of data to copy
    )
/*++

Routine Description:

    This routine handles the receive indication for SMB's along all vcs in a connection to a
    server.

Arguments:

    pEventContext      - the server entry

    hVc                - the Vc on which the SMB has been received

    ReceiveFlags       - options for receive

    BytesIndicated     - the bytes that are present in the indication.

    BytesAvailable     - the total data available

    pTsdu              - the data

    pDataBufferPointer - the buffer for copying the data not indicated.

    pDataBufferSize    - the length of the buffer

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY  pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

    if (pServerEntry->SecuritySignaturesActive) {
        Status = SmbCeReceiveIndWithSecuritySignature(
                     pServerEntry,
                     BytesIndicated,
                     BytesAvailable,
                     pBytesTaken,
                     pTsdu,
                     pDataBufferPointer,
                     pDataBufferSize,
                     ReceiveFlags);
    } else {
        Status = SmbCeReceiveInd(
                     pServerEntry,
                     BytesIndicated,
                     BytesAvailable,
                     pBytesTaken,
                     pTsdu,
                     pDataBufferPointer,
                     pDataBufferSize,
                     ReceiveFlags);
    }


    return Status;
}

NTSTATUS
VctIndDataReady(
    IN PVOID        pEventContext,
    IN PMDL         pBuffer,
    IN ULONG        DataSize,
    IN NTSTATUS     CopyDataStatus
    )
/*++

Routine Description:

    This routine handles the indication when the requested data has been copied

Arguments:

    pEventContext - the server instance

    pBuffer       - the buffer being returned

    DataSize      - the amount of data copied in bytes

    CopyDataStatus - CopyDataStatus

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY  pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

    if (pServerEntry->SecuritySignaturesActive) {
        Status = SmbCeDataReadyIndWithSecuritySignature(
                     pServerEntry,
                     pBuffer,
                     DataSize,
                     CopyDataStatus);
    } else {
        Status = SmbCeDataReadyInd(
                     pServerEntry,
                     pBuffer,
                     DataSize,
                     CopyDataStatus);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndDisconnect(
    IN PVOID          pEventContext,
    IN PRXCE_VC       pRxCeVc,
    IN int            DisconnectDataLength,
    IN PVOID          DisconnectData,
    IN int            DisconnectInformationLength,
    IN PVOID          DisconnectInformation,
    IN ULONG          DisconnectFlags
    )
/*++

Routine Description:

    This routine handles the disconnect indication for a VC.

Arguments:

    pEventContext               - the server instance

    hVc                         - the virtual circuit

    DisconnectDataLength        -

    DisconnectData              -

    DisconnectInformationLength -

    DisconnectInformation       -

    DisconnectFlags             -

Return Value:

    STATUS_SUCCESS - the disconnect indication has been handled

--*/
{
    PSMBCEDB_SERVER_ENTRY       pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;
    PSMBCEDB_SERVER_ENTRY       pListEntry;
    PSMBCE_VC                   pVc;
    PSMBCEDB_REQUEST_ENTRY      pRequestEntry;
    PSMB_EXCHANGE               pExchange;
    PSMBCE_SERVER_VC_TRANSPORT  pVcTransport;

    BOOLEAN fValidServerEntry = FALSE;
    BOOLEAN OutstandingWorkItem;

    // Traverse the list of server entries to ensure that the disconnect was on a
    // valid server entry. If it is not on a valid server entry ignore it.

    SmbCeAcquireSpinLock();

    pListEntry = SmbCeGetFirstServerEntry();

    while (pListEntry != NULL) {
        if (pListEntry == pServerEntry) {
            // The invalidation needs to hold onto an extra reference to avoid
            // race conditions which could lead to premature destruction of
            // this server entry.
            SmbCeReferenceServerEntry(pServerEntry);
            fValidServerEntry = TRUE;
            break;
        }
        pListEntry = SmbCeGetNextServerEntry(pListEntry);
    }
 
    if (fValidServerEntry) {
        pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

        if (pVcTransport != NULL) {
            ULONG VcIndex;

            for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
                pVc = &pVcTransport->Vcs[VcIndex];

                if (&pVc->RxCeVc == pRxCeVc) {
                    VctUpdateVcStateLite(pVc,SMBCE_VC_STATE_DISCONNECTED);
                    pVc->Status   = STATUS_CONNECTION_DISCONNECTED;
                    break;
                }
            }
        }

	OutstandingWorkItem = pServerEntry->DisconnectWorkItemOutstanding;
	// OK to unconditionally set to TRUE
	pServerEntry->DisconnectWorkItemOutstanding = TRUE;
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    if (fValidServerEntry) {
        RxDbgTrace(0,Dbg,("@@@@@@ Disconnect Indication for %lx @@@@@\n",pServerEntry));
        InterlockedIncrement(&MRxSmbStatistics.ServerDisconnects);

        // Update the Server entry if this is the only VC associated with the transport.
        SmbCeTransportDisconnectIndicated(pServerEntry);
   
	// only dereference if necessary (we might already have an outstanding request)
	if(OutstandingWorkItem == FALSE ) {  

	    InitializeListHead(&pServerEntry->WorkQueueItemForDisconnect.List);

	    RxPostToWorkerThread(
		MRxSmbDeviceObject,
		CriticalWorkQueue,
		&pServerEntry->WorkQueueItemForDisconnect,
		SmbCepDereferenceServerEntry,  
		pServerEntry);
	}
	 
        RxDbgTrace(0, Dbg, ("VctIndDisconnect: Processing Disconnect indication on VC entry %lx\n",pVc));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndError(
    IN PVOID          pEventContext,
    IN PRXCE_VC       pRxCeVc,
    IN NTSTATUS       IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    pRxCeVc       - the RxCe virtual circuit

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS                   Status;
    ULONG                      VcIndex;
    PSMBCEDB_SERVER_ENTRY      pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

    // Acquire the resource
    SmbCeAcquireSpinLock();

    // Map the RXCE vc handle to the appropriate SMBCE entry and get the request
    // list associated with it.

    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        pVc = &pVcTransport->Vcs[VcIndex];

        if (&pVc->RxCeVc == pRxCeVc) {
            VctUpdateVcStateLite(pVc,SMBCE_VC_STATE_DISCONNECTED);
            pVc->Status   = IndicatedStatus;
            break;
        }
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    RxDbgTrace(0, Dbg, ("VctIndError: Processing Error indication on VC entry %lx\n",pVc));

    Status = SmbCeErrorInd(
                 pServerEntry,
                 IndicatedStatus);

    return Status;
}

NTSTATUS
VctIndEndpointError(
    IN PVOID          pEventContext,
    IN NTSTATUS       IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndSendPossible(
    IN PVOID          pEventContext,    // the event context.
    IN PRXCE_VC       pRxCeVc,
    IN ULONG          BytesAvailable
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    hVc           - the VC instance

    BytesAvailable - the number of bytes that can be sent

Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndReceiveDatagram(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL   *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG pDataBufferSize         // amount of data to copy
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
VctIndSendComplete(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pRxCeVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       SendCompletionStatus
   )
/*++

Routine Description:

    This routine handles the send complete indication for asynchronous sends

Arguments:

    pEventContext - the server instance

    pRxCeVc       - the RxCe VC instance

    pCompletionContext - the context for identifying the send request

    SendCompletionStatus - the send completion status

Return Value:

    STATUS_SUCCESS always ..

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

    Status = SmbCeSendCompleteInd(
                 pServerEntry,
                 pCompletionContext,
                 SendCompletionStatus);

    return Status;
}

//
// Static dispatch vectors for Virtual Circuit based transports
//

RXCE_ADDRESS_EVENT_HANDLER
MRxSmbVctAddressEventHandler = {
                                   VctIndEndpointError,
                                   VctIndReceiveDatagram,
                                   VctIndDataReady,
                                   VctIndSendPossible,
                                   NULL
                               };

RXCE_CONNECTION_EVENT_HANDLER
MRxSmbVctConnectionEventHandler = {
                                      VctIndDisconnect,
                                      VctIndError,
                                      VctIndReceive,
                                      VctIndReceiveDatagram,
                                      VctIndReceive,
                                      VctIndSendPossible,
                                      VctIndDataReady,
                                      VctIndSendComplete
                                  };

TRANSPORT_DISPATCH_VECTOR
MRxSmbVctTransportDispatch = {
                                VctSend,
                                VctSendDatagram,
                                VctTranceive,
                                VctReceive,
                                NULL,
                                VctInitializeExchange,
                                VctUninitializeExchange,
                                VctTearDownServerTransport,
                                VctInitiateDisconnect
                             };


typedef enum _RXCE_VC_FUNCTION_CODE {
   VcConnect,
   VcDisconnect
} RXCE_VC_FUNCTION_CODE, *PRXCE_VC_FUNCTION_CODE;

typedef struct _RXCE_VC_CONNECT_CONTEXT {
   RXCE_VC_FUNCTION_CODE         FunctionCode;
   PRX_WORKERTHREAD_ROUTINE      pRoutine;
   PSMBCEDB_SERVER_ENTRY         pServerEntry;
   PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext;
   PSMBCE_SERVER_TRANSPORT       pServerTransport;
   NTSTATUS                      Status;
   KEVENT                        SyncEvent;
} RXCE_VC_CONNECT_CONTEXT, *PRXCE_VC_CONNECT_CONTEXT;

NTSTATUS
VctCompleteInitialization(
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    PSMBCE_TRANSPORT           pTransport,
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    The remote address can be either deduced from the information in the Rx Context
    or a NETBIOS address needs to be built from the server name.
    This transport address is used subsequently to establish the connection.

--*/
{
    NTSTATUS Status;
    PSMBCE_VC                  pVc;

    RXCE_CONNECTION_INFO         ConnectionInfo;
    RXCE_TRANSPORT_PROVIDER_INFO ProviderInfo;

    PAGED_CODE();

    pVc = &pVcTransport->Vcs[0];

    // Query the transport information ...
    Status = RxCeQueryInformation(
                  &pVc->RxCeVc,
                  RxCeTransportProviderInformation,
                  &ProviderInfo,
                  sizeof(ProviderInfo));

    if (NT_SUCCESS(Status)) {
        pVcTransport->MaximumSendSize = MIN( ProviderInfo.MaxSendSize,
                                           MAXIMUM_PARTIAL_BUFFER_SIZE );
    } else {
        // CODE.IMPROVMENT - fix constant below to a #define, also is the
        //    value correct?
        ASSERT( 1024 <= MAXIMUM_PARTIAL_BUFFER_SIZE );
        pVcTransport->MaximumSendSize = 1024;
    }

    // Query the connection information ....
    Status = RxCeQueryInformation(
                 &pVc->RxCeVc,
                 RxCeConnectionEndpointInformation,
                 &ConnectionInfo,
                 sizeof(ConnectionInfo));

    if (NT_SUCCESS(Status)) {
        // The setting of the delay parameter is an important heuristic
        // that determines how quickly and how often timeouts occur. As
        // a first cut a very conservative estimate for the time has been
        // choosen, i.e., double the time required to transmit a 64 k packet.
        // This parameter should be fine tuned.

        pVcTransport->Delay.QuadPart = (-ConnectionInfo.Delay.QuadPart) +
                           (-ConnectionInfo.Delay.QuadPart);
        if (ConnectionInfo.Throughput.LowPart != 0) {
            pVcTransport->Delay.QuadPart +=
                     (MAX_SMB_PACKET_SIZE/ConnectionInfo.Throughput.LowPart) * 1000 * 10000;
        }

        RxDbgTrace( 0, Dbg, ("Connection delay set to %ld 100ns ticks\n",pVcTransport->Delay.LowPart));

        pVcTransport->pDispatchVector = &MRxSmbVctTransportDispatch;
        pVcTransport->MaximumNumberOfVCs = 1;

        pVc->State     = SMBCE_VC_STATE_MULTIPLEXED;

        pVcTransport->State = SMBCEDB_ACTIVE;
    } else {
        RxDbgTrace(0, Dbg, ("VctInitialize : RxCeQueryInformation returned %lx\n",Status));
    }

    if (NT_SUCCESS(Status)) {
        pVcTransport->pTransport   = pTransport;
    } else {
        RxDbgTrace(0, Dbg, ("VctInitialize : Connection Initialization Failed %lx\n",Status));
    }

    return Status;
}

NTSTATUS
VctUninitialize(
    PVOID pTransport)
/*++

Routine Description:

    This routine uninitializes the transport instance

Arguments:

    pVcTransport - the VC transport instance

Return Value:

    STATUS_SUCCESS - the server transport construction has been uninitialzied.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS                   Status = STATUS_SUCCESS;
    ULONG                      VcIndex;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
    ULONG                      TransportFlags;

    PAGED_CODE();

    // The spinlock needs to be acquired for manipulating the list of Vcs because of
    // indications that will be processed till the appropriate RXCE data structures are
    // dismantled

    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        pVc = &pVcTransport->Vcs[VcIndex];

        // Assert the fact that the request list associated with the VC is empty.
        // Tear down the VC entry
        Status = RxCeTearDownVC(&pVc->RxCeVc);
        ASSERT(Status == STATUS_SUCCESS);
    }

    // Tear down the connection endpoint ..
    Status = RxCeTearDownConnection(&pVcTransport->RxCeConnection);
    ASSERT(Status == STATUS_SUCCESS);

    RxDbgTrace(0, Dbg, ("VctUninitialize : RxCeDisconnect returned %lx\n",Status));

    // Dereference the underlying transport
    if (pVcTransport->pTransport != NULL) {
        SmbCeDereferenceTransport(pVcTransport->pTransport);
    }

    ASSERT((pVcTransport->Vcs[0].RxCeVc.hEndpoint == INVALID_HANDLE_VALUE) ||
           (pVcTransport->Vcs[0].RxCeVc.hEndpoint == NULL));

    ASSERT(pVcTransport->Vcs[0].RxCeVc.pEndpointFileObject == NULL);

    // Free up the transport entry
    RxFreePool(pVcTransport);

    return Status;
}

NTSTATUS
VctpTranslateNetbiosNameToIpAddress(
    IN  OEM_STRING *pName,
    OUT ULONG      *pIpAddress
    )
/*++

Routine Description:

    This routine converts ascii ipaddr (11.101.4.25) into a ULONG.  This is
    based on the inet_addr code in winsock

Arguments:
    pName   - the string containing the ipaddress

Return Value:

    the ipaddress as a ULONG if it's a valid ipaddress.  Otherwise, 0.

Notes:

    The body of this routine has been borrowed fron NetBt.

--*/
{
    NTSTATUS  Status;
    PCHAR    pStr;
    int      i;
    int      len, fieldLen;
    int      fieldsDone;
    ULONG    IpAddress;
    BYTE     ByteVal;
    PCHAR    pIpPtr;
    BOOLEAN  fDotFound;
    BOOLEAN  fieldOk;

    PAGED_CODE();

    Status = STATUS_INVALID_ADDRESS_COMPONENT;

    if (pName->Length > NETBIOS_NAME_LEN) {
        return Status;
    }

    pStr = pName->Buffer;
    len = 0;
    pIpPtr = (PCHAR)&IpAddress;
    pIpPtr += 3;                   // so that we store in network order
    fieldsDone=0;

    //
    // the 11.101.4.25 format can be atmost 15 chars, and pName is guaranteed
    // to be at least 16 chars long (how convenient!!).  Convert the string to
    // a ULONG.
    //
    while(len < NETBIOS_NAME_LEN)
    {
        fieldLen=0;
        fieldOk = FALSE;
        ByteVal = 0;
        fDotFound = FALSE;

        //
        // This loop traverses each of the four fields (max len of each
        // field is 3, plus 1 for the '.'
        //
        while (fieldLen < 4)
        {
            if (*pStr >='0' && *pStr <='9')
            {
                ByteVal = (ByteVal*10) + (*pStr - '0');
                fieldOk = TRUE;
            }

            else if (*pStr == '.' || *pStr == ' ' || *pStr == '\0')
            {
                *pIpPtr = ByteVal;
                pIpPtr--;
                fieldsDone++;

                if (*pStr == '.')
                    fDotFound = TRUE;

                // if we got a space or 0, assume it's the 4th field
                if (*pStr == ' ' || *pStr == '\0')
                {
                    break;
                }
            }

            // unacceptable char: can't be ipaddr
            else
            {
                return(Status);
            }

            pStr++;
            len++;
            fieldLen++;

            // if we found the dot, we are done with this field: go to the next one
            if (fDotFound)
                break;
        }

        // this field wasn't ok (e.g. "11.101..4" or "11.101.4." etc.)
        if (!fieldOk)
        {
            return(Status);
        }

        // if we are done with all 4 fields, we are done with the outer loop too
        if ( fieldsDone == 4)
            break;

        if (!fDotFound)
        {
            return(Status);
        }
    }

    //
    // make sure the remaining chars are spaces or 0's (i.e. don't allow
    // 11.101.4.25xyz to succeed)
    //
    for (i=len; i<NETBIOS_NAME_LEN; i++, pStr++)
    {
        if (*pStr != ' ' && *pStr != '\0')
        {
            return(Status);
        }
    }

    *pIpAddress = IpAddress;
    return( STATUS_SUCCESS );
}


ULONG
VctComputeTransportAddressSize(
   IN PUNICODE_STRING pServerName)

/*++

Routine Description:

    This routine takes a computer name (PUNICODE_STRING) and computes the size of the
    TRANSPORT_ADDRESSS buffer required to connect to it.

Arguments:

    IN PUNICODE_STRING Name - Supplies the name to put into the transport

Return Value:

    size of the buffer.

Notes:

    The compound transport address passed to the transports consists of two
    TDI_NETBIOS_EX_ADDRESSes and a TDI_NETBIOS_ADDRESS. The two NETBIOS_EX addresses refer
    to the two different endpoints registered by the server, i.e., *SMBSERVER and
    the Server name padded upto NETBIOS_NAME_LEN with blanks. The order in which
    the two NETBIOS_EX addresses are constructed depend upon the length of the server
    name. If it is greater than NETBIOS_NAME_LEN *SMBSERVER is the first enpoint
    and vice versa

--*/
{
   ULONG NetbiosAddressLength,NetbiosExAddressLength,NetbiosUnicodeExAddressLength,TransportAddressSize;
   ULONG OemServerNameLength;

   PAGED_CODE();

   OemServerNameLength = RtlUnicodeStringToOemSize(pServerName);

   NetbiosAddressLength = sizeof(TDI_ADDRESS_NETBIOS);
   if( OemServerNameLength > NETBIOS_NAME_LEN ) {
       NetbiosAddressLength += OemServerNameLength - NETBIOS_NAME_LEN;
   }

   NetbiosExAddressLength = FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress) +
                        NetbiosAddressLength;
   
   NetbiosUnicodeExAddressLength = FIELD_OFFSET(TDI_ADDRESS_NETBIOS_UNICODE_EX,RemoteNameBuffer) +
                        pServerName->Length +
                        DNS_NAME_BUFFER_LENGTH * sizeof(WCHAR);

   TransportAddressSize = FIELD_OFFSET(TRANSPORT_ADDRESS,Address) +
                          3 * FIELD_OFFSET(TA_ADDRESS,Address) +
                          NetbiosAddressLength +
                          2 * NetbiosExAddressLength +
                          NetbiosUnicodeExAddressLength;

   return TransportAddressSize;
}

NTSTATUS
VctBuildTransportAddress (
    IN  PTRANSPORT_ADDRESS pTransportAddress,
    IN  ULONG              TransportAddressLength,
    IN  PUNICODE_STRING    pServerName,
    OUT PULONG             pServerIpAddress
    )
/*++

Routine Description:

    This routine takes a computer name (PUNICODE_STRING) and converts it into an
    acceptable form for passing in as transport address.

Arguments:

    pTransportAddress      - Supplies the structure to fill in

    TransportAddressLength - Supplies the length of the buffer at TransportAddress

    pServerName            - Supplies the name to put into the transport

    pServerNameIsInIpAddressFormat = Server Name is of the dotted IP address kind

Return Value:

    None.

Notes:

    The compound transport address passed to the transports consists of two
    TDI_NETBIOS_EX_ADDRESSes and a TDI_NETBIOS_ADDRESS. The two NETBIOS_EX addresses refer
    to the two different endpoints registered by the server, i.e., *SMBSERVER and
    the Server name padded upto NETBIOS_NAME_LEN with blanks. The order in which
    the two NETBIOS_EX addresses are constructed depend upon the length of the server
    name. If it is greater than NETBIOS_NAME_LEN *SMBSERVER is the first enpoint
    and vice versa

    The WINS database can be inconsistent for extended periods of time. In order to
    account for this inconsistency on NETBIOS names and DNS names we will not
    issue the address for *SMBSERVER. This will be revisited when we have a better
    mechanism for identifying/authenticating the server and the client machine to each other.

--*/

{
    OEM_STRING OemServerName;
    NTSTATUS   Status;

    PTDI_ADDRESS_NETBIOS_EX pTdiNetbiosExAddress;
    PTDI_ADDRESS_NETBIOS    pTdiNetbiosAddress;
    PTA_ADDRESS             pFirstNetbiosExAddress,pSecondNetbiosExAddress,pNetbiosAddress,pNetbiosUnicodeExAddress;
    PTDI_ADDRESS_NETBIOS_UNICODE_EX pTdiNetbiosUnicodeExAddress;

    PCHAR  FirstEndpointName,SecondEndpointName;
    CHAR   EndpointNameBuffer[NETBIOS_NAME_LEN];
    WCHAR  UnicodeEndpointNameBuffer[NETBIOS_NAME_LEN];
    USHORT NetbiosAddressLength,NetbiosExAddressLength;
    USHORT NetbiosAddressType = TDI_ADDRESS_TYPE_NETBIOS;

    ULONG  ComponentLength;

    ULONG   RemoteIpAddress;
    BOOLEAN ServerNameIsInIpAddressForm;

    PAGED_CODE();

    if (TransportAddressLength < VctComputeTransportAddressSize(pServerName)) {
       return STATUS_BUFFER_OVERFLOW;
    }

    pFirstNetbiosExAddress = &pTransportAddress->Address[0];

    pTdiNetbiosExAddress = (PTDI_ADDRESS_NETBIOS_EX)pFirstNetbiosExAddress->Address;
    pTdiNetbiosExAddress->NetbiosAddress.NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;

    OemServerName.Length = pServerName->Length;
    OemServerName.MaximumLength = OemServerName.Length + 1;
    OemServerName.Buffer = pTdiNetbiosExAddress->NetbiosAddress.NetbiosName;

    Status = RtlUpcaseUnicodeStringToOemString(&OemServerName, pServerName, FALSE);
    if( !NT_SUCCESS( Status ) ) {
        //return STATUS_BAD_NETWORK_PATH;
        OemServerName.Length = 0;
    }

    if (OemServerName.Length < NETBIOS_NAME_LEN) {
       RtlCopyMemory( &OemServerName.Buffer[ OemServerName.Length ],
                      "                ",
                      NETBIOS_NAME_LEN - OemServerName.Length
                    );
       OemServerName.Length = NETBIOS_NAME_LEN;
    }

    Status = VctpTranslateNetbiosNameToIpAddress(&OemServerName,&RemoteIpAddress);
    if (Status == STATUS_SUCCESS) {
        if ((RemoteIpAddress == 0) || (RemoteIpAddress == 0xffffffff)) {
           // If the server name is a valid IP address and matches with one of the two
           // broadcast addresses used by IP turn back the request.
           return STATUS_INVALID_ADDRESS_COMPONENT;
        }

        *pServerIpAddress = RemoteIpAddress;
        ServerNameIsInIpAddressForm = TRUE;
    } else {
        *pServerIpAddress = 0;
        ServerNameIsInIpAddressForm = FALSE;
    }


    NetbiosAddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    if( OemServerName.Length > NETBIOS_NAME_LEN ) {
        NetbiosAddressLength += OemServerName.Length - NETBIOS_NAME_LEN;
    }

    NetbiosExAddressLength = (USHORT)(FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress) +
                             NetbiosAddressLength);

    pFirstNetbiosExAddress->AddressLength = NetbiosExAddressLength;
    pFirstNetbiosExAddress->AddressType   = TDI_ADDRESS_TYPE_NETBIOS_EX;

#if 0
    // This arm of the code will be activated and the other arm deactivated when we have
    // mutual authenitication between server and client machines in NT5.0

    if (ServerNameIsInIpAddressForm) {
       pTransportAddress->TAAddressCount = 2;

       pNetbiosAddress = (PTA_ADDRESS)((PCHAR)pFirstNetbiosExAddress +
                                       FIELD_OFFSET(TA_ADDRESS,Address) +
                                       NetbiosExAddressLength);

       FirstEndpointName = SMBSERVER_LOCAL_ENDPOINT_NAME;
    } else {
       pTransportAddress->TAAddressCount = 3;

       pSecondNetbiosExAddress = (PTA_ADDRESS)((PCHAR)pFirstNetbiosExAddress +
                                         FIELD_OFFSET(TA_ADDRESS,Address) +
                                         NetbiosExAddressLength);

       pNetbiosAddress = (PTA_ADDRESS)((PCHAR)pSecondNetbiosExAddress +
                                       FIELD_OFFSET(TA_ADDRESS,Address) +
                                       NetbiosExAddressLength);

       // Scan the server name till the first delimiter (DNS delimiter .) and form
       // the endpoint name by padding the remaining name with blanks.

       RtlCopyMemory(
             EndpointNameBuffer,
             OemServerName.Buffer,
             NETBIOS_NAME_LEN);

       ComponentLength = 0;
       while (ComponentLength < NETBIOS_NAME_LEN) {
          if (EndpointNameBuffer[ComponentLength] == '.') {
             break;
          }
          ComponentLength++;
       }

       if (ComponentLength == NETBIOS_NAME_LEN) {
          EndpointNameBuffer[NETBIOS_NAME_LEN - 1] = ' ';
       } else {
          RtlCopyMemory(&EndpointNameBuffer[ComponentLength],
                        "                ",
                        NETBIOS_NAME_LEN - ComponentLength);
       }

       FirstEndpointName  = EndpointNameBuffer;
       SecondEndpointName = SMBSERVER_LOCAL_ENDPOINT_NAME;
    }
#else
    pTransportAddress->TAAddressCount = 3;

    pNetbiosAddress = (PTA_ADDRESS)((PCHAR)pFirstNetbiosExAddress +
                                    FIELD_OFFSET(TA_ADDRESS,Address) +
                                    NetbiosExAddressLength);
    
    if (ServerNameIsInIpAddressForm) {
       FirstEndpointName = SMBSERVER_LOCAL_ENDPOINT_NAME;
    } else {
       // Scan the server name till the first delimiter (DNS delimiter .) and form
       // the endpoint name by padding the remaining name with blanks.

       RtlCopyMemory(
             EndpointNameBuffer,
             OemServerName.Buffer,
             NETBIOS_NAME_LEN);

       ComponentLength = 0;
       while (ComponentLength < NETBIOS_NAME_LEN) {
          if (EndpointNameBuffer[ComponentLength] == '.') {
             break;
          }
          ComponentLength++;
       }

       if (ComponentLength == NETBIOS_NAME_LEN) {
          EndpointNameBuffer[NETBIOS_NAME_LEN - 1] = ' ';
       } else {
          RtlCopyMemory(&EndpointNameBuffer[ComponentLength],
                        "                ",
                        NETBIOS_NAME_LEN - ComponentLength);
       }

       FirstEndpointName  = EndpointNameBuffer;
    }
#endif

    // Copy the first endpoint name
    RtlCopyMemory(
        pTdiNetbiosExAddress->EndpointName,
        FirstEndpointName,
        NETBIOS_NAME_LEN);

#if 0
    // This will be activated alongwith the other code when mutual authentication is
    // in place
    if (!ServerNameIsInIpAddressForm) {
       // The same NETBIOS_EX address needs to be duplicated with a different endpoint name
       // for the second TA_ADDRESS.

       RtlCopyMemory(
            pSecondNetbiosExAddress,
            pFirstNetbiosExAddress,
            (FIELD_OFFSET(TA_ADDRESS,Address) + NetbiosExAddressLength));

       RtlCopyMemory(
            ((PCHAR)pSecondNetbiosExAddress +
             FIELD_OFFSET(TA_ADDRESS,Address) +
             FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,EndpointName)),
            SecondEndpointName,
            NETBIOS_NAME_LEN);
    }
#else
    //ASSERT(pTransportAddress->TAAddressCount == 2);
#endif
    // The Netbios address associated with the first NETBIOS_EX address is the last netbios
    // address that is passed in.

    RtlCopyMemory(
         ((PCHAR)pNetbiosAddress),
         &NetbiosAddressLength,
         sizeof(USHORT));

    RtlCopyMemory(
         ((PCHAR)pNetbiosAddress + FIELD_OFFSET(TA_ADDRESS,AddressType)),
         &NetbiosAddressType,
         sizeof(USHORT));

    RtlCopyMemory(
         ((PCHAR)pNetbiosAddress + FIELD_OFFSET(TA_ADDRESS,Address)),
         &pTdiNetbiosExAddress->NetbiosAddress,
         NetbiosAddressLength);

    // Unicode Netbios name
    pNetbiosUnicodeExAddress = (PTA_ADDRESS)((PCHAR)pNetbiosAddress +
                                    FIELD_OFFSET(TA_ADDRESS,Address) +
                                    NetbiosAddressLength);

    pNetbiosUnicodeExAddress->AddressLength = (USHORT)(FIELD_OFFSET(TDI_ADDRESS_NETBIOS_UNICODE_EX,RemoteNameBuffer) +
                                              DNS_NAME_BUFFER_LENGTH * sizeof(WCHAR));
    pNetbiosUnicodeExAddress->AddressType   = TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX;
    
    pTdiNetbiosUnicodeExAddress = (PTDI_ADDRESS_NETBIOS_UNICODE_EX)pNetbiosUnicodeExAddress->Address;
    pTdiNetbiosUnicodeExAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;
    pTdiNetbiosUnicodeExAddress->NameBufferType = NBT_READWRITE;

    pTdiNetbiosUnicodeExAddress->EndpointName.Length = (NETBIOS_NAME_LEN)*sizeof(WCHAR);
    pTdiNetbiosUnicodeExAddress->EndpointName.MaximumLength = (NETBIOS_NAME_LEN+1)*sizeof(WCHAR);
    pTdiNetbiosUnicodeExAddress->EndpointName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->EndpointBuffer;

    pTdiNetbiosUnicodeExAddress->RemoteName.Length = pServerName->Length;
    pTdiNetbiosUnicodeExAddress->RemoteName.MaximumLength = DNS_NAME_BUFFER_LENGTH*sizeof(WCHAR);
    pTdiNetbiosUnicodeExAddress->RemoteName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->RemoteNameBuffer;

    if (pTdiNetbiosUnicodeExAddress->RemoteName.MaximumLength > pServerName->Length) {
        ComponentLength = pServerName->Length;
    } else {
        ComponentLength = pTdiNetbiosUnicodeExAddress->RemoteName.MaximumLength;
    }

    RtlCopyMemory(
          pTdiNetbiosUnicodeExAddress->RemoteNameBuffer,
          pServerName->Buffer,
          ComponentLength);
    
    if (ServerNameIsInIpAddressForm) {
        RtlCopyMemory(
              pTdiNetbiosUnicodeExAddress->EndpointBuffer,
              SMBSERVER_LOCAL_ENDPOINT_NAME_UNICODE,
              NETBIOS_NAME_LEN);
    } else {
        // Scan the server name till the first delimiter (DNS delimiter .) and form
        // the endpoint name by padding the remaining name with blanks.
        
        RtlCopyMemory(
             pTdiNetbiosUnicodeExAddress->EndpointBuffer,
             L"                ",
             NETBIOS_NAME_LEN*sizeof(WCHAR));
      
        if (pTdiNetbiosUnicodeExAddress->EndpointName.Length > pServerName->Length) {
            ComponentLength = pServerName->Length;
        } else {
            ComponentLength = pTdiNetbiosUnicodeExAddress->EndpointName.Length;
        }

        RtlCopyMemory(
             pTdiNetbiosUnicodeExAddress->EndpointBuffer,
             pServerName->Buffer,
             ComponentLength);

        ComponentLength = 0;
        while (ComponentLength < NETBIOS_NAME_LEN) {
           if (pTdiNetbiosUnicodeExAddress->EndpointBuffer[ComponentLength] == L'.') {
              break;
           }
           ComponentLength++;
        }

        if (ComponentLength == NETBIOS_NAME_LEN) {
           pTdiNetbiosUnicodeExAddress->EndpointBuffer[NETBIOS_NAME_LEN - 1] = ' ';
        } else {
           RtlCopyMemory(&pTdiNetbiosUnicodeExAddress->EndpointBuffer[ComponentLength],
                        L"                ",
                        (NETBIOS_NAME_LEN-ComponentLength)*sizeof(WCHAR));
        }
    }

    //DbgPrint("Build TA %lx %lx %lx\n",pFirstNetbiosExAddress,pNetbiosAddress,pNetbiosUnicodeExAddress);
    
    return STATUS_SUCCESS;
}

typedef struct _SMBCE_VC_CONNECTION_COMPLETION_CONTEXT {
    RXCE_CONNECTION_COMPLETION_CONTEXT;

    PSMBCE_TRANSPORT_ARRAY     pTransportArray;
    PSMBCE_TRANSPORT           pTransport;
    PSMBCE_SERVER_VC_TRANSPORT pServerTransport;

    ULONG                   TransportAddressLength;
    PTRANSPORT_ADDRESS      pTransportAddress;

    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext;
} SMBCE_VC_CONNECTION_COMPLETION_CONTEXT,
  *PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT;

NTSTATUS
VctpCreateConnectionCallback(
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT pContext)
/*++

Routine Description:

    This is the connection callback routine initiated when the underlying
    transports have completed initialization

Arguments:

    pCOntext = the connection completion context

Notes:

--*/
{
    NTSTATUS Status;

    PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT      pVcCompletionContext;
    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pSmbCeContext;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pVcCompletionContext = (PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT)pContext;
    pSmbCeContext        = pVcCompletionContext->pContext;

    pServerEntry = pSmbCeContext->pServerEntry;

    pSmbCeContext->Status = pVcCompletionContext->Status;

    Status = pVcCompletionContext->Status;

    if (Status == STATUS_SUCCESS) {
        PTA_ADDRESS pTaAdress;
        PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)pVcCompletionContext->pConnectionInformation->RemoteAddress;
        LONG NoOfAddress;

        if (pVcCompletionContext->pTransport == NULL) {
            pVcCompletionContext->pTransport =
                pVcCompletionContext->pTransportArray->SmbCeTransports[
                    pVcCompletionContext->AddressIndex];

            SmbCeReferenceTransport(pVcCompletionContext->pTransport);
        }
        
        //DbgPrint("Remote address %lx \n",pVcCompletionContext->pConnectionInformation->RemoteAddress);

        //DbgPrint("Number of TA returned %d %lx\n",pTransportAddress->TAAddressCount,pTransportAddress->Address);
        pTaAdress = &pTransportAddress->Address[0];

        for (NoOfAddress=0; NoOfAddress<pTransportAddress->TAAddressCount;NoOfAddress++) {
            if (pTaAdress->AddressType == TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX) {
                PTDI_ADDRESS_NETBIOS_UNICODE_EX pTdiNetbiosUnicodeExAddress;

                pTdiNetbiosUnicodeExAddress = (PTDI_ADDRESS_NETBIOS_UNICODE_EX)pTaAdress->Address;
                pTdiNetbiosUnicodeExAddress->EndpointName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->EndpointBuffer;
                pTdiNetbiosUnicodeExAddress->RemoteName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->RemoteNameBuffer;
                
                SmbCeAcquireResource();
                if (pTdiNetbiosUnicodeExAddress->NameBufferType == NBT_WRITTEN) {
                    //DbgPrint("DNS name was returned from NetBT %wZ\n", &pTdiNetbiosUnicodeExAddress->RemoteName);

                    DWORD dwNewSize = pTdiNetbiosUnicodeExAddress->RemoteName.Length+2*sizeof(WCHAR);

                    // if old allocation is to small get rid of it
                    if(pServerEntry->DnsName.Buffer != NULL && 
                       dwNewSize > pServerEntry->DnsName.MaximumLength) {
                        RxFreePool(pServerEntry->DnsName.Buffer);
                        pServerEntry->DnsName.Buffer = NULL;
                    }

                    // make new allocation (if we don't already have one)
                    if(pServerEntry->DnsName.Buffer == NULL) {
                        pServerEntry->DnsName.Buffer = RxAllocatePoolWithTag(NonPagedPool, dwNewSize, MRXSMB_SERVER_POOLTAG);
                    }

                    if (pServerEntry->DnsName.Buffer != NULL) {
                        pServerEntry->DnsName.Length = pTdiNetbiosUnicodeExAddress->RemoteName.Length;
                        pServerEntry->DnsName.MaximumLength = pServerEntry->DnsName.Length+2*sizeof(WCHAR);

                        RtlCopyMemory(pServerEntry->DnsName.Buffer,
                                      pTdiNetbiosUnicodeExAddress->RemoteNameBuffer,
                                      pServerEntry->DnsName.Length);

                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } else {
                    //DbgPrint("DNS name was not returned from NetBT for %wZ\n", &pTdiNetbiosUnicodeExAddress->RemoteName);
                    if(pServerEntry->DnsName.Buffer != NULL) {
                        RxFreePool(pServerEntry->DnsName.Buffer);
                        pServerEntry->DnsName.Buffer = NULL;
                    }
                }
                SmbCeReleaseResource();

                break;
            } else {
                //DbgPrint("TA %lx is not a NETBIOS_UNICODE_EX\n", pTaAdress);
                pTaAdress = (PTA_ADDRESS)((PCHAR)pTaAdress +
                                FIELD_OFFSET(TA_ADDRESS,Address) +
                                pTaAdress->AddressLength);
            }
        }
        
        if (Status == STATUS_SUCCESS) {
            // The Server IP address is not known. Query the underlying
            // transport for the remote transport address, i.e., NETBIOS
            // name or IP address. This will be subsequently used to
            // determine the VC number to be used in session setup and X for
            // downlevel servers.

            Status = RxCeQueryInformation(
                        pVcCompletionContext->pVc,
                        RxCeRemoteAddressInformation,
                        pVcCompletionContext->pTransportAddress,
                        pVcCompletionContext->TransportAddressLength);
        }

        if (Status == STATUS_SUCCESS) {
            ULONG   NumberOfAddresses;
            USHORT  AddressLength;
            USHORT  AddressType;
            PBYTE   pBuffer = (PBYTE)pVcCompletionContext->pTransportAddress;
            
            // All Transports currently return a data structure in which
            // the first four bytes are a ULONG which encodes the number
            // of connections opened to the given remote address. The
            // actual Transport address follows.
            pBuffer += sizeof(ULONG);

            // The buffer contains a TRANSPORT_ADDRESS, the first field
            // of which is the count.
            NumberOfAddresses = SmbGetUlong(pBuffer);

            // This is followed by an array of variable length TA_ADDRESS
            // structures. At this point pBuffer points to the first
            // TA_ADDRESS.
            pBuffer += sizeof(ULONG);

            while (NumberOfAddresses-- > 0) {
                AddressLength = SmbGetUshort(pBuffer);
                pBuffer += sizeof(USHORT);

                AddressType = SmbGetUshort(pBuffer);

                if (AddressType != TDI_ADDRESS_TYPE_IP) {
                    // skip to the next TA_ADDRESS
                    pBuffer += AddressLength + sizeof(USHORT);
                } else {
                    // Skip past the type field to position at the
                    // corresponding TDI_ADDRESS_IP structure
                    pBuffer += sizeof(USHORT);

                    // skip to the in_addr field
                    pBuffer += FIELD_OFFSET(TDI_ADDRESS_IP,in_addr);

                    // Extract the IP address
                    RtlCopyMemory(
                        &pServerEntry->Server.IpAddress,
                        pBuffer,
                        sizeof(ULONG));

                    break;
                }
            }
        } else {
           RxDbgTrace(0, Dbg, ("Remote Address Query returned %lx\n",Status));
        }

        if (NT_SUCCESS(Status)) {
            Status = VctCompleteInitialization(
                         pServerEntry,                            // The server entry
                         pVcCompletionContext->pTransport,        // the transport/address information
                         pVcCompletionContext->pServerTransport); // the server transport instance
        }

        if (NT_SUCCESS(Status)) {
            pSmbCeContext->pTransport =
                (PSMBCE_SERVER_TRANSPORT)pVcCompletionContext->pServerTransport;
            pVcCompletionContext->pServerTransport = NULL;
            pVcCompletionContext->pTransport = NULL;
        }

        pSmbCeContext->Status = Status;
    } else {
        SmbLogError(Status,
                    LOG,
                    VctpCreateConnectionCallback,
                    LOGULONG(Status)
                    LOGPTR(pServerEntry)
                    LOGUSTR(pServerEntry->Name));
    }

    if (!NT_SUCCESS(Status)) {
        RxCeTearDownVC(pVcCompletionContext->pVc);
        RxCeTearDownConnection(pVcCompletionContext->pConnection);
        SmbCeDereferenceTransport(pVcCompletionContext->pTransport);
        pVcCompletionContext->pTransport = NULL;
    }

    if (pVcCompletionContext->pTransportArray != NULL) {
        SmbCeDereferenceTransportArray(pVcCompletionContext->pTransportArray);
    }

    if (pVcCompletionContext->pTransportAddress != NULL) {
        RxFreePool(pVcCompletionContext->pTransportAddress);
    }

    if (pVcCompletionContext->pConnectionInformation != NULL) {
        RxFreePool(pVcCompletionContext->pConnectionInformation);
    }

    ASSERT(pVcCompletionContext->pTransport == NULL);

    if (pVcCompletionContext->pServerTransport != NULL) {
        SmbMmFreeServerTransport(
            (PSMBCE_SERVER_TRANSPORT)pVcCompletionContext->pServerTransport);
    }

    RxFreePool(pVcCompletionContext);

    pSmbCeContext->State  = SmbCeServerVcTransportConstructionEnd;

    SmbCeConstructServerTransport(pSmbCeContext);
    return STATUS_SUCCESS;
}

NTSTATUS
VctInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pContext - the transport construction context

Return Value:

    STATUS_PENDING - asynchronous construction has been initiated

Notes:

    Currently, only connection oriented transports are handled. The current TDI
    spec expects handles to be passed in as part of the connect request. This
    implies that connect/reconnect/disconnect requests need to be issued from the
    process which created the connection. In the case of the SMB mini rdr there
    is no FSP associated with it ( threads are borrowed/commandeered ) from the
    system process to do all the work. This is the reason for special casing VC
    initialization into a separate routine. The server transport initialization
    routine handles the other transport initialization and also provides the
    context for VC initialization.

--*/
{
    NTSTATUS Status = STATUS_PENDING;

    PSMBCE_TRANSPORT_ARRAY pTransportArray;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pTransportArray   = SmbCeReferenceTransportArray();


    if (pTransportArray == NULL) {
        Status = STATUS_NETWORK_UNREACHABLE;
    } else {
        PSMBCEDB_SERVER_ENTRY  pServerEntry;
        UNICODE_STRING         ServerName;

        PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT pCompletionContext;
        PRXCE_CONNECTION_INFORMATION InitialConnectionInformation = NULL;

        ULONG ServerIpAddress;

        pServerEntry = pContext->pServerEntry;

        ServerName.Buffer        = pServerEntry->Name.Buffer + 1;
        ServerName.Length        = pServerEntry->Name.Length - sizeof(WCHAR);
        ServerName.MaximumLength = pServerEntry->Name.MaximumLength - sizeof(WCHAR);

        pServerEntry->Server.IpAddress = 0;

        pCompletionContext = (PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT)
                             RxAllocatePoolWithTag(
                                 NonPagedPool,
                                 sizeof(SMBCE_VC_CONNECTION_COMPLETION_CONTEXT),
                                 MRXSMB_VC_POOLTAG);

        if (pCompletionContext != NULL) {
            RtlZeroMemory(pCompletionContext,sizeof(SMBCE_VC_CONNECTION_COMPLETION_CONTEXT));
            
            pCompletionContext->pContext = pContext;

            pCompletionContext->TransportAddressLength = VctComputeTransportAddressSize(
                                                             &ServerName);

            pCompletionContext->pTransportAddress = (PTRANSPORT_ADDRESS)
                                                    RxAllocatePoolWithTag(
                                                        NonPagedPool,
                                                        pCompletionContext->TransportAddressLength,
                                                        MRXSMB_VC_POOLTAG);

            if (pCompletionContext->pTransportAddress == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RtlZeroMemory(pCompletionContext->pTransportAddress,
                              pCompletionContext->TransportAddressLength);

                Status = VctBuildTransportAddress(
                             pCompletionContext->pTransportAddress,
                             pCompletionContext->TransportAddressLength,
                             &ServerName,
                             &ServerIpAddress);
            }

            if (Status == STATUS_SUCCESS) {
                pCompletionContext->pServerTransport = (PSMBCE_SERVER_VC_TRANSPORT)
                                                       SmbMmAllocateServerTransport(
                                                           SMBCE_STT_VC);

                if (pCompletionContext->pServerTransport == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    pCompletionContext->pConnection =
                        &(pCompletionContext->pServerTransport->RxCeConnection);
                    pCompletionContext->pVc =
                        &(pCompletionContext->pServerTransport->Vcs[0].RxCeVc);
                }
            }

            if (Status == STATUS_SUCCESS) {
                InitialConnectionInformation = RxAllocatePoolWithTag(
                                                   NonPagedPool,
                                                   sizeof(RXCE_CONNECTION_INFORMATION),
                                                   MRXSMB_VC_POOLTAG);

                if (InitialConnectionInformation == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    InitialConnectionInformation->UserDataLength = 0;
                    InitialConnectionInformation->OptionsLength  = 0;
                    InitialConnectionInformation->RemoteAddressLength = pCompletionContext->TransportAddressLength;
                    InitialConnectionInformation->RemoteAddress = pCompletionContext->pTransportAddress;
                }
            }

            if (Status == STATUS_SUCCESS) {
                PSMBCE_TRANSPORT        pTransport;
                
                pCompletionContext->pTransport = NULL;
                pCompletionContext->pTransportArray   = pTransportArray;
                pCompletionContext->pConnectionInformation = InitialConnectionInformation;
                //DbgPrint("Remote address %lx \n",pCompletionContext->pConnectionInformation->RemoteAddress);

                if (pServerEntry->PreferredTransport != NULL) {
                    pTransport = pServerEntry->PreferredTransport;

                    Status = RxCeBuildConnection(
                                 &pTransport->RxCeAddress,
                                 InitialConnectionInformation,
                                 &MRxSmbVctConnectionEventHandler,
                                 pServerEntry,
                                 pCompletionContext->pConnection,
                                 pCompletionContext->pVc);

                    if (Status == STATUS_SUCCESS) {
                        pCompletionContext->pTransport = pTransport;
                        SmbCeReferenceTransport(pTransport);
                    }

                    ASSERT(Status != STATUS_PENDING);

                    if (Status != STATUS_SUCCESS) {
                        SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
                        pServerEntry->PreferredTransport = NULL;
                    }

                    pCompletionContext->Status = Status;

                    VctpCreateConnectionCallback(
                        (PRXCE_CONNECTION_COMPLETION_CONTEXT)pCompletionContext);

                    Status = STATUS_PENDING;
                } else {

                    Status = RxCeBuildConnectionOverMultipleTransports(
                                 MRxSmbDeviceObject,
                                 MRxSmbObeyBindingOrder ?
                                    RxCeSelectBestSuccessfulTransport :
                                    RxCeSelectFirstSuccessfulTransport,

                                 pCompletionContext->pTransportArray->Count,
                                 pCompletionContext->pTransportArray->LocalAddresses,
                                 &ServerName,
                                 InitialConnectionInformation,
                                 &MRxSmbVctConnectionEventHandler,
                                 pServerEntry,
                                 VctpCreateConnectionCallback,
                                 (PRXCE_CONNECTION_COMPLETION_CONTEXT)pCompletionContext);

//                    ASSERT(Status == STATUS_PENDING);
                }
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Status != STATUS_PENDING) {
            if (pCompletionContext != NULL) {
                if (pCompletionContext->pTransportAddress != NULL) {
                    RxFreePool(pCompletionContext->pTransportAddress);
                }

                if (pCompletionContext->pServerTransport != NULL) {
                    RxFreePool(pCompletionContext->pServerTransport);
                }
                
                RxFreePool(pCompletionContext);
            }

            if (InitialConnectionInformation != NULL) {
                RxFreePool(InitialConnectionInformation);
            }

            SmbCeDereferenceTransportArray(pTransportArray);
        }
    }

    if (Status != STATUS_PENDING) {
        ASSERT(Status != STATUS_SUCCESS);

        pContext->State  = SmbCeServerVcTransportConstructionEnd;
        pContext->Status = Status;

        // Call the construct server transport routine to complete the construction
        SmbCeConstructServerTransport(pContext);

        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
VctTearDownServerTransport(
   PSMBCE_SERVER_TRANSPORT pServerTransport)
{
    NTSTATUS Status;
    PKEVENT pRundownEvent = pServerTransport->pRundownEvent;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    Status = VctUninitialize(pServerTransport);

    if (pRundownEvent != NULL) {
        KeSetEvent(pRundownEvent, 0, FALSE );
    }

    return Status;
}

NTSTATUS
VctInitiateDisconnect(
    PSMBCE_SERVER_TRANSPORT pServerTransport)
{
    ULONG                      VcIndex;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerTransport;

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        NTSTATUS Status;

        pVc = &pVcTransport->Vcs[VcIndex];

        Status = RxCeInitiateVCDisconnect(&pVc->RxCeVc);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("VctInitiateDisconnect: Disconnected Status %lxd\n",Status));
        }
    }

    return STATUS_SUCCESS;
}

PFILE_OBJECT
SmbCepReferenceEndpointFileObject(
    PSMBCE_SERVER_TRANSPORT pTransport)
/*++

Routine Description:

    This routine returns the connection file object associated with
    a transport

Arguments:

    pTransport - the transport instance

Notes:

    This routine currently returns this for VC transports. When we implement
    other transports a suitable abstraction needs to be implemented

--*/
{
    PFILE_OBJECT         pEndpointFileObject =  NULL;
    PSMBCE_OBJECT_HEADER pHeader = (PSMBCE_OBJECT_HEADER)pTransport;

    if ((pHeader != NULL) && (pHeader->ObjectType == SMBCE_STT_VC)) {
        PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

        pEndpointFileObject = pVcTransport->Vcs[0].RxCeVc.pEndpointFileObject;

        if (pEndpointFileObject != NULL) {
            ObReferenceObject(pEndpointFileObject);
        }

    }

    return pEndpointFileObject;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\vnrcntxt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbcedb.c

Abstract:

    This module implements all functions related to accessing the SMB connection engine
    database

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

Notes:

    The mapping between MRX_V_NET_ROOT and a mini rdr data structure is a many to
    one relationship, i.e., more than one MRX_V_NET_ROOT instance can be associated with the
    same mini rdr data structure.

--*/

#include "precomp.h"
#pragma hdrstop

#include "exsessup.h"
#include "secext.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeCompleteVNetRootContextInitialization)
#pragma alloc_text(PAGE, SmbCeDestroyAssociatedVNetRootContext)
#pragma alloc_text(PAGE, SmbCeTearDownVNetRootContext)
#endif

RXDT_Extern(SMBCEDB);
#define Dbg        (DEBUG_TRACE_SMBCEDB)

extern BOOLEAN Win9xSessionRestriction;

PSMBCE_V_NET_ROOT_CONTEXT
SmbCeFindVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXTS pVNetRootContexts,
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    PSMBCEDB_SESSION_ENTRY     pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY    pNetRootEntry,
    BOOLEAN                    fCscAgentOpen)
/*++

Routine Description:

    This routine finds a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:
    pVNetRootContexts - list of VNetRootContexts for searching
    
    PServerEntry - the ServerEntry should be the same as the one on found VNetRootContext
    
    PSessionEntry - the SessionEntry should be the same as the one on found VNetRootContext
    
    pNetRootEntry - the NetRootEntry should be the same as the one on found VNetRootContext
  
    fCscAgentOpen - this V_NET_ROOT_CONTEXT instance is being created for the CSC
                    agent

Return Value:

    VNetRootContext if found

Notes:

--*/
{
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;

    pVNetRootContext = SmbCeGetFirstVNetRootContext(
                            pVNetRootContexts);

    while (pVNetRootContext != NULL) {
        if ((pVNetRootContext->pServerEntry  == pServerEntry)  &&
            (pVNetRootContext->pSessionEntry == pSessionEntry) &&
            (pVNetRootContext->pNetRootEntry == pNetRootEntry) &&
            (BooleanFlagOn(pVNetRootContext->Flags,
                           SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE) == fCscAgentOpen)) {

            SmbCeRemoveVNetRootContext(
                pVNetRootContexts,
                pVNetRootContext);

            SmbCeAddVNetRootContext(
                &pServerEntry->VNetRootContexts,
                pVNetRootContext);

            InterlockedDecrement(&pServerEntry->Server.NumberOfVNetRootContextsForScavenging);
            SmbCeLog(("CachedVNRContext(S) %lx\n",pVNetRootContext));
            SmbLog(LOG,
                   SmbCeFindVNetRootContext,
                   LOGPTR(pVNetRootContext));
            break;
        } else {
            pVNetRootContext = SmbCeGetNextVNetRootContext(
                                   pVNetRootContexts,
                                   pVNetRootContext);
        }
    }

    return pVNetRootContext;
}

NTSTATUS
SmbCeFindOrConstructVNetRootContext(
    PMRX_V_NET_ROOT         pVNetRoot,
    BOOLEAN                 fDeferNetworkInitialization,
    BOOLEAN                 fCscAgentOpen)
/*++

Routine Description:

    This routine finds or constructs a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRoot - the MRX_V_NET_ROOT instance

    fDeferNetworkInitialization - a directive to delay network initialization for new
                                  instances.

    fCscAgentOpen - this V_NET_ROOT_CONTEXT instance is being created for the CSC
                    agent

Return Value:

    STATUS_SUCCESS if the MRX_V_NET_ROOT instance was successfully initialized

Notes:

    The algorithm that has been implemented tries to delay the construction of a
    new instance as much as possible. It does this be either reusing a context
    that has already been active or a context instance that has been marked for
    scavenging but has not been scavenged.

--*/
{
    NTSTATUS Status;

    PMRX_SRV_CALL pSrvCall;
    PMRX_NET_ROOT pNetRoot;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;

    PSMBCEDB_SERVER_ENTRY   pServerEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry = NULL;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;

    BOOLEAN  fInitializeNetRoot;
    BOOLEAN  fDereferenceSessionEntry = FALSE;
    BOOLEAN  fDereferenceNetRootEntry = FALSE;

    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;

    SmbCeAcquireResource();

    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    // The V_NET_ROOT is associated with a NET_ROOT. The two cases of interest are as
    // follows
    // 1) the V_NET_ROOT and the associated NET_ROOT are being newly created.
    // 2) a new V_NET_ROOT associated with an existing NET_ROOT is being created.
    //
    // These two cases can be distinguished by checking if the context associated with
    // NET_ROOT is NULL. Since the construction of NET_ROOT's/V_NET_ROOT's are serialized
    // by the wrapper this is a safe check.
    // ( The wrapper cannot have more then one thread tryingto initialize the same
    // NET_ROOT).

    pNetRootEntry = (PSMBCEDB_NET_ROOT_ENTRY)pNetRoot->Context;
    fInitializeNetRoot = (pNetRootEntry == NULL);

    pVNetRoot->Context = NULL;

    // Find or construct the session entry that will be associated with the context. The
    // one error that deserves special consideration is STATUS_NETWORK_CREDENTIAL_CONFLICT.
    // This error signifies that the credentials presented with the MRX_V_NET_ROOT instance
    // conflicted with an existing session. This conflict could be either becuase there
    // exists an active session or because a previously active session is awaiting
    // scavenging. In the former case the error needs to be propagated back but in the
    // later case the contexts must be selectively scavenged.
    //
    // The scavenging should be limited only to those contexts to the appropriate server.

    Status = SmbCeFindOrConstructSessionEntry(
                 pVNetRoot,
                 &pSessionEntry);


    if (Status == STATUS_NETWORK_CREDENTIAL_CONFLICT) {
        NTSTATUS ScavengingStatus;

        SmbCeReleaseResource();

        ScavengingStatus = SmbCeScavengeRelatedContexts(pServerEntry);

        if (ScavengingStatus == STATUS_SUCCESS) {
            SmbCeAcquireResource();

            Status = SmbCeFindOrConstructSessionEntry(
                         pVNetRoot,
                         &pSessionEntry);
        } else {
            return Status;
        }
    }

    fDereferenceSessionEntry = (Status == STATUS_SUCCESS);

    if (Status == STATUS_SUCCESS) {
        if (fInitializeNetRoot) {
            pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;

            // Initialize the device type and state for a new MRX_NET_ROOT instance
            switch (pNetRoot->Type) {
            case NET_ROOT_DISK:
               {
                   pNetRoot->DeviceType = RxDeviceType(DISK);

                   RxInitializeNetRootThrottlingParameters(
                       &pNetRoot->DiskParameters.LockThrottlingParameters,
                       MRxSmbConfiguration.LockIncrement,
                       MRxSmbConfiguration.MaximumLock
                       );
               }
               break;

            case NET_ROOT_PIPE:
               {
                   pNetRoot->DeviceType = RxDeviceType(NAMED_PIPE);

                   RxInitializeNetRootThrottlingParameters(
                       &pNetRoot->NamedPipeParameters.PipeReadThrottlingParameters,
                       MRxSmbConfiguration.PipeIncrement,
                       MRxSmbConfiguration.PipeMaximum
                       );
               }
               break;
            case NET_ROOT_COMM:
               pNetRoot->DeviceType = RxDeviceType(SERIAL_PORT);
               break;
            case NET_ROOT_PRINT:
               pNetRoot->DeviceType = RxDeviceType(PRINTER);
               break;
            case NET_ROOT_MAILSLOT:
               pNetRoot->DeviceType = RxDeviceType(MAILSLOT);
               break;
            case NET_ROOT_WILD:
               break;
            default:
               ASSERT(!"Valid Net Root Type");
            }

            Status = SmbCeFindOrConstructNetRootEntry(
                         pNetRoot,
                         &pNetRootEntry);

            RxDbgTrace( 0, Dbg, ("SmbCeOpenNetRoot %lx\n",Status));
        } else {
            SmbCeLog(("ReuseNREntry %lx\n",pNetRootEntry));
            SmbLog(LOG,
                   SmbCeFindOrConstructVNetRootContext_1,
                   LOGPTR(pNetRootEntry));
            SmbCeReferenceNetRootEntry(pNetRootEntry);
        }

        fDereferenceNetRootEntry = (Status == STATUS_SUCCESS);
    }

    if (Status == STATUS_SUCCESS) {
        pVNetRootContext = SmbCeFindVNetRootContext(
                               &pServerEntry->VNetRootContexts,
                               pServerEntry,
                               pSessionEntry,
                               pNetRootEntry,
                               fCscAgentOpen);

        if (pVNetRootContext == NULL) {
            pVNetRootContext = SmbCeFindVNetRootContext(
                                   &MRxSmbScavengerServiceContext.VNetRootContexts,
                                   pServerEntry,
                                   pSessionEntry,
                                   pNetRootEntry,
                                   fCscAgentOpen);
        }

        if (pVNetRootContext != NULL) {
            // An existing instance can be reused. No more work to be done
            SmbCeReferenceVNetRootContext(pVNetRootContext);
        } else {
            // None of the existing instances can be reused. A new instance needs to be
            // constructed.

            pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)
                               RxAllocatePoolWithTag(
                                    NonPagedPool,
                                    sizeof(SMBCE_V_NET_ROOT_CONTEXT),
                                    MRXSMB_VNETROOT_POOLTAG);

            if (pVNetRootContext != NULL) {
                // Initialize the new instance

                RtlZeroMemory(
                    pVNetRootContext,
                    sizeof(SMBCE_V_NET_ROOT_CONTEXT));

                // Transfer the references made during the construction of the session and
                // the net root entries to the new context. Disable the dereferencing at
                // the end of this routine.

                fDereferenceSessionEntry = FALSE;
                fDereferenceNetRootEntry = FALSE;

                SmbCeReferenceServerEntry(pServerEntry);

                pVNetRootContext->Header.NodeType = SMB_CONNECTION_ENGINE_NTC(
                                                        SMBCEDB_OT_VNETROOTCONTEXT);

                if (pNetRootEntry->NetRoot.NetRootType == NET_ROOT_MAILSLOT) {
                    pVNetRootContext->Header.State = SMBCEDB_ACTIVE;
                } else {
                    pVNetRootContext->Header.State = SMBCEDB_INVALID;
                }

                pVNetRootContext->Flags = 0;

                if (fCscAgentOpen) {
                    pVNetRootContext->Flags |= SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE;

                }

                InitializeListHead(&pVNetRootContext->Requests.ListHead);

                pVNetRootContext->pServerEntry  = pServerEntry;
                pVNetRootContext->pSessionEntry = pSessionEntry;
                pVNetRootContext->pNetRootEntry = pNetRootEntry;

                SmbCeReferenceVNetRootContext(pVNetRootContext);

                // Add it to the list of active contexts
                SmbCeAddVNetRootContext(
                    &pServerEntry->VNetRootContexts,
                    pVNetRootContext);

                SmbCeLog(("NewVNetRootContext %lx\n",pVNetRootContext));
                SmbLog(LOG,
                       SmbCeFindOrConstructVNetRootContext_2,
                       LOGPTR(pVNetRootContext));
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (Status == STATUS_SUCCESS) {
        // If everything was successful set up the MRX_V_NET_ROOT and MRX_NET_ROOT
        // instances
        pVNetRoot->Context = pVNetRootContext;
        pVNetRootContext->pRdbssVNetRoot = pVNetRoot;

        if (fInitializeNetRoot) {
            ASSERT(pNetRootEntry->pRdbssNetRoot == NULL);

            InterlockedExchangePointer(
                &pNetRootEntry->pRdbssNetRoot,
                pNetRoot);

            SmbCeUpdateNetRoot(pNetRootEntry,pNetRoot);

            SmbCeReferenceNetRootEntry(pNetRootEntry);
            pNetRoot->Context = pNetRootEntry;
        } else {
            if (FlagOn(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED)) {
                ClearFlag(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED);
                SmbCeReferenceNetRootEntry(pNetRootEntry);
            }
        }

        InterlockedIncrement(&pSessionEntry->Session.NumberOfActiveVNetRoot);
    } else {
        pVNetRoot->Context = NULL;
        if (fInitializeNetRoot) {
            pNetRoot->Context  = NULL;
        }
    }

    SmbCeReleaseResource();

    if (fDereferenceSessionEntry) {
        SmbCeDereferenceSessionEntry(pSessionEntry);
    }

    if (fDereferenceNetRootEntry) {
        SmbCeDereferenceNetRootEntry(pNetRootEntry);
    }

    if (!fDeferNetworkInitialization &&
        (Status == STATUS_SUCCESS)) {

        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER) {
        ASSERT((Status != STATUS_SUCCESS) || (pVNetRoot->Context != NULL));
    }

    return Status;
}

VOID
SmbCeCompleteVNetRootContextInitialization(
    PVOID  pContext)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pContext  - the SMBCE_V_NET_ROOT_CONTEXT instance


Notes:

    PRE_CONDITION: The VNetRootContext must have been referenced to ensure that
    even it has been finalized it will not be deleted.

--*/
{
    NTSTATUS Status;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    PSMBCEDB_REQUEST_ENTRY    pRequestEntry;
    SMBCEDB_REQUESTS          Requests;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("Net Root Entry Finalization\n"));

    pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)pContext;

    ASSERT(pVNetRootContext->Header.ObjectType == SMBCEDB_OT_VNETROOTCONTEXT);

    SmbCeAcquireResource();
    
    pVNetRootContext->pExchange = NULL;

    SmbCeTransferRequests(&Requests,&pVNetRootContext->Requests);

    if (pVNetRootContext->Header.State == SMBCEDB_ACTIVE) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INVALID_CONNECTION;
        SmbCeUpdateVNetRootContextState(
            pVNetRootContext,
            SMBCEDB_INVALID);
    }

    SmbCeReleaseResource();

    // Iterate over the list of pending requests and resume all of them
    SmbCeResumeOutstandingRequests(&Requests,Status);

    SmbCeDereferenceVNetRootContext(pVNetRootContext);
}

VOID
SmbCepDereferenceVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
/*++

Routine Description:

    This routine dereferences a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRootContext  - the SMBCE_V_NET_ROOT_CONTEXT instance

Notes:

    There are two intersting points to note. A mini redirector can avoid potential
    network traffic by delaying the scavenging of the SMBCE_V_NET_ROOT_CONTEXT
    instance since it contains all the relevant network setup to satisfy requests.

    This is a policy that is implemented in the mini redirector and is different from
    the wrapper policies.

    Once the decision to delay scavenging has been made, there are two options. The
    successful and unsuccessful instances can be delayed or only the successful
    instances. The current algorithm is to delay the scavenging of the successful
    SMBCE_V_NET_ROOT_CONTEXT instances only.

    Also there are three components to a VNetRootContext that can be scavenged
    independently. If the server exists and a session setup to the server fails
    because of wrong credentials there is no point in throwing away the server
    entry eagerly. This routine selectively gathers the failed fields for eager
    scavenging and retains the VNetRootContext skeleton alongwith the other
    structures that can be deferred.

--*/
{
    if (pVNetRootContext != NULL) {
        LONG FinalRefCount;

        FinalRefCount = InterlockedDecrement(
                            &pVNetRootContext->Header.SwizzleCount);

        if (FinalRefCount == 0) {
            LARGE_INTEGER CurrentTime;
            BOOLEAN       TearDownVNetRootContext = FALSE;

            PSMBCE_SERVER           pServer = &pVNetRootContext->pServerEntry->Server;
            PSMBCE_SESSION          pSession = &pVNetRootContext->pSessionEntry->Session;

            SmbCeAcquireResource();

            if (pVNetRootContext->Header.SwizzleCount == 0) {
                // Remove the instance from the active list of contexts to the server.
                SmbCeRemoveVNetRootContext(
                    &pVNetRootContext->pSessionEntry->pServerEntry->VNetRootContexts,
                    pVNetRootContext);

                // if it was a successful instance mark it for scavenging, otherwise
                // tear it down immediately

                if ((pVNetRootContext->pSessionEntry != NULL) &&
                    (pVNetRootContext->pSessionEntry->Header.State != SMBCEDB_ACTIVE ||
                     pSession->pUserName != NULL ||
                     pSession->pPassword != NULL ||
                     pSession->pUserDomainName != NULL)) {
                    TearDownVNetRootContext = TRUE;
                }

                if ((pVNetRootContext->pNetRootEntry != NULL) &&
                    (pVNetRootContext->pNetRootEntry->Header.State != SMBCEDB_ACTIVE ||
                     TearDownVNetRootContext)) {
                    TearDownVNetRootContext = TRUE;
                }

                if (Win9xSessionRestriction &&
                    (pVNetRootContext->pServerEntry != NULL) &&
                    FlagOn(pVNetRootContext->pServerEntry->Server.DialectFlags,DF_W95)) {
                    TearDownVNetRootContext = TRUE;
                }

                InterlockedIncrement(&pServer->NumberOfVNetRootContextsForScavenging);

                if (!TearDownVNetRootContext &&
                    (pVNetRootContext->pNetRootEntry != NULL) &&
                    (pVNetRootContext->pSessionEntry != NULL) &&
                    pServer->NumberOfVNetRootContextsForScavenging < MaximumNumberOfVNetRootContextsForScavenging) {

                    ClearFlag(pVNetRootContext->Flags, SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE);

                    KeQueryTickCount( &CurrentTime );

                    pVNetRootContext->ExpireTime.QuadPart = CurrentTime.QuadPart +
                        (LONGLONG) ((MRXSMB_V_NETROOT_CONTEXT_SCAVENGER_INTERVAL * 10 * 1000 * 1000) / KeQueryTimeIncrement());

                    SmbCeAddVNetRootContext(
                        &MRxSmbScavengerServiceContext.VNetRootContexts,
                        pVNetRootContext);

                    MRxSmbActivateRecurrentService(
                        (PRECURRENT_SERVICE_CONTEXT)&MRxSmbScavengerServiceContext);

                    SmbCeLog(("ScavngVNetRootCntxt %lx\n",pVNetRootContext));
                    SmbLog(LOG,
                           SmbCepDereferenceVNetRootContext,
                           LOGPTR(pVNetRootContext));
                } else {
                    TearDownVNetRootContext = TRUE;
                }
            }

            SmbCeReleaseResource();

            if (TearDownVNetRootContext) {
                pVNetRootContext->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                SmbCeTearDownVNetRootContext(pVNetRootContext);
            }
        }
    }
}

NTSTATUS
SmbCeDestroyAssociatedVNetRootContext(
    PMRX_V_NET_ROOT pVNetRoot)
/*++

Routine Description:

    This routine derferences a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRootContext - the SMBCE_V_NET_ROOT_CONTEXT instance to be dereferenced

--*/
{
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    PAGED_CODE();

    pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)pVNetRoot->Context;

    if (pVNetRootContext != NULL) {
        pVNetRootContext->pRdbssVNetRoot = NULL;

        SmbCeDecrementNumberOfActiveVNetRootOnSession(pVNetRootContext);
        SmbCeDereferenceVNetRootContext(pVNetRootContext);
    }

    pVNetRoot->Context = NULL;
    
    return STATUS_SUCCESS;
}

VOID
SmbCeTearDownVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
/*++

Routine Description:

    This routine tears down a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRootContext - the SMBCE_V_NET_ROOT_CONTEXT instance to be torn down

--*/
{
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PAGED_CODE();

    SmbCeLog(("TearVNetRootContext %lx\n",pVNetRootContext));
    SmbLog(LOG,
           SmbCeTearDownVNetRootContext,
           LOGPTR(pVNetRootContext));

    pNetRootEntry = pVNetRootContext->pNetRootEntry;

    if ((pNetRootEntry != NULL) &&
        BooleanFlagOn(pVNetRootContext->Flags,SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID) &&
        (SmbCeGetServerType(pVNetRootContext->pServerEntry) == SMBCEDB_FILE_SERVER)) {

        SmbCeDisconnect(pVNetRootContext);
    }

    if (pNetRootEntry != NULL) {
        pVNetRootContext->pNetRootEntry = NULL;
        SmbCeDereferenceNetRootEntry(pNetRootEntry);
    }

    if (pVNetRootContext->pSessionEntry != NULL) {
        SmbCeDereferenceSessionEntry(pVNetRootContext->pSessionEntry);
    }

    InterlockedDecrement(&pVNetRootContext->pServerEntry->Server.NumberOfVNetRootContextsForScavenging);

    SmbCeDereferenceServerEntry(pVNetRootContext->pServerEntry);

    RxFreePool(pVNetRootContext);
}

NTSTATUS
SmbCeScavenger(
    PVOID pContext)
/*++

Routine Description:

    This routine scavenges SMBCE_V_NET_ROOT_CONTEXT instances

Arguments:

    pContext - the scavenger service context

Notes:

    Since the contexts for scavenging are threaded together in an entry that
    is managed in a FIFO fashion, if the first entry fails the time interval
    test ( expiry time has not elapsed ) all the other entries in the list
    are guaranteed to fail the test. This is an important property that eases
    the implementation of scavenging.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext;
    LARGE_INTEGER             CurrentTime;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    BOOLEAN                   fTerminateScavenging = FALSE;

    pScavengerServiceContext = (PMRXSMB_SCAVENGER_SERVICE_CONTEXT)pContext;

    do {

        SmbCeAcquireResource();

        KeQueryTickCount( &CurrentTime );

        pVNetRootContext = SmbCeGetFirstVNetRootContext(
                               &pScavengerServiceContext->VNetRootContexts);

        fTerminateScavenging = (pVNetRootContext == NULL);

        if (!fTerminateScavenging) {
            if ((CurrentTime.QuadPart >= pVNetRootContext->ExpireTime.QuadPart) ||
                (pScavengerServiceContext->RecurrentServiceContext.State == RECURRENT_SERVICE_SHUTDOWN)) {
                SmbCeRemoveVNetRootContext(
                    &pScavengerServiceContext->VNetRootContexts,
                    pVNetRootContext);
            } else {
                fTerminateScavenging = TRUE;
            }
        }

        SmbCeReleaseResource();

        if (!fTerminateScavenging &&
            (pVNetRootContext != NULL)) {
            SmbCeTearDownVNetRootContext(pVNetRootContext);
        }
    } while (!fTerminateScavenging);

    return Status;
}

NTSTATUS
SmbCeScavengeRelatedContexts(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine scavenges SMBCE_V_NET_ROOT_CONTEXT instances for a given
    server entry

Arguments:

    pServerEntry - the server entry

Notes:

--*/
{
    NTSTATUS Status;
    SMBCE_V_NET_ROOT_CONTEXTS VNetRootContexts;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    InitializeListHead(&VNetRootContexts.ListHead);

    SmbCeAcquireResource();

    pVNetRootContext = SmbCeGetFirstVNetRootContext(
                           &MRxSmbScavengerServiceContext.VNetRootContexts);
    while (pVNetRootContext != NULL) {
        PSMBCE_V_NET_ROOT_CONTEXT pNextVNetRootContext;


        pNextVNetRootContext = SmbCeGetNextVNetRootContext(
                                   &MRxSmbScavengerServiceContext.VNetRootContexts,
                                   pVNetRootContext);

        if (pVNetRootContext->pServerEntry == pServerEntry) {
            SmbCeRemoveVNetRootContext(
                &MRxScavengerServiceContext.VNetRootContexts,
                pVNetRootContext);

            SmbCeAddVNetRootContext(
                &VNetRootContexts,
                pVNetRootContext);
        }

        pVNetRootContext = pNextVNetRootContext;
    }

    SmbCeReleaseResource();

    pVNetRootContext = SmbCeGetFirstVNetRootContext(
                           &VNetRootContexts);

    if (pVNetRootContext != NULL) {
        do {
            SmbCeRemoveVNetRootContext(
                &VNetRootContexts,
                pVNetRootContext);

            SmbCeTearDownVNetRootContext(pVNetRootContext);

            pVNetRootContext = SmbCeGetFirstVNetRootContext(
                                   &VNetRootContexts);
        } while ( pVNetRootContext != NULL );

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    SmbCeLog(("Scavctxts Srv %lx Status %lx\n",pServerEntry,Status));
    SmbLog(LOG,
           SmbCeScavengeRelatedContexts,
           LOGULONG(Status)
           LOGPTR(pServerEntry)
           LOGUSTR(pServerEntry->Name));

    return Status;
}

VOID
SmbCeDecrementNumberOfActiveVNetRootOnSession(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext
    )
{
    ULONG   NumberOfVNetRoot;
    BOOLEAN fLogOffRequired = FALSE;

    PSMBCEDB_SERVER_ENTRY  pServerEntry = NULL;
    PSMBCEDB_SESSION_ENTRY pSessionEntry = NULL;

    SmbCeAcquireResource();

    NumberOfVNetRoot = InterlockedDecrement(&pVNetRootContext->pSessionEntry->Session.NumberOfActiveVNetRoot);

    if (NumberOfVNetRoot == 0) {
        pSessionEntry = pVNetRootContext->pSessionEntry;
        pServerEntry  = pVNetRootContext->pServerEntry;

        if (!FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
            SmbCeRemoveSessionEntry(pServerEntry,pSessionEntry);
            SmbCeRemoveDefaultSessionEntry(pSessionEntry);
        }

        if ((pSessionEntry->Session.UserId != (SMB_USER_ID)(SMBCE_SHARE_LEVEL_SERVER_USERID)) &&
            (pSessionEntry->Session.UserId != 0) &&
            (pSessionEntry->Header.State == SMBCEDB_ACTIVE) &&
            !FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
            SmbCeReferenceServerEntry(pServerEntry);
            SmbCeReferenceSessionEntry(pSessionEntry);
            fLogOffRequired = TRUE;
        }

        // all the consequent requests on this session should fail
        pSessionEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
        pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_LOGGED_OFF;
        pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION;
    }

    SmbCeReleaseResource();

    if (fLogOffRequired) {
        SmbCeLogOff(pServerEntry,pSessionEntry);
        SmbCeDereferenceServerEntry(pServerEntry);
    }
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the mini redirector call down routines pertaining
    to write of file system objects.

Author:

    Joe Linn      [JoeLinn]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbWrite)
#pragma alloc_text(PAGE, MRxSmbWriteMailSlot)
#pragma alloc_text(PAGE, MRxSmbBuildWriteRequest)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Write)
#pragma alloc_text(PAGE, MRxSmbFinishWrite)
#endif

#define MAX(a,b) ((a) > (b) ? (a) : (b))

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#ifndef FORCE_NO_NTWRITEANDX
#define MRxSmbForceNoNtWriteAndX FALSE
#else
BOOLEAN MRxSmbForceNoNtWriteAndX = TRUE;
#endif

#define WRITE_COPY_THRESHOLD 64
#define FORCECOPYMODE FALSE

#ifdef SETFORCECOPYMODE
#undef  FORCECOPYMODE
#define FORCECOPYMODE MRxSmbForceCopyMode
ULONG MRxSmbForceCopyMode = TRUE;
#endif

extern ULONG MaxNumOfExchangesForPipelineReadWrite;

NTSTATUS
SmbPseExchangeStart_Write(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbFindNextSectionForReadWrite(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    PULONG NumOfOutstandingExchanges
    );

ULONG MRxSmbWriteSendOptions = 0;

NTSTATUS
MRxSmbDereferenceGlobalReadWrite (
    PSMB_PSE_OE_READWRITE GlobalReadWrite
    )
{
    ULONG RefCount;

    RefCount = InterlockedDecrement(&GlobalReadWrite->RefCount);
    SmbCeLog(("Deref GRW %x %d\n",GlobalReadWrite,RefCount));

    if (RefCount == 0) {
        RxFreePool(GlobalReadWrite);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
MRxSmbWrite (
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine opens a file across the network.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;
    SMBFCB_HOLDING_STATE SmbFcbHoldingState = SmbFcb_NotHeld;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    ULONG NumberOfSections;
    ULONG NumOfOutstandingExchanges = 0;
    ULONG MaximumBufferSizeThisIteration;
    PSMB_PSE_OE_READWRITE GlobalReadWrite = NULL;
    ULONG GlobalReadWriteAllocationSize;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;
    BOOLEAN EnablePipelineWrite = TRUE;
    BOOLEAN MsgModePipeOperation = FALSE;
    BOOLEAN ExchangePending = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbWrite\n", 0 ));

    // Pipe buffer cannot be bigger than MAX_PIPE_BUFFER_SIZE, otherwise the
    // server has problems.
    if (RxContext->pFcb->pNetRoot->Type == NET_ROOT_PIPE) {
        if (RxContext->CurrentIrpSp->Parameters.Write.Length > MAX_PIPE_BUFFER_SIZE) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
    }

    if ( NodeType(capFcb) == RDBSS_NTC_MAILSLOT ) {
        // This is an attempt to write on a mailslot file which is handled
        // differently.

        Status = MRxSmbWriteMailSlot(RxContext);

        RxDbgTrace(-1, Dbg, ("MRxSmbWrite: Mailslot write returned %lx\n",Status));
        return Status;
    }

    // For CSC we go ahead and mark an FCB as having been written to.
    // When CSC is turned ON, if this flag is set before we obtained
    // shadow handles, then the data corresponding to the file is
    // deemed stale and is truncated

    if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE) {
        PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
        smbFcb->MFlags |= SMB_FCB_FLAG_WRITES_PERFORMED;
    }

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    SrvOpen = capFobx->pSrvOpen;
    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;

    if (smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_II &&
        !BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,
                       LOWIO_READWRITEFLAG_PAGING_IO)) {
        PMRX_SRV_CALL             pSrvCall;

        pSrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;

        RxIndicateChangeOfBufferingStateForSrvOpen(
            pSrvCall,
            SrvOpen,
            MRxSmbMakeSrvOpenKey(pVNetRootContext->TreeId,smbSrvOpen->Fid),
            ULongToPtr(SMB_OPLOCK_LEVEL_NONE));
        SmbCeLog(("Breaking oplock to None in Write SO %lx\n",SrvOpen));
        SmbLog(LOG,
               MRxSmbWrite,
               LOGPTR(SrvOpen));
    }

    IF_NOT_MRXSMB_CSC_ENABLED{
        ASSERT(smbSrvOpen->hfShadow == 0);
    } else {
        if (smbSrvOpen->hfShadow != 0){
            NTSTATUS ShadowReadNtStatus;
            ShadowReadNtStatus = MRxSmbCscWritePrologue(
                                     RxContext,
                                     &SmbFcbHoldingState);

            if (ShadowReadNtStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace(-1, Dbg, ("MRxSmbWrite shadow hit with status=%08lx\n", ShadowReadNtStatus ));
                return(ShadowReadNtStatus);
            } else {
                RxDbgTrace(0, Dbg, ("MRxSmbWrite shadowmiss with status=%08lx\n", ShadowReadNtStatus ));
            }
        }
    }

    if (capFcb->pNetRoot->Type == NET_ROOT_PIPE) {
        EnablePipelineWrite = FALSE;

        if (capFobx->PipeHandleInformation->ReadMode != FILE_PIPE_BYTE_STREAM_MODE) {
            MsgModePipeOperation = TRUE;
        }
    }

    if (!FlagOn(pVNetRootContext->pServerEntry->Server.DialectFlags,DF_LARGE_WRITEX)) {
        EnablePipelineWrite = FALSE;
    }

    MaximumBufferSizeThisIteration = pVNetRootContext->pNetRootEntry->NetRoot.MaximumWriteBufferSize;

    if (MsgModePipeOperation) {
        MaximumBufferSizeThisIteration -= 2;
    }

    NumberOfSections = LowIoContext->ParamsFor.ReadWrite.ByteCount / MaximumBufferSizeThisIteration;

    if ( (LowIoContext->ParamsFor.ReadWrite.ByteCount % MaximumBufferSizeThisIteration) ||
         (LowIoContext->ParamsFor.ReadWrite.ByteCount == 0) ) {
        NumberOfSections ++;
    }

    GlobalReadWriteAllocationSize = sizeof(SMB_PSE_OE_READWRITE) +
                                    NumberOfSections*sizeof(SMB_PSE_OE_READWRITE_STATE);

    GlobalReadWrite = RxAllocatePoolWithTag(
                          NonPagedPool,
                          GlobalReadWriteAllocationSize,
                          MRXSMB_RW_POOLTAG);

    if (GlobalReadWrite == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(GlobalReadWrite,GlobalReadWriteAllocationSize);

    GlobalReadWrite->MaximumBufferSize = MaximumBufferSizeThisIteration;
    GlobalReadWrite->TotalNumOfSections = NumberOfSections;

    KeInitializeEvent(
        &GlobalReadWrite->CompletionEvent,
        SynchronizationEvent,
        FALSE);

    GlobalReadWrite->UserBufferBase = RxLowIoGetBufferAddress( RxContext );
    GlobalReadWrite->ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    GlobalReadWrite->RemainingByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

    if (GlobalReadWrite->ByteOffsetAsLI.QuadPart == -1 ) {
        GlobalReadWrite->WriteToTheEnd = TRUE;
        GlobalReadWrite->ByteOffsetAsLI.QuadPart = smbSrvOpen->FileInfo.Standard.EndOfFile.QuadPart;
    }

    if (LowIoContext->ParamsFor.ReadWrite.Buffer != NULL) {
        GlobalReadWrite->UserBufferBase = RxLowIoGetBufferAddress( RxContext );
    } else {
        GlobalReadWrite->UserBufferBase = (PBYTE)1;   //any nonzero value will do
    }

    if (MRxSmbEnableCompression &&
        (capFcb->Attributes & FILE_ATTRIBUTE_COMPRESSED) &&
        (pVNetRootContext->pServerEntry->Server.Capabilities & COMPRESSED_DATA_CAPABILITY)) {
        GlobalReadWrite->CompressedReadOrWrite = TRUE;
        EnablePipelineWrite = FALSE;
    } else {
        GlobalReadWrite->CompressedReadOrWrite = FALSE;
    }

    GlobalReadWrite->ThisBufferOffset = 0;

    GlobalReadWrite->PartialExchangeMdlInUse = FALSE;
    GlobalReadWrite->PartialDataMdlInUse     = FALSE;
    GlobalReadWrite->pCompressedDataBuffer   = NULL;
    GlobalReadWrite->RefCount = 1;
    GlobalReadWrite->SmbFcbHoldingState = SmbFcbHoldingState;

    do {
        Status = SmbPseCreateOrdinaryExchange(
                               RxContext,
                               capFobx->pSrvOpen->pVNetRoot,
                               SMBPSE_OE_FROM_WRITE,
                               SmbPseExchangeStart_Write,
                               &OrdinaryExchange);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
            break;
        }

        OrdinaryExchange->AsyncResumptionRoutine = SmbPseExchangeStart_Write;
        OrdinaryExchange->GlobalReadWrite = GlobalReadWrite;

        RtlCopyMemory(&OrdinaryExchange->ReadWrite,
                      GlobalReadWrite,
                      sizeof(SMB_PSE_OE_READWRITE));

        if ((capFcb->pNetRoot->Type == NET_ROOT_PIPE) &&
            (capFobx->PipeHandleInformation->ReadMode != FILE_PIPE_BYTE_STREAM_MODE) ) {
            SetFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_MSGMODE_PIPE_OPERATION);
        }

        ExAcquireFastMutex(&MRxSmbReadWriteMutex);

        Status = MRxSmbFindNextSectionForReadWrite(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                   &NumOfOutstandingExchanges);

        ExReleaseFastMutex(&MRxSmbReadWriteMutex);

        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            ULONG RefCount;

            RefCount = InterlockedIncrement(&GlobalReadWrite->RefCount);

            SmbCeLog(("Ref GRW %x %d\n",GlobalReadWrite,RefCount));
            SmbCeLog(("Pipeline Write %x %d %d\n",OrdinaryExchange,NumberOfSections,NumOfOutstandingExchanges));

            Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);
            NumberOfSections --;

            if ( Status != RX_MAP_STATUS(PENDING) ) {
                ExAcquireFastMutex(&MRxSmbReadWriteMutex);

                if (Status != STATUS_SUCCESS) {
                    NumberOfSections ++;

                    GlobalReadWrite->SectionState[OrdinaryExchange->ReadWrite.CurrentSection] = SmbPseOEReadWriteIoStates_Initial;
                    SmbCeLog(("Section undo %d\n",OrdinaryExchange->ReadWrite.CurrentSection));
                }

                if (!OrdinaryExchange->ReadWrite.ReadWriteFinalized) {
                    MRxSmbDereferenceGlobalReadWrite(GlobalReadWrite);
                    NumOfOutstandingExchanges = InterlockedDecrement(&GlobalReadWrite->NumOfOutstandingOperations);
                } else {
                    NumOfOutstandingExchanges --;
                }

                if ((Status == STATUS_TOO_MANY_COMMANDS) && (NumOfOutstandingExchanges > 0)) {
                    Status = STATUS_SUCCESS;
                }

                if ((Status != STATUS_SUCCESS) &&
                    (GlobalReadWrite->CompletionStatus == STATUS_SUCCESS)) {
                    GlobalReadWrite->CompletionStatus = Status;
                }

                ExReleaseFastMutex(&MRxSmbReadWriteMutex);

                SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            }
            else {
                ExchangePending = TRUE;
            }

            if (NumOfOutstandingExchanges >= MaxNumOfExchangesForPipelineReadWrite) {
                break;
            }
        } else {
            SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            Status = STATUS_PENDING;
            break;
        }
    } while ((Status == STATUS_RETRY) ||
             EnablePipelineWrite &&
             (NumberOfSections > 0) &&
             (Status == STATUS_PENDING));

    SmbCeLog(("Pipeline Write out %x %d\n",Status,NumberOfSections));

    if (!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
        if (ExchangePending) {
            KeWaitForSingleObject(
                &GlobalReadWrite->CompletionEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL );

            Status = GlobalReadWrite->CompletionStatus;
        }

        if (SmbFcbHoldingState != SmbFcb_NotHeld) {
            MRxSmbCscReleaseSmbFcb(
                RxContext,
                &SmbFcbHoldingState);
        }
    } else {
        if (ExchangePending) {
            Status = STATUS_PENDING;
        }
    }

    MRxSmbDereferenceGlobalReadWrite(GlobalReadWrite);

    RxDbgTrace(-1, Dbg, ("MRxSmbWrite  exit with status=%08lx\n", Status ));

    return(Status);
} // MRxSmbWrite

NTSTATUS
MRxSmbWriteMailSlot(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine processes a write smb for a mail slot.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);

    RxCaptureFcb;
    RxCaptureFobx;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;

    UNICODE_STRING TransactionName;
    UNICODE_STRING MailSlotName;
    PUNICODE_STRING FcbName = &(((PFCB)(capFcb))->FcbTableEntry.Path);
    PUNICODE_STRING AlreadyPrefixedName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PAGED_CODE();

    if (AlreadyPrefixedName->Length > sizeof(WCHAR)) {
        MailSlotName.Length = AlreadyPrefixedName->Length - sizeof(WCHAR);
    } else {
        MailSlotName.Length = 0;
    }

    MailSlotName.MaximumLength = MailSlotName.Length;
    MailSlotName.Buffer = AlreadyPrefixedName->Buffer + 1;

    TransactionName.Length = (USHORT)(s_MailSlotTransactionName.Length +
                                     MailSlotName.Length);
    TransactionName.MaximumLength = TransactionName.Length;
    TransactionName.Buffer = (PWCHAR)RxAllocatePoolWithTag(
                                        PagedPool,
                                        TransactionName.Length,
                                        MRXSMB_MAILSLOT_POOLTAG);

    if (TransactionName.Buffer != NULL) {
        USHORT    Setup[3];        // Setup params for mailslot write transaction
        USHORT    OutputParam;

        PBYTE  pInputDataBuffer        = NULL;
        PBYTE  pOutputDataBuffer       = NULL;

        ULONG  InputDataBufferLength   = 0;
        ULONG  OutputDataBufferLength  = 0;

        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
        SMB_TRANSACTION_OPTIONS             TransactionOptions;

        TransactionOptions = RxDefaultTransactionOptions;

        pInputDataBuffer = RxLowIoGetBufferAddress( RxContext );
        InputDataBufferLength= pLowIoContext->ParamsFor.ReadWrite.ByteCount;

        RtlCopyMemory(
            TransactionName.Buffer,
            s_MailSlotTransactionName.Buffer,
            s_MailSlotTransactionName.Length );

        RtlCopyMemory(
            (PBYTE)TransactionName.Buffer +
             s_MailSlotTransactionName.Length,
            MailSlotName.Buffer,
            MailSlotName.Length );

        RxDbgTrace(0, Dbg, ("MRxSmbWriteMailSlot: Mailslot transaction name %wZ\n",&TransactionName));

        Setup[0] = TRANS_MAILSLOT_WRITE;
        Setup[1] = 0;                   // Priority of write
        Setup[2] = 2;                   // Unreliable request (Second class mailslot)

        TransactionOptions.NtTransactFunction = 0; // TRANSACT2/TRANSACT.
        TransactionOptions.pTransactionName   = &TransactionName;
        TransactionOptions.Flags              = (SMB_TRANSACTION_NO_RESPONSE |
                                               SMB_XACT_FLAGS_FID_NOT_NEEDED |
                                               SMB_XACT_FLAGS_MAILSLOT_OPERATION);
        TransactionOptions.TimeoutIntervalInMilliSeconds =
                                             SMBCE_TRANSACTION_TIMEOUT_NOT_USED;

        Status = SmbCeTransact(
                     RxContext,                    // RXContext for transaction
                     &TransactionOptions,          // transaction options
                     Setup,                        // the setup buffer
                     sizeof(Setup),                // setup buffer length
                     NULL,                         // the output  setup buffer
                     0,                            // output setup buffer length
                     NULL,                         // Input Param Buffer
                     0,                            // Input param buffer length
                     &OutputParam,                 // Output param buffer
                     sizeof(OutputParam),          // output param buffer length
                     pInputDataBuffer,             // Input data buffer
                     InputDataBufferLength,        // Input data buffer length
                     NULL,                         // output data buffer
                     0,                            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        if ( RX_MAP_STATUS(SUCCESS) == Status ) {
            RxContext->InformationToReturn += InputDataBufferLength;
        }

        RxFreePool( TransactionName.Buffer );
    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    RxDbgTrace( 0, Dbg, ("MRxSmbMailSlotWrite: ...returning %lx\n",Status));

    return Status;
} // MRxSmbWriteMailSlot

NTSTATUS
MRxSmbPrepareCompressedWriteRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PBYTE                      *pWriteDataBufferPointer,
    PMDL                       *pWriteDataMdlPointer)
/*++

Routine Description:

    This routine prepares the buffers for a compressed write request

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    The write requests issued to an uplevel server for a file which is stored in
    a compressed fashion on the server can be classified into two categories ..

        1) ALIGNED WRITE REQUESTS
            These requests begin at an offset in the file which is an integral
            multiple of the compression chunk size. If the write length is either
            an integral multiple of the number of chunks or the write is at the
            end of the file then the data can be sent as a compressed write request.

        2) UNALIGNED WRITE REQUESTS
            These requests begin at offsets which are not an integral multiple of
            the compression chunk size.

    Any Write request submitted by the user can be decomposed into atmost two
    UNALIGNED WRITE REQUESTS and 0 or more ALIGNED WRITE REQUESTS.

    The RDR adopts a strategy of sending atmst 64K of compressed data alongwith
    the COMPRESSED_DATA_INFO structure in a single write request to the server.
    In the worst case this will involving writing the request 64k at a time
    ( no compression possible in the given data ) and in the best case we will
    be able to write using a single request.

    In addition to the write buffer supplied by the user we require two more
    buffers to complete the write request using compressed data. The first
    buffer is for holding the COMPRESSED_DATA_INFO structure and the second
    buffer is for holding the compressed data. The buffer associated with the
    exchange is used to hold the CDI while a separate buffer is allocated to store
    the compressed data. The two MDL's allocated as part of the
    SMB_PSE_OE_READWRITE is used as the MDLs for the compressed data buffer and
    the COMPRESSED_DATA_INFO structure

--*/
{
#define COMPRESSED_DATA_BUFFER_SIZE (0x10000)

    NTSTATUS Status = STATUS_SUCCESS;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PSMBCE_NET_ROOT pNetRoot;

    PCOMPRESSED_DATA_INFO pCompressedDataInfo;
    PUCHAR  pWriteDataBuffer;
    ULONG   WriteDataBufferLength,CompressedDataInfoLength;
    ULONG   CompressedDataLength;
    USHORT  NumberOfChunks;

    *pWriteDataBufferPointer = NULL;
    *pWriteDataMdlPointer    = NULL;

    pWriteDataBuffer = rw->UserBufferBase + rw->ThisBufferOffset;

    pNetRoot = SmbCeGetExchangeNetRoot((PSMB_EXCHANGE)OrdinaryExchange);

    rw->CompressedRequestInProgress = FALSE;

    if (rw->RemainingByteCount < (2 * pNetRoot->ChunkSize)) {
        WriteDataBufferLength = rw->RemainingByteCount;
    } else if (rw->ByteOffsetAsLI.LowPart & (pNetRoot->ChunkSize - 1)) {
        // The Write request is not aligned at a chunk size. Send the unaligned
        // portion as an uncompressed write request

        WriteDataBufferLength = pNetRoot->ChunkSize -
                                (
                                 rw->ByteOffsetAsLI.LowPart &
                                 (pNetRoot->ChunkSize - 1)
                                );
    } else {
        PUCHAR pCompressedDataBuffer,pWorkSpaceBuffer;
        ULONG  WorkSpaceBufferSize,WorkSpaceFragmentSize;

        if (rw->pCompressedDataBuffer == NULL) {
            rw->pCompressedDataBuffer = RxAllocatePoolWithTag(
                                            NonPagedPool,
                                            COMPRESSED_DATA_BUFFER_SIZE,
                                            MRXSMB_RW_POOLTAG);

            if (rw->pCompressedDataBuffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        pCompressedDataBuffer = rw->pCompressedDataBuffer;

        if (Status == STATUS_SUCCESS) {
            Status = RtlGetCompressionWorkSpaceSize(
                         COMPRESSION_FORMAT_LZNT1,
                         &WorkSpaceBufferSize,
                         &WorkSpaceFragmentSize );

            if (Status == STATUS_SUCCESS) {
                pWorkSpaceBuffer = RxAllocatePoolWithTag(
                                       PagedPool,
                                       WorkSpaceBufferSize,
                                       MRXSMB_RW_POOLTAG);

                if (pWorkSpaceBuffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        if (Status == STATUS_SUCCESS) {
            COMPRESSED_DATA_INFO CompressedChunkInfo;

            USHORT MaximumNumberOfChunks;
            ULONG  CompressedChunkInfoLength;
            ULONG  RequestByteCount;

            RequestByteCount = rw->RemainingByteCount -
                               (rw->RemainingByteCount & (pNetRoot->ChunkSize - 1));

            CompressedChunkInfoLength = sizeof(CompressedChunkInfo);

            pCompressedDataInfo = (PCOMPRESSED_DATA_INFO)
                                  ROUND_UP_POINTER(
                                      (StufferState->BufferBase +
                                       sizeof(SMB_HEADER) +
                                       FIELD_OFFSET(REQ_NT_WRITE_ANDX,Buffer)),
                                      ALIGN_QUAD);

            CompressedDataInfoLength = (ULONG)(StufferState->BufferLimit -
                                               (PBYTE)pCompressedDataInfo);

            MaximumNumberOfChunks = (USHORT)(
                                        (CompressedDataInfoLength -
                                         FIELD_OFFSET(
                                             COMPRESSED_DATA_INFO,
                                             CompressedChunkSizes)) /
                                        sizeof(ULONG));

            if ((RequestByteCount / pNetRoot->ChunkSize) < MaximumNumberOfChunks) {
                MaximumNumberOfChunks = (USHORT)(RequestByteCount /
                                                 pNetRoot->ChunkSize);
            }

            pCompressedDataInfo->CompressionFormatAndEngine =
                pNetRoot->CompressionFormatAndEngine;
            pCompressedDataInfo->ChunkShift =
                pNetRoot->ChunkShift;
            pCompressedDataInfo->CompressionUnitShift =
                pNetRoot->CompressionUnitShift;
            pCompressedDataInfo->ClusterShift =
                pNetRoot->ClusterShift;

            RtlCopyMemory(
                &CompressedChunkInfo,
                pCompressedDataInfo,
                FIELD_OFFSET(
                    COMPRESSED_DATA_INFO,
                    NumberOfChunks)
                );

            NumberOfChunks = 0;
            CompressedDataLength = 0;

            for (;;) {
                if ((COMPRESSED_DATA_BUFFER_SIZE - CompressedDataLength) <
                    pNetRoot->ChunkSize) {
                    if (CompressedDataLength == 0) {
                        Status = STATUS_SMB_USE_STANDARD;
                    }
                    break;
                }

                Status = RtlCompressChunks(
                             pWriteDataBuffer,
                             pNetRoot->ChunkSize,
                             pCompressedDataBuffer,
                             (COMPRESSED_DATA_BUFFER_SIZE - CompressedDataLength),
                             &CompressedChunkInfo,
                             CompressedChunkInfoLength,
                             pWorkSpaceBuffer);

                if (Status != STATUS_SUCCESS) {
                    break;
                }

                pCompressedDataBuffer += CompressedChunkInfo.CompressedChunkSizes[0];
                CompressedDataLength += CompressedChunkInfo.CompressedChunkSizes[0];

                pCompressedDataInfo->CompressedChunkSizes[NumberOfChunks] =
                    CompressedChunkInfo.CompressedChunkSizes[0];

                pWriteDataBuffer += pNetRoot->ChunkSize;

                if (++NumberOfChunks >= MaximumNumberOfChunks) {
                    break;
                }
            }

            if (Status != STATUS_SUCCESS) {
                if (CompressedDataLength  > 0) {
                    Status = STATUS_SUCCESS;
                }
            }

            if (Status == STATUS_SUCCESS) {
                rw->CompressedRequestInProgress = TRUE;
                pWriteDataBuffer = rw->pCompressedDataBuffer;
                WriteDataBufferLength = CompressedDataLength;
            } else if (Status != STATUS_BUFFER_TOO_SMALL) {
                DbgPrint("Failure compressing data -- Status %lx, Switching over to uncompressed\n",Status);
            }

            if (pWorkSpaceBuffer != NULL) {
                RxFreePool(
                    pWorkSpaceBuffer);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (Status == STATUS_SUCCESS) {
        rw->PartialDataMdlInUse = TRUE;

        MmInitializeMdl(
            &rw->PartialDataMdl,
            pWriteDataBuffer,
            WriteDataBufferLength);

        MmBuildMdlForNonPagedPool( &rw->PartialDataMdl );

        if (rw->CompressedRequestInProgress) {
            rw->CompressedDataInfoLength = FIELD_OFFSET(
                                               COMPRESSED_DATA_INFO,
                                               CompressedChunkSizes) +
                                               NumberOfChunks * sizeof(ULONG);
            pCompressedDataInfo->NumberOfChunks = NumberOfChunks;

            rw->PartialExchangeMdlInUse = TRUE;

            MmInitializeMdl(
                &rw->PartialExchangeMdl,
                pCompressedDataInfo,
                rw->CompressedDataInfoLength);

            MmBuildMdlForNonPagedPool( &rw->PartialExchangeMdl );

            rw->ThisByteCount = pCompressedDataInfo->NumberOfChunks *
                                pNetRoot->ChunkSize;

            rw->PartialExchangeMdl.Next = &rw->PartialDataMdl;

            *pWriteDataMdlPointer = &rw->PartialExchangeMdl;
        } else {
            rw->ThisByteCount = WriteDataBufferLength;

            *pWriteDataMdlPointer = &rw->PartialDataMdl;
        }
    } else {
        // If for whatever reason the compression fails switch over to an
        // uncompressed write mode.
        rw->CompressedReadOrWrite = FALSE;
    }

    ASSERT(
        !rw->CompressedReadOrWrite ||
        ((*pWriteDataMdlPointer != NULL) && (*pWriteDataBufferPointer == NULL)));

    return Status;
}

NTSTATUS
MRxSmbBuildWriteRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    BOOLEAN                    IsPagingIo,
    UCHAR                      WriteCommand,
    ULONG                      ByteCount,
    PLARGE_INTEGER             ByteOffsetAsLI,
    PBYTE                      Buffer,
    PMDL                       BufferAsMdl)
/*++

Routine Description:

    This is the start routine for write.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_PSE_OE_READWRITE GlobalReadWrite = OrdinaryExchange->GlobalReadWrite;
    PRX_CONTEXT RxContext = StufferState->RxContext;

    RxCaptureFcb;
    RxCaptureFobx;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    ULONG OffsetLow,OffsetHigh;

    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    USHORT  WriteMode = 0;
    ULONG   DataLengthLow,DataLengthHigh;
    ULONG   BytesRemaining = 0;
    BOOLEAN AddLengthBytes = FALSE;
    ULONG   WriteCommandSize;

    PSMBCE_SERVER pServer = SmbCeGetExchangeServer((PSMB_EXCHANGE)OrdinaryExchange);
    BOOLEAN UseNtVersion;

    UseNtVersion = BooleanFlagOn(pServer->DialectFlags,DF_NT_SMBS) &&
                   !MRxSmbForceNoNtWriteAndX;

    // The data length field in SMB is a USHORT, and hence the data length given
    // needs to be split up into two parts -- DataLengthHigh and DataLengthLow
    DataLengthLow  = (ByteCount & 0xffff);
    DataLengthHigh = ((ByteCount & 0xffff0000) >> 16);

    OffsetLow  = ByteOffsetAsLI->LowPart;
    OffsetHigh = ByteOffsetAsLI->HighPart;

    switch (WriteCommand) {
    case SMB_COM_WRITE_ANDX:
        WriteCommandSize = SMB_REQUEST_SIZE(NT_WRITE_ANDX);
        break;
    case SMB_COM_WRITE:
        WriteCommandSize = SMB_REQUEST_SIZE(WRITE);
        break;
    case SMB_COM_WRITE_PRINT_FILE:
        WriteCommandSize = SMB_REQUEST_SIZE(WRITE_PRINT_FILE);
        break;
    }

    Status = MRxSmbStartSMBCommand(
                 StufferState,
                 SetInitialSMB_Never,
                 WriteCommand,
                 WriteCommandSize,
                 NO_EXTRA_DATA,
                 NO_SPECIAL_ALIGNMENT,
                 RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                 0,0,0,0 STUFFERTRACE(Dbg,'FC'));

    MRxSmbDumpStufferState(
        1000,
        "SMB Write Request before stuffing",
        StufferState);

    switch (WriteCommand) {
    case SMB_COM_WRITE_ANDX :
        {
            if ( UseNtVersion && IsPagingIo ) {
                SmbPutAlignedUshort(
                    &NtSmbHeader->Flags2,
                    SmbGetAlignedUshort(&NtSmbHeader->Flags2)|SMB_FLAGS2_PAGING_IO );
            }

            // set the writemode correctly....mainly multismb pipe stuff but also
            // writethru for diskfiles
            if (FlagOn(
                    OrdinaryExchange->OpSpecificFlags,
                    OE_RW_FLAG_MSGMODE_PIPE_OPERATION) ) {

                //DOWNLEVEL pinball has wants a different value here....see rdr1.

                // We need to use the GlobalReadWrite structure here because the local one
                // will always have RemainingByteCount == write length.  Note that pipe writes
                // will be broken if we do not disable pipeline writes on them..
                BytesRemaining = GlobalReadWrite->RemainingByteCount;

                //  If this write takes more than one Smb then we must set WRITE_RAW.
                //  The first Smb of the series must have START_OF_MESSAGE.
                if (!FlagOn(
                        OrdinaryExchange->OpSpecificFlags,
                        OE_RW_FLAG_SUBSEQUENT_OPERATION) ) {
                    if ( rw->ThisByteCount < BytesRemaining ) {

                        //  First Smb in a multi SMB write.
                        //  Add a USHORT at the start of data saying how large the
                        //  write is.

                        AddLengthBytes = TRUE;
                        DataLengthLow += sizeof(USHORT);
                        ASSERT(DataLengthHigh == 0);

                        SetFlag(
                            OrdinaryExchange->OpSpecificFlags,
                            OE_RW_FLAG_REDUCE_RETURNCOUNT);

                        //  Tell the server that the data has the length at the start.
                        WriteMode |= (SMB_WMODE_WRITE_RAW_NAMED_PIPE |
                                      SMB_WMODE_START_OF_MESSAGE);
                    } else {
                        //  All fits in one Smb
                        WriteMode |= SMB_WMODE_START_OF_MESSAGE;
                    }
                } else {
                    // any subsequent pipewrites are obviously raw and not the first
                    WriteMode |= SMB_WMODE_WRITE_RAW_NAMED_PIPE;
                }
            } else {
                // If the data is to be written in a compressed fashion turn on
                // the compressed data bit in the header
                if ((rw->CompressedReadOrWrite) &&
                    (rw->CompressedDataInfoLength > 0)) {
                    ASSERT(UseNtVersion);

                    SmbPutAlignedUshort(
                        &NtSmbHeader->Flags2,
                        SmbGetAlignedUshort(&NtSmbHeader->Flags2) | SMB_FLAGS2_COMPRESSED );

                    // The Remaining field in NT_WRITE_ANDX also doubles as the field
                    // in which the CDI length is sent to the server
                    BytesRemaining = rw->CompressedDataInfoLength;
                }


                //
                //  If the file object was opened in write through mode, set write
                //  through on the write operation.
                if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WRITE_THROUGH)) {
                    WriteMode |= SMB_WMODE_WRITE_THROUGH;
                }
            }

            MRxSmbStuffSMB (
                StufferState,
                "XwddwwwwQ",
                                                  //  X UCHAR WordCount;
                                                  //    UCHAR AndXCommand;
                                                  //    UCHAR AndXReserved;
                                                  //    _USHORT( AndXOffset );
                smbSrvOpen->Fid,                  //  w _USHORT( Fid );
                OffsetLow,                        //  d _ULONG( Offset );
                -1,                               //  d _ULONG( Timeout );
                WriteMode,                        //  w _USHORT( WriteMode );
                BytesRemaining,                   //  w _USHORT( Remaining );
                DataLengthHigh,                   //  w _USHORT( DataLengthHigh );
                DataLengthLow,                    //  w _USHORT( DataLength );
                                                  //  Q _USHORT( DataOffset );
                SMB_OFFSET_CHECK(WRITE_ANDX,DataOffset)
                StufferCondition(UseNtVersion), "D",
                SMB_OFFSET_CHECK(NT_WRITE_ANDX,OffsetHigh)
                OffsetHigh,                       //  D NTonly  _ULONG( OffsetHigh );
                                                  //
                STUFFER_CTL_NORMAL, "BS5",
                                                  //  B _USHORT( ByteCount );
                SMB_WCT_CHECK(((UseNtVersion)?14:12))
                                                  //    UCHAR Buffer[1];
                                                  //  S //UCHAR Pad[];
                                                  //  5 //UCHAR Data[];
                StufferCondition(AddLengthBytes), "w", LowIoContext->ParamsFor.ReadWrite.ByteCount,
                StufferCondition(Buffer!=NULL), "c!",
                ByteCount,
                Buffer,                           //  c the actual data
                0
                );
        }
        break;

    case SMB_COM_WRITE :
        {
            MRxSmbStuffSMB (
                StufferState,
                "0wwdwByw",
                                       //  0   UCHAR WordCount;                    // Count of parameter words = 5
                smbSrvOpen->Fid,       //  w   _USHORT( Fid );                     // File handle
                DataLengthLow,         //  w   _USHORT( Count );                   // Number of bytes to be written
                OffsetLow,             //  d   _ULONG( Offset );                   // Offset in file to begin write
                BytesRemaining,        //  w   _USHORT( Remaining );               // Bytes remaining to satisfy request
                SMB_WCT_CHECK(5)       //  B   _USHORT( ByteCount );               // Count of data bytes
                                            //      //UCHAR Buffer[1];                  // Buffer containing:
                0x01,                  //  y     UCHAR BufferFormat;               //  0x01 -- Data block
                DataLengthLow,            //  w     _USHORT( DataLength );            //  Length of data
                                       //        ULONG Buffer[1];                  //  Data
                StufferCondition(Buffer!=NULL), "c!",
                ByteCount,
                Buffer,     //  c     the actual data
                0
                );
        }
        break;

    case SMB_COM_WRITE_PRINT_FILE:
        {
            MRxSmbStuffSMB (
                StufferState,
                "0wByw",
                                       // 0  UCHAR WordCount;                    // Count of parameter words = 1
                smbSrvOpen->Fid,       // w  _USHORT( Fid );                     // File handle
                SMB_WCT_CHECK(1)       // B  _USHORT( ByteCount );               // Count of data bytes; min = 4
                                            //    UCHAR Buffer[1];                    // Buffer containing:
                0x01,                  // y  //UCHAR BufferFormat;               //  0x01 -- Data block
                DataLengthLow,         // w  //USHORT DataLength;                //  Length of data
                                            //    //UCHAR Data[];                     //  Data
                StufferCondition(Buffer!=NULL), "c!",
                ByteCount,
                Buffer,     //  c     the actual data
                0
                );
        }
        break;

    default:
        Status = STATUS_UNSUCCESSFUL ;
        break;
    }

    if ( BufferAsMdl ) {
        MRxSmbStuffAppendRawData( StufferState, BufferAsMdl );
        MRxSmbStuffSetByteCount( StufferState );
    }

    MRxSmbDumpStufferState(
        700,
        "SMB Write Request after stuffing",
        StufferState);

    if (Status==STATUS_SUCCESS) {
        InterlockedIncrement(&MRxSmbStatistics.SmallWriteSmbs);
    }

    return Status;
}

BOOLEAN DisableLargeWrites = 0;

NTSTATUS
SmbPseExchangeStart_Write (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for write.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    ULONG StartEntryCount;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PSMB_PSE_OE_READWRITE GlobalReadWrite = OrdinaryExchange->GlobalReadWrite;
    ULONG NumOfOutstandingOperations;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PMDL OriginalDataMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FCB  SmbFcb = MRxSmbGetFcbExtension(capFcb);

    BOOLEAN SynchronousIo, IsPagingIo;
    UCHAR   WriteCommand;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Write\n"));

    ASSERT( OrdinaryExchange->Type == ORDINARY_EXCHANGE );

    ASSERT(
        (
            (OriginalDataMdl!=NULL) &&
            (
                RxMdlIsLocked(OriginalDataMdl) ||
                RxMdlSourceIsNonPaged(OriginalDataMdl)
            )
        ) ||
        (
            (OriginalDataMdl==NULL) &&
            (LowIoContext->ParamsFor.ReadWrite.ByteCount==0)
        )
        );

    ASSERT((OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    SynchronousIo = !BooleanFlagOn(
                        RxContext->Flags,
                        RX_CONTEXT_FLAG_ASYNC_OPERATION);

    IsPagingIo = BooleanFlagOn(
                     LowIoContext->ParamsFor.ReadWrite.Flags,
                     LOWIO_READWRITEFLAG_PAGING_IO);

    // Ensure that the Fid is validated
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {
        PSMBCE_SERVER         pServer;
        PSMBCE_NET_ROOT       pNetRoot;

        pServer  = SmbCeGetExchangeServer(OrdinaryExchange);
        pNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);

        switch (OrdinaryExchange->OpSpecificState) {
        case SmbPseOEInnerIoStates_Initial:
            {
                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
                MRxSmbSetInitialSMB( StufferState STUFFERTRACE(Dbg,'FC') );
            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_ReadyToSend:
            {
                ULONG MaximumBufferSizeThisIteration;
                PCHAR Buffer = NULL;
                PMDL  BufferAsMdl = NULL;

                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
                OrdinaryExchange->SendOptions = MRxSmbWriteSendOptions;

                if (FlagOn(pServer->DialectFlags,DF_LANMAN10) &&
                    FlagOn(pServer->DialectFlags,DF_LARGE_FILES) &&
                    (StufferState->RxContext->pFcb->pNetRoot->Type != NET_ROOT_PRINT)) {
                    WriteCommand = SMB_COM_WRITE_ANDX;
                } else {
                    WriteCommand = SMB_COM_WRITE;
                }

                MaximumBufferSizeThisIteration = rw->MaximumBufferSize;

                // There are four parameters pertaining to a write request
                //
                //  1. Write Length -- rw->ThisByteCount
                //  2. Write Offset -- rw->ByteOffsetAsLI
                //  3. Write Buffer -- Buffer
                //  4. Write Buffer as a MDL -- BufferAsMdl
                //
                // All writes can be classified into one of the following
                // categories ...
                //
                //  1. Extremely Small writes
                //      These are writes lesser than the COPY_THRESHOLD or
                //      we are in a debug mode that forces us to do only small
                //      writes.
                //
                //  2. Write requests against downlevel servers or non disk
                //     file write requests against up level servers.
                //      In all these cases we are constrained by the Server
                //      which limits the number of bytes to roughly 4k. This
                //      is based upon the Smb Buffer size returned during
                //      negotiation.
                //
                //  3. Write requests ( Uncompressed ) against uplevel (NT5+)
                //     servers
                //      These write requests can be arbitrarily large
                //
                //  4. Write requests (Compressed) against uplevel servers
                //      In these cases the server constrains us to send
                //      only 64k of compressed data with the added restriction
                //      that the compressed data info structure must be less
                //      than the SMB buffer size.
                //

                rw->CompressedDataInfoLength = 0;

                if ((rw->RemainingByteCount < WRITE_COPY_THRESHOLD) ||
                    FORCECOPYMODE) {
                    if (FORCECOPYMODE &&
                        (rw->ThisByteCount > MaximumBufferSizeThisIteration) ) {
                        rw->ThisByteCount = MaximumBufferSizeThisIteration;
                    } else {
                        rw->ThisByteCount = rw->RemainingByteCount;
                    }

                    Buffer = rw->UserBufferBase + rw->ThisBufferOffset;

                    ASSERT( WRITE_COPY_THRESHOLD <= pNetRoot->MaximumWriteBufferSize );
                } else {
                    if (rw->CompressedReadOrWrite) {
                        MRxSmbPrepareCompressedWriteRequest(
                            OrdinaryExchange,
                            &Buffer,
                            &BufferAsMdl);
                    }

                    if (!rw->CompressedReadOrWrite) {
                        rw->ThisByteCount = min(
                                                rw->RemainingByteCount,
                                                MaximumBufferSizeThisIteration);

                        if ((rw->ThisBufferOffset != 0) ||
                            (rw->ThisByteCount != OriginalDataMdl->ByteCount)) {
                            MmInitializeMdl(
                                &rw->PartialDataMdl,
                                0,
                                MAX_PARTIAL_DATA_MDL_BUFFER_SIZE);

                            IoBuildPartialMdl(
                                OriginalDataMdl,
                                &rw->PartialDataMdl,
                                (PCHAR)MmGetMdlVirtualAddress(OriginalDataMdl) +
                                    rw->ThisBufferOffset,
                                rw->ThisByteCount );

                            BufferAsMdl = &rw->PartialDataMdl;
                        } else {
                            BufferAsMdl = OriginalDataMdl;
                        }
                    }
                }

                Status = MRxSmbBuildWriteRequest(
                             OrdinaryExchange,
                             IsPagingIo,
                             WriteCommand,
                             rw->ThisByteCount,
                             &rw->ByteOffsetAsLI,
                             Buffer,
                             BufferAsMdl);

                if (Status != STATUS_SUCCESS) {
                    RxDbgTrace(0, Dbg, ("bad write stuffer status........\n"));
                    goto FINALLY;
                }

                InterlockedIncrement(&MRxSmbStatistics.WriteSmbs);

                Status = SmbPseOrdinaryExchange(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             SMBPSE_OETYPE_WRITE );

                if ( Status == STATUS_PENDING) {
                    goto FINALLY;
                }
            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_OperationOutstanding:
        case SmbPseOEInnerIoStates_OperationCompleted:
            {
                NTSTATUS ExchangeStatus;

                SetFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_SUBSEQUENT_OPERATION);

                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;

                if (rw->PartialExchangeMdlInUse) {
                    MmPrepareMdlForReuse(
                        &rw->PartialExchangeMdl);
                    rw->PartialDataMdlInUse = FALSE;
                }

                if (rw->PartialDataMdlInUse) {
                    MmPrepareMdlForReuse(
                        &rw->PartialDataMdl);
                    rw->PartialDataMdlInUse = FALSE;
                }

                Status = OrdinaryExchange->Status;
                ExchangeStatus = OrdinaryExchange->Status;

                if (Status != STATUS_SUCCESS) {
                    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(OrdinaryExchange);

                    if (Status == STATUS_RETRY) {
                        SmbCeUninitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                        Status = SmbCeReconnect(SmbCeGetExchangeVNetRoot(OrdinaryExchange));

                        if (Status == STATUS_SUCCESS) {
                            OrdinaryExchange->Status = STATUS_SUCCESS;
                            OrdinaryExchange->SmbStatus = STATUS_SUCCESS;
                            Status = SmbCeInitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                            ASSERT(Status == STATUS_SUCCESS);

                            if (Status != STATUS_SUCCESS) {
                                goto FINALLY;
                            }
                        } else {
                            goto FINALLY;
                        }
                    } else if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) &&
                        (smbSrvOpen->DeferredOpenContext != NULL) &&
                        (Status == STATUS_IO_TIMEOUT ||
                         Status == STATUS_BAD_NETWORK_PATH ||
                         Status == STATUS_NETWORK_UNREACHABLE ||
                         Status == STATUS_USER_SESSION_DELETED ||
                         Status == STATUS_REMOTE_NOT_LISTENING ||
                         Status == STATUS_CONNECTION_DISCONNECTED)) {

                        Status = SmbCeRemoteBootReconnect((PSMB_EXCHANGE)OrdinaryExchange,RxContext);

                        if (Status == STATUS_SUCCESS) {
                            // Resume the write from the previous offset.

                            OrdinaryExchange->SmbStatus = STATUS_SUCCESS;
                            SmbCeInitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                        } else {
                            Status = STATUS_RETRY;
                        }
                    }
                }

                ExAcquireFastMutex(&MRxSmbReadWriteMutex);

                if (ExchangeStatus == STATUS_SUCCESS) {
                    rw->RemainingByteCount -= rw->BytesReturned;
                    RxContext->InformationToReturn += rw->BytesReturned;
                    rw->ByteOffsetAsLI.QuadPart += rw->BytesReturned;
                    rw->ThisBufferOffset += rw->BytesReturned;

                    if (rw->WriteToTheEnd) {
                        smbSrvOpen->FileInfo.Standard.EndOfFile.QuadPart += rw->BytesReturned;
                        MRxSmbUpdateFileInfoCacheFileSize(RxContext, (PLARGE_INTEGER)(&smbSrvOpen->FileInfo.Standard.EndOfFile.QuadPart));
                    }
                }

                if ((Status != STATUS_SUCCESS) ||
                    (rw->RemainingByteCount ==0)) {

                    if (rw->RemainingByteCount == 0) {
                        RxDbgTrace(
                            0,
                            Dbg,
                            (
                             "OE %lx TBC %lx RBC %lx BR %lx TBO %lx\n",
                             OrdinaryExchange,rw->ThisByteCount,
                             rw->RemainingByteCount,
                             rw->BytesReturned,
                             rw->ThisBufferOffset )
                            );

                        RxDbgTrace(
                            0,
                            Dbg,
                            ("Bytes written %lx\n",
                             RxContext->InformationToReturn)
                            );

                        if (rw->pCompressedDataBuffer != NULL) {
                            RxFreePool(rw->pCompressedDataBuffer);
                            rw->pCompressedDataBuffer = NULL;
                        }
                    }

                    if (rw->RemainingByteCount == 0 &&
                        GlobalReadWrite->SectionState[rw->CurrentSection] == SmbPseOEReadWriteIoStates_OperationOutstanding) {
                        GlobalReadWrite->SectionState[rw->CurrentSection] = SmbPseOEReadWriteIoStates_OperationCompleted;
                        SmbCeLog(("Section done %d\n",rw->CurrentSection));
                    } else {
                        GlobalReadWrite->SectionState[rw->CurrentSection] = SmbPseOEReadWriteIoStates_Initial;
                        SmbCeLog(("Section undo %d\n",rw->CurrentSection));
                    }

                    if ((Status == STATUS_RETRY) ||
                        (Status == STATUS_SUCCESS) ||
                        (Status == STATUS_SMB_USE_STANDARD)) {
                        if (Status == STATUS_SMB_USE_STANDARD) {
                            GlobalReadWrite->CompletionStatus = STATUS_SMB_USE_STANDARD;
                        }

                        Status = MRxSmbFindNextSectionForReadWrite(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                                   &NumOfOutstandingOperations);
                    }

                    NumOfOutstandingOperations = InterlockedDecrement(&GlobalReadWrite->NumOfOutstandingOperations);

                    if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                        if ((Status == STATUS_TOO_MANY_COMMANDS) && (NumOfOutstandingOperations > 0)) {
                            Status = STATUS_SUCCESS;
                        }

                        if (Status != STATUS_SUCCESS &&
                            GlobalReadWrite->CompletionStatus == STATUS_SUCCESS) {
                            GlobalReadWrite->CompletionStatus = Status;
                        }

                        rw->ReadWriteFinalized = TRUE;

                        SmbCeLog(("Pipeline Write final %x %x %d\n",OrdinaryExchange,Status,NumOfOutstandingOperations));
                    }

                    ExReleaseFastMutex(&MRxSmbReadWriteMutex);

                    if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                        goto FINALLY;
                    }
                } else {
                    ExReleaseFastMutex(&MRxSmbReadWriteMutex);
                }

                RxDbgTrace(
                    0,
                    Dbg,
                    ( "Next Iteration OE %lx RBC %lx TBO %lx\n",
                      OrdinaryExchange,
                      rw->RemainingByteCount,
                      rw->ThisBufferOffset)
                    );

                RxDbgTrace(
                    0,
                    Dbg,
                    ("OE %lx TBC %lx, BR %lx\n",
                     OrdinaryExchange,
                     rw->ThisByteCount,
                     rw->BytesReturned));

                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
            }
            break;
        }
    }

FINALLY:

    if (Status != STATUS_PENDING) {
        BOOLEAN ReadWriteOutStanding = FALSE;
        PSMB_PSE_OE_READWRITE GlobalReadWrite = OrdinaryExchange->GlobalReadWrite;

        if (!rw->ReadWriteFinalized) {
            ExAcquireFastMutex(&MRxSmbReadWriteMutex);

            if (rw->RemainingByteCount == 0 &&
                GlobalReadWrite->SectionState[rw->CurrentSection] == SmbPseOEReadWriteIoStates_OperationOutstanding) {
                GlobalReadWrite->SectionState[rw->CurrentSection] = SmbPseOEReadWriteIoStates_OperationCompleted;
                SmbCeLog(("Section done %d\n",rw->CurrentSection));
            } else {
                GlobalReadWrite->SectionState[rw->CurrentSection] = SmbPseOEReadWriteIoStates_Initial;
                SmbCeLog(("Section undo %d\n",rw->CurrentSection));
            }

            NumOfOutstandingOperations = InterlockedDecrement(&GlobalReadWrite->NumOfOutstandingOperations);

            if ((Status == STATUS_TOO_MANY_COMMANDS) && (NumOfOutstandingOperations > 0)) {
                Status = STATUS_SUCCESS;
            }

            if (Status != STATUS_SUCCESS &&
                GlobalReadWrite->CompletionStatus == STATUS_SUCCESS) {
                GlobalReadWrite->CompletionStatus = Status;
            }

            rw->ReadWriteFinalized = TRUE;

            SmbCeLog(("Pipeline Write final %x %x %d\n",OrdinaryExchange,Status,NumOfOutstandingOperations));

            ExReleaseFastMutex(&MRxSmbReadWriteMutex);
        }

        if (!NumOfOutstandingOperations) {
            ASSERT(Status != STATUS_RETRY);

            // update shadow as appropriate
            // We do this here to ensure the shadow is updated only once (at IRP completion)
            IF_NOT_MRXSMB_CSC_ENABLED{
                ASSERT(MRxSmbGetSrvOpenExtension(SrvOpen)->hfShadow == 0);
            } else {
                if (MRxSmbGetSrvOpenExtension(SrvOpen)->hfShadow != 0){
                    MRxSmbCscWriteEpilogue(RxContext,&Status);
                }
            }

            if (!SynchronousIo &&
                (GlobalReadWrite->SmbFcbHoldingState != SmbFcb_NotHeld)) {
                MRxSmbCscReleaseSmbFcb(
                    StufferState->RxContext,
                    &GlobalReadWrite->SmbFcbHoldingState);
            }

            Status = GlobalReadWrite->CompletionStatus;
            SmbPseAsyncCompletionIfNecessary(OrdinaryExchange,RxContext);
            SmbCeLog(("Write complete %x %x\n",OrdinaryExchange,Status));

            if (SynchronousIo) {
                KeSetEvent(
                    &GlobalReadWrite->CompletionEvent,
                    0,
                    FALSE);
            }
        } else {
            SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            Status = STATUS_PENDING;
        }

        MRxSmbDereferenceGlobalReadWrite(GlobalReadWrite);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Write exit w %08lx\n", Status ));
    return Status;

} // SmbPseExchangeStart_Write

NTSTATUS
MRxSmbFinishWrite (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    IN      PBYTE                       ResponseBuffer
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the write response and finishes
    the write. Everything you need is locked down... so we can finish in the
    indication routine

Arguments:

    OrdinaryExchange - the exchange instance

    ResponseBuffer - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesReturned = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishWrite\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishWrite:");

    switch (OrdinaryExchange->LastSmbCommand) {
    case SMB_COM_WRITE_ANDX:
        {
            PSMBCE_SERVER    pServer;
            PSMBCE_NET_ROOT  pNetRoot;
            PRESP_WRITE_ANDX Response = (PRESP_WRITE_ANDX)ResponseBuffer;

            if (Response->WordCount != 6 ||
                SmbGetUshort(&Response->ByteCount) != 0) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            pServer = SmbCeGetExchangeServer((PSMB_EXCHANGE)OrdinaryExchange);
            pNetRoot = SmbCeGetExchangeNetRoot((PSMB_EXCHANGE)OrdinaryExchange);

            BytesReturned = SmbGetUshort( &Response->Count );

            if (FlagOn(pServer->DialectFlags,DF_LARGE_WRITEX)) {
                ULONG BytesReturnedHigh;

                BytesReturnedHigh = SmbGetUshort(&Response->CountHigh);

                BytesReturned = (BytesReturnedHigh << 16) | BytesReturned;
            }

            if (pNetRoot->NetRootType != NET_ROOT_PIPE) {
                if ((OrdinaryExchange->Status == STATUS_SUCCESS) &&
                    (OrdinaryExchange->ReadWrite.ThisByteCount > 2) &&
                    (BytesReturned == 0)) {
                        Status = STATUS_INVALID_NETWORK_RESPONSE;
                }
            } else {
                // Servers are not setting the bytes returned correctly for
                // pipe writes. This enables us to gracefully handle responses
                // from such servers

                BytesReturned = OrdinaryExchange->ReadWrite.ThisByteCount;
            }

            //if we added 2 headerbytes then let's get rid of them......
            if ( FlagOn(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_REDUCE_RETURNCOUNT) ) {
                // BytesReturned -= sizeof(USHORT);
                ClearFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_REDUCE_RETURNCOUNT);
            }
        }
        break;

    case SMB_COM_WRITE :
        {
            PRESP_WRITE  Response = (PRESP_WRITE)ResponseBuffer;

            if (Response->WordCount != 1 ||
                SmbGetUshort(&Response->ByteCount) != 0) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            BytesReturned = SmbGetUshort( &Response->Count );
        }
        break;

    case SMB_COM_WRITE_PRINT_FILE:
        {
            PRESP_WRITE_PRINT_FILE Response = (PRESP_WRITE_PRINT_FILE)ResponseBuffer;

            if (Response->WordCount != 0) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            //the response does not tell how many bytes were taken! get the byte count from the exchange
            BytesReturned = OrdinaryExchange->ReadWrite.ThisByteCount;
        }
        break;

    default :
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        break;
    }

    RxDbgTrace(0, Dbg, ("-->BytesReturned=%08lx\n", BytesReturned));

    OrdinaryExchange->ReadWrite.BytesReturned = BytesReturned;

    if (Status == STATUS_SUCCESS &&
        OrdinaryExchange->ReadWrite.ThisByteCount > 2 &&
        BytesReturned > OrdinaryExchange->ReadWrite.ThisByteCount) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    // invalidate the name based file info cache since it is almost impossible
    // to know the last write time of the file on the server.
    MRxSmbInvalidateFileInfoCache(OrdinaryExchange->RxContext);

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishWrite   returning %08lx\n", Status ));

    return Status;
} // MRxSmbFinishWrite

NTSTATUS
MRxSmbFindNextSectionForReadWrite(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    PULONG NumOfOutstandingExchanges
    )
/*++

Routine Description:

    This routine find out the next section for the read/write operation and set up the
    exchange readwrite struction accordingly.

Arguments:

    RxContext - the RDBSS context

    OrdinaryExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RxCaptureFcb;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Section;
    BOOLEAN SectionFound = FALSE;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PSMB_PSE_OE_READWRITE GlobalReadWrite = OrdinaryExchange->GlobalReadWrite;
    PSMBCE_SERVER         pServer;

    pServer  = SmbCeGetExchangeServer(OrdinaryExchange);
    *NumOfOutstandingExchanges = GlobalReadWrite->NumOfOutstandingOperations;

    if ((GlobalReadWrite->CompletionStatus != STATUS_SUCCESS) &&
        (GlobalReadWrite->CompletionStatus != STATUS_SMB_USE_STANDARD)) {

        Status = GlobalReadWrite->CompletionStatus;
        goto FINALLY;
    }

    if (GlobalReadWrite->CompletionStatus == STATUS_SMB_USE_STANDARD) {
        RxContext->InformationToReturn = 0;

        GlobalReadWrite->CompressedRequestInProgress = FALSE;
        GlobalReadWrite->CompressedReadOrWrite = FALSE;
        GlobalReadWrite->CompletionStatus = STATUS_SUCCESS;
        OrdinaryExchange->Status = STATUS_SUCCESS;

        for (Section=0;Section<GlobalReadWrite->TotalNumOfSections;Section++) {
            switch (GlobalReadWrite->SectionState[Section]) {
            case SmbPseOEReadWriteIoStates_OperationOutstanding:
                 GlobalReadWrite->SectionState[Section] = SmbPseOEReadWriteIoStates_OperationAbandoned;
                 break;
            case SmbPseOEReadWriteIoStates_OperationCompleted:
                 GlobalReadWrite->SectionState[Section] = SmbPseOEReadWriteIoStates_Initial;
                 break;
            }
        }
    }

    for (Section=0;Section<GlobalReadWrite->TotalNumOfSections;Section++) {
        if (GlobalReadWrite->SectionState[Section] == SmbPseOEReadWriteIoStates_Initial) {
            GlobalReadWrite->SectionState[Section] = SmbPseOEReadWriteIoStates_OperationOutstanding;
            SectionFound = TRUE;
            break;
        }
    }

    if (SectionFound) {
        rw->ByteOffsetAsLI.QuadPart = GlobalReadWrite->ByteOffsetAsLI.QuadPart +
                                      (ULONGLONG)GlobalReadWrite->MaximumBufferSize*Section;

        if ((Section == GlobalReadWrite->TotalNumOfSections - 1) &&
            (GlobalReadWrite->RemainingByteCount % GlobalReadWrite->MaximumBufferSize != 0)) {
            rw->RemainingByteCount = GlobalReadWrite->RemainingByteCount % GlobalReadWrite->MaximumBufferSize;
        } else if( GlobalReadWrite->RemainingByteCount != 0 ) {
            rw->RemainingByteCount = GlobalReadWrite->MaximumBufferSize;
        } else {
            rw->RemainingByteCount = 0;
        }

        rw->ThisBufferOffset = GlobalReadWrite->MaximumBufferSize*Section;

        rw->CurrentSection = Section;

        *NumOfOutstandingExchanges = InterlockedIncrement(&GlobalReadWrite->NumOfOutstandingOperations);
        Status = STATUS_MORE_PROCESSING_REQUIRED;
        SmbCeLog(("Next section found %d %x\n",Section,OrdinaryExchange));
    }

FINALLY:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\chunk.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Chunk.c

Abstract:

    This module implements the copychunk interface for the smbcsc agent.

Author:

    Joe Linn [JoeLinn]    10-apr-1997

Revision History:

Notes:

The following describes the intended implementation.

On win95, the following sequence is performed:

    Win32OpenWithCopyChunkIntent ();
    while (MoreToDo()) {
        Win32CopyChunk();
    }
    Win32CloseWithCopyChunkIntent ();

Win32OpenWithCopyChunkIntent and Win32CloseWithCopyChunkIntent are implemented
by Win32 open and close operations; CopyChunk is an ioctl. On NT, all three
operations will be performed by ioctls. Internally, the will allow internal
NT-only calls to be used as appropriate. A major advantage of implementing
Win32OpenWithCopyChunkIntent as an ioctl is that the intent is unambiguously
captured.

A wrapper modification has been  made whereby a calldown to the minirdr is
made before collapsing is tried..a minirdr is able to bypass collapsing using
this calldown.

There are two important cases: surrogate opens and copychunk-thru opens. For
surrogate opens, the mini is able to discover an existing srvopen (the
surrogate) with read access. Here, the mini simply records the surrogate
srvopen (and surrounding UID/PID in the smbFcb for use later with the read.
For copychunk-thru opens, the mini must go on the wire with an open. When complete,
it records in the smbFcb all of the appropriate stuff.

Thus, when a OpenWithCopyChunkIntent comes in one of the following will obtain:
   1. a surrogate can be found; information is recorded and the open succeeds
   2. there is an existing open and no surrogate is found and the open fails
   3. nonchunk opens are in progress..the open fails
   4. a copychunk-thru is attempted at the server. Here, we must stall
      subsequent opens on the same fcb. When the open completes we have
      two cases:
        a. the open failed. Unblock any stalled opens and fail the open
        b. the open succeeded. Record the information, unblock the stalled
           guys and the open succeeds.

A surrogate open is invalidated when the corresponding srvopen is closed..the
data is in the fcb so normal Fcb serialization makes this work correctly. A
copychunk-thru open is invalidated by any any nonchunk open on the same fcb.
The logistics will be handled by MrxSmbCscCloseCopychunkThruOpen; the major
problem will be to get into an exchange in the right security context (i.e. UID).

An OpenWithCopyChunkIntent is implemented as a normal open except that it is
identified (currently) by using specifying a profile of
    FILE_OPEN
    FILE_READ_ATTRIBUTES
    AllocationSize = {`\377ffCSC',?ioctl-irp}

A ReadWithCopyChunkIntent and CloseWithCopyChunkIntent just normal read and
close operations but are further identified by a bit set in the smbSrvOpen by
OpenWithCopyChunkIntent. For the read, if the copychunk info in the fcb is
invalid, the read just fails and copychunk fails. Otherwise the issue is again
just to get into the right context (UID/TID) so that the fid will be valid.



--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

//there is some toplevel irp manipulation in here.......
#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //ifdef RX_PRIVATE_BUILD

extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_MRXSMBCSC;
#define Dbg (DEBUG_TRACE_MRXSMBCSC)

LONG MRxSmbSpecialCopyChunkAllocationSizeMarker = (LONG)'\377csc';

typedef union _SMBMRX_COPYCHUNKCONTEXT {
   COPYCHUNKCONTEXT;
   struct {
       ULONG spacer[3];
       PRX_CONTEXT RxContext;
   };
} SMBMRX_COPYCHUNKCONTEXT, *PSMBMRX_COPYCHUNKCONTEXT;

#define UNC_PREFIX_STRING  L"\\??\\UNC"
PWCHAR MRxSmbCscUncPrefixString = UNC_PREFIX_STRING;

#ifdef RX_PRIVATE_BUILD
#if 1
BOOLEAN AllowAgentOpens = TRUE;
#else
BOOLEAN AllowAgentOpens = FALSE;
#endif
#else
BOOLEAN AllowAgentOpens = TRUE;
#endif //ifdef RX_PRIVATE_BUILD


NTSTATUS
MRxSmbCscIoctlOpenForCopyChunk (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine performs a fileopen with copychunk intent.

Arguments:

    RxContext - the RDBSS context. this contains a pointer to the bcs text
                giving the UNC filename and also the copychunk context where
                we store various things...including the underlying filehandle.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PWCHAR  FileName = (PWCHAR)LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    ULONG   FileNameLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PSMBMRX_COPYCHUNKCONTEXT CopyChunkContext =
                     (PSMBMRX_COPYCHUNKCONTEXT)(LowIoContext->ParamsFor.IoCtl.pOutputBuffer);

    ULONG   UncPrefixLength = sizeof(UNC_PREFIX_STRING)-sizeof(WCHAR);
    UNICODE_STRING FileNameU,tmpU;
    PWCHAR pPrefixedName = NULL;

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG Disposition,ShareAccess,CreateOptions;
    LARGE_INTEGER SpecialCopyChunkAllocationSize;

    C_ASSERT(sizeof(SMBMRX_COPYCHUNKCONTEXT) == sizeof(COPYCHUNKCONTEXT));

    RxDbgTrace(+1, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk entry...%08lx %08lx %08lx %08lx\n",
            RxContext, FileName, FileNameLength, CopyChunkContext));

    CopyChunkContext->handle = INVALID_HANDLE_VALUE;

    IF_DEBUG {
        if (!AllowAgentOpens) {
            Status = (STATUS_INVALID_PARAMETER);
            goto FINALLY;
        }
    }

    if (FileName[FileNameLength/sizeof(WCHAR)]!= 0) {
        RxDbgTrace(0, Dbg, ("Bad Filename passed...%08lx %08lx\n",FileName,FileNameLength));
        Status = (STATUS_INVALID_PARAMETER);
        goto FINALLY;
    }

    //  we allow multiple temporary agents (spp)
//    if (!IsSpecialApp()) {
//        DbgPrint(0, Dbg, ("CopyChunk operation in wrong thread!!!\n");
//        Status = (STATUS_INVALID_PARAMETER);
//        goto FINALLY;
//    }

    RxDbgTrace(0, Dbg,  ("MRxSmbCscIoctlOpenForCopyChunk name...%08lx %s\n", RxContext, FileName));

    pPrefixedName = (PWCHAR)RxAllocatePoolWithTag(
                             PagedPool,
                             UncPrefixLength + FileNameLength,  // one wchar extra
                             MRXSMB_MISC_POOLTAG );

    if (pPrefixedName == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    FileNameU.Buffer = pPrefixedName;

    RtlCopyMemory(pPrefixedName, MRxSmbCscUncPrefixString, UncPrefixLength);

    // copy the UNC name, step over the first back slash of the two leading ones
    RtlCopyMemory(&pPrefixedName[UncPrefixLength/sizeof(WCHAR)], &FileName[1], FileNameLength-sizeof(WCHAR));

    FileNameU.Length = FileNameU.MaximumLength = (USHORT)(UncPrefixLength + FileNameLength-sizeof(WCHAR));
    RxDbgTrace(0, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk Uname...%08lx %wZ\n", RxContext, &FileNameU));


    InitializeObjectAttributes(
          &ObjectAttributes,
          &FileNameU,
          OBJ_CASE_INSENSITIVE,
          0,
          NULL
          );

    SpecialCopyChunkAllocationSize.HighPart = MRxSmbSpecialCopyChunkAllocationSizeMarker;

    SpecialCopyChunkAllocationSize.LowPart = ((CopyChunkContext->dwFlags & COPYCHUNKCONTEXT_FLAG_IS_AGENT_OPEN)!=0);

    Disposition = FILE_OPEN;
    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | FILE_NON_DIRECTORY_FILE;
    //CODE.IMPROVEMENT.ASHAMED
    //i am doing this as unbuffered ios.....the alternative is to do
    //buffered ios but the problem is that we must not have any
    //pagingIOs issued on these handles. so, the following would also
    //have to be done:
    //   1) no fastio on these...or fix fastio so it didn;t always wait
    //   2) always flush....we would always want to flush at the top of read
    //   3) no initialize cachemap...rather, use the FO in the segment-pointers
    //   4) no wait on cccopyread calls.
    //the effect of these improvements would be pretty big: you wouldn't have to go
    //back to the server for stuff already in the cache. but 'til then
    CreateOptions |= FILE_NO_INTERMEDIATE_BUFFERING;


    //CODE.IMPROVEMENT if we used IoCreateFile instead and IO_NO_PARAMETER
    //                 checking, then we could pass in a nonsensical value
    //                 and have even more foolproof way of describing a chunk
    //                 open

    Status = ZwCreateFile(
        &CopyChunkContext->handle,  //OUT PHANDLE FileHandle,
        FILE_READ_ATTRIBUTES | SYNCHRONIZE, //IN ACCESS_MASK DesiredAccess,
        &ObjectAttributes, //IN POBJECT_ATTRIBUTES ObjectAttributes,
        &IoStatusBlock, //OUT PIO_STATUS_BLOCK IoStatusBlock,
        &SpecialCopyChunkAllocationSize, //IN PLARGE_INTEGER AllocationSize OPTIONAL,
        FILE_ATTRIBUTE_NORMAL, //IN ULONG FileAttributes,
        ShareAccess, //IN ULONG ShareAccess,
        Disposition, //IN ULONG CreateDisposition,
        CreateOptions, //IN ULONG CreateOptions,
        NULL, //IN PVOID EaBuffer OPTIONAL,
        0  //IN ULONG EaLength,
        );

    IF_DEBUG {
        //this little snippett just allows me to test the closechunkopen logic
        if (FALSE) {
            HANDLE h;
            NTSTATUS TestOpenStatus;
            RxDbgTrace(0, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk...f***open %08lx\n",
                      RxContext));
            TestOpenStatus = ZwCreateFile(
                &h,  //OUT PHANDLE FileHandle,
                GENERIC_READ | SYNCHRONIZE, //IN ACCESS_MASK DesiredAccess,
                &ObjectAttributes, //IN POBJECT_ATTRIBUTES ObjectAttributes,
                &IoStatusBlock, //OUT PIO_STATUS_BLOCK IoStatusBlock,
                NULL, //IN PLARGE_INTEGER AllocationSize OPTIONAL,
                FILE_ATTRIBUTE_NORMAL, //IN ULONG FileAttributes,
                ShareAccess, //IN ULONG ShareAccess,
                Disposition, //IN ULONG CreateDisposition,
                CreateOptions, //IN ULONG CreateOptions,
                NULL, //IN PVOID EaBuffer OPTIONAL,
                0  //IN ULONG EaLength
                );
            RxDbgTrace(0, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk...f***open %08lx teststs=%08lx %08lx\n",
                      RxContext, TestOpenStatus, h));
            if (NT_SUCCESS(TestOpenStatus)) {
                NtClose(h);
            }
        }
    }


FINALLY:
    if (pPrefixedName!=NULL) {
        RxFreePool(pPrefixedName);
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk...%08lx %08lx %08lx\n",
              RxContext, Status, CopyChunkContext->handle));
    return(Status);
}

NTSTATUS
MRxSmbCscIoctlCloseForCopyChunk (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine performs the special IOCTL operation for the CSC agent.

Arguments:

    RxContext - the RDBSS context which points to the copychunk context. this contains the
                underlying handle to close.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PSMBMRX_COPYCHUNKCONTEXT CopyChunkContext =
                     (PSMBMRX_COPYCHUNKCONTEXT)(LowIoContext->ParamsFor.IoCtl.pOutputBuffer);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscIoctlCloseForCopyChunk...%08lx %08lx %08lx\n",
            RxContext, 0, CopyChunkContext));
    if (CopyChunkContext->handle != INVALID_HANDLE_VALUE) {
        Status = NtClose(CopyChunkContext->handle);
        if (Status != STATUS_SUCCESS)
            Status = STATUS_UNSUCCESSFUL;
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }
//FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCscIoctlCloseForCopyChunk...%08lx %08lx\n", RxContext, Status));
    return(Status);
}

//CODE.IMPROVEMENT.NTIFS had to get this from ntifs.h since we use ntsrv.h
extern POBJECT_TYPE *IoFileObjectType;

NTSTATUS
MRxSmbCscIoctlCopyChunk (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine performs the copychunk function.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    what we do here is
    1)  get the filesize of the shadow...we use the handle stored in the
        agent's smbsrvopen......hence complicated synchronization.
    2)  allocate a read buffer COODE.IMPROVEMENT...should be done in the agent
    3)  issue the underlying read
    4)  write the acquired data to the file

   the putaway is done in the read tail. it must seem that we go to a lot of trouble
   to get the filesize using the underlying handle....actually, we could just get our
   handle. maybe, we should do that.

   also, it may seem that we should just rely on the underlying read to
   calculate where the chunk read should start. we do not do that because that
   would mean that we would have to bypass the cache! actually, we bypass it
   now anyway but later we may stop doing that. it's really, really bad to
   go back to the server for data that we have in cache. as well, the
   cachemanager/memorymanager can turn our small IOs into large Ios. so, we would
   need code in the minirdr read loop to keep the Ios down to the maximum chunk size.


--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    //PBYTE   FileName = (PBYTE)LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    //ULONG   FileNameLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength - 1;
    PSMBMRX_COPYCHUNKCONTEXT CopyChunkContext =
                     (PSMBMRX_COPYCHUNKCONTEXT)(LowIoContext->ParamsFor.IoCtl.pOutputBuffer);
    int iRet,ShadowFileLength;
    PFILE_OBJECT FileObject;
    BOOLEAN ObjectReferenceTaken = FALSE;
    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN CriticalSectionEntered = FALSE;
    PMRX_FCB underlyingFcb;
    PMRX_FOBX underlyingFobx;
    PMRX_SRV_OPEN underlyingSrvOpen;
    PMRX_SMB_SRV_OPEN underlyingsmbSrvOpen;
    PVOID hfShadow;

    IO_STATUS_BLOCK IoStatusBlock;
    PBYTE Buffer = NULL;
    LARGE_INTEGER ReadOffset;
    int iAmountRead; //need this as int

    PIRP TopIrp;

    // all probing/validation is already on entry to mrxsmbcscioctl
    RxDbgTrace(+1, Dbg, ("MRxSmbCscIoctlCopyChunk...%08lx %08lx\n", RxContext,CopyChunkContext));

    //
    // we have to find out the size of the shadow file. we do this by going thru
    // the objectmanager. in this way, we do not require any extra state about
    // the ongoing copy....only the underlying handle. if we did not do this, we
    // would have to rely on whoever had the copychunk context to preserve it
    // correctly.

    //
    // Reference the file object to get the pointer.
    //

    Status = ObReferenceObjectByHandle( CopyChunkContext->handle,
                                        0,
                                        *IoFileObjectType,
                                        RxContext->CurrentIrp->RequestorMode,
                                        (PVOID *) &FileObject,
                                        NULL );
    if (!NT_SUCCESS( Status )) {
        goto FINALLY;
    }

    ObjectReferenceTaken = TRUE;
    // keep the reference so the handle doesn't vanish from underneath us
#if 0
    // make sure this handle belongs to us
    if (FileObject->DeviceObject != (PDEVICE_OBJECT)MRxSmbDeviceObject)
    {
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace(0, Dbg, ("Invalid device object, not our handle \r\n"));
        goto FINALLY;
    }
#endif
    underlyingFcb = (PMRX_FCB)(FileObject->FsContext);
    underlyingFobx = (PMRX_FOBX)(FileObject->FsContext2);

    if(NodeType(underlyingFcb) != RDBSS_NTC_STORAGE_TYPE_FILE)
    {
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace(0, Dbg, ("Invalid storage type, handle is not for a file\r\n"));
        goto FINALLY;

    }

    Status = RxAcquireSharedFcbResourceInMRx( underlyingFcb );

    if (!NT_SUCCESS( Status )) {
        goto FINALLY;
    }
    FcbAcquired = TRUE;

    underlyingSrvOpen = underlyingFobx->pSrvOpen;
    underlyingsmbSrvOpen = MRxSmbGetSrvOpenExtension(underlyingSrvOpen);

    //if this is not a copychunk handle quit
    if (!FlagOn(underlyingsmbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)){
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace(0, Dbg, ("not a copychunk handle\r\n"));
        goto FINALLY;
    }

    hfShadow = underlyingsmbSrvOpen->hfShadow;
    if (hfShadow==0) {
        Status = STATUS_UNSUCCESSFUL;
        RxDbgTrace(0, Dbg, ("Nt5CSC: no shadowhandle for copychunk\n"));
        goto FINALLY;
    }

    ASSERT_MINIRDRFILEOBJECT((PNT5CSC_MINIFILEOBJECT)hfShadow);

    EnterShadowCrit();
    CriticalSectionEntered = TRUE;


    //don't need the shadowreadwritemutex here because it's not really important
    //to have the correct endoffile value....worst case: an extra read flows....

    iRet = GetFileSizeLocal(hfShadow, &ShadowFileLength);
    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscIoctlCopyChunk... %08lx (st=%08lx) fsize= %08lx\n",
            RxContext, iRet, ShadowFileLength));

    if (iRet <0) {
        Status = STATUS_UNSUCCESSFUL;
        goto FINALLY;
    }

    LeaveShadowCrit();
    CriticalSectionEntered = FALSE;

    RxReleaseFcbResourceInMRx( underlyingFcb );
    FcbAcquired = FALSE;

    ObDereferenceObject( FileObject );
    ObjectReferenceTaken = FALSE;

    Buffer = RxAllocatePoolWithTag(
                             PagedPool,
                             CopyChunkContext->ChunkSize,
                             MRXSMB_MISC_POOLTAG );

    if (Buffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscIoctlCopyChunk... about to read %08lx %08lx\n",
            RxContext, Buffer));

    ReadOffset.QuadPart = ShadowFileLength;

    try {

        try {
            TopIrp = IoGetTopLevelIrp();
            IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear

            Status = ZwReadFile(
                            CopyChunkContext->handle, //IN HANDLE FileHandle,
                            0, //IN HANDLE Event OPTIONAL,
                            0, //IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
                            NULL, //IN PVOID ApcContext OPTIONAL,
                            &IoStatusBlock, //OUT PIO_STATUS_BLOCK IoStatusBlock,
                            Buffer, //OUT PVOID Buffer,
                            CopyChunkContext->ChunkSize, //IN ULONG Length,
                            &ReadOffset, //IN PLARGE_INTEGER ByteOffset OPTIONAL,
                            NULL //IN PULONG Key OPTIONAL
                            );
        } finally {
            IoSetTopLevelIrp(TopIrp); //restore my context for unwind
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }

    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscIoctlCopyChunk... back from read %08lx %08lx %08lx\n",
            RxContext, Status, IoStatusBlock.Information));

    CopyChunkContext->LastAmountRead = 0;
    if (Status == STATUS_END_OF_FILE) {
        //we're cookin'...just map it
        Status = STATUS_SUCCESS;
        goto FINALLY;
    }
    if (!NT_SUCCESS(Status)) {
        goto FINALLY;
    }
    CopyChunkContext->LastAmountRead = (ULONG)IoStatusBlock.Information;
    CopyChunkContext->TotalSizeBeforeThisRead = ShadowFileLength;


FINALLY:
    if (Buffer != NULL) {
        RxFreePool(Buffer);
    }
    if (CriticalSectionEntered) {
        LeaveShadowCrit();
    }
    if (FcbAcquired) {
        RxReleaseFcbResourceInMRx( underlyingFcb );
    }
    if (ObjectReferenceTaken) {
        ObDereferenceObject( FileObject );
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbCscIoctlCopyChunk...%08lx %08lx\n", RxContext, Status));
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\agntevnt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    AgntEvnt.c

Abstract:

    This module implements the interface by which the csc driver reports
    stuff to the agent.

Author:

    Joe Linn [JoeLinn]    5-may-1997

Revision History:

Notes:

Additional synchronization surrounds net_start and net_stop. for netstop, we
have to wait for the agent to signal that he is finished before we can proceed.
we probably we should implement a mechanism by which he can refuse the
netstop. anyway this is done by recording the netstop context that is waiting
before signaling the event. the same sort of thing is true for netstart.
--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_MRXSMBCSC;
#define Dbg (DEBUG_TRACE_MRXSMBCSC)

// A global variable which indicates the current status of the net
// TRUE implies available. This is used in controlling the
// transitioning indication to the agent
LONG CscNetPresent = FALSE;
LONG CscAgentNotifiedOfNetStatusChange = CSC_AGENT_NOT_NOTIFIED;
LONG CscAgentNotifiedOfFullCache = CSC_AGENT_NOT_NOTIFIED;

PKEVENT MRxSmbAgentSynchronizationEvent = NULL;
ULONG MRxSmbAgentSynchronizationEventIdx = 0;
PKEVENT MRxSmbAgentFillEvent = NULL;
PRX_CONTEXT MRxSmbContextAwaitingAgent = NULL;
PRX_CONTEXT MRxSmbContextAwaitingFillAgent = NULL;
LONG    vcntTransportsForCSC=0;
extern ULONG CscSessionIdCausingTransition;

//CODE.IMPROVEMENT.NTIFS had to just know to do this......
extern POBJECT_TYPE *ExEventObjectType;

//CODE.IMPROVEMENT.NTIFS just stole this from oak\in\zwapi.h
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

typedef struct _MRXSMBCSC_OPENEVENT_POSTCONTEXT {
    KEVENT PostEvent;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
} MRXSMBCSC_OPENEVENT_POSTCONTEXT, *PMRXSMBCSC_OPENEVENT_POSTCONTEXT;

VOID
MRxSmbCscOpenAgentEvent (
    BOOLEAN PostedCall);

VOID
MRxSmbCscOpenAgentFillEvent (
    BOOLEAN PostedCall);

NTSTATUS
MRxSmbCscOpenAgentEventPostWrapper(
    IN OUT PMRXSMBCSC_OPENEVENT_POSTCONTEXT OpenEventPostContext
    )
{

    RxDbgTrace( 0, Dbg, ("MRxSmbCscOpenAgentEventPostWrapper entry\n"));

    MRxSmbCscOpenAgentEvent(TRUE);

    RxDbgTrace( 0, Dbg, ("MRxSmbCscOpenAgentEventPostWrapper exit\n"));

    KeSetEvent( &OpenEventPostContext->PostEvent, 0, FALSE );
    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbCscOpenAgentFillEventPostWrapper(
    IN OUT PMRXSMBCSC_OPENEVENT_POSTCONTEXT OpenFillEventPostContext
    )
{

    RxDbgTrace( 0, Dbg, ("MRxSmbCscOpenAgentFillEventPostWrapper entry\n"));

    MRxSmbCscOpenAgentFillEvent(TRUE);

    RxDbgTrace( 0, Dbg, ("MRxSmbCscOpenAgentFillEventPostWrapper exit\n"));

    KeSetEvent( &OpenFillEventPostContext->PostEvent, 0, FALSE );
    return(STATUS_SUCCESS);
}

VOID
MRxSmbCscOpenAgentEvent (
    BOOLEAN PostedCall
    )
/*++

Routine Description:

   This routine gets a pointer to the agent's event.

Arguments:

Return Value:

Notes:

    The shadowcrit serialization mutex must have already been acquired before the call.

--*/
{
    NTSTATUS Status;
    HANDLE EventHandle;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR SessEventName[100];
    WCHAR IdBuffer[16];
    UNICODE_STRING IdString;

    ASSERT (MRxSmbAgentSynchronizationEvent == NULL);

    // DbgPrint("MRxSmbCscOpenAgentEvent(%d) Caused by sess 0x%x\n",
    //                 PostedCall,
    //                 CscSessionIdCausingTransition);

    if (PsGetCurrentProcess()!= RxGetRDBSSProcess()) {
        //CODE.IMPROVEMENT we should capture the rdbss process
        //  and avoid this call (RxGetRDBSSProcess)
        NTSTATUS PostStatus;
        MRXSMBCSC_OPENEVENT_POSTCONTEXT PostContext;

        ASSERT(!PostedCall);

        KeInitializeEvent(&PostContext.PostEvent,
                          NotificationEvent,
                          FALSE );

        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(PostContext.WorkQueueItem);i+=sizeof(ULONG)) {
                PBYTE BytePtr = ((PBYTE)&PostContext.WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         &PostContext.WorkQueueItem,
                         MRxSmbCscOpenAgentEventPostWrapper,
                         &PostContext);

        ASSERT(PostStatus == STATUS_SUCCESS);


        KeWaitForSingleObject( &PostContext.PostEvent,
                               Executive, KernelMode, FALSE, NULL );

        return;
    }

    // Build an event name with the session id at the end
    wcscpy(SessEventName, SESSION_EVENT_NAME_NT);
    wcscat(SessEventName, L"_");
    EventName.Buffer = SessEventName;
    EventName.Length = wcslen(SessEventName) * sizeof(WCHAR);
    EventName.MaximumLength = sizeof(SessEventName);
    IdString.Buffer = IdBuffer;
    IdString.Length = 0;
    IdString.MaximumLength = sizeof(IdBuffer);
    RtlIntegerToUnicodeString(CscSessionIdCausingTransition, 10, &IdString);
    RtlAppendUnicodeStringToString(&EventName, &IdString);

    // DbgPrint("MRxSmbCscOpenAgentEvent: SessEventName = %wZ\n", &EventName);

    InitializeObjectAttributes( &ObjectAttributes,
                                &EventName,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    Status = ZwOpenEvent( &EventHandle,
                         EVENT_ALL_ACCESS,
                         &ObjectAttributes
                         );
    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent no event %08lx\n",Status));
        return;
    }

    Status = ObReferenceObjectByHandle( EventHandle,
                                        0,
                                        *ExEventObjectType,
                                        KernelMode,
                                        (PVOID *) &MRxSmbAgentSynchronizationEvent,
                                        NULL );

    MRxSmbAgentSynchronizationEventIdx = CscSessionIdCausingTransition;

    ZwClose(EventHandle);

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent couldn't reference %08lx\n", Status));
        MRxSmbAgentSynchronizationEvent = NULL;
        MRxSmbAgentSynchronizationEventIdx = 0;
        return;
    }

    return;
}

NTSTATUS
MRxSmbCscSignalAgent (
    PRX_CONTEXT RxContext OPTIONAL,
    ULONG  Controls
    )
/*++

Routine Description:

   This routine signals the csc usermode agent using the appropriate event.

Arguments:

    RxContext - the RDBSS context. if this is provided then the context is
                as the guy who is waiting.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    The shadowcrit serialization mutex must have already been acquired before the call.
    We will drop it here.


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN ShadowCritEntered = TRUE; //must be in critsect on
    BOOLEAN PreventLeaveCrit = BooleanFlagOn(Controls,SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscSignalAgent entry...%08lx\n",RxContext));

    DbgDoit(ASSERT(vfInShadowCrit));
    ASSERT(MRxSmbIsCscEnabled);

    if (!FlagOn(Controls,SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT)) {
        if (hthreadReint==0) {
            //no agent and no force...just get out
            RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent no agent/noforce %08lx\n", RxContext));
            goto FINALLY;
        }
    }

    if (
        MRxSmbAgentSynchronizationEvent != NULL
            &&
        MRxSmbAgentSynchronizationEventIdx != CscSessionIdCausingTransition
    ) {
        ObDereferenceObject(MRxSmbAgentSynchronizationEvent);
        MRxSmbAgentSynchronizationEvent = NULL;
        MRxSmbAgentSynchronizationEventIdx = 0;
    }

    if (MRxSmbAgentSynchronizationEvent == NULL) {
        MRxSmbCscOpenAgentEvent(FALSE); //FALSE==>not a posted call
        if (MRxSmbAgentSynchronizationEvent == NULL) {
            //still NULL...no agent.........
            RxDbgTrace(0, Dbg, ("MRxSmbCscSignalAgent no event %08lx %08lx\n",
                               RxContext,Status));
            Status = STATUS_SUCCESS;
            goto FINALLY;
        }
    }

    if (RxContext != NULL) {
        MRxSmbContextAwaitingAgent = RxContext;
    }

    if (!PreventLeaveCrit) {
        LeaveShadowCrit();
        ShadowCritEntered = FALSE;
    } else {
        ASSERT(RxContext==NULL); //cant wait with critsect held
    }

    // reduce the window of MRxSmbAgentSynchronizationEvent getting nulled out
    // by explictly checking before pulsing
    if (MRxSmbAgentSynchronizationEvent)
    {
        KeSetEvent(MRxSmbAgentSynchronizationEvent,0,FALSE);
    }

    if (RxContext != NULL) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent waiting %08lx\n", RxContext));
        RxWaitSync(RxContext);
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent end of wait %08lx\n", RxContext));
    }

    RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent %08lx\n", RxContext));

FINALLY:
    if (ShadowCritEntered && !PreventLeaveCrit) {
        LeaveShadowCrit();
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscSignalAgent... exit %08lx %08lx\n",
              RxContext, Status));
    return(Status);
}

VOID
MRxSmbCscSignalNetStatus(
    BOOLEAN NetPresent,
    BOOLEAN fFirstLast
    )
{
    if(!MRxSmbIsCscEnabled) {
        return;
    }

    if (NetPresent)
    {
        InterlockedIncrement(&vcntTransportsForCSC);
    }
    else
    {
        if(vcntTransportsForCSC == 0)
        {
            DbgPrint("CSC:Mismatched transport departure messages from mini redir \n");
            return;
        }
        InterlockedDecrement(&vcntTransportsForCSC);
    }

    if (!fFirstLast)
    {
        return;
    }

    InterlockedExchange(
        &CscNetPresent,
        NetPresent);

    InterlockedExchange(
        &CscAgentNotifiedOfNetStatusChange,
        CSC_AGENT_NOT_NOTIFIED);

    CscNotifyAgentOfNetStatusChangeIfRequired(FALSE);
}

VOID
CscNotifyAgentOfNetStatusChangeIfRequired(
    BOOLEAN fInvokeAutoDial
    )
{
    LONG AgentNotificationState;

    AgentNotificationState = InterlockedExchange(
                                 &CscAgentNotifiedOfNetStatusChange,
                                 CSC_AGENT_NOTIFIED);

    if (AgentNotificationState == CSC_AGENT_NOT_NOTIFIED) {
        EnterShadowCrit();   //this is dropped in the signalagent routine....

        if (CscNetPresent) {
            SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_GOT_NET);
        } else {
            SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_NO_NET);
            if (fInvokeAutoDial)
            {
                SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_INVOKE_AUTODIAL);
            }

        }

        MRxSmbCscSignalAgent(
            NULL,
            SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);
    }
}

VOID
CscNotifyAgentOfFullCacheIfRequired(
    VOID)
{
    // DbgPrint("CscNotifyAgentOfFullCacheIfRequired()\n");

    if (MRxSmbAgentSynchronizationEvent == NULL) {
        MRxSmbCscOpenAgentEvent(FALSE); //FALSE==>not a posted call
        if (MRxSmbAgentSynchronizationEvent == NULL) {
            RxDbgTrace(0, Dbg, ("MRxSmbCscSignalAgent no event %08lx %08lx\n"));
            // DbgPrint("CscNotifyAgentOfFullCacheIfRequired exit no event\n");
            return;
        }
    }

    SetFlag(sGS.uFlagsEvents, FLAG_GLOBALSTATUS_INVOKE_FREESPACE);

    if (MRxSmbAgentSynchronizationEvent)
        KeSetEvent(MRxSmbAgentSynchronizationEvent,0,FALSE);

    // DbgPrint("CscNotifyAgentOfFullCacheIfRequired exit\n");
}

//CODE.IMPROVEMENT.ASHAMED...the next two routines are virtually identical; also there's
// a lot of very similar codein the third
VOID
MRxSmbCscAgentSynchronizationOnStart (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine signals the csc usermode agent that a start is occurring.
   By passing the context to the signal routine, we indicate that we want
   to wait for an external guy (in this case ioctl_register_start) to signal us
   tro proceed

Arguments:

    RxContext - the RDBSS context.

Return Value:


Notes:


--*/
{
#if 0
    NTSTATUS Status;

    if(!MRxSmbIsCscEnabled) {
        return;
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbCscAgentSynchronizationOnStart entry...%08lx\n",RxContext));

    EnterShadowCrit();   //this is dropped in the signalagent routine....

    // check if an agent is already registered
    // if he is then we don't need to do any of this stuff

    if (!hthreadReint)
    {
        SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_START);

        Status = MRxSmbCscSignalAgent(RxContext,
                                  SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);
    }
    else
    {
        LeaveShadowCrit();
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscAgentSynchronizationOnStart...%08lx %08lx\n",
              RxContext, Status));
#endif
    return;

}


VOID
MRxSmbCscAgentSynchronizationOnStop (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine signals the csc usermode agent that a stop is occurring.
   By passing the context to the signal routine, we indicate that we want
   to wait for an external guy (in this case ioctl_register_stop) to signal us
   tro proceed

Arguments:

    RxContext - the RDBSS context.

Return Value:


Notes:


--*/
{
#if 0
    NTSTATUS Status;

    if(!MRxSmbIsCscEnabled) {
        return;
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbCscAgentSynchronizationOnStop entry...%08lx\n",RxContext));

    EnterShadowCrit();   //this is dropped in the signalagent routine....

    if (hthreadReint)
    {
        SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_STOP);

        Status = MRxSmbCscSignalAgent(RxContext,0); //0 means no special operations
    }
    else
    {
        LeaveShadowCrit();
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscAgentSynchronizationOnStop...%08lx %08lx\n",
              RxContext, Status));
#endif
    return;
}


VOID
MRxSmbCscReleaseRxContextFromAgentWait (
    void
    )
/*++

Routine Description:

   This routine checks to see if there is a context waiting for the agent. If so,
   it signals the context's syncevent. It also clears the specified flags.

Arguments:

    RxContext - the RDBSS context.

Return Value:


Notes:


--*/
{
    PRX_CONTEXT WaitingContext;
    RxDbgTrace(+1, Dbg, ("MRxSmbCscReleaseRxContextFromAgentWait entry...%08lx\n"));

    ASSERT(MRxSmbIsCscEnabled);
    EnterShadowCrit();

    WaitingContext = MRxSmbContextAwaitingAgent;
    MRxSmbContextAwaitingAgent = NULL;

    LeaveShadowCrit();

    if (WaitingContext != NULL) {
        RxSignalSynchronousWaiter(WaitingContext);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscReleaseRxContextFromAgentWait...%08lx\n"));
    return;
}

//CODE.IMPROVEMENT get this in an include file
extern ULONG MRxSmbCscNumberOfShadowOpens;
extern ULONG MRxSmbCscActivityThreshold;

VOID
MRxSmbCscReportFileOpens (
    void
    )
/*++

Routine Description:

   This routine checks to see if there has been enough activity to signal
   the agent to recompute reference priorities.

Arguments:

Return Value:


Notes:


--*/
{
    NTSTATUS Status;
    RxDbgTrace(+1, Dbg, ("MRxSmbCscReportFileOpens entry...%08lx %08lx\n",
           MRxSmbCscNumberOfShadowOpens,(ULONG)(sGS.cntFileOpen) ));

    EnterShadowCrit();   //this is dropped in the signalagent routine....

    MRxSmbCscNumberOfShadowOpens++;

    if ((MRxSmbCscNumberOfShadowOpens > (ULONG)(sGS.cntFileOpen) )   // to guard against rollover
          &&  ((MRxSmbCscNumberOfShadowOpens - (ULONG)(sGS.cntFileOpen))
                                    < MRxSmbCscActivityThreshold)) {
        RxDbgTrace(-1, Dbg, ("MRxSmbCscReportFileOpens inactive...\n"));
        LeaveShadowCrit();
        return;
    }

    //SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_START);
    sGS.cntFileOpen = MRxSmbCscNumberOfShadowOpens;

    Status = MRxSmbCscSignalAgent(NULL,0);   //this means don't wait for a repsonse

    RxDbgTrace(-1, Dbg, ("MRxSmbCscReportFileOpens...activeexit\n"));
    return;
}

NTSTATUS
MRxSmbCscSignalFillAgent(
    PRX_CONTEXT RxContext OPTIONAL,
    ULONG  Controls)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN ShadowCritEntered = TRUE; //must be in critsect on
    BOOLEAN PreventLeaveCrit = BooleanFlagOn(Controls,SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscSignalFillAgent entry...%08lx\n",RxContext));

    // DbgPrint("MRxSmbCscSignalFillAgent entry...%08lx\n",RxContext);

    ASSERT(MRxSmbIsCscEnabled);

    if (!FlagOn(Controls,SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT)) {
        if (hthreadReint==0) {
            //no agent and no force...just get out
            RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent no agent/noforce %08lx\n", RxContext));
            goto FINALLY;
        }
    }

    if (MRxSmbAgentFillEvent == NULL) {
        // DbgPrint("MRxSmbCscSignalFillAgent: gotta open the event...\n");
        MRxSmbCscOpenAgentFillEvent(FALSE); //FALSE==>not a posted call
        if (MRxSmbAgentFillEvent == NULL) {
            //still NULL...no agent.........
            RxDbgTrace(0, Dbg, ("MRxSmbCscSignalFillAgent no event %08lx %08lx\n",
                               RxContext,Status));
            // DbgPrint("MRxSmbCscSignalFillAgent no event %08lx %08lx\n");
            Status = STATUS_SUCCESS;
            goto FINALLY;
        }
    }

    if (RxContext != NULL) {
        MRxSmbContextAwaitingFillAgent = RxContext;
    }

    // if (!PreventLeaveCrit) {
    //     LeaveShadowCrit();
    //     ShadowCritEntered = FALSE;
    // } else {
    //     ASSERT(RxContext==NULL); //cant wait with critsect held
    // }

    // reduce the window of MRxSmbAgentFillEvent getting nulled out
    // by explictly checking before pulsing

    if (MRxSmbAgentFillEvent) {
        KeSetEvent(MRxSmbAgentFillEvent,0,FALSE);
    }

    if (RxContext != NULL) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent waiting %08lx\n", RxContext));
        RxWaitSync(RxContext);
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent end of wait %08lx\n", RxContext));
    }

    RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent %08lx\n", RxContext));

FINALLY:
    // if (ShadowCritEntered && !PreventLeaveCrit) {
    //     LeaveShadowCrit();
    // }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscSignalFillAgent... exit %08lx %08lx\n",
              RxContext, Status));

    // DbgPrint("MRxSmbCscSignalFillAgent... exit %08lx %08lx\n", Status);

    return(Status);
}

VOID
MRxSmbCscOpenAgentFillEvent (
    BOOLEAN PostedCall)
{
    NTSTATUS Status;
    HANDLE EventHandle;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    if (PsGetCurrentProcess()!= RxGetRDBSSProcess()) {
        //CODE.IMPROVEMENT we should capture the rdbss process
        //  and avoid this call (RxGetRDBSSProcess)
        NTSTATUS PostStatus;
        MRXSMBCSC_OPENEVENT_POSTCONTEXT PostContext;

        ASSERT(!PostedCall);

        // DbgPrint("MRxSmbCscOpenAgentFillEvent: posting...\n");

        KeInitializeEvent(&PostContext.PostEvent,
                          NotificationEvent,
                          FALSE );

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         &PostContext.WorkQueueItem,
                         MRxSmbCscOpenAgentFillEventPostWrapper,
                         &PostContext);

        ASSERT(PostStatus == STATUS_SUCCESS);


        KeWaitForSingleObject( &PostContext.PostEvent,
                               Executive, KernelMode, FALSE, NULL );

        // DbgPrint("MRxSmbCscOpenAgentFillEvent: posting done...\n");

        return;
    }

    RtlInitUnicodeString(&EventName,SHARED_FILL_EVENT_NAME_NT);
    InitializeObjectAttributes( &ObjectAttributes,
                                &EventName,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    Status = ZwOpenEvent( &EventHandle,
                         EVENT_ALL_ACCESS,
                         &ObjectAttributes);

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent no event %08lx\n",Status));
        DbgPrint("MRxSmbCscSignalFillAgent no event %08lx\n",Status);
        return;
    }

    Status = ObReferenceObjectByHandle( EventHandle,
                                        0,
                                        *ExEventObjectType,
                                        KernelMode,
                                        (PVOID *) &MRxSmbAgentFillEvent,
                                        NULL );

    ZwClose(EventHandle);

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent couldn't reference %08lx\n", Status));
        DbgPrint("MRxSmbCscSignalFillAgent couldn't reference %08lx\n", Status);
        MRxSmbAgentFillEvent = NULL;
        return;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\dconnect.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DConnect.c

Abstract:

    This module implements the routines by which the a server\share comes
    up in a disconnected state.

Author:

    Joe Linn [JoeLinn]    5-may-1997

Revision History:

    Shishir Pardikar(shishirp)      Various bug fixes   Aug 1997 onwards

    Shishir Pardikar(shishirp)      Change Notification In disconnected state 27-aug-1998

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifdef MRXSMB_BUILD_FOR_CSC_DCON
extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_MRXSMBCSC;
#define Dbg (DEBUG_TRACE_MRXSMBCSC)

WCHAR   wchSingleBackSlash = '\\';
UNICODE_STRING  vRootString = {2,2,&wchSingleBackSlash};     // root string for change notification

WCHAR   vtzOfflineVolume[] = L"Offline";

typedef struct tagNOTIFYEE_FOBX
{
    LIST_ENTRY  NextNotifyeeFobx;
    MRX_FOBX       *pFobx;
}
NOTIFYEE_FOBX, *PNOTIFYEE_FOBX;

PNOTIFYEE_FOBX
PIsFobxInTheList(
    PLIST_ENTRY pNotifyeeFobxList,
    PMRX_FOBX       pFobx
    );

BOOL
FCleanupAllNotifyees(
    PNOTIFY_SYNC pNotifySync,
    PLIST_ENTRY pDirNotifyList,
    PLIST_ENTRY pNotifyeeFobxList,
    PFAST_MUTEX pNotifyeeFobxListMutex
    );

PMRX_SMB_FCB
MRxSmbCscRecoverMrxFcbFromFdb (
    IN PFDB Fdb
    );

NTSTATUS
MRxSmbCscNegotiateDisconnected(
    PSMBCEDB_SERVER_ENTRY   pServerEntry
    )

/*++

Routine Description:

   This routine takes the place of negotiating when the special tranport marker
   has been detected in the negotiate routine.

Arguments:


Return Value:


Notes:


--*/
{
    NTSTATUS Status;

    RxDbgTrace(0,Dbg,("MRxSmbCscNegotiateDisconnected %08lx %08lx\n",
                pServerEntry, pServerEntry->pTransport));
    if (MRxSmbIsCscEnabledForDisconnected) {

        pServerEntry->ServerStatus = STATUS_SUCCESS;

        SmbCeUpdateServerEntryState(
                            pServerEntry,
                            SMBCEDB_ACTIVE);

        //no need for anyting else!
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_HOST_UNREACHABLE;
    }

    return Status;
}

NTSTATUS
MRxSmbCscDisconnectedConnect (
    IN OUT PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange
    )
/*++

Routine Description:

   This routine takes the place of connecting when we're doing disconnected
   mode. what we do is to simulate what would happen if the exchange had come thru
   ParseSmbHeader.

Arguments:


Return Value:


Notes:


--*/
{
    NTSTATUS Status = STATUS_PENDING;
    BOOLEAN PostFinalize;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;
//    PSMBCEDB_SESSION_ENTRY  pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    SMBCEDB_OBJECT_STATE SessionState;
    SMBCEDB_OBJECT_STATE NetRootState;

    PMRX_V_NET_ROOT VNetRoot;
    PMRX_NET_ROOT   NetRoot;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    CSC_SHARE_HANDLE  hShare;
    CSC_SHADOW_HANDLE  hRootDir,hShadow;


    PRX_CONTEXT RxContext = pNetRootExchange->pCreateNetRootContext->RxContext;

    VNetRoot = pNetRootExchange->SmbCeContext.pVNetRoot;
    NetRoot  = VNetRoot->pNetRoot;

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(VNetRoot);

    pServerEntry  = SmbCeGetExchangeServerEntry(&pNetRootExchange->Exchange);
//    pSessionEntry = SmbCeGetExchangeSessionEntry(&pNetRootExchange->Exchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(&pNetRootExchange->Exchange);

    if ((NetRoot->Type == NET_ROOT_DISK) ||
        (NetRoot->Type == NET_ROOT_WILD)) {

        ASSERT(MRxSmbIsCscEnabledForDisconnected);

        RxDbgTrace(0,Dbg,("MRxSmbCscDisconnectedConnect %08lx %08lx\n",
                    pServerEntry, pServerEntry->pTransport));

        // init netrootentry. This will be inited by the ObtainShareHandles call
        pNetRootEntry->NetRoot.CscEnabled = TRUE;       // assume csc is enabled
        pNetRootEntry->NetRoot.CscShadowable = FALSE;   // ACHTUNG, don't set this to TRUE
                                                        // otherwise a share will get created
                                                        // in disconnectd state
        

        pNetRootEntry->NetRoot.NetRootType = NET_ROOT_DISK;

        hShare = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
        if (hShare==0) {
            NTSTATUS LocalStatus;
            EnterShadowCrit();
            LocalStatus = MRxSmbCscObtainShareHandles(
                              NetRoot->pNetRootName,
                              TRUE,
                              FALSE,
                              SmbCeGetAssociatedNetRootEntry(NetRoot)
                              );
            if (LocalStatus != STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg,
                    ("MRxSmbCscDisconnectedConnect no server handle -> %08xl %08lx\n",
                        RxContext,LocalStatus ));
            } else {
                hShare = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
            }
            LeaveShadowCrit();
        }
    } else {
        hShare = 0;
    }

    //ok, we have to do everything that parsesmbheader would have done

    if (hShare==0) {
        //can't find it in the table......just fail........
        pNetRootExchange->Status = STATUS_BAD_NETWORK_NAME;
//        SessionState = SMBCEDB_INVALID;
        NetRootState = SMBCEDB_MARKED_FOR_DELETION;
    } else {
        pNetRootExchange->Status = STATUS_SUCCESS;
        pNetRootExchange->SmbStatus = STATUS_SUCCESS;


//        SessionState = SMBCEDB_ACTIVE;

        //NETROOT STUFF
        //some of the netroot stuff is earlier....before the lookup
        NetRootState = SMBCEDB_ACTIVE;
    }

#if 0
    SmbCeUpdateSessionEntryState(
        pSessionEntry,
        SessionState);
#endif

    SmbCeUpdateVNetRootContextState(
        pVNetRootContext,
        NetRootState);

    SmbConstructNetRootExchangeFinalize(
        &pNetRootExchange->Exchange,
        &PostFinalize);

    ASSERT(!PostFinalize);
    return Status;
}

typedef struct _MRXSMBCSC_QUERYDIR_INFO {
    WCHAR Pattern[2];
    FINDSHADOW sFS;
    ULONG uShadowStatus;
    _WIN32_FIND_DATA Find32;
    ULONG NumCallsSoFar;
    BOOLEAN IsNonEmpty;
} MRXSMBCSC_QUERYDIR_INFO, *PMRXSMBCSC_QUERYDIR_INFO;

NTSTATUS
MRxSmbCscLoadNextDirectoryEntry(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRXSMBCSC_QUERYDIR_INFO QuerydirInfo,
    OUT LPHSHADOW hShadowp
    )
{
    NTSTATUS Status;
    int iRet;
    HSHADOW hTmp=0; //???

    if (QuerydirInfo->NumCallsSoFar <= 1)
    {
        iRet = GetAncestorsHSHADOW(QuerydirInfo->sFS.hDir, &hTmp, NULL);

        if (iRet >= SRET_OK)
        {
            iRet = GetShadowInfo(hTmp,
                                QuerydirInfo->sFS.hDir,
                                &QuerydirInfo->Find32,
                                &QuerydirInfo->uShadowStatus,
                                NULL
                                );
            if (iRet >= SRET_OK)
            {

                if (QuerydirInfo->NumCallsSoFar == 0 )
                {
                    QuerydirInfo->Find32.cFileName[0] = (WCHAR)'.';
                    QuerydirInfo->Find32.cFileName[1] = 0;
                    QuerydirInfo->Find32.cAlternateFileName[0] = (WCHAR)'.';
                    QuerydirInfo->Find32.cAlternateFileName[1] = 0;
                }
                else
                {
                    QuerydirInfo->Find32.cFileName[0] = (WCHAR)'.';
                    QuerydirInfo->Find32.cFileName[1] = (WCHAR)'.';
                    QuerydirInfo->Find32.cFileName[2] = 0;
                    QuerydirInfo->Find32.cAlternateFileName[0] = (WCHAR)'.';
                    QuerydirInfo->Find32.cAlternateFileName[1] = (WCHAR)'.';
                    QuerydirInfo->Find32.cAlternateFileName[2] = 0;
                }


            }
        }
    }
    else if (QuerydirInfo->NumCallsSoFar == 2)
    {

        iRet = FindOpenHSHADOW(&QuerydirInfo->sFS,
                               &hTmp,
                               &QuerydirInfo->Find32,
                               &QuerydirInfo->uShadowStatus,
                               NULL);
    } else {
        iRet = FindNextHSHADOW(&QuerydirInfo->sFS,
                               &hTmp,
                               &QuerydirInfo->Find32,
                               &QuerydirInfo->uShadowStatus,
                               NULL);
    }


    if (iRet < SRET_OK)
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        if (QuerydirInfo->NumCallsSoFar >= 2)
        {
            if (hTmp)
            {
                *hShadowp = hTmp;
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = STATUS_NO_MORE_FILES;
            }
        }
        else
        {
            *hShadowp = hTmp;
            Status = STATUS_SUCCESS;
        }
    }


    QuerydirInfo->NumCallsSoFar++;
    QuerydirInfo->IsNonEmpty = (Status==STATUS_SUCCESS);

    return(Status);
}


NTSTATUS
MRxSmbDCscQueryDirectory (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;
    PFILE_DIRECTORY_INFORMATION pPreviousBuffer = NULL;

    PMRXSMBCSC_QUERYDIR_INFO QuerydirInfo;
    BOOLEAN EnteredCriticalSection = FALSE;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;

    ULONG EntriesReturned = 0;
    BOOLEAN IsResume = FALSE;

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (!Disconnected) {
        return (STATUS_CONNECTION_DISCONNECTED);
    }

    // if there is reumeinfo but it is not the one that CSC allocated,
    // we want to fail this find.

    if (smbFobx->Enumeration.ResumeInfo &&
        !FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_IS_CSC_SEARCH))
    {
        return (STATUS_NO_MORE_FILES);
    }

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscQueryDirectory entry(%08lx)...%08lx %08lx %08lx %08lx\n",
            RxContext,
            FileInformationClass,pBuffer,*pLengthRemaining,
            smbFobx->Enumeration.ResumeInfo ));

    if (smbFobx->Enumeration.ResumeInfo == NULL) {
        PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;

        if (smbFobx->Enumeration.WildCardsFound = FsRtlDoesNameContainWildCards(Template)){
            //we need an upcased template for
            RtlUpcaseUnicodeString( Template, Template, FALSE );
        }

        //allocate and initialize the structure
        QuerydirInfo = (PMRXSMBCSC_QUERYDIR_INFO)RxAllocatePoolWithTag(
                                                      PagedPool,
                                                      sizeof(MRXSMBCSC_QUERYDIR_INFO),
                                                      MRXSMB_DIRCTL_POOLTAG);
        if (QuerydirInfo==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the QuerydirInfo!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_IS_CSC_SEARCH;

        smbFobx->Enumeration.ResumeInfo = (PMRX_SMB_DIRECTORY_RESUME_INFO)QuerydirInfo;
        RtlZeroMemory(QuerydirInfo,sizeof(*QuerydirInfo));
        QuerydirInfo->Pattern[0] = L'*'; //[1] is already null

        QuerydirInfo->sFS.hDir = smbFcb->hShadow;

        QuerydirInfo->sFS.uSrchFlags = FLAG_FINDSHADOW_META
                                         |FLAG_FINDSHADOW_ALLOW_NORMAL
                                         |FLAG_FINDSHADOW_NEWSTYLE;

        QuerydirInfo->sFS.uAttrib = 0xffffffff;
        QuerydirInfo->sFS.lpPattern = &QuerydirInfo->Pattern[0];
        QuerydirInfo->sFS.lpfnMMProc = FsobjMMProc;

    } else {
        QuerydirInfo = (PMRXSMBCSC_QUERYDIR_INFO)(smbFobx->Enumeration.ResumeInfo);
        ASSERT(FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_IS_CSC_SEARCH));
        IsResume = TRUE;
    }

    EnterShadowCrit();
    EnteredCriticalSection = TRUE;

    for (;;) {
        NTSTATUS LoadStatus;
        BOOLEAN FilterFailure;
        UNICODE_STRING FileName,AlternateFileName;
        ULONG SpaceNeeded;
        PBYTE pRememberBuffer;
        _WIN32_FIND_DATA *Find32 = &QuerydirInfo->Find32;
        BOOLEAN BufferOverflow;
        HSHADOW hShadow = 0;

        if (!QuerydirInfo->IsNonEmpty) {
            LoadStatus = MRxSmbCscLoadNextDirectoryEntry(RxContext,QuerydirInfo, &hShadow);
            if (LoadStatus!=STATUS_SUCCESS) {
                smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_IS_CSC_SEARCH;
                Status = (EntriesReturned==0)?STATUS_NO_MORE_FILES:STATUS_SUCCESS;
                if (EntriesReturned > 0)
                    Status = STATUS_SUCCESS;
                else
                    Status = (IsResume == TRUE) ? STATUS_NO_MORE_FILES : STATUS_NO_SUCH_FILE;
                goto FINALLY;
            }
        }

        RxDbgTrace(0, Dbg,
            ("MRxSmbDCscQueryDirectory (%08lx)...qdiryaya <%ws>\n",
                RxContext,
                &QuerydirInfo->Find32.cFileName[0] ));
        RtlInitUnicodeString(&FileName,&QuerydirInfo->Find32.cFileName[0]);
        RtlInitUnicodeString(&AlternateFileName,&QuerydirInfo->Find32.cAlternateFileName[0]);
        RxDbgTrace(0, Dbg,
            ("MRxSmbDCscQueryDirectory (%08lx)...qdiryaya2 <%wZ><%wZ>|<%wZ>\n",
                RxContext,
                &FileName,&AlternateFileName,
                &capFobx->UnicodeQueryTemplate));

        FilterFailure = FALSE;

        if (smbFobx->Enumeration.WildCardsFound ) {
            try
            {
            
                FilterFailure = !FsRtlIsNameInExpression(
                                       &capFobx->UnicodeQueryTemplate,
                                       &FileName,
                                       TRUE,
                                       NULL );
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                FilterFailure = TRUE;
            }
        } else {
            FilterFailure = !RtlEqualUnicodeString(
                                   &capFobx->UnicodeQueryTemplate,
                                   &FileName,
                                   TRUE );   //case-insensitive
        }

        //check shortname
        if (FilterFailure) {
            if (smbFobx->Enumeration.WildCardsFound ) {
                try
                {
                    FilterFailure = !FsRtlIsNameInExpression(
                                           &capFobx->UnicodeQueryTemplate,
                                           &AlternateFileName,
                                           TRUE,
                                           NULL );
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    FilterFailure = TRUE;
                }
            } else {
                FilterFailure = !RtlEqualUnicodeString(
                                       &capFobx->UnicodeQueryTemplate,
                                       &AlternateFileName,
                                       TRUE );   //case-insensitive
            }
        }

        if (FilterFailure) {
            QuerydirInfo->IsNonEmpty = FALSE;
            continue;
        }

        //OK, we have an entry we'd like to return.....see if it will fit.

        pRememberBuffer = pBuffer;
        if (EntriesReturned != 0) {
            pBuffer = (PBYTE)QuadAlignPtr(pBuffer); //assume that this will fit
        }
        SpaceNeeded = smbFobx->Enumeration.FileNameOffset+FileName.Length;

        RxDbgTrace(0, Dbg,
            ("MRxSmbDCscQueryDirectory (%08lx)...qdiryaya3 <%wZ><%wZ>|<%wZ> needs %08lx %08lx %08lx %08lx\n",
                RxContext,
                &FileName,&AlternateFileName,
                &capFobx->UnicodeQueryTemplate,
                pBuffer,SpaceNeeded,pRememberBuffer,*pLengthRemaining));

        if (pBuffer+SpaceNeeded > pRememberBuffer+*pLengthRemaining) {

            //buffer overflow on this enrty....
            //pBuffer = pRememberBuffer; //rollback
            Status = (EntriesReturned==0)?STATUS_BUFFER_OVERFLOW:STATUS_SUCCESS;
            goto FINALLY;

        } else {
            PFILE_DIRECTORY_INFORMATION pThisBuffer = (PFILE_DIRECTORY_INFORMATION)pBuffer;

            if (pPreviousBuffer != NULL) {
                pPreviousBuffer->NextEntryOffset = (ULONG)(((PBYTE)pThisBuffer)-((PBYTE)pPreviousBuffer));
            }
            pPreviousBuffer = pThisBuffer;
            RtlZeroMemory(pBuffer,smbFobx->Enumeration.FileNameOffset);
            RtlCopyMemory(pBuffer+smbFobx->Enumeration.FileNameOffset,
                          FileName.Buffer,
                          FileName.Length);
            *((PULONG)(pBuffer+smbFobx->Enumeration.FileNameLengthOffset)) = FileName.Length;
            //hallucinate the record based on specific return type
            switch (FileInformationClass) {
            case FileNamesInformation:
                break;

            case FileBothDirectoryInformation:{
                PFILE_BOTH_DIR_INFORMATION pThisBufferAsBOTH
                                   = (PFILE_BOTH_DIR_INFORMATION)pThisBuffer;

                //Do not copy more than size of shortname
				pThisBufferAsBOTH->ShortNameLength = min(sizeof(pThisBufferAsBOTH->ShortName),(CCHAR)(AlternateFileName.Length));
                RtlCopyMemory( &pThisBufferAsBOTH->ShortName[0],
                               AlternateFileName.Buffer,
                               pThisBufferAsBOTH->ShortNameLength );
                }
                //no break intentional

            case FileDirectoryInformation:
            case FileFullDirectoryInformation:
                //just fill what we have...
                pThisBuffer->FileAttributes = Find32->dwFileAttributes;
                COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                          pThisBuffer->CreationTime,
                          Find32->ftCreationTime);
                COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                          pThisBuffer->LastAccessTime,
                          Find32->ftLastAccessTime);
                COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                          pThisBuffer->LastWriteTime,
                          Find32->ftLastWriteTime);

                pThisBuffer->EndOfFile.HighPart = Find32->nFileSizeHigh;
                pThisBuffer->EndOfFile.LowPart = Find32->nFileSizeLow;
                pThisBuffer->AllocationSize = pThisBuffer->EndOfFile;

                if (IsLeaf(hShadow)) {
                    PFDB pFDB = MRxSmbCscFindFdbFromHShadow(hShadow);
                    if (pFDB != NULL) {
                        PMRX_SMB_FCB smbFcb = MRxSmbCscRecoverMrxFcbFromFdb(pFDB);
                        PMRX_FCB mrxFcb = smbFcb->ContainingFcb;

                        pThisBuffer->EndOfFile = mrxFcb->Header.FileSize;
                        pThisBuffer->AllocationSize = pThisBuffer->EndOfFile;
                    }
                }

                break;

            default:
               RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Invalid FS information class\n"));
               ASSERT(!"this can't happen");
               Status = STATUS_INVALID_PARAMETER;
               goto FINALLY;
            }
            pBuffer += SpaceNeeded;
            *pLengthRemaining -= (ULONG)(pBuffer-pRememberBuffer);
            EntriesReturned++;
            QuerydirInfo->IsNonEmpty = FALSE;
            if (RxContext->QueryDirectory.ReturnSingleEntry) {
                Status = STATUS_SUCCESS;
                goto FINALLY;
            }
        }


    }


FINALLY:

    if (EnteredCriticalSection) {
        LeaveShadowCrit();
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbDCscQueryDirectory exit-> %08lx %08lx\n", RxContext, Status ));
    return Status;
}

NTSTATUS
MRxSmbDCscGetFsSizeInfo (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine routes a fs size query to the underlying filesystem. It does
   this by opening a handle to the priorityqueue inode and uses this to route
   call. CODE.IMPROVEMENT.ASHAMED if the system is converted to use relative
   opens, then we should just use the relative open fileobject for this passthru.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    FS_INFORMATION_CLASS FsInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;
    ULONG PassedInLength,ReturnedLength;

    BOOLEAN CriticalSectionEntered = FALSE;

    PNT5CSC_MINIFILEOBJECT MiniFileObject;

    FsInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscGetFsSizeInfo entry(%08lx)...%08lx  %08lx %08lx\n",
            RxContext,
            FsInformationClass, pBuffer, *pLengthRemaining ));

    EnterShadowCrit();
    CriticalSectionEntered = TRUE;


    OpenFileHSHADOW(ULID_PQ,
                    0,
                    0,
                    (CSCHFILE *)(&MiniFileObject)
                    );

    if (MiniFileObject == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto FINALLY;
    }

    PassedInLength = *pLengthRemaining;
    //DbgBreakPoint();

    Status = Nt5CscXxxInformation(
                        (PCHAR)IRP_MJ_QUERY_VOLUME_INFORMATION,
                        MiniFileObject,
                        FsInformationClass,
                        PassedInLength,
                        pBuffer,
                        &ReturnedLength
                        );

    if (!NT_ERROR(Status)) {
        *pLengthRemaining -= ReturnedLength;
    }



FINALLY:
    if (MiniFileObject != NULL) {
        CloseFileLocal((CSCHFILE)(MiniFileObject));
    }

    if (CriticalSectionEntered) {
        LeaveShadowCrit();
    }


    RxDbgTrace(-1, Dbg, ("MRxSmbDCscGetFsSizeInfo exit-> %08lx %08lx %08lx %08lx\n",
                 RxContext, Status, ReturnedLength, *pLengthRemaining ));
    return Status;
}

NTSTATUS
MRxSmbDCscFlush (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a flush in disconnected mode. since we don't send
   a flush in disconnected mode and since we dont need to flush the shadow
   (since we use all unbuffered writes) we can just return SUCCESS.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (!SmbCeIsServerInDisconnectedMode(pServerEntry)) {
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbDCscQueryVolumeInformation (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a queryvolume in disconnected mode. it draws on
   the same philosphy as downlevel queryvolume.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
 
    FS_INFORMATION_CLASS FsInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;
    ULONG   LengthUsed;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;
    PSMBCE_NET_ROOT psmbNetRoot = &pNetRootEntry->NetRoot;

    Disconnected = SmbCeIsServerInDisconnectedMode(pServerEntry);

    if (!Disconnected) {
        return(STATUS_CONNECTION_DISCONNECTED);
    }

    FsInformationClass = RxContext->Info.FsInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscQueryVolumeInformation entry(%08lx)...%08lx  %08lx %08lx bytes @ %08lx %08lx %08lx\n",
            RxContext,
            FsInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    switch (FsInformationClass) {
    case FileFsAttributeInformation:
        //here, cause it to return the data from our tableentry in downlvli.c
        if (psmbNetRoot->FileSystemNameLength == 0) {
            //set our name
            psmbNetRoot->FileSystemNameLength = 14;
            psmbNetRoot->FileSystemName[0] = '*';
            psmbNetRoot->FileSystemName[1] = 'N';
            psmbNetRoot->FileSystemName[2] = 'T';
            psmbNetRoot->FileSystemName[3] = '5';
            psmbNetRoot->FileSystemName[4] = 'C';
            psmbNetRoot->FileSystemName[5] = 'S';
            psmbNetRoot->FileSystemName[6] = 'C';
        }
        psmbNetRoot->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES | FILE_UNICODE_ON_DISK;
        psmbNetRoot->MaximumComponentNameLength = 255;
        Status = MRxSmbGetFsAttributesFromNetRoot(RxContext);
        goto FINALLY;
        //no break needed because of gotofinally

    case FileFsVolumeInformation: {
        PFILE_FS_VOLUME_INFORMATION FsVolInfo = (PFILE_FS_VOLUME_INFORMATION)pBuffer;
        
        ASSERT(*pLengthRemaining >= sizeof(FILE_FS_VOLUME_INFORMATION));
        //here, we have no reliable information....return zeros
        FsVolInfo->VolumeCreationTime.QuadPart = 0;
        FsVolInfo->VolumeSerialNumber = 0;
        FsVolInfo->VolumeLabelLength = 0;
        FsVolInfo->SupportsObjects = FALSE;
        
        // calculate the size of the VolumeLabel we have and put it in a temp var
        LengthUsed = *pLengthRemaining - FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel[0]);

        LengthUsed = min(LengthUsed, sizeof(vtzOfflineVolume)-2);

        memcpy(FsVolInfo->VolumeLabel, vtzOfflineVolume, LengthUsed);
        FsVolInfo->VolumeLabelLength = LengthUsed;
        *pLengthRemaining -= (FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel[0])+LengthUsed);
        }
        goto FINALLY;
        //no break needed because of gotofinally

    case FileFsSizeInformation: case FileFsFullSizeInformation:
        //here, we route to the underlying filesystem
        Status = MRxSmbDCscGetFsSizeInfo(RxContext);
        goto FINALLY;
        //no break needed because of gotofinally

    case FileFsDeviceInformation:
        ASSERT(!"this should have been turned away");
        //no break;
    default:
        Status = STATUS_NOT_IMPLEMENTED;
        goto FINALLY;
    }


FINALLY:

    RxDbgTrace(-1, Dbg, ("MRxSmbDCscQueryVolumeInformation exit(%08lx %08lx)...%08lx  %08lx %08lx bytes @ %08lx\n",
            RxContext, Status,
            FsInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    return Status;
}

NTSTATUS
MRxSmbDCscQueryFileInfo (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a queryfileinfo in disconnected mode. because info buffering
   is enabled, it should never call down here! so we can just return STATUS_DISCONNECTED
   all the time!.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;
    PSMBCE_NET_ROOT psmbNetRoot = &pNetRootEntry->NetRoot;

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (!Disconnected) {
        PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

        if (pServerEntry->Header.State == SMBCEDB_ACTIVE) {
            return(STATUS_MORE_PROCESSING_REQUIRED);
        } else {
            return(STATUS_CONNECTION_DISCONNECTED);
        }
    }


    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscQueryFileInfo entry(%08lx)...%08lx  %08lx %08lx bytes @ %08lx %08lx %08lx\n",
            RxContext,
            FileInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    switch (FileInformationClass) {
    case FileBasicInformation:
        {
        PFILE_BASIC_INFORMATION Buffer = (PFILE_BASIC_INFORMATION)pBuffer;

        switch (NodeType(capFcb)) {
        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
        case RDBSS_NTC_STORAGE_TYPE_FILE:

            //copy in all the stuff that we know....it may be enough.....

            Buffer->ChangeTime     = pFileInfo->Basic.ChangeTime;
            Buffer->CreationTime   = pFileInfo->Basic.CreationTime;
            Buffer->LastWriteTime  = pFileInfo->Basic.LastWriteTime;
            Buffer->LastAccessTime = pFileInfo->Basic.LastAccessTime;
            Buffer->FileAttributes = pFileInfo->Basic.FileAttributes;

            if (FlagOn( capFcb->FcbState, FCB_STATE_TEMPORARY )) {
                SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
            }

            RxContext->Info.LengthRemaining -= sizeof(FILE_BASIC_INFORMATION);
            break;

        default:
            Status = STATUS_NOT_IMPLEMENTED;
        }
        }
        break;
    case FileStandardInformation:
        {
        PFILE_STANDARD_INFORMATION Buffer = (PFILE_STANDARD_INFORMATION)pBuffer;
        PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);

        switch (NodeType(capFcb)) {
        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
            Buffer->Directory = TRUE;
            RxContext->Info.LengthRemaining -= sizeof(FILE_STANDARD_INFORMATION);
            break;
        case RDBSS_NTC_STORAGE_TYPE_FILE:
            memset(Buffer, 0, sizeof(FILE_STANDARD_INFORMATION));
            Buffer->AllocationSize = smbFcb->NewShadowSize;
            Buffer->EndOfFile = smbFcb->NewShadowSize;
            RxContext->Info.LengthRemaining -= sizeof(FILE_STANDARD_INFORMATION);
            break;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
        }
        }
        break;
    case FileEaInformation:
        {
            PFILE_EA_INFORMATION EaBuffer = (PFILE_EA_INFORMATION)pBuffer;

            EaBuffer->EaSize = 0;
            RxContext->Info.LengthRemaining -= sizeof(FILE_EA_INFORMATION);
        }
        break;
    default:
        Status = STATUS_NOT_IMPLEMENTED;
    }

    RxDbgTrace(-1, Dbg,
        ("MRxSmbDCscQueryFileInfo exit(%08lx %08lx)...%08lx  %08lx %08lx bytes @ %08lx\n",
            RxContext, Status,
            FileInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    return Status;
}

NTSTATUS
MRxSmbDCscSetFileInfo (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a querydirectory in disconnected mode. it draws on
   the same philosphy as downlevel querydirectory.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;
    ULONG DummyReturnedLength;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;
    PSMBCE_NET_ROOT psmbNetRoot = &pNetRootEntry->NetRoot;
    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow);

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (!Disconnected) {
        return(STATUS_CONNECTION_DISCONNECTED);
    }

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscSetFileInfo entry(%08lx)...%08lx  %08lx %08lx bytes @ %08lx %08lx %08lx\n",
            RxContext,
            FileInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    switch (FileInformationClass) {
    case FileEndOfFileInformation:
    case FileAllocationInformation:
    case FileBasicInformation:
    case FileDispositionInformation:
        MRxSmbCscSetFileInfoEpilogue(RxContext,&Status);
        goto FINALLY;
    
    case FileRenameInformation:
        MRxSmbCscRenameEpilogue(RxContext,&Status);
        goto FINALLY;

    default:
        Status = STATUS_NOT_IMPLEMENTED;
        goto FINALLY;
    }

FINALLY:

    RxDbgTrace(-1, Dbg,
        ("MRxSmbDCscSetFileInfo exit(%08lx %08lx)...%08lx  %08lx %08lx bytes @ %08lx\n",
            RxContext, Status,
            FileInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    return Status;
}


NTSTATUS
MRxSmbDCscFsCtl(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a querydirectory in disconnected mode. it draws on
   the same philosphy as downlevel querydirectory.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
MRxSmbDCscIsValidDirectory(
    IN OUT PRX_CONTEXT     RxContext,
    IN     PUNICODE_STRING DirectoryName)
{
    NTSTATUS            Status;
    MRX_SMB_FCB         CscSmbFcb;
    WIN32_FIND_DATA     Find32;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(RxContext->Create.pNetRoot);
    memset(&(CscSmbFcb.MinimalCscSmbFcb), 0, sizeof(CscSmbFcb.MinimalCscSmbFcb));

    if (!pNetRootEntry->NetRoot.sCscRootInfo.hRootDir)
    {
        return STATUS_BAD_NETWORK_PATH;
    }

    EnterShadowCrit();

    Status = MRxSmbCscCreateShadowFromPath(
                DirectoryName,
                &(pNetRootEntry->NetRoot.sCscRootInfo),
                &Find32,
                NULL,
                (CREATESHADOW_CONTROL_NOCREATE |
                 CREATESHADOW_CONTROL_NOREVERSELOOKUP),
                &(CscSmbFcb.MinimalCscSmbFcb),
                RxContext,
                TRUE,
                NULL);

    if ((Status != STATUS_SUCCESS) ||
        !(Find32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        Status = STATUS_BAD_NETWORK_PATH;
    }

    LeaveShadowCrit();

    return Status;
}

NTSTATUS
MRxSmbCscNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext
      )

/*++

Routine Description:

    This routine sets a directory notification for a directory in disconnected state
    The smbmini makes this call when it notices that the serverentry is in disconnected state
    All change notifications are maintained in a list, so that when the server is being transitioned
    from offline to online, we can complete all of them.
    
    We use FOBX as the unique key for change notifications.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    If successfully registered a change notify, it returns STATUS_PENDING. It also
    hijacks the IRP and reduces the refcount on the RxContext, so that the wrapper
    will delete this rxcontext.

--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;
    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    BOOLEAN FcbAcquired = FALSE;
    ULONG CompletionFilter;
    BOOLEAN WatchTree;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PUNICODE_STRING pDirName=NULL;
    PNOTIFYEE_FOBX  pNF = NULL;

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);

    if (!RxIsFcbAcquiredExclusive(capFcb)) {
        ASSERT(!RxIsFcbAcquiredShared(capFcb));
        Status = RxAcquireExclusiveFcbResourceInMRx( capFcb );

        FcbAcquired = (Status == STATUS_SUCCESS);
    }

    CompletionFilter = pLowIoContext->ParamsFor.NotifyChangeDirectory.CompletionFilter;
    WatchTree = pLowIoContext->ParamsFor.NotifyChangeDirectory.WatchTree;

    if (!(((PFCB)capFcb)->PrivateAlreadyPrefixedName).Length)
    {
        pDirName = &vRootString;
    }
    else
    {
        pDirName = &(((PFCB)capFcb)->PrivateAlreadyPrefixedName);
    }
    //
    //  Call the Fsrtl package to process the request.
    //

    pNF = AllocMem(sizeof(NOTIFYEE_FOBX));

    if (!pNF)
    {
        return STATUS_INSUFFICIENT_RESOURCES;        
    }

    pNF->pFobx = capFobx;

    SmbCeLog(("chngnotify fobx=%x\n", capFobx));
    SmbLog(LOG,
           MRxSmbCscNotifyChangeDirectory,
           LOGPTR(capFobx));

//    DbgPrint("chngnotify %wZ fobx=%x NR=%x DirList=%x\n", pDirName, capFobx, pNetRootEntry, &pNetRootEntry->NetRoot.DirNotifyList);
    FsRtlNotifyFullChangeDirectory( pNetRootEntry->NetRoot.pNotifySync,
                                    &pNetRootEntry->NetRoot.DirNotifyList,
                                    capFobx,
                                    (PSTRING)pDirName,
                                    WatchTree,
                                    TRUE,
                                    CompletionFilter,
                                    RxContext->CurrentIrp,
                                    NULL,
                                    NULL
                                    );

    // attach this 
    ExAcquireFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);
    
    if (!PIsFobxInTheList(&pNetRootEntry->NetRoot.NotifyeeFobxList, capFobx))
    {
        InsertTailList(&pNetRootEntry->NetRoot.NotifyeeFobxList, &pNF->NextNotifyeeFobx);
    }
    else
    {
        FreeMem((PVOID)pNF);
    }

    ExReleaseFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);

    // as we hijacked the Irp, let us make sure that rdbss gets rid of the rxcontext
    RxContext->CurrentIrp = NULL;

    RxCompleteRequest_Real(RxContext, NULL, STATUS_PENDING);

    Status = STATUS_PENDING;

    if (FcbAcquired) {
        RxReleaseFcbResourceInMRx(capFcb );
    }

    return Status;

}

NTSTATUS
MRxSmbCscCleanupFobx(
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine cleans up a file system object.
   For CSC, the only thing we do is to remove changenotification.
Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    RxCaptureFcb;
    RxCaptureFobx;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    BOOLEAN fInList = FALSE;
    PNOTIFYEE_FOBX pNF = NULL;

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (MRxSmbCSCIsDisconnectedOpen(capFcb, MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen)))
    {
        ExAcquireFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);

        pNF = PIsFobxInTheList(&pNetRootEntry->NetRoot.NotifyeeFobxList, capFobx);

        if (pNF)
        {
            RemoveEntryList(&pNF->NextNotifyeeFobx);
            FreeMem(pNF);
            pNF = NULL;
            fInList = TRUE;
        }
        ExReleaseFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);

        if (fInList)
        {
            SmbCeLog(("chngnotify cleanup fobx=%x\n", capFobx));
            SmbLog(LOG,
                   MRxSmbCscCleanupFobx,
                   LOGPTR(capFobx));
//            DbgPrint("chngnotify Cleanup fobx=%x NR=%x DirList=%x\n", capFobx, pNetRootEntry, &pNetRootEntry->NetRoot.DirNotifyList);
            FsRtlNotifyCleanup (
                pNetRootEntry->NetRoot.pNotifySync,
                &pNetRootEntry->NetRoot.DirNotifyList,
                capFobx
                );
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbCscInitializeNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
    )
/*++

Routine Description:

    This routine initializes, the change notify structures in the netrootentry

Arguments:

Return Value:


--*/
{
        NTSTATUS NtStatus = STATUS_SUCCESS;

        try {
            FsRtlNotifyInitializeSync( &pNetRootEntry->NetRoot.pNotifySync );
        } except(EXCEPTION_EXECUTE_HANDLER) {
                NtStatus = GetExceptionCode();
        }
        if (NtStatus == STATUS_SUCCESS) {
            InitializeListHead( &pNetRootEntry->NetRoot.DirNotifyList );
            InitializeListHead( &pNetRootEntry->NetRoot.NotifyeeFobxList);
            ExInitializeFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);
        }
        return NtStatus;

}

VOID
MRxSmbCscUninitializeNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
    )
/*++

Routine Description:

    This routine unitializes, the change notify structures

Arguments:


Return Value:


--*/
{
        FsRtlNotifyUninitializeSync( &pNetRootEntry->NetRoot.pNotifySync );

}

BOOLEAN
MRxSmbCSCIsDisconnectedOpen(
    PMRX_FCB    pFcb,
    PMRX_SMB_SRV_OPEN smbSrvOpen
    )
/*++

Routine Description:

    A slightly more involved check to see whether this is a disconnected open.

Arguments:

Return Value:


--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(pFcb->pNetRoot->pSrvCall);
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(pFcb);

    if(BooleanFlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN))
    {
        return TRUE;
    }

    // we need to also check that the serverentry is non-NULL. This can happen when
    // you the syetem is about to shut down, or the FCB has been orphaned.
    
    if (pServerEntry && SmbCeIsServerInDisconnectedMode(pServerEntry))
    {
        if (smbFcb->hShadow || smbFcb->hShadowRenamed)
        {
            // is the shadow visible in disconnected state?
            return(IsShadowVisible(TRUE, smbFcb->dwFileAttributes, smbFcb->ShadowStatus) != 0);
        }
    }
    return FALSE;
}
#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON




PNOTIFYEE_FOBX
PIsFobxInTheList(
    PLIST_ENTRY pNotifyeeFobxList,
    PMRX_FOBX       pFobx
    )
/*++

Routine Description:

    This a support routine form change notification. It checks whether an FOBX, which is
    the redir's internal representation of a handle, is a change notification handle
    or not. Note, the shadow crit sect must be held when calling this.

Arguments:

Return Value:


--*/
{
    PLIST_ENTRY pListEntry;


    pListEntry = pNotifyeeFobxList->Flink;

    if (pListEntry)
    {
        while (pListEntry != pNotifyeeFobxList)
        {
            PNOTIFYEE_FOBX pNF = (PNOTIFYEE_FOBX)CONTAINING_RECORD(pListEntry, NOTIFYEE_FOBX, NextNotifyeeFobx);

            if (pNF->pFobx == pFobx)
            {
                return pNF;
            }
            
            pListEntry = pListEntry->Flink;
        }
    }
    
    return NULL;
}

BOOL
FCleanupAllNotifyees(
    PNOTIFY_SYNC pNotifySync,
    PLIST_ENTRY pDirNotifyList,
    PLIST_ENTRY pNotifyeeFobxList,
    PFAST_MUTEX pNotifyeeFobxListMutex
    )
/*++

Routine Description:

    This routine completes all outstanding changenotifications for a paricular list of 
    notifyees

Arguments:

Return Value:


--*/
{

    PLIST_ENTRY pListEntry;
    PNOTIFYEE_FOBX pNF;
    BOOL fDoneSome = FALSE;

    ExAcquireFastMutex(pNotifyeeFobxListMutex);

    pListEntry = pNotifyeeFobxList->Flink;

    if (pListEntry)
    {
        while (pListEntry != pNotifyeeFobxList)
        {
            pNF = (PNOTIFYEE_FOBX)CONTAINING_RECORD(pListEntry, NOTIFYEE_FOBX, NextNotifyeeFobx);

            SmbCeLog(("chngnotify cleanup fobx=%x\n", pNF->pFobx));
            SmbLog(LOG,
                   FCleanupAllNotifyees,
                   LOGPTR(pNF->pFobx));
//            DbgPrint("chngnotify Cleanup fobx=%x DirList=%x\n", pNF->pFobx, pDirNotifyList);
            FsRtlNotifyCleanup (
                pNotifySync,
                pDirNotifyList,
                pNF->pFobx
                );
            
            RemoveEntryList(&pNF->NextNotifyeeFobx);

            FreeMem(pNF);
            fDoneSome = TRUE;

            pListEntry = pNotifyeeFobxList->Flink;

        }
        
    }
    
    ExReleaseFastMutex(pNotifyeeFobxListMutex);

    return fDoneSome;
}

VOID
MRxSmbCSCResumeAllOutstandingOperations(
    PSMBCEDB_SERVER_ENTRY   pServerEntry
)
/*++

Routine Description:

    This routine completes all outstanding change notifications on the server.
    This is called when a server is being transitioned from offline to online.
    The caller must make sure that smbceresource is held, so that there are
    no synchronization problems while enumerating.

Arguments:

Return Value:


--*/
{
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
    while (pNetRootEntry != NULL) {
        if (pNetRootEntry->NetRoot.pNotifySync)
        {

            FCleanupAllNotifyees(pNetRootEntry->NetRoot.pNotifySync,
                                &pNetRootEntry->NetRoot.DirNotifyList,
                                &pNetRootEntry->NetRoot.NotifyeeFobxList,
                                &pNetRootEntry->NetRoot.NotifyeeFobxListMutex
                                 );
        }
        pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
    }
}

VOID
MRxSmbCSCObtainRightsForUserOnFile(
    IN  PRX_CONTEXT     pRxContext,
    HSHADOW             hDir,
    HSHADOW             hShadow,
    OUT ACCESS_MASK     *pMaximalAccessRights,
    OUT ACCESS_MASK     *pGuestMaximalAccessRights
    )
/*++

Routine Description:

    This routine gets the rights for a specific user. The routine is called during
    
    a create operation in disconnected state.
    
    
Arguments:

    pRxContext  Context for the create operation. We use this to get the user SID
    
    hDir        Directory Inode
    
    hShadow     File Inode

    pMaximalAccessRights    Access rights on the file for the user returned to the caller
    
    pGuestMaximalAccessRights Guest Access rights on the file returned to the caller

Return Value:

    None

--*/
{
    NTSTATUS    Status;
    BOOLEAN     AccessGranted = FALSE, SidHasAccessMask;
    SID_CONTEXT SidContext;
    int i;

    *pMaximalAccessRights = *pGuestMaximalAccessRights = 0;

    Status = CscRetrieveSid(
         pRxContext,
         &SidContext);

    if (Status == STATUS_SUCCESS) {
        CACHED_SECURITY_INFORMATION CachedSecurityInformation;

        ULONG BytesReturned,SidLength;
        DWORD CscStatus;
        CSC_SID_INDEX SidIndex;

        if (SidContext.pSid != NULL) {
            SidLength = RtlLengthSid(
                        SidContext.pSid);

        SidIndex = CscMapSidToIndex(
                   SidContext.pSid,
                   SidLength);
        } else {
            SidIndex = CSC_INVALID_SID_INDEX;
        }

        if (SidIndex == CSC_INVALID_SID_INDEX) {
            // The sid was not located in the existing Sid mappings
            // Map this Sid to that of a Guest
            SidIndex = CSC_GUEST_SID_INDEX;
        }

        BytesReturned = sizeof(CachedSecurityInformation);

        CscStatus = GetShadowInfoEx(
            hDir,
            hShadow,
            NULL,
            NULL,
            NULL,
            &CachedSecurityInformation,
            &BytesReturned);

        if (CscStatus == ERROR_SUCCESS) {
            if (BytesReturned == sizeof(CACHED_SECURITY_INFORMATION)) {
                // Walk through the cached access rights to determine the
                // maximal permissible access rights.
                for (i = 0; (i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES); i++) {

                    if(CachedSecurityInformation.AccessRights[i].SidIndex == SidIndex)
                    {
                        if (CSC_GUEST_SID_INDEX != SidIndex)
                        {
                            *pMaximalAccessRights = CachedSecurityInformation.AccessRights[i].MaximalRights;
                        }
                    }

                    if (CachedSecurityInformation.AccessRights[i].SidIndex == CSC_GUEST_SID_INDEX)
                    {
                        *pGuestMaximalAccessRights = CachedSecurityInformation.AccessRights[i].MaximalRights;
                    }
                    
                }
            }

        }

        CscDiscardSid(&SidContext);
    }

}


VOID
MRxSmbCscFlushFdb(
    IN PFDB Fdb
    )
/*++

Routine Description:

    This routine is called from delete ioctl to flush an open file which is being delay closed.
    Files which are closed by the user but for which the redir hasn't pushed out the
    close, cannot have their cached replicas deleted because these are open too. This 
    causes CSCDeleteIoctl to fail, and the user has not idea why.
    
    This routine must be called with ShadowCritSect held
    
Arguments:

    Fdb CSC version of smbfcb.
    
Return Value:

    None

--*/
{
    PMRX_SMB_FCB pSmbFcb;
    PNET_ROOT pNetRoot;

    pSmbFcb = MRxSmbCscRecoverMrxFcbFromFdb(Fdb);
    pNetRoot = (PNET_ROOT)(pSmbFcb->ContainingFcb->pNetRoot);

    LeaveShadowCrit();
    RxScavengeFobxsForNetRoot(pNetRoot,NULL);
    EnterShadowCrit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\cscdfs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cscdfs.c

Abstract:

    This module implements the routines for integrating DFS funcitionality with
    CSC

Author:

    Balan Sethu Raman [SethuR]    23 - January - 1998

Revision History:

Notes:

    The CSC/DFS integration poses some interesting problem for transparent
    switchover from online to offline operation and viceversa.

    The DFS driver ( incorporated into MUP in its current incarnation ) builds
    up a logical name space by stitching together varios physical volumes on
    different machines. In the normal course of events the CSC framework will
    be above the DFS driver in the food chain. In such cases this module
    would be redundant and the entire process is contained in the CSC code.
    Since this is not an available option owing to the necessity of integrating
    the CSC code in its present form this module tries to seamlessly provide
    that functionality.

    The DFS driver uses specially defined IOCTL's over the SMB protocol to garner
    and disperse DFS state information. The SMB protocol contains additional
    flag definitions that communicate the type of shares ( DFS aware or otherwise)
    to the clients. This information is stored in the redirector data structures.
    The DFS driver uses the FsContext2 field of the file object passed to it in
    Create calls to communicate the fact that it is a DFS open to the underlying
    redirector. This is used to validate opens in the redirector.

    With the introduction of CSC as part of the redirector there are some new
    wrinkles in the system. Since the DFS driver munges the names passed to it
    the name seen by the redirector is very different from the passed in by the
    user. If the CSC were to base its database based upon the names passed to
    the redirector then a DFS will be required to operate in the offline case.
    The DFS driver will persistently store its PKT data structure and do the same
    name munging in the offline case. With the introduction of fault tolerant DFS
    maintaining the state consistently and persistently will be a very tough
    problem.

    Another option to consider would be that the CSC database will be maintained
    in terms of the path names passed in by the user and not the munged names
    passed in by the redirector. This would imply that in the offline state the
    CSC code can independently exist to serve files off the DFS namespace without
    the DFS driver. The current solution that has been implemented for integrating
    CSC and DFS is based on this premise.

    In order to make this work we need to establish a mechanism for DFS to pass
    in the original name passed into DFS. This is done by usurping the FsContext
    field in the file object associated with the IRP that is passed in. DFS
    fills in this field with an instance of a DFS defined data structure
    (DFS_CSC_NAME_CONTEXT). This data structure contains the original name
    passed into DFS alonwith an indication of whether the open was triggerred by
    the CSC agent. The DFS driver is responsible for managing the storage
    associated with these contexts. When the DFS driver hands over the IRP this
    value is filled in and must remain valid till the IRP is completed. On
    completion of the IRP the context field would have been overridden by the
    underlying driver. The DFS driver cannot rely on the context fields having
    the value on return and must take adequate steps to squirrel away the data
    in its data structures.

    Having thus established the mechanism for DFS to pass in the original name
    the next step is to outline the mechanisms for CSC to use it. Since the CSC
    database is organized in terms of server/share names we will limit the
    discussion to shares with the implicit understanding that the extension to
    all file names in the name space is trivial.

    The DFS shares that are established for accessing files/folders can be classified
    into four categories based on their lifetimes

    1) DFS Share accessed in connected mode only

    2) DFS Share accessed in disconnected mode only

    3) DFS Share established in connected mode but is accessed after transitioning to
       disconnected mode

    4) DFS Share established in disconnected mode but is accessed after transitioning
       to connected mode.

    In the case of connected mode operation we need to ensure that the redirector
    consistently manipulates the RDR data structures in terms of the munged name
    passed in by the DFS driver and the CSC database in terms of the original
    name passed in by the user. As an example consider the following name

       \\DfsRoot\DfsShare\foo\bar passed in by the user. This name can be

    munged into one of three possible names by the DFS driver.

        TBD -- fill in appropriate FTDFS, middle level volume and leaf volume
        munged name.

    In the current RDR data structures the NET_ROOT_ENTRY claims the first two
    components of a name for the CSC database structures. There are two instances
    of CSC database handles for the Server ( server and share name in UNC
    terminology ) and the root directory. These names were driven off the name
    as seen by the redirector ( munged name ). In the modified scheme these will
    be driven off the original name passed in by the user. This ensures that no
    other code path need be changed in the redirector to facilitate DFS/CSC
    integration.

    In disconnected mode the names as passed in by the user is passed into the
    redirector which passes the appropriate components to CSC. Since CSC is
    maintained in terms of original names it works as before.

    When the user has modified files on a DFS share it is necessary to ensure
    that the DFS name space munging/resolution does not come into play till
    the CSC agent has had a chance to ensure that the files have been integrated
    This is accomplished by having the redirector preprocess the DFS open requests
    in connected mode. If the share has been marked dirty in the CSC database
    the redirector munges the name on its own to bypass DFS name resolution and
    returns STATUS_REPARSE to the DFS driver.

    There is one other situation which needs special treatment. A DFS server/share
    cannot be transitioned to disconnected operation by the redirector. Since
    the DFS name space is built out of multiple options with a variety of fault
    tolerant options the inability to open a file/contact a server in the DFS
    namespace cannot lead to transitioning in the redirector. It is left to
    the discretion of the DFS driver to implement the appropriate mechanism

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

NTSTATUS
CscDfsParseDfsPath(
    PUNICODE_STRING pDfsPath,
    PUNICODE_STRING pServerName,
    PUNICODE_STRING pSharePath,
    PUNICODE_STRING pFilePathRelativeToShare)
/*++

Routine Description:

    This routine parses the DFS path into a share path and a file path

Arguments:

    pDfsPath -- the DFS path

    pServerName -- the name of the server

    pSharePath -- the share path

    pFilePathRelativeToShare -- file path relative to share

Return Value:

    STATUS_SUCCESS -- successful

    STATUS_OBJECT_PATH_INVALID -- the path supplied was invalid

Notes:

    Either pServerName or pSharePath or pFilePathRelativeToShare can be NULL

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PWCHAR pTempPathString;

    ULONG NumberOfBackSlashesSkipped;
    ULONG TempPathLengthInChars;
    ULONG SharePathLengthInChars;

    pTempPathString = pDfsPath->Buffer;
    TempPathLengthInChars = pDfsPath->Length / sizeof(WCHAR);

    if (pServerName != NULL) {
        pServerName->Length = pServerName->MaximumLength = 0;
        pServerName->Buffer = NULL;
    }

    if (pSharePath != NULL) {
        pSharePath->Length = pSharePath->MaximumLength = 0;
        pSharePath->Buffer = NULL;
    }

    if (pFilePathRelativeToShare != NULL) {
        pFilePathRelativeToShare->Length = pFilePathRelativeToShare->MaximumLength = 0;
        pFilePathRelativeToShare->Buffer = NULL;
    }

    // Skip till after the third backslash or the end of the name
    // whichever comes first.
    // The name we are interested in is of the form \server\share\
    // with the last backslash being optional.

    NumberOfBackSlashesSkipped = 0;
    SharePathLengthInChars = 0;

    while (TempPathLengthInChars > 0) {
        if (*pTempPathString++ == L'\\') {
            NumberOfBackSlashesSkipped++;

            if (NumberOfBackSlashesSkipped == 2) {
                if (pServerName != NULL) {
                    pServerName->Length = (USHORT)SharePathLengthInChars * sizeof(WCHAR);
                    pServerName->MaximumLength = pServerName->Length;
                    pServerName->Buffer = pDfsPath->Buffer;
                }
            } else if (NumberOfBackSlashesSkipped == 3) {
                break;
            }
        }

        TempPathLengthInChars--;
        SharePathLengthInChars++;
    }

    if (NumberOfBackSlashesSkipped >= 2) {
        if (pSharePath != NULL) {
            pSharePath->Length = (USHORT)SharePathLengthInChars * sizeof(WCHAR);
            pSharePath->MaximumLength = pSharePath->Length;
            pSharePath->Buffer = pDfsPath->Buffer;
        }

        if ((pFilePathRelativeToShare != NULL) &&
            (NumberOfBackSlashesSkipped == 3)) {
            pFilePathRelativeToShare->Length =
                pDfsPath->Length - ((USHORT)SharePathLengthInChars * sizeof(WCHAR));
            pFilePathRelativeToShare->MaximumLength = pFilePathRelativeToShare->Length;
            pFilePathRelativeToShare->Buffer = pDfsPath->Buffer + SharePathLengthInChars;
        }

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_OBJECT_PATH_INVALID;
    }

    return Status;
}

PDFS_NAME_CONTEXT
CscIsValidDfsNameContext(
    PVOID   pFsContext)
/*++

Routine Description:

    This routine determines if the supplied context is a valid DFS_NAME_CONTEXT

Arguments:

    pFsContext - the supplied context

Return Value:

    valid context ponter if the supplied context is a valid DFS_NAME_CONTEXT
    instance, otherwise NULL

Notes:

--*/
{
    PDFS_NAME_CONTEXT pValidDfsNameContext = NULL;

    if (pFsContext != NULL) {
        pValidDfsNameContext = pFsContext;
    }

    return pValidDfsNameContext;
}

NTSTATUS
CscGrabPathFromDfs(
    PFILE_OBJECT      pFileObject,
    PDFS_NAME_CONTEXT pDfsNameContext)
/*++

Routine Description:

    This routine modifies the file object in preparation for returning
    STATUS_REPARSE

Arguments:

    pFileObject - the file object

    pDfsNameContext - the DFS_NAME_CONTEXT instance

Return Value:

    STATUS_REPARSE if everything is successful

Notes:

--*/
{
    NTSTATUS Status;

    USHORT DeviceNameLength,ReparsePathLength;
    PWSTR  pFileNameBuffer;

    DeviceNameLength = wcslen(DD_NFS_DEVICE_NAME_U) *
                       sizeof(WCHAR);


    ReparsePathLength = DeviceNameLength +
                        pDfsNameContext->UNCFileName.Length;

    if (pDfsNameContext->UNCFileName.Buffer[0] != L'\\') {
        ReparsePathLength += sizeof(WCHAR);
    }

    pFileNameBuffer = RxAllocatePoolWithTag(
                          PagedPool | POOL_COLD_ALLOCATION,
                          ReparsePathLength,
                          RX_MISC_POOLTAG);

    if (pFileNameBuffer != NULL) {
        // Copy the device name
        RtlCopyMemory(
            pFileNameBuffer,
            DD_NFS_DEVICE_NAME_U,
            DeviceNameLength);

        if (pDfsNameContext->UNCFileName.Buffer[0] != L'\\') {
            DeviceNameLength += sizeof(WCHAR);

            pFileNameBuffer[DeviceNameLength/sizeof(WCHAR)]
                = L'\\';
        }

        // Copy the new name
        RtlCopyMemory(
            ((PBYTE)pFileNameBuffer +
             DeviceNameLength),
            pDfsNameContext->UNCFileName.Buffer,
            pDfsNameContext->UNCFileName.Length);

        if (pFileObject->FileName.Buffer != NULL)
            ExFreePool(pFileObject->FileName.Buffer);

        pFileObject->FileName.Buffer = pFileNameBuffer;
        pFileObject->FileName.Length = ReparsePathLength;
        pFileObject->FileName.MaximumLength =
            pFileObject->FileName.Length;

        Status = STATUS_REPARSE;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
CscPreProcessCreateIrp(
    PIRP    pIrp)
/*++

Routine Description:

    This routine determines if the CSC/Redirector should defeat the DFS
    name resolution scheme

Arguments:

    pIrp - the IRP

Return Value:

    This routine bases this determination on whether there are dirty files
    corresponding to this DFS share name. If there are the name is claimed by
    the redirector by changing the file name to the new value and returning
    STATUS_REPARSE. In all other cases STATUS_SUCCESS is returned.

Notes:

    This routine assumes that the name passed in the DFS_NAME_CONTEXT is a
    name in the following format irrespective of whether the user specifies a
    drive letter based name or a UNC name.

        \DfsRoot\DfsShare\ ....

--*/
{
    NTSTATUS    Status;

    PIO_STACK_LOCATION pIrpSp;
    PFILE_OBJECT       pFileObject;
    PDFS_NAME_CONTEXT  pDfsNameContext;

    if(!MRxSmbIsCscEnabled ||
        !fShadow
        ) {
        return(STATUS_SUCCESS);
    }

    Status = STATUS_SUCCESS;

    pIrpSp  = IoGetCurrentIrpStackLocation(pIrp);

    pFileObject = pIrpSp->FileObject;

    pDfsNameContext = CscIsValidDfsNameContext(pFileObject->FsContext);

    if ((pDfsNameContext != NULL) &&
        (pDfsNameContext->NameContextType != DFS_CSCAGENT_NAME_CONTEXT)) {
        UNICODE_STRING ShareName;
        UNICODE_STRING  ServerName;

        Status = CscDfsParseDfsPath(
                     &pDfsNameContext->UNCFileName,
                     &ServerName,
                     &ShareName,
                     NULL);

        // Locate the share name / server name in the database.
        if (Status == STATUS_SUCCESS) {
            // At this stage the given path name has been parsed into the
            // relevant components, i.e., the server name, the share name
            // ( also includes the server name ) and the file name relative
            // to the share. Of these the first two components are valuable
            // in determining whether the given path has to be grabbed from
            // DFS.

            Status = STATUS_MORE_PROCESSING_REQUIRED;

            // If a server entry exists in the connection engine database
            // for the given server name and it had been marked for
            // disconnected operation then the path needs to be grabbed from
            // DFS. This will take into account those cases wherein there
            // is some connectivity but the DFS root has been explicitly
            // marked for disconnected operation.

            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                PSMBCEDB_SERVER_ENTRY pServerEntry;

                SmbCeAcquireResource();

                pServerEntry = SmbCeFindServerEntry(
                                   &ServerName,
                                   SMBCEDB_FILE_SERVER,
                                   NULL);

                SmbCeReleaseResource();

                if (pServerEntry != NULL) {
                    if (SmbCeIsServerInDisconnectedMode(pServerEntry)) {
                        Status = STATUS_REPARSE;
                    }

                    SmbCeDereferenceServerEntry(pServerEntry);
                }
            }

            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {

                // If no server entry exists or it has not been transitioned into
                // disconnected mode we check the CSC database for an entry
                // corresponding to the given share name. If one exists and there
                // are no transports available then the name needs to be grabbed.
                // This takes into account all the cases wherein there is no
                // net connectivity.

                SHADOWINFO ShadowInfo;
                DWORD      CscServerStatus;

                EnterShadowCrit();

                CscServerStatus = FindCreateShareForNt(
                                      &ShareName,
                                      FALSE,
                                      &ShadowInfo,
                                      NULL);

                LeaveShadowCrit();

                if ( CscServerStatus == SRET_OK ) {
                    PSMBCE_TRANSPORT_ARRAY pTransportArray;

                    // If an entry corresponding to the dfs root exists in the
                    // CSC database transition to using it either if it is marked
                    // dirty or there are no transports.

                    pTransportArray = SmbCeReferenceTransportArray();
                    SmbCeDereferenceTransportArray(pTransportArray);

                    if (pTransportArray == NULL) {
                        Status = STATUS_REPARSE;
                    }
                }
            }

            // if the status value is STATUS_REPARSE one of the rule applications
            // was successful and we do the appropriate name munging to grab
            // the DFS path
            // If the status value is still STATUS_MORE_PROCESSING_REQUIRED
            // it implies that none of our rules for reparsing the DFS path
            // was successful. We map the status back to STATUS_SUCCESS to
            // resume the connected mode of operation

            if (Status == STATUS_REPARSE) {
                if (pDfsNameContext->Flags & DFS_FLAG_LAST_ALTERNATE) {
                    Status = CscGrabPathFromDfs(
                                 pFileObject,
                                 pDfsNameContext);
                } else {
                    Status = STATUS_NETWORK_UNREACHABLE;
                }
            } else if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                Status = STATUS_SUCCESS;
            }
        }
    }

    return Status;
}

NTSTATUS
CscDfsDoDfsNameMapping(
    IN  PUNICODE_STRING pDfsPrefix,
    IN  PUNICODE_STRING pActualPrefix,
    IN  PUNICODE_STRING pNameToMap,
    IN  BOOL            fResolvedNameToDFSName,
    OUT PUNICODE_STRING pResult
    )
/*++

Routine Description:

    Given the DfsPrefix and it's corresponding actualprefix, this routine maps a resolved
    name to the corresponding DFS name or viceversa

    As an example if \\csctest\dfs\ntfs is actually resolved to \\dkruse1\ntfs
    then \\csctest\dfs\ntfs\dir1\foo.txt resolves to \\dkruse1\ntfs\dir1\foo.txt.

    The DFS prefix in this case is \ntfs and the Actual prefix is \.

    Thus, given an actual path \dir1\foo.txt, this routine reverse maps it to
    \ntfs\dir1\foo.txt or viceversa


Arguments:

    pDfsPrefix              Dfs Name prefix

    pActaulPrefix           Corresponding actual prefix

    pNameToMap              Actual name

    fResolvedNameToDFSName  If true, we are converting resolved name to DFS name, else viceversa

    pResult                 Output DFS name

Return Value:

    STATUS_SUCCESS if successful, NT error code otherwise

Notes:


    This routine is used by CSC to obtain a DFS name from an actual name or viceversa. It is used to get the
    DFS name of a rename name so that the CSC database can do the manipulations in terms
    of the DFS names. It is also used to get the info from the server using the real name
    while createing entries in the CSC database in the DFS namespace.

--*/
{
    NTSTATUS    Status = STATUS_NO_SUCH_FILE;
    PUNICODE_STRING pSourcePrefix=pActualPrefix , pDestPrefix=pDfsPrefix;
    UNICODE_STRING  NameToCopy;

    memset(pResult, 0, sizeof(UNICODE_STRING));

    if (fResolvedNameToDFSName)
    {
        // converting resolved name to DFS name
        pSourcePrefix=pActualPrefix;
        pDestPrefix=pDfsPrefix;
    }
    else
    {
        // converting DFS name to resolved name
        pSourcePrefix=pDfsPrefix;
        pDestPrefix=pActualPrefix;

    }
  //  DbgPrint("CscDoDfsnamemapping: DestPrefix=%wZ SourcePrefix=%wZ NameToMap=%wZ\n",
//                pDestPrefix, pSourcePrefix,  pNameToMap);

    //mathc the prefix
    if (RtlPrefixUnicodeString(pSourcePrefix, pNameToMap, TRUE))
    {
        ASSERT(pNameToMap->Length >= pSourcePrefix->Length);

        // Calculate the max length.
        pResult->MaximumLength = pDestPrefix->Length + pNameToMap->Length - pSourcePrefix->Length+2;

        pResult->Buffer = (PWCHAR)AllocMem(pResult->MaximumLength);

        if (pResult->Buffer)
        {
            // set the initial length
            pResult->Length = pDestPrefix->Length;
            memcpy(pResult->Buffer, pDestPrefix->Buffer, pDestPrefix->Length);

            // if there isn't a terminating backslash, put it in there
            if (pResult->Buffer[pResult->Length/sizeof(USHORT)-1] != L'\\')
            {
                pResult->Buffer[pResult->Length/sizeof(USHORT)] = L'\\';
                pResult->Length += 2;

            }

            NameToCopy.Buffer = pNameToMap->Buffer+pSourcePrefix->Length/sizeof(USHORT);
            NameToCopy.Length = pNameToMap->Length-pSourcePrefix->Length;

//            DbgPrint("CscDoDfsNameMapping: Copying %wZ\n", &NameToCopy);

            // now copy the nametomap without the sourceprefix, into the buffer
            memcpy( pResult->Buffer+pResult->Length/sizeof(USHORT),
                    NameToCopy.Buffer,
                    NameToCopy.Length);

            pResult->Length += NameToCopy.Length;

            ASSERT(pResult->Length <= pResult->MaximumLength);

//            DbgPrint("CscDoDfsNameMapping: pResult %wZ\n", pResult);
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return Status;
}

NTSTATUS
CscDfsObtainReverseMapping(
    IN  PUNICODE_STRING pDfsPath,
    IN  PUNICODE_STRING pResolvedPath,
    OUT PUNICODE_STRING pReverseMappingDfs,
    OUT PUNICODE_STRING pReverseMappingActual)

/*++

Routine Description:

    This routine obtains the mapping strings which allow csc to map a resolved path
    to a DFS path

    As an example if \\csctest\dfs\ntfs is actually resolved to \\dkruse1\ntfs
    then \\csctest\dfs\ntfs\dir1\foo.txt resolves to \\dkruse1\ntfs\dir1\foo.txt.

    The DFS prefix in this case is \ntfs and the Actual prefix is \.

Arguments:

    pDfsPath    Path relative to the root of the DFS share

    pResolvedPath   Path relative to the actual share

    pReverseMappingDfs

    pReverseMappingActual

Return Value:

    STATUS_SUCCESS if successful, NT error code otherwise

Notes:


--*/
{
    NTSTATUS    Status=STATUS_INSUFFICIENT_RESOURCES;
    PWCHAR  pDfs, pActual;
    WCHAR   wDfs, wActual;
    DWORD   cbDfs=0, cbActual=0;
    UNICODE_STRING  uniSavResolved, uniSavDfs;
    BOOL    fSavedResolved = FALSE, fSavedDfs = FALSE;


    // take care of the root
    if (pResolvedPath->Length == 0)
    {
        uniSavResolved = *pResolvedPath;
        pResolvedPath->Length = pResolvedPath->MaximumLength = 2;
        pResolvedPath->Buffer = L"\\";
        fSavedResolved = TRUE;
    }
    // take care of the root
    if (pDfsPath->Length == 0)
    {
        uniSavDfs = *pDfsPath;
        pDfsPath->Length = pDfsPath->MaximumLength = 2;
        pDfsPath->Buffer = L"\\";
        fSavedDfs = TRUE;
    }

    memset(pReverseMappingDfs, 0, sizeof(UNICODE_STRING));
    memset(pReverseMappingActual, 0, sizeof(UNICODE_STRING));

    // point to the end of each string
    pDfs = (PWCHAR)((LPBYTE)(pDfsPath->Buffer)+pDfsPath->Length - 2);
    cbDfs = pDfsPath->Length;

    pActual = (PWCHAR)((LPBYTE)(pResolvedPath->Buffer)+pResolvedPath->Length - 2);
    cbActual = pResolvedPath->Length;

//    DbgPrint("CscDfsObtainReverseMapping: In DfsPath=%wZ ResolvedPath=%wZ\n", pDfsPath, pResolvedPath);

    pReverseMappingDfs->MaximumLength = pReverseMappingDfs->Length = (USHORT)cbDfs;
    pReverseMappingActual->MaximumLength = pReverseMappingActual->Length = (USHORT)cbActual;

    for (;;)
    {
        // do an upcase comparison
        wDfs = RtlUpcaseUnicodeChar(*pDfs);
        wActual = RtlUpcaseUnicodeChar(*pActual);

        if (wDfs != wActual)
        {
            ASSERT(pReverseMappingDfs->Length && pReverseMappingActual->Length);
            break;
        }

        // if we reached a backslash, checkpoint the path upto this point
        if (wDfs == (WCHAR)'\\')
        {
            pReverseMappingDfs->MaximumLength = pReverseMappingDfs->Length = (USHORT)cbDfs;
            pReverseMappingActual->MaximumLength = pReverseMappingActual->Length = (USHORT)cbActual;
        }

        if ((pDfs == pDfsPath->Buffer)||(pActual ==  pResolvedPath->Buffer))
        {
            break;
        }

        --pDfs;--pActual;
        cbDfs -= 2; cbActual -= 2;
    }

    pReverseMappingDfs->Buffer = (PWCHAR)RxAllocatePoolWithTag(NonPagedPool, pReverseMappingDfs->Length, RX_MISC_POOLTAG);

    if (pReverseMappingDfs->Buffer)
    {
        pReverseMappingActual->Buffer = (PWCHAR)RxAllocatePoolWithTag(NonPagedPool, pReverseMappingActual->Length, RX_MISC_POOLTAG);

        if (pReverseMappingActual->Buffer)
        {

            memcpy(pReverseMappingDfs->Buffer, pDfsPath->Buffer, pReverseMappingDfs->Length);
            memcpy(pReverseMappingActual->Buffer, pResolvedPath->Buffer, pReverseMappingActual->Length);

//            DbgPrint("CscDfsObtainReverseMapping: out DfsPrefix=%wZ ActualPrefix=%wZ\n", pReverseMappingDfs, pReverseMappingActual);
            Status = STATUS_SUCCESS;
        }
    }

    if (Status != STATUS_SUCCESS)
    {
        if (pReverseMappingDfs->Buffer)
        {
            FreeMem(pReverseMappingDfs->Buffer);
        }
        pReverseMappingDfs->Buffer = NULL;

        if (pReverseMappingActual->Buffer)
        {
            FreeMem(pReverseMappingActual->Buffer);
        }
        pReverseMappingActual->Buffer = NULL;
    }

    if (fSavedResolved)
    {
        *pResolvedPath = uniSavResolved;
    }
    if (fSavedDfs)
    {
        *pDfsPath = uniSavDfs;

    }
    return Status;
}

NTSTATUS
CscDfsStripLeadingServerShare(
    IN  PUNICODE_STRING pDfsRootPath
    )
/*++

Routine Description:

    This routine strips the leading server-share of a DFS root path. Thus when Dfs sends down a path
    relative to the root such as \server\share\foo.txt, this routien makes the path \foo.txt

Arguments:

    pDfsRootPath    Path relative to the root of the DFS share

Return Value:

    STATUS_SUCCESS if successful, NT error code otherwise

Notes:


--*/
{
    ULONG cnt = 0, i;

    DbgPrint("Stripping %wZ \n", pDfsRootPath);
    for (i=0; ;++i)
    {
        if (i*sizeof(WCHAR) > pDfsRootPath->Length)
        {
            return STATUS_UNSUCCESSFUL;
        }
        if (pDfsRootPath->Buffer[i] == '\\')
        {
            // if this is the 3rd slash then we have successfully stripped the name
            if (cnt == 2)
            {
                break;
            }
            cnt++;
        }
    }
    pDfsRootPath->Buffer = &pDfsRootPath->Buffer[i];
    pDfsRootPath->Length -= (USHORT)(i * sizeof(WCHAR));
    DbgPrint("Stripped name %wZ \n", pDfsRootPath);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\csc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    csc.c

Abstract:

    This module implements the client side caching interface for the SMB mini rdr.

Author:

    Joe Linn [joelinn]    21-jan-1997

Revision History:

    Shishir Pardikar disconnected ops, parameter validation, bug fixes .....

--*/

#include "precomp.h"
#pragma hdrstop

#include <smbdebug.h>

#define Dbg (DEBUG_TRACE_MRXSMBCSC)
RXDT_DefineCategory(MRXSMBCSC);


//local prototype

LONG
MRxSmbCSCExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

BOOLEAN
CscpAccessCheck(
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation,
    ULONG                        CachedSecurityInformationLength,
    CSC_SID_INDEX                SidIndex,
    ACCESS_MASK                  AccessMask,
    BOOLEAN                      *pSidHasAccessmask
);

BOOLEAN
CscAccessCheck(
    HSHADOW              hParent,
    HSHADOW              hFile,
    PRX_CONTEXT          RxContext,
    ACCESS_MASK          AccessMask,
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformationForShadow,
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformationForShare
    );

VOID
MRxSmbCscFillWithoutNamesFind32FromFcb (
      IN  PMINIMAL_CSC_SMBFCB MinimalCscSmbFcb,
      OUT _WIN32_FIND_DATA  *Find32
      );

NTSTATUS
MRxSmbCscGetFileInfoForCshadow(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbGetFileInfoFromServer (
    IN  OUT PRX_CONTEXT     RxContext,
    IN  PUNICODE_STRING     FullFileName,
    OUT _WIN32_FIND_DATA    *Find32,
    IN  PMRX_SRV_OPEN       pSrvOpen,
    OUT BOOLEAN             *lpfIsRoot
    );

BOOLEAN
MRxSmbCscIsFatNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    );

VOID
MRxSmbCscGenerate83NameAsNeeded(
      IN     CSC_SHADOW_HANDLE   hDir,
      PWCHAR FileName,
      PWCHAR SFN
      );
int
RefreshShadow( HSHADOW  hDir,
   IN HSHADOW  hShadow,
   IN LPFIND32 lpFind32,
   OUT ULONG *lpuShadowStatus
   );

NTSTATUS
SmbPseExchangeStart_CloseCopyChunk(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCscCloseExistingThruOpen(
    IN OUT PRX_CONTEXT   RxContext
    );

ULONG
GetPathLevelFromUnicodeString (
    PUNICODE_STRING Name
      );

NTSTATUS
MRxSmbCscFixupFindFirst (
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
    );
VOID
MRxSmbCscLocateAndFillFind32WithinSmbbuf(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbCscGetFileInfoFromServerWithinExchange (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    PUNICODE_STRING FileName
    );

NTSTATUS
IoctlGetDebugInfo(
    PRX_CONTEXT RxContext,
    PBYTE InputBuffer,
    ULONG InputBufferLength,
    PBYTE OutputBuffer,
    ULONG OutputBufferLength);

NTSTATUS
MRxSmbCscLocalFileOpen(
      IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbCscObtainShadowHandles (
    IN OUT PRX_CONTEXT       RxContext,
    IN OUT PNTSTATUS         Status,
    IN OUT _WIN32_FIND_DATA  *Find32,
    OUT    PBOOLEAN          Created,
    IN     ULONG             CreateShadowControls,
    IN     BOOLEAN           Disconnected
    );

// type of buffer used to capture structures passed in which have embedded pointers.
// Once we have captured the structure, the embedded pointers cannot be changed and
// our parameter validation holds good throughout the duration of the call

typedef union tagCAPTURE_BUFFERS
{
    COPYPARAMSW  sCP;
    SHADOWINFO  sSI;
    SHAREINFO  sSVI;
}
CAPTURE_BUFFERS, *LPCAPTURE_BUFFERS;

// table entry type off which the parameter validation is driven
typedef struct tagCSC_IOCTL_ENTRY
{
    ULONG   IoControlCode;  // iocontrolcode for sanity check
    DWORD   dwFlags;        // bits indicating what type of strucutre is passed in
    DWORD   dwLength;       // size of the passed in strucutre
}
CSC_IOCTL_ENTRY;

// defines for the flags in dwFlags field in CSC_IOCTL_ENTRY structure
#define FLAG_CSC_IOCTL_PQPARAMS         0x00000001
#define FLAG_CSC_IOCTL_COPYPARAMS       0x00000002
#define FLAG_CSC_IOCTL_SHADOWINFO       0x00000004
#define FLAG_CSC_IOCTL_COPYCHUNKCONTEXT 0x00000008
#define FLAG_CSC_IOCTL_GLOBALSTATUS     0x00000010

#define FLAG_CSC_IOCTL_BUFFERTYPE_MASK  0xff

#define SMB_CSC_BITS_TO_DATABASE_CSC_BITS(CscFlags) (((CscFlags) << 4) & SHARE_CACHING_MASK)
#define DATABASE_CSC_BITS_TO_SMB_CSC_BITS(CscFlags) (((CscFlags) & SHARE_CACHING_MASK) >> 4)


// #define IOCTL_NAME_OF_SERVER_GOING_OFFLINE      (_SHADOW_IOCTL_CODE(45))

#ifdef  DEBUG
extern ULONG HookKdPrintVector = HOOK_KDP_BADERRORS;
extern ULONG HookKdPrintVectorDef = HOOK_KDP_GOOD_DEFAULT;
#endif

#ifdef RX_PRIVATE_BUILD
ULONG MRxSmbCscDbgPrintF = 0; // 1;
#endif //ifdef RX_PRIVATE_BUILD

//
// this variable is used to "help" the agent know when to recalculate
// the reference priorities
//
ULONG MRxSmbCscNumberOfShadowOpens = 0;
ULONG MRxSmbCscActivityThreshold = 16;
ULONG MRxSmbCscInitialRefPri = MAX_PRI;
// these two lists are used to list up all the netroots and fcbs
// that have shadows so that we can find them for the ioctls. today
// are just doubly-linked lists but we can anticipate that this may
// become a performance issue, particularly for fcbs. at that point, we
// can either change to bucket hashing or tries

LIST_ENTRY xCscFcbsList;
PIRP    vIrpReint = NULL;

#define MRxSmbCscAddReverseFcbTranslation(smbFcb) {\
    InsertTailList(&xCscFcbsList,                      \
               &(smbFcb)->ShadowReverseTranslationLinks); \
    }
#define MRxSmbCscRemoveReverseFcbTranslation(smbFcb) {\
    RemoveEntryList(&(smbFcb)->ShadowReverseTranslationLinks); \
    }

PMRX_SMB_FCB
MRxSmbCscRecoverMrxFcbFromFdb (
    IN PFDB Fdb
    );

BOOL
CscDfsShareIsInReint(
    IN  PRX_CONTEXT         RxContext
    );
//
// From zwapi.h.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
CaptureInputBufferIfNecessaryAndProbe(
    DWORD   IoControlCode,
    PRX_CONTEXT     pRxContext,
    PBYTE   InputBuffer,
    LPCAPTURE_BUFFERS lpCapBuff,
    PBYTE   *ppAuxBuf,
    PBYTE   *ppOrgBuf,
    PBYTE   *ppReturnBuffer
    );

NTSTATUS
ValidateCopyParams(
    LPCOPYPARAMS    lpCP
    );

NTSTATUS
ValidateShadowInfo(
    DWORD           IoControlCode,
    LPSHADOWINFO    lpSI,
    LPBYTE          *ppAuxBuf,
    LPBYTE          *ppOrgBuf
    );

NTSTATUS
ValidateCopyChunkContext(
    PRX_CONTEXT RxContext,
    DWORD       IoControlCode
    );

NTSTATUS
CscProbeForReadWrite(
    PBYTE   pBuffer,
    DWORD   dwSize
    );

NTSTATUS
CscProbeAndCaptureForReadWrite(
    PBYTE   pBuffer,
    DWORD   dwSize,
    PBYTE   *ppAuxBuf
    );

VOID
CopyBackIfNecessary(
    DWORD   IoControlCode,
    PBYTE   InputBuffer,
    LPCAPTURE_BUFFERS lpCapBuff,
    PBYTE   pAuxBuf,
    PBYTE   pOrgBuf,
    BOOL    fSuccess
    );

VOID
EnterShadowCritRx(
    PRX_CONTEXT     pRxContext
    );

VOID
LeaveShadowCritRx(
    PRX_CONTEXT     pRxContext
    );

#if defined(REMOTE_BOOT)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    IN PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );

//
// From ntrtl.h.
//

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PBOOLEAN SaclPresent,
    PACL *Sacl,
    PBOOLEAN SaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID *Group,
    PBOOLEAN GroupDefaulted
    );

#endif

//sigh BUBUG get this stuff into an include file.....
#define SHADOW_VERSION 0x8287
extern char vszShadowDir[MAX_SHADOW_DIR_NAME+1];
extern PVOID lpdbShadow;
//CODE.IMPROFVEMENT this should be in a .h file
extern PKEVENT MRxSmbAgentSynchronizationEvent;
extern PKEVENT MRxSmbAgentFillEvent;
extern PSMBCEDB_SERVER_ENTRY   CscServerEntryBeingTransitioned;
extern ULONG CscSessionIdCausingTransition;
extern ULONG vulDatabaseStatus;
extern unsigned cntInodeTransactions;

extern VOID
MRxSmbDecrementSrvOpenCount(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    LONG                  SrvOpenServerVersion,
    PMRX_SRV_OPEN         SrvOpen);

VOID ValidateSmbFcbList(VOID);

BOOL SetOfflineOpenStatusForShare(
    CSC_SHARE_HANDLE    hShare,
    CSC_SHADOW_HANDLE   hRootDir,
    OUT PULONG pShareStatus
    );

LONG CSCBeginReint(
    IN OUT  PRX_CONTEXT RxContext,
    IN OUT  LPSHADOWINFO    lpSI
    );

ULONG CSCEndReint(
    IN OUT  LPSHADOWINFO    lpSI
    );

VOID CSCCancelReint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP ThisIrp
    );

VOID
CreateFakeFind32(
    CSC_SHADOW_HANDLE hDir,
    _WIN32_FIND_DATA  *pFind32,
    PRX_CONTEXT         RxContext,
    BOOLEAN LastComponentInName
    );

NTSTATUS
OkToDeleteObject(
    HSHADOW hDir,
    HSHADOW hShadow,
    _WIN32_FIND_DATA  *Find32,
    ULONG   uShadowStatus,
    BOOLEAN fDisconnected
    );

#pragma alloc_text(PAGE, MRxSmbCSCExceptionFilter)

#if defined(REMOTE_BOOT)
#pragma alloc_text(PAGE, ZwImpersonateSelf)
#pragma alloc_text(PAGE, ZwAdjustPrivilege)
#pragma alloc_text(PAGE, RtlGetSecurityInformationFromSecurityDescriptor)
#endif

#pragma alloc_text(PAGE, MRxSmbInitializeCSC)
#pragma alloc_text(PAGE, MRxSmbUninitializeCSC)
#pragma alloc_text(PAGE, CscpAccessCheck)
#pragma alloc_text(PAGE, CscAccessCheck)
#pragma alloc_text(PAGE, MRxSmbCscAcquireSmbFcb)
#pragma alloc_text(PAGE, MRxSmbCscReleaseSmbFcb)
#pragma alloc_text(PAGE, MRxSmbCscSetFileInfoEpilogue)
#pragma alloc_text(PAGE, MRxSmbCscIoCtl)
#pragma alloc_text(PAGE, MRxSmbCscObtainShareHandles)
#pragma alloc_text(PAGE, MRxSmbCscFillWithoutNamesFind32FromFcb)
#pragma alloc_text(PAGE, MRxSmbCscGetFileInfoForCshadow)
#pragma alloc_text(PAGE, MRxSmbGetFileInfoFromServer)
#pragma alloc_text(PAGE, MRxSmbCscIsFatNameValid)
#pragma alloc_text(PAGE, MRxSmbCscGenerate83NameAsNeeded)
#pragma alloc_text(PAGE, MRxSmbCscCreateShadowFromPath)
#pragma alloc_text(PAGE, RefreshShadow)
#pragma alloc_text(PAGE, MRxSmbCscIsThisACopyChunkOpen)
#pragma alloc_text(PAGE, SmbPseExchangeStart_CloseCopyChunk)
#pragma alloc_text(PAGE, MRxSmbCscCloseExistingThruOpen)
#pragma alloc_text(PAGE, MRxSmbCscCreatePrologue)
#pragma alloc_text(PAGE, MRxSmbCscObtainShadowHandles)
#if defined(REMOTE_BOOT)
#pragma alloc_text(PAGE, MRxSmbCscSetSecurityOnShadow)
#endif
#pragma alloc_text(PAGE, MRxSmbCscCreateEpilogue)
#pragma alloc_text(PAGE, MRxSmbCscDeleteAfterCloseEpilogue)
#pragma alloc_text(PAGE, GetPathLevelFromUnicodeString)
#pragma alloc_text(PAGE, MRxSmbCscRenameEpilogue)
#pragma alloc_text(PAGE, MRxSmbCscCloseShadowHandle)
#pragma alloc_text(PAGE, MRxSmbCscFixupFindFirst)
#pragma alloc_text(PAGE, MRxSmbCscLocateAndFillFind32WithinSmbbuf)
#pragma alloc_text(PAGE, MRxSmbCscGetFileInfoFromServerWithinExchange)
#pragma alloc_text(PAGE, MRxSmbCscUpdateShadowFromClose)
#pragma alloc_text(PAGE, MRxSmbCscDeallocateForFcb)
#pragma alloc_text(PAGE, MRxSmbCscRecoverMrxFcbFromFdb)
#pragma alloc_text(PAGE, MRxSmbCscFindFdbFromHShadow)
#pragma alloc_text(PAGE, MRxSmbCscFindResourceFromHandlesWithModify)
#pragma alloc_text(PAGE, MRxSmbCscFindLocalFlagsFromFdb)
#pragma alloc_text(PAGE, MRxSmbCscSetSecurityPrologue)
#pragma alloc_text(PAGE, MRxSmbCscSetSecurityEpilogue)
#pragma alloc_text(PAGE, CaptureInputBufferIfNecessaryAndProbe)
#pragma alloc_text(PAGE, ValidateCopyParams)
#pragma alloc_text(PAGE, ValidateShadowInfo)
#pragma alloc_text(PAGE, ValidateCopyChunkContext)
#pragma alloc_text(PAGE, CscProbeForReadWrite)
#pragma alloc_text(PAGE, CopyBackIfNecessary)
#pragma alloc_text(PAGE, ValidateSmbFcbList)
#pragma alloc_text(PAGE, SetOfflineOpenStatusForShare)
#pragma alloc_text(PAGE, MRxSmbCscLocalFileOpen)
#pragma alloc_text(PAGE, CSCCheckLocalOpens)
#pragma alloc_text(PAGE, IsCSCBusy)
#pragma alloc_text(PAGE, ClearCSCStateOnRedirStructures)
#pragma alloc_text(PAGE, CscDfsShareIsInReint)
#pragma alloc_text(PAGE, CloseOpenFiles)
#pragma alloc_text(PAGE, CreateFakeFind32)
#pragma alloc_text(PAGE, OkToDeleteObject)
#pragma alloc_text(PAGE, IoctlGetDebugInfo)

//remember whether to delete the link
BOOLEAN MRxSmbCscLinkCreated = FALSE;

PCONTEXT CSCExpCXR;
PEXCEPTION_RECORD CSCExpEXR;
PVOID CSCExpAddr;
NTSTATUS CSCExpCode;

LONG
MRxSmbCSCExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )


/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It first determines the true exception
    code by examining the exception record. If there is an Irp Context, then it inserts the status
    into the RxContext. Finally, it determines whether to handle the exception or bugcheck
    according to whether the except is one of the expected ones. in actuality, all exceptions are expected
    except for some lowlevel machine errors (see fsrtl\filter.c)

Arguments:

    RxContext    - the irp context of current operation for storing away the code.

    ExceptionPointer - Supplies the exception context.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;

    //save these values in statics so i can see 'em on the debugger............
    ExceptionCode = CSCExpCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    CSCExpAddr = ExceptionPointer->ExceptionRecord->ExceptionAddress;
    CSCExpEXR  = ExceptionPointer->ExceptionRecord;
    CSCExpCXR  = ExceptionPointer->ContextRecord;

    RxDbgTrace(0, Dbg, ("!!! ExceptioCode=%lx Addr=%lx EXR=%lx CXR=%lx\n", CSCExpCode, CSCExpAddr, CSCExpEXR, CSCExpCXR));
    RxLog(("!!! %lx %lx %lx %lx\n", CSCExpCode, CSCExpAddr, CSCExpEXR, CSCExpCXR));

//    ASSERT(FALSE);

    return EXCEPTION_EXECUTE_HANDLER;
}

#if defined(REMOTE_BOOT)
//
// Stolen from RTL, changed to use Zw APis.
//

NTSTATUS
ZwImpersonateSelf(
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This routine may be used to obtain an Impersonation token representing
    your own process's context.  This may be useful for enabling a privilege
    for a single thread rather than for the entire process; or changing
    the default DACL for a single thread.

    The token is assigned to the callers thread.



Arguments:

    ImpersonationLevel - The level to make the impersonation token.



Return Value:

    STATUS_SUCCESS -  The thread is now impersonating the calling process.

    Other - Status values returned by:

            ZwOpenProcessToken()
            ZwDuplicateToken()
            ZwSetInformationThread()

--*/

{
    NTSTATUS
        Status,
        IgnoreStatus;

    HANDLE
        Token1,
        Token2;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    SECURITY_QUALITY_OF_SERVICE
        Qos;


    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);

    Qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    Qos.ImpersonationLevel = ImpersonationLevel;
    Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    Qos.EffectiveOnly = FALSE;
    ObjectAttributes.SecurityQualityOfService = &Qos;

    Status = ZwOpenProcessToken( NtCurrentProcess(), TOKEN_DUPLICATE, &Token1 );

    if (NT_SUCCESS(Status)) {
        Status = ZwDuplicateToken(
                     Token1,
                     TOKEN_IMPERSONATE,
                     &ObjectAttributes,
                     FALSE,                 //EffectiveOnly
                     TokenImpersonation,
                     &Token2
                     );
        if (NT_SUCCESS(Status)) {
            Status = ZwSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &Token2,
                         sizeof(HANDLE)
                         );

            IgnoreStatus = ZwClose( Token2 );
        }


        IgnoreStatus = ZwClose( Token1 );
    }


    return(Status);

}


NTSTATUS
ZwAdjustPrivilege(
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,
    PBOOLEAN WasEnabled
    )

/*++

Routine Description:

    This procedure enables or disables a privilege process-wide.

Arguments:

    Privilege - The lower 32-bits of the privilege ID to be enabled or
        disabled.  The upper 32-bits is assumed to be zero.

    Enable - A boolean indicating whether the privilege is to be enabled
        or disabled.  TRUE indicates the privilege is to be enabled.
        FALSE indicates the privilege is to be disabled.

    Client - A boolean indicating whether the privilege should be adjusted
        in a client token or the process's own token.   TRUE indicates
        the client's token should be used (and an error returned if there
        is no client token).  FALSE indicates the process's token should
        be used.

    WasEnabled - points to a boolean to receive an indication of whether
        the privilege was previously enabled or disabled.  TRUE indicates
        the privilege was previously enabled.  FALSE indicates the privilege
        was previoulsy disabled.  This value is useful for returning the
        privilege to its original state after using it.


Return Value:

    STATUS_SUCCESS - The privilege has been sucessfully enabled or disabled.

    STATUS_PRIVILEGE_NOT_HELD - The privilege is not held by the specified context.

    Other status values as may be returned by:

            ZwOpenProcessToken()
            ZwAdjustPrivilegesToken()


--*/

{
    NTSTATUS
        Status,
        TmpStatus;

    HANDLE
        Token;

    LUID
        LuidPrivilege;

    PTOKEN_PRIVILEGES
        NewPrivileges,
        OldPrivileges;

    ULONG
        Length;

    UCHAR
        Buffer1[sizeof(TOKEN_PRIVILEGES)+
                ((1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES))],
        Buffer2[sizeof(TOKEN_PRIVILEGES)+
                ((1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES))];


    NewPrivileges = (PTOKEN_PRIVILEGES)Buffer1;
    OldPrivileges = (PTOKEN_PRIVILEGES)Buffer2;

    //
    // Open the appropriate token...
    //

    if (Client == TRUE) {
        Status = ZwOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                     FALSE,
                     &Token
                     );
    } else {

        Status = ZwOpenProcessToken(
                     NtCurrentProcess(),
                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                     &Token
                    );
    }

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertUlongToLuid(Privilege);


    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;



    //
    // Adjust the privilege
    //

    Status = ZwAdjustPrivilegesToken(
                 Token,                     // TokenHandle
                 FALSE,                     // DisableAllPrivileges
                 NewPrivileges,             // NewPrivileges
                 sizeof(Buffer1),           // BufferLength
                 OldPrivileges,             // PreviousState (OPTIONAL)
                 &Length                    // ReturnLength
                 );


    TmpStatus = ZwClose(Token);
    ASSERT(NT_SUCCESS(TmpStatus));


    //
    // Map the success code NOT_ALL_ASSIGNED to an appropriate error
    // since we're only trying to adjust the one privilege.
    //

    if (Status == STATUS_NOT_ALL_ASSIGNED) {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }


    if (NT_SUCCESS(Status)) {

        //
        // If there are no privileges in the previous state, there were
        // no changes made. The previous state of the privilege
        // is whatever we tried to change it to.
        //

        if (OldPrivileges->PrivilegeCount == 0) {

            (*WasEnabled) = Enable;

        } else {

            (*WasEnabled) =
                (OldPrivileges->Privileges[0].Attributes & SE_PRIVILEGE_ENABLED)
                ? TRUE : FALSE;
        }
    }

    return(Status);
}

//
// May move this into RTL someday, and let it access internals directly.
//

NTSTATUS
RtlGetSecurityInformationFromSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSECURITY_INFORMATION SecurityInformation
    )

/*++

Routine Description:

    This procedure sets the security information bits for fields
    that are valid in the security descriptor.

Arguments:

    SecurityDescriptor - The passed-in security descriptor.

    SecurityInformation - Returns the bitmask.

Return Value:

    STATUS_SUCCESS - The bitmask was returned successfully.

    Other status values if the security descriptor is invalid.

--*/

{
    SECURITY_INFORMATION BuiltSecurityInformation = 0;
    PACL TempAcl;
    PSID TempSid;
    BOOLEAN Present;
    BOOLEAN Defaulted;
    NTSTATUS Status;

    Status = RtlGetDaclSecurityDescriptor(SecurityDescriptor,
                                          &Present,
                                          &TempAcl,
                                          &Defaulted);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Present) {
        BuiltSecurityInformation |= DACL_SECURITY_INFORMATION;
    }

    Status = RtlGetSaclSecurityDescriptor(SecurityDescriptor,
                                          &Present,
                                          &TempAcl,
                                          &Defaulted);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Present) {
        BuiltSecurityInformation |= SACL_SECURITY_INFORMATION;
    }

    Status = RtlGetOwnerSecurityDescriptor(SecurityDescriptor,
                                           &TempSid,
                                           &Defaulted);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (TempSid != NULL) {
        BuiltSecurityInformation |= OWNER_SECURITY_INFORMATION;
    }

    Status = RtlGetGroupSecurityDescriptor(SecurityDescriptor,
                                           &TempSid,
                                           &Defaulted);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (TempSid != NULL) {
        BuiltSecurityInformation |= GROUP_SECURITY_INFORMATION;
    }

    *SecurityInformation = BuiltSecurityInformation;

    return STATUS_SUCCESS;

}
#endif

NTSTATUS
MRxSmbInitializeCSC (
    PUNICODE_STRING SmbMiniRedirectorName
    )
/*++

Routine Description:

    This routine initializes the CSC database

Arguments:

    SmbMiniRedirectorName - the mini redirector name

Return Value:

    STATUS_SUCCESS if successfull otherwise appropriate error

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING CscLinkName;
    ULONG ii;

    C_ASSERT(sizeof(GENERICHEADER)==64);
    C_ASSERT(sizeof(INODEHEADER)==sizeof(GENERICHEADER));
    C_ASSERT(sizeof(SHAREHEADER)==sizeof(GENERICHEADER));
    C_ASSERT(sizeof(FILEHEADER)==sizeof(GENERICHEADER));
    C_ASSERT(sizeof(QHEADER)==sizeof(GENERICHEADER));

    if(!MRxSmbIsCscEnabled) {
        return (STATUS_SUCCESS);
    }

    try {

        InitializeListHead(&xCscFcbsList);

        ExInitializeFastMutex(&CscServerEntryTransitioningMutex);
        KeInitializeEvent(
            &CscServerEntryTransitioningEvent,
            NotificationEvent,
            FALSE);

        //initialize the "semaphore" for the shadow critical section......
        InitializeShadowCritStructures();

        //create a symbolic link for the agent
        RtlInitUnicodeString(&CscLinkName,MRXSMB_CSC_SYMLINK_NAME);
        IoDeleteSymbolicLink(&CscLinkName);
        Status = IoCreateSymbolicLink(&CscLinkName,SmbMiniRedirectorName);
        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }

        MRxSmbCscLinkCreated = TRUE;

        try_exit: NOTHING;
        } finally {
        if (Status != STATUS_SUCCESS) {
            MRxSmbUninitializeCSC();
        }
    }
    return(Status);
}

VOID
MRxSmbUninitializeCSC(
    void
    )
/*++

Routine Description:

    This routine uninitializes the CSC database

Notes:


--*/
{
    NTSTATUS Status;
    ULONG ii;

    if(!MRxSmbIsCscEnabled) {
        return;
    }
    if (MRxSmbCscLinkCreated) {
        UNICODE_STRING CscLinkName;
        RtlInitUnicodeString(&CscLinkName,MRXSMB_CSC_SYMLINK_NAME);
        Status = IoDeleteSymbolicLink(&CscLinkName);
        ASSERT(Status==STATUS_SUCCESS);
    }

    ii = CloseShadowDB();
    CleanupShadowCritStructures();

    //get rid of references on events
    if (MRxSmbAgentSynchronizationEvent!=NULL) {
        ObDereferenceObject(MRxSmbAgentSynchronizationEvent);
        MRxSmbAgentSynchronizationEvent = NULL;
    }
    if (MRxSmbAgentFillEvent!=NULL) {
        ObDereferenceObject(MRxSmbAgentFillEvent);
        MRxSmbAgentFillEvent = NULL;
    }
}

// The CSC database access rights are stored in terms of SID. The SID is the
// user security id that persists across reboots. The retrieval of the SID
// is a complicated process. This mechanism is captured by the two routines
// CscRetrieveSid and CscDiscardSid. This mechanism is required to avoid
// redundant copying of the SID data from the buffer allocated by the security
// sub system to the redirector buffers. Consequently we need to create a new
// data type which contains the SID alongwith the context ( security allocated
// buffer ). This buffer is allocated on retrieval and freed on discard.

NTSTATUS
CscRetrieveSid(
    PRX_CONTEXT     pRxContext,
    PSID_CONTEXT    pSidContext)
/*++

Routine Description:

    This routine retrieves the SID associated with a given context

Arguments:

    RxContext - the RX_CONTEXT instance

    pSidContext - the SID context

Return Value:

    STATUS_SUCCESS if successfull otherwise appropriate error

Notes:


--*/
{
    NTSTATUS Status;

    PIO_SECURITY_CONTEXT pSecurityContext;

    PACCESS_TOKEN pToken;

    pSecurityContext    = pRxContext->Create.NtCreateParameters.SecurityContext;

    if (pSecurityContext != NULL) {
        pToken = pSecurityContext->AccessState->SubjectSecurityContext.ClientToken;

        if (pToken == NULL) {
            pToken = pSecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
        }
    } else {
        pSidContext->Context = NULL;
        pSidContext->pSid = NULL;
        return STATUS_SUCCESS;
    }

    if (pToken != NULL) {
        Status = SeQueryInformationToken(
                 pToken,
                 TokenUser,
                 &pSidContext->Context);

        if (Status == STATUS_SUCCESS) {
            PTOKEN_USER    pCurrentTokenUser;

            pCurrentTokenUser = (PTOKEN_USER)pSidContext->Context;

            pSidContext->pSid = pCurrentTokenUser->User.Sid;
        }
    }
    else {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

VOID
CscDiscardSid(
    PSID_CONTEXT pSidContext)
/*++

Routine Description:

    This routine discards the sid context

Arguments:

    pSidContext - the SID context

--*/
{
    PTOKEN_USER pTokenUser;

    pTokenUser = (PTOKEN_USER)pSidContext->Context;

    if (pTokenUser != NULL) {
        ASSERT(pTokenUser->User.Sid == pSidContext->pSid);

        ExFreePool(pTokenUser);
    }
}

BOOLEAN UseEagerEvaluation = TRUE;

BOOLEAN
CscpAccessCheck(
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation,
    ULONG                        CachedSecurityInformationLength,
    CSC_SID_INDEX                SidIndex,
    ACCESS_MASK                  AccessMask,
    BOOLEAN                      *pSidHasAccessMask
    )
/*++

Routine Description:

    This routine evaluates the access rights for a given SID index with the
    cached security information

Arguments:

    pCachedSecurityInformation - the cached security information

    CachedSecurityInformationLength - the cached security information length

    SidIndex - the SID index

    AccessMask - desired access

--*/
{
    CSC_SID_INDEX i;
    BOOLEAN AccessGranted = FALSE;

    *pSidHasAccessMask = FALSE;

    if (CachedSecurityInformationLength == sizeof(CACHED_SECURITY_INFORMATION)) {
        // Walk through the cached access rights to determine the
        // maximal permissible access rights.
        for (i = 0;
            ((i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) &&
            (pCachedSecurityInformation->AccessRights[i].SidIndex != SidIndex));
            i++) {
        }

        if (i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) {
            // Ensure that the desired access is a subset of the
            // maximal access rights allowed for this SID

            *pSidHasAccessMask = TRUE;

            AccessGranted = ((AccessMask &
                             pCachedSecurityInformation->AccessRights[i].MaximalRights)
                            == AccessMask);
        } else {
            // if the index cannot be found, ensure that the SID_INDEXES
            // are valid. If none of them are valid then we treat the
            // cached security information as being invalid and let the
            // access through

            for(i = 0;
                ((i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) &&
                (pCachedSecurityInformation->AccessRights[i].SidIndex ==
                CSC_INVALID_SID_INDEX));
                i++);

            if (i == CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) {
                AccessGranted = TRUE;
            }
        }
    } else if (CachedSecurityInformationLength == 0) {
        AccessGranted = TRUE;
    } else {
        AccessGranted = FALSE;
    }

    return AccessGranted;
}

BOOLEAN
CscAccessCheck(
    HSHADOW              hParent,
    HSHADOW              hFile,
    PRX_CONTEXT          RxContext,
    ACCESS_MASK          AccessMask,
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformationForShadow,
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformationForShare
    )
/*++

Routine Description:

    This routine performs the access check for a given LUID and an ACCESS_MASK
    against the saved rights

Arguments:

Return Value:

    TRUE -- if access is granted

    FALSE -- if access is denied

Notes:

    This routine is the primary routine for evaluating access rights. In order
    to acheive total encapsulation the signature of this routine needs to be
    specified such that the eager evaluation approach as well as the lazy
    evaluation approach can be supported.

    This is a kernel mode only routine.

    The ACCESS_MASK as specified in NT consists of two parts.. the lower 16 bits
    are specific rights ( specified by file system etc. ) while the upper 16 bits
    are generic rights common to all components.

    The cached access rights stored in the CSC data structure store the specific
    rights. Consequently the ACCESS_MASK specified needs to be stripped of the
    generic rights bit before comparing them.

--*/
{
    NTSTATUS    Status;
    BOOLEAN     AccessGranted = FALSE, SidHasAccessMask;
    SID_CONTEXT SidContext;

    Status = CscRetrieveSid(
         RxContext,
         &SidContext);

    if (Status == STATUS_SUCCESS) {
        if (UseEagerEvaluation) {
            HSHARE hShare = 0;

            CACHED_SECURITY_INFORMATION CachedSecurityInformation;

            ULONG BytesReturned,SidLength;
            DWORD CscStatus;
            CSC_SID_INDEX SidIndex;

            if (SidContext.pSid != NULL) {
                SidLength = RtlLengthSid(
                            SidContext.pSid);

            SidIndex = CscMapSidToIndex(
                       SidContext.pSid,
                       SidLength);
            } else {
                SidIndex = CSC_INVALID_SID_INDEX;
            }

            if (SidIndex == CSC_INVALID_SID_INDEX) {
                // The sid was not located in the existing Sid mappings
                // Map this Sid to that of a Guest
                SidIndex = CSC_GUEST_SID_INDEX;
            }

            // Check the share level ACL if there is any.
            if (GetAncestorsHSHADOW(
                    hFile,
                    NULL,
                    &hShare)) {

                BytesReturned = sizeof(CachedSecurityInformation);

                CscStatus = GetShareInfoEx(
                        hShare,
                        NULL,
                        NULL,
                        &CachedSecurityInformation,
                        &BytesReturned);

                // return the info if the caller want's it
                if (pCachedSecurityInformationForShare)
                {
                    *pCachedSecurityInformationForShare = CachedSecurityInformation;
                }

                if (CscStatus == ERROR_SUCCESS) {
                    AccessGranted = CscpAccessCheck(
                        &CachedSecurityInformation,
                        BytesReturned,
                        SidIndex,
                        AccessMask & FILE_SHARE_VALID_FLAGS,
                        &SidHasAccessMask
                        );

                    // if access was not granted for a non-guest
                    // because there was no accessmask for him, then check whether
                    // he should be allowed access as guest

                    if (!AccessGranted && (SidIndex != CSC_GUEST_SID_INDEX) && !SidHasAccessMask)
                    {
                        AccessGranted = CscpAccessCheck(
                            &CachedSecurityInformation,
                            BytesReturned,
                            CSC_GUEST_SID_INDEX,
                            AccessMask & FILE_SHARE_VALID_FLAGS,
                            &SidHasAccessMask
                            );

                    }
                }
            }

            if (AccessGranted) {

                BytesReturned = sizeof(CachedSecurityInformation);

                CscStatus = GetShadowInfoEx(
                    hParent,
                    hFile,
                    NULL,
                    NULL,
                    NULL,
                    &CachedSecurityInformation,
                    &BytesReturned);
                if (CscStatus == ERROR_SUCCESS) {

                    // return the info if the caller want's it
                    if (pCachedSecurityInformationForShadow)
                    {
                        *pCachedSecurityInformationForShadow = CachedSecurityInformation;
                    }

                    AccessGranted = CscpAccessCheck(
                        &CachedSecurityInformation,
                        BytesReturned,
                        SidIndex,
                        AccessMask & 0x1ff,
                        &SidHasAccessMask
                        );

                    // if access was not granted for a non-guest
                    // because there was no accessmask for him, then check whether
                    // he should be allowed access as guest
                    if (!AccessGranted && (SidIndex != CSC_GUEST_SID_INDEX) && !SidHasAccessMask)
                    {
                        AccessGranted = CscpAccessCheck(
                            &CachedSecurityInformation,
                            BytesReturned,
                            CSC_GUEST_SID_INDEX,
                            AccessMask & 0x1ff,
                            &SidHasAccessMask
                            );

                    }
                }
            }
        }

        CscDiscardSid(&SidContext);
    }

    if (RxContext->CurrentIrp && (RxContext->CurrentIrp->Tail.Overlay.OriginalFileObject->FileName.Length > 0)) {
        RxDbgTrace(0,Dbg,
            ("CscAccessCheck for %wZ DesiredAccess %lx AccessGranted %lx\n",
            &RxContext->CurrentIrp->Tail.Overlay.OriginalFileObject->FileName,
            AccessMask,
            AccessGranted));
    } else {
        RxDbgTrace(0,Dbg,
            ("CscAccessCheck for DesiredAccess %lx AccessGranted %lx\n",
            AccessMask,
            AccessGranted));
    }

    return AccessGranted;
}

NTSTATUS
MRxSmbCscAcquireSmbFcb (
    IN OUT PRX_CONTEXT RxContext,
    IN  ULONG TypeOfAcquirePlusFlags,
    OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

   This routine performs the readwrite synchronization that is required for
   keeping the cache consistent. Basically, the rule is many-readers-one-writer.
   This code relies on being able to use the minirdr context for links.

   A key concept here is that if we are entered and the minirdr context
   is nonull, then we are being reentered(!) after being queued and our
   acquire has succeeded.

Arguments:

    RxContext - the RDBSS context

    TypeOfAcquirePlusFlags -- flags for resource acquisition

    SmbFcbHoldingState -- resource holding state on exit

Return Value:

    NTSTATUS - STATUS_SUCCESS - the lock was acquired
           STATUS_CANCELLED - the operation was cancelled
                  while you were waiting
           STATUS_PENDING - the lock was not acquire; the operation
                will be issued when you do get it
           STATUS_LOCK_NOT_GRANTED - couldn't get it and fail
                     immediately was spec'd

Notes:


--*/
{
    NTSTATUS Status = STATUS_PENDING;
    RxCaptureFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    BOOLEAN MutexAcquired = FALSE;
    DEBUG_ONLY_DECL(BOOLEAN HadToWait = FALSE;)
    USHORT TypeOfAcquire = (USHORT)TypeOfAcquirePlusFlags;
    BOOLEAN FailImmediately = BooleanFlagOn(TypeOfAcquirePlusFlags,
                        FailImmediately_SmbFcbAcquire);
    BOOLEAN DroppingFcbLock = BooleanFlagOn(TypeOfAcquirePlusFlags,
                        DroppingFcbLock_SmbFcbAcquire);

    PMRXSMBCSC_SYNC_RX_CONTEXT pRxSyncContext
        = MRxSmbGetMinirdrContextForCscSync(RxContext);

    RxDbgTrace(0,Dbg,("MRxSmbCscAcquireSmbFcb"
        "  %08lx %08lx %08lx %08lx <%wZ>\n",
        RxContext, TypeOfAcquire,
        smbFcb, smbFcb->CscOutstandingReaders,
        GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));

    ASSERT ((TypeOfAcquire==Shared_SmbFcbAcquire)
           ||(TypeOfAcquire==Exclusive_SmbFcbAcquire));
    ASSERT (sizeof(MRXSMBCSC_SYNC_RX_CONTEXT) <= MRX_CONTEXT_SIZE);

    ExAcquireFastMutex(&MRxSmbSerializationMutex);
    MutexAcquired = TRUE;

    ASSERT(pRxSyncContext->Dummy == 0);

    if (pRxSyncContext->TypeOfAcquire == 0) {
        pRxSyncContext->TypeOfAcquire = TypeOfAcquire;
        pRxSyncContext->FcbLockWasDropped = FALSE;

        if (smbFcb->CscReadWriteWaitersList.Flink==NULL) {
            InitializeListHead(&smbFcb->CscReadWriteWaitersList);
        }

        do {
            if (pRxSyncContext->FcbLockWasDropped){
                NTSTATUS AStatus;
                RxDbgTrace(
                    0,Dbg,
                    ("MRxSmbCscAcquireSmbFcb %08lx acquireing fcblock\n",
                     RxContext));

                Status = RxAcquireExclusiveFcbResourceInMRx(capFcb);

                if (Status != STATUS_SUCCESS) {
                    break;
                }

                pRxSyncContext->FcbLockWasDropped = FALSE;

                Status = STATUS_PENDING;

                // Acquire the mutex again
                ExAcquireFastMutex(&MRxSmbSerializationMutex);
                MutexAcquired = TRUE;
            }

            //if no one is waiting, maybe we can get right in.....
            if (IsListEmpty(&smbFcb->CscReadWriteWaitersList)) {
                if (TypeOfAcquire==Shared_SmbFcbAcquire) {
                    if (smbFcb->CscOutstandingReaders >= 0) {
                        smbFcb->CscOutstandingReaders++;
                        Status = STATUS_SUCCESS;
                    }
                } else {
                    if (smbFcb->CscOutstandingReaders == 0) {
                        smbFcb->CscOutstandingReaders--; //sets to -1
                        Status = STATUS_SUCCESS;
                    }
                }
            }

            if ((Status == STATUS_PENDING) && FailImmediately) {
                Status = STATUS_LOCK_NOT_GRANTED;
            }

            if (Status == STATUS_PENDING) {
                InsertTailList(&smbFcb->CscReadWriteWaitersList,
                   &pRxSyncContext->CscSyncLinks);
                if (DroppingFcbLock) {
                    RxDbgTrace(
                        0,Dbg,
                        ("MRxSmbCscAcquireSmbFcb %08lx dropping fcblock\n",
                         RxContext));
                    RxReleaseFcbResourceInMRx(capFcb);
                    pRxSyncContext->FcbLockWasDropped = TRUE;
                }
                if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                    ASSERT(Status == STATUS_PENDING);
                    goto FINALLY;
                }

                KeInitializeEvent( &RxContext->SyncEvent,
                    NotificationEvent,
                    FALSE );
                ExReleaseFastMutex( &MRxSmbSerializationMutex );
                MutexAcquired = FALSE;
                RxWaitSync( RxContext );

                if (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_CANCELLED)) {
                    Status = STATUS_CANCELLED;
                } else {
                    Status = STATUS_SUCCESS;
                }
            }
        } while ( (pRxSyncContext->FcbLockWasDropped) && (Status == STATUS_SUCCESS) );
    } else {
        Status = STATUS_SUCCESS;
        DbgDoit(
            HadToWait = TRUE;
           )
    }

FINALLY:
    ASSERT(pRxSyncContext->Dummy == 0);
    if (MutexAcquired) {
        ExReleaseFastMutex(&MRxSmbSerializationMutex);
    }

    if (Status == STATUS_SUCCESS) {
        *SmbFcbHoldingState = TypeOfAcquire;
        RxDbgTrace(0,Dbg,("MRxSmbCscAcquireSmbFcb"
        " %08lx acquired %s %s c=%08lx,%08lx\n",
        RxContext,
        (TypeOfAcquire==Shared_SmbFcbAcquire)
                     ?"Shared":"Exclusive",
        (HadToWait)?"HadToWait":"W/O waiting",
        smbFcb->CscOutstandingReaders));
    }

    return(Status);
}

VOID
MRxSmbCscReleaseSmbFcb (
    IN OUT PRX_CONTEXT RxContext,
    IN SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

   This routine performs the readwrite synchronization that is required for
   keeping the cache consistent. Basically, the rule is many-readers-one-writer.
   This code relies on being able to use the minirdr context for links.

   A key concept here is that if we are entered and the minirdr context
   is nonull, then we are being reentered(!) after being queued and our
   acquire has succeeded.

Arguments:

    RxContext - the RDBSS context

Return Value:


Notes:


--*/
{
    NTSTATUS Status = STATUS_PENDING;
    RxCaptureFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    BOOLEAN Reader = (RxContext->MajorFunction == IRP_MJ_READ);

    PMRXSMBCSC_SYNC_RX_CONTEXT pRxSyncContext
        = MRxSmbGetMinirdrContextForCscSync(RxContext);

    RxDbgTrace(0,Dbg,("MRxSmbCscReleaseSmbFcb entry"
        "  %08lx %08lx %08lx <%wZ>\n",
        RxContext, smbFcb,
        smbFcb->CscOutstandingReaders,
        GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));

    ASSERT(pRxSyncContext->Dummy == 0);
    ASSERT(*SmbFcbHoldingState!=SmbFcb_NotHeld);

    ExAcquireFastMutex(&MRxSmbSerializationMutex);

    //first, undo my doings.....
    if (*SmbFcbHoldingState == SmbFcb_HeldShared) {
        ASSERT(smbFcb->CscOutstandingReaders>0);
        smbFcb->CscOutstandingReaders--;
    } else {
        ASSERT(smbFcb->CscOutstandingReaders==-1);
        smbFcb->CscOutstandingReaders++; //sets it to zero
    }

    //now start up some guys who may be waiting
    if (!IsListEmpty(&smbFcb->CscReadWriteWaitersList)) {

        PLIST_ENTRY ListEntry = smbFcb->CscReadWriteWaitersList.Flink;

        for (;ListEntry != &smbFcb->CscReadWriteWaitersList;) {
            PLIST_ENTRY ThisListEntry = ListEntry;
            PMRXSMBCSC_SYNC_RX_CONTEXT innerRxSyncContext
                =  CONTAINING_RECORD(ListEntry,
                       MRXSMBCSC_SYNC_RX_CONTEXT,
                       CscSyncLinks);
            PRX_CONTEXT innerRxContext
                = CONTAINING_RECORD(innerRxSyncContext,
                      RX_CONTEXT,
                      MRxContext[0]);
            ULONG innerTypeOfAcquire = (innerRxSyncContext->TypeOfAcquire);

            //move down the list before removing this entry!!!
            ListEntry = ListEntry->Flink;

            // in the followng, Routine is used to restart an async guy. only
            // create, read, and write currently come thru here and of these
            // only read and write are async. so it is okay to ignore create
            // w.r.t. seeting the Routine
            ASSERT(innerRxSyncContext->Dummy == 0);

            if (!innerRxSyncContext->FcbLockWasDropped) {
                if (innerTypeOfAcquire==Shared_SmbFcbAcquire) {
                    if (smbFcb->CscOutstandingReaders < 0) break;
                    smbFcb->CscOutstandingReaders++;
                } else {
                    if (smbFcb->CscOutstandingReaders != 0) break;
                    smbFcb->CscOutstandingReaders--; //sets to -1
                }
            }
            ASSERT(&innerRxSyncContext->CscSyncLinks == ThisListEntry);
            RemoveEntryList(ThisListEntry);
            RxDbgTrace(
                0,Dbg,
                ("MRxSmbCscReleaseSmbFcb acquired after for %s c=%08lx, %08lx\n",
                 (innerTypeOfAcquire==Shared_SmbFcbAcquire)
                  ?"Shared":"Exclusive",
                 smbFcb->CscOutstandingReaders,
                 innerRxContext));
            if (FlagOn(innerRxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                NTSTATUS PostStatus;
                DbgDoit(InitializeListHead(&innerRxSyncContext->CscSyncLinks);)

                PostStatus = RxPostToWorkerThread(
                                 MRxSmbDeviceObject,
                                 CriticalWorkQueue,
                                 &innerRxContext->WorkQueueItem,
                                 MRxSmbResumeAsyncReadWriteRequests,
                                 innerRxContext);
                ASSERT(PostStatus == STATUS_SUCCESS);
            } else {
                RxSignalSynchronousWaiter(innerRxContext);
            }
        }
    }

    ASSERT(smbFcb->CscOutstandingReaders>=-1);

    ExReleaseFastMutex(&MRxSmbSerializationMutex);
    *SmbFcbHoldingState = SmbFcb_NotHeld;

    RxDbgTrace(0,Dbg,("MRxSmbCscReleaseSmbFcb exit"
        "  %08lx %08lx\n", RxContext, smbFcb->CscOutstandingReaders));
}

VOID
MRxSmbCscSetFileInfoEpilogue (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PNTSTATUS   Status
    )
/*++

Routine Description:

   This routine performs the tail of a write operation for CSC. In
   particular, if the written data overlaps or extends the cached prefix
   then we write the data into the cache.

   The status of the write operation is passed in case we someday find
   things are so messed up that we want to return a failure even after
   a successful read. not today however...

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS LocalStatus = STATUS_SUCCESS;
    ULONG iRet,ShadowFileLength;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    BOOLEAN EnteredCriticalSection = FALSE;

    FILE_INFORMATION_CLASS  FileInformationClass;
    PVOID                   pBuffer;
    ULONG                   BufferLength;

    _WIN32_FIND_DATA        Find32;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
     = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);

    BOOLEAN fDisconnected;

    ULONG uShadowStatus;
    DWORD   dwNotifyFilter=0;


    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)||
        (!smbFcb->hShadow)
        ) {
        return;
    }

    fDisconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    RxDbgTrace(+1, Dbg,
    ("MRxSmbCscSetFileInfoEpilogue...%08lx  on handle %08lx\n",
        RxContext,
        smbSrvOpen->hfShadow ));

    if (*Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("MRxSmbCscSetFileInfoEpilogue exit w/o extending -> %08lx\n", Status ));
        goto FINALLY;
    }

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    BufferLength = RxContext->Info.Length;

    RxDbgTrace(0, Dbg,
    ("MRxSmbCscSetFileInfoEpilogue: Class %08lx size %08lx\n",
        FileInformationClass,BufferLength));

    switch (FileInformationClass) {
        case FileBasicInformation:
        break;

        case FileAllocationInformation:
        break;

        case FileEndOfFileInformation:
        break;

        case FileDispositionInformation:
        break;

        case FileRenameInformation:
        default:

        goto FINALLY;
   }

    EnterShadowCritRx(RxContext);
    EnteredCriticalSection = TRUE;

    if(GetShadowInfo(smbFcb->hParentDir,
             smbFcb->hShadow,
             &Find32,
             &uShadowStatus, NULL) < SRET_OK) {
        goto FINALLY;
    }

    // Bypass the shadow if it is not visibile for this connection
    if (!IsShadowVisible(fDisconnected,
             Find32.dwFileAttributes,
             uShadowStatus)) {
        goto FINALLY;
    }

    if (FileInformationClass==FileBasicInformation) {
        //copy the stuff from the userbuffer as appropriate...these values
        //must be appropriate since we were successful
        PFILE_BASIC_INFORMATION BasicInfo = (PFILE_BASIC_INFORMATION)pBuffer;
        if (BasicInfo->FileAttributes != 0) {
            Find32.dwFileAttributes = ((BasicInfo->FileAttributes & ~(FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_DIRECTORY))
                                        | (Find32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY));
                                        ;
            dwNotifyFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES;
            if (fDisconnected)
            {
                uShadowStatus |= SHADOW_ATTRIB_CHANGE;
                smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_SHADOW_ATTRIB_MODIFIED;
            }
        }
        if ((BasicInfo->CreationTime.QuadPart != 0)&&
                (BasicInfo->CreationTime.QuadPart != 0xffffffffffffffff))
        {
            COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32.ftCreationTime,
                            BasicInfo->CreationTime);
        }
        if ((BasicInfo->LastAccessTime.QuadPart != 0) &&
            (BasicInfo->LastAccessTime.QuadPart != 0xffffffffffffffff))
        {
            COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32.ftLastAccessTime,
                            BasicInfo->LastAccessTime);
        }

        //
        //  If the user is specifying -1 for a field, that means
        //  we should leave that field unchanged, even if we might
        //  have otherwise set it ourselves.  We'll set the Ccb flag
        //  saying that the user set the field so that we
        //  don't do our default updating.
        //
        //  We set the field to 0 then so we know not to actually
        //  set the field to the user-specified (and in this case,
        //  illegal) value.
        //

       if (BasicInfo->LastWriteTime.QuadPart == 0xffffffffffffffff)
       {
           BasicInfo->LastWriteTime.QuadPart = 0;

           if (fDisconnected)
           {
               smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_SHADOW_LWT_MODIFIED;
           }
       }

       if (BasicInfo->LastWriteTime.QuadPart != 0)
       {
           ASSERT(BasicInfo->LastWriteTime.QuadPart != 0xffffffffffffffff);

            COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32.ftLastWriteTime,
                            BasicInfo->LastWriteTime);
            if (fDisconnected)
            {
                uShadowStatus |= SHADOW_TIME_CHANGE;
                smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_SHADOW_LWT_MODIFIED;
            }
            dwNotifyFilter |= FILE_NOTIFY_CHANGE_LAST_WRITE;
        }
    }
    else if (FileInformationClass==FileDispositionInformation)
    {
        if (fDisconnected)
        {
            // if this is a file and we are trying to delete it
            // without permissions, then bail

            if (!(Find32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)&&
                !(FILE_WRITE_DATA & smbSrvOpen->MaximalAccessRights)&&
                !(FILE_WRITE_DATA & smbSrvOpen->GuestMaximalAccessRights))
            {
                *Status = STATUS_ACCESS_DENIED;
                RxLog(("No rights to del %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
                HookKdPrint(BADERRORS, ("No rights to del %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
            }
            else
            {
                LocalStatus = OkToDeleteObject(smbFcb->hParentDir, smbFcb->hShadow, &Find32, uShadowStatus, fDisconnected);

                if (LocalStatus != STATUS_SUCCESS)
                {
                    RxLog(("Can't del %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
                    *Status = LocalStatus;
                }
            }
        }

        goto FINALLY;

    }
    else {
        //basically, all i can do here is to ensure that the shadow is no bigger than the size
        //given, whether allocationsize or filesize. when we read back the actual size at close
        //some readjusting may be required so we turn sparse on.
        PFILE_END_OF_FILE_INFORMATION UserEndOfFileInformation
                         = (PFILE_END_OF_FILE_INFORMATION)pBuffer;
        int iRet;
        ULONG ShadowFileLength;

        ASSERT( FIELD_OFFSET(FILE_END_OF_FILE_INFORMATION,EndOfFile)
                       == FIELD_OFFSET(FILE_ALLOCATION_INFORMATION,AllocationSize) );

        //don't need the shadowreadwritemutex here because SetFileInfo has both resources...
        //thus, no other operations can come down

        if (!(CSCHFILE)(smbSrvOpen->hfShadow))
        {
            if (fDisconnected)
            {
                *Status = STATUS_OBJECT_TYPE_MISMATCH;
            }

            goto FINALLY;
        }
        iRet = GetFileSizeLocal((CSCHFILE)(smbSrvOpen->hfShadow), &ShadowFileLength);
        if (iRet<0) {
            if (fDisconnected)
            {
                *Status = STATUS_UNSUCCESSFUL;
            }
            goto FINALLY;
        }
        if (ShadowFileLength != UserEndOfFileInformation->EndOfFile.QuadPart) {
            NTSTATUS SetStatus;
            PNT5CSC_MINIFILEOBJECT MiniFileObject
               = (PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow);
            IO_STATUS_BLOCK IoStatusBlock;
            ULONG DummyReturnedLength;

            // If we are connected, don't extend sparse files!!!!
            if (fDisconnected ||
                (!(uShadowStatus & SHADOW_SPARSE) || (ShadowFileLength > UserEndOfFileInformation->EndOfFile.QuadPart)))
            {
//                DbgPrint("SetEof on %x Old=%x New=%x \n", smbFcb->hShadow,  ShadowFileLength, UserEndOfFileInformation->EndOfFile.QuadPart);

                SetStatus = Nt5CscXxxInformation(
                        (PCHAR)IRP_MJ_SET_INFORMATION,
                        MiniFileObject,
                        FileEndOfFileInformation,
                        sizeof(FILE_END_OF_FILE_INFORMATION),
                        pBuffer,
                        &DummyReturnedLength
                        );
            }

#if defined(BITCOPY)
            // Do I need to check if EOFinfo (a 64-bit value) is using
            // the upper 32 bits? CscBmp library only supports 32-bit
            // file sizes.
            if (smbFcb->lpDirtyBitmap && fDisconnected &&
                    UserEndOfFileInformation->EndOfFile.HighPart == 0) {
                // Is it ShadowFileLength?
                CscBmpResize(
                    smbFcb->lpDirtyBitmap,
                    (DWORD)UserEndOfFileInformation->EndOfFile.QuadPart);
            } else if (UserEndOfFileInformation->EndOfFile.HighPart != 0) {
                // File is too big to be represented by a CscBmp, delete.
                CscBmpMarkInvalid(smbFcb->lpDirtyBitmap);
            }
#endif // defined(BITCOPY)

            if (fDisconnected)
            {
                uShadowStatus |= SHADOW_DIRTY;
                dwNotifyFilter |= FILE_NOTIFY_CHANGE_SIZE;
            }
            mSetBits(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED);
            Find32.nFileSizeLow = (DWORD)UserEndOfFileInformation->EndOfFile.QuadPart;
        }

    }

    if (fDisconnected)
    {
        MarkShareDirty(&smbFcb->sCscRootInfo.ShareStatus, smbFcb->sCscRootInfo.hShare);
    }

    if(SetShadowInfo(smbFcb->hParentDir,
             smbFcb->hShadow,
             &Find32,
             uShadowStatus,
             SHADOW_FLAGS_ASSIGN
            | ((fDisconnected)?SHADOW_FLAGS_DONT_UPDATE_ORGTIME
                      :0)
             ) < SRET_OK) {
        goto FINALLY;
    }


FINALLY:
    if (EnteredCriticalSection) {
        LeaveShadowCritRx(RxContext);
    }

    // in disconnected state, report the changes
    if (fDisconnected && dwNotifyFilter)
    {
        FsRtlNotifyFullReportChange(
            pNetRootEntry->NetRoot.pNotifySync,
            &pNetRootEntry->NetRoot.DirNotifyList,
            (PSTRING)GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb),
            (USHORT)(GET_ALREADY_PREFIXED_NAME(SrvOpen, capFcb)->Length -
                        smbFcb->MinimalCscSmbFcb.LastComponentLength),
            NULL,
            NULL,
            dwNotifyFilter,
            FILE_ACTION_MODIFIED,
            NULL);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscSetFileInfoEpilogue -> %08lx\n", Status ));
    return;
}

//this could easily bein a .h file

int IoctlRegisterAgent(
   ULONG_PTR uHwnd
   );

int IoctlUnRegisterAgent(
   ULONG_PTR uHwnd
   );

int IoctlGetUNCPath(
   LPCOPYPARAMS lpCopyParams
   );

int IoctlBeginPQEnum(
   LPPQPARAMS lpPQPar
   );

int IoctlEndPQEnum(
   LPPQPARAMS lpPQPar
   );

int IoctlNextPriShadow(
   LPPQPARAMS lpPQPar
   );

int IoctlPrevPriShadow(
   LPPQPARAMS lpPQPar
   );

int IoctlGetShadowInfo(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlSetShadowInfo(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlChkUpdtStatus(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlDoShadowMaintenance(
   LPSHADOWINFO   lpSI
   );

BOOLEAN
CscCheckForNullW(
    PWCHAR pBuf,
    ULONG Count);

NTSTATUS
MRxSmbCscIoctlOpenForCopyChunk (
    PRX_CONTEXT RxContext
    );
NTSTATUS
MRxSmbCscIoctlCloseForCopyChunk (
    PRX_CONTEXT RxContext
    );
NTSTATUS
MRxSmbCscIoctlCopyChunk (
    PRX_CONTEXT RxContext
    );

int IoctlBeginReint(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlEndReint(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlCreateShadow(
   LPSHADOWINFO lpSI
   );

int IoctlDeleteShadow(
   LPSHADOWINFO   lpSI
   );

int IoctlGetShareStatus(
   LPSHADOWINFO   lpSI
   );

int IoctlSetShareStatus(
   LPSHADOWINFO   lpSI
   );

int IoctlAddUse(
   LPCOPYPARAMS lpCP
   );

int IoctlDelUse(
   LPCOPYPARAMS lpCP
   );

int IoctlGetUse(
   LPCOPYPARAMS lpCP
   );

int IoctlSwitches(LPSHADOWINFO lpSI);

int IoctlGetShadow(
   LPSHADOWINFO lpSI
   );

int IoctlAddHint(      // Add a new hint or change an existing hint
   LPSHADOWINFO   lpSI
   );

int IoctlDeleteHint(   // Delete an existing hint
   LPSHADOWINFO lpSI
   );

int IoctlGetHint(
   LPSHADOWINFO   lpSI
   );

int IoctlGetGlobalStatus(
   ULONG SessionId,
   LPGLOBALSTATUS lpGS
   );

int IoctlFindOpenHSHADOW
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindNextHSHADOW
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindCloseHSHADOW
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindOpenHint
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindNextHint
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindCloseHint
   (
   LPSHADOWINFO   lpSI
   );

int IoctlSetPriorityHSHADOW(
   LPSHADOWINFO   lpSI
   );

int IoctlGetPriorityHSHADOW(
   LPSHADOWINFO   lpSI
   );

int IoctlGetAliasHSHADOW(
   LPSHADOWINFO   lpSI
   );

#define CSC_CASE(__case)         \
    case __case:                 \
    RxDbgTrace(0,Dbg,("MRxSmbCscIoctl %08lx %s %08lx %08lx\n",RxContext,#__case,InputBuffer,OutputBuffer));

ULONG GetNextPriShadowCount = 0;

NTSTATUS
MRxSmbCscIoCtl(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine performs the special IOCTL operation for the CSC agent.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    ShadowIRet is overloaded: 
         -1 == error, copy the error back
          0 == error, return Wrong password (STATUS_WRONG_PASSWORD)
          1 == success, output params, copy them back
          2 == return status unmodified, no output params


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG   IoControlCode = LowIoContext->ParamsFor.IoCtl.IoControlCode;
    PBYTE   InputBuffer = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    PBYTE   pNewInputBuffer=NULL;
    ULONG   InputBufferLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PBYTE   OutputBuffer = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;
    ULONG   OutputBufferLength = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
    LONG    ShadowIRet = 0;
    CAPTURE_BUFFERS sCapBuff;
    PBYTE   pAuxBuf = NULL;
    PBYTE   pOrgBuf = NULL;
    BOOLEAN SuppressFinalTrace = FALSE, fEnteredShadowCrit=FALSE;
    KPROCESSOR_MODE RequestorMode;
    ULONG   SessionId = 0;

#if defined (_WIN64)
    if (IoIs32bitProcess(RxContext->CurrentIrp)) {
        RxDbgTrace(0, Dbg, ("32 bit IOCTL in 64 bit returning STATUS_NOT_IMPLEMENTED\n"));
        return STATUS_NOT_IMPLEMENTED;
    }
#endif // _WIN64

    
    if (RxContext != NULL && RxContext->CurrentIrp != NULL)
        IoGetRequestorSessionId(RxContext->CurrentIrp, &SessionId);

    try
    {
        RequestorMode = RxContext->CurrentIrp->RequestorMode;

        if (
            RequestorMode != KernelMode
                &&
            IoControlCode != IOCTL_GET_DEBUG_INFO
        ) {
            if (CaptureInputBufferIfNecessaryAndProbe(
                        IoControlCode,
                        RxContext,
                        InputBuffer,
                        &sCapBuff,
                        &pAuxBuf,
                        &pOrgBuf,
                        &pNewInputBuffer)!=STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg, ("Invalid parameters for Ioctl=%x\n", IoControlCode));
                return STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            pNewInputBuffer = InputBuffer;
        }
        // DbgPrint("MRxSmbCscIoCtl IoControlCode=%d\n", (IoControlCode >> 2) & 0xfff);
        switch (IoControlCode) {
        CSC_CASE(IOCTL_SHADOW_GETVERSION)
        Status = (NTSTATUS)(SHADOW_VERSION); // no-op
        break;

        CSC_CASE(IOCTL_SHADOW_REGISTER_AGENT)
        ShadowIRet = IoctlRegisterAgent((ULONG_PTR)pNewInputBuffer);
        if (ShadowIRet>=0) {
            MRxSmbCscReleaseRxContextFromAgentWait();
        }
        break;

        CSC_CASE(IOCTL_SHADOW_UNREGISTER_AGENT)
        ShadowIRet = IoctlUnRegisterAgent((ULONG_PTR)pNewInputBuffer);
        if (ShadowIRet>=0) {
            MRxSmbCscReleaseRxContextFromAgentWait();
        }
        break;

        CSC_CASE(IOCTL_SHADOW_GET_UNC_PATH)
        ShadowIRet = IoctlGetUNCPath((LPCOPYPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_BEGIN_PQ_ENUM)
        ShadowIRet = IoctlBeginPQEnum((LPPQPARAMS)pNewInputBuffer);
        GetNextPriShadowCount = 0;
        break;

        CSC_CASE(IOCTL_SHADOW_END_PQ_ENUM)
        ShadowIRet = IoctlEndPQEnum((LPPQPARAMS)pNewInputBuffer);
        break;

        //CSC_CASE(IOCTL_SHADOW_NEXT_PRI_SHADOW)
        case IOCTL_SHADOW_NEXT_PRI_SHADOW:                 \
        if ((GetNextPriShadowCount<6) || ((GetNextPriShadowCount%40)==0)) {
            RxDbgTrace(0,Dbg,("MRxSmbCscIoctl %08lx %s(%d) %08lx %08lx\n",
                       RxContext,
                       "IOCTL_SHADOW_NEXT_PRI_SHADOW",GetNextPriShadowCount,
                       pNewInputBuffer,OutputBuffer));
        }
        ShadowIRet = IoctlNextPriShadow((LPPQPARAMS)pNewInputBuffer);
        GetNextPriShadowCount++;
        SuppressFinalTrace = TRUE;
        break;

        CSC_CASE(IOCTL_SHADOW_PREV_PRI_SHADOW)
        ShadowIRet = IoctlPrevPriShadow((LPPQPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_GET_SHADOW_INFO)
        ShadowIRet = IoctlGetShadowInfo((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_SET_SHADOW_INFO)
        ShadowIRet = IoctlSetShadowInfo((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_CHK_UPDT_STATUS)
        ShadowIRet = IoctlChkUpdtStatus((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_DO_SHADOW_MAINTENANCE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

#if defined(REMOTE_BOOT)
            // If this IOCTL is for turning caching back on we need to update
            // the mini redirector accordingly.
            if ((pShadowInfo->uOp == SHADOW_CHANGE_HANDLE_CACHING_STATE) &&
                (pShadowInfo->uStatus != FALSE)) {
                RxDbgTrace(0, Dbg, ("RB Client : Turning caching back on\n"));
                MRxSmbOplocksDisabledOnRemoteBootClients = FALSE;
            }
#endif // defined(REMOTE_BOOT)

            ShadowIRet = IoctlDoShadowMaintenance(pShadowInfo);
        }
        break;

        CSC_CASE(IOCTL_GET_DEBUG_INFO)
        ShadowIRet = 2;
        Status = IoctlGetDebugInfo(
                    RxContext,
                    InputBuffer,
                    InputBufferLength,
                    OutputBuffer,
                    OutputBufferLength);
        break;

        CSC_CASE(IOCTL_SHADOW_COPYCHUNK)
        ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
        Status = MRxSmbCscIoctlCopyChunk(RxContext);
        break;

        CSC_CASE(IOCTL_CLOSEFORCOPYCHUNK)
        ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
        Status = MRxSmbCscIoctlCloseForCopyChunk(RxContext);
        break;

        CSC_CASE(IOCTL_OPENFORCOPYCHUNK)
        ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
        Status = MRxSmbCscIoctlOpenForCopyChunk(RxContext);
        break;

        CSC_CASE(IOCTL_IS_SERVER_OFFLINE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            if (pShadowInfo->lpBuffer == NULL
                    ||
                CscCheckForNullW(pShadowInfo->lpBuffer, pShadowInfo->cbBufferSize/sizeof(WCHAR)) == TRUE
            ) {
                ShadowIRet = 1;
                pShadowInfo->uStatus = CscIsServerOffline((PWCHAR)pShadowInfo->lpBuffer);
            }

        }
        break;

        CSC_CASE(IOCTL_TAKE_SERVER_OFFLINE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            if (pShadowInfo->lpBuffer != NULL
                    &&
                CscCheckForNullW(pShadowInfo->lpBuffer, pShadowInfo->cbBufferSize/sizeof(WCHAR)) == TRUE
            ) {
                ShadowIRet = 1;
                pShadowInfo->uStatus = CscTakeServerOffline( (PWCHAR)pShadowInfo->lpBuffer);
            }

        }
        break;

        CSC_CASE(IOCTL_TRANSITION_SERVER_TO_OFFLINE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
            Status = CscTransitionServerToOffline(
                 SessionId,
                 pShadowInfo->hShare,
                 pShadowInfo->uStatus);
            // DbgPrint("###IOCTL_TRANSITION_SERVER_TO_OFFLINE: pulsing fill event\n");
            MRxSmbCscSignalFillAgent(NULL, 0);
        }
        break;

        CSC_CASE(IOCTL_TRANSITION_SERVER_TO_ONLINE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
            Status = CscTransitionServerToOnline(
                 pShadowInfo->hShare);
            // DbgPrint("###IOCTL_TRANSITION_SERVER_TO_ONLINE: pulsing fill event\n");
            MRxSmbCscSignalFillAgent(NULL, 0);
        }
        break;

        CSC_CASE(IOCTL_NAME_OF_SERVER_GOING_OFFLINE)
        {
            LPSHADOWINFO lpSI = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = 1;

            CscGetServerNameWaitingToGoOffline(
                    lpSI->lpBuffer,
                    &(lpSI->cbBufferSize),
                    &Status);
            if (Status == STATUS_BUFFER_TOO_SMALL)
            {
                ((LPSHADOWINFO)InputBuffer)->cbBufferSize = lpSI->cbBufferSize;

                HookKdPrint(ALWAYS, ("Buffer too small, Need %d \n", ((LPSHADOWINFO)InputBuffer)->cbBufferSize));
            }
        }
        break;

        CSC_CASE(IOCTL_SHAREID_TO_SHARENAME)
        {
            LPSHADOWINFO lpSI = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = 1;

            CscShareIdToShareName(
                    lpSI->hShare,
                    lpSI->lpBuffer,
                    &(lpSI->cbBufferSize),
                    &Status);
            if (Status == STATUS_BUFFER_TOO_SMALL) {
                ((LPSHADOWINFO)InputBuffer)->cbBufferSize = lpSI->cbBufferSize;

                HookKdPrint(
                    ALWAYS,
                    ("Buffer small, Need %d \n", ((LPSHADOWINFO)InputBuffer)->cbBufferSize));
            } else if (Status != STATUS_SUCCESS) {
                lpSI->dwError = ERROR_FILE_NOT_FOUND;
                ShadowIRet = -1;
            }
        }
        break;


        CSC_CASE(IOCTL_SHADOW_BEGIN_REINT)
        ShadowIRet = CSCBeginReint(RxContext, (LPSHADOWINFO)pNewInputBuffer);
        if (ShadowIRet >= 1)
        {
            ShadowIRet = 2;
            Status = STATUS_PENDING;
        }
        break;

        CSC_CASE(IOCTL_SHADOW_END_REINT)
        ShadowIRet = CSCEndReint((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_CREATE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = -1;
            if (pShadowInfo->lpFind32
                   &&
                CscCheckForNullW(pShadowInfo->lpFind32->cFileName, MAX_PATH) == TRUE
            ) {
                ShadowIRet = IoctlCreateShadow(pShadowInfo);
            }
        }
        break;

        CSC_CASE(IOCTL_SHADOW_DELETE)
        ShadowIRet = IoctlDeleteShadow((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_GET_SHARE_STATUS)
        ShadowIRet = IoctlGetShareStatus((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SET_SHARE_STATUS)
        ShadowIRet = IoctlSetShareStatus((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_ADDUSE)
        //ShadowIRet = IoctlAddUse((LPCOPYPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_DELUSE)
        //ShadowIRet = IoctlDelUse((LPCOPYPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_GETUSE)
        //ShadowIRet = IoctlGetUse((LPCOPYPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SWITCHES)
        ShadowIRet = IoctlSwitches((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_GETSHADOW)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = -1;
            if (pShadowInfo->lpFind32
                   &&
                CscCheckForNullW(pShadowInfo->lpFind32->cFileName, MAX_PATH) == TRUE
            ) {
                ShadowIRet = IoctlGetShadow(pShadowInfo);
            }
        }
        break;

        CSC_CASE(IOCTL_GETGLOBALSTATUS)
        ShadowIRet = IoctlGetGlobalStatus(SessionId, (LPGLOBALSTATUS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_FINDOPEN_SHADOW)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = -1;
            if (pShadowInfo->lpFind32
                   &&
                CscCheckForNullW(pShadowInfo->lpFind32->cFileName, MAX_PATH) == TRUE
            ) {
                ShadowIRet = IoctlFindOpenHSHADOW(pShadowInfo);
            }
        }
        break;

        CSC_CASE(IOCTL_FINDNEXT_SHADOW)
        ShadowIRet = IoctlFindNextHSHADOW((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_FINDCLOSE_SHADOW)
        ShadowIRet = IoctlFindCloseHSHADOW((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_GETPRIORITY_SHADOW)
        ShadowIRet = IoctlGetPriorityHSHADOW((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SETPRIORITY_SHADOW)
        ShadowIRet = IoctlSetPriorityHSHADOW((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_ADD_HINT)
        ShadowIRet = IoctlAddHint((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_DELETE_HINT)
        ShadowIRet = IoctlDeleteHint((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_FINDOPEN_HINT)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = -1;
            if (pShadowInfo->lpFind32
                   &&
                CscCheckForNullW(pShadowInfo->lpFind32->cFileName, MAX_PATH) == TRUE
            ) {
                ShadowIRet = IoctlFindOpenHint(pShadowInfo);
            }
        }
        break;

        CSC_CASE(IOCTL_FINDNEXT_HINT)
        ShadowIRet = IoctlFindNextHint((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_FINDCLOSE_HINT)
        ShadowIRet = IoctlFindCloseHint((LPSHADOWINFO)pNewInputBuffer);
        break;

        default:
        RxDbgTrace(-1, Dbg, ("MRxSmbCscIoCtl not csc ioctl-> %08lx\n", Status ));
        return Status;
        }
        if (ShadowIRet == 0) {
                Status = STATUS_WRONG_PASSWORD;
        } else if (ShadowIRet == -1) {
            if (RequestorMode != KernelMode)
            {
                CopyBackIfNecessary(
                    IoControlCode,
                    InputBuffer,
                    &sCapBuff,
                    pAuxBuf,
                    pOrgBuf,
                    FALSE);
            }
            Status = STATUS_UNSUCCESSFUL;
        } else if (ShadowIRet == 1) {

            if (RequestorMode != KernelMode)
            {
                CopyBackIfNecessary(
                    IoControlCode,
                    InputBuffer,
                    &sCapBuff,
                    pAuxBuf,
                    pOrgBuf,
                    TRUE);
            }

            Status = STATUS_SUCCESS;
        }

        if (SuppressFinalTrace) {
            RxDbgTraceUnIndent(-1, Dbg);
        } else {
            RxDbgTrace(-1, Dbg,
                ("MRxSmbCscIoCtl -> %08lx %08lx\n", Status, ShadowIRet ));
        }
    }
    except(MRxSmbCSCExceptionFilter( RxContext, GetExceptionInformation() ))
    {
        RxDbgTrace(0, Dbg, ("MrxSmbCSCIoctl: took an exception \r\n"));
        LeaveShadowCritIfThisThreadOwnsIt();
        Status = STATUS_INVALID_PARAMETER;
    }

    if (pAuxBuf != NULL) {
        // DbgPrint("Freeing pAuxBuf\n");
        RxFreePool(pAuxBuf);
    }

    // DbgPrint("MRxSmbCscIoCtl exit 0x%x\n", Status);
    return Status;
}

NTSTATUS
MRxSmbCscObtainShareHandles (
    IN OUT PUNICODE_STRING         ShareName,
    IN BOOLEAN                     DisconnectedMode,
    IN BOOLEAN                     CopyChunkOpen,
    IN OUT PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
)
/*++

Routine Description:

   This routine performs the obtains the handles (Share and root directory)
   for a particular \server\share, updating the values in the netrootentry
   if found.

Arguments:

    pNetRootEntry - the SMB MRX net root data structure

Return Value:

    NTSTATUS - The return status for the operation
          STATUS_NOT_INPLEMENTED - couldn't find or create
          STATUS_SUCCESS - found or created

Notes:

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    BOOLEAN CreateIfNotFound = FALSE;

    SHADOWINFO ShadowInfo;

    DbgDoit(ASSERT(vfInShadowCrit));

    if (fShadow == 0) {
        return(Status);
    }

    if (pNetRootEntry->NetRoot.sCscRootInfo.hShare != 0)  {
        Status = STATUS_SUCCESS;
        goto FINALLY;
    }

    // At this stage one of the following two assumptions should be TRUE.
    // Connected Mode Operation ...
    //  In this instance the call can succeed only if the Net Root is
    //  marked as being shadowable by the CSC client and iot is of type
    //  Disk.
    // Disconnected Mode Operation ...
    //  In this case we have not yet ascertained the type and attributes
    //  Therefore we let the call go through. If we can open the handle
    //  to the Share then we mark the net root to be of the appropriate
    //  type.

    if (    !DisconnectedMode &&
            !CopyChunkOpen &&
            (/*!pNetRootEntry->NetRoot.CscEnabled ||*/
            (pNetRootEntry->NetRoot.NetRootType != NET_ROOT_DISK))) {
        goto FINALLY;
    }

    // allocate a buffer that's the right size: one extra char is
    // for a trailing null and the other for a preceding L'\\'

    if (ShadowingON()) {
        if (!DisconnectedMode &&
            pNetRootEntry->NetRoot.CscShadowable) {
            CreateIfNotFound = TRUE;
        }
    }

    RxDbgTrace(0, Dbg,
    ("MRxSmbCscObtainShareHandles...servershare=%wZ %08lx\n",
         ShareName,CreateIfNotFound));

    if (FindCreateShareForNt(
        ShareName,
        CreateIfNotFound,
        &ShadowInfo,
        NULL  //this means don't tell me if you create
        ) == SRET_OK ) {

        ASSERT(ShadowInfo.hShare != 0);

        pNetRootEntry->NetRoot.sCscRootInfo.hShare = ShadowInfo.hShare;
        pNetRootEntry->NetRoot.sCscRootInfo.hRootDir = ShadowInfo.hShadow;
        pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus = (USHORT)(ShadowInfo.uStatus);
        pNetRootEntry->NetRoot.sCscRootInfo.Flags = 0;

        RxLog(("OSHH...hDir=%x\n",pNetRootEntry->NetRoot.sCscRootInfo.hRootDir));

        // if we are connected, by this time we have the smb caching flags
        // we check to see whether these match those on the database
        // If they don't, we stamp the new ones
        if (!DisconnectedMode)
        {
            if ((ShadowInfo.uStatus & SHARE_CACHING_MASK)!=
                (ULONG)SMB_CSC_BITS_TO_DATABASE_CSC_BITS(pNetRootEntry->NetRoot.CscFlags))
            {
//                RxDbgTrace(0, Dbg, ("Mismatched smb caching flags, stamping %x on hShare=%x\n",
//                                    SMB_CSC_BITS_TO_DATABASE_CSC_BITS(pNetRootEntry->NetRoot.CscFlags),
//                                    pNetRootEntry->NetRoot.sCscRootInfo.hShare));

                pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus &= ~SHARE_CACHING_MASK;
                pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus |= SMB_CSC_BITS_TO_DATABASE_CSC_BITS(pNetRootEntry->NetRoot.CscFlags);

                SetShareStatus( pNetRootEntry->NetRoot.sCscRootInfo.hShare,
                                 pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus,
                                 SHADOW_FLAGS_ASSIGN);
            }

        }
        else
        {
            // in disconnected mode we use the last set of flags
            pNetRootEntry->NetRoot.CscFlags = DATABASE_CSC_BITS_TO_SMB_CSC_BITS(pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus);

            RxDbgTrace(0, Dbg, ("Setting CscFlags=%x on the netrootentry %x in disconnected state\n",pNetRootEntry->NetRoot.CscFlags, pNetRootEntry));

            switch (pNetRootEntry->NetRoot.CscFlags) {
                case SMB_CSC_CACHE_AUTO_REINT:
                case SMB_CSC_CACHE_VDO:
                    pNetRootEntry->NetRoot.CscEnabled = TRUE;
                    pNetRootEntry->NetRoot.CscShadowable = TRUE;
                break;

                case SMB_CSC_CACHE_MANUAL_REINT:
                    pNetRootEntry->NetRoot.CscEnabled    = TRUE;
                    pNetRootEntry->NetRoot.CscShadowable = FALSE;
                break;

                case SMB_CSC_NO_CACHING:
                    pNetRootEntry->NetRoot.CscEnabled = FALSE;
                    pNetRootEntry->NetRoot.CscShadowable = FALSE;
            }

        }

        Status = STATUS_SUCCESS;
    } else {
        if (DisconnectedMode) {
            Status = STATUS_BAD_NETWORK_PATH;
        } else if (!CreateIfNotFound) {
            pNetRootEntry->NetRoot.sCscRootInfo.hShare      = 0;
            pNetRootEntry->NetRoot.sCscRootInfo.hRootDir     = 0;
            pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus = 0;
            pNetRootEntry->NetRoot.sCscRootInfo.Flags = 0;

            Status = STATUS_SUCCESS;
        }
    }

FINALLY:

    RxDbgTrace(
    -1,
    Dbg,
    ("MRxSmbCscObtainShareHandles -> %08lx (h=%08lx)\n",
        Status, pNetRootEntry->NetRoot.sCscRootInfo.hShare ));

    return Status;
}


NTSTATUS
MRxSmbCscPartOfCreateVNetRoot (
    IN PRX_CONTEXT RxContext,
    IN OUT PMRX_NET_ROOT NetRoot )
{
    NTSTATUS Status;

    PMRX_SRV_CALL           SrvCall;

    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    HSHARE hShare;

    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)
        ) {
        return(STATUS_SUCCESS);
    }

    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    pServerEntry  = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

    if (!CscIsDfsOpen(RxContext)) {
        BOOLEAN Disconnected = SmbCeIsServerInDisconnectedMode(pServerEntry);

        EnterShadowCritRx(RxContext);

        // force a database entry refresh
        hShare = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
        pNetRootEntry->NetRoot.sCscRootInfo.hShare = 0;
#if 0
        if ((NetRoot->pNetRootName->Length >= (sizeof(L"\\win95b\\fat")-2)) &&
            !memcmp(NetRoot->pNetRootName->Buffer, L"\\win95b\\fat", sizeof(L"\\win95b\\fat")-2))
        {
            pNetRootEntry->NetRoot.CscShadowable =
            pNetRootEntry->NetRoot.CscEnabled = TRUE;
        }
#endif
        Status = MRxSmbCscObtainShareHandles(
                 NetRoot->pNetRootName,
                 Disconnected,
                 FALSE,
                 pNetRootEntry
                );

              // update the share rights if necessary

        if (!Disconnected) {

            if(pNetRootEntry->NetRoot.UpdateCscShareRights) {
                if (pNetRootEntry->NetRoot.sCscRootInfo.hShare != 0) {
                    CSC_SID_ACCESS_RIGHTS AccessRights[2];

                    DWORD CscStatus;

                    SID_CONTEXT SidContext;

                    // not a DFS root
                    pNetRootEntry->NetRoot.sCscRootInfo.Flags = 0;

                    if (CscRetrieveSid(RxContext,&SidContext) == STATUS_SUCCESS) {
                        AccessRights[0].pSid = SidContext.pSid;
                        AccessRights[0].SidLength = RtlLengthSid(SidContext.pSid);
                        AccessRights[0].MaximalAccessRights = pNetRootEntry->MaximalAccessRights;

                        AccessRights[1].pSid = CSC_GUEST_SID;
                        AccessRights[1].SidLength = CSC_GUEST_SID_LENGTH;
                        AccessRights[1].MaximalAccessRights = pNetRootEntry->GuestMaximalAccessRights;

                        CscStatus = CscAddMaximalAccessRightsForShare(
                                pNetRootEntry->NetRoot.sCscRootInfo.hShare,
                                2,
                                AccessRights);
                        if (CscStatus != ERROR_SUCCESS) {
                            RxDbgTrace(
                            0,
                            Dbg,
                            ("MRxSmbCscCreateEpilogue Error Updating Access rights %lx\n",
                            Status));
                        }
                        else
                        {
                            pNetRootEntry->NetRoot.UpdateCscShareRights = FALSE;
                        }

                        CscDiscardSid(&SidContext);
                    }
                }
            }
        }

        LeaveShadowCritRx(RxContext);

    } else {
        pNetRootEntry->NetRoot.sCscRootInfo.hShare = 0;
        pNetRootEntry->NetRoot.sCscRootInfo.hRootDir = 0;
        pNetRootEntry->NetRoot.sCscRootInfo.Flags = 0;
        Status = STATUS_SUCCESS;
    }

    return  Status;
}

#ifndef MRXSMB_BUILD_FOR_CSC_DCON
VOID
MRxSmbCscFillWithoutNamesFind32FromFcb (
      IN  PMINIMAL_CSC_SMBFCB MinimalCscSmbFcb,
      OUT _WIN32_FIND_DATA  *Find32
      )
/*++

Routine Description:

   This routine copies the nonname stuff from the fcb to the find32.

Arguments:

    Fcb
    Find32

Return Value:

    none

Notes:


--*/
{
    PFCB wrapperFcb = (PFCB)(MinimalCscSmbFcb->ContainingFcb);
    if (wrapperFcb==NULL) {
        return;
    }
    Find32->dwFileAttributes = wrapperFcb->Attributes;   //&~FILE_ATTRIBUTE_NORMAL??
    COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32->ftLastWriteTime,
                    wrapperFcb->LastWriteTime);
    //COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32->ftChangeTime,
    //                                    wrapperFcb->LastChangeTime);
    COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32->ftCreationTime,
                    wrapperFcb->CreationTime);
    COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32->ftLastAccessTime,
                    wrapperFcb->LastAccessTime);
    Find32->nFileSizeHigh = wrapperFcb->Header.FileSize.HighPart;
    Find32->nFileSizeLow  = wrapperFcb->Header.FileSize.LowPart;
}
#endif //#ifndef MRXSMB_BUILD_FOR_CSC_DCON

NTSTATUS
MRxSmbCscGetFileInfoForCshadow(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine that basically continues the implementation
    of MRxSmbGetFileInfoFromServer within the exchange initiation.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));
    Status = MRxSmbCscGetFileInfoFromServerWithinExchange (
         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
         NULL); //NULL means the name is already in the exchange
    return(Status);
}

NTSTATUS
MRxSmbGetFileInfoFromServer (
    IN  OUT PRX_CONTEXT     RxContext,
    IN  PUNICODE_STRING     FullFileName,
    OUT _WIN32_FIND_DATA    *Find32,
    IN  PMRX_SRV_OPEN       pSrvOpen,
    OUT BOOLEAN             *lpfIsRoot
    )
/*++

Routine Description:

   This routine goes to the server to get a both_directory_info for
   the file mentioned. Here, we have no exchange so we have to get
   one. the underlying machinery for this leaves the pointer in the
   exchange structure. We can then copy it out into the Find32 passed
   in here.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = NULL;
    PMRX_SMB_SRV_OPEN smbSrvOpen = NULL;
    PMRX_V_NET_ROOT VNetRootToUse = NULL;
    PSMBCE_V_NET_ROOT_CONTEXT   pVNetRootContext = NULL;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;
    BOOLEAN FinalizationComplete;
    UNICODE_STRING uniRealName;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbGetFileInfoFromServer\n", 0 ));

    if (pSrvOpen)
    {
        SrvOpen = pSrvOpen;
    }
    else
    {
        SrvOpen = capFobx->pSrvOpen;
    }

    if (lpfIsRoot)
    {
        *lpfIsRoot = FALSE;
    }

    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    VNetRootToUse = SrvOpen->pVNetRoot;
    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(VNetRootToUse);

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    Status = SmbPseCreateOrdinaryExchange(
               RxContext,
               SrvOpen->pVNetRoot,
               SMBPSE_OE_FROM_GETFILEINFOFORCSHADOW,
               MRxSmbCscGetFileInfoForCshadow,
               &OrdinaryExchange);

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return Status;
    }

    if (smbFcb->uniDfsPrefix.Buffer)
    {
        UNICODE_STRING  DfsName;

        if((Status = CscDfsDoDfsNameMapping(&smbFcb->uniDfsPrefix,
                               &smbFcb->uniActualPrefix,
                               FullFileName,
                               FALSE, // fDFSNameToResolvedName
                               &uniRealName
                               )) != STATUS_SUCCESS)
        {
            RxDbgTrace(-1, Dbg, ("Couldn't map DFS name to real name!\n"));
            return Status;
        }

//        DbgPrint("MrxSmbCscgetFileInfoFromServer: %wZ, real name %wZ\n",FullFileName, &uniRealName);
        // if this is a root, then fixup the filename
        if ((uniRealName.Length == 0) ||
            ((uniRealName.Length == 2)&&(*uniRealName.Buffer == L'\\')))
        {
            if (lpfIsRoot)
            {
                *lpfIsRoot = TRUE;
            }
        }
    }
    else
    {
        uniRealName = *FullFileName;
    }

    OrdinaryExchange->pPathArgument1 = &uniRealName;

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status!=RX_MAP_STATUS(PENDING));

    if (Status == STATUS_SUCCESS) {

        RtlCopyMemory(Find32, OrdinaryExchange->Find32WithinSmbbuf,sizeof(*Find32));

    }

    FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    ASSERT(FinalizationComplete);

    if (smbFcb->uniDfsPrefix.Buffer){
        RxFreePool(uniRealName.Buffer);
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbGetFileInfoFromServer  exit with status=%08lx\n", Status ));
    return(Status);

}

BOOLEAN
MRxSmbCscIsFatNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    )

/*++

Routine Description:

    This routine checks if the specified file name is conformant to the
    Fat 8.3 file naming rules.

Arguments:

    FileName - Supplies the name to check.

    WildCardsPermissible - Tells us if wild card characters are ok.

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

Notes:

    i just lifted this routine from ntfs (jll-7-30-97)


--*/

{
    BOOLEAN Results;
    STRING DbcsName;
    USHORT i;
    CHAR Buffer[24];
    WCHAR wc;
    BOOLEAN AllowExtendedChars = TRUE;

    PAGED_CODE();

    //
    //  If the name is more than 24 bytes then it can't be a valid Fat name.
    //

    if (FileName->Length > 24) {

        return FALSE;
    }

    //
    //  We will do some extra checking ourselves because we really want to be
    //  fairly restrictive of what an 8.3 name contains.  That way
    //  we will then generate an 8.3 name for some nomially valid 8.3
    //  names (e.g., names that contain DBCS characters).  The extra characters
    //  we'll filter off are those characters less than and equal to the space
    //  character and those beyond lowercase z.
    //

    if (AllowExtendedChars) {

        for (i = 0; i < FileName->Length / sizeof( WCHAR ); i += 1) {

            wc = FileName->Buffer[i];

            if ((wc <= 0x0020) || (wc == 0x007c)) { return FALSE; }
        }

    } else {

        for (i = 0; i < FileName->Length / sizeof( WCHAR ); i += 1) {

            wc = FileName->Buffer[i];

            if ((wc <= 0x0020) || (wc >= 0x007f) || (wc == 0x007c)) { return FALSE; }
        }
    }

    //
    //  The characters match up okay so now build up the dbcs string to call
    //  the fsrtl routine to check for legal 8.3 formation
    //

    Results = FALSE;

    DbcsName.MaximumLength = 24;
    DbcsName.Buffer = Buffer;

    if (NT_SUCCESS(RtlUnicodeStringToCountedOemString( &DbcsName, FileName, FALSE))) {

        if (FsRtlIsFatDbcsLegal( DbcsName, WildCardsPermissible, FALSE, FALSE )) {

            Results = TRUE;
        }
    }

    //
    //  And return to our caller
    //

    return Results;
}

VOID
MRxSmbCscGenerate83NameAsNeeded(
      IN     CSC_SHADOW_HANDLE   hDir,
      PWCHAR FileName,
      PWCHAR SFN
      )
/*++

Routine Description:

   This routine generates a SFN for a filename if it's not already
   an SFN.

Arguments:


Return Value:


Notes:


--*/
{
    UNICODE_STRING FileNameU;
    WCHAR ShortNameBuffer[14];
    UNICODE_STRING ShortUnicodeName;
    GENERATE_NAME_CONTEXT Context;

    //set up for no short name
    *SFN = 0;

    RtlInitUnicodeString(&FileNameU,FileName);
    if (MRxSmbCscIsFatNameValid (&FileNameU,FALSE)) {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscGenerate83NameAsNeeded no SFN needed for ...<%ws>\n",
            FileName));
        return;
    }

    RxDbgTrace(0, Dbg,
    ("MRxSmbCscGenerate83NameAsNeeded need SFN  for ...<%ws>\n",
        FileName));

    //  Now generate a short name.
    //

    ShortUnicodeName.Length = 0;
    ShortUnicodeName.MaximumLength = 12 * sizeof(WCHAR);
    ShortUnicodeName.Buffer = ShortNameBuffer;

    RtlZeroMemory( &Context, sizeof( GENERATE_NAME_CONTEXT ) );

    while ( TRUE ) {

        NTSTATUS Status;
        ULONG StatusOfShadowApiCall;
        CSC_SHADOW_HANDLE hNew;
        ULONG ShadowStatus;

        RtlGenerate8dot3Name( &FileNameU, TRUE, &Context, &ShortUnicodeName );

        //add the zero.....sigh......
        ShortUnicodeName.Buffer[ShortUnicodeName.Length/sizeof(WCHAR)] = 0;

        RxDbgTrace(0, Dbg,
            ("MRxSmbCscGenerate83NameAsNeeded tryinh SFN <%ws>\n",
            ShortUnicodeName.Buffer));
            //look for existing shadow by that name
        hNew = 0;
        StatusOfShadowApiCall = GetShadow(
                          hDir,   // HSHADOW  hDir,
                          ShortUnicodeName.Buffer,
                              // USHORT *lpName,
                          &hNew,  // LPHSHADOW lphShadow,
                          NULL,   // LPFIND32 lpFind32,
                          &ShadowStatus,
                              // ULONG far *lpuShadowStatus,
                          NULL    // LPOTHERINFO lpOI
                          );

        if (hNew == 0) {
            //the name was not found.....we're in business
            RtlCopyMemory(SFN,
              ShortUnicodeName.Buffer,
              ShortUnicodeName.Length+sizeof(WCHAR));

            RxDbgTrace(0, Dbg,
            ("MRxSmbCscGenerate83NameAsNeeded using SFN <%ws>\n",
                SFN));

            return;
        }
    }

}

DEBUG_ONLY_DECL(ULONG MRxSmbCscCreateShadowEarlyExits = 0;)


NTSTATUS
MRxSmbCscCreateShadowFromPath (
    IN  PUNICODE_STRING     AlreadyPrefixedName,
    IN  PCSC_ROOT_INFO      pCscRootInfo,
    OUT _WIN32_FIND_DATA   *Find32,
    OUT PBOOLEAN            Created  OPTIONAL,
    IN     ULONG               Controls,
    IN OUT PMINIMAL_CSC_SMBFCB MinimalCscSmbFcb,
    IN OUT PRX_CONTEXT         RxContext,
    IN     BOOLEAN             fDisconnected,
    OUT      ULONG               *pulInheritedHintFlags
    )
/*++

Routine Description:

   This routine walks down the current name creating/verifying shadows as it goes.

Arguments:

   AlreadyPrefixedName - the filename for which is a shadow is found/created

   pNetRootEntry - the netroot which is the base for the shadow

   Find32 - a FIND32 structure filled in with the stored info for the shadow

   Created OPT - (NULL or) a PBOOLEANset to TRUE if a new shadow is created

   Controls - some special flags controlling when shadows are created

   MinimalCscSmbFcb - the place where the shadow info is reported

   RxContext - the RDBSS context

   Disconnected - indicates the mode of operation

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status=STATUS_SUCCESS, LocalStatus;
    UNICODE_STRING PathName, ComponentName;
    PWCHAR PreviousSlash,NextSlash,Limit;
    CSC_SHADOW_HANDLE hNew;
    CSC_SHADOW_HANDLE hDir = pCscRootInfo->hRootDir;
    ULONG StatusOfShadowApiCall;
    ULONG ShadowStatus;
    BOOLEAN LastComponentInName = FALSE, fRootHintFlagsObtained=FALSE;
    ULONG DirectoryLevel, ulHintFlags=0;
    OTHERINFO sOI;          //hint/refpri data
    BOOLEAN JunkCreated;

    //CODE.IMPROVEMENT  this is a little dangerous.....not everyone who
    //   calls this routine has an actual smbFcb. we should get some asserts
    //   going wheever we use this that it's the same as the one that
    //   we could have gotten from the RxContext.
    PMRX_SMB_FCB smbFcb = CONTAINING_RECORD(MinimalCscSmbFcb,
                        MRX_SMB_FCB,
                        MinimalCscSmbFcb);

    BEGIN_TIMING(MRxSmbCscCreateShadowFromPath);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscCreateShadowFromPath...<%wZ> %08lx %08lx\n",
                       AlreadyPrefixedName,hDir,Controls));

    DbgDoit(ASSERT(vfInShadowCrit));

    ASSERT(hDir);

    if (Created == NULL) {
        Created = &JunkCreated;
    }
    *Created = FALSE;

    PathName = *AlreadyPrefixedName;

    if (FlagOn(Controls, CREATESHADOW_CONTROL_STRIP_SHARE_NAME))
    {
        ASSERT(!fDisconnected);

        if(CscDfsStripLeadingServerShare(&PathName) != STATUS_SUCCESS)
        {
            return Status;
        }
    }

    Limit = (PWCHAR)(((PBYTE)PathName.Buffer)+ PathName.Length);

    // strip out trailing 0s and slash
    if (PathName.Length > 2)
    {
        while ((*(Limit-1)==0)||(*(Limit-1)=='\\'))
        {
            --Limit;
            PathName.Length -= 2;
            ASSERT((*Limit == 0) || (*Limit == '\\'));
            if (Limit == PathName.Buffer)
            {
                ASSERT(FALSE);
                break;
            }
        }
    }

    PreviousSlash = PathName.Buffer;

    // in connected mode apply the character exclusion list + filetype exclusion list
    // in disconnected mode only apply the character exclusion list

    MinimalCscSmbFcb->fDoBitCopy = FALSE;
    
    if (CheckForBandwidthConservation(PathName.Buffer,                    // name
                                PathName.Length/sizeof(USHORT)))     // size in bytes
    {
        MinimalCscSmbFcb->fDoBitCopy = TRUE;
        HookKdPrint(BITCOPY, ("Bitcopy enabled for %wZ \n", &PathName));
    }
    else if (ExcludeFromCreateShadow(PathName.Buffer,                    // name
                                PathName.Length/sizeof(USHORT),     // size in bytes
                                (fDisconnected==0)))                // Check filetype Exclusion List
    {
        Controls |= CREATESHADOW_CONTROL_NOCREATE;
    }
    


    if ((PathName.Length == 0) ||
    ((PathName.Length == 2) &&
     (*PreviousSlash == OBJ_NAME_PATH_SEPARATOR))) {
        //in disconnected mode, we have to handle opening the root dir
        RxDbgTrace(0,
            Dbg,
            ("MRxSmbCscCreateShadowFromPath basdir ret/handles...<%08lx>\n",
             hDir));

        //fill in the stuff that we have.....
        MinimalCscSmbFcb->hParentDir = 0;
        MinimalCscSmbFcb->hShadow = hDir;
        MinimalCscSmbFcb->LastComponentOffset = 0;
        MinimalCscSmbFcb->LastComponentLength = 0;

        if (!FlagOn(Controls,CREATESHADOW_CONTROL_NOREVERSELOOKUP)
            && (smbFcb->ShadowReverseTranslationLinks.Flink == 0)) {
            ValidateSmbFcbList();
            smbFcb->ContainingFcb->fMiniInited = TRUE;
            MRxSmbCscAddReverseFcbTranslation(smbFcb);
        }

        //fill in a vacuous find32structure
        RtlZeroMemory(Find32,sizeof(_WIN32_FIND_DATA));
        Find32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;


        //make sure that we avoid the loop below
        PreviousSlash = Limit;
        //we're outta here......
    }

    // stop the guy if he doesn't have access
    if (FlagOn(Controls,CREATESHADOW_CONTROL_DO_SHARE_ACCESS_CHECK))
    {
        ASSERT(fDisconnected);

        if(!CscAccessCheck(
                        0,
                        hDir,
                        RxContext,
                        RxContext->Create.NtCreateParameters.DesiredAccess,
                        NULL,
                        NULL
                        ))
        {
            Status = STATUS_ACCESS_DENIED;
            HookKdPrint(BADERRORS, ("CSFP: Access Check failed on root directory %x", hDir));
            goto bailout;
        }
    }

    for (DirectoryLevel=1;;DirectoryLevel++) {
        BOOLEAN UsingExistingShadow;

        if (PreviousSlash >= Limit) {
            break;
        }

        NextSlash = PreviousSlash + 1;

        for (;;NextSlash++) {
            if (NextSlash >= Limit) {
                LastComponentInName = TRUE;
                break;
            }
            if (*NextSlash == OBJ_NAME_PATH_SEPARATOR) {

                // assert that we don't have a trailing slash at the end
                ASSERT((NextSlash+1) < Limit);

                break;
            }
        }

        ComponentName.Buffer = PreviousSlash+1;
        ComponentName.Length =
            (USHORT)(((PBYTE)(NextSlash)) - ((PBYTE)ComponentName.Buffer));

        PreviousSlash = NextSlash;

        RtlZeroMemory(Find32,sizeof(_WIN32_FIND_DATA));
        RtlCopyMemory(&Find32->cFileName[0],
                  ComponentName.Buffer,
                  ComponentName.Length);

        //lastcomponentname stuff for connected has been moved below.....


        RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreateShadowFromPath name from find32 for GetShadow...<%ws>\n",
            &Find32->cFileName[0]));

        hNew = 0;

        UsingExistingShadow = FALSE;

        ASSERT(Find32->cFileName[0]);

        StatusOfShadowApiCall = GetShadow(
                        hDir,                   // HSHADOW  hDir,
                        &Find32->cFileName[0],  // USHORT *lpName,
                          &hNew,                // LPHSHADOW lphShadow,
                          Find32,               // LPFIND32 lpFind32,
                          &ShadowStatus,        // ULONG far *lpuShadowStatus,
                          &sOI                  // LPOTHERINFO lpOI
                          );

        if (StatusOfShadowApiCall != SRET_OK) {
            //no need to fail the open but we get no shadow info
            break;
        }

        if (hNew) {
            // accumulate pin inheritance flags
            ulHintFlags |= (sOI.ulHintFlags & FLAG_CSC_HINT_INHERIT_MASK);
        }

        //we will have to do something about it if a directory turns
        // a file or viceversa for connected

        if (hNew==0) {
            LPOTHERINFO lpOI=NULL;
            UNICODE_STRING ComponentPath;

            if (FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATE)) {
                //if no creates...we're outta here.......
                if (FALSE) {
                    DbgDoit({
                        if ( ((MRxSmbCscCreateShadowEarlyExits++)&0x7f) == 0x7f ) {
                            RxLog(("Csc EarlyExit no create %d\n",
                               MRxSmbCscCreateShadowEarlyExits));
                        }
                    })
                }
                break;
            }

            if (LastComponentInName && FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATELEAF)) {
                //if no creates...we're outta here.......but we still need to set what
                //would be the hParentDir......and the name offsets
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreateShadowFromPath noleaf ret/handles..."
                                "<%08lx><%08lx><%08lx>\n",
                            StatusOfShadowApiCall,hDir,hNew));
                MinimalCscSmbFcb->hParentDir = hDir;
                MinimalCscSmbFcb->LastComponentOffset = (USHORT)(ComponentName.Buffer - AlreadyPrefixedName->Buffer);
                MinimalCscSmbFcb->LastComponentLength = ComponentName.Length;
                break;
            }

            if (!LastComponentInName && FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATENONLEAF)) {
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreateShadowFromPath nocreatenonleaf ret/handles..."
                                "<%08lx><%08lx><%08lx>\n",
                            StatusOfShadowApiCall,hDir,hNew));
                break;
            }

            ASSERT(RxContext!=NULL);

            ShadowStatus = 0;
            if (!fDisconnected){      //ok for dcon   start of big dcon blob 1
                BOOLEAN fIsRoot = FALSE;
                BEGIN_TIMING(MRxSmbGetFileInfoFromServer);

                ComponentPath.Buffer = PathName.Buffer;
                ComponentPath.Length =
                           (USHORT)(((PBYTE)(NextSlash)) - ((PBYTE)ComponentPath.Buffer));
                LeaveShadowCritRx(RxContext);
                Status = MRxSmbGetFileInfoFromServer(RxContext,&ComponentPath,Find32, NULL, &fIsRoot);
                EnterShadowCritRx(RxContext);

                END_TIMING(MRxSmbGetFileInfoFromServer);
                if (Status != STATUS_SUCCESS)
                {
                    // if this is a DFS path and we couldn't reverse map, it
                    // just create a directory or file with fake info and mark it as stale
                    if (smbFcb->uniDfsPrefix.Buffer && (Status == STATUS_NO_SUCH_FILE))
                    {
                        ShadowStatus |= SHADOW_STALE;
                        CreateFakeFind32(hDir, Find32, RxContext, LastComponentInName);
                        HookKdPrint(NAME, ("Fake win32 for DFS share %ls\n", Find32->cFileName));
                        Status = STATUS_SUCCESS;
                    }
                    else
                    {
                        HookKdPrint(BADERRORS, (" MRxSmbGetFileInfoFromServer failed %ls Status=%x\n", Find32->cFileName, Status));
                        // we change the STATUS_RETRY to something worse. STATUS_RETRY is used
                        if (Status == STATUS_RETRY)
                        {
                            Status = STATUS_UNSUCCESSFUL;
                        }
                        break;
                    }
                }
                else
                {
                    // in case of DFS, this could be a root, in which case the naem we get back won't be
                    // correct. Restore it to the original name
                    if (smbFcb->uniDfsPrefix.Buffer && fIsRoot)
                    {
                        ShadowStatus |= SHADOW_STALE;

                        RtlCopyMemory(&Find32->cFileName[0],
                                  ComponentName.Buffer,
                                  ComponentName.Length);

                        Find32->cFileName[ComponentName.Length/sizeof(USHORT)] = 0;

                        MRxSmbCscGenerate83NameAsNeeded(hDir,
                                        &Find32->cFileName[0],
                                        &Find32->cAlternateFileName[0]);
                    }
                }

            } else {
                ShadowStatus = SHADOW_LOCALLY_CREATED;
                //CODE.IMPROVEMENT...should we check for 0-length as well
                RxDbgTrace(0, Dbg,
                    ("MRxSmbCscCreateShadowFromPath setting to locallycreated...<%ws>\n",
                    &Find32->cFileName[0],ShadowStatus));
                CreateFakeFind32(hDir, Find32, RxContext, LastComponentInName);
            }

            if (!LastComponentInName ||
                FlagOn(Controls,CREATESHADOW_CONTROL_SPARSECREATE) ||
                FlagOn(Find32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)  ) {

                ShadowStatus |= SHADOW_SPARSE;
                //CODE.IMPROVEMENT...should we check for 0-length as well
                RxDbgTrace(0, Dbg,
                    ("MRxSmbCscCreateShadowFromPath setting to sparse...<%ws>\n",
                &Find32->cFileName[0],ShadowStatus));
            }

            // check for pin flag inheritance when creating anything

            if(!fRootHintFlagsObtained) {
                StatusOfShadowApiCall = GetShadowInfo(
                            0,
                            pCscRootInfo->hRootDir,
                            NULL,
                            NULL,
                            &sOI
                            );

                if(StatusOfShadowApiCall != SRET_OK) {
                    break;
                }

                fRootHintFlagsObtained = TRUE;

                // or the inheritance bits
                ulHintFlags |= (sOI.ulHintFlags & FLAG_CSC_HINT_INHERIT_MASK);

            }

            // If there is any tunnelling info then use it to create this guy
            if (RetrieveTunnelInfo(
                hDir,
                &Find32->cFileName[0],    // potential SFN  OK for red/yellow
                (fDisconnected)?Find32:NULL,    // get LFN only when disconnected
                &sOI)) {
                lpOI = &sOI;
            }

            // are we supposed to do any inheritance?
            if (ulHintFlags & (FLAG_CSC_HINT_INHERIT_MASK)) {
                if (!lpOI) {
                    InitOtherInfo(&sOI);
                    lpOI = &sOI;
                    lpOI->ulHintFlags = 0;
                }

                if (ulHintFlags & FLAG_CSC_HINT_PIN_INHERIT_USER) {
                    lpOI->ulHintFlags |= FLAG_CSC_HINT_PIN_USER;
                }

                if (ulHintFlags & FLAG_CSC_HINT_PIN_INHERIT_SYSTEM) {
                    lpOI->ulHintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
                }
            }

            // if this is a file on which special heuristic needs to be applied
            // and none of it's parents have system pin inheritance bit set
            // then we do not create the file.
            // Thus on remoteboot shares, we will create entries for these files
            // even if they are opend without the execute flag set.
            // This takes care of the upgrade NT50 to an RB machine scenario

            if ((Controls & CREATESHADOW_CONTROL_FILE_WITH_HEURISTIC)&&
                !(ulHintFlags & FLAG_CSC_HINT_PIN_INHERIT_SYSTEM))
            {
                break;
            }

#if defined(REMOTE_BOOT)
            //
            // In the remote boot case, there was an extra PVOID lpContext
            // parameter to CreateShadowInternal, to which we passed a pointer
            // to a structure. The structure held the cp value (NT_CREATE_PARAMETERS)
            // from &RxContext->Create.NtCreateParameters and the address of
            // a local NTSTATUS value. Eventually this caused the underlying
            // call to IoCreateFile to be done while impersonating the current
            // user, and the status from IoCreateFile was readable upon
            // return from the local value.
            //
#endif

            StatusOfShadowApiCall = CreateShadowInternal (
                        hDir,        // HSHADOW  hDir,
                        Find32,      // LPFIND32 lpFind32,
                        ShadowStatus,// ULONG uFlags,
                        lpOI,        // LPOTHERINFO lpOI,
                        &hNew        // LPHSHADOW  lphNew
                        );

            HookKdPrint(NAME, ("Create %ws in hDir=%x, hShadow=%x Status=%x StatusOfShadowApiCall=%x\n\n", Find32->cFileName, hDir, hNew, ShadowStatus, StatusOfShadowApiCall));

            if (StatusOfShadowApiCall != SRET_OK) {
                RxDbgTrace(0, Dbg,
                    ("MRxSmbCscCreateShadowFromPath createshadowinternal failed!!!...<%ws>\n",
                    &Find32->cFileName[0],ShadowStatus));
                break; //no need to fail the open but we get no shadow info
            }

            *Created = LastComponentInName;

            RxLog(("Created %ws in hDir=%x, hShadow=%x Status=%x\n\n", Find32->cFileName, hDir, hNew, ShadowStatus));

        } else {

            RxDbgTrace(0,Dbg,
            ("MRxSmbCscCreateShadowFromPath name from getsh <%ws>\n",
                &Find32->cFileName[0]));

            if (!fDisconnected) // nothing in connected mode
            {
                // Check if this file should be invisible in connected state
                // We won't want to do this for VDO

                if( (!(Find32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) &&
                    mShadowNeedReint(ShadowStatus))
                {
                    HookKdPrint(BADERRORS, ("File needs merge %x %x Stts=%x %ls\n", hDir, hNew, ShadowStatus, Find32->cFileName));
                    Status = STATUS_ACCESS_DENIED;
                    break;
                }
            }
            else        // lots in disconnected mode
            {
                if (LastComponentInName && (FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATELEAF)||
                                            FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATE)))
                {
                    // if this is the last component and we are not supposed to
                    // create it then skip it.
                }
                else
                {
                    // If it is marked deleted then it is time to recreate it
                    if (mShadowDeleted(ShadowStatus))
                    {
                        PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

                        // Check for a type change from a deleted filename
                        // to a directory name; the other way around is not possible
                        // in our scheme where shadowed directories are not deletable

                        // just bailout
                        if(((IsFile(Find32->dwFileAttributes) != 0) // pre type
                                    != ((LastComponentInName && !FlagOn(cp->CreateOptions,FILE_DIRECTORY_FILE))!=0)))
                        {
                            RxLog(("MRxSmbCscCreateShadowFromPath: type change, failing\n"));
                            HookKdPrint(BADERRORS, ("MRxSmbCscCreateShadowFromPath: type change, failing\n"));
                            Status = STATUS_ACCESS_DENIED;
                            break;
                        }

                        KeQuerySystemTime(((PLARGE_INTEGER)(&Find32->ftCreationTime)));
                        Find32->ftLastAccessTime = Find32->ftLastWriteTime = Find32->ftCreationTime;
                        //already zero Find32->nFileSizeHigh = Find32->nFileSizeLow = 0;

                        ShadowStatus = SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE|SHADOW_REUSED;

                        // Update the shadow info without changing the version stamp

                        if(SetShadowInfo(hDir, hNew, Find32, ShadowStatus,
                         SHADOW_FLAGS_ASSIGN|SHADOW_FLAGS_DONT_UPDATE_ORGTIME
                          ) < SRET_OK)
                        {
                            hNew = 0;
                            break;
                        }
                        // set created flag to true. Based on the Recreated bit, we will know whether
                        // this entry was resurrected or not
                        *Created = TRUE;

                    }
                    else if (IsFile(Find32->dwFileAttributes) && (mShadowSparse(ShadowStatus)))
                    {
                        ShadowStatus = SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE|SHADOW_REUSED;

                        Find32->ftLastAccessTime = Find32->ftLastWriteTime = Find32->ftCreationTime;
                        Find32->nFileSizeHigh = Find32->nFileSizeLow = 0;

                        if ((TruncateDataHSHADOW(hDir, hNew)>=SRET_OK)&&
                            (SetShadowInfo(hDir, hNew, Find32, ShadowStatus,SHADOW_FLAGS_ASSIGN)>=SRET_OK))
                        {
                            // set created flag to true. Based on the Recreated bit, we will know whether
                            // this entry was resurrected or not
                            *Created = TRUE;

                        }
                        else
                        {
                            Status = STATUS_UNSUCCESSFUL;
                            hNew = 0;
                            break;

                        }
                    }
                }
            }
        }

        if (LastComponentInName && (hNew!=0)) {
            LONG nFileSizeLow, nFileSizeHigh;

            // if we are here from the createepilogue then we need to see whether there is an
            // FCB floating around for this name that has a delete_on_close issued on one of the fobxs
            // and is ready for purge. If it isn't ready for purging, ie. there are some
            // outstanding opens on it then this current create is an invalid operation

            if(FlagOn(Controls,CREATESHADOW_CONTROL_FAIL_IF_MARKED_FOR_DELETION))
            {
                PMRX_SMB_FCB pSmbFcb = MRxSmbCscRecoverMrxFcbFromFdb(MRxSmbCscFindFdbFromHShadow(hNew));


                if (pSmbFcb && (pSmbFcb->LocalFlags & FLAG_FDB_DELETE_ON_CLOSE))
                {
                    RxCaptureFcb;
                    RxLog(("delonclose FCB=%x\n", pSmbFcb));
                    RxLog(("prgrelfobx \n"));
                    LeaveShadowCritRx(RxContext);
                    RxScavengeFobxsForNetRoot((PNET_ROOT)(capFcb->pNetRoot),(PFCB)capFcb);
                    EnterShadowCritRx(RxContext);
                    if (MRxSmbCscFindFdbFromHShadow(hNew))
                    {
                        RxLog(("ACCESS_DENIED FCB=%x \n", capFcb));
                        HookKdPrint(BADERRORS, ("ACCESS_DENIED FCB=%x \n", capFcb));
                        Status = STATUS_ACCESS_DENIED;
                        break;
                    }

                    // we potentially have an inode which has been deleted
                    // let us try to get the inode again

                    RxLog(("purged relfobx \n"));
                    Status = STATUS_RETRY;
                    hNew = 0;
                    break;
                }
            }
            if (hNew!=0) {
                // When any local changes are made ensure that the share in the
                // CSC database is marked dirty if it has not been prevoiously
                // marked. This facilitates the easy detection of changes for
                // reintegration by the agent.

                if (ShadowStatus &  SHADOW_MODFLAGS) {
                    MarkShareDirty(&pCscRootInfo->ShareStatus, (ULONG)(pCscRootInfo->hShare));
                }

                //okay, lets remember this in the fcb
                smbFcb->hParentDir = hDir;
                smbFcb->hShadow = hNew;
                smbFcb->ShadowStatus = (USHORT)ShadowStatus;

                    //it's excellent if we can find the last component again...fast
                smbFcb->LastComponentOffset = (USHORT)(ComponentName.Buffer -
                                  AlreadyPrefixedName->Buffer);
                smbFcb->LastComponentLength = ComponentName.Length;

                if (!FlagOn(Controls,CREATESHADOW_CONTROL_NOREVERSELOOKUP)
                      && (smbFcb->ShadowReverseTranslationLinks.Flink == 0)) {
                    ValidateSmbFcbList();
                    smbFcb->ContainingFcb->fMiniInited = TRUE;
                    MRxSmbCscAddReverseFcbTranslation(smbFcb);
                    smbFcb->OriginalShadowSize.LowPart = Find32->nFileSizeLow;
                    smbFcb->OriginalShadowSize.HighPart = Find32->nFileSizeHigh;
                }

                // Initialize the serialization mechanism used for reads/writes
                ExInitializeFastMutex(&smbFcb->CscShadowReadWriteMutex);
            }

        }

        RxDbgTrace(0, Dbg, ("MRxSmbCscCreateShadowFromPath ret/handles...<%08lx><%08lx><%08lx><%08lx>\n",
                        StatusOfShadowApiCall,hDir,hNew));

        hDir = hNew;
    }

    if (pulInheritedHintFlags)
    {
        *pulInheritedHintFlags = ulHintFlags;
    }
bailout:
    RxDbgTrace(-1, Dbg, ("MRxSmbCscCreateShadowFromPath -> %08lx\n", Status ));

    END_TIMING(MRxSmbCscCreateShadowFromPath);
    return Status;
}

//CODE.IMPROVEMENT this routine should be in cshadow.c in the record
//    manager.....but it's in hook.c for the shadow VxD so maybe hookcmmn.c
int RefreshShadow( HSHADOW  hDir,
   IN HSHADOW  hShadow,
   IN LPFIND32 lpFind32,
   OUT ULONG *lpuShadowStatus
   )
/*++

Routine Description:

    This routine, checks whether the local copy is current or not. If it isn't then it
    stamps the local copy as being stale.

Arguments:

    hShadow     Inode representing the local copy

    lpFind32    The new find32 info as obtained from the Share

    lpuShadowStatus Returns the new status of the inode

Return Value:

    Success if >= 0, failed other wise

Notes:


--*/
{
   int iRet = -1;
   int iLocalRet;
   ULONG uShadowStatus;

   // ACHTUNG never called in disconnected state

   RxLog(("Refresh %x \n", hShadow));

   if (ChkUpdtStatusHSHADOW(hDir, hShadow, lpFind32, &uShadowStatus) < 0)
   {
      goto bailout;
   }
   if (uShadowStatus & SHADOW_STALE)
   {
        long nFileSizeHigh, nFileSizeLow;

        if (uShadowStatus & SHADOW_DIRTY)
        {
            KdPrint(("RefreshShadow: conflict on  %x\r\n", hShadow));
            iRet = -2;
            goto bailout;// conflict
        }
//        DbgPrint("Tuncating %ws %x \n", lpFind32->cFileName, hShadow);
        // Truncate the data to 0, this also adjusts the shadow space usage
        TruncateDataHSHADOW(hDir, hShadow);
        // Set status flags to indicate sparse file
        uShadowStatus = SHADOW_SPARSE;

        // ACHTUNG!!! We know we are connected,
        //            hence we don't use SHADOW_FLAG_DONT_UPDATE_ORGTIME
          iLocalRet = SetShadowInfo(hDir,
                    hShadow,
                    lpFind32,
                    uShadowStatus,
                    SHADOW_FLAGS_ASSIGN
                    );
        if (iLocalRet < SRET_OK)
        {
            goto bailout;
        }
#ifdef MAYBE
      MakeSpace(lpFind32->nFileSizeHigh, lpFind32->nFileSizeLow);
#endif //MAYBE
//      AllocShadowSpace(lpFind32->nFileSizeHigh, lpFind32->nFileSizeLow, TRUE);
        iRet = 1;
    }
    else
    {
        iRet = 0;
    }

    *lpuShadowStatus = uShadowStatus;

bailout:

   return (iRet);
}


BOOLEAN
MRxSmbCscIsThisACopyChunkOpen (
    IN PRX_CONTEXT RxContext,
    BOOLEAN   *lpfAgent
    )
/*++

Routine Description:

   This routine determines if the open described by the RxContext is
   a open-with-chunk intent.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    BOOLEAN IsChunkOpen = FALSE;

    RxCaptureFcb;
    PNT_CREATE_PARAMETERS CreateParameters = &RxContext->Create.NtCreateParameters;

    if ((CreateParameters->DesiredAccess == (FILE_READ_ATTRIBUTES | SYNCHRONIZE)) &&
    (CreateParameters->Disposition == FILE_OPEN) &&
    (CreateParameters->AllocationSize.HighPart ==
        MRxSmbSpecialCopyChunkAllocationSizeMarker)) {
        IsChunkOpen = (TRUE);
        if (lpfAgent)
        {
            *lpfAgent =  (CreateParameters->AllocationSize.LowPart != 0);
        }
    }

    return IsChunkOpen;
}


NTSTATUS
SmbPseExchangeStart_CloseCopyChunk(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for close.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB      smbFcb  = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PSMBCEDB_SERVER_ENTRY pServerEntry= SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_CloseCopyChunk %08lx\n", RxContext ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    Status = MRxSmbBuildClose(StufferState);

    if (Status == STATUS_SUCCESS) {

        // Ensure that the Fid is validated....
        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

        Status = SmbPseOrdinaryExchange(
                SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                SMBPSE_OETYPE_CLOSE
                );
        // Ensure that the Fid validation is disabled
        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);
        ASSERT (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE));
    }

    //even if it didn't work there's nothing i can do......keep going
    SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

    MRxSmbDecrementSrvOpenCount(pServerEntry,smbSrvOpen->Version,SrvOpen);

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_CloseCopyChunk %08lx exit w %08lx\n", RxContext, Status ));
    return Status;
}

NTSTATUS
MRxSmbCscCloseExistingThruOpen(
    IN OUT PRX_CONTEXT   RxContext
    )
/*++

Routine Description:

   This routine closes the existing copychunk thru open and marks it as not open

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;

    RxCaptureFcb;
    PMRX_FOBX SaveFobxFromContext = RxContext->pFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_FOBX capFobx = smbFcb->CopyChunkThruOpen;
    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    ASSERT ( NodeTypeIsFcb(capFcb) );

    RxDbgTrace(+1, Dbg, ("MRxSmbCscCloseExistingThruOpen %08lx %08lx %wZ\n",
        RxContext,SrvOpen,GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext) ));

    if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
        ASSERT(smbSrvOpen->hfShadow == 0);
        RxDbgTrace(-1, Dbg, ("CopyChunkOpen already closed\n"));
        return (STATUS_SUCCESS);
    }

    //briefly shanghai the capfobx field in the RxContext
    ASSERT(SaveFobxFromContext==NULL);
    RxContext->pFobx = capFobx;

    if (smbSrvOpen->hfShadow != 0){
        MRxSmbCscCloseShadowHandle(RxContext);
    }

    Status = SmbPseCreateOrdinaryExchange(
               RxContext,
               SrvOpen->pVNetRoot,
               SMBPSE_OE_FROM_CLOSECOPYCHUNKSRVCALL,
               SmbPseExchangeStart_CloseCopyChunk,
               &OrdinaryExchange);

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        RxContext->pFobx = SaveFobxFromContext;
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != (STATUS_PENDING));

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

    RxDbgTrace(-1, Dbg,
    ("MRxSmbCscCloseExistingThruOpen  exit w/ status=%08lx\n", Status ));

    RxContext->pFobx = SaveFobxFromContext;

    if (smbSrvOpen->Flags & SMB_SRVOPEN_FLAG_AGENT_COPYCHUNK_OPEN)
    {
        smbFcb->CopyChunkThruOpen = NULL;
        smbSrvOpen->Flags &= ~SMB_SRVOPEN_FLAG_AGENT_COPYCHUNK_OPEN;
    }
    RxDbgTrace(0, Dbg, ("MRxSmbCscCloseExistingThruOpen status=%x\n", Status));

    return(Status);
}

ULONG SuccessfulSurrogateOpens = 0;

NTSTATUS
MRxSmbCscCreatePrologue (
    IN OUT PRX_CONTEXT RxContext,
    OUT    SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

    This routine performs the correct synchronization among opens. This
    synchronization required because CopyChunk-thru opens are not allowed
    to exist alongside any other kind.

    So, we first must identify copychunk opens and fixup the access,
    allocationsize, etc.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;

    RxCaptureFcb;

    PMRX_SMB_FCB      smbFcb;
    PMRX_SRV_OPEN     SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PMRX_NET_ROOT             NetRoot;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    BOOLEAN               IsCopyChunkOpen, IsThisTheAgent=FALSE;
    PNT_CREATE_PARAMETERS CreateParameters;

    BOOLEAN  EnteredCriticalSection = FALSE;
    NTSTATUS AcquireStatus = STATUS_UNSUCCESSFUL;
    ULONG    AcquireOptions;
    BOOLEAN Disconnected = FALSE;
    DWORD   dwEarlyOut = 0;

    ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);

    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)) {
        return Status;
    }

    SrvOpen     = RxContext->pRelevantSrvOpen;
    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot);

    if (FlagOn(
        pVNetRootContext->Flags,
        SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE)) {
        RxLog(("%wZ is a an AgentInstance\n", &(pVNetRootContext->pNetRootEntry->Name)));
        HookKdPrint(AGENT, ("%wZ is a an AgentInstance\n", &(pVNetRootContext->pNetRootEntry->Name)));
        ASSERT(SrvOpen->pVNetRoot->Flags & VNETROOT_FLAG_CSCAGENT_INSTANCE);
        // DbgPrint("Skipping agent instances\n");
        return Status;
    }


    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        PDFS_NAME_CONTEXT pDfsNameContext = NULL;

        pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext && (pDfsNameContext->NameContextType == DFS_CSCAGENT_NAME_CONTEXT))
        {
            RxLog(("%wZ is a a DFS AgentInstance\n", &(pVNetRootContext->pNetRootEntry->Name)));
            HookKdPrint(NAME, ("%wZ is a DFS AgentInstance\n", &(pVNetRootContext->pNetRootEntry->Name)));
            return Status;
        }
    }

    NetRoot = capFcb->pNetRoot;
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    pServerEntry  = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);

    if (pNetRootEntry->NetRoot.NetRootType != NET_ROOT_DISK) {
        if (!SmbCeIsServerInDisconnectedMode(pServerEntry))
        {
            return Status;
        }
        else
        {
            return STATUS_NETWORK_UNREACHABLE;
        }
    }

    // Check with CSC whether any opens need to fail on this share
    if(hShareReint &&
        ((pNetRootEntry->NetRoot.sCscRootInfo.hShare == hShareReint)||
                    (CscDfsShareIsInReint(RxContext))))
    {
        HookKdPrint(BADERRORS, ("Share %x merging \n", hShareReint));
        return STATUS_ACCESS_DENIED;

    }

    smbFcb      = MRxSmbGetFcbExtension(capFcb);
    smbSrvOpen  = MRxSmbGetSrvOpenExtension(SrvOpen);


    CreateParameters = &RxContext->Create.NtCreateParameters;

    Disconnected = SmbCeIsServerInDisconnectedMode(pServerEntry);

    RxDbgTrace(+1, Dbg,
    ("MRxSmbCscCreatePrologue(%08lx)...%08lx\n",
        RxContext,Disconnected ));

    HookKdPrint(NAME, ("CreatePrologue: Create %wZ Disposition=%x Options=%x DCON=%d \n",
                       GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                       CreateParameters->Disposition,
                       CreateParameters->CreateOptions,
                       Disconnected));

    if (smbFcb->ContainingFcb == NULL) {
        smbFcb->ContainingFcb = capFcb;
    } else {
        ASSERT(smbFcb->ContainingFcb == capFcb);
    }

    IsCopyChunkOpen = MRxSmbCscIsThisACopyChunkOpen(RxContext, &IsThisTheAgent);

    if (IsCopyChunkOpen) {
        PLIST_ENTRY ListEntry;
        ULONG NumNonCopyChunkOpens = 0;

        HookKdPrint(NAME, ("CreatePrologue: Copychunk Open \n"));
        CreateParameters->AllocationSize.QuadPart = 0;
        CreateParameters->DesiredAccess |= FILE_READ_DATA;
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN);
        if (IsThisTheAgent)
        {
            HookKdPrint(NAME, ("CreatePrologue: Agent Copychunk Open \n"));
            SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_AGENT_COPYCHUNK_OPEN);
        }
        SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_COLLAPSING_DISABLED);

        if (Disconnected) {
            Status = STATUS_NETWORK_UNREACHABLE;
//            RxDbgTrace(0, Dbg, ("Network Unreacheable, aborting copychunk\n"));
            dwEarlyOut = 1;
            goto FINALLY;
        }

        //check for a surrogate.....this would be studly.....

        RxLog(("Checking for surrogate\n"));

        for (   ListEntry = capFcb->SrvOpenList.Flink;
            ListEntry != &capFcb->SrvOpenList;
            ListEntry = ListEntry->Flink
            ) {
            PMRX_SRV_OPEN SurrogateSrvOpen = CONTAINING_RECORD(
                             ListEntry,
                             MRX_SRV_OPEN,
                             SrvOpenQLinks);
            PMRX_SMB_SRV_OPEN smbSurrogateSrvOpen = MRxSmbGetSrvOpenExtension(SurrogateSrvOpen);

            if (smbSurrogateSrvOpen == NULL)
                continue;

            if (smbFcb->hShadow == 0) {
            // if we don't have the shadow handle...just blow it off....
                RxLog(("No shadow handle, quitting\n"));
                break;
            }

            if (smbFcb->SurrogateSrvOpen != NULL) {
                // if we already have a surrogate, just use it....
                SurrogateSrvOpen = smbFcb->SurrogateSrvOpen;
            }

            ASSERT(SurrogateSrvOpen && NodeType(SurrogateSrvOpen) == RDBSS_NTC_SRVOPEN);
            if (FlagOn(smbSurrogateSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)) {
                //cant surrogate on a copychunk open!
                continue;
            }

            NumNonCopyChunkOpens++;

            // if it's not open or not open successfully...cant surrogate
            if (FlagOn(smbSurrogateSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                continue;
            }

            if (!FlagOn(smbSurrogateSrvOpen->Flags,SMB_SRVOPEN_FLAG_SUCCESSFUL_OPEN)) {
                continue;
            }

            // if it doesn't have access for read or execute, cant surrogate
            if ((SurrogateSrvOpen->DesiredAccess &
                (FILE_READ_DATA|FILE_EXECUTE)) == 0) {
                continue;
            }

            ASSERT( (smbFcb->SurrogateSrvOpen == SurrogateSrvOpen)
                  || (smbFcb->SurrogateSrvOpen == NULL));
            SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED);
            smbFcb->SurrogateSrvOpen = SurrogateSrvOpen;
            smbSrvOpen->Fid = smbSurrogateSrvOpen->Fid;
            smbSrvOpen->Version = smbSurrogateSrvOpen->Version;

            RxContext->pFobx = (PMRX_FOBX)RxCreateNetFobx(RxContext, SrvOpen);

            if (RxContext->pFobx == NULL) {
                Status = (STATUS_INSUFFICIENT_RESOURCES);
                RxDbgTrace(0, Dbg, ("Failed fobx create, aborting copychunk\n"));
                goto FINALLY;
            }

            // i thought about just using the surrogate's handle here but
            // decided against it. the surrogate's localopen may have failed
            // for some reason that no longer obtains...so i get my own
            // handle.

#if defined(BITCOPY)
            OpenFileHSHADOWAndCscBmp(
                smbFcb->hShadow,
                0,
                0,
                (CSCHFILE *)(&(smbSrvOpen->hfShadow)),
                smbFcb->fDoBitCopy,
                0,
                NULL
                );
#else
            OpenFileHSHADOW(
                smbFcb->hShadow,
                0,
                0,
                (CSCHFILE *)(&(smbSrvOpen->hfShadow))
                );
#endif // defined(BITCOPY)

            if (smbSrvOpen->hfShadow == 0) {
                Status = STATUS_UNSUCCESSFUL;
                RxLog(("Couldn't find a file to piggyback on, failing copychunk\n"));
            } else {
                SuccessfulSurrogateOpens++;
                Status = STATUS_SUCCESS;
                RxLog(("Found a file to piggyback on, succeeding copychunk\n"));
            }

            dwEarlyOut = 2;
            goto FINALLY;
        }

#if 0
        //couldn't find a surrogate.......if there are existing opens then blowoff
        //this open...the agent will come back later
#endif

        if (NumNonCopyChunkOpens>0) {
            RxLog(("CscCrPro Creating thru open when NonNumCopyChunkOpens is non-zero %d for hShadow=%x\n",
                               NumNonCopyChunkOpens, smbFcb->hShadow));

            RxDbgTrace(0, Dbg, ("MRxSmbCscCreatePrologue Creating thru open when NonNumCopyChunkOpens is non-zero %d for hShadow=%x\n",
                               NumNonCopyChunkOpens, smbFcb->hShadow));

        }
    } else {
        NTSTATUS LocalStatus;

        LocalStatus = CscInitializeServerEntryDfsRoot(
                          RxContext,
                          pServerEntry);

        if (LocalStatus != STATUS_SUCCESS) {
            Status = LocalStatus;
            goto FINALLY;
        }

        LocalStatus = MRxSmbCscLocalFileOpen(RxContext);

        if (LocalStatus == STATUS_SUCCESS)
        {
            RxLog(("LocalOpen\n"));
            Status = STATUS_SUCCESS;
            Disconnected = TRUE;    // do a fake disconnected open
        }
        else if (LocalStatus != STATUS_MORE_PROCESSING_REQUIRED)
        {
            RxLog(("LocalOpen Failed Status=%x\n", LocalStatus));
            Status = LocalStatus;
            goto FINALLY;
        }

    }

    if (IsCopyChunkOpen) {
        AcquireOptions = (Exclusive_SmbFcbAcquire |
                      DroppingFcbLock_SmbFcbAcquire |
                      FailImmediately_SmbFcbAcquire);

    } else {
        AcquireOptions = (Shared_SmbFcbAcquire |
                  DroppingFcbLock_SmbFcbAcquire);
    }

    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    AcquireStatus = MRxSmbCscAcquireSmbFcb(
            RxContext,
            AcquireOptions,
            SmbFcbHoldingState);

    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    if (AcquireStatus != STATUS_SUCCESS) {
        //we couldn't acquire.....get out
        Status = AcquireStatus;
        ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreatePrologue couldn't acquire!!!-> %08lx %08lx\n",
            RxContext,Status ));
        RxLog(("CSC AcquireStatus=%x\n", AcquireStatus));
        dwEarlyOut = 3;
        goto FINALLY;
    }

    ASSERT( IsCopyChunkOpen?(smbFcb->CscOutstandingReaders == -1)
               :(smbFcb->CscOutstandingReaders > 0));

    // There are two cases in which the open request can be satisfied locally.
    // Either we are in a disconnected mode of operation for this share or the
    // share has been marked for a mode of operation which calls for the
    // suppression of opens and closes ( hereafter we will refer to it as
    // (Suppress Opens Client Side Caching (SOCSC)) mode of operation to
    // distinguish it from VDO ( virtual disconnected operation ) which is
    // slated for subsequent releases of NT
    // Note that in the SOCSC mode it is likely that we do not have the
    // corresponding file cached locally. In such cases the open needs to be
    // propagated to the client, i.e., you cannot create a local file without
    // checking with the server for the existence of a file with the same name

    if (Disconnected) {
        SMBFCB_HOLDING_STATE FakeSmbFcbHoldingState = SmbFcb_NotHeld;

        RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreatePrologue calling epilog directly!!!-> %08lx %08lx\n",
            RxContext,Status ));

        smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN;

        //we pass a fake holdingstate and do the release from out finally
        MRxSmbCscCreateEpilogue(
            RxContext,
            &Status,
            &FakeSmbFcbHoldingState);

        dwEarlyOut = 4;
        goto FINALLY;
    }

    // deal with any existing thru-open

    if (smbFcb->CopyChunkThruOpen != NULL) {
        if (IsCopyChunkOpen && IsThisTheAgent){
            // here we're a thruopen and there's an existing one...
            // fail the new one....
            Status = STATUS_UNSUCCESSFUL;
            // DbgPrint("Agent being turned away while attempting fill on %x\n", smbFcb->hShadow);
            RxDbgTrace(0, Dbg,
                ("MRxSmbCscCreatePrologue failing new thru open!!!-> %08lx %08lx\n",
                RxContext,Status ));
            dwEarlyOut = 5;
                goto FINALLY;
        } else {
            // the new open if not a thru open or it is a thruopen from the agent.
            // get rid of it now
#ifdef DBG
                if (IsCopyChunkOpen)
                {
                    // This is a copychunk open by the sync manager
                    // assert that the thruopen being nuked is that of the agent

                    PMRX_SMB_SRV_OPEN psmbSrvOpenT = MRxSmbGetSrvOpenExtension(smbFcb->CopyChunkThruOpen->pSrvOpen);
//                    ASSERT(psmbSrvOpenT->Flags & SMB_SRVOPEN_FLAG_AGENT_COPYCHUNK_OPEN);
                }
#endif

            MRxSmbCscCloseExistingThruOpen(RxContext);
        }
    }

FINALLY:
    if (EnteredCriticalSection) {
        LeaveShadowCrit();
    }

    if (Status!=STATUS_MORE_PROCESSING_REQUIRED) {
        if (AcquireStatus == STATUS_SUCCESS) {
            MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
        }
        ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
    }

    if (Disconnected) {
        // at shutdown, there can be a situation where an open comes down
        // but CSC has already been shutdown. If CSC is shutdown, return the appropriate error

        if (fShadow)
        {
            if (Status==STATUS_MORE_PROCESSING_REQUIRED)
            {
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreatePrologue: STATUS_MORE_PROCESSING_REQUIRED, dwEarlyOut=%d\r\n", dwEarlyOut));
            }
            ASSERT(Status!=STATUS_MORE_PROCESSING_REQUIRED);
        }
        else
        {
            if (AcquireStatus == STATUS_SUCCESS) {
                MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
            }
            ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
            Status = STATUS_NETWORK_UNREACHABLE;
        }
    }

    RxLog(("CscCrPro %x %x\n", RxContext, Status ));

    RxDbgTrace(-1, Dbg, ("MRxSmbCscCreatePrologue ->  %08lx %08lx\n",
           RxContext, Status ));

    return Status;
}

NTSTATUS
MRxSmbCscObtainShadowHandles (
    IN OUT PRX_CONTEXT       RxContext,
    IN OUT PNTSTATUS         Status,
    IN OUT _WIN32_FIND_DATA  *Find32,
    OUT    PBOOLEAN          Created,
    IN     ULONG             CreateShadowControls,
    IN     BOOLEAN           Disconnected
    )
/*++

Routine Description:

   This routine tries to obtain the shadow handles for a given fcb. If it can,
   it also will get the share handle as part of the process.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    The netroot entry may have the rootinode for the actual share or it's DFS alternate.
    If it is a root for the DFS alternate, the appropritae bit in the Flags field of the
    sCscRootInfo structure in NetRootEntry is set.

    This routine essentially manufactures the correct root inode for the incoming path
    and stuffs it in the sCscRootInfo for the smbfcb. This root indoe is used for
    all subsequent operations on this file.

--*/
{
    NTSTATUS LocalStatus;

    RxCaptureFcb;

    PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN     SrvOpen;

    PMRX_NET_ROOT           NetRoot       = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

    CSC_SHARE_HANDLE    hShare;
    CSC_SHADOW_HANDLE   hShadow;
    CSC_ROOT_INFO   *pCscRootInfo, sCscRootInfoSav;

    BOOLEAN DisconnectedMode;

    UNICODE_STRING    ShadowPath,SharePath,ServerPath;

    PDFS_NAME_CONTEXT pDfsNameContext = NULL;
    DWORD   cntRetry = 0;
    BOOLEAN fSaved = FALSE;

    DbgDoit(ASSERT(vfInShadowCrit));

    LocalStatus = STATUS_SUCCESS;

    SrvOpen = RxContext->pRelevantSrvOpen;
    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

        //SrvOpen = RxContext->Create.pSrvOpen;
    } else {
        RxCaptureFobx;

        if (SrvOpen)
        {
            ASSERT((SrvOpen == capFobx->pSrvOpen));
        }
    }

    if (smbFcb->ContainingFcb == NULL) {
        smbFcb->ContainingFcb = capFcb;
    } else {
        ASSERT(smbFcb->ContainingFcb == capFcb);
    }

    if (pDfsNameContext) {
        LocalStatus = CscDfsParseDfsPath(
                   &pDfsNameContext->UNCFileName,
                   &ServerPath,
                   &SharePath,
                   &ShadowPath);

        HookKdPrint(NAME, ("OSHH: DfsName %wZ %wZ\n", &SharePath, &ShadowPath));
        DisconnectedMode = FALSE;

        pCscRootInfo = &(smbFcb->sCscRootInfo);

        if (pNetRootEntry->NetRoot.sCscRootInfo.hShare)
        {
            sCscRootInfoSav = pNetRootEntry->NetRoot.sCscRootInfo;
            fSaved = TRUE;
        }

        // clear this so ObtainSharehandles is forced to obtain them
        memset( &(pNetRootEntry->NetRoot.sCscRootInfo),
                0,
                sizeof(pNetRootEntry->NetRoot.sCscRootInfo));

    } else {
        PSMBCEDB_SERVER_ENTRY pServerEntry;
        pServerEntry  = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);

        DisconnectedMode = SmbCeIsServerInDisconnectedMode(pServerEntry);

        SharePath  = *(NetRoot->pNetRootName);
        ShadowPath = *GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
        HookKdPrint(NAME, ("OSHH: NormalName %wZ %wZ\n", &SharePath, &ShadowPath));

        if (pNetRootEntry->NetRoot.sCscRootInfo.Flags & CSC_ROOT_INFO_FLAG_DFS_ROOT)

        {
//            ASSERT(pNetRootEntry->NetRoot.sCscRootInfo.hShare);
            sCscRootInfoSav = pNetRootEntry->NetRoot.sCscRootInfo;
            fSaved = TRUE;
            // clear this so ObtainSharehandles is forced to obtain them
            memset( &(pNetRootEntry->NetRoot.sCscRootInfo),
                    0,
                    sizeof(pNetRootEntry->NetRoot.sCscRootInfo));
        }

        pCscRootInfo = &(pNetRootEntry->NetRoot.sCscRootInfo);
    }


    HookKdPrint(NAME, ("hShare=%x, hRoot=%x, hDir=%x hShadow=%x \n",
             smbFcb->sCscRootInfo.hShare,
             smbFcb->sCscRootInfo.hRootDir,
             smbFcb->hParentDir,
             smbFcb->hShadow));


    if (LocalStatus == STATUS_SUCCESS){

        PMRX_SMB_SRV_OPEN smbSrvOpen;

        if(pCscRootInfo->hShare == 0)
        {
            smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
            LocalStatus = MRxSmbCscObtainShareHandles(
                      &SharePath,
                      DisconnectedMode,
                      BooleanFlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN),
                      SmbCeGetAssociatedNetRootEntry(NetRoot)
                      );

            if (LocalStatus != STATUS_SUCCESS) {

                if (pDfsNameContext) {
                    pNetRootEntry->NetRoot.sCscRootInfo = sCscRootInfoSav;
                }

                RxLog(("CscObtShdH no share handle %x %x\n", RxContext,LocalStatus ));
                RxDbgTrace(0, Dbg,("MRxSmbCscObtainShadowHandles no share handle -> %08xl %08lx\n",
                        RxContext,LocalStatus ));

                return STATUS_SUCCESS;

            }
            else {

                // if this is DFS name get the reverse mapping

                if (pDfsNameContext && !smbFcb->uniDfsPrefix.Buffer)
                {
                    UNICODE_STRING uniTemp;
                    uniTemp = *GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
                    if (RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT))
                    {
                        int i, cntSlashes=0;

                        // Strip the first two elements

                        for (i=0; i<uniTemp.Length; i+=2, uniTemp.Buffer++)
                        {
                            if (*uniTemp.Buffer == L'\\')
                            {
                                if (++cntSlashes > 2)
                                {
                                    break;
                                }
                            }

                        }

                        if (uniTemp.Length > (USHORT)i)
                        {
                            uniTemp.Length -= (USHORT)i;
                        }
                        else
                        {
                            uniTemp.Length = 0;
                        }

                    }
                    if ((LocalStatus = CscDfsObtainReverseMapping(&ShadowPath,
                                                  &uniTemp,
                                                  &smbFcb->uniDfsPrefix,
                                                  &smbFcb->uniActualPrefix)) != STATUS_SUCCESS)
                    {
                        pNetRootEntry->NetRoot.sCscRootInfo = sCscRootInfoSav;
                        return LocalStatus;
                    }

                    HookKdPrint(NAME, ("%wZ %wZ DfsPrefix=%wZ ActualPrefix=%wZ\n", &ShadowPath, &uniTemp, &smbFcb->uniDfsPrefix, &smbFcb->uniActualPrefix));

                }

                // note the fact that the NetRootEntry has the
                // root inode corresponding to the DFS
                if (pDfsNameContext)
                {
                    if (pNetRootEntry->NetRoot.sCscRootInfo.hShare)
                    {
                        pNetRootEntry->NetRoot.sCscRootInfo.Flags = CSC_ROOT_INFO_FLAG_DFS_ROOT;
                    }
                }
                else
                {
                    ASSERT(!(pNetRootEntry->NetRoot.sCscRootInfo.Flags & CSC_ROOT_INFO_FLAG_DFS_ROOT));
                }

                // stuff the FCB with the correct root info
                smbFcb->sCscRootInfo = pNetRootEntry->NetRoot.sCscRootInfo;

            }
        }
        else
        {
            // if this is a normal share or we are operating in disconnected state
            // then we need to make sure that the info that is in the NETROOT entry
            // is stuffed into the FCB
            if (!pDfsNameContext && (smbFcb->sCscRootInfo.hShare == 0))
            {
                // stuff the FCB with the correct root info
                smbFcb->sCscRootInfo = pNetRootEntry->NetRoot.sCscRootInfo;
            }
        }
    }

    // if saved, restore the original rootinfo on the netroot
    if (fSaved)
    {
        pNetRootEntry->NetRoot.sCscRootInfo = sCscRootInfoSav;
    }

    if ((LocalStatus == STATUS_SUCCESS)&&(smbFcb->sCscRootInfo.hRootDir != 0)) {

        if (smbFcb->sCscRootInfo.hShare == hShareReint)
        {
            smbFcb->hShadow = 0;
            smbFcb->hParentDir = 0;
            LocalStatus = STATUS_SUCCESS;
        }
        else
        {

            RxDbgTrace( 0, Dbg,
                ("MRxSmbCscObtainShadowHandles h's= %08lx %08lx\n",
                     pCscRootInfo->hShare, pCscRootInfo->hRootDir));

            HookKdPrint(NAME, ("Obtainshdowhandles %wZ Controls=%x\n", &ShadowPath, CreateShadowControls));

            // due to a race condition in the way RDBSS handles FCBs
            // we may get a retyr from CreateShadowFromPath.
            // see the comments in that routine near the
            // check for CREATESHADOW_CONTROL_FAIL_IF_MARKED_FOR_DELETION
            do
            {
                LocalStatus = MRxSmbCscCreateShadowFromPath(
                    &ShadowPath,
                    &smbFcb->sCscRootInfo,
                    Find32,
                    Created,
                    CreateShadowControls,
                    &smbFcb->MinimalCscSmbFcb,
                    RxContext,
                    Disconnected,
                    NULL            // don't want inherited hint flags
                    );

                if (LocalStatus != STATUS_RETRY)
                {
                    LocalStatus=STATUS_SUCCESS;
                    break;
                }
                if (++cntRetry > 4)
                {
                    LocalStatus=STATUS_SUCCESS;
                    ASSERT(FALSE);
                }
            }
            while (TRUE);
        }
    }
#if 0
    DbgPrint("hShare=%x, hRoot=%x, hDir=%x hShadow=%x \n",
             smbFcb->sCscRootInfo.hShare,
             smbFcb->sCscRootInfo.hRootDir,
             smbFcb->hParentDir,
             smbFcb->hShadow);
#endif

    return LocalStatus;
}


#if defined(REMOTE_BOOT)
NTSTATUS
MRxSmbCscSetSecurityOnShadow(
    HSHADOW hShadow,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

   Given an HSHADOW, this routine opens the file and sets the
   security information passed in.

Arguments:

    hShadow - the handle to the shadow file

    SecurityInformation - the security information to set

    SecurityDescriptor - the security descriptor to set

Return Value:

Notes:


--*/
{
    PWCHAR fileName;
    DWORD fileNameSize;
    UNICODE_STRING fileNameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE fileHandle;
    NTSTATUS ZwStatus;
    int iRet;

    fileNameSize = sizeof(WCHAR) * MAX_PATH;
    fileName = RxAllocatePoolWithTag(NonPagedPool, fileNameSize, RX_MISC_POOLTAG);
    if (fileName == NULL) {

        ZwStatus = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        iRet = GetWideCharLocalNameHSHADOW(
                   hShadow,
                   fileName,
                   &fileNameSize,
                   FALSE);

        if (iRet == SRET_OK) {

            //
            // Open the file and set the security descriptor on it.
            //

            RtlInitUnicodeString(&fileNameString, fileName);

            InitializeObjectAttributes(
                &objectAttributes,
                &fileNameString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            ZwStatus = ZwOpenFile(
                           &fileHandle,
                           FILE_GENERIC_WRITE,
                           &objectAttributes,
                           &ioStatusBlock,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_SYNCHRONOUS_IO_NONALERT);

            if (!NT_SUCCESS(ZwStatus) || !NT_SUCCESS(ioStatusBlock.Status)) {
                //
                // We've been getting bogus names from CSC, ignore this error for now.
                //
                if (ZwStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                    ZwStatus = STATUS_SUCCESS;
                } else {
                    KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not ZwOpenFile %ws %lx %lx\n", fileName, ZwStatus, ioStatusBlock.Status));
                }
            } else {

                HANDLE TokenHandle = NULL;
                BOOLEAN Impersonated = FALSE;
                BOOLEAN WasEnabled;

                //
                // If we are going to set the owner, need to have privilege.
                //

                if (SecurityInformation & OWNER_SECURITY_INFORMATION) {

                    ZwStatus = ZwOpenThreadToken(NtCurrentThread(),
                                                 TOKEN_QUERY,
                                                 FALSE,
                                                 &TokenHandle);

                    if (ZwStatus == STATUS_NO_TOKEN) {
                        TokenHandle = NULL;
                        ZwStatus = STATUS_SUCCESS;
                    }

                    if (!NT_SUCCESS(ZwStatus)) {
                        KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not NtOpenThread %ws %lx\n", fileName, ZwStatus));
                    } else {
                        ZwStatus = ZwImpersonateSelf(SecurityImpersonation);
                        if (!NT_SUCCESS(ZwStatus)) {
                            KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not RtlImpersonateSelf for %ws %lx\n", fileName, ZwStatus));
                        } else {
                            Impersonated = TRUE;
                            ZwStatus = ZwAdjustPrivilege(
                                           SE_RESTORE_PRIVILEGE,
                                           TRUE,
                                           TRUE,
                                           &WasEnabled);
                            if (!NT_SUCCESS(ZwStatus)) {
                                KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not RtlAdjustPrivilege for %ws %lx %d\n", fileName, ZwStatus, WasEnabled));
                            }
                        }
                    }
                }

                if (NT_SUCCESS(ZwStatus)) {

                    ZwStatus = ZwSetSecurityObject(
                                   fileHandle,
                                   SecurityInformation,
                                   SecurityDescriptor);

                    if (!NT_SUCCESS(ZwStatus)) {
                        KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not ZwSetSecurityObject %ws %lx\n", fileName, ZwStatus));
                    }
                }

                if (Impersonated) {
                    NTSTATUS TmpStatus;
                    TmpStatus = ZwSetInformationThread(NtCurrentThread(),
                                                       ThreadImpersonationToken,
                                                       &TokenHandle,
                                                       sizeof(HANDLE));
                    if (!NT_SUCCESS(TmpStatus)) {
                        KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not revert thread %lx!\n", TmpStatus));
                    }

                }

                if (TokenHandle != NULL) {
                    ZwClose(TokenHandle);
                }

                ZwClose(fileHandle);
            }

        } else {

            ZwStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        RxFreePool(fileName);

    }

    return ZwStatus;

}
#endif

VOID
MRxSmbCscCreateEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status,
      IN     SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      )
/*++

Routine Description:

   This routine performs the tail of a create operation for CSC.

Arguments:

    RxContext - the RDBSS context

    Status - in disconnected mode, we return the overall status of the open

    SmbFcbHoldingState - indicates whether a ReleaseSmbFcb is required or not

Return Value:

Notes:

    This is a workhorse of a routine for most of the CSC operations. It has become unwieldy and
    very messy but at this point in time we don't want to mess with it (SPP)

--*/
{
    NTSTATUS LocalStatus;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SMB_FCB      smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN     SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    BOOLEAN ThisIsAPseudoOpen =
         BooleanFlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry =
                  SmbCeGetAssociatedNetRootEntry(NetRoot);

    BOOLEAN Disconnected;

    CSC_SHARE_HANDLE  hShare;
    CSC_SHADOW_HANDLE  hRootDir,hShadow,hParentDir;

    BOOLEAN ShadowWasRefreshed = FALSE;
    PNT_CREATE_PARAMETERS CreateParameters = &RxContext->Create.NtCreateParameters;

    ULONG ReturnedCreateInformation
             = RxContext->Create.ReturnedCreateInformation;
    ULONG CreateInformation; //the new stuff for disconnected mode......
    ULONG CreateDisposition = RxContext->Create.NtCreateParameters.Disposition;
    ULONG CreateOptions = RxContext->Create.NtCreateParameters.CreateOptions;

    _WIN32_FIND_DATA *lpFind32=NULL; //this should not be on the stack CODE.IMPROVEMENT
    OTHERINFO oSI;
    BOOLEAN bGotOtherInfo = FALSE;

    BOOLEAN CreatedShadow = FALSE;
    BOOLEAN NeedTruncate = FALSE; //ok for red/yellow
    BOOLEAN EnteredCriticalSection = FALSE;
    DWORD   dwEarlyOuts=0, dwNotifyFilter=0, dwFileAction=0;

    ASSERT(RxContext!=NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot);

    // If we shouldn't be doing CSC, quit right from here

    if(pVNetRootContext == NULL ||
       !MRxSmbIsCscEnabled ||   // MrxSmb not enabled for csc
       (fShadow == 0))   // record manager not enabled for csc
    {
        return;
    }

    if (FlagOn(                 // agent call
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE)
    ) {
        RxLog(("%wZ AgntInst\n", &(pVNetRootContext->pNetRootEntry->Name)));
        ASSERT(SrvOpen->pVNetRoot->Flags & VNETROOT_FLAG_CSCAGENT_INSTANCE);
        // DbgPrint("Skipping agent instances\n");
        goto EarlyOut;
    }

    {
        // we know that this is a create
        PDFS_NAME_CONTEXT pDfsNameContext = CscIsValidDfsNameContext(
                                            RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext && (pDfsNameContext->NameContextType == DFS_CSCAGENT_NAME_CONTEXT)) {
            RxLog(("%wZ DFS AgntInst\n", &(pVNetRootContext->pNetRootEntry->Name)));
            goto EarlyOut;
        }
    }

    // check whether this is a disconnected open or not
    Disconnected = BooleanFlagOn(
               smbSrvOpen->Flags,
               SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN);

    HookKdPrint(NAME, ("CreateEpilogue: Create %wZ Disposition=%x Options=%x DCON=%d \n",
                       GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                       CreateDisposition,
                       CreateOptions,
                       Disconnected));

    //  If the open is for a netroot which is not a disk, then we quit from here
    //  and let the redir handle it in connected state
    //  CSC is a filesystem cache.

    if (pNetRootEntry->NetRoot.NetRootType != NET_ROOT_DISK) {

        if (Disconnected) {
            *Status = STATUS_ONLY_IF_CONNECTED;
        }

        return;
    }

    // quit if we are doing sparse filling via copychunks
    if (!Disconnected &&
        (!pNetRootEntry->NetRoot.CscEnabled) &&
        !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)) {
        goto EarlyOut;
    }

    if (*SmbFcbHoldingState != SmbFcb_NotHeld) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue...early release %08lx\n",
               RxContext));
        MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
        ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
    }

    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    if ((*Status != STATUS_SUCCESS) &&
        (*Status != STATUS_ACCESS_DENIED)) {
        if (!Disconnected ||
            (*Status != STATUS_MORE_PROCESSING_REQUIRED)) {
            return;
        }
    }

    // Shadow database locked

    EnterShadowCritRx(RxContext);
    EnteredCriticalSection = TRUE;

    lpFind32 = RxAllocatePoolWithTag(
                 NonPagedPool,
                 sizeof(_WIN32_FIND_DATA),
                 MRXSMB_MISC_POOLTAG );

    if (!lpFind32)
    {
        RxDbgTrace(0, Dbg, ("MRxSmbCscCreateShadowFromPath: Failed allocation of find32 structure \n"));
        dwEarlyOuts=1;
        *Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbCscCreateEpilogue...%08lx %wZ %wZ\n",
            RxContext,NetRoot->pNetRootName,GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));

    // if this is a copychunk thru-open....say so in the fcb
    if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)) {
//        ASSERT(smbFcb->CopyChunkThruOpen == NULL);
        smbFcb->CopyChunkThruOpen = capFobx;
        RxDbgTrace( 0, Dbg,
            ("MRxSmbCscCreateEpilogue set ccto  %08lx %08lx %08lx %08lx\n",
            RxContext, capFcb, capFobx, SrvOpen));
    }

    if (ThisIsAPseudoOpen && !Disconnected) {
        PDFS_NAME_CONTEXT pDfsNameContext = NULL;

        pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext)
        {
            LocalStatus = MRxSmbCscObtainShadowHandles(
                      RxContext,
                      Status,
                      lpFind32,
                      &CreatedShadow,
                      CREATESHADOW_CONTROL_NOCREATE,
                      FALSE);
        }

        hShadow = 0;
    } else {
        // if we have no shadow, make one as required..........ok red/yellow

        if (smbFcb->hShadow == 0){
            ULONG CreateShadowControl;

            if (!Disconnected) {
                if (*Status == STATUS_ACCESS_DENIED) {
                    CreateShadowControl = CREATESHADOW_CONTROL_NOCREATE;
                } else {
                    CreateShadowControl = (pNetRootEntry->NetRoot.CscShadowable)
                              ? CREATESHADOW_NO_SPECIAL_CONTROLS
                              : CREATESHADOW_CONTROL_NOCREATE;

                    // The step below is done to save bandwidth and make some apps
                    // like edit.exe work.
                    // It essentially creates an entry in the database for a file which
                    // is being created from this client on the server.
                    // Thus the temp files created by apps like word get created
                    // in the database and filled up during the writes.

                    if((ReturnedCreateInformation<= FILE_MAXIMUM_DISPOSITION) &&
                        (ReturnedCreateInformation!=FILE_OPENED)) {

                        CreateShadowControl &= ~CREATESHADOW_CONTROL_NOCREATE;
                    }

                    // disallow autocaching of encrypted files if the database is
                    // not encrypted.
                    if ((vulDatabaseStatus & FLAG_DATABASESTATUS_ENCRYPTED) == 0
                            &&
                        smbFcb->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED
                    ) {
                        CreateShadowControl |= CREATESHADOW_CONTROL_NOCREATE;
                    }

                //
                // The Windows Explorer likes to open .DLL and .EXE files to extract
                //  the ICON -- and it does this whenever it is trying to show the contents
                //  of a directory.  We don't want this explorer activity to force the files
                //  to be cached.  So we only automatically cache .DLL and .EXE files if they
                //  are being opened for execution
                //  We make an exception for VDO shares. The rational being that most
                //  often the users would run apps without opening a folders

                if( CreateShadowControl == CREATESHADOW_NO_SPECIAL_CONTROLS &&
                    !(CreateParameters->DesiredAccess & FILE_EXECUTE)
                    &&(pNetRootEntry->NetRoot.CscFlags != SMB_CSC_CACHE_VDO)) {

                    PUNICODE_STRING fileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

                    UNICODE_STRING exe = { 3*sizeof(WCHAR), 3*sizeof(WCHAR), L"exe" };
                    UNICODE_STRING dll = { 3*sizeof(WCHAR), 3*sizeof(WCHAR), L"dll" };
                    UNICODE_STRING s;

                    //
                    // If the filename ends in .DLL or .EXE, then we do not cache it this time
                    //
                    if( fileName->Length > 4 * sizeof(WCHAR) &&
                    fileName->Buffer[ fileName->Length/sizeof(WCHAR) - 4 ] == L'.'){

                        s.Length = s.MaximumLength = 3 * sizeof( WCHAR );
                        s.Buffer = &fileName->Buffer[ (fileName->Length - s.Length)/sizeof(WCHAR) ];

                        if( RtlCompareUnicodeString( &s, &exe, TRUE ) == 0 ||
                            RtlCompareUnicodeString( &s, &dll, TRUE ) == 0 ) {

                            CreateShadowControl = CREATESHADOW_CONTROL_FILE_WITH_HEURISTIC;
                        }
                    }
                }
            }
        } else {   //disconnected
            switch (CreateDisposition) {
            case FILE_OVERWRITE:
            case FILE_OPEN:
                CreateShadowControl = CREATESHADOW_CONTROL_NOCREATE;
            break;
            case FILE_CREATE:
            case FILE_SUPERSEDE: //NTRAID-455238-1/31/2000-shishirp supersede not implemented
            case FILE_OVERWRITE_IF:
            case FILE_OPEN_IF:
            default:
                CreateShadowControl = CREATESHADOW_NO_SPECIAL_CONTROLS;
                break;
            }

            if (*Status != STATUS_MORE_PROCESSING_REQUIRED) {
                dwEarlyOuts=2;
                goto FINALLY;
            }

            // make sure we do share access check before we do any damage
            CreateShadowControl |= CREATESHADOW_CONTROL_DO_SHARE_ACCESS_CHECK;

        }   // if (!Disconnected)

        CreateShadowControl |= CREATESHADOW_CONTROL_FAIL_IF_MARKED_FOR_DELETION;

        if (!Disconnected &&
        ((ReturnedCreateInformation==FILE_OPENED) ||
         (ReturnedCreateInformation==FILE_OVERWRITTEN) )  ){
            CreateShadowControl |= CREATESHADOW_CONTROL_SPARSECREATE;
        }

        LocalStatus = MRxSmbCscObtainShadowHandles(
                  RxContext,
                  Status,
                  lpFind32,
                  &CreatedShadow,
                  CreateShadowControl,
                  Disconnected);

        if (LocalStatus != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg,
                ("MRxSmbCscCreateEpilogue no handles-> %08lx %08lx\n",RxContext,LocalStatus ));
            dwEarlyOuts=3;
            *Status = LocalStatus;
            goto FINALLY;
        }

        // if we got an inode for a file which was opened or created recently
        // and there have been some writes on it before this
        // then we need to truncate the data so we don't give stale data to the user

        if (smbFcb->hShadow &&
            IsFile(lpFind32->dwFileAttributes) &&
                        !CreatedShadow &&
            FlagOn(smbFcb->MFlags, SMB_FCB_FLAG_WRITES_PERFORMED))
        {
            if(TruncateDataHSHADOW(smbFcb->hParentDir, smbFcb->hShadow) < SRET_OK)
            {
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue: Failed to get shadowinfo for hDir=%x hShadow=%x \r\n", smbFcb->hParentDir, smbFcb->hShadow));
                dwEarlyOuts=31;
                goto FINALLY;
            }
        }

    } else {    //
        ULONG uShadowStatus;
        int iRet;

        RxDbgTrace( 0, Dbg,
        ("MRxSmbCscCreateEpilogue found existing hdir/hshadow= %08lx %08lx\n",
                       smbFcb->hParentDir, smbFcb->hShadow));

        iRet = GetShadowInfo(
               smbFcb->hParentDir,
               smbFcb->hShadow,
               lpFind32,
               &uShadowStatus,
               &oSI);

        if (iRet < SRET_OK) {
            RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue: Failed to get shadowinfo for hDir=%x hShadow=%x \r\n", smbFcb->hParentDir, smbFcb->hShadow));
            dwEarlyOuts=4;
            goto FINALLY;
        }

        bGotOtherInfo = TRUE;

        //
        // Notepad bug (175322) - quick open/close/open can lose bits - OR in the disk bits
        // with the in-memory bits.
        //
        smbFcb->ShadowStatus |= (USHORT)uShadowStatus;

        RxDbgTrace(0, Dbg,
           ("MRxSmbCscCreateEpilogue name from lpFind32..<%ws>\n",lpFind32->cFileName));

    }

    hShadow    = smbFcb->hShadow;
    hParentDir = smbFcb->hParentDir;

    //
    // If a file is encrypted, but the cache is not, we only allow a file
    // to be cached when the user explicitly asks to do so.
    //
    // Unless we're in the middle of an inode transaction...
    //

    if (
        !Disconnected
            &&
        hShadow != 0
            &&
        cntInodeTransactions == 0
            &&
        (vulDatabaseStatus & FLAG_DATABASESTATUS_ENCRYPTED) == 0
            &&
        (smbFcb->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0
    ) {
        int iRet = SRET_OK;
        ULONG uShadowStatus;

        if (bGotOtherInfo == FALSE) {
            iRet = GetShadowInfo(
                       smbFcb->hParentDir,
                       smbFcb->hShadow,
                       lpFind32,
                       &uShadowStatus,
                       &oSI);
        }
        if (
            iRet >= SRET_OK
                &&
            (oSI.ulHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_SYSTEM)) == 0
                &&
            oSI.ulHintPri == 0
        ) {
            DeleteShadow(hParentDir, hShadow);
            hShadow = smbFcb->hShadow = 0;
        }
    }

    if (hShadow != 0) {

        if (Disconnected)
        {
            if ((CreateOptions & FILE_DIRECTORY_FILE) && !(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                *Status = STATUS_OBJECT_TYPE_MISMATCH;
                goto FINALLY;
            }
            if ((CreateOptions & FILE_NON_DIRECTORY_FILE) && (lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                *Status = STATUS_FILE_IS_A_DIRECTORY;
                goto FINALLY;
            }


            // don't allow writing to a readonly file
            if (!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && // a file
                 (lpFind32->dwFileAttributes & FILE_ATTRIBUTE_READONLY) && // readonly attribute set
                 (CreateParameters->DesiredAccess & (FILE_WRITE_DATA|FILE_APPEND_DATA))) // wants to modify
            {
                if (!CreatedShadow)
                {
                    HookKdPrint(NAME, ("Modifying RO file %x %x\n", hParentDir, hShadow));
                    *Status = STATUS_ACCESS_DENIED;
                    goto FINALLY;
                }
            }
        }

        // If the Shadow handle was successfully manufactured we have one of
        // two possibilities -- In a disconnected state the access check
        // needs to be made and in the connected state the access rights need
        // to be updated.
#if defined(REMOTE_BOOT)
        // For remote boot, this whole next section (the if(Disconnected)
        // and the else clause) was not done, since we later impersonated
        // the user while opening the file.
#endif
        if (Disconnected) {
            BOOLEAN AccessGranted;
            CACHED_SECURITY_INFORMATION CachedSecurityInformationForShare;

            memset(&CachedSecurityInformationForShare, 0, sizeof(CachedSecurityInformationForShare));

            AccessGranted = CscAccessCheck(
                            hParentDir,
                            hShadow,
                            RxContext,
                            CreateParameters->DesiredAccess,
                            NULL,
                            &CachedSecurityInformationForShare
                            );

            if (!AccessGranted) {
                HookKdPrint(BADERRORS, ("Security access denied %x %x\n", hParentDir, hShadow));
                *Status = STATUS_ACCESS_DENIED;
                hShadow = 0;
            }
            else if (CreatedShadow && !(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                DWORD CscStatus, i;
                SID_CONTEXT SidContext;
                CSC_SID_ACCESS_RIGHTS AccessRights[2];

                // if the file has been created in offline mode, give the
                // creator all the rights

                if (CscRetrieveSid(RxContext,&SidContext) == STATUS_SUCCESS) {
                    if (SidContext.pSid != NULL) {

                        AccessRights[0].pSid = SidContext.pSid;
                        AccessRights[0].SidLength = RtlLengthSid(SidContext.pSid);

                        AccessRights[0].MaximalAccessRights = FILE_ALL_ACCESS;
                        AccessRights[1].pSid = CSC_GUEST_SID;
                        AccessRights[1].SidLength = CSC_GUEST_SID_LENGTH;
                        AccessRights[1].MaximalAccessRights = 0;

#if 0
                        for (i=0;i<CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES;++i)
                        {
                            if(CachedSecurityInformationForShare.AccessRights[i].SidIndex == CSC_GUEST_SID_INDEX)
                            {
                                AccessRights[1].MaximalAccessRights = CachedSecurityInformationForShare.AccessRights[i].MaximalRights;
                                break;
                            }
                        }
#endif
                        CscStatus = CscAddMaximalAccessRightsForSids(
                                hParentDir,
                                hShadow,
                                2,
                                AccessRights);

                        if (CscStatus != ERROR_SUCCESS) {
                            RxDbgTrace(
                                0,
                                Dbg,
                                ("MRxSmbCscCreateEpilogue Error Updating Access rights %lx\n",Status));
                        }
                     }   // if (SidContext.pSid != NULL)

                     CscDiscardSid(&SidContext);
                }
            }

        } else {
            CSC_SID_ACCESS_RIGHTS AccessRights[2];
            DWORD CscStatus;
            SID_CONTEXT SidContext;

            if (CscRetrieveSid(RxContext,&SidContext) == STATUS_SUCCESS) {
                if (SidContext.pSid != NULL) {

                    AccessRights[0].pSid = SidContext.pSid;
                    AccessRights[0].SidLength = RtlLengthSid(SidContext.pSid);

                    // update the share right if necessary
                    if (pNetRootEntry->NetRoot.UpdateCscShareRights)
                    {
                        AccessRights[0].MaximalAccessRights = pNetRootEntry->MaximalAccessRights;

                        AccessRights[1].pSid = CSC_GUEST_SID;
                        AccessRights[1].SidLength = CSC_GUEST_SID_LENGTH;
                        AccessRights[1].MaximalAccessRights = pNetRootEntry->GuestMaximalAccessRights;

                        CscStatus = CscAddMaximalAccessRightsForShare(
                                    smbFcb->sCscRootInfo.hShare,
                                    2,
                                    AccessRights);
                        if (CscStatus != ERROR_SUCCESS) {
                            RxDbgTrace(
                            0,
                            Dbg,
                            ("MRxSmbCscCreateEpilogue Error Updating Access rights %lx\n",
                            Status));
                        }
                        else
                        {
                            pNetRootEntry->NetRoot.UpdateCscShareRights = FALSE;
                        }
                    }


                    if (!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                    {

                        AccessRights[0].MaximalAccessRights = smbSrvOpen->MaximalAccessRights;

                        AccessRights[1].pSid = CSC_GUEST_SID;
                        AccessRights[1].SidLength = CSC_GUEST_SID_LENGTH;
                        AccessRights[1].MaximalAccessRights = smbSrvOpen->GuestMaximalAccessRights;

                        if (*Status == STATUS_ACCESS_DENIED) {
                            AccessRights[0].MaximalAccessRights = 0;
                            AccessRights[1].MaximalAccessRights = 0;
                        } else {
                            AccessRights[0].MaximalAccessRights = smbSrvOpen->MaximalAccessRights;
                            AccessRights[1].MaximalAccessRights = smbSrvOpen->GuestMaximalAccessRights;
                        }

                        CscStatus = CscAddMaximalAccessRightsForSids(
                                hParentDir,
                                hShadow,
                                2,
                                AccessRights);

                        if (CscStatus != ERROR_SUCCESS) {
                            RxDbgTrace(
                                0,
                                Dbg,
                                ("MRxSmbCscCreateEpilogue Error Updating Access rights %lx\n",Status));
                        }
                    }
                 }   // if (SidContext.pSid != NULL)

                 CscDiscardSid(&SidContext);
            }   // if (CscRetrieveSid(RxContext,&SidContext) == STATUS_SUCCESS)

            // having updated the access fields, we quit from here.
            if (*Status == STATUS_ACCESS_DENIED)
            {
                goto FINALLY;
            }
        }
    } // if (hShadow != 0)

    if ((hShadow != 0) &&
        !Disconnected  &&  //ok for red/yellow
        (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE)) {

        // here we check to see if the timestamp of the file has changed
        // if so, the shadow needs to be truncated so we don't use it anymore
        ULONG ShadowStatus;
        LONG ShadowApiReturn;

        lpFind32->ftLastWriteTime.dwHighDateTime = smbFcb->LastCscTimeStampHigh;
        lpFind32->ftLastWriteTime.dwLowDateTime  = smbFcb->LastCscTimeStampLow;
        lpFind32->nFileSizeHigh = smbFcb->NewShadowSize.HighPart;
        lpFind32->nFileSizeLow = smbFcb->NewShadowSize.LowPart;
        lpFind32->dwFileAttributes = smbFcb->dwFileAttributes;


        RxDbgTrace(0, Dbg,
           ("MRxSmbCscCreateEpilogue trying for refresh...<%ws>\n",lpFind32->cFileName));

        ShadowApiReturn = RefreshShadow(
                  hParentDir,   //HSHADOW  hDir,
                  hShadow,      //HSHADOW  hShadow,
                  lpFind32,      //LPFIND32 lpFind32,
                  &ShadowStatus //ULONG *lpuShadowStatus
                  );

            if (ShadowApiReturn<0) {
                hShadow = 0;
                RxDbgTrace(0, Dbg,
                ("MRxSmbCscCreateEpilogue refresh failed..%08lx.<%ws>\n",RxContext,lpFind32->cFileName));
            } else {
                smbFcb->ShadowStatus = (USHORT)ShadowStatus;
                if ( ShadowApiReturn==1)
				{
					ShadowWasRefreshed = 1;
					//WinSE Bug 28543
					//Set this flag so that we remember that we truncated the file
					//and so in MrxSmbCSCUpdateShadowFromClose we don't reset the
					//SPARSE flag. - NavjotV
					SetFlag(smbFcb->MFlags,SMB_FCB_FLAG_CSC_TRUNCATED_SHADOW);

				}

            }
        }
    }

    NeedTruncate = FALSE;
    RxDbgTrace(0, Dbg,
       ("MRxSmbCscCreateEpilogue trying for truncate...%08lx %08lx %08lx %08lx\n",
           RxContext,hShadow,CreatedShadow,
           RxContext->Create.ReturnedCreateInformation));

    if (hShadow != 0) {

        if (!Disconnected) {
            CreateInformation = ReturnedCreateInformation;

            if (!CreatedShadow &&
                (ReturnedCreateInformation<= FILE_MAXIMUM_DISPOSITION) &&
                (ReturnedCreateInformation!=FILE_OPENED)  ) {
                if ((NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE)) {
                    NeedTruncate = TRUE;
                }
            }
        }
        else {  // Disconnected
            ULONG ShadowStatus = smbFcb->ShadowStatus;
            BOOLEAN ItsAFile = !BooleanFlagOn(lpFind32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY);

            CreateInformation = FILE_OPENED;

            switch (CreateDisposition) {
                case FILE_OPEN:
                NOTHING;
                break;

                case FILE_OPEN_IF:
                if (CreatedShadow) {
                    CreateInformation = FILE_CREATED;
                } else if (FlagOn(ShadowStatus,SHADOW_SPARSE)) {
                    NeedTruncate = ItsAFile;
                    CreateInformation = FILE_CREATED;
                }
                break;

                case FILE_OVERWRITE:
                case FILE_OVERWRITE_IF:
                if (CreatedShadow) {
                    ASSERT(CreateDisposition==FILE_OVERWRITE_IF);
                    CreateInformation = FILE_CREATED;
                } else {
                    NeedTruncate = ItsAFile;
                    CreateInformation = FILE_OVERWRITTEN;
                }
                break;

                case FILE_CREATE:
                if (!CreatedShadow)
                {
                    *Status = STATUS_OBJECT_NAME_COLLISION;
                    goto FINALLY;

                }
                case FILE_SUPERSEDE:
                if (!CreatedShadow) {
                    NeedTruncate = ItsAFile;
                };
                CreateInformation = FILE_CREATED;
                break;

                default:
                ASSERT(FALSE);
            }

            // In disconnected state, note down the changes that have occurred
            // in order to notify them to the fsrtl package.

            if (CreatedShadow)
            {
                dwNotifyFilter = (IsFile(smbFcb->dwFileAttributes)?FILE_NOTIFY_CHANGE_FILE_NAME:FILE_NOTIFY_CHANGE_DIR_NAME);
                dwFileAction = FILE_ACTION_ADDED;
            }
            else if (NeedTruncate)
            {
                dwNotifyFilter = FILE_NOTIFY_CHANGE_SIZE;
                dwFileAction = FILE_ACTION_MODIFIED;
            }
        }   // if (!Disconnected)
    }

    if (NeedTruncate) {
        int iLocalRet;
        ULONG uShadowStatus = smbFcb->ShadowStatus;

        uShadowStatus &= ~SHADOW_SPARSE;
        lpFind32->nFileSizeLow = lpFind32->nFileSizeHigh = 0;

        ASSERT(hShadow!=0);

        HookKdPrint(NAME, ("CreateEpilogue needtruncate %ws %08lx\n",lpFind32->cFileName,uShadowStatus));

        RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreateEpilogue needtruncate...<%ws> %08lx\n",
            lpFind32->cFileName,uShadowStatus));

        TruncateDataHSHADOW(hParentDir, hShadow);
        iLocalRet = SetShadowInfo(
                hParentDir,
                hShadow,
                lpFind32,
                uShadowStatus,
                SHADOW_FLAGS_ASSIGN  |
                ((Disconnected) ?SHADOW_FLAGS_DONT_UPDATE_ORGTIME :0)
                );

        if (iLocalRet < SRET_OK) {
            hShadow = 0;
        } else {
            smbFcb->ShadowStatus = (USHORT)uShadowStatus;
        }
    }   // if (NeedTruncate)

    if (Disconnected) {
        ULONG ShadowStatus = smbFcb->ShadowStatus;
        if (*Status == STATUS_MORE_PROCESSING_REQUIRED) {

            CreateDisposition = RxContext->Create.NtCreateParameters.Disposition;

            RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreateEpilogue lastDCON...<%ws> %08lx %08lx %08lx\n",
            lpFind32->cFileName,ShadowStatus,CreateDisposition,lpFind32->dwFileAttributes));

            switch (CreateDisposition) {
                case FILE_OPEN:
                case FILE_OVERWRITE:
                if ((hShadow==0) ||
                       ( FlagOn(ShadowStatus,SHADOW_SPARSE) &&
                             !FlagOn(lpFind32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY))
                   ) {

                    *Status = STATUS_NO_SUCH_FILE;
                } else {
                    // Bypass the shadow if it is not visibile for this connection
                    if (!IsShadowVisible(Disconnected,
                             lpFind32->dwFileAttributes,
                             ShadowStatus)) {

                        *Status = STATUS_NO_SUCH_FILE;
                    }
                    else
                    {
                        *Status = STATUS_SUCCESS;
                    }
                }
                break;

                case FILE_OPEN_IF:
                case FILE_OVERWRITE_IF:
                case FILE_CREATE:
                case FILE_SUPERSEDE:
                    if (hShadow==0) {

                        *Status = STATUS_NO_SUCH_FILE;

                    } else {
                        *Status = STATUS_SUCCESS;
                        //CreateInformation == FILE_OPENED|CREATED set in switch above;
                    }
                break;

                default:
                ASSERT(FALSE);
            }
        }

        if (*Status == STATUS_SUCCESS) {
            //next, we have to do everything that the create code would have done...
            //specifically, we have to build a fobx and we have to do a initfcb.
            //basically, we have to do the create success tail........
            BOOLEAN MustRegainExclusiveResource = FALSE;
            PSMBPSE_FILEINFO_BUNDLE FileInfo = &smbSrvOpen->FileInfo;
            SMBFCB_HOLDING_STATE FakeSmbFcbHoldingState = SmbFcb_NotHeld;
            RX_FILE_TYPE StorageType;

            //RtlZeroMemory(FileInfo,sizeof(FileInfo));

            FileInfo->Basic.FileAttributes = lpFind32->dwFileAttributes;
            COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                  FileInfo->Basic.CreationTime,
                  lpFind32->ftCreationTime);
            COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                  FileInfo->Basic.LastAccessTime,
                  lpFind32->ftLastAccessTime);
            COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                  FileInfo->Basic.LastWriteTime,
                  lpFind32->ftLastWriteTime);

            FileInfo->Standard.NumberOfLinks = 1;
            FileInfo->Standard.EndOfFile.HighPart = lpFind32->nFileSizeHigh;
            FileInfo->Standard.EndOfFile.LowPart = lpFind32->nFileSizeLow;
            FileInfo->Standard.AllocationSize = FileInfo->Standard.EndOfFile; //rdr1 actually rounds up based of svr disk attribs
            FileInfo->Standard.Directory = BooleanFlagOn(lpFind32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY);

            //CODE.IMRPOVEMENT successtail should figure out the storage type
            StorageType = FlagOn(lpFind32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)
                       ?(FileTypeDirectory)
                       :(FileTypeFile);

            *Status = MRxSmbCreateFileSuccessTail (
                  RxContext,
                  &MustRegainExclusiveResource,
                  &FakeSmbFcbHoldingState,
                  StorageType,
                  0xf00d,
                  0xbaad,
                  SMB_OPLOCK_LEVEL_BATCH,
                  CreateInformation,
                  FileInfo
                  );

            HookKdPrint(NAME, ("CreateEpilogue %ws attrib=%x \n",lpFind32->cFileName,lpFind32->dwFileAttributes));

        }

        if (*Status != STATUS_SUCCESS){
            hShadow = 0;
        }
    }   // if (Disconnected)

    if (hShadow != 0) {

        PUNICODE_STRING pName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

        // upcase it so change notification will get it right
        // this works because rdbss always does caseinsensitive compare
        UniToUpper(pName->Buffer, pName->Buffer, pName->Length);

        // here we get a local handle on behalf of this srvopen; we only do this
        // open if it's a file (not a directory) AND if the access rights specified
        // indicate that we might use/modify the data in the shadow.


        if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE) {
            PNT_CREATE_PARAMETERS CreateParameters = &RxContext->Create.NtCreateParameters;

            // why are we not using macros provided in ntioapi.h for access rights?
            ULONG NeedShadowAccessRights = FILE_READ_DATA
                             | FILE_WRITE_DATA
                             | FILE_READ_ATTRIBUTES
                             | FILE_WRITE_ATTRIBUTES
                             | FILE_APPEND_DATA
                             | FILE_EXECUTE;

            if ( (CreateParameters->DesiredAccess & NeedShadowAccessRights) != 0 ) {
//                ASSERT( sizeof(HFILE) == sizeof(HANDLE) );
                ASSERT( hShadow == smbFcb->hShadow );
                ASSERT( hParentDir == smbFcb->hParentDir );

#if defined(REMOTE_BOOT)
                //
                // In the remote boot case, there was an extra context
                // parameter to OpenFileHSHADOW which held a pointer
                // to CreateParameters and a local status value.
                //
#endif

#if !defined(BITCOPY)
                OpenFileHSHADOW(
                    hShadow,
                    0,
                    0,
                    (CSCHFILE *)(&(smbSrvOpen->hfShadow))
                    );
#else
                OpenFileHSHADOWAndCscBmp(
                    smbFcb->hShadow,
                    0,
                    0,
                    (CSCHFILE *)(&(smbSrvOpen->hfShadow)),
                    smbFcb->fDoBitCopy,
                    0,
                    NULL
                    );
                // Check if needed to Open a CSC_BITMAP
                if (
                    smbFcb->fDoBitCopy == TRUE
                        &&
                    smbFcb->NewShadowSize.HighPart == 0 // no 64-bit
                        &&
                    Disconnected // only in dcon mode
                        &&
                    !FlagOn(smbFcb->ShadowStatus,SHADOW_SPARSE)
                        &&
                    smbFcb->lpDirtyBitmap == NULL // shadow file not sparse
                        &&
                    // have not been created before
                    (FlagOn(
                        CreateParameters->DesiredAccess,
                        FILE_WRITE_DATA|FILE_APPEND_DATA))
                    // opened for writes
                    // && is NTFS -- see below
                ) {
                      BOOL fHasStreams;
                      
                      if (HasStreamSupport(smbSrvOpen->hfShadow, &fHasStreams) &&
                            (fHasStreams == TRUE))
                      {
                          OpenCscBmp(hShadow, &((LPCSC_BITMAP)(smbFcb->lpDirtyBitmap)));
                      }
                  }
#endif // defined(BITCOPY)



#if defined(REMOTE_BOOT)
                //
                // Here we checked the local status value and set
                // *Status from it if (iRet != SRET_OK).
                //
#endif

                if (smbSrvOpen->hfShadow != 0) {
                    HookKdPrint(NAME, ("Opened file %ws, hShadow=%x handle=%x \n", lpFind32->cFileName, hShadow, smbSrvOpen->hfShadow));
                    RxLog(("CSC Opened file %ws, hShadow=%x capFcb=%x SrvOpen=%x\n", lpFind32->cFileName, hShadow, capFcb, SrvOpen));

//                    NeedToReportFileOpen = TRUE;
                    SetPriorityHSHADOW(hParentDir, hShadow, MAX_PRI, RETAIN_VALUE);

                    if (Disconnected)
                    {
                        MRxSmbCSCObtainRightsForUserOnFile(RxContext,
                                                           hParentDir,
                                                           hShadow,
                                                           &smbSrvOpen->MaximalAccessRights,
                                                           &smbSrvOpen->GuestMaximalAccessRights);
                    }
                }

            }
        }   // if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE)

        IF_DEBUG {
            if (FALSE) {
                BOOL thisone, nextone;
                PFDB smbLookedUpFcb,smbLookedUpFcbNext;

                smbLookedUpFcb = PFindFdbFromHShadow(hShadow);
                smbLookedUpFcbNext = PFindFdbFromHShadow(hShadow+1);
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue lookups -> %08lx %08lx %08lx\n",
                      smbFcb,
                      MRxSmbCscRecoverMrxFcbFromFdb(smbLookedUpFcb),
                      MRxSmbCscRecoverMrxFcbFromFdb(smbLookedUpFcbNext)  ));
            }
        }
    }   // if (hShadow != 0)

FINALLY:

    if (lpFind32)
    {
        RxFreePool(lpFind32);
    }
    if (EnteredCriticalSection) {
        LeaveShadowCritRx(RxContext);
    }

#if 0
    if (NeedToReportFileOpen) {
        //this is a bit strange....it's done this way because MRxSmbCscReportFileOpens
        //enters the critsec for himself.....it is also called from within MRxSmbCollapseOpen
        //if instead MRxSmbCollapseOpen called a wrapper routine, we could have
        //MRxSmbCscReportFileOpens not enter and we could do this above
        MRxSmbCscReportFileOpens();  //CODE.IMPROVEMENT this guy shouldn't enter
    }
#endif

    if (Disconnected)
    {
        if(*Status == STATUS_MORE_PROCESSING_REQUIRED) {
            // if we ever get here after CSC is shutdown, we need to return appropriate error
            if (fShadow)
            {
                RxLog(("EarlyOut = %d \r\n", dwEarlyOuts));
                // should never get here
                DbgPrint("MRxSmbCscCreateEpilogue: EarlyOut = %d \r\n", dwEarlyOuts);
                ASSERT(FALSE);
            }
            else
            {
                *Status = STATUS_NETWORK_UNREACHABLE;
            }
        }
        else if (*Status == STATUS_SUCCESS)
        {
            // report changes to the notification package
            if (dwNotifyFilter)
            {
                ASSERT(dwFileAction);

                RxLog(("chngnot hShadow=%x filter=%x\n",smbFcb->hShadow, dwNotifyFilter));

                FsRtlNotifyFullReportChange(
                    pNetRootEntry->NetRoot.pNotifySync,
                    &pNetRootEntry->NetRoot.DirNotifyList,
                    (PSTRING)GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb),
                    (USHORT)(GET_ALREADY_PREFIXED_NAME(SrvOpen, capFcb)->Length -
                                smbFcb->MinimalCscSmbFcb.LastComponentLength),
                    NULL,
                    NULL,
                    dwNotifyFilter,
                    dwFileAction,
                    NULL);
            }
        }
    }

    HookKdPrint(NAME, ("CreateEpilogue Out: returnedCreateInfo=%x Status=%x\n",
                        ReturnedCreateInformation, *Status));

    RxDbgTrace(-1, Dbg, ("MRxSmbCscCreateEpilogue ->%08lx %08lx\n",RxContext, *Status ));
    RxLog(("CscCrEpi %x %x\n",RxContext, *Status ));
    return;

EarlyOut:
    if (*SmbFcbHoldingState != SmbFcb_NotHeld) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue...early release %08lx\n",
               RxContext));
        MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
        ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
    }
    return;    
}

VOID
MRxSmbCscDeleteAfterCloseEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a delete-after-close operation for CSC.
   Basically, it deletes the file from the cache.

   The status of the operation is passed in case we someday find
   things are so messed up that we want to return a failure even if the
   nonshadowed operations was successful. not today however...

Arguments:

    RxContext - the RDBSS context

Return Value:


Notes:


--*/
{
    NTSTATUS LocalStatus=STATUS_UNSUCCESSFUL;
    int iRet = -1;
    ULONG ShadowFileLength;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry =
                  SmbCeGetAssociatedNetRootEntry(NetRoot);

    BOOLEAN EnteredCriticalSection = FALSE;
    _WIN32_FIND_DATA Find32; //this should not be on the stack CODE.IMPROVEMENT
    BOOLEAN Disconnected;
    ULONG uShadowStatus;
    OTHERINFO    sOI;

    if(!MRxSmbIsCscEnabled) {
        return;
    }
    if (fShadow == 0) {
        return;
    }

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    RxDbgTrace(+1, Dbg,
    ("MRxSmbCscDeleteAfterCloseEpilogue entry %08lx...%08lx on handle %08lx\n",
        RxContext, SrvOpen, smbSrvOpen->hfShadow ));

    if (*Status != STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscDeleteAfterCloseEpilogue exit(status) w/o deleteing -> %08lx %08lx\n", RxContext, Status ));
        goto FINALLY;
    }

    EnterShadowCritRx(RxContext);
    EnteredCriticalSection = TRUE;

    //if we don't have a shadow...go look for one
    if (smbFcb->hShadow == 0) {
        if (!smbFcb->hShadowRenamed)
        {
            LocalStatus = MRxSmbCscObtainShadowHandles(
                      RxContext,
                      Status,
                      &Find32,
                      NULL,
                      CREATESHADOW_CONTROL_NOCREATE,
                      Disconnected);

            if (LocalStatus != STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg,
            ("MRxSmbCscDeleteAfterCloseEpilogue couldn't get handles-> %08lx %08lx\n",RxContext,LocalStatus ));
                goto FINALLY;
            }
        }
        else
        {
            smbFcb->hShadow = smbFcb->hShadowRenamed;
            smbFcb->hParentDir = smbFcb->hParentDirRenamed;
        }

        if (smbFcb->hShadow == 0) {
            RxDbgTrace(0, Dbg,
            ("MRxSmbCscDeleteAfterCloseEpilogue no handles-> %08lx %08lx\n",RxContext,LocalStatus ));
            goto FINALLY;
        }
    }

    if(GetShadowInfo(smbFcb->hParentDir,
             smbFcb->hShadow,
             &Find32,
             &uShadowStatus, &sOI) < SRET_OK) {
        goto FINALLY;
    }

    if (IsShadowVisible(
        Disconnected,
        Find32.dwFileAttributes,
        uShadowStatus)) {
        BOOLEAN fMarkDeleted = (Disconnected && !mShadowLocallyCreated(uShadowStatus));

        LocalStatus = OkToDeleteObject(smbFcb->hParentDir, smbFcb->hShadow, &Find32, uShadowStatus, Disconnected);

        // If it is not OK to delete, the quit
        if (LocalStatus != STATUS_SUCCESS)
        {
            iRet = -1;
            goto FINALLY;
        }

        if (!fMarkDeleted)
        {
            if (capFcb->OpenCount != 0)
            {
                DbgPrint("Marking for delete hDir=%x hShadow=%x %ws \n\n", smbFcb->hParentDir, smbFcb->hShadow, Find32.cFileName);
                ASSERT(FALSE);
                RxLog(("Marking for delete hDir=%x hShadow=%x %ws \n\n", smbFcb->hParentDir, smbFcb->hShadow, Find32.cFileName));

                // if we are supposed to really delete this file, note this fact on the FCB
                // we will delete it when the FCB is deallocated
                smbFcb->LocalFlags |= FLAG_FDB_DELETE_ON_CLOSE;
                iRet = 0;
            }
            else
            {
                iRet = DeleteShadowHelper(FALSE, smbFcb->hParentDir, smbFcb->hShadow);
                smbFcb->hShadow = 0;

                if (iRet < 0)
                {
                    goto FINALLY;
                }

            }
        }
        else
        {

            iRet = DeleteShadowHelper(TRUE, smbFcb->hParentDir, smbFcb->hShadow);
            smbFcb->hShadow = 0;
        }

        if (iRet >= 0)
        {
            PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
            PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

            InsertTunnelInfo(smbFcb->hParentDir,
                     Find32.cFileName,
                     Find32.cAlternateFileName,
                     &sOI);
            if (fMarkDeleted) {
                MarkShareDirty(&smbFcb->sCscRootInfo.ShareStatus, smbFcb->sCscRootInfo.hShare);
            }
            // when disconnected, report the change
            if (Disconnected)
            {
                FsRtlNotifyFullReportChange(
                    pNetRootEntry->NetRoot.pNotifySync,
                    &pNetRootEntry->NetRoot.DirNotifyList,
                    (PSTRING)GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                    (USHORT)(GET_ALREADY_PREFIXED_NAME(NULL, capFcb)->Length -
                    smbFcb->MinimalCscSmbFcb.LastComponentLength),
                    NULL,
                    NULL,
                    IsFile(Find32.dwFileAttributes)?FILE_NOTIFY_CHANGE_FILE_NAME
                                                  :FILE_NOTIFY_CHANGE_DIR_NAME,
                    FILE_ACTION_REMOVED,
                    NULL);
            }
        }

    }

FINALLY:
    if (EnteredCriticalSection) {
        LeaveShadowCritRx(RxContext);
    }

    if (Disconnected) {
        if (iRet < 0) {
            *Status = LocalStatus; //do we need a better error mapping?
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscDeleteAfterCloseEpilogue exit-> %08lx %08lx\n", RxContext, Status ));
    return;
}

ULONG
GetPathLevelFromUnicodeString (
    PUNICODE_STRING Name
      )
/*++

Routine Description:

   This routine counts the number of L'\\' in a string. It is used to set
   the priority level for a directory on a rename operation.

Arguments:

    Name -

Return Value:


Notes:


--*/
{
    PWCHAR t = Name->Buffer;
    LONG l = Name->Length;
    ULONG Count = 1;

    for (;l<2;l--) {
        if (*t++ == L'\\') {
            Count++;
        }
    }
    return(Count);
}

VOID
MRxSmbCscRenameEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a rename operation for CSC.
   Basically, it renames the file in the record manager datastructures.
   Unfortunately, there is no "basically" to it.

   The status of the operation is passed in case we someday find
   things are so messed up that we want to return a failure even if the
   nonshadowed operations was successful. not today however...

Arguments:

    RxContext - the RDBSS context

Return Value:


Notes:

    The routine does the following operations
    - Get the Inode for the source ie. If \foo.dir\bar.txt is the source, we traverse the path
      to get the inode for bar.txt.
    - If necessary create the destination namespace in the CSC database i.e., if \foo.dir\bar.txt
      is being renamed to \xxx.dir\yyy.dir\abc.txt, then ensure that the hierarchy \xxx.dir\yyy.dir
      exists in the local namespace.

    - If the destination inode exists, then apply the visibility and replace_if_exists logic to it.
      If the operation is still valid, then get all the info about the destination inode and
      delete it. Apply the info on the destination inode to the source.
    - Do a rename

--*/
{
    NTSTATUS LocalStatus = STATUS_UNSUCCESSFUL;
    ULONG ShadowFileLength;
    int iRet = -1;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry =
                  SmbCeGetAssociatedNetRootEntry(NetRoot);

    UNICODE_STRING RenameName={0,0,NULL};
    UNICODE_STRING LastComponentName = {0,0,NULL};
    PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;
    MRX_SMB_FCB CscSmbFcb;

    BOOLEAN EnteredCriticalSection = FALSE;
    _WIN32_FIND_DATA Find32; //this should not be on the stack CODE.IMPROVEMENT
    ULONG ulInheritedHintFlags=0;

    BOOL fDoTunneling = FALSE;
    HSHADOW hDir, hDirTo, hShadow=0, hShadowTo=0;
    ULONG uShadowStatusFrom, uShadowStatusTo, uRenameFlags, attrSav;
    OTHERINFO sOI, sOIFrom;
    LPOTHERINFO lpOI=NULL;
    BOOLEAN Disconnected, fAlreadyStripped = FALSE;
    RETRIEVE_TUNNEL_INFO_RETURNS TunnelType;
    _FILETIME ftLWTime;
    BOOL fFile;
    USHORT *lpcFileNameTuna = NULL, *lpcAlternateFileNameTuna = NULL;

    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)) {
        RxLog(("RenCSC disabled \n"));
        return;
    }

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    // an open for rename should never be a local open
    ASSERT(!BooleanFlagOn(
               smbSrvOpen->Flags,
               SMB_SRVOPEN_FLAG_LOCAL_OPEN));

    if (!Disconnected &&
        !pNetRootEntry->NetRoot.CscEnabled) {
        RxLog(("NR %x Not cscenabled %x\n", pNetRootEntry));
        return;
    }

    RxDbgTrace(+1, Dbg,
    ("MRxSmbCscRenameEpilogue entry %08lx...%08lx on handle %08lx\n",
        RxContext, SrvOpen, smbSrvOpen->hfShadow ));

    if (*Status != STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue exit(status) w/o deleteing -> %08lx %08lx\n", RxContext, Status ));
        goto FINALLY;
    }

    uRenameFlags = 0;

    EnterShadowCritRx(RxContext);
    EnteredCriticalSection = TRUE;

    //if we don't have a shadow...go look for one
    if (smbFcb->hShadow == 0) {
        LocalStatus = MRxSmbCscObtainShadowHandles(
                  RxContext,
                  Status,
                  &Find32,
                  NULL,
                  CREATESHADOW_CONTROL_NOCREATE|
                  ((capFobx->Flags & FOBX_FLAG_DFS_OPEN)?CREATESHADOW_CONTROL_STRIP_SHARE_NAME:0),
                  Disconnected);

        if (LocalStatus != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg,
            ("MRxSmbCscRenameEpilogue couldn't get handles-> %08lx %08lx\n",RxContext,LocalStatus ));
            goto FINALLY;
        }

        if (smbFcb->hShadow == 0) {
            RxDbgTrace(0, Dbg,
            ("MRxSmbCscRenameEpilogue no handles-> %08lx %08lx\n",RxContext,LocalStatus ));
            goto FINALLY;
        }
    }

    if (GetShadowInfo(
        smbFcb->hParentDir,
        smbFcb->hShadow,
        &Find32,
        &uShadowStatusFrom, &sOIFrom) < SRET_OK) {
        LocalStatus = STATUS_NO_SUCH_FILE;
        goto FINALLY;
    }

    hShadow = smbFcb->hShadow;
    hDir = smbFcb->hParentDir;
    if (!hShadow ||
    !IsShadowVisible(
        Disconnected,
        Find32.dwFileAttributes,
        uShadowStatusFrom))  {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscRenameEpilogue no shadoworinvisible-> %08lx %08lx\n",RxContext,LocalStatus ));
            LocalStatus = STATUS_NO_SUCH_FILE;
            goto FINALLY;
    }

//    DbgPrint("Renaming %ws ", Find32.cFileName);
    RxLog(("Renaming hDir=%x hShadow=%x %ws ", hDir, hShadow, Find32.cFileName));

    fFile = IsFile(Find32.dwFileAttributes);

    // NB begin temp use of uRenameFlags
    uRenameFlags = (wstrlen(Find32.cFileName)+1)*sizeof(USHORT);

    lpcFileNameTuna = AllocMem(uRenameFlags);

    lpcAlternateFileNameTuna = AllocMem(sizeof(Find32.cAlternateFileName));

    if (!lpcFileNameTuna || ! lpcAlternateFileNameTuna) {
        LocalStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY; //bailout;
    }

    // save the alternate filename for tunnelling purposes
    memcpy(lpcAlternateFileNameTuna,
       Find32.cAlternateFileName,
       sizeof(Find32.cAlternateFileName));

    memcpy(lpcFileNameTuna, Find32.cFileName, uRenameFlags);

    // end temp use of uRenameFlags
    uRenameFlags = 0;


    // Save the last write time
    ftLWTime = Find32.ftLastWriteTime;

    if (Disconnected) {

        // if this is a file and we are trying to delete it
        // without permissions, then bail

        if (fFile &&
            !(FILE_WRITE_DATA & smbSrvOpen->MaximalAccessRights)&&
            !(FILE_WRITE_DATA & smbSrvOpen->GuestMaximalAccessRights))
        {
            LocalStatus = STATUS_ACCESS_DENIED;
            RxLog(("No rights to rename %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
            HookKdPrint(BADERRORS, ("No rights to rename %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
            goto FINALLY; //bailout;
        }

        // In disconnected state we don't allow directory renames on
        // remotely obtained directories
        // This is consistent with not allowing delete on these directories

        if (!fFile && !mShadowLocallyCreated(uShadowStatusFrom)) {
            LocalStatus = STATUS_ONLY_IF_CONNECTED;
            goto FINALLY; //bailout;
        }

        if (!mShadowLocallyCreated(uShadowStatusFrom)) { // remote object

            // Ask RenameShadow to mark the source as deleted, it will have to
            // be reintegrated later
            uRenameFlags |= RNMFLGS_MARK_SOURCE_DELETED;

            // if this is the copy of the original,
            // ie. it has not gone through delete/create cycles,
            // we need to save it's value in the new shadow structure
            // so that while reintegrating, we can do rename operations
            // before merging.
            // The SHADOW_REUSE flag is set in CreateShadowFromPath, and
            // in his routine while dealing with hShadowTo
            // when the shadow of a remote object that has been marked deleted
            // is reused during disconnected operation.
            // When a reused object is renamed, the new object is NOT a
            // true alias of the original object on the Share

            if (!mShadowReused(uShadowStatusFrom)) {
                // not been reused, give his rename alias, if any, to the new one
                uRenameFlags |= RNMFLGS_SAVE_ALIAS;
            }
        }
        else
        { // locally created

            // This is a locally created shadow that is being renamed
            // we wan't to retain it's alias, if any, so we know if it
            // was renamed from a remote object or was created locally
            uRenameFlags |= RNMFLGS_RETAIN_ALIAS;
        }
    }

    // Let us create the directory hierarchy in which the file/directory
    // is to be renamed
//    ASSERT((RenameInformation->FileName[0] == L'\\') || (RenameInformation->FileName[0] == L':'))
    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;
    if (smbFcb->uniDfsPrefix.Buffer)
    {
        UNICODE_STRING  DfsName;

        if (capFobx->Flags & FOBX_FLAG_DFS_OPEN)
        {
            LocalStatus = CscDfsStripLeadingServerShare(&RenameName);

            if (LocalStatus != STATUS_SUCCESS)
            {
                RenameName.Buffer = NULL;
                goto FINALLY;
            }

            fAlreadyStripped = TRUE;
        }

        if(CscDfsDoDfsNameMapping(&smbFcb->uniDfsPrefix,
                               &smbFcb->uniActualPrefix,
                               &RenameName,
                               TRUE,    //fResolvedNameToDFSName
                               &DfsName
                               ) != STATUS_SUCCESS)
        {
            LocalStatus = STATUS_INSUFFICIENT_RESOURCES;
            RenameName.Buffer = NULL;
            goto FINALLY;
        }

        RenameName = DfsName;
    }


    RtlZeroMemory(&CscSmbFcb, sizeof(CscSmbFcb));

    CscSmbFcb.MinimalCscSmbFcb.sCscRootInfo = smbFcb->sCscRootInfo;

    MRxSmbCscCreateShadowFromPath(
        &RenameName,
        &CscSmbFcb.MinimalCscSmbFcb.sCscRootInfo,
        &Find32,
        NULL,
        (CREATESHADOW_CONTROL_NOREVERSELOOKUP |
         CREATESHADOW_CONTROL_NOCREATELEAF|
         ((!fAlreadyStripped && (capFobx->Flags & FOBX_FLAG_DFS_OPEN))?CREATESHADOW_CONTROL_STRIP_SHARE_NAME:0)
         ),
        &CscSmbFcb.MinimalCscSmbFcb,
        RxContext,
        Disconnected,
        &ulInheritedHintFlags
        );

    hDirTo = CscSmbFcb.MinimalCscSmbFcb.hParentDir;
    hShadowTo = CscSmbFcb.MinimalCscSmbFcb.hShadow;
    uShadowStatusTo = CscSmbFcb.MinimalCscSmbFcb.ShadowStatus;

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...000=%08lx %08lx %08lx\n",
            hDirTo,hShadowTo,uShadowStatusTo));

    if (!hDirTo) {
        HookKdPrint(BADERRORS, ("Cannot rename root %x in dcon \n", hShadowTo));
        LocalStatus = STATUS_ACCESS_DENIED;
        goto FINALLY; //bailout;
    }

    //
    // allocate a buffer that's the right size: one extra char is
    // for a trailing null....this buffer is used to get the tunnelling
    // information

    LastComponentName.Length = CscSmbFcb.MinimalCscSmbFcb.LastComponentLength;
    LastComponentName.Buffer = (PWCHAR)RxAllocatePoolWithTag(
                        PagedPool,
                        LastComponentName.Length  + (1 * sizeof(WCHAR)),
                        RX_MISC_POOLTAG);

    if (LastComponentName.Buffer==NULL) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue -> noalloc\n"));
    } else {
        PWCHAR t;

        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...lastcomponentinhex=%08lx\n",LastComponentName.Buffer));
        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...renamebuffer=%08lx\n",RenameName.Buffer));
        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...lcofff=%08lx,%08lx\n",
                      CscSmbFcb.MinimalCscSmbFcb.LastComponentOffset,CscSmbFcb.MinimalCscSmbFcb.LastComponentLength));

        RtlCopyMemory(
            LastComponentName.Buffer,
            RenameName.Buffer + CscSmbFcb.MinimalCscSmbFcb.LastComponentOffset,
            LastComponentName.Length);

        t = (PWCHAR)( ((PBYTE)(LastComponentName.Buffer)) + LastComponentName.Length );

        *t = 0;

        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...lastcomponent=%ws (%08lx)\n",
                LastComponentName.Buffer,LastComponentName.Buffer));
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 1111=(%08lx)\n", hDirTo));

    // Do we have a destination shadow for rename?
    if (hShadowTo) {

        BOOLEAN fDestShadowVisible = FALSE;

        if (IsShadowVisible(
            Disconnected,
            Find32.dwFileAttributes,
            uShadowStatusTo))
        {
            fDestShadowVisible = TRUE;
        }

        // If it is visible and this is not a replace_if_exists operation
        // then this is an illegal rename

        if (fDestShadowVisible && !RxContext->Info.ReplaceIfExists)
        {
            LocalStatus = STATUS_OBJECT_NAME_COLLISION;
            goto FINALLY; //bailout;
        }

        if (!Disconnected) {// connected

            if (!RxContext->Info.ReplaceIfExists)
            {
                // When we are connected, we are doing rename in caching mode
                // If the renameTo exists and needs reintegration,
                // we protect it by nuking the renameFrom and succeeding
                // the rename

                KdPrint(("SfnRename:unary op %x, \r\n", hShadow));

                ASSERT(mShadowOutofSync(uShadowStatusTo));

                ASSERT(!fFile || !mShadowOutofSync(uShadowStatusFrom));
                ASSERT(!mShadowBusy(uShadowStatusFrom));

                if(DeleteShadow(hDir, hShadow) < SRET_OK) {
                    LocalStatus = STATUS_UNSUCCESSFUL;
                } else {
                    iRet = 0;
                    smbFcb->hShadow = 0;
                }

                goto FINALLY; //bailout;
            }
        }

        // Nuke the renameTo shadow
        if(DeleteShadow(hDirTo, hShadowTo) < SRET_OK) {
            LocalStatus = STATUS_UNSUCCESSFUL;
            goto FINALLY; //bailout;
        } else {
            //hunt up the fcb, if any and zero the hshadow
            PFDB smbLookedUpFdbTo;
            PMRX_SMB_FCB smbFcbTo;

            smbLookedUpFdbTo = PFindFdbFromHShadow(hShadowTo);
            if (smbLookedUpFdbTo!=NULL) {
                smbFcbTo = MRxSmbCscRecoverMrxFcbFromFdb(smbLookedUpFdbTo);
                RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue lookups -> %08lx %08lx %08lx\n",
                        smbFcbTo,
                        smbLookedUpFdbTo,
                        hShadowTo  ));
                ASSERT((smbFcbTo->hShadow == hShadowTo)||(smbFcbTo->hShadowRenamed == hShadowTo));
                smbFcbTo->hShadow = 0;
            }
        }

        if (Disconnected && !mShadowLocallyCreated(uShadowStatusTo)) {
            // When the renameTo is a remote object
            // it is possible for two remote objects to get crosslinked, ie. be each others
            // aliases. The reintegrator needs to deal with this case.

            // Cleanup the locally created status of the hShadowFrom if it
            // did exist because it is being renamed to a remote object
            mClearBits(uShadowStatusFrom, SHADOW_LOCALLY_CREATED);

            // Mark the original object as having been reused so a rename
            // on it will not point back to this object.
            // Also set all the CHANGE attributes to indicate that this is a
            // spanking new object. Actually doesn't SHADOW_REUSED flag do that
            // already?
            mSetBits(uShadowStatusFrom, SHADOW_REUSED|SHADOW_DIRTY|SHADOW_ATTRIB_CHANGE);
        }
    }

    if (!hShadowTo)
    {
        if (Disconnected) {
            // we don't have a renameTo. If we are in disconnected state, let us
            // mark it as locally created, which it is.
            mSetBits(uShadowStatusFrom, SHADOW_LOCALLY_CREATED);
        }
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 3333= (%08lx)\n", hDirTo));
    ASSERT(hDir && hShadow && hDirTo);

    if (!Disconnected)    {// connected
        //get the names and attributes from the Share
        MRxSmbGetFileInfoFromServer(RxContext,&RenameName,&Find32,NULL,NULL);
    } else {// disconnected
        if (hShadowTo) {
            // Find32 contains the orgtime of hShadowTo
            // we tell the RenameShadow routine to reuse it.

            Find32.ftLastWriteTime = ftLWTime;
            uRenameFlags |= RNMFLGS_USE_FIND32_TIMESTAMPS;
        } else {
            Find32.cFileName[0] = 0;
            Find32.cAlternateFileName[0] = 0;
        }
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 4444= (%08lx)\n", hDirTo));

    if (!fFile) {
        // We set the reference priority of the directories to their level
        // in the hierarchiy starting 1 for the root. That way we
        // walk the PQ in reverse priority order for directories. to create
        // all the direcotry objects hierarchically. But with hints
        // this is going to be a problem.
        Find32.dwReserved0 = GetPathLevelFromUnicodeString(&RenameName);
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 5555= (%08lx)\n", hDirTo));
    // If there is any tunnelling info then use it to create this guy
    if (LastComponentName.Buffer &&
    (TunnelType = RetrieveTunnelInfo(
              hDirTo,    // directory where the renames are happenieng
              LastComponentName.Buffer,    // potential SFN
              (Disconnected)? &Find32:NULL, // get LFN only when disconnected
              &sOI)))  {
        lpOI = &sOI;
    }

    if (Disconnected) {
        //muck with the names.......
        switch (TunnelType) {
            case TUNNEL_RET_SHORTNAME_TUNNEL:
            //we tunneled on the shortname.....retrievetunnelinfo did the copies....
            break;

            case TUNNEL_RET_NOTFOUND:
                //no tunnel. use the name passed as the long name
            RtlCopyMemory( &Find32.cFileName[0],
               LastComponentName.Buffer,
               LastComponentName.Length + sizeof(WCHAR) );
            //lack of break intentional;

            case TUNNEL_RET_LONGNAME_TUNNEL:
            //if we tunneled on the longname....retrievetunnelinfo did the copies....
            //but we may still need a shortname
            MRxSmbCscGenerate83NameAsNeeded(hDirTo,
                            &Find32.cFileName[0],
                            &Find32.cAlternateFileName[0]);
            break;
        }
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 6666=(%08lx)\n", hDirTo));


    if (RenameShadow(
        hDir,
        hShadow,
        hDirTo,
        &Find32,
        uShadowStatusFrom,
        lpOI,
        uRenameFlags,
        &hShadowTo) < SRET_OK)
    {
        LocalStatus = STATUS_UNSUCCESSFUL;
        goto FINALLY; //bailout;
    }

    smbFcb->hShadow = 0;

    ASSERT(hShadowTo);

    smbFcb->hShadowRenamed = hShadowTo;
    smbFcb->hParentDirRenamed = hDirTo;

    fDoTunneling = TRUE;

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 7777= (%08lx)\n", hDirTo));
    if (Disconnected) {
        // Mark it on the Share, so reintegration can proceed
        MarkShareDirty(&smbFcb->sCscRootInfo.ShareStatus,
                        (ULONG)(smbFcb->sCscRootInfo.hShare));
    }

    if (mPinInheritFlags(ulInheritedHintFlags))
    {
        RxDbgTrace(0, Dbg, ("RenameEpilogue: Setting inherited hintflags on hShadow=%x \n", hShadowTo));

        if(GetShadowInfo(hDirTo, hShadowTo, NULL, NULL, &sOI) >= SRET_OK)
        {
            if (ulInheritedHintFlags & FLAG_CSC_HINT_PIN_INHERIT_USER) {
                sOI.ulHintFlags |= FLAG_CSC_HINT_PIN_USER;
            }

            if (ulInheritedHintFlags & FLAG_CSC_HINT_PIN_INHERIT_SYSTEM) {
                sOI.ulHintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
            }

            SetShadowInfoEx(hDirTo, hShadowTo, NULL, 0, SHADOW_FLAGS_OR, &sOI, NULL, NULL);
        }
    }

    iRet = 0;

    // This effectively bumps up the version number of the current CSC namespace
    // if this share is a remoteboot share and is being merged, then the reintegration code will
    // backoff

    IncrementActivityCountForShare(smbFcb->sCscRootInfo.hShare);

FINALLY:
    if (fDoTunneling) {
        // We succeeded the rename, let use keep the tunneling info for the source
        InsertTunnelInfo(
            hDir,
            lpcFileNameTuna,
            lpcAlternateFileNameTuna,
            &sOIFrom);
    }

    if (EnteredCriticalSection) {
        LeaveShadowCritRx(RxContext);
    }

    if (LastComponentName.Buffer) {
        RxFreePool(LastComponentName.Buffer);
    }

    if (lpcFileNameTuna) {
        FreeMem(lpcFileNameTuna);
    }

    if (lpcAlternateFileNameTuna) {
        FreeMem(lpcAlternateFileNameTuna);
    }

    if (Disconnected) {
        if (iRet!=0) {
            *Status = LocalStatus;
        }
        else
        {
            // when disconnected, report the change
            // we can be smart about this and report only once if this is not across
            // directories
            FsRtlNotifyFullReportChange(
                pNetRootEntry->NetRoot.pNotifySync,
                &pNetRootEntry->NetRoot.DirNotifyList,
                (PSTRING)GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                (USHORT)(GET_ALREADY_PREFIXED_NAME(NULL, capFcb)->Length -
                smbFcb->MinimalCscSmbFcb.LastComponentLength),
                NULL,
                NULL,
                (fFile)?FILE_NOTIFY_CHANGE_FILE_NAME:FILE_NOTIFY_CHANGE_DIR_NAME,
                FILE_ACTION_RENAMED_OLD_NAME,
                NULL);

            // upcase it so change notification will get it right

            UniToUpper(RenameName.Buffer, RenameName.Buffer, RenameName.Length);
            FsRtlNotifyFullReportChange(
                pNetRootEntry->NetRoot.pNotifySync,
                &pNetRootEntry->NetRoot.DirNotifyList,
                (PSTRING)&RenameName,
                (USHORT)(RenameName.Length -
                    CscSmbFcb.MinimalCscSmbFcb.LastComponentLength),
                NULL,
                NULL,
                (fFile)?FILE_NOTIFY_CHANGE_FILE_NAME:FILE_NOTIFY_CHANGE_DIR_NAME,
                FILE_ACTION_RENAMED_NEW_NAME,
                NULL);
        }
    }

    if (smbFcb->uniDfsPrefix.Buffer && RenameName.Buffer)
    {
        RxFreePool(RenameName.Buffer);
    }

//    DbgPrint("to %ws\n", Find32.cFileName);
    RxLog(("to hDirTo=%x hShadowTo=%x %ws uShadowStatusFrom=%x\n", hDirTo, hShadowTo, Find32.cFileName, uShadowStatusFrom));

    RxLog(("Status=%x \n\n", *Status));

    RxDbgTrace(-1, Dbg, ("MRxSmbCscRenameEpilogue exit-> %08lx %08lx\n", RxContext, *Status ));
    return;
}


VOID
MRxSmbCscCloseShadowHandle (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine closes the filehandle opened for CSC.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

//    DbgPrint("MRxSmbCscCloseShadowHandle %x\n", smbSrvOpen->hfShadow);

    ASSERT(smbSrvOpen->hfShadow != 0);

    CloseFileLocal((CSCHFILE)(smbSrvOpen->hfShadow));

    smbSrvOpen->hfShadow = 0;

    if (smbSrvOpen->Flags & SMB_SRVOPEN_FLAG_LOCAL_OPEN)
    {
        ASSERT(smbFcb->cntLocalOpens);
        smbFcb->cntLocalOpens--;
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscCloseShadowHandle\n"));
}

NTSTATUS
MRxSmbCscFixupFindFirst (
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
    )
/*++

Routine Description:

   This routine is called from the simplesyncT2 builder/sender to fixup
   the t2 request before it's sent. the deal is that the parameters section
   has to be built up in part but i don't want to preallocate. so, i pass in
   a dummy (but valid pointer) and then drop in the actual parameters
   here.

Arguments:


Return Value:


Notes:

    We will use the smbbuf for everything here. First, we use it for sending
    and receiving. at the end of receiving, the FILE_BOTH_INFORMATION will be
    in the buffer and this will be recomposed into a w32_find buffer in the
    same buffer. if we find for any reason that we can't do this (buffer too
    small, send/rcv doesn't work, whatever) then we'll nuke the shadow and it
    will have to be reloaded.


--*/
{
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_HEADER SmbHeader = (PSMB_HEADER)StufferState->BufferBase;
    PREQ_TRANSACTION  TransactRequest = (PREQ_TRANSACTION)(SmbHeader+1);
    ULONG ParameterCount = SmbGetUshort(&TransactRequest->ParameterCount);
    ULONG ParameterOffset = SmbGetUshort(&TransactRequest->ParameterOffset);
    PBYTE Parameters = ((PBYTE)(SmbHeader))+ParameterOffset;
    REQ_FIND_FIRST2 FindFirst;
    NTSTATUS Status=STATUS_SUCCESS;
    PSMBCE_SERVER   pServer = NULL;

    RxDbgTrace(0, Dbg, ("MRxSmbCscFixupFindFirst %08lx %08lx %08lx %08lx\n",
        OrdinaryExchange,ParameterCount,ParameterOffset,Parameters));

    // SearchAttributes is hardcoded to the magic number 0x16
    FindFirst.SearchAttributes = (SMB_FILE_ATTRIBUTE_DIRECTORY |
                  SMB_FILE_ATTRIBUTE_SYSTEM |
                  SMB_FILE_ATTRIBUTE_HIDDEN);

    FindFirst.SearchCount = 1;

    FindFirst.Flags = (SMB_FIND_CLOSE_AFTER_REQUEST |
               SMB_FIND_CLOSE_AT_EOS |
               SMB_FIND_RETURN_RESUME_KEYS);

    FindFirst.InformationLevel = SMB_FIND_FILE_BOTH_DIRECTORY_INFO;

    FindFirst.SearchStorageType = 0;

    RtlCopyMemory (
    Parameters,
    &FindFirst,
    FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]));
    pServer = SmbCeGetExchangeServer(OrdinaryExchange);

    ASSERT(pServer);

    if (FlagOn(pServer->DialectFlags,DF_UNICODE))
    {

        ASSERT(FlagOn(SmbHeader->Flags2,SMB_FLAGS2_UNICODE));

        RtlCopyMemory(
            Parameters + FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]),
            OrdinaryExchange->pPathArgument1->Buffer,
            OrdinaryExchange->pPathArgument1->Length);

        SmbPutUshort(
            (Parameters +
             FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]) +
             OrdinaryExchange->pPathArgument1->Length),
            0); //traiing null
    }
    else
    {
        OEM_STRING OemString;

        OemString.Length =
        OemString.MaximumLength =
            (USHORT)( StufferState->BufferLimit - Parameters  - sizeof(CHAR));

        OemString.Buffer = (Parameters + FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]));

        if (FlagOn(SmbHeader->Flags,SMB_FLAGS_CASE_INSENSITIVE) &&
            !FlagOn(SmbHeader->Flags2,SMB_FLAGS2_KNOWS_LONG_NAMES)) {
            Status = RtlUpcaseUnicodeStringToOemString(
                             &OemString,
                             OrdinaryExchange->pPathArgument1,
                             FALSE);
        } else {
            Status = RtlUnicodeStringToOemString(
                             &OemString,
                             OrdinaryExchange->pPathArgument1,
                             FALSE);
        }

        if (!NT_SUCCESS(Status)) {
            ASSERT(!"BufferOverrun");
            return(RX_MAP_STATUS(BUFFER_OVERFLOW));
        }

        OemString.Length = (USHORT)RtlxUnicodeStringToOemSize(OrdinaryExchange->pPathArgument1);

        ASSERT(OemString.Length);

        *(Parameters + FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0])+OemString.Length-1) = 0;
    }

    return(Status);
}

typedef  FILE_BOTH_DIR_INFORMATION SMB_UNALIGNED *MRXSMBCSC_FILE_BOTH_DIR_INFORMATION;
VOID
MRxSmbCscLocateAndFillFind32WithinSmbbuf(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

   When this routine is called, the associated smbbuf contains a findfirst
   response with the FILE_BOTH_INFORMATION aboard. This routine first locates
   a position in the smbbuf to hold a find32. Then, the information is
   converted from the NT format for use with the shadow routines.


Arguments:


Return Value:

    Find32 - The ptr to the find32 (actually, the smbbuf!)

Notes:


--*/
{
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_HEADER SmbHeader = (PSMB_HEADER)StufferState->BufferBase;
    PRESP_TRANSACTION TransactResponse = (PRESP_TRANSACTION)(SmbHeader+1);
    ULONG DataOffset,FileNameLength,ShortNameLength;
    _WIN32_FIND_DATA *Find32;
    PBYTE AlternateName;
    MRXSMBCSC_FILE_BOTH_DIR_INFORMATION BothDirInfo;
    PSMBCE_SERVER   pServer = NULL;

    //first, we have to get a potentially unaligned ptr to the bothdirinfo
    DataOffset = SmbGetUshort(&TransactResponse->DataOffset);

    AlternateName = ((PBYTE)SmbHeader);
    BothDirInfo = (MRXSMBCSC_FILE_BOTH_DIR_INFORMATION)(((PBYTE)SmbHeader)+DataOffset);
    FileNameLength = SmbGetUlong(&BothDirInfo->FileNameLength);
    ShortNameLength = BothDirInfo->ShortNameLength;
    RxDbgTrace(0, Dbg, ("MRxSmbCscLocateAndFillFind32WithinSmbbuf offset=%08lx %08lx %08lx\n",
        DataOffset,FileNameLength,ShortNameLength));


    //save the alternate name info in the very beginning of the buffer..that
    //way, the copy of the full name will not destroy it
    if (ShortNameLength != 0) {
        RtlCopyMemory(
            AlternateName,
            &BothDirInfo->ShortName[0],
            ShortNameLength);
    }


    Find32 = (_WIN32_FIND_DATA *)(AlternateName + LongAlign(sizeof(Find32->cAlternateFileName)));
    Find32->dwFileAttributes = SmbGetUlong(&BothDirInfo->FileAttributes);
    Find32->ftCreationTime.dwLowDateTime = SmbGetUlong(&BothDirInfo->CreationTime.LowPart);
    Find32->ftCreationTime.dwHighDateTime = SmbGetUlong(&BothDirInfo->CreationTime.HighPart);
    Find32->ftLastAccessTime.dwLowDateTime = SmbGetUlong(&BothDirInfo->LastAccessTime.LowPart);
    Find32->ftLastAccessTime.dwHighDateTime = SmbGetUlong(&BothDirInfo->LastAccessTime.HighPart);
    Find32->ftLastWriteTime.dwLowDateTime = SmbGetUlong(&BothDirInfo->LastWriteTime.LowPart);
    Find32->ftLastWriteTime.dwHighDateTime = SmbGetUlong(&BothDirInfo->LastWriteTime.HighPart);
    Find32->nFileSizeLow = SmbGetUlong(&BothDirInfo->EndOfFile.LowPart);
    Find32->nFileSizeHigh = SmbGetUlong(&BothDirInfo->EndOfFile.HighPart);

    pServer = SmbCeGetExchangeServer(OrdinaryExchange);

    ASSERT(pServer);

    if (FlagOn(pServer->DialectFlags,DF_UNICODE))
    {
        //copy the full name....don't forget the NULL
        RtlCopyMemory (
            &Find32->cFileName[0],
            &BothDirInfo->FileName[0],
            FileNameLength );

        Find32->cFileName[FileNameLength/sizeof(WCHAR)] = 0;

        //finally, copy the shortname...don't forget the null
        RtlCopyMemory(
            &Find32->cAlternateFileName[0],
            AlternateName,
            ShortNameLength );

            Find32->cAlternateFileName[ShortNameLength/sizeof(WCHAR)] = 0;
    }
    else
    {
        UNICODE_STRING  strUni;
        OEM_STRING      strOem;
        NTSTATUS Status;

        strOem.Length = strOem.MaximumLength = (USHORT)FileNameLength;
        strOem.Buffer = (PBYTE)&BothDirInfo->FileName[0];

        strUni.Length =  (USHORT)RtlxOemStringToUnicodeSize(&strOem);
        strUni.MaximumLength = (USHORT)sizeof(Find32->cFileName);
        strUni.Buffer = Find32->cFileName;

        Status = RtlOemStringToUnicodeString(&strUni, &strOem, FALSE);
        ASSERT(Status == STATUS_SUCCESS);

        Find32->cFileName[strUni.Length/sizeof(WCHAR)];

        strOem.Length = strOem.MaximumLength = (USHORT)ShortNameLength;
        strOem.Buffer = AlternateName;

        strUni.Length = (USHORT)RtlxOemStringToUnicodeSize(&strOem);
        strUni.MaximumLength = (USHORT)sizeof(Find32->cAlternateFileName);
        strUni.Buffer = Find32->cAlternateFileName;

        Status = RtlOemStringToUnicodeString(&strUni, &strOem, FALSE);

        if (Status != STATUS_SUCCESS)
        {
            DbgPrint("oem=%x, uni=%x Status=%x\n", &strUni, &strOem, Status);
            ASSERT(FALSE);
        }

        Find32->cAlternateFileName[strUni.Length/sizeof(WCHAR)];
        ASSERT(Find32->cFileName[0]);
    }

    OrdinaryExchange->Find32WithinSmbbuf = Find32;

    RxDbgTrace(0, Dbg, ("MRxSmbCscLocateAndFillFind32WithinSmbbuf size,name=%08lx %ws\n",
        Find32->nFileSizeLow, &Find32->cFileName[0]));

    return;
}


NTSTATUS
MRxSmbCscGetFileInfoFromServerWithinExchange (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    PUNICODE_STRING FileName OPTIONAL
    )
/*++

Routine Description:

   This routine reads information about a file; it may have been locally
   modified or it may be in the process of having a showdow created. in any
   case, the info is returned as a pointer to a Find32 structure. The find32
   structure is contained within the smbbuf of the exchange.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    We will use the smbbuf for everything here. First, we use it for sending
    and receiving. at the end of receiving, the FILE_BOTH_INFORMATION will be
    in the buffer and this will be recomposed into a w32_find buffer in the
    same buffer. if we find for any reason that we can't do this (buffer too
    small, send/rcv doesn't work, whatever) then we'll nuke the shadow and it
    will have to be reloaded.


--*/
{
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    ULONG ParameterLength, TotalLength;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    if (FileName!=NULL) {
        OrdinaryExchange->pPathArgument1 = FileName; //so it can be found later
    } else {
        ASSERT(OrdinaryExchange->pPathArgument1 != NULL);
        FileName = OrdinaryExchange->pPathArgument1;
    }

    ParameterLength = FileName->Length + sizeof(WCHAR);
    ParameterLength += FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]);

    TotalLength = sizeof(SMB_HEADER) + FIELD_OFFSET(REQ_TRANSACTION,Buffer[0]);  //basic
    TotalLength += sizeof(WORD); //bytecount
    TotalLength = LongAlign(TotalLength); //move past pad
    TotalLength += LongAlign(ParameterLength);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscGetFileInfoFromServerWithinExchange %08lx %08lx %08lx\n",
      RxContext,TotalLength,ParameterLength));

    if (TotalLength > OrdinaryExchange->SmbBufSize) {
        goto FINALLY;
    }

    //note that the parameter buffer is not the actual parameters BUT
    //it is a valid buffer. CODE.IMPROVEMENT perhaps the called routine
    //should take cognizance of the passed fixup routine and not require
    //a valid param buffer and not do the copy.

    Status = __MRxSmbSimpleSyncTransact2(
         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
         SMBPSE_OETYPE_T2_FOR_ONE_FILE_DIRCTRL,
         TRANS2_FIND_FIRST2,
         StufferState->ActualBufferBase,ParameterLength,
         NULL,0,
         MRxSmbCscFixupFindFirst
         );

    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    MRxSmbCscLocateAndFillFind32WithinSmbbuf(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCscGetFileInfoFromServerWithinExchange %08lx %08lx\n",
        RxContext,Status));

    return(Status);

}

VOID
MRxSmbCscUpdateShadowFromClose (
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

   This routine updates the shadow information after a close.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    If anything every goes wrong, we just don't update. this will cause
    the shadow to be reload later.


--*/
{
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    RxCaptureFcb;RxCaptureFobx;

    PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);

    _WIN32_FIND_DATA *Find32 = NULL;
    ULONG uStatus;
    int TruncateRetVal = -1;
    _WIN32_FIND_DATA *AllocatedFind32 = NULL;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;

    PMRX_SRV_OPEN     SrvOpen    = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    BOOLEAN Disconnected;

    RxDbgTrace(+1, Dbg, ("MRxSmbCscUpdateShadowFromClose %08lx\n",
      RxContext));

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    pServerEntry  = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (smbFcb->hShadow==0) {
        if (Disconnected) {
            if (smbSrvOpen->hfShadow != 0){
                MRxSmbCscCloseShadowHandle(RxContext);
            }
        }

        RxDbgTrace(-1, Dbg,
            ("MRxSmbCscUpdateShadowFromClose shadowzero %08lx\n",RxContext));

        return;
    }

    if (smbFcb->ContainingFcb->FcbState & FCB_STATE_ORPHANED)
    {
        if (smbSrvOpen->hfShadow != 0){
            MRxSmbCscCloseShadowHandle(RxContext);
        }

        RxDbgTrace(-1, Dbg,
            ("MRxSmbCscUpdateShadowFromClose Orphaned FCB %x\n", smbFcb->ContainingFcb));

        return;
    }

    EnterShadowCritRx(RxContext);

    if (!Disconnected) {
        // If the file has been modified, we need to get the new timestamp
        // from the server. By the time we come here the file has already been
        // closed on the server, so we can safely get the new timestamp.

        if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED)){
            NTSTATUS LocalStatus;

            LeaveShadowCritRx(RxContext);

            LocalStatus = MRxSmbCscGetFileInfoFromServerWithinExchange(
                       SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                       GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext));

            if (LocalStatus == STATUS_SUCCESS) {
                Find32 = OrdinaryExchange->Find32WithinSmbbuf;
                RxLog(("Fromclose hShadow=%x l=%x h=%x\n", smbFcb->hShadow, Find32->ftLastWriteTime.dwLowDateTime, Find32->ftLastWriteTime.dwHighDateTime));
            } else {
                RxLog(("MRxSmbCscGetFileInfoFromServerWithinExchange returned LocalStatus\n"));
            }

            EnterShadowCritRx(RxContext);
        }

        if(GetShadowInfo(smbFcb->hParentDir,
                 smbFcb->hShadow,
                 NULL,
                 &uStatus, NULL) < SRET_OK)
        {
            goto FINALLY;
        }
        

		// in connected mode for a sparsely filled file that is not corrupt
        // ie. no writes have failed on it, if the original size and the
        // current size match, remove the sparse marking
		
		// This optimization was added for notepad case in which when the app
		// opens the file it reads the entire file. Therefore CSC does not need 
		// to fill the file and therefore we should clear the SPARSE flag. - NavjotV

		//WinSE Bug- 25843
		// We want to do this only if file is not Truncated in an earlier
		// create. When we truncate the file we want it to stay SPARSE till 
		// we actually fill the file - NavjotV


        if((NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE) &&
           !smbFcb->ShadowIsCorrupt &&
           !FlagOn(smbFcb->MFlags, SMB_FCB_FLAG_CSC_TRUNCATED_SHADOW) && 
		   (uStatus & SHADOW_SPARSE))
        {
            LARGE_INTEGER liTemp;

            if(GetSizeHSHADOW(
                smbFcb->hShadow,
                &(liTemp.HighPart),
                &(liTemp.LowPart))>=0)
            {
				
				if ((liTemp.HighPart == smbFcb->OriginalShadowSize.HighPart)&&
                    (liTemp.LowPart == smbFcb->OriginalShadowSize.LowPart))
                {
                    uStatus &= ~SHADOW_SPARSE;
                    smbFcb->ShadowStatus &= ~SHADOW_SPARSE;
//                    RxDbgTrace(0, Dbg, ("hShadow=%x unsparsed\r\n", smbFcb->hShadow));
                    RxLog(("hShadow=%x unsparsed\r\n", smbFcb->hShadow));
                }
            }
        }
    } else {
    // disconnected operation

        if (smbFcb->hParentDir==0xffffffff) {
            goto FINALLY;
        }

        AllocatedFind32 = (_WIN32_FIND_DATA *)RxAllocatePoolWithTag(
                            PagedPool | POOL_COLD_ALLOCATION,
                            sizeof(_WIN32_FIND_DATA),
                            RX_MISC_POOLTAG);
        if (AllocatedFind32==NULL) {
            goto FINALLY;
        }

        Find32 = AllocatedFind32;

        if (GetShadowInfo(
            smbFcb->hParentDir,
            smbFcb->hShadow,
            Find32,
            &uStatus,
            NULL) < SRET_OK) {
            goto FINALLY; //bailout;
        }

        if (IsFile(Find32->dwFileAttributes))
        {
            GetSizeHSHADOW(
                smbFcb->hShadow,
                &(Find32->nFileSizeHigh),
                &(Find32->nFileSizeLow));
        }
        else
        {
            Find32->nFileSizeHigh = Find32->nFileSizeLow = 0;
        }

    }

    // If the shadow has become stale due to write errors
    // or has become dirty because of writes on a complete file
    // or sparse because of writes beyond what we have cached
    // we need to mark it as such

    uStatus |= (smbFcb->ShadowStatus & SHADOW_MODFLAGS);

    if (Disconnected && FlagOn(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED))
    {
        uStatus |= SHADOW_DIRTY;
    }

    if (Disconnected && FlagOn(smbFcb->LocalFlags, FLAG_FDB_SHADOW_SNAPSHOTTED))
    {
        uStatus |= SHADOW_DIRTY;
    }

    if (Find32) {
        smbFcb->OriginalShadowSize.LowPart = Find32->nFileSizeLow;
        smbFcb->OriginalShadowSize.HighPart = Find32->nFileSizeHigh;
    }

    if (smbFcb->ShadowIsCorrupt) {
        TruncateRetVal = TruncateDataHSHADOW(smbFcb->hParentDir, smbFcb->hShadow);
        if (TruncateRetVal>=SRET_OK) {
            // Set status flags to indicate sparse file
            uStatus |= SHADOW_SPARSE;
        }
    }


    if (Disconnected &&
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED) &&
        !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SHADOW_LWT_MODIFIED))
    {
        GetSystemTime(&(Find32->ftLastWriteTime));
    }

    if (SetShadowInfo(
        smbFcb->hParentDir,
        smbFcb->hShadow,
        Find32,
        uStatus,
        ( SHADOW_FLAGS_ASSIGN |
        ((Disconnected) ?
        SHADOW_FLAGS_DONT_UPDATE_ORGTIME :
        0)
        )) < SRET_OK)  {

        goto FINALLY;
    }

    if (TruncateRetVal>=SRET_OK) {
        smbFcb->ShadowIsCorrupt = FALSE;
    }

    if (Disconnected) {
        if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SHADOW_MODIFIED)) {
            MarkShareDirty(&smbFcb->sCscRootInfo.ShareStatus, smbFcb->sCscRootInfo.hShare);
        }

        if (smbSrvOpen->hfShadow != 0){
            MRxSmbCscCloseShadowHandle(RxContext);
        }
    }

FINALLY:
    LeaveShadowCritRx(RxContext);

    if (AllocatedFind32!=NULL) {
        RxFreePool(AllocatedFind32);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscUpdateShadowFromClose %08lx\n",
        RxContext));

}

VOID
MRxSmbCscDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    )
/*++

Routine Description:

   This routine tears down the Csc part of a netroot. Currently, all it does is
   to pull the netroot out of the list of csc netroots.

Arguments:

    pNetRootEntry -

Return Value:

Notes:


--*/
{
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(pFcb);

    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)
        ) {
        pFcb->fMiniInited = FALSE; // clean it up on shutdown
        return;
    }

    if (pFcb->pNetRoot->Type != NET_ROOT_DISK)
    {
        return;
    }

    EnterShadowCrit();
    
#if defined(BITCOPY)

    if (smbFcb && smbFcb->lpDirtyBitmap) {
        LPSTR strmName;
        // Save Bitmap to disk and Delete Bitmap      
        strmName = FormAppendNameString(lpdbShadow,
                                smbFcb->hShadow,
                                CscBmpAltStrmName);
        if (strmName != NULL) {
            if (smbFcb->hShadow >= 0x80000000) {
                // Write only to file inodes
                CscBmpWrite(smbFcb->lpDirtyBitmap, strmName);
            }
            CscBmpDelete(&((LPCSC_BITMAP)(smbFcb->lpDirtyBitmap)));
            ExFreePool(strmName);
        }
    }
#endif // defined(BITCOPY)

    try
    {
        if (smbFcb->ShadowReverseTranslationLinks.Flink != 0) {

            RxDbgTrace(+1, Dbg, ("MRxSmbCscDeallocateForFcb...%08lx %08lx %08lx %08lx\n",
                            pFcb,
                            smbFcb->hShadow,
                            smbFcb->hParentDir,
                            smbFcb->ShadowReverseTranslationLinks.Flink ));

            ValidateSmbFcbList();
            ASSERT(pFcb->fMiniInited);
            pFcb->fMiniInited = FALSE;
            MRxSmbCscRemoveReverseFcbTranslation(smbFcb);

            RxDbgTrace(-1, Dbg, ("MRxSmbCscDeallocateForFcb exit\n"));
        } else {
            ASSERT(smbFcb->ShadowReverseTranslationLinks.Flink == 0);
        }

        if(FlagOn(smbFcb->LocalFlags, FLAG_FDB_DELETE_ON_CLOSE))
        {
            RxLog(("Dealloc: Deleting hShadow=%x %x %x \n", smbFcb->hShadow, pFcb, smbFcb));
            DeleteShadowHelper(FALSE, smbFcb->hParentDir, smbFcb->hShadow);
            smbFcb->hParentDir = smbFcb->hShadow = 0;
        }
        // if there are any Dfs reverse mapping structures, free them
        if (smbFcb->uniDfsPrefix.Buffer)
        {
            FreeMem(smbFcb->uniDfsPrefix.Buffer);
            ASSERT(smbFcb->uniActualPrefix.Buffer);
            FreeMem(smbFcb->uniActualPrefix.Buffer);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        if(pFcb->fMiniInited)
        {
            DbgPrint("CSCFcbList messed up \n");
            ASSERT(FALSE);
        }
        goto FINALLY;
    }
FINALLY:
    LeaveShadowCrit();

    return;
}

PMRX_SMB_FCB
MRxSmbCscRecoverMrxFcbFromFdb (
    IN PFDB Fdb
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    if (Fdb==NULL) {
        return NULL;
    }

    return CONTAINING_RECORD(
           &Fdb->usFlags,
           MRX_SMB_FCB,
           ShadowStatus
           );

}

PFDB MRxSmbCscFindFdbFromHShadow (
    IN HSHADOW hShadow
    )
/*++

Routine Description:

   This routine looks thru the current open mrxsmbfcbs and returns a mrxsmbfcb
   that corresponds to the HSHADOW passed. In the interest of not mucking with
   the w95 code, we cast this pointer into a PFDB in such a way that
   the the shadowstatus in the mrxsmbfcb lines up with the usFlags in PFDB.

Arguments:

Return Value:

Notes:


--*/
{
    PLIST_ENTRY pListEntry;

    DbgDoit(ASSERT(vfInShadowCrit));

    pListEntry = xCscFcbsList.Flink;
    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);

        if (((smbFcb->hShadow == hShadow)||(smbFcb->hShadowRenamed == hShadow)) &&
            (!(smbFcb->ContainingFcb->FcbState & FCB_STATE_ORPHANED)))
        {
            PFDB Fdb;
            PUSHORT pShadowStatus = &smbFcb->ShadowStatus;
            ASSERT ( sizeof(Fdb->usFlags) == sizeof (USHORT) );
            Fdb = CONTAINING_RECORD(pShadowStatus,FDB,usFlags);
            return Fdb;
        }

        pListEntry = pListEntry->Flink;
    }

    return NULL;
}

PRESOURCE
MRxSmbCscFindResourceFromHandlesWithModify (
    IN HSHARE  hShare,
    IN HSHADOW  hRoot,
    IN USHORT usLocalFlagsIncl,
    IN USHORT usLocalFlagsExcl,
    OUT PULONG ShareStatus,
    OUT PULONG DriveMap,
    IN  ULONG uStatus,
    IN  ULONG uOp
   )
/*++

Routine Description:

   This routine looks thru the currently connected netrootentries and
   returns the one that corresponds EITHER to the HSHADOW passed or to
   the HSHARE passed. In the interest of not mucking with the w95 code,
   we cast this pointer into a PRESOURCE. we also return the share
   status as well as the drivemap.....we dont know the drivemap
   but we could get it by walking the list of vnetroots. It is not used anywhere by the UI

   If the uOp is not 0xffffffff, then we modify the status as well as
   returning it.

Arguments:

    IN HSHARE  hShare - the share handle to look for
    IN HSHADOW  hRoot - the rootdir handle to look for
    IN USHORT usLocalFlagsIncl - make sure that some of these flags are included (0xffff mean
                         include any flags)
    IN USHORT usLocalFlagsExcl - make sure that none of these flags are included
    OUT PULONG ShareStatus - a pointer to where we will store the status
    OUT PULONG DriveMap - a pointer to where we will store the drivemap info
    IN  ULONG uStatus - input status to use in the "bit operations"
    IN  ULONG uOp - which operation

Return Value:

Notes:

   The flags passed here are used in one ioctl to either exclude or include
   connected or disconnected resources as appropriate.


--*/

{
    PRESOURCE pResource = NULL;
    BOOLEAN TableLockHeld = FALSE;
    PLIST_ENTRY ListEntry;

    RxDbgTrace(+1, Dbg, ("MRxSmbCscFindResourceFromRoot...%08lx\n",hRoot));
    DbgDoit(ASSERT(vfInShadowCrit));
    if ((hRoot==0) && (hShare==0)) {
        return NULL;
    }

    //we can't hold this....sigh
    LeaveShadowCrit();

    try {

        RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);
        TableLockHeld = TRUE;

        if (IsListEmpty( &RxNetNameTable.MemberQueue )) {
            try_return(pResource = NULL);
        }

        if (ShareStatus)
        {
            *ShareStatus = 0;
        }

        ListEntry = RxNetNameTable.MemberQueue.Flink;
        for (;ListEntry != &RxNetNameTable.MemberQueue;) {
            PVOID Container;
            PRX_PREFIX_ENTRY PrefixEntry;
            PMRX_NET_ROOT NetRoot;
            PMRX_V_NET_ROOT VNetRoot;
            PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
            PSMBCEDB_SERVER_ENTRY pServerEntry;
            PUSHORT ThisShareStatus;

            PrefixEntry = CONTAINING_RECORD( ListEntry,
                             RX_PREFIX_ENTRY,
                             MemberQLinks );
            ListEntry = ListEntry->Flink;
            ASSERT (NodeType(PrefixEntry) == RDBSS_NTC_PREFIX_ENTRY);
            Container = PrefixEntry->ContainingRecord;
            RxDbgTrace(0, Dbg,
            ("---> ListE PfxE Container Name  %08lx %08lx %08lx %wZ\n",
                ListEntry, PrefixEntry, Container, &PrefixEntry->Prefix));

            switch (NodeType(Container)) {
                case RDBSS_NTC_NETROOT :
                NetRoot = (PMRX_NET_ROOT)Container;

                RxDbgTrace(0, Dbg,
                ("NetRoot->pSrvCall=0x%x, NetRoot->Type=%d, NetRoot->Context=0x%x, NetRoot->pSrvCall->RxDeviceObject=0x%x\n",
                    NetRoot->pSrvCall, NetRoot->Type, NetRoot->Context, NetRoot->pSrvCall->RxDeviceObject));

                if ((NetRoot->pSrvCall == NULL) ||
                    (NetRoot->Type != NET_ROOT_DISK) ||
                    (NetRoot->Context == NULL) ||
                    (NetRoot->pSrvCall->RxDeviceObject != MRxSmbDeviceObject)) {
                    RxDbgTrace(0, Dbg,("Skipping \n"));
                    continue;
                }

                pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
                ThisShareStatus = &pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus;
                pServerEntry = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);

                RxDbgTrace(0, Dbg,
                ("pNetRootEntry->NetRoot.CscEnabled=%d, pNetRootEntry->NetRoot.sCscRootInfo.hRootDir=0x%x, pNetRootEntry->NetRoot.sCscRootInfo.hShare=0x%x\n",
                    pNetRootEntry->NetRoot.CscEnabled, pNetRootEntry->NetRoot.sCscRootInfo.hRootDir, pNetRootEntry->NetRoot.sCscRootInfo.hShare
                    ));

                if ((hRoot!=0xffffffff)||(hShare != 0xffffffff))
                {
                    if (pNetRootEntry->NetRoot.CscEnabled &&
                        ((pNetRootEntry->NetRoot.sCscRootInfo.hRootDir == hRoot) ||
                        (pNetRootEntry->NetRoot.sCscRootInfo.hShare == hShare) )) {

                        if (*ThisShareStatus & usLocalFlagsExcl) {

                            RxDbgTrace(0, Dbg,("Skipping *ThisShareStatus=\n", *ThisShareStatus));
                            continue;
                        }

                        if ((usLocalFlagsIncl==0xffff)
                            || (*ThisShareStatus & usLocalFlagsIncl)) {

                            switch (mBitOpShadowFlags(uOp)) {
                                case SHADOW_FLAGS_ASSIGN:
                                *ThisShareStatus = (USHORT)uStatus;
                                break;

                                case SHADOW_FLAGS_OR:
                                *ThisShareStatus |= (USHORT)uStatus;
                                break;

                                case SHADOW_FLAGS_AND:
                                *ThisShareStatus &= (USHORT)uStatus;
                                break;
                            }

                            *ShareStatus |= (*ThisShareStatus | SHARE_CONNECTED);

                            if(SmbCeIsServerInDisconnectedMode(pServerEntry))
                            {
                                *ShareStatus |= SHARE_DISCONNECTED_OP;

                            }

                            if (pServerEntry->Server.IsPinnedOffline == TRUE)
                                *ShareStatus |= SHARE_PINNED_OFFLINE;

                            RxDbgTrace(0, Dbg,("Count of srvopens=%d\n", pServerEntry->Server.NumberOfSrvOpens));

                            *DriveMap = 0; //not used anywhere

                            try_return (pResource = (PRESOURCE)pNetRootEntry);
                        }
                    }
                }
                else // hShare and hRoot are 0xffffffff, this means we are looping
                {
                    if (mBitOpShadowFlags(uOp) == SHADOW_FLAGS_AND)
                    {
                        if (pNetRootEntry->NetRoot.sCscRootInfo.hRootDir)
                        {
                            pNetRootEntry->NetRoot.sCscRootInfo.hRootDir = 0;
                            pNetRootEntry->NetRoot.sCscRootInfo.hShare = 0;
                        }
                    }
                }
            continue;
            case RDBSS_NTC_SRVCALL :
            continue;

            case RDBSS_NTC_V_NETROOT :
            VNetRoot = (PMRX_V_NET_ROOT)Container;

            // NTRAID#455236-1/31/2000-shishirp we should'nt be using this field here, it is strictly meant
            // for the wrapper
            if (((PV_NET_ROOT)Container)->Condition == Condition_Good)
            {
                if (VNetRoot->Context != NULL) {
                    pNetRootEntry = ((PSMBCE_V_NET_ROOT_CONTEXT)VNetRoot->Context)->pNetRootEntry;
                    RxDbgTrace(0, Dbg,("RDBSS_NTC_V_NETROOT: VNetRoot=%x, pNetRootEntry=%x\r\n",
                                VNetRoot, pNetRootEntry));

                    if ((hRoot!=0xffffffff)||(hShare != 0xffffffff))
                    {
                         if ((pNetRootEntry != NULL) &&
                             pNetRootEntry->NetRoot.CscEnabled &&
                             ((pNetRootEntry->NetRoot.sCscRootInfo.hRootDir == hRoot) ||
                             (pNetRootEntry->NetRoot.sCscRootInfo.hShare == hShare))) {

                         }
                    }
                    else
                    {
                        if (pNetRootEntry->NetRoot.sCscRootInfo.hRootDir)
                        {
                            pNetRootEntry->NetRoot.sCscRootInfo.hRootDir = 0;
                            pNetRootEntry->NetRoot.sCscRootInfo.hShare = 0;
                        }
                    }
                }
            }

            default:
            continue;
        }
    }

    try_return(pResource = NULL);

try_exit:NOTHING;

    } finally {

        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }

        EnterShadowCrit();
        if (pResource && ((hShare != 0xffffffff) || (hRoot != 0xffffffff)))
        {
            if (ShareStatus)
            {
                SetOfflineOpenStatusForShare(hShare, hRoot, ShareStatus);
            }
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscFindResourceFromRoot...%08lx\n",pResource));

    return(pResource);
}

#undef GetShadowInfo
#undef SetShadowInfo

// this is just a simple wrapper function except that we pick off the rootdir case.
// ...see the recordmanager code for args
int PUBLIC
MRxSmbCscWrappedGetShadowInfo(
    HSHADOW hDir,
    HSHADOW hNew,
    LPFIND32 lpFind32,
    ULONG far *lpuFlags,
    LPOTHERINFO lpOI)
{
    if (hDir != -1) {
        return(GetShadowInfo(hDir, hNew, lpFind32, lpuFlags, lpOI));
    }

    //otherwise....just make it up...........
    RtlZeroMemory(
    lpFind32,
    sizeof(*lpFind32));

    lpFind32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
    *lpuFlags = SHADOW_SPARSE;

    return(SRET_OK);
}


// this is just a simple wrapper function except that we pick off the rootdir case.
// ...see the recordmanager code for args
int PUBLIC
MRxSmbCscWrappedSetShadowInfo(
    HSHADOW hDir,
    HSHADOW hNew,
    LPFIND32 lpFind32,
    ULONG uFlags,
    ULONG uOp)
{
    if (hDir == -1) {
        return(SRET_OK);
    }

    return(SetShadowInfo(hDir, hNew, lpFind32, uFlags, uOp));
}

USHORT  *
MRxSmbCscFindLocalFlagsFromFdb(
    PFDB    pFdb
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    PMRX_SMB_FCB smbFcb;
    PUSHORT pShadowStatus = &(pFdb->usFlags);

    DbgDoit(ASSERT(vfInShadowCrit));

    smbFcb = CONTAINING_RECORD(pShadowStatus,MRX_SMB_FCB,ShadowStatus);
    return (&(smbFcb->LocalFlags));
}

NTSTATUS
MRxSmbCscSetSecurityPrologue (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine is called when a set security call is made. It tries
    to set the ACL on the CSC cached version of the file.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{

#if defined(REMOTE_BOOT)
    RxCaptureFcb;

    _WIN32_FIND_DATA Find32;
    PMRX_SMB_FCB smbFcb;
    NTSTATUS Status;

    //
    // First we need to set the security descriptor on the CSC
    // version of the file, if one exists.
    //
    smbFcb = MRxSmbGetFcbExtension(capFcb);

    EnterShadowCritRx(RxContext);

    Status = MRxSmbCscCreateShadowFromPath(
                GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),
                SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot),
                &Find32,
                NULL,
                CREATESHADOW_CONTROL_NOCREATE,
                &smbFcb->MinimalCscSmbFcb,
                RxContext,
                FALSE,
                NULL
                );   // not disconnected

    LeaveShadowCritRx(RxContext);

    if (Status == STATUS_SUCCESS) {

        Status = MRxSmbCscSetSecurityOnShadow(
             smbFcb->MinimalCscSmbFcb.hShadow,
             RxContext->SetSecurity.SecurityInformation,
             RxContext->SetSecurity.SecurityDescriptor);

        if (!NT_SUCCESS(Status)) {
            KdPrint(("MRxSmbCscSetSecurityPrologue: Could not set security (%lx) for %wZ: %lx\n", RxContext,
                GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext), Status));
        }

    } else {

        //
        //

        Status = STATUS_SUCCESS;

    }

    return Status;
#else
    return STATUS_SUCCESS;
#endif

}

VOID
MRxSmbCscSetSecurityEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a set security operation for CSC.

   If the set failed, it tries to restore the old ACL on the file.

Arguments:

    RxContext - the RDBSS context

    Status - the overall status of the open

Return Value:

Notes:


--*/
{
    return;
}

// Table off which the parameter validation is driven
// there is some redundancy in this table, specifically, we could have only the flags
// and get rid of the other two fields.

CSC_IOCTL_ENTRY rgCscIoctlTable[] =
{
    {IOCTL_SHADOW_GETVERSION,       0,  0},
    {IOCTL_SHADOW_REGISTER_AGENT,   FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_UNREGISTER_AGENT, 0,  0},
    {IOCTL_SHADOW_GET_UNC_PATH,     FLAG_CSC_IOCTL_COPYPARAMS,  sizeof(COPYPARAMS)},
    {IOCTL_SHADOW_BEGIN_PQ_ENUM,    FLAG_CSC_IOCTL_PQPARAMS,    sizeof(PQPARAMS)},
    {IOCTL_SHADOW_END_PQ_ENUM,      FLAG_CSC_IOCTL_PQPARAMS,    sizeof(PQPARAMS)},
    {IOCTL_SHADOW_NEXT_PRI_SHADOW,  FLAG_CSC_IOCTL_PQPARAMS,    sizeof(PQPARAMS)},
    {IOCTL_SHADOW_PREV_PRI_SHADOW,  FLAG_CSC_IOCTL_PQPARAMS,    sizeof(PQPARAMS)},
    {IOCTL_SHADOW_GET_SHADOW_INFO,  FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_SET_SHADOW_INFO,  FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_CHK_UPDT_STATUS,  FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_DO_SHADOW_MAINTENANCE,   FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_COPYCHUNK,        FLAG_CSC_IOCTL_COPYCHUNKCONTEXT,    sizeof(COPYCHUNKCONTEXT)},
    {IOCTL_SHADOW_BEGIN_REINT,      FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_END_REINT,        FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_CREATE,           FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_DELETE,           FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GET_SHARE_STATUS,       FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SET_SHARE_STATUS,       FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_ADDUSE,                  0,  0},  // not applicable on NT
    {IOCTL_DELUSE,                  0,  0},  // not applicable on NT
    {IOCTL_GETUSE,                  0,  0},  // not applicable on NT
    {IOCTL_SWITCHES,                FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GETSHADOW,               FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GETGLOBALSTATUS,         FLAG_CSC_IOCTL_GLOBALSTATUS,sizeof(GLOBALSTATUS)},
    {IOCTL_FINDOPEN_SHADOW,         FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDNEXT_SHADOW,         FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDCLOSE_SHADOW,        FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GETPRIORITY_SHADOW,      FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SETPRIORITY_SHADOW,      FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_ADD_HINT,                FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_DELETE_HINT,             FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDOPEN_HINT,           FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDNEXT_HINT,           FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDCLOSE_HINT,          FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GET_IH_PRIORITY,         FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GETALIAS_HSHADOW,        FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {_SHADOW_IOCTL_CODE(37), 0, 0}, // hole in the ioctl range
    {_SHADOW_IOCTL_CODE(38), 0, 0}, // hole in the ioctl range
    {_SHADOW_IOCTL_CODE(39), 0, 0}, // hole in the ioctl range
    {IOCTL_OPENFORCOPYCHUNK,                FLAG_CSC_IOCTL_COPYCHUNKCONTEXT,    sizeof(COPYCHUNKCONTEXT)},
    {IOCTL_CLOSEFORCOPYCHUNK,               FLAG_CSC_IOCTL_COPYCHUNKCONTEXT,    sizeof(COPYCHUNKCONTEXT)},
    {IOCTL_IS_SERVER_OFFLINE,               FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_TRANSITION_SERVER_TO_ONLINE,     FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_TRANSITION_SERVER_TO_OFFLINE,    FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_TAKE_SERVER_OFFLINE,             FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_NAME_OF_SERVER_GOING_OFFLINE,    FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHAREID_TO_SHARENAME,            FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)}
};

NTSTATUS
CaptureInputBufferIfNecessaryAndProbe(
    IN  DWORD               IoControlCode,
    IN  PRX_CONTEXT         pRxContext,
    IN  PBYTE               InputBuffer,
    IN  LPCAPTURE_BUFFERS   lpCapBuff,
    OUT PBYTE               *ppAuxBuf,
    OUT PBYTE               *ppOrgBuf,
    OUT PBYTE               *ppReturnBuffer
    )
/*++

Routine Description:

    This routine does the capturing if necessary and probing of the buffers.
    Note that because the csc ioctls are always called with METHOD_NEITHER
    buffering mode, we always execute the code below.

Arguments:

    IoControlCode   Ioctl code

    pRxContext      context which has all the info of the original ioctl call for IO subsystem

    InputBuffer     Input Buffer

    lpCapBuff       capture buffer passed in by the caller. If this ioctl needs capturing
                    then this buffer is used to capture the input buffer.
                    We use this in case of SHADOWINFO and COPYPARAMS structures being passed in
                    as only in these two case there are embedded pointers

    ppAuxBuf        if we needed to capture another part of the buffer (lpFind32 or lpBuffer),
                    this routine will allocate a buffer which will be passed back here, and
                    must be freed by the caller.

    ppReturnBuffer  either the input buffer itself, or lpCapBuff (if inputbuffer is captured)

Return Value:

Notes:


--*/
{
    int         indx;
    BOOL        fRet = FALSE;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    KPROCESSOR_MODE requestorMode;

    indx = ((IoControlCode >> 2) & 0xfff) - SHADOW_IOCTL_ENUM_BASE;

    if((indx >=0 ) && (indx < sizeof(rgCscIoctlTable)/sizeof(CSC_IOCTL_ENTRY)))
    {

        *ppReturnBuffer = InputBuffer;

        if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_COPYCHUNKCONTEXT)
        {
            return(ValidateCopyChunkContext(pRxContext, IoControlCode));
        }

        if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_BUFFERTYPE_MASK)
        {
            try
            {
                ProbeForRead(InputBuffer,
                             rgCscIoctlTable[indx].dwLength,
                             1);

                ProbeForWrite(InputBuffer,
                             rgCscIoctlTable[indx].dwLength,
                             1);

                if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_COPYPARAMS)
                {
                    lpCapBuff->sCP = *(LPCOPYPARAMS)InputBuffer;
                    *ppReturnBuffer = (PBYTE)&(lpCapBuff->sCP);
                    Status = ValidateCopyParams(&(lpCapBuff->sCP));
                }
                else if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_SHADOWINFO)
                {
                    lpCapBuff->sSI = *(LPSHADOWINFO)InputBuffer;
                    *ppReturnBuffer = (PBYTE)&(lpCapBuff->sSI);
                    Status = ValidateShadowInfo(
                                IoControlCode,
                                &(lpCapBuff->sSI),
                                ppAuxBuf,
                                ppOrgBuf);
                }
                else
                {
                    Status = STATUS_SUCCESS;
                }

            }
            except(EXCEPTION_EXECUTE_HANDLER )
            {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}



NTSTATUS
ValidateCopyParams(
    LPCOPYPARAMS    lpCP
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    if((CscProbeForReadWrite((PBYTE)lpCP->lpLocalPath, MAX_PATH*sizeof(USHORT)) == STATUS_SUCCESS)&&
        (CscProbeForReadWrite((PBYTE)lpCP->lpRemotePath, MAX_PATH*sizeof(USHORT)) == STATUS_SUCCESS)&&
        (CscProbeForReadWrite((PBYTE)lpCP->lpSharePath, MAX_SERVER_SHARE_NAME_FOR_CSC*2) == STATUS_SUCCESS))
    {
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
ValidateShadowInfo(
    DWORD           IoControlCode,
    LPSHADOWINFO    lpSI,
    LPBYTE          *ppAuxBuf,
    LPBYTE          *ppOrgBuf
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    NTSTATUS Status;

    // by the time we get here, the SHADOWINFO strucuture has already been
    // probed

    // IOCTL_DO_SHADOW_MAINTENANCE has multiple suboperations, so we
    // deal them seperately.

    if (IoControlCode == IOCTL_DO_SHADOW_MAINTENANCE)
    {
        // DbgPrint("SHADOW_OP:0x%x\n", lpSI->uOp);
        switch(lpSI->uOp)
        {
            case SHADOW_REDUCE_REFPRI:              //  2
//          case SHADOW_RECALC_IHPRI:               //  5
            case SHADOW_PER_THREAD_DISABLE:         //  7
            case SHADOW_PER_THREAD_ENABLE:          //  8
            case SHADOW_ADDHINT_FROM_INODE:         //  10
            case SHADOW_DELETEHINT_FROM_INODE:      //  11
            case SHADOW_BEGIN_INODE_TRANSACTION:    //  13
            case SHADOW_END_INODE_TRANSACTION:      //  14
            case SHADOW_TRANSITION_SERVER_TO_OFFLINE:   // 19
            case SHADOW_CHANGE_HANDLE_CACHING_STATE:    // 20
            case SHADOW_RECREATE:                       // 21
            case SHADOW_SPARSE_STALE_DETECTION_COUNTER: // 23
            case SHADOW_DISABLE_CSC_FOR_USER:           // 25
            case SHADOW_SET_DATABASE_STATUS:            // 26
            case SHADOW_MANUAL_FILE_DETECTION_COUNTER:  // 28
                return STATUS_SUCCESS;

            case SHADOW_FIND_CREATE_PRINCIPAL_ID:   //  15
            case SHADOW_GET_SECURITY_INFO:          //  16
            case SHADOW_SET_EXCLUSION_LIST:         //  17
            case SHADOW_SET_BW_CONSERVE_LIST:       //  18
            case SHADOW_GET_SPACE_STATS:            //  5
                if (!lpSI->lpBuffer || !lpSI->cbBufferSize)
                {
                    return STATUS_INVALID_PARAMETER;
                }
                else
                {
                    Status =  CscProbeAndCaptureForReadWrite(
                                lpSI->lpBuffer,
                                lpSI->cbBufferSize,
                                ppAuxBuf);
                    if (Status == STATUS_SUCCESS) {
                        *ppOrgBuf =(PBYTE) lpSI->lpBuffer;
                        lpSI->lpBuffer = (PBYTE) *ppAuxBuf;
                    }
                    return Status;
                }

            case SHADOW_REINIT_DATABASE:            //  9
            case SHADOW_MAKE_SPACE:                 //  1
            case SHADOW_ADD_SPACE:                  //  3
            case SHADOW_FREE_SPACE:                 //  4
            case SHADOW_SET_MAX_SPACE:              //  6
            case SHADOW_COPY_INODE_FILE:            //  12
            case SHADOW_RENAME:                     //  22
            case SHADOW_ENABLE_CSC_FOR_USER:        //  24
            case SHADOW_PURGE_UNPINNED_FILES:       //  27
                Status = CscProbeAndCaptureForReadWrite(
                            (PBYTE)(lpSI->lpFind32),
                            sizeof(WIN32_FIND_DATA),
                            ppAuxBuf);
                if (Status == STATUS_SUCCESS) {
                    *ppOrgBuf =(PBYTE) lpSI->lpFind32;
                    lpSI->lpFind32 = (LPFIND32) *ppAuxBuf;
                }
                return Status;

            default:
                return STATUS_INVALID_PARAMETER;

        }
    } else if (
        IoControlCode == IOCTL_GET_SHARE_STATUS
            ||
        IoControlCode == IOCTL_SET_SHARE_STATUS
    ) {
        Status =  CscProbeAndCaptureForReadWrite(
                    (PBYTE)(lpSI->lpFind32),
                    sizeof(SHAREINFOW),
                    ppAuxBuf);
        if (Status == STATUS_SUCCESS) {
            *ppOrgBuf =(PBYTE) lpSI->lpFind32;
            lpSI->lpFind32 = (LPFIND32) *ppAuxBuf;
        }
        return Status;
    } else if (
        IoControlCode == IOCTL_IS_SERVER_OFFLINE
            ||
        IoControlCode == IOCTL_TAKE_SERVER_OFFLINE
            ||
        IoControlCode == IOCTL_NAME_OF_SERVER_GOING_OFFLINE
            ||
        IoControlCode == IOCTL_SHAREID_TO_SHARENAME
    ) {
        Status =  CscProbeAndCaptureForReadWrite(
                    lpSI->lpBuffer,
                    lpSI->cbBufferSize,
                    ppAuxBuf);
        if (Status == STATUS_SUCCESS) {
            *ppOrgBuf =(PBYTE) lpSI->lpBuffer;
            lpSI->lpBuffer = (PBYTE) *ppAuxBuf;
        }
        return Status;
    }

    // for all other ioctls which take SHADOWINFO structure, there may be an embedded
    // find32 structure, which must be probed

    ASSERT(IoControlCode != IOCTL_DO_SHADOW_MAINTENANCE);
    Status = CscProbeAndCaptureForReadWrite(
                (PBYTE)(lpSI->lpFind32),
                sizeof(WIN32_FIND_DATA),
                ppAuxBuf);
    if (Status == STATUS_SUCCESS) {
        *ppOrgBuf =(PBYTE) lpSI->lpFind32;
        lpSI->lpFind32 = (LPFIND32) *ppAuxBuf;
    }
    return Status;
}

NTSTATUS
ValidateCopyChunkContext(
    PRX_CONTEXT RxContext,
    DWORD       IoControlCode
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    // on open, validate the name
    if (IoControlCode == IOCTL_OPENFORCOPYCHUNK)
    {
        PBYTE   FileName = (PBYTE)LowIoContext->ParamsFor.IoCtl.pInputBuffer;
        ULONG   FileNameLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength - 1;

        // let us varify that the name passed in is within our limits
        if ((FileNameLength > ((MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC)*sizeof(USHORT)))||
            CscProbeForReadWrite(FileName, FileNameLength) != STATUS_SUCCESS)
        {
            return STATUS_INVALID_PARAMETER;
        }

        return STATUS_SUCCESS;
    }
    else
    {
        // on copychunk or close we need to validate the chunk structure.
        // we don't need to validate the handle in it because the
        // object manager does that in MrxSmbCscCopyChunk and MrxSmbCscCloseForCopyChunk
        // routines

        COPYCHUNKCONTEXT *CopyChunkContext =
                     (COPYCHUNKCONTEXT *)(LowIoContext->ParamsFor.IoCtl.pOutputBuffer);

        if (!CopyChunkContext)
        {
            return STATUS_INVALID_PARAMETER;
        }


        // for all copychunk calls, validate the copychunkcontext buffer
        return CscProbeForReadWrite((PBYTE)CopyChunkContext, sizeof(COPYCHUNKCONTEXT));
    }

}

NTSTATUS
CscProbeForReadWrite(
    PBYTE   pBuffer,
    DWORD   dwSize
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    try
    {
        if (pBuffer != NULL) {
            ProbeForRead(
                pBuffer,
                dwSize,
                1);

            ProbeForWrite(
                pBuffer,
                dwSize,
                1);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status=STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
CscProbeAndCaptureForReadWrite(
    PBYTE   pBuffer,
    DWORD   dwSize,
    PBYTE   *ppAuxBuf
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PBYTE pBuf = NULL;
    
    try {
        if (pBuffer != NULL && dwSize > 0) {
            ProbeForRead(pBuffer, dwSize, 1);
            ProbeForWrite(pBuffer, dwSize, 1);
            pBuf = RxAllocatePoolWithTag(PagedPool, dwSize, 'xXRM');
            if (pBuf != NULL) {
                RtlCopyMemory(pBuf, pBuffer, dwSize);
                *ppAuxBuf = pBuf;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (Status != STATUS_SUCCESS && pBuf != NULL) {
        RxFreePool(pBuf);
    }

    return Status;
}

VOID
CopyBackIfNecessary(
    IN     DWORD   IoControlCode,
    IN OUT PBYTE   InputBuffer,
    IN     LPCAPTURE_BUFFERS lpCapBuff,
    IN     PBYTE   pAuxBuf,
    IN     PBYTE   pOrgBuf,
    BOOL    fSuccess
    )
/*++

Routine Description:

    This routine copies back the capture buffer to the inout buffer, in ioctls which
    expect output.

Arguments:

Return Value:

Notes:


--*/
{
    int         indx;
    BOOL        fRet = FALSE;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    LPSHADOWINFO lpSI = NULL;

    indx = ((IoControlCode >> 2) & 0xfff) - SHADOW_IOCTL_ENUM_BASE;

    ASSERT((indx >=0 ) && (indx < sizeof(rgCscIoctlTable)/sizeof(CSC_IOCTL_ENTRY)));

    if (fSuccess)
    {

        if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_SHADOWINFO) {
            *(LPSHADOWINFO)InputBuffer = lpCapBuff->sSI;
            lpSI = &lpCapBuff->sSI;
            if (pAuxBuf != NULL && pOrgBuf != NULL) {
                //
                // Some ioctls have embedded pointers.  We have to copy the 2nd buffer
                // back, too, and set the embedded pointer back to that buffer.
                //
                if (IoControlCode == IOCTL_DO_SHADOW_MAINTENANCE) {
                    // DbgPrint("SHADOW_OP(2):0x%x\n", lpSI->uOp);
                    switch(lpSI->uOp) {
                        case SHADOW_FIND_CREATE_PRINCIPAL_ID:   // 15
                        case SHADOW_GET_SECURITY_INFO:          // 16
                        case SHADOW_SET_EXCLUSION_LIST:         // 17
                        case SHADOW_SET_BW_CONSERVE_LIST:       // 18
                        case SHADOW_GET_SPACE_STATS:            //  5
                            RtlMoveMemory(pOrgBuf, pAuxBuf, lpSI->cbBufferSize);
                            lpSI->lpBuffer = (PBYTE) pOrgBuf;
                            break;
                        case SHADOW_REINIT_DATABASE:            //  9
                        case SHADOW_MAKE_SPACE:                 //  1
                        case SHADOW_ADD_SPACE:                  //  3
                        case SHADOW_FREE_SPACE:                 //  4
                        case SHADOW_SET_MAX_SPACE:              //  6
                        case SHADOW_COPY_INODE_FILE:            //  12
                        case SHADOW_RENAME:                     //  22
                        case SHADOW_ENABLE_CSC_FOR_USER:        //  24
                        case SHADOW_PURGE_UNPINNED_FILES:       //  27
                            RtlMoveMemory(pOrgBuf, pAuxBuf, sizeof(WIN32_FIND_DATA));
                            lpSI->lpFind32 = (LPFIND32) pOrgBuf;
                            break;
                    }
                } else if (
                       IoControlCode == IOCTL_GET_SHARE_STATUS
                            ||
                       IoControlCode == IOCTL_SET_SHARE_STATUS
                ) {
                    RtlMoveMemory(pOrgBuf, pAuxBuf, sizeof(SHAREINFOW));
                    lpSI->lpFind32 = (LPFIND32) pOrgBuf;
                } else if (
                    IoControlCode == IOCTL_IS_SERVER_OFFLINE
                        ||
                    IoControlCode == IOCTL_TAKE_SERVER_OFFLINE
                        ||
                    IoControlCode == IOCTL_NAME_OF_SERVER_GOING_OFFLINE
                        ||
                    IoControlCode == IOCTL_SHAREID_TO_SHARENAME
                ) {
                    RtlMoveMemory(pOrgBuf, pAuxBuf, lpSI->cbBufferSize);
                    lpSI->lpBuffer = (PBYTE) pOrgBuf;
                } else {
                    RtlMoveMemory(pOrgBuf, pAuxBuf, sizeof(WIN32_FIND_DATA));
                    lpSI->lpFind32 = (LPFIND32) pOrgBuf;
                }
            }
        }
    } else {
        if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_SHADOWINFO) {
            ((LPSHADOWINFO)InputBuffer)->dwError  = lpCapBuff->sSI.dwError;
        } else if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_COPYPARAMS) {
            ((LPCOPYPARAMS)InputBuffer)->dwError = lpCapBuff->sCP.dwError;
        }
    }
}

VOID ValidateSmbFcbList(
    VOID)
/*++

Routine Description:

    This routine validates the smbfcb reverse lookup list

Arguments:

Return Value:

Notes:

    This validation code must be called from within the shadow critical section

--*/

{
    PLIST_ENTRY pListEntry;
    DWORD   cntFlink, cntBlink;

    DbgDoit(ASSERT(vfInShadowCrit));

    cntFlink = cntBlink = 0;

    // check forward list validity

    pListEntry = xCscFcbsList.Flink;

    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);


        try
        {
            if((NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_FILE) &&
                (NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)&&
                (NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_UNKNOWN)
                )
            {
                DbgPrint("ValidateSmbFcbList:Invalid nodetype %x fcb=%x smbfcb=%x\n",
                            NodeType(smbFcb->ContainingFcb),smbFcb->ContainingFcb, smbFcb);
//                DbgBreakPoint();
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            DbgPrint("ValidateSmbFcbList:Invalid smbFcb %x \n", smbFcb);
            DbgBreakPoint();
        }


        ++cntFlink;
        pListEntry = pListEntry->Flink;
    }

    // check backward list validity

    pListEntry = xCscFcbsList.Blink;

    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);


        try
        {
            if((NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_FILE) &&
                (NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)&&
                (NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_UNKNOWN))
            {
                DbgPrint("ValidateSmbFcbList:Invalid nodetype %x fcb=%x smbfcb=%x\n",
                            NodeType(smbFcb->ContainingFcb),smbFcb->ContainingFcb, smbFcb);
//                DbgBreakPoint();
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            DbgPrint("ValidateSmbFcbList:Invalid smbFcb %x \n", smbFcb);
//            DbgBreakPoint();
        }

        ++cntBlink;
        pListEntry = pListEntry->Blink;
    }

    // both counts should be the same
    ASSERT(cntFlink == cntBlink);
}

BOOL SetOfflineOpenStatusForShare(
    CSC_SHARE_HANDLE  hShare,
    CSC_SHADOW_HANDLE   hRootDir,
    OUT PULONG pShareStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/

{
    PLIST_ENTRY pListEntry;

    DbgDoit(ASSERT(vfInShadowCrit));

    if ((hRootDir==0) && (hShare==0)) {
        return 0;
    }

    ASSERT((hShare!=0xffffffff) || (hRootDir!=0xffffffff));

    pListEntry = xCscFcbsList.Flink;

    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);

        if (((smbFcb->sCscRootInfo.hShare == hShare)
            ||(smbFcb->sCscRootInfo.hRootDir == hRootDir)))

        {
            if(smbFcb->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                *pShareStatus |= SHARE_FINDS_IN_PROGRESS;
            }
            else
            {
                *pShareStatus |= SHARE_FILES_OPEN;
            }

        }
        pListEntry = pListEntry->Flink;
    }

    return FALSE;
}

VOID
EnterShadowCritRx(
    PRX_CONTEXT     pRxContext
    )
{
    EnterShadowCrit();
    if (pRxContext)
    {
        ASSERT(!pRxContext->dwShadowCritOwner);
        pRxContext->dwShadowCritOwner = GetCurThreadHandle();
    }
}

VOID
LeaveShadowCritRx(
    PRX_CONTEXT     pRxContext
    )
{

    if (pRxContext)
    {
        ASSERT(pRxContext->dwShadowCritOwner);
        pRxContext->dwShadowCritOwner = 0;
    }
    LeaveShadowCrit();
}

NTSTATUS
CscInitializeServerEntryDfsRoot(
    PRX_CONTEXT     pRxContext,
    PSMBCEDB_SERVER_ENTRY   pServerEntry
    )
{
    PDFS_NAME_CONTEXT pDfsNameContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ServerPath;

    if (pRxContext &&
        pRxContext->CurrentIrpSp &&
        (pRxContext->CurrentIrpSp->MajorFunction == IRP_MJ_CREATE)) {
        pDfsNameContext = CscIsValidDfsNameContext(pRxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext){
            Status = CscDfsParseDfsPath(
                         &pDfsNameContext->UNCFileName,
                         &ServerPath,
                         NULL,
                         NULL);

            if (Status == STATUS_SUCCESS) {
                if (pServerEntry->DfsRootName.Buffer == NULL) {
                    pServerEntry->DfsRootName.Buffer = RxAllocatePoolWithTag(
                                                       NonPagedPool,
                                                       ServerPath.Length,
                                                       RX_MISC_POOLTAG);

                    if (pServerEntry->DfsRootName.Buffer == NULL)
                    {
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    RtlCopyMemory(pServerEntry->DfsRootName.Buffer,
                                  ServerPath.Buffer,
                                  ServerPath.Length);

                    pServerEntry->DfsRootName.MaximumLength = ServerPath.Length;
                    pServerEntry->DfsRootName.Length = ServerPath.Length;

//                    DbgPrint("Initialized %x with DfsRoot %wZ\n", pServerEntry, &pServerEntry->DfsRootName);
                }
            }
        }
    }

    return Status;
}


NTSTATUS
MRxSmbCscLocalFileOpen(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine performs the conserving bandwidth for remote boot client. The bandwidth
   is saved by the way of reducing the files opened on the boot server, instead the local
   copy of the file on CSC is used.

   There is a set the rules that the file has to meet in order to be opened locally.

   * file tried to open on VDO share
   * a local copy of the file has been created on CSC, which is not sparse
   * the write or name space operations have to go through the server except
   * Only execute operations are allowed through

   The routine checks the file whether it meets those rules. The actual open happens on
   MRxSmbCscCreateEpilogue.

Arguments:

    RxContext - the RDBSS context


Return Value:

    Status -  we return the local open status

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    NTSTATUS LocalStatus;

    RxCaptureFcb;

    PMRX_SMB_FCB      smbFcb;
    PMRX_SRV_OPEN     SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PMRX_NET_ROOT             NetRoot;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    ULONG       CreateDisposition = RxContext->Create.NtCreateParameters.Disposition;
    ULONG       CreateOptions = RxContext->Create.NtCreateParameters.CreateOptions;
    ACCESS_MASK DesiredAccess = RxContext->Create.NtCreateParameters.DesiredAccess;

    BOOLEAN CreatedShadow = FALSE;
    ULONG uShadowStatus;
    _WIN32_FIND_DATA Find32, CscFind32;
    PUNICODE_STRING PathName;
    int iRet;
    int EarlyOut = 0;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER DeadLine;
    BOOL    fLocalOpens = FALSE;

    NetRoot = capFcb->pNetRoot;
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

    SrvOpen    = RxContext->pRelevantSrvOpen;
    smbFcb     = MRxSmbGetFcbExtension(capFcb);
    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PathName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    pServerEntry  = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);

    // don't do local open if the share is either in disconnected state
    // or the share is not a VDO share

    if (SmbCeIsServerInDisconnectedMode(pServerEntry) ||
        (pNetRootEntry->NetRoot.CscFlags != SMB_CSC_CACHE_VDO))
    {
        RxDbgTrace( 0, Dbg, ("Server disconnected or not VDO share, CscFlags=%x\n", pNetRootEntry->NetRoot.CscFlags));
        return Status;
    }

    EnterShadowCritRx(RxContext);


    LocalStatus = MRxSmbCscObtainShadowHandles(
                  RxContext,
                  &Status,
                  &CscFind32,
                  &CreatedShadow,
                  CREATESHADOW_CONTROL_NOCREATE,
                  FALSE);

    if (LocalStatus != STATUS_SUCCESS) {
        EarlyOut = 1;
        goto FINALLY;
    }

    if ((smbFcb->hShadow == 0) ||
         (smbFcb->ShadowStatus == SHADOW_SPARSE) ||
         (smbFcb->ShadowStatus & SHADOW_MODFLAGS) ||
         (CscFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        // if no local copy or file is sparse, or modified, or it is a directory,
        // file cannot open locally
        EarlyOut = 2;
        goto FINALLY;
    }

    LeaveShadowCritRx(RxContext);
    fLocalOpens = CSCCheckLocalOpens(RxContext);
    EnterShadowCritRx(RxContext);

    if (DesiredAccess &
         (  GENERIC_WRITE |
            FILE_WRITE_EA |
            FILE_ADD_FILE |
            FILE_WRITE_DATA |
            FILE_APPEND_DATA |
            FILE_DELETE_CHILD |
            FILE_ADD_SUBDIRECTORY)) { // FILE_WRITE_ATTRIBUTE is OK
        if (fLocalOpens)
        {
            HookKdPrint(BADERRORS, ("VDO not allowed for this desired access %x %x\n", smbFcb->hShadow, DesiredAccess));
            Status = STATUS_ACCESS_DENIED;
        }

        EarlyOut = 3;
        goto FINALLY;
    }

    if (CreateOptions & FILE_DELETE_ON_CLOSE)
    {
        if (fLocalOpens)
        {
            HookKdPrint(BADERRORS, ("DeletOnClose not allowed %x %x\n", smbFcb->hShadow, DesiredAccess));
            Status = STATUS_ACCESS_DENIED;
            EarlyOut = 30;
            goto FINALLY;
        }
    }

    if (CreateDisposition != FILE_OPEN)
    {
        // name space operations should go to the server
        if (fLocalOpens)
        {
            Status = STATUS_SHARING_VIOLATION;
        }

        EarlyOut = 4;
        goto FINALLY;
    }

    if (!(DesiredAccess & FILE_EXECUTE))
    {
        // DbgPrint("FILE_EXECUTE not set (0x%x) on %wZ\n", DesiredAccess, PathName);
        EarlyOut = 5;
        goto FINALLY;
    }


#if 0
    KeQuerySystemTime( &CurrentTime );

    // system time is based on 100ns
    DeadLine.QuadPart = smbFcb->LastSyncTime.QuadPart + (LONGLONG) (CscSyncInterval * 10 * 1000 * 1000);

    if (CurrentTime.QuadPart < DeadLine.QuadPart) {
        Status = STATUS_SUCCESS;
        goto FINALLY;
    }
#endif

    // do a check on the server only when there is no outstanding local open
    if (!fLocalOpens)
    {
        LeaveShadowCritRx(RxContext);
        LocalStatus = MRxSmbGetFileInfoFromServer(RxContext,PathName,&Find32,SrvOpen,NULL);
        EnterShadowCritRx(RxContext);

        if (LocalStatus != STATUS_SUCCESS) {
            // if cannot get file information from the server, file cannot open locally
            EarlyOut = 6;
            goto FINALLY;
        }

        iRet = RefreshShadow(
                  smbFcb->hParentDir,
                  smbFcb->hShadow,
                  &Find32,
                  &uShadowStatus
                  );

        if (iRet < SRET_OK) {
            // if refresh shadow fails, file cannot open locally
            EarlyOut = 7;
            goto FINALLY;
        } else {
            SetShadowInfo(smbFcb->hParentDir,
                          smbFcb->hShadow,
                          NULL,
                          0,
                          SHADOW_FLAGS_OR|SHADOW_FLAGS_SET_REFRESH_TIME);
        }

        if (uShadowStatus == SHADOW_SPARSE) {
            // if the file is sparse, it cannot open locally
            EarlyOut = 8;
            goto FINALLY;
        } else {
            // no more rule, file can open locally
            Status = STATUS_SUCCESS;
        }
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

FINALLY:

    if (Status == STATUS_SUCCESS) {
        SetFlag(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_LOCAL_OPEN);
        smbFcb->cntLocalOpens++;
        //RxDbgTrace(0, Dbg, ("Local :   %wZ\n",PathName));
        RxLog(("Local Open %lx %lx %lx\n",smbFcb->hParentDir, smbFcb->hShadow, capFcb));

        RxDbgTrace( 0, Dbg,
            ("MRxSmbCscLocalFileOpen hdir/hshadow= %08lx %08lx\n",
            smbFcb->hParentDir, smbFcb->hShadow));
    } else {
        RxDbgTrace(0, Dbg, ("Remote: %d %wZ\n",EarlyOut,PathName));
    }

    LeaveShadowCritRx(RxContext);

    return Status;
}





BOOL
CSCCheckLocalOpens(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   The routine checks whether there is any fcb in the fcb list which has our inode.
   The reason why this has to be done is because of rename.
   Thus if a file cat.exe is opened the smbFcb->hShadow field had the inode.
   Then if a rename to dog.exe is done while the file is open, the smbfcb->hShadow field is
   set to 0 and smbFcb->hShadowRename is set to the inode value.
   After that when a delete comes through, RDBSS cannot check the sharing violation because
   it doesn'nt change the name in the FCB to dog.exe. So it creates a new FCB for dog.exe.
   Yet we do have to give sharing violation in this scenario. We accomplish this
   by detecting just such a scenario in the routine below.

   It essentially goes though the FCB reverselookup list and if it finds an FCB which
   has the same hShadow or hShadowRenamed as this one, and it's cntLocalOpens is
   non-zero, then it gives sharing violation.

Arguments:

    RxContext - the RDBSS context

    Status    - miniredir status

Return Value:

    Status -  Passed in status, or STATUS_SHARING_VILOATION

Notes:


--*/
{
    BOOL    fRet = FALSE;
    RxCaptureFcb;
    PMRX_SMB_FCB            smbFcb, pSmbFcbT;
    PMRX_NET_ROOT           NetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    CSC_SHADOW_HANDLE       hShadow;
    PLIST_ENTRY             pListEntry;


    NetRoot = capFcb->pNetRoot;
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    smbFcb     = MRxSmbGetFcbExtension(capFcb);

    hShadow = (smbFcb->hShadow)?smbFcb->hShadow:smbFcb->hShadowRenamed;


    if (!hShadow || (pNetRootEntry->NetRoot.CscFlags != SMB_CSC_CACHE_VDO))
    {
        return FALSE;
    }

    EnterShadowCritRx(RxContext);

    pListEntry = xCscFcbsList.Flink;

    while (pListEntry != &xCscFcbsList) {

        pSmbFcbT = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);
        if ((pSmbFcbT->hShadow==smbFcb->hShadow) ||
            (pSmbFcbT->hShadowRenamed==smbFcb->hShadow))
        {
            if (pSmbFcbT->cntLocalOpens)
            {
                RxLog(("smbfcb=%x has local opens for hShadow=%x\n", pSmbFcbT, smbFcb->hShadow));
                fRet = TRUE;
                break;

            }
        }

        pListEntry = pListEntry->Flink;
    }

    LeaveShadowCritRx(RxContext);
    return fRet;
}


BOOL
IsCSCBusy(
    VOID
    )
/*++

Routine Description:

    This routine checks whether any files are being shadowed by CSC

Arguments:

    None

Return Value:

    TRUE if any files are being shadowed, FALSE otherwise

Notes:

    Used by the diableCSC ioctl

--*/
{
    DbgDoit(ASSERT(vfInShadowCrit));
    return (xCscFcbsList.Flink != &xCscFcbsList);
}

VOID
ClearCSCStateOnRedirStructures(
    VOID
    )
/*++

Routine Description:

    This routine clears the csc state on netroots

Arguments:

    None

Return Value:

    None

Notes:

    Used by the diableCSC ioctl

--*/
{

    DbgDoit(ASSERT(vfInShadowCrit));
    ASSERT(!IsCSCBusy());
    ClearAllResourcesOfShadowingState();

    DbgDoit(ASSERT(vfInShadowCrit));
    CscTransitionServerToOnline(0); // transition all servers
}

BOOL
CscDfsShareIsInReint(
    IN  PRX_CONTEXT         RxContext
    )
/*++

Routine Description:


Arguments:


Return Value:


Notes:


--*/
{
    PDFS_NAME_CONTEXT pDfsNameContext = NULL;
    UNICODE_STRING    SharePath;
    NTSTATUS    LocalStatus;
    CSC_SHARE_HANDLE    CscShareHandle;
    ULONG               ulRootHintFlags;

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {

        pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext)
        {
            LocalStatus = CscDfsParseDfsPath(
                       &pDfsNameContext->UNCFileName,
                       NULL,
                       &SharePath,
                       NULL);

            if (LocalStatus == STATUS_SUCCESS)
            {
                GetHShareFromUNCString(
                    SharePath.Buffer,
                    SharePath.Length,
                    1,
                    TRUE,
                    &CscShareHandle,
                    &ulRootHintFlags);


                if (CscShareHandle && (CscShareHandle == hShareReint))
                {
                    return TRUE;
                }
            }

        }
    }
    return FALSE;
}

LONG CSCBeginReint(
    IN OUT  PRX_CONTEXT RxContext,
    IN OUT  LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

    begins merge. This routine needs to be in pagelocked memory because
    it takes cancel spinlock.

    We pend the Irp that issued the beginreint ioctl and set our cancel routine in it.
    If the thread doing the merge dies for some reason, the Ps code calls our cancel routine
    to cacncel this irp, this is when we cleanup the merge state.

Arguments:

    RxContext

    lpSI        Buffer passed down by the caller

Return Value:

    None.

--*/
{
    LONG   ShadowIRet;
    KIRQL   CancelIrql;
    BOOL    fCancelled = FALSE;


    ShadowIRet = IoctlBeginReint(lpSI);

    if (ShadowIRet >= 1)
    {
        CloseOpenFiles(lpSI->hShare, NULL, 0);
        IoAcquireCancelSpinLock( &CancelIrql);
        if (RxContext->CurrentIrp->Cancel)
        {
            vIrpReint = NULL;
            IoReleaseCancelSpinLock( CancelIrql );
            IoctlEndReint(lpSI);

        }
        else
        {
            // succeeded begin merge on this share
            vIrpReint = RxContext->CurrentIrp;

            IoSetCancelRoutine(RxContext->CurrentIrp, CSCCancelReint);
            IoReleaseCancelSpinLock( CancelIrql );

            // Returning STATUS_PENDING
            IoMarkIrpPending(RxContext->CurrentIrp);

            // as we hijacked the Irp, let us make sure that rdbss gets rid of the rxcontext
            RxContext->CurrentIrp = NULL;

            RxCompleteRequest_Real(RxContext, NULL, STATUS_PENDING);
        }
    }

    return ShadowIRet;
}

ULONG CSCEndReint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

    ends merge. This routine needs to be in pagelocked memory because it takes cancel spinlock
    This is normal termination. We cleanup our merge state and complete the irp we pended
    during begin

Arguments:

    lpSI

Return Value:

    None.

--*/
{
    int ShadowIRet=-1;
    KIRQL   CancelIrql;
    PIRP    pIrp;

    // check if reint was actualy going on on this share
    ShadowIRet = IoctlEndReint(lpSI);

    if (ShadowIRet >= 0)
    {
        IoAcquireCancelSpinLock( &CancelIrql);

        pIrp = vIrpReint;
        vIrpReint = NULL;

        if (pIrp)
        {
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = 0;
            IoSetCancelRoutine(pIrp, NULL);
        }

        IoReleaseCancelSpinLock( CancelIrql );

        if (pIrp)
        {
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        }
    }
    return ShadowIRet;
}

VOID CSCCancelReint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP ThisIrp
    )
/*++

Routine Description:

    Cancels a merge begun by the user. This routine needs to be in pagelocked memory because
    it takes cancel spinlock.


Arguments:

    DeviceObject - Ignored.

    ThisIrp  -  This is the Irp to cancel.

Return Value:

    None.

--*/
{
    SHADOWINFO  sSI;

    memset(&sSI, 0, sizeof(sSI));
    sSI.hShare = hShareReint;
    IoSetCancelRoutine( ThisIrp, NULL );
    vIrpReint = NULL;
    IoReleaseCancelSpinLock( ThisIrp->CancelIrql );
    ThisIrp->IoStatus.Status = STATUS_SUCCESS;
    ThisIrp->IoStatus.Information = 0;
    IoCompleteRequest(ThisIrp, IO_NO_INCREMENT);
    IoctlEndReint(&sSI);
}

BOOL
CloseOpenFiles(
    HSHARE  hShare,
    PUNICODE_STRING pServerName,
    int     lenSkip
    )
/*++

Routine Description:

    Closes all open files for CSC. Does this by issuing a foceclose on the vneteroot
    This an equivalent of wnetcancelconnection on a share with forced close of files

Arguments:

    hShare          CSC handle to the share to close, ignored if pServerName is non-NULL

    pServerName     All open files on on shares belonging to this server

    lenskip         #of  backslashes in servername (usually one)

Return Value:

    Whether atleast one open file was found

--*/
{
    BOOL    fFoundAtleastOne=FALSE, fFound;
    PLIST_ENTRY pListEntry;
    SHAREINFOW sSR;
    UNICODE_STRING uniShare;

    EnterShadowCrit();
    pListEntry = xCscFcbsList.Flink;

    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);

        fFound = FALSE;
        if (pServerName)
        {
            ASSERT(smbFcb->sCscRootInfo.hShare);
            GetShareInfo(smbFcb->sCscRootInfo.hShare, &sSR, NULL);

            uniShare.Buffer = sSR.rgSharePath+lenSkip;
            uniShare.Length = uniShare.MaximumLength = pServerName->Length;

//            DbgPrint("matching %wZ with Servername\n", &uniShare);
            if(RtlEqualUnicodeString(pServerName, &uniShare, TRUE)&&
                (uniShare.Buffer[pServerName->Length/sizeof(WCHAR)]==(WCHAR)'\\'))
            {
//                DbgPrint("matched \n");
                fFound=TRUE;
            }
        }
        else  if ((smbFcb->sCscRootInfo.hShare == hShare))
        {
            fFound = TRUE;
        }

        if (fFound)
        {
            if (!(smbFcb->ContainingFcb->FcbState & FCB_STATE_ORPHANED))
            {
                PNET_ROOT pNetRoot = (PNET_ROOT)((PFCB)(smbFcb->ContainingFcb))->pNetRoot;

                
               fFoundAtleastOne = TRUE;
               LeaveShadowCrit();
               RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);
               RxForceFinalizeAllVNetRoots(pNetRoot);
               RxReleasePrefixTableLock( &RxNetNameTable );
               EnterShadowCrit();
               pListEntry = xCscFcbsList.Flink;
               //
               //  ...start again
               //
               continue;
            }
            else
            {
//                DbgPrint("Skipping orphaned FCB for hShadow=%x \n", smbFcb->hShadow);
            }
        }

        pListEntry = pListEntry->Flink;
    }

    LeaveShadowCrit();
    return fFoundAtleastOne;
}

VOID
CreateFakeFind32(
    HSHADOW hDir,
    _WIN32_FIND_DATA  *Find32,
    PRX_CONTEXT         RxContext,
    BOOLEAN LastComponentInName
    )
/*++

Routine Description:

    Creates a win32 structure for offline use. This is also created for DFS directories

Arguments:

    hDir    directory inode where the item is to be created

    Find32  win32 data to be fixed up

    RxContext

    LastComponentInname If this is not true, then this must be a directory

Return Value:

    None.

--*/
{
    KeQuerySystemTime(((PLARGE_INTEGER)(&Find32->ftCreationTime)));
    Find32->ftLastAccessTime = Find32->ftLastWriteTime = Find32->ftCreationTime;
    //already zero Find32->nFileSizeHigh = Find32->nFileSizeLow = 0;

    if (!LastComponentInName) {

        // must be a directory....don't know the other attribs without going to get them
        Find32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;

    } else {
        PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

        Find32->dwFileAttributes = cp->FileAttributes;
        Find32->dwFileAttributes   &= (FILE_ATTRIBUTE_READONLY |
               FILE_ATTRIBUTE_HIDDEN   |
               FILE_ATTRIBUTE_SYSTEM   |
               FILE_ATTRIBUTE_ARCHIVE );
        if (FlagOn(cp->CreateOptions,FILE_DIRECTORY_FILE)) {
            Find32->dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
        }
    }

    MRxSmbCscGenerate83NameAsNeeded(hDir,
                    &Find32->cFileName[0],
                    &Find32->cAlternateFileName[0]);
}

NTSTATUS
OkToDeleteObject(
    HSHADOW hDir,
    HSHADOW hShadow,
    _WIN32_FIND_DATA  *Find32,
    ULONG   uShadowStatus,
    BOOLEAN fDisconnected
    )
/*++

Routine Description:

    Check to see if the file can be deleted.

Arguments:


Return Value:

    STATUS_SUCCESS if Ok to delete, some appropriate status otherwise

--*/
{
    BOOLEAN fHasDescendents = FALSE;
    NTSTATUS    LocalStatus = STATUS_SUCCESS;

    // in disconnected mode, we don't allow deletions of directories
    // which have been cached while online
    // This automatically takes care of the roots

    if (fDisconnected)
    {
        if (!IsFile(Find32->dwFileAttributes))
        {
            if(!mShadowLocallyCreated(uShadowStatus)) {
                LocalStatus = STATUS_ONLY_IF_CONNECTED;
                goto FINALLY; //bailout;
            }
        }

        ASSERT(hDir);
    }

    // if we are deleting a directory, and it has descendents
    // then fail with appropriate error
    if (!IsFile(Find32->dwFileAttributes))
    {
        if(HasDescendentsHShadow(hDir, hShadow, &fHasDescendents) >= 0)
        {
            if (fHasDescendents)
            {
                LocalStatus = STATUS_DIRECTORY_NOT_EMPTY;
                goto FINALLY; //bailout;
            }
        }
        else
        {
            goto FINALLY; //bailout;
        }
    }

    // don't delete if readonly
    if (Find32->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
    {
        LocalStatus = STATUS_CANNOT_DELETE;
        goto FINALLY; //bailout;

    }

FINALLY:
    return LocalStatus;
}

int IoctlGetGlobalStatus(
    ULONG SessionId,
    LPGLOBALSTATUS lpGS
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    #if 0
    if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_NO_NET)
        DbgPrint("IoctlGetGlobalStatus: FLAG_GLOBALSTATUS_NO_NET\r\n");
    if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED)
        DbgPrint("IoctlGetGlobalStatus: FLAG_GLOBALSTATUS_SHARE_DISCONNECTED share=%d\r\n",
            sGS.hShareDisconnected);
    #endif

    // DbgPrint("IOCTL_GETGLOBALSTATUS Transitioning 0x%x sess 0x%x vs 0x%x\n",
    //                 CscServerEntryBeingTransitioned,
    //                 SessionId,
    //                 CscSessionIdCausingTransition);

    EnterShadowCrit();
    GetShadowSpaceInfo(&(sGS.sST));
    *lpGS = sGS;
    lpGS->uDatabaseErrorFlags = QueryDatabaseErrorFlags();
    if ((sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED) != 0) {
        // Only the session causing a transition will see the SHARE_DISCONNECT bit, and
        // reset it.
        if (SessionId == CscSessionIdCausingTransition)
            sGS.uFlagsEvents = 0;
        else
            lpGS->uFlagsEvents &= ~FLAG_GLOBALSTATUS_SHARE_DISCONNECTED;
    } else {
        sGS.uFlagsEvents = 0;
    }
    LeaveShadowCrit();
    return (1);
}

NTSTATUS
IoctlGetDebugInfo(
    PRX_CONTEXT RxContext,
    PBYTE InputBuffer,
    ULONG InputBufferLength,
    PBYTE OutputBuffer,
    ULONG OutputBufferLength)
{
    ULONG Cmd = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PIOCTL_GET_DEBUG_INFO_ARG pInfoArg = NULL;
    PBYTE pOutBuf = OutputBuffer;
    KPROCESSOR_MODE RequestorMode;

    // DbgPrint("In IoctlGetDebugInfo(IP=0x%x,IL=0x%x,OP=0x%x,OL=0x%x)\n",
    //              InputBuffer,
    //              InputBufferLength,
    //              OutputBuffer,
    //              OutputBufferLength);

    if (
        InputBufferLength < sizeof(ULONG)
            ||
        OutputBufferLength < FIELD_OFFSET(IOCTL_GET_DEBUG_INFO_ARG, ServerEntryObject)
    ) {
        return STATUS_INVALID_PARAMETER;
    }

    RequestorMode = RxContext->CurrentIrp->RequestorMode;

    if (RequestorMode != KernelMode) {
        try {
            ProbeForRead(InputBuffer, InputBufferLength, 1);
            Cmd = *(PULONG)InputBuffer;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
        if (NtStatus != STATUS_SUCCESS)
            return NtStatus;
        pOutBuf = RxAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, OutputBufferLength, RX_MISC_POOLTAG);
        if (pOutBuf == NULL)
            return STATUS_INSUFFICIENT_RESOURCES;
    }

    // DbgPrint("Cmd=%d\n", Cmd);
    if (Cmd == DEBUG_INFO_SERVERLIST) {
        PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
        PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;
        PSMBCEDB_SERVER_ENTRY_ARG pServerEntryArg = NULL;
        PSMBCEDB_NETROOT_ENTRY_ARG pNetRootEntryArg = NULL;
        ULONG Size = 0;
        ULONG ServerEntryCount = 0;
        ULONG NetRootEntryCount = 0;
        PCHAR pCh = NULL;
        ULONG i;
        ULONG j;

        //
        // Two passes - 1st to check size, 2nd to marshal the info in
        //
        SmbCeAcquireResource();
        try {
            Size = 0;
            ServerEntryCount = 0;
            pServerEntry = SmbCeGetFirstServerEntry();
            while (pServerEntry != NULL) {
                ServerEntryCount++;
                Size += pServerEntry->Name.Length + sizeof(WCHAR) +
                            pServerEntry->DomainName.Length  + sizeof(WCHAR) +
                                pServerEntry->DfsRootName.Length + sizeof(WCHAR) +
                                    pServerEntry->DnsName.Length + sizeof(WCHAR);
                NetRootEntryCount = 0;
                pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
                while (pNetRootEntry != NULL) {
                    NetRootEntryCount++;
                    Size += pNetRootEntry->Name.Length + sizeof(WCHAR);
                    pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
                }
                Size += sizeof(SMBCEDB_NETROOT_ENTRY_ARG) * NetRootEntryCount;
                pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
        // DbgPrint("Sizecheck1: ServerEntryCount=%d,NtStatus=0x%x\n", ServerEntryCount, NtStatus);
        if (NtStatus != STATUS_SUCCESS || ServerEntryCount == 0) {
            SmbCeReleaseResource();
            RtlZeroMemory(pOutBuf, OutputBufferLength);
            pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
            pInfoArg->Status = NtStatus;
            goto AllDone;
        }
        Size += FIELD_OFFSET(IOCTL_GET_DEBUG_INFO_ARG, ServerEntryObject[ServerEntryCount]);
        // DbgPrint("Sizecheck2: Size=%d(0x%x)\n", Size, Size);
        if (Size > OutputBufferLength) {
            RtlZeroMemory(pOutBuf, OutputBufferLength);
            pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            pInfoArg->Status = NtStatus;
            pInfoArg->EntryCount = Size;
            SmbCeReleaseResource();
            goto AllDone;
        }
        //
        // Marshal it in
        //
        // Start of buffer is the array of server entries
        // Middle are the arrays of netroots
        // End contains all the strings
        //
        RtlZeroMemory(pOutBuf, OutputBufferLength);
        pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
        pInfoArg->Status = 0;
        pInfoArg->Version = 4;
        pInfoArg->EntryCount = ServerEntryCount;
        pCh = (PCHAR)(pOutBuf + OutputBufferLength);
        pNetRootEntryArg = (PSMBCEDB_NETROOT_ENTRY_ARG)
                                &pInfoArg->ServerEntryObject[ServerEntryCount];
        ServerEntryCount = 0;
        pServerEntry = SmbCeGetFirstServerEntry();
        while (pServerEntry != NULL) {
            pServerEntryArg = &pInfoArg->ServerEntryObject[ServerEntryCount];
            pServerEntryArg->ServerStatus = pServerEntry->ServerStatus;
            pServerEntryArg->SecuritySignaturesEnabled = pServerEntry->SecuritySignaturesEnabled;
            pServerEntryArg->CscState = pServerEntry->Server.CscState;
            pServerEntryArg->IsFakeDfsServerForOfflineUse =
                                            pServerEntry->Server.IsFakeDfsServerForOfflineUse;
            pServerEntryArg->IsPinnedOffline = pServerEntry->Server.IsPinnedOffline;
            pServerEntryArg->pNetRoots = pNetRootEntryArg;
            pCh -= pServerEntry->Name.Length + sizeof(WCHAR);
            pServerEntryArg->Name = (PWCHAR) pCh;
            RtlCopyMemory(pCh, pServerEntry->Name.Buffer, pServerEntry->Name.Length);
            pCh -= pServerEntry->DomainName.Length + sizeof(WCHAR);
            pServerEntryArg->DomainName = (PWCHAR)pCh;
            RtlCopyMemory(pCh, pServerEntry->DomainName.Buffer, pServerEntry->DomainName.Length);
            pCh -= pServerEntry->DfsRootName.Length + sizeof(WCHAR) + 1;;
            pServerEntryArg->DfsRootName = (PWCHAR)pCh;
            RtlCopyMemory(pCh, pServerEntry->DfsRootName.Buffer, pServerEntry->DfsRootName.Length);
            pCh -= pServerEntry->DnsName.Length + sizeof(WCHAR);
            pServerEntryArg->DnsName = (PWCHAR)pCh;
            RtlCopyMemory(pCh, pServerEntry->DnsName.Buffer, pServerEntry->DnsName.Length);
            NetRootEntryCount = 0;
            pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
            while (pNetRootEntry != NULL) {
                pNetRootEntryArg->MaximalAccessRights = pNetRootEntry->MaximalAccessRights;
                pNetRootEntryArg->GuestMaximalAccessRights=pNetRootEntry->GuestMaximalAccessRights;
                pNetRootEntryArg->DfsAware = pNetRootEntry->NetRoot.DfsAware;
                pNetRootEntryArg->hShare = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
                pNetRootEntryArg->hRootDir = pNetRootEntry->NetRoot.sCscRootInfo.hRootDir;
                pNetRootEntryArg->ShareStatus = pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus;
                pNetRootEntryArg->CscEnabled = pNetRootEntry->NetRoot.CscEnabled;
                pNetRootEntryArg->CscFlags = pNetRootEntry->NetRoot.CscFlags;
                pNetRootEntryArg->CscShadowable = pNetRootEntry->NetRoot.CscShadowable;
                pNetRootEntryArg->Disconnected = pNetRootEntry->NetRoot.Disconnected;
                pCh -= pNetRootEntry->Name.Length + sizeof(WCHAR);
                pNetRootEntryArg->Name = (PWCHAR)pCh;
                RtlCopyMemory(pCh, pNetRootEntry->Name.Buffer, pNetRootEntry->Name.Length);
                NetRootEntryCount++;
                pNetRootEntryArg++;
                pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
            }
            pServerEntryArg->NetRootEntryCount = NetRootEntryCount;
            ServerEntryCount++;
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
        SmbCeReleaseResource();
        //
        // Now do fixups
        //
        for (i = 0; i < pInfoArg->EntryCount; i++) {
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].Name, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].DomainName, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].DfsRootName, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].DnsName, pOutBuf);
            for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++)
                POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].pNetRoots[j].Name, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].pNetRoots, pOutBuf);
        }
    } else if (Cmd == DEBUG_INFO_CSCFCBSLIST) {
        PIOCTL_GET_DEBUG_INFO_ARG pInfoArg = NULL;
        PMRX_SMB_FCB_ENTRY_ARG pFcbEntryArg = NULL;
        PMRX_SMB_FCB pSmbFcb = NULL;
        PLIST_ENTRY pListEntry = NULL;
        ULONG Size = 0;
        PCHAR pCh = NULL;
        ULONG FcbCount = 0;
        ULONG i;

        EnterShadowCritRx(RxContext);
        pListEntry = xCscFcbsList.Flink;
        FcbCount = 0;
        while (pListEntry != &xCscFcbsList) {
            FcbCount++;
            pSmbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                            pListEntry,
                            MRX_SMB_FCB,
                            ShadowReverseTranslationLinks);
            Size += pSmbFcb->MinimalCscSmbFcb.uniDfsPrefix.Length + sizeof(WCHAR) +
                        pSmbFcb->MinimalCscSmbFcb.uniActualPrefix.Length + sizeof(WCHAR);
            pListEntry = pListEntry->Flink;
        }
        Size += FIELD_OFFSET(IOCTL_GET_DEBUG_INFO_ARG, FcbEntryObject[FcbCount]);
        if (Size > OutputBufferLength) {
            RtlZeroMemory(pOutBuf, OutputBufferLength);
            pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            pInfoArg->Status = NtStatus;
            pInfoArg->EntryCount = Size;
            LeaveShadowCritRx(RxContext);
            goto AllDone;
        }
        RtlZeroMemory(pOutBuf, OutputBufferLength);
        pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
        pInfoArg->Status = 0;
        pInfoArg->Version = 1;
        pInfoArg->EntryCount = FcbCount;
        FcbCount = 0;
        pCh = (PCHAR)(pOutBuf + OutputBufferLength);
        pListEntry = xCscFcbsList.Flink;
        while (pListEntry != &xCscFcbsList) {
            pFcbEntryArg = &pInfoArg->FcbEntryObject[FcbCount];
            pSmbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                            pListEntry,
                            MRX_SMB_FCB,
                            ShadowReverseTranslationLinks);
            pFcbEntryArg->MFlags = pSmbFcb->MFlags;
            pFcbEntryArg->Tid = pSmbFcb->Tid;
            pFcbEntryArg->ShadowIsCorrupt = pSmbFcb->ShadowIsCorrupt;
            pFcbEntryArg->hShadow = pSmbFcb->hShadow;
            pFcbEntryArg->hParentDir = pSmbFcb->hParentDir;
            pFcbEntryArg->hShadowRenamed = pSmbFcb->hShadowRenamed;
            pFcbEntryArg->ShadowStatus = pSmbFcb->ShadowStatus;
            pFcbEntryArg->LocalFlags = pSmbFcb->LocalFlags;
            pFcbEntryArg->LastComponentOffset = pSmbFcb->LastComponentOffset;
            pFcbEntryArg->LastComponentLength = pSmbFcb->LastComponentLength;
            pFcbEntryArg->hShare = pSmbFcb->sCscRootInfo.hShare;
            pFcbEntryArg->hRootDir = pSmbFcb->sCscRootInfo.hRootDir;
            pFcbEntryArg->ShareStatus = pSmbFcb->sCscRootInfo.ShareStatus;
            pFcbEntryArg->Flags = pSmbFcb->sCscRootInfo.Flags;
            pCh -= pSmbFcb->MinimalCscSmbFcb.uniDfsPrefix.Length + sizeof(WCHAR);
            pFcbEntryArg->DfsPrefix = (PWCHAR)pCh;
            RtlCopyMemory(
                    pCh,
                    pSmbFcb->MinimalCscSmbFcb.uniDfsPrefix.Buffer,
                    pSmbFcb->MinimalCscSmbFcb.uniDfsPrefix.Length);
            pCh -= pSmbFcb->MinimalCscSmbFcb.uniActualPrefix.Length + sizeof(WCHAR);
            pFcbEntryArg->ActualPrefix = (PWCHAR)pCh;
            RtlCopyMemory(
                    pCh,
                    pSmbFcb->MinimalCscSmbFcb.uniActualPrefix.Buffer,
                    pSmbFcb->MinimalCscSmbFcb.uniActualPrefix.Length);
            FcbCount++;
            pListEntry = pListEntry->Flink;
        }
        LeaveShadowCritRx(RxContext);
        for (i = 0; i < pInfoArg->EntryCount; i++) {
            POINTER_TO_OFFSET(pInfoArg->FcbEntryObject[i].DfsPrefix, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->FcbEntryObject[i].ActualPrefix, pOutBuf);
        }
    } else {
        RtlZeroMemory(pOutBuf, OutputBufferLength);
        pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
        NtStatus = STATUS_INVALID_PARAMETER;
        pInfoArg->Status = NtStatus;
        goto AllDone;
    }

AllDone:

    if (RequestorMode != KernelMode) {
        try {
            ProbeForWrite(OutputBuffer, OutputBufferLength, 1);
            RtlCopyMemory(OutputBuffer, pOutBuf, OutputBufferLength);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }

    if (pOutBuf != OutputBuffer)
        RxFreePool(pOutBuf);
        
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\nt5csc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nt5csc.h

Abstract:

    The global include file for nt5csc within the nt5csc library

Author:

    Joe Linn (Joelinn) - Created  5-may-97

Revision History:

--*/

#ifndef _NT5CSC_H_
#define _NT5CSC_H_

//this include finds ntcsc.h from rdr2\inc
#include "..\csc\record.mgr\ntcsc.h"

#define CSC_AGENT_NOTIFIED     (0x11111111)
#define CSC_AGENT_NOT_NOTIFIED (0x22222222)

extern LONG    CscNetPresent;
extern LONG    CscAgentNotifiedOfNetStatusChange;
extern LONG    CscAgentNotifiedOfFullCache;

extern VOID
CscNotifyAgentOfNetStatusChangeIfRequired(BOOLEAN fInvokeAutodial);

// this event and mutex is used for synchronizing the transitioning of a
// server entry from connected to disconnected mode

extern KEVENT       CscServerEntryTransitioningEvent;
extern FAST_MUTEX   CscServerEntryTransitioningMutex;

extern FAST_MUTEX MRxSmbCscShadowReadWriteMutex;

//shared routines

INLINE
BOOLEAN
CscIsDfsOpen(
    PRX_CONTEXT RxContext)
{
    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    return (RxContext->Create.NtCreateParameters.DfsContext != NULL);
}

PDFS_NAME_CONTEXT
CscIsValidDfsNameContext(
    PVOID   pFsContext);

NTSTATUS
CscDfsParseDfsPath(
    PUNICODE_STRING pDfsPath,
    PUNICODE_STRING pServerName,
    PUNICODE_STRING pSharePath,
    PUNICODE_STRING pFilePathRelativeToShare);

NTSTATUS
CscGrabPathFromDfs(
    PFILE_OBJECT      pFileObject,
    PDFS_NAME_CONTEXT pDfsNameContext);

NTSTATUS
MRxSmbCscObtainShareHandles (
    IN PUNICODE_STRING              ShareName,
    IN BOOLEAN                      DisconnectedMode,
    IN BOOLEAN                      CopyChunkOpen,
    IN OUT PSMBCEDB_NET_ROOT_ENTRY  pNetRootEntry
    );

//acquire/release stuff


// Another view of the minirdr context in the RxContext is as
// links for Csc Synchronization. This is used both for read/write
// synchronization and open synchornization when surrogate opens are
// involved

typedef struct _MRXSMBCSC_SYNC_RX_CONTEXT {
    ULONG Dummy; //this is the cancel routine....it must not be filled in
    USHORT TypeOfAcquire;
    UCHAR  FcbLockWasDropped;
    LIST_ENTRY   CscSyncLinks;
} MRXSMBCSC_SYNC_RX_CONTEXT, *PMRXSMBCSC_SYNC_RX_CONTEXT;


#define MRxSmbGetMinirdrContextForCscSync(pRxContext)     \
        ((PMRXSMBCSC_SYNC_RX_CONTEXT)(&(pRxContext)->MRxContext[0]))

#define Shared_SmbFcbAcquire SmbFcb_HeldShared
#define Exclusive_SmbFcbAcquire SmbFcb_HeldExclusive
#define DroppingFcbLock_SmbFcbAcquire 0x80000000
#define FailImmediately_SmbFcbAcquire 0x40000000


typedef struct _SID_CONTEXT_ {
    PSID    pSid;
    PVOID   Context;
} SID_CONTEXT, *PSID_CONTEXT;


NTSTATUS
MRxSmbCscAcquireSmbFcb (
      IN OUT PRX_CONTEXT RxContext,
      IN  ULONG TypeOfAcquirePlusFlags,
      OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      );

VOID
MRxSmbCscReleaseSmbFcb (
      IN OUT PRX_CONTEXT RxContext,
      IN SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      );

VOID
MRxSmbCSCResumeAllOutstandingOperations(
    PSMBCEDB_SERVER_ENTRY   pServerEntry
);

// Control flag definitions for creating shadow handles
#define CREATESHADOW_NO_SPECIAL_CONTROLS                    0x0000
#define CREATESHADOW_CONTROL_NOCREATE                       0x0001
#define CREATESHADOW_CONTROL_NOREVERSELOOKUP                0x0002
#define CREATESHADOW_CONTROL_NOCREATELEAF                   0x0004
#define CREATESHADOW_CONTROL_NOCREATENONLEAF                0x0008
#define CREATESHADOW_CONTROL_SPARSECREATE                   0x0010
#define CREATESHADOW_CONTROL_FILE_WITH_HEURISTIC            0x0020  //.exe or .dll
#define CREATESHADOW_CONTROL_FAIL_IF_MARKED_FOR_DELETION    0x0040
#define CREATESHADOW_CONTROL_DO_SHARE_ACCESS_CHECK          0x0080
#define CREATESHADOW_CONTROL_STRIP_SHARE_NAME               0x0100


#ifdef DEBUG
//Hook dbgprint interface
#define HookKdPrint(__bit,__x) {\
    if (((HOOK_KDP_##__bit)==0) || FlagOn(HookKdPrintVector,(HOOK_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}
#define HOOK_KDP_ALWAYS             0x00000000
#define HOOK_KDP_BADERRORS          0x00000001
#define HOOK_KDP_NAME               0x00000002
#define HOOK_KDP_NET                0x00000004
#define HOOK_KDP_RW                 0x00000008
#define HOOK_KDP_TRANSITION         0x00000010
#define HOOK_KDP_AGENT              0x00000020
#define HOOK_KDP_IOCTL              0x00000040
#define HOOK_KDP_BITCOPY            0x00000080

#define HOOK_KDP_GOOD_DEFAULT (HOOK_KDP_BADERRORS         \
                | 0)

extern ULONG HookKdPrintVector;
extern ULONG HookKdPrintVectorDef;
#else
#define HookKdPrint(__bit,__x)  {NOTHING;}
#endif


extern NTSTATUS
MRxSmbCscCreateShadowFromPath (
    IN      PUNICODE_STRING     AlreadyPrefixedName,
    IN      PCSC_ROOT_INFO      pCscRootInfo,
    OUT     _WIN32_FIND_DATA   *Find32,
    OUT     PBOOLEAN            Created  OPTIONAL,
    IN      ULONG               Controls,
    IN OUT  PMINIMAL_CSC_SMBFCB MinimalCscSmbFcb,
    IN OUT  PRX_CONTEXT         RxContext,
    IN      BOOLEAN             fDisconnected,
    OUT     ULONG               *pulInheritedHintFlags
    );


#ifndef MRXSMB_BUILD_FOR_CSC_DCON
#define MRxSmbCscWriteDisconnected(__RXCONTEXT) (STATUS_SUCCESS)
#else
NTSTATUS
MRxSmbCscWriteDisconnected (
      IN OUT PRX_CONTEXT RxContext
      );
#endif
//NTSTATUS
//MRxSmbCscSpecialShadowWriteForPagingIo (
//      IN OUT PRX_CONTEXT RxContext,
//      IN     ULONG       ShadowFileLength,
//         OUT PULONG LengthActuallyWritten
//      );



#define CSC_REPORT_CHANGE(pNetRootEntry, pFcb, pSmbFcb, Filter, Action) \
            (pNetRootEntry)->NetRoot.pNotifySync,                       \
            &((pNetRootEntry)->NetRoot.DirNotifyList)                   \
            (pFcb)->pPrivateAlreaydPrefixedName.Buffer,                 \
            (USHORT)(GET_ALREADY_PREFIXED_NAME(pFcb)->PrivateAlreaydPrefixedName.Length -        \
                        (pSmbFcb)->MinimalCscSmbFcb.LastComponentLength),                \
            NULL,                                                       \
            NULL,                                                       \
            (ULONG)Filter,                                              \
            (ULONG)Action,                                              \
            NULL)


#ifdef RX_PRIVATE_BUILD
#if 1
#ifdef RDBSSTRACE
extern ULONG MRxSmbCscDbgPrintF;
#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) { if(MRxSmbCscDbgPrintF){DbgPrint __d__;}}
#undef RxDbgTraceUnIndent
#define RxDbgTraceUnIndent(a,b) {NOTHING;}
#endif //#ifdef RDBSSTRACE
#endif //if 1
#endif //ifdef RX_PRIVATE_BUILD



//CODE.IMPROVEMENT if we added another field to the large_integer union then we'd
//                 eliminate these 2 macros
#define COPY_LARGEINTEGER_TO_STRUCTFILETIME(dest,src) {\
     (dest).dwLowDateTime = (src).LowPart;             \
     (dest).dwHighDateTime = (src).HighPart;           \
     }
#define COPY_STRUCTFILETIME_TO_LARGEINTEGER(dest,src) {\
     (dest).LowPart = (src).dwLowDateTime;             \
     (dest).HighPart = (src).dwHighDateTime;           \
     }


NTSTATUS
CscDfsDoDfsNameMapping(
    PUNICODE_STRING pDfsPrefix, 
    PUNICODE_STRING pActualPrefix, 
    PUNICODE_STRING pNameToReverseMap,
    BOOL            fResolvedNameToDFSName,
    PUNICODE_STRING pResult);
    
NTSTATUS
CscDfsObtainReverseMapping( 
    PUNICODE_STRING pDfsPath,
    PUNICODE_STRING pResolvedPath,
    PUNICODE_STRING pReversemappingFrom,
    PUNICODE_STRING pReverseMappingTo);
    
NTSTATUS
CscDfsStripLeadingServerShare(
    IN  PUNICODE_STRING pDfsRootPath
    );

BOOLEAN
MRxSmbCSCIsDisconnectedOpen(
    PMRX_FCB    pFcb,
    PMRX_SMB_SRV_OPEN smbSrvOpen
    );

BOOL
CloseOpenFiles(
    HSHARE  hShare,
    PUNICODE_STRING pServerName,
    int     lenSkip
    );
    
VOID
MRxSmbCSCObtainRightsForUserOnFile(
    IN  PRX_CONTEXT     pRxContext,
    HSHADOW             hDir,
    HSHADOW             hShadow,
    OUT ACCESS_MASK     *pMaximalAccessRights,
    OUT ACCESS_MASK     *pGuestMaximalAccessRights
    );
    
NTSTATUS
CscRetrieveSid(
    PRX_CONTEXT     pRxContext,
    PSID_CONTEXT    pSidContext
    );

VOID
CscDiscardSid(
    PSID_CONTEXT pSidContext
    );

    
    
#endif   // _NT5CSC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\precomp.h ===
#include "..\rdbss\smb.mrx\precomp.h" //this should find it form rdr2\inc
#include "dfsfsctl.h"
#include "nt5csc.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\daytona\security.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    sessetup.c

Abstract:

    This module implements the Session setup related routines

Author:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

--*/

#include "precomp.h"
#pragma hdrstop

#include <exsessup.h>
#include "ntlsapi.h"
#include "mrxsec.h"

NTSTATUS
BuildSessionSetupSecurityInformation(
    PSMB_EXCHANGE   pExchange,
    PBYTE           pSmbBuffer,
    PULONG          pSmbBufferSize)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pSmbBuffer - the SMB buffer

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS Status;
    BOOLEAN  fProcessAttached = FALSE;

    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;

    STRING CaseSensitiveResponse;
    STRING CaseInsensitiveResponse;

    PVOID  pSecurityBlob;
    USHORT SecurityBlobSize;

    PSMBCE_SERVER  pServer  = &pExchange->SmbCeContext.pServerEntry->Server;
    PSMBCE_SESSION pSession = &pExchange->SmbCeContext.pSessionEntry->Session;

    SECURITY_RESPONSE_CONTEXT ResponseContext;

    PAGED_CODE();
    RxDbgTrace( +1, Dbg, ("BuildSessionSetupSecurityInformation -- Entry\n"));

    //  Attach to the redirector's FSP to allow us to call into the security impl.
    if (PsGetCurrentProcess() != RxGetRDBSSProcess()) {
        KeAttachProcess(RxGetRDBSSProcess());

        fProcessAttached = TRUE;
    }

    if (pServer->DialectFlags & DF_EXTENDED_SECURITY) {
        Status = BuildExtendedSessionSetupResponsePrologue(
                     pExchange,
                     &pSecurityBlob,
                     &SecurityBlobSize,
                     &ResponseContext);
    } else {
        Status = BuildNtLanmanResponsePrologue(
                     pExchange,
                     &UserName,
                     &DomainName,
                     &CaseSensitiveResponse,
                     &CaseInsensitiveResponse,
                     &ResponseContext);
    }

    if (NT_SUCCESS(Status)) {
        PBYTE    pBuffer    = pSmbBuffer;
        ULONG    BufferSize = *pSmbBufferSize;

        if ((pServer->Dialect == NTLANMAN_DIALECT) &&
            (BooleanFlagOn(pServer->DialectFlags,DF_EXTENDED_SECURITY))) {
            PREQ_NT_EXTENDED_SESSION_SETUP_ANDX pExtendedNtSessionSetupReq;

            // Position the buffer for copying the security blob
            pBuffer += FIELD_OFFSET(REQ_NT_EXTENDED_SESSION_SETUP_ANDX,Buffer);
            BufferSize -= FIELD_OFFSET(REQ_NT_EXTENDED_SESSION_SETUP_ANDX,Buffer);

            pExtendedNtSessionSetupReq = (PREQ_NT_EXTENDED_SESSION_SETUP_ANDX)pSmbBuffer;

            SmbPutUshort(
                &pExtendedNtSessionSetupReq->SecurityBlobLength,
                SecurityBlobSize);

            if (BufferSize >= SecurityBlobSize) {
                RtlCopyMemory(
                    pBuffer,
                    pSecurityBlob,
                    SecurityBlobSize);
                BufferSize -= SecurityBlobSize;
            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
        } else if (pServer->Dialect == NTLANMAN_DIALECT) {
            PREQ_NT_SESSION_SETUP_ANDX pNtSessionSetupReq = (PREQ_NT_SESSION_SETUP_ANDX)pSmbBuffer;

            // It it is a NT server both the case insensitive and case sensitive passwords
            // need to be copied. for share-level, just copy a token 1-byte NULL password

            // Position the buffer for copying the password.
            pBuffer += FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);
            BufferSize -= FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);

            if (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL){

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtUserPasswords\n"));

                SmbPutUshort(
                    &pNtSessionSetupReq->CaseInsensitivePasswordLength,
                    CaseInsensitiveResponse.Length);

                SmbPutUshort(
                    &pNtSessionSetupReq->CaseSensitivePasswordLength,
                    CaseSensitiveResponse.Length);

                Status = SmbPutString(
                             &pBuffer,
                             &CaseInsensitiveResponse,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutString(
                                 &pBuffer,
                                 &CaseSensitiveResponse,
                                 &BufferSize);
                }
            } else {

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtSharePasswords\n"));

                SmbPutUshort(&pNtSessionSetupReq->CaseInsensitivePasswordLength, 1);
                SmbPutUshort(&pNtSessionSetupReq->CaseSensitivePasswordLength, 1);
                *pBuffer = 0;
                *(pBuffer+1) = 0;
                pBuffer += 2;
                BufferSize -= 2;
            }
        } else {
            PREQ_SESSION_SETUP_ANDX pSessionSetupReq = (PREQ_SESSION_SETUP_ANDX)pSmbBuffer;

            // Position the buffer for copying the password.
            pBuffer += FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);
            BufferSize -= FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);

            if (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL) {
                // For othe lanman servers only the case sensitive password is required.
                SmbPutUshort(
                    &pSessionSetupReq->PasswordLength,
                    CaseSensitiveResponse.Length);

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseSensitiveResponse,
                             &BufferSize);
            } else {
                // Share level security. Send a null string for the password
                SmbPutUshort(&pSessionSetupReq->PasswordLength,1);
                *pBuffer++ = '\0';
                BufferSize -= sizeof(CHAR);
            }
        }

        // The User name and the domain name strings can be either copied from
        // the information returned in the request response or the information
        // that is already present in the session entry.
        if (NT_SUCCESS(Status) &&
            !BooleanFlagOn(pServer->DialectFlags,DF_EXTENDED_SECURITY)) {
            if ((pServer->Dialect == NTLANMAN_DIALECT) &&
                (pServer->NtServer.NtCapabilities & CAP_UNICODE)) {
                // Copy the account/domain names as UNICODE strings
                PBYTE pTempBuffer = pBuffer;

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as unicode\n"));
                pBuffer = ALIGN_SMB_WSTR(pBuffer);
                BufferSize -= (pBuffer - pTempBuffer);

                Status = SmbPutUnicodeString(
                             &pBuffer,
                             &UserName,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutUnicodeString(
                                 &pBuffer,
                                 &DomainName,
                                 &BufferSize);

                }
            } else {
                // Copy the account/domain names as ASCII strings.
                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as ascii\n"));
                Status = SmbPutUnicodeStringAsOemString(
                             &pBuffer,
                             &UserName,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutUnicodeStringAsOemString(
                                 &pBuffer,
                                 &DomainName,
                                 &BufferSize);
                }
            }
        }

        if (NT_SUCCESS(Status)) {
            *pSmbBufferSize = BufferSize;
        }
    }

    // Free the buffer allocated by the security package.
    if (pServer->DialectFlags & DF_EXTENDED_SECURITY) {
        BuildExtendedSessionSetupResponseEpilogue(&ResponseContext);
    } else {
        BuildNtLanmanResponseEpilogue(&ResponseContext);
    }

    // Detach from the rdr process.
    if (fProcessAttached) {
        KeDetachProcess();
    }

    RxDbgTrace( -1, Dbg, ("BuildSessionSetupSecurityInformation -- Exit, status=%08lx\n",Status));
    return Status;
}
NTSTATUS
BuildTreeConnectSecurityInformation(
    PSMB_EXCHANGE  pExchange,
    PBYTE          pBuffer,
    PBYTE          pPasswordLength,
    PULONG         pSmbBufferSize)
/*++

Routine Description:

    This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pLogonId - the logon id. for which the session is being setup

    pPassword - the user  supplied password if any

    pBuffer - the password buffer

    pPasswordLength - where the password length is to be stored

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS FinalStatus,Status;
    BOOLEAN  fProcessAttached = FALSE;

    UNICODE_STRING UserName,DomainName;
    STRING         CaseSensitiveChallengeResponse,CaseInsensitiveChallengeResponse;

    SECURITY_RESPONSE_CONTEXT ResponseContext;

    ULONG PasswordLength = 0;

    PSMBCE_SERVER  pServer  = &pExchange->SmbCeContext.pServerEntry->Server;
    PSMBCE_SESSION pSession = &pExchange->SmbCeContext.pSessionEntry->Session;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    if (pServer->EncryptPasswords) {
        //  Attach to the redirector's FSP to allow us to call into the securiy impl.
        if (PsGetCurrentProcess() != RxGetRDBSSProcess()) {
            KeAttachProcess(RxGetRDBSSProcess());
            fProcessAttached = TRUE;
        }

        Status = BuildNtLanmanResponsePrologue(
                     pExchange,
                     &UserName,
                     &DomainName,
                     &CaseSensitiveChallengeResponse,
                     &CaseInsensitiveChallengeResponse,
                     &ResponseContext);

        if (NT_SUCCESS(Status)) {
            if (FlagOn(pServer->DialectFlags,DF_MIXEDCASEPW)) {
                RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case sensitive password\n"));
                // Copy the password length onto the SMB buffer
                PasswordLength = CaseSensitiveChallengeResponse.Length;

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseSensitiveChallengeResponse,
                             pSmbBufferSize);
            } else {
                RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case insensitive password\n"));
                // Copy the password length onto the SMB buffer
                PasswordLength = CaseInsensitiveChallengeResponse.Length;

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseInsensitiveChallengeResponse,
                             pSmbBufferSize);
            }

            BuildNtLanmanResponseEpilogue(&ResponseContext);
        }

        if (fProcessAttached) {
            KeDetachProcess();
        }
    } else {
        if (pSession->pPassword == NULL) {
            // The logon password cannot be sent as plain text. Send a single blank as password.

            PasswordLength = 2;
            if (*pSmbBufferSize >= 2) {
                *((PCHAR)pBuffer) = ' ';
                pBuffer += sizeof(CHAR);
                *((PCHAR)pBuffer) = '\0';
                pBuffer += sizeof(CHAR);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
        } else {
            OEM_STRING OemString;

            OemString.Length = OemString.MaximumLength = (USHORT)(*pSmbBufferSize - sizeof(CHAR));
            OemString.Buffer = pBuffer;
            Status = RtlUnicodeStringToOemString(
                         &OemString,
                         pSession->pPassword,
                         FALSE);

            if (NT_SUCCESS(Status)) {
                PasswordLength = OemString.Length+1;
            }
        }

        // reduce the byte count
        *pSmbBufferSize -= PasswordLength;
    }

    SmbPutUshort(pPasswordLength,(USHORT)PasswordLength);

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\readrite.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ReadRite.c

Abstract:

    This module implements the routines for reading/writeng shadows at
    the right time.

Author:

    Joe Linn [JoeLinn]    5-may-1997

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_MRXSMBCSC;
#define Dbg (DEBUG_TRACE_MRXSMBCSC)

// The CscEnterShadowReadWriteCrit and CscLeaveShadowReadWriteCrit are defined
// as macros to allow us the ability to capture context information. In non
// debug builds these will be defined as the regular Ex routines for
// mutex acquisition/release

#if DBG

#define CscEnterShadowReadWriteCrit(pSmbFcb) \
            CscpEnterShadowReadWriteCrit(pSmbFcb,__FILE__,__LINE__);

#define CscLeaveShadowReadWriteCrit(pSmbFcb) \
            CscpLeaveShadowReadWriteCrit(pSmbFcb,__FILE__,__LINE__);

VOID
CscpEnterShadowReadWriteCrit(
    PMRX_SMB_FCB    pSmbFcb,
    PCHAR           FileName,
    ULONG           Line)
{
    ExAcquireFastMutex(&pSmbFcb->CscShadowReadWriteMutex);
}

VOID
CscpLeaveShadowReadWriteCrit(
    PMRX_SMB_FCB pSmbFcb,
    PCHAR        FileName,
    ULONG        Line)
{
    ExReleaseFastMutex(&pSmbFcb->CscShadowReadWriteMutex);
}
#else

#define CscEnterShadowReadWriteCrit(pSmbFcb) \
            ExAcquireFastMutex(&pSmbFcb->CscShadowReadWriteMutex);

#define CscLeaveShadowReadWriteCrit(pSmbFcb) \
            ExReleaseFastMutex(&pSmbFcb->CscShadowReadWriteMutex);

#endif

NTSTATUS
MRxSmbCscShadowWrite (
    IN OUT PRX_CONTEXT RxContext,
    IN     ULONG       ByteCount,
    IN     ULONGLONG   ShadowFileLength,
    OUT PULONG LengthActuallyWritten
    );

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //ifdef RX_PRIVATE_BUILD


NTSTATUS
MRxSmbCscReadPrologue (
    IN OUT PRX_CONTEXT RxContext,
    OUT    SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

   This routine first performs the correct read synchronization and then
   looks at the shadow file and tries to do a read.

   CODE.IMPROVEMENT because the minirdr is not set up to handle "the rest of
   a read", we fail here if any part of the read is not in the cache. indeed,
   the minirdr should be setup to continue....if it were then we could take
   a prefix of the chunk here and get the rest on the net.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    ULONG iRet,ShadowFileLength;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_FCB      smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    BOOLEAN                 Disconnected;

    PMRXSMBCSC_SYNC_RX_CONTEXT pRxSyncContext;
    BOOLEAN                    ThisIsAReenter;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE          UserBuffer = RxLowIoGetBufferAddress(RxContext);
    ULONGLONG      ByteOffset = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    ULONG          ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

    BOOLEAN EnteredCriticalSection = FALSE;
    NTSTATUS AcquireStatus;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbCscReadPrologue(%08lx)...%08lx bytes @ %08lx on handle %08lx\n",
            RxContext,ByteCount,((PLARGE_INTEGER)(&ByteOffset))->LowPart,smbSrvOpen->hfShadow ));

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    pRxSyncContext = MRxSmbGetMinirdrContextForCscSync(RxContext);

    ASSERT((pRxSyncContext->TypeOfAcquire == 0) ||
           (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)));

    ThisIsAReenter = (pRxSyncContext->TypeOfAcquire != 0);

    AcquireStatus = MRxSmbCscAcquireSmbFcb(
                        RxContext,
                        Shared_SmbFcbAcquire,
                        SmbFcbHoldingState);

    if (AcquireStatus != STATUS_SUCCESS) {
        //we couldn't acquire.....get out
        Status = AcquireStatus;
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscReadPrologue couldn't acquire!!!-> %08lx %08lx\n",
                Status, RxContext ));
        goto FINALLY;
    }

    ASSERT( smbFcb->CscOutstandingReaders > 0);

    //if this is a copychunk open......don't try to get it from the cache.....
    if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)){
        goto FINALLY;
    }

#if 0
    //if this is the agent......don't try to get it from the cache.....
    //because of the way this test is done.....the agent must do all synchronous
    //I/O. otherwise, we could have posted and this test will be wrong.
    if (IsSpecialApp()) {
        goto FINALLY;
    }
#endif

    // we cannot satisfy the read from here in connected mode unless
    //     a) we have an oplock, or
    //     b) our opens add up to deny write

    if ((smbFcb->LastOplockLevel == SMB_OPLOCK_LEVEL_NONE) &&
        (!Disconnected)) {
        PSHARE_ACCESS ShareAccess;
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscReadPrologue no oplock!!!-> %08lx %08lx\n",
                Status, RxContext ));

        ShareAccess = &((PFCB)capFcb)->ShareAccessPerSrvOpens;

        if ((ShareAccess->OpenCount > 0) &&
            (ShareAccess->SharedWrite == ShareAccess->OpenCount)) {
            RxDbgTrace(0, Dbg,
                ("MRxSmbCscReadPrologue no oplock and write access allowed!!!"
                 "-> %08lx %08lx\n",
                    Status, RxContext ));
            goto FINALLY;
        }
    }

    CscEnterShadowReadWriteCrit(smbFcb);
    EnteredCriticalSection = TRUE;

    // check whether we can satisfy the read locally
    iRet = GetFileSizeLocal((CSCHFILE)(smbSrvOpen->hfShadow), &ShadowFileLength);
    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscReadPrologue (st=%08lx) fsize= %08lx\n",
             iRet, ShadowFileLength));

    if (Disconnected && (ByteOffset >= ShadowFileLength)) {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscReadPrologue %08lx EOFdcon\n",
                               RxContext ));
        RxContext->InformationToReturn = 0;
        Status = STATUS_END_OF_FILE;
    } else if ( Disconnected ||
        (ByteOffset+ByteCount <= ShadowFileLength) ) {
        //okay then....let's get it from cache!!!!
        //CODE.IMPROVEMENT.ASHAMED we should get any part that overlaps the
        //                         cache from cache....sigh...this is for
        //                         connected obviously
        LONG ReadLength;
        IO_STATUS_BLOCK IoStatusBlockT;

        ReadLength = Nt5CscReadWriteFileEx (
                R0_READFILE,
                (CSCHFILE)smbSrvOpen->hfShadow,
                (ULONG)ByteOffset,
                UserBuffer,
                ByteCount,
                0,
                &IoStatusBlockT);


        if (ReadLength >= 0)
        {
            RxDbgTrace(0, Dbg,
                ("MRxSmbCscReadPrologue %08lx read %08lx bytes\n",
                               RxContext, ReadLength ));
            //sometimes things are good........
            RxContext->InformationToReturn = ReadLength;
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = IoStatusBlockT.Status;
        }
    }

FINALLY:
    if (EnteredCriticalSection) {
        CscLeaveShadowReadWriteCrit(smbFcb);
    }

    if (Status==STATUS_SUCCESS) {
        MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
    }

    if (ThisIsAReenter &&
        (Status != STATUS_MORE_PROCESSING_REQUIRED)) {
        ASSERT(Status != STATUS_PENDING);
        ASSERT(FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
        RxContext->StoredStatus = Status;
        RxLowIoCompletion(RxContext);
        Status = STATUS_PENDING;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscReadPrologue -> %08lx\n", Status ));
    return Status;
}

ULONG ExtendOnSurrogateOpen = 0;

VOID
MRxSmbCscReadEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a read operation for CSC. In
   particular, if the read data can be used to extend the cached
   prefix, then we make it so.

   The status of the read operation is passed in case we someday find
   things are so messed up that we want to return a failure even after
   a successful read. not today however...

   CODE.IMPROVEMENT.ASHAMED when we get here the buffer may overlap..we
   should only write the suffix. if we do this, we will have to do some
   wierd stuff in the pagingio path but it will be worth it.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS LocalStatus;
    ULONG ShadowFileLength;
    LONG iRet;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB  smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE UserBuffer = RxLowIoGetBufferAddress(RxContext);
    ULONGLONG ByteOffset = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    ULONG ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
    ULONG ReadLength = (ULONG)RxContext->InformationToReturn;
    BOOLEAN EnteredCriticalSection = FALSE;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbCscReadEpilogueentry %08lx...%08lx bytes @ %08lx on handle %08lx\n",
            RxContext, ByteCount,
            ((PLARGE_INTEGER)(&ByteOffset))->LowPart,
            smbSrvOpen->hfShadow ));

    if ((*Status != STATUS_SUCCESS)
           || (ReadLength ==0) ){
        RxDbgTrace(0, Dbg, ("MRxSmbCscReadEpilogue exit w/o extending -> %08lx\n", Status ));
        goto FINALLY;
    }
    if (smbFcb->ShadowIsCorrupt) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscReadEpilogue exit w/o extending sh_corrupt-> %08lx\n", Status ));
        goto FINALLY;
    }

    // we cannot ask for the csc lock if we are not the toplevel guy......
    if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_THIS_DEVICE_TOP_LEVEL)) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscReadEpilogue exit w/o extending NOTTOP -> %08lx\n", Status ));
        //KdPrint(("MRxSmbCscReadEpilogue exit w/o extending NOTTOP -> %08lx\n", Status ));
        goto FINALLY;
    }

    CscEnterShadowReadWriteCrit(smbFcb);
    EnteredCriticalSection = TRUE;

    // check whether we are extend overlapping the prefix
    iRet = GetFileSizeLocal((CSCHFILE)(smbSrvOpen->hfShadow), &ShadowFileLength);
    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscReadEpilogue %08lx (st=%08lx) fsize= %08lx, readlen=%08lx\n",
            RxContext, iRet, ShadowFileLength, ReadLength));

    if (iRet <0) {
        goto FINALLY;
    }

    if ((ByteOffset <= ShadowFileLength) && (ByteOffset+ReadLength > ShadowFileLength)) {
        NTSTATUS ShadowWriteStatus;
        ULONG LengthActuallyWritten;
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscReadEpilogue %08lx writing  %08lx bytes\n",
                RxContext,ReadLength ));

        if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED)) {
            ExtendOnSurrogateOpen++;
        }

        // do a write only if there is non-zero size data to be written.
        if (RxContext->InformationToReturn)
        {
            ShadowWriteStatus = MRxSmbCscShadowWrite(
                                    RxContext,
                                    (ULONG)RxContext->InformationToReturn,
                                    ShadowFileLength,
                                    &LengthActuallyWritten);
            RxDbgTrace(0, Dbg,
                ("MRxSmbCscReadEpilogue %08lx writing  %08lx bytes %08lx written\n",
                    RxContext,ReadLength,LengthActuallyWritten ));

            if (ShadowWriteStatus != STATUS_SUCCESS)
            {
                if (FlagOn(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)) {

//                    RxDbgTrace(0, Dbg, ("Copychunk failed status=%x \r\n", ShadowWriteStatus));

                    *Status = ShadowWriteStatus;
                }
            }

        }
    }

FINALLY:
    if (EnteredCriticalSection) {
        CscLeaveShadowReadWriteCrit(smbFcb);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscReadEpilogue exit -> %08lx %08lx\n", RxContext, Status ));
    return;
}



NTSTATUS
MRxSmbCscWritePrologue (
      IN OUT PRX_CONTEXT RxContext,
      OUT    SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      )
/*++

Routine Description:

   This routine just performs the correct write synchronization.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    NTSTATUS AcquireStatus;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);

    BOOLEAN Disconnected;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE          UserBuffer = RxLowIoGetBufferAddress(RxContext);
    ULONGLONG      ByteOffset = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    ULONG          ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbCscWritePrologue entry(%08lx)...%08lx bytes @ %08lx on handle %08lx\n",
            RxContext,ByteCount,
            ((PLARGE_INTEGER)(&ByteOffset))->LowPart,smbSrvOpen->hfShadow ));

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);
                        



    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        ASSERT(!Disconnected);
    } else {
        if (Disconnected) {
            Status = MRxSmbCscWriteDisconnected(RxContext);
            RxDbgTrace(-1, Dbg,
                ("MRxSmbCscWritePrologue dcon(%08lx)... %08lx %08lx\n",
                    RxContext,Status,RxContext->InformationToReturn ));
            return(Status);
        }
    }

    AcquireStatus = MRxSmbCscAcquireSmbFcb(
                        RxContext,
                        Exclusive_SmbFcbAcquire,
                        SmbFcbHoldingState);

    if (AcquireStatus != STATUS_SUCCESS) {
        //we couldn't acquire.....get out
        Status = AcquireStatus;
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscWritePrologue couldn't acquire!!!-> %08lx %08lx\n",
                RxContext, Status ));
    }

    IF_DEBUG {
        if (Status == STATUS_SUCCESS) {
            RxCaptureFcb;
            PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
            ASSERT( smbFcb->CscOutstandingReaders < 0);
        }
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbCscWritePrologue exit-> %08lx %08lx\n", RxContext, Status ));
    return Status;
}

VOID
MRxSmbCscWriteEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a write operation for CSC. In
   particular, if the written data overlaps or extends the cached prefix
   then we write the data into the cache.

   The status of the write operation is passed in case we someday find
   things are so messed up that we want to return a failure even after
   a successful read. not today however...

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS LocalStatus;
    ULONG ShadowFileLength;
    LONG iRet;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE UserBuffer = RxLowIoGetBufferAddress(RxContext);
    ULONGLONG ByteOffset = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    ULONG ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
    ULONG WriteLength = (ULONG)RxContext->InformationToReturn;
    BOOLEAN EnteredCriticalSection = FALSE;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbCscWriteEpilogue entry %08lx...%08lx bytes @ %08lx on handle %08lx\n",
            RxContext, ByteCount,
            ((PLARGE_INTEGER)(&ByteOffset))->LowPart,
            smbSrvOpen->hfShadow ));

    if ((*Status != STATUS_SUCCESS) || (WriteLength ==0)) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscWriteEpilogue exit w/o extending -> %08lx\n", Status ));
        goto FINALLY;
    }

    if (smbFcb->ShadowIsCorrupt) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscWriteEpilogue exit w/o extending sh_corrupt-> %08lx\n", Status ));
        goto FINALLY;
    }

    // remember that modifications have happened
    // so that we can update the time stamp at close
    mSetBits(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED);

    CscEnterShadowReadWriteCrit(smbFcb);
    EnteredCriticalSection = TRUE;

    // check whether we are extend overlapping the prefix
    iRet = GetFileSizeLocal((CSCHFILE)(smbSrvOpen->hfShadow), &ShadowFileLength);
    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscWriteEpilogue %08lx (st=%08lx) fsize= %08lx, writelen=%08lx\n",
            RxContext, iRet, ShadowFileLength, WriteLength));

    if (iRet <0) {
        goto FINALLY;
    }

    if (!mShadowSparse(smbFcb->ShadowStatus)
                     || (ByteOffset <= ShadowFileLength)) {
        ULONG LengthActuallyWritten;
        NTSTATUS ShadowWriteStatus;
        // do a write only if there is non-zero size data to be written.
        if (RxContext->InformationToReturn)
        {

            RxDbgTrace(0, Dbg,
                 ("MRxSmbCscWriteEpilogue writing  %08lx bytes\n", WriteLength ));

            ShadowWriteStatus = MRxSmbCscShadowWrite(
                                    RxContext,
                                    (ULONG)RxContext->InformationToReturn,
                                    ShadowFileLength,
                                    &LengthActuallyWritten);

            if (LengthActuallyWritten != WriteLength) {
                //the localwrite has failedso the shadowis now corrupt!
                smbFcb->ShadowIsCorrupt = TRUE;
                RxDbgTrace(0, Dbg, ("MRxSmbCscWriteEpilogue: Shadow Is Now corrupt"
                                  "  %08lx %08lx %08lx\n",
                               ShadowWriteStatus,
                               LengthActuallyWritten,
                               WriteLength  ));
            }
        }
    }

FINALLY:
    if (EnteredCriticalSection) {
        CscLeaveShadowReadWriteCrit(smbFcb);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscWriteEpilogue exit-> %08lx %08lx\n", RxContext, Status ));
    return;
}

// this is used to do pagesized read-before-write
// CHAR xMRxSmbCscSideBuffer[PAGE_SIZE];

NTSTATUS
MRxSmbCscShadowWrite (
      IN OUT PRX_CONTEXT RxContext,
      IN     ULONG       ByteCount,
      IN     ULONGLONG   ShadowFileLength,
         OUT PULONG LengthActuallyWritten
      )
/*++

Routine Description:

   This routine performs a shadowwrite. it uses unbuffered write doing
   prereads as necessary. sigh. we cannot use buffered write because such
   a write could be arbitrarily deferred (as in CcCanIWrite) so that we
   deadlock.
   

Arguments:

    RxContext - the RDBSS context

Return Value:
       RxPxBuildAsynchronousRequest

Notes:

CODE.IMPROVEMENT.ASHAMED if we could get a nondeferrable cached write....we
would only have to do all this nobuffered stuff under intense memory pressure
instead of all the time.

The routine does this in (potentially) 3 phases

1) If the starting offset is not aligned on a page boundary then
   - read from the earlier page boundary to the next page boundary to the starting offset
   - merge the passed in buffer
   - write the whole page

2) 0 or more page size writes

3) residual write of less than page size, similar to what is explained in 1) above


--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE UserBuffer = RxLowIoGetBufferAddress(RxContext);

    LARGE_INTEGER ByteOffset,EndBytePlusOne;
    ULONG MisAlignment,InMemoryMisAlignment;
    ULONG LengthRead,BytesToCopy,BytesToWrite,LengthWritten;
    CHAR *pAllocatedSideBuffer = NULL;

    IO_STATUS_BLOCK IoStatusBlock;

    BOOLEAN PagingIo = BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,
                                     LOWIO_READWRITEFLAG_PAGING_IO);

    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow);


    ByteOffset.QuadPart     = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    EndBytePlusOne.QuadPart = ByteOffset.QuadPart + ByteCount;
    *LengthActuallyWritten  = 0;

    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    pAllocatedSideBuffer = RxAllocatePoolWithTag(
                               NonPagedPool,
                               PAGE_SIZE,
                               MRXSMB_MISC_POOLTAG );

    if (pAllocatedSideBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // In attempting to do the write there are a multitude of error cases. The
    // following for loop is a scoping construct to ensure that the recovery
    // code can be concentrated in the tail of the routine.

    try {
        RxDbgTrace(
            +1, Dbg,
            ("MRxSmbCscShadowWrite %08lx len/off=%08lx %08lx %08lx %08lx\n",
            RxContext,ByteCount,ByteOffset.LowPart,UserBuffer,&pAllocatedSideBuffer[0]));

        // CASE 1: byteoffset is not aligned
        //         we write enough to get aligned.

        MisAlignment = ByteOffset.LowPart & (PAGE_SIZE - 1);
        if ( MisAlignment != 0) {
            LARGE_INTEGER AlignedOffset = ByteOffset;

            AlignedOffset.LowPart &= ~(PAGE_SIZE - 1);

            RtlZeroMemory(
                &pAllocatedSideBuffer[0],
                PAGE_SIZE);

            //if the aligned offset is within the file, we have to read
            if ((ShadowFileLength!=0) &&
                (AlignedOffset.QuadPart < ((LONGLONG)(ShadowFileLength)) )) {
                LengthRead = Nt5CscReadWriteFileEx (
                                 R0_READFILE,
                                (CSCHFILE)MiniFileObject,
                                 AlignedOffset.QuadPart,
                                 &pAllocatedSideBuffer[0],
                                 PAGE_SIZE,
                                 NT5CSC_RW_FLAG_IRP_NOCACHE,
                                 &IoStatusBlock
                                 );

                Status = IoStatusBlock.Status;

                if ((Status != STATUS_SUCCESS) &&
                    (Status != STATUS_END_OF_FILE)) {
                    RxDbgTrace (
                        -1, Dbg,
                        ("  -->Status/count after preread failed %08lx(%08lx,%08lx)\n",
                        RxContext,Status,*LengthActuallyWritten));
                    try_return(Status);
                }
            } else {
                LengthRead = 0;
            }

            //copy the right bytes into the buffer
            BytesToCopy = min(ByteCount,PAGE_SIZE-MisAlignment);

            RtlCopyMemory(
                &pAllocatedSideBuffer[0]+MisAlignment,
                UserBuffer,
                BytesToCopy);

            BytesToWrite = MisAlignment + BytesToCopy;

            if (BytesToWrite < LengthRead) {
                BytesToWrite = LengthRead;
            }

            RxDbgTrace(
                0, Dbg,
                ("alignwrite len/off=%08lx %08lx %08lx\n",
                BytesToWrite,AlignedOffset.LowPart,0));

            LengthWritten = Nt5CscReadWriteFileEx (
                                R0_WRITEFILE,
                               (CSCHFILE)MiniFileObject,
                                AlignedOffset.QuadPart,
                                &pAllocatedSideBuffer[0],
                                BytesToWrite,
                                NT5CSC_RW_FLAG_IRP_NOCACHE,
                                &IoStatusBlock
                                );

            Status = IoStatusBlock.Status;

            if (Status != STATUS_SUCCESS) {
                RxDbgTrace (
                    -1, Dbg,
                    ("  -->Status/count after alingwrite failed %08lx(%08lx,%08lx)\n",
                    RxContext,Status,*LengthActuallyWritten));
                try_return(Status);
            }

            *LengthActuallyWritten += BytesToCopy;
            if (BytesToCopy == ByteCount) {
                RxDbgTrace (-1, Dbg,
                         ("  -->Status/count after alingwrite succeded and out %08lx(%08lx,%08lx)\n",
                         RxContext,Status,*LengthActuallyWritten));
                try_return(Status);
            }

            ByteCount -= BytesToCopy;
            ByteOffset.QuadPart += BytesToCopy;
            UserBuffer += BytesToCopy;
        }

        //  CASE 2 with an aligned startpointer, we write out as much as we can
        //         without copying. if the endpointer is aligned OR we cover the
        //         end of the file, then we write out everything. otherwise, we
        //         just write however many whole pages we have.

        // we also have to back to to just writing full pages if including the
        // "trailing bytes" would take us onto a new physical page of memory
        // because we are doing this write under the original Mdl lock.

        RxDbgTrace(
            +1, Dbg,
            ("MRxSmbCscShadowWrite case 2 %08lx len/off=%08lx %08lx %08lx %08lx\n",
            RxContext,ByteCount,ByteOffset.LowPart,UserBuffer,&pAllocatedSideBuffer[0]));

        BytesToWrite = (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT;

        MisAlignment = EndBytePlusOne.LowPart & (PAGE_SIZE - 1);
        InMemoryMisAlignment = (ULONG)((ULONG_PTR)UserBuffer) & (PAGE_SIZE - 1);

        if ((InMemoryMisAlignment == 0) &&
            (EndBytePlusOne.QuadPart) >= ((LONGLONG)ShadowFileLength)) {
            BytesToWrite = ByteCount;
        }

        if ((BytesToWrite != 0)&&(BytesToWrite>=PAGE_SIZE)) {
            if (((ULONG_PTR)UserBuffer & 0x3) == 0) {
                RxDbgTrace(
                    0, Dbg,
                    ("spaningwrite len/off=%08lx %08lx %08lx %08lx\n",
                    BytesToWrite,ByteCount,ByteOffset.LowPart,UserBuffer));

                LengthWritten = Nt5CscReadWriteFileEx (
                                    R0_WRITEFILE,
                                    (CSCHFILE)MiniFileObject,
                                    ByteOffset.QuadPart,
                                    UserBuffer,
                                    BytesToWrite,
                                    NT5CSC_RW_FLAG_IRP_NOCACHE,
                                    &IoStatusBlock
                                    );

                Status = IoStatusBlock.Status;

                if (Status != STATUS_SUCCESS) {
                    RxDbgTrace (
                        -1, Dbg,
                        ("  -->Status/count after spanningingwrite failed %08lx(%08lx,%08lx)\n",
                        RxContext,Status,*LengthActuallyWritten));
                    try_return(Status);
                }

                *LengthActuallyWritten += BytesToWrite;

                if (BytesToWrite == ByteCount) {
                    RxDbgTrace (
                        -1, Dbg,
                        ("  -->Status/count after spanningingwrite succeded and out %08lx(%08lx,%08lx)\n",
                        RxContext,Status,*LengthActuallyWritten));
                    try_return(Status);
                }

                ByteCount -= BytesToWrite;
                ByteOffset.QuadPart += BytesToWrite;
                UserBuffer += BytesToWrite;
            } else {
                // This is the case when the offsets are aligned but the user supplied
                // buffer is not aligned. In such cases we have to resort to copying
                // the user supplied buffer onto the local buffer allocated and then
                // spin out the writes

                while (BytesToWrite > 0) {
                    ULONG BytesToWriteThisIteration;

                    BytesToWriteThisIteration = (BytesToWrite < PAGE_SIZE) ?
                                                BytesToWrite :
                                                PAGE_SIZE;

                    RtlCopyMemory(
                        &pAllocatedSideBuffer[0],
                        UserBuffer,
                        BytesToWriteThisIteration);

                    LengthWritten = Nt5CscReadWriteFileEx (
                                        R0_WRITEFILE,
                                        (CSCHFILE)MiniFileObject,
                                        ByteOffset.QuadPart,
                                        &pAllocatedSideBuffer[0],
                                        BytesToWriteThisIteration,
                                        NT5CSC_RW_FLAG_IRP_NOCACHE,
                                        &IoStatusBlock
                                        );

                    Status = IoStatusBlock.Status;

                    if (Status != STATUS_SUCCESS) {
                        try_return(Status);
                    }

                    ByteCount -= LengthWritten;
                    ByteOffset.QuadPart += LengthWritten;
                    UserBuffer += LengthWritten;

                    *LengthActuallyWritten += LengthWritten;

                    BytesToWrite -= LengthWritten;
                }

                if (*LengthActuallyWritten == ByteCount) {
                    try_return(Status);
                }
            }
        }

        // CASE 3: we don't have the whole buffer, ByteCount is less than PAGE_SIZE

        RtlZeroMemory(&pAllocatedSideBuffer[0], PAGE_SIZE);

        RxDbgTrace(
            +1, Dbg,
            ("MRxSmbCscShadowWrite case 3 %08lx len/off=%08lx %08lx %08lx %08lx\n",
            RxContext,ByteCount,ByteOffset.LowPart,
                                UserBuffer,
                                &pAllocatedSideBuffer[0]));


        LengthRead = Nt5CscReadWriteFileEx (
                         R0_READFILE,
                         (CSCHFILE)MiniFileObject,
                         ByteOffset.QuadPart,
                         &pAllocatedSideBuffer[0],
                         PAGE_SIZE,
                         NT5CSC_RW_FLAG_IRP_NOCACHE,
                         &IoStatusBlock
                         );

        Status = IoStatusBlock.Status;
        if ((Status != STATUS_SUCCESS) &&
                (Status != STATUS_END_OF_FILE)) {
            RxDbgTrace (-1, Dbg,
                     ("  -->Status/count after punkread failed %08lx(%08lx,%08lx)\n",
                     RxContext,Status,*LengthActuallyWritten));
            try_return(Status);
        }

        RtlCopyMemory(&pAllocatedSideBuffer[0],UserBuffer,ByteCount);
        BytesToWrite = ByteCount;
        
        // here, if the ByetsToWrite is not sector aligned, it gets so
        // because LeghthRead must be sector aligned

        if (BytesToWrite < LengthRead) {
            BytesToWrite = LengthRead;
        }

        RxDbgTrace(0, Dbg, ("punkwrite len/off=%08lx %08lx %08lx\n",
                                BytesToWrite,
                                ByteOffset.LowPart,
                                UserBuffer));
        if (BytesToWrite)
        {
            LengthWritten = Nt5CscReadWriteFileEx (
                                R0_WRITEFILE,
                                (CSCHFILE)MiniFileObject,
                                ByteOffset.QuadPart,
                                &pAllocatedSideBuffer[0],
                                BytesToWrite,
                                NT5CSC_RW_FLAG_IRP_NOCACHE,
                                &IoStatusBlock
                                );
            Status = IoStatusBlock.Status;
            if (Status != STATUS_SUCCESS) {
                RxDbgTrace (-1, Dbg,
                         ("  -->Status/count after punkwrite failed %08lx(%08lx,%08lx)\n",
                         RxContext,Status,*LengthActuallyWritten));
                try_return(Status);
            }
        }

        *LengthActuallyWritten += ByteCount;
        RxDbgTrace (-1, Dbg,
                 ("  -->Status/count after punkwrite succeded and out %08lx(%08lx,%08lx)\n",
                 RxContext,Status,*LengthActuallyWritten));

    try_exit: NOTHING;
    } finally {
        ASSERT(pAllocatedSideBuffer);
        RxFreePool(pAllocatedSideBuffer);
    }

    return(Status);
}


#ifdef MRXSMB_BUILD_FOR_CSC_DCON
NTSTATUS
MRxSmbDCscExtendForCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine performs the extend-for-cache operation. if connected, the
   cache is backed up by the server's disk....so we do nothing. if disconnected,
   we extend on the underlying shadow file by writing a zero in a good place and then
   reading back the allocation size.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;

    ULONG Buffer = 0;
    ULONG LengthActuallyWritten;
    LARGE_INTEGER ByteOffset;
    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow);

    IO_STATUS_BLOCK IoStatusBlock;


    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (!Disconnected) {
        return(Status);
    }

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscExtendForCache(%08lx)...%08lx/%08lx @ %08lx on handle %08lx\n",
            RxContext,pNewFileSize->LowPart,
            pNewAllocationSize->LowPart,smbSrvOpen->hfShadow ));

    ByteOffset.QuadPart = pNewFileSize->QuadPart - 1;

    LengthActuallyWritten = Nt5CscReadWriteFileEx (
                                R0_WRITEFILE,
                                (CSCHFILE)MiniFileObject,
                                ByteOffset.QuadPart,
                                &Buffer,
                                1,
                                0,
                                &IoStatusBlock
                                );

    if (LengthActuallyWritten != 1) {
        Status = IoStatusBlock.Status;
        RxDbgTrace(0, Dbg,
            ("MRxSmbDCscExtendForCache(%08lx) write error... %08lx\n",RxContext,Status));
        goto FINALLY;
    }

    //MiniFileObject->StandardInfo.EndOfFile.LowPart = 0xfffffeee;

    Status = Nt5CscXxxInformation(
                    (PCHAR)IRP_MJ_QUERY_INFORMATION,
                    MiniFileObject,
                    FileStandardInformation,
                    sizeof(MiniFileObject->StandardInfo),
                    &MiniFileObject->StandardInfo,
                    &MiniFileObject->ReturnedLength
                    );

    if (Status != STATUS_SUCCESS) {
       RxDbgTrace(0, Dbg,
            ("MRxSmbDCscExtendForCache(%08lx) qfi error... %08lx\n",RxContext,Status));
       goto FINALLY;
    }

    *pNewAllocationSize = MiniFileObject->StandardInfo.AllocationSize;

FINALLY:

    RxDbgTrace(-1, Dbg,
        ("MRxSmbDCscExtendForCache(%08lx) exit...%08lx/%08lx @ %08lx, status %08lx\n",
            RxContext,pNewFileSize->LowPart,
            pNewAllocationSize->LowPart,smbSrvOpen->hfShadow ));

    return(Status);

}



NTSTATUS
MRxSmbCscWriteDisconnected (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs the correct write when we're disconnected. it
   calls the same routine for writing (ShadowWrite) as connected mode writes.
   ShadowWrite requires the filelength for its correct operation; in
   disconnected mode, we just get this out of the smb!

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);

    PFCB wrapperFcb = (PFCB)(capFcb); 
    ULONGLONG ShadowFileLength;
    ULONG LengthActuallyWritten;
    ULONG ByteCount = RxContext->LowIoContext.ParamsFor.ReadWrite.ByteCount;
    ULONGLONG   ByteOffset;
    BOOLEAN EnteredCriticalSection = FALSE;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry =
                  SmbCeGetAssociatedNetRootEntry(NetRoot);
#if defined(BITCOPY)
    ULONG * lpByteOffset;
#endif // defined(BITCOPY)


    ByteOffset = RxContext->LowIoContext.ParamsFor.ReadWrite.ByteOffset;

    IF_DEBUG {
        PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
             = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
        PSMBCEDB_SERVER_ENTRY   pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
        BOOLEAN Disconnected;

        Disconnected = (BooleanFlagOn(
                           smbSrvOpen->Flags,
                           SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN)||
                        SmbCeIsServerInDisconnectedMode(pServerEntry));


        ASSERT(Disconnected);
    }

    IF_DEBUG {
        ASSERT_MINIRDRFILEOBJECT((PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow));

        RxDbgTrace(+1, Dbg,
            ("MRxSmbCscWriteDisconnected entry(%08lx)...%08lx bytes @ %08lx on handle %08lx\n",
                RxContext,ByteCount,
                (ULONG)ByteOffset,smbSrvOpen->hfShadow ));
    }

    // remember that modifications have happened
    // so that we can update the time stamp at close
    mSetBits(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED);

    CscEnterShadowReadWriteCrit(smbFcb);
    EnteredCriticalSection = TRUE;

    ShadowFileLength = wrapperFcb->Header.FileSize.QuadPart;

    Status = MRxSmbCscShadowWrite(
                 RxContext,
                 ByteCount,
                 ShadowFileLength,
                 &LengthActuallyWritten);

    RxContext->InformationToReturn = LengthActuallyWritten;

#if defined(BITCOPY)
    // Mark the bitmap, if it exists
    lpByteOffset = (ULONG*)(LPVOID)&ByteOffset;
    if (Status == STATUS_SUCCESS) {
        CscBmpMark(smbFcb->lpDirtyBitmap,
            lpByteOffset[0],
            LengthActuallyWritten);
    }
#endif // defined(BITCOPY)

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscWriteDisconnected(%08lx) write error... %08lx %08lx %08lx\n",
                        RxContext,Status,ByteCount,LengthActuallyWritten));
        goto FINALLY;
    }
    else
    {
        // note the fact that this replica is dirty and it's data would have to merged
        smbFcb->ShadowStatus |= SHADOW_DIRTY;

        // if the file has gotten extended, then notify the change
        if ((ByteOffset+LengthActuallyWritten) > ShadowFileLength)
        {
            FsRtlNotifyFullReportChange(
                pNetRootEntry->NetRoot.pNotifySync,
                &pNetRootEntry->NetRoot.DirNotifyList,
                (PSTRING)GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                (USHORT)(GET_ALREADY_PREFIXED_NAME(NULL, capFcb)->Length -
                smbFcb->MinimalCscSmbFcb.LastComponentLength),
                NULL,
                NULL,
                FILE_NOTIFY_CHANGE_SIZE,
                FILE_ACTION_MODIFIED,
                NULL);
        }
    }


FINALLY:
    if (EnteredCriticalSection) {
        CscLeaveShadowReadWriteCrit(smbFcb);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscWriteDisconnected exit-> %08lx %08lx\n", RxContext, Status ));
    return Status;
}

#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\transitn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    transitn.c

Abstract:

    This module implements the routines for transitioning from the connected mode
    and vice versa

Author:

    Balan Sethu Raman [SethuR]    11 - November - 1997

Revision History:

Notes:

    The transition of a connection from a connected mode to a disconnected mode
    and vice versa is guided by the principles of transparency and fideltiy.

    The principle of transparency demands that the transition be made smoothly
    on the detection of the appropriate condition without any user intervention
    if at all possible and the principle of fidelity relies upon the notion of
    truth and the responsibility for its maintenance. If we wish to adhere to the
    opinion that the client has the truth at all times and the server is merely
    a convenient repositiory for snapshots of the truth one set of semantics falls
    out. On the other hand we could insist that the server has the truth at all
    times and the client caches snapshots of the truth for offline availability
    and performance gains from avoiding network traffic a different set of
    semantics falls out. Note that under certain scenarios the both schemes yield
    identical results, i.e., absence of file sharing.

    Transitioning from connected mode to disconnected mode
    ------------------------------------------------------

    When transitioning from connected mode it is important to consider existing
    connections and the existing file system objects. In the mini redirector
    terminology it is the SRV_CALL, NET_ROOT instances and the FCB instances that
    are important.

    The trigger for the transition is normally due to the occurence of one of the
    following two events.

    1) all the existing transports are going away, because the user has unplugged
    the net.

    2) an ongoing operation on the connection returns an error that indicates that
    the server is no longer accessible.

    These two cases are different -- the first one indicates the unavailability
    of net for a potentially long period of time and the second one indicates a
    transient loss of the net. Consequently we treat these two different events
    in different ways -- the first one triggers a top down transition to a
    disconnected mode while the second one triggers a bottom up transition to a
    disconnected mode. As an example consider the case when we have two files
    foo.doc, foo1.doc open on a particular share. When we get an indication that
    the net is no longer available, we mark the SRV_CALL and NET_ROOT instances
    as having transitioned to the disconnected mode. This automatically entails
    that as file system operations are performed on the various open files, foo.doc
    foo1.doc respectively the corresponding transition occurs.

    On the other hand if there was an error in a particular operation of foo.doc
    then the transition to disconected mode is done for the appropriate FCB alone.
    Thus if we open a new file immediately after that and the net becomes
    available we go on the net for opening the second file.

    However, owing to the multi step renames that apps use we forego this option.
    Thus the following distinction needs to be made. When no FCB instances are
    open and an error occurs we delay the transition till a open request comes
    through. This will allow us to mask some transient failures on the NET.

--*/


#include "precomp.h"
#pragma hdrstop
#include "acd.h"
#include "acdapi.h"
#include "ntddmup.h"

#pragma code_seg("PAGE")

#define Dbg (DEBUG_TRACE_MRXSMBCSC_TRANSITN)
RXDT_DefineCategory(MRXSMBCSC_TRANSITN);

#define CSC_AUTODIAL_POLL_COUNT  10
#define INVALID_SESSION_ID 0xffffffff

BOOLEAN
CscIsSpecialShare(
    PUNICODE_STRING ShareName);

#define UNICODE_STRING_STRUCT(s) \
        {sizeof(s) - sizeof(WCHAR), sizeof(s) - sizeof(WCHAR), (s)}

static UNICODE_STRING CscSpecialShares[] = {
    UNICODE_STRING_STRUCT(L"PIPE"),
    UNICODE_STRING_STRUCT(L"IPC$"),
    UNICODE_STRING_STRUCT(L"ADMIN$"),
    UNICODE_STRING_STRUCT(L"MAILSLOT")
};

KEVENT       CscServerEntryTransitioningEvent;
FAST_MUTEX   CscServerEntryTransitioningMutex;

PSMBCEDB_SERVER_ENTRY   CscServerEntryBeingTransitioned  = NULL;
ULONG                   CscSessionIdCausingTransition = 0;
HSHARE                  CscShareHandlePassedToAgent;
BOOLEAN                 vfRetryFromUI = FALSE;
PSMBCEDB_SERVER_ENTRY   CscDfsRootServerEntryBeingTransitioned  = NULL;

BOOLEAN CscDisableOfflineOperation = FALSE;
ULONG   hTransitionMutexOwner=0;

BOOLEAN CSCCheckForAcd(VOID);

BOOLEAN CscTransitnOKToGoOffline(
    NTSTATUS    RemoteStatus
    );

BOOLEAN
CscIsServerOffline(
    PWCHAR ServerName)
/*++

Routine Description:

   This routine initiates the processing of a transition request by notifying
   the agent and waiting for the response.

Arguments:

    ServerName - the server name


Return Value:

    returns TRUE if the server entry is offline

Notes:

    If ServerName is NULL we return the status of the Net

--*/
{
    BOOLEAN ServerOffline;
    DWORD   cntSlashes;
    UNICODE_STRING uniTemp;

    ServerOffline = (CscNetPresent == 0);

    if (ServerName != NULL) {
        PSMBCEDB_SERVER_ENTRY pServerEntry;
        USHORT                ServerNameLengthInBytes;
        PWCHAR                pTempName;
        UNICODE_STRING        ServerNameString;

        ServerOffline = FALSE;

        pTempName = ServerName;
        ServerNameLengthInBytes = 0;
        cntSlashes = 0;

        if (*pTempName == L'\\')
        {
            ++pTempName;
            ++cntSlashes;
        }

        if (*pTempName == L'\\')
        {
            ++pTempName;
            ++cntSlashes;
        }

        // we allow \\servername or servername (with no \\)
        if (cntSlashes == 1)
        {
            return FALSE;
        }

        while (*pTempName++ != L'\0') {
            ServerNameLengthInBytes += sizeof(WCHAR);
        }

        ServerNameString.MaximumLength = ServerNameString.Length = ServerNameLengthInBytes;
        ServerNameString.Buffer        = ServerName+cntSlashes;

        SmbCeAcquireResource();

        try
        {
            pServerEntry = SmbCeGetFirstServerEntry();
            while (pServerEntry != NULL) {

                uniTemp = pServerEntry->Name;

                // skip the single backslash on the server entry name
                uniTemp.Length -= sizeof(WCHAR);
                uniTemp.Buffer += 1;

                if (uniTemp.Length == ServerNameLengthInBytes) {
                    if (RtlCompareUnicodeString(
                            &uniTemp,
                            &ServerNameString,
                            TRUE) == 0) {

                        ServerOffline = SmbCeIsServerInDisconnectedMode(pServerEntry);

                        break;
                    }
                }

                pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            SmbCeReleaseResource();
            return FALSE;
        }

        SmbCeReleaseResource();

        if (!pServerEntry && !CscNetPresent)
        {
            HSHARE  CscShareHandle = 0;
            ULONG    ulRootHintFlags=0;

            GetHShareFromUNCString(
                ServerNameString.Buffer,
                ServerNameString.Length,
                2,      // No double-leading backslashes in the name passed in
                FALSE,  // server name
                &CscShareHandle,
                &ulRootHintFlags);
            ServerOffline = (CscShareHandle != 0);
        }
    }

    return ServerOffline;
}


NTSTATUS
CscTakeServerOffline(
    PWCHAR ServerName)
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    UNICODE_STRING ServerNameString;
    UNICODE_STRING tmpSrvName;
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;

    // DbgPrint("CscTakeServerOffline(%ws)\n", ServerName);

    if (ServerName == NULL) {
        Status = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }
    // Clip leading backslashes
    while (*ServerName == L'\\') {
        ServerName++;
    }
    RtlInitUnicodeString(&ServerNameString, ServerName);
    // Scan list of server entries looking for this one
    SmbCeAcquireResource();
    try {
        pServerEntry = SmbCeGetFirstServerEntry();
        while (pServerEntry != NULL) {
            if (pServerEntry->Server.CscState == ServerCscShadowing) {
                if (pServerEntry->DfsRootName.Length > 0) {
                    tmpSrvName = pServerEntry->DfsRootName;
                    tmpSrvName.Length -= sizeof(WCHAR);
                    tmpSrvName.Buffer += 1;
                    if (RtlCompareUnicodeString(&tmpSrvName, &ServerNameString, TRUE) == 0)
                        break;
                } else {
                    tmpSrvName = pServerEntry->Name;
                    tmpSrvName.Length -= sizeof(WCHAR);
                    tmpSrvName.Buffer += 1;
                    if (RtlCompareUnicodeString(&tmpSrvName, &ServerNameString, TRUE) == 0)
                        break;
                }
            }
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SmbCeReleaseResource();
        Status = ERROR_INVALID_PARAMETER;
    }
    if (pServerEntry != NULL) {
        // DbgPrint("Found ServerEntry@0x%x\n", pServerEntry);
        SmbCeReferenceServerEntry(pServerEntry);
        SmbCeReleaseResource();
        Status = CscTransitionServerEntryForDisconnectedOperation(
            pServerEntry,
            NULL,
            STATUS_BAD_NETWORK_NAME,
            FALSE);
        // Mark it so it will not auto-reconnect
        if (Status == STATUS_SUCCESS)
            pServerEntry->Server.IsPinnedOffline = TRUE;
        SmbCeDereferenceServerEntry(pServerEntry);
    } else {
        SmbCeReleaseResource();
    }

AllDone:
    return Status;
}

BOOLEAN
CscCheckWithAgentForTransitioningServerEntry(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SessionId,
    HSHARE                  AgentShareHandle,
    BOOLEAN                 fInvokeAutoDial,
    BOOLEAN                 *lpfRetryFromUI,
    PSMBCEDB_SERVER_ENTRY   *pDfsRootServerEntry
    )
/*++

Routine Description:

   This routine initiates the processing of a transition request by notifying
   the agent and waiting for the response.

Arguments:

    pServerEntry  - the server entry

    pNetRootEntry - the net root entry instance

Return Value:

    returns TRUE if the server entry was transitioned for offlien operation

--*/
{
    LONG    cntTransportsForCSC=0;
    BOOLEAN TransitionedServerEntry, OkToTransition = FALSE;
    PSMBCEDB_SERVER_ENTRY   pTempServerEntry = NULL;

    if(!MRxSmbIsCscEnabled) {
        return(FALSE);
    }

//    DbgPrint("CscCheckWithAgent %wZ \n", &pServerEntry->Name);

    ExAcquireFastMutex(&CscServerEntryTransitioningMutex);

    hTransitionMutexOwner = GetCurThreadHandle();
    if (pServerEntry->DfsRootName.Length != 0)
    {
        PSMBCEDB_SERVER_ENTRY pThisServerEntry;
        PSMBCEDB_SERVER_ENTRY pNextServerEntry;

        SmbCeAcquireResource();

        pThisServerEntry = SmbCeGetFirstServerEntry();

        while (pThisServerEntry != NULL) {
            pNextServerEntry = SmbCeGetNextServerEntry(pThisServerEntry);

            if (RtlEqualUnicodeString(&pServerEntry->DfsRootName,
                                          &pThisServerEntry->Name,
                                          TRUE)) {

//                DbgPrint("CscCheckWithAgent DfsRoot %wZ \n", &pThisServerEntry->Name);
                pTempServerEntry = pThisServerEntry;

                break;
            }

            pThisServerEntry = pNextServerEntry;
        }
        SmbCeReleaseResource();
    }


    CscServerEntryBeingTransitioned  = pServerEntry;
    CscDfsRootServerEntryBeingTransitioned = pTempServerEntry;
    CscShareHandlePassedToAgent     = AgentShareHandle;
    vfRetryFromUI = FALSE;

    KeResetEvent(&CscServerEntryTransitioningEvent);

    OkToTransition = (!SmbCeIsServerInDisconnectedMode(pServerEntry)||
                      (pTempServerEntry && !SmbCeIsServerInDisconnectedMode(pTempServerEntry)));

    if (OkToTransition) {

        // This is dropped in MRxSmbCscSignalAgent
        EnterShadowCrit();

        SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_SHARE_DISCONNECTED);
        if (fInvokeAutoDial)
        {
            SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_INVOKE_AUTODIAL);
        }
        sGS.hShareDisconnected = AgentShareHandle;

        CscSessionIdCausingTransition = SessionId;

        MRxSmbCscSignalAgent(
            NULL,
            SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);

        KeWaitForSingleObject(
            &CscServerEntryTransitioningEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    }

    TransitionedServerEntry = (SmbCeIsServerInDisconnectedMode(pServerEntry) &&
                               (!pTempServerEntry || SmbCeIsServerInDisconnectedMode(pTempServerEntry)));

    *pDfsRootServerEntry = pTempServerEntry;

    CscServerEntryBeingTransitioned  = NULL;
    CscShareHandlePassedToAgent     = 0;
    CscDfsRootServerEntryBeingTransitioned = NULL;
    CscSessionIdCausingTransition = 0;
    *lpfRetryFromUI = vfRetryFromUI;
    hTransitionMutexOwner = 0;
    ExReleaseFastMutex(&CscServerEntryTransitioningMutex);

    return TransitionedServerEntry;
}

NTSTATUS
CscTransitionServerToOffline(
    ULONG SessionId,
    HSHARE hShare,
    ULONG   TransitionStatus)
/*++

Routine Description:

   This routine updates the RDR data structures based upon the decision of the
   agent

Arguments:

    hShare - the shadow handle to the server

    TransitionStatus -- it is tri state value.
        0 implies retry the operation.
        1 transition this server for offline operation
        anything else means fail

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    LONG CscState = ServerCscShadowing;

    if(!MRxSmbIsCscEnabled) {
        return(STATUS_UNSUCCESSFUL);
    }

    // DbgPrint("CscTransitionServerToOffline: Share 0x%x SessionId 0x%x (vs 0x%x)\n",
    //                 hShare,
    //                 SessionId,
    //                 CscSessionIdCausingTransition);

    switch (TransitionStatus) {
    case 1 :
        if (fShadow &&  // only if CSC is turned ON by the agent do we go disconnected
            CscServerEntryBeingTransitioned &&  // there is a server entry (this must be true
            CscSessionIdCausingTransition == SessionId &&  // The right session
            CscShareHandlePassedToAgent    // and we have a share in the database
            )
        {
            // then it is OK to go disconnected
            CscState = ServerCscDisconnected;
        }
        break;


    case 0 :  // UI said retry
        vfRetryFromUI = TRUE;
        break;

    default:
        break;
    }


    if (CscServerEntryBeingTransitioned != NULL && SessionId == CscSessionIdCausingTransition) {
//        DbgPrint("CscTransitionServerToOffline %wZ \n", &CscServerEntryBeingTransitioned->Name);
        InterlockedExchange(
                &CscServerEntryBeingTransitioned->Server.CscState,
                CscState);

        // DbgPrint("CscTransitionServerToOffline %wZ Sess 0x%x\n",
        //         &CscServerEntryBeingTransitioned->Name,
        //         SessionId);

        if (CscDfsRootServerEntryBeingTransitioned)
        {
            // if this is an alternate, then also put the
            // dfs root in disconnected state if it isn't already

            if (!SmbCeIsServerInDisconnectedMode(CscDfsRootServerEntryBeingTransitioned))
            {
                SmbCeReferenceServerEntry(CscDfsRootServerEntryBeingTransitioned);
            }

            InterlockedExchange(
                    &CscDfsRootServerEntryBeingTransitioned->Server.CscState,
                    CscState);

        }

        // Signal the event on which the other requests in the RDR are waiting
        KeSetEvent(
            &CscServerEntryTransitioningEvent,
            0,
            FALSE );
    } else {
//        ASSERT(!"No server entry is transitioning to offline");
    }


    return STATUS_SUCCESS;
}

VOID
CscPrepareServerEntryForOnlineOperation(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    BOOL    fGoAllTheWay
    )
/*++

Routine Description:

   This routine transitions a given server entry for online operation

Arguments:

    pServerEntry - the server entry that needs to be transitioned
    NTSTATUS - The return status for the operation

--*/
{
    PSMBCEDB_SESSION_ENTRY      pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY     pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT   pVNetRootContext;

    LONG CscState;

    SmbCeLog(("Transition SE %lx fGoAllTheWay=%d\n",pServerEntry, fGoAllTheWay));
    SmbLog(LOG,
           CscPrepareServerEntryForOnlineOperation_1,
           LOGULONG(fGoAllTheWay)
           LOGPTR(pServerEntry)
           LOGUSTR(pServerEntry->Name));

    if (fGoAllTheWay)
    {
        CscState = InterlockedCompareExchange(
                       &pServerEntry->Server.CscState,
                       ServerCscTransitioningToShadowing,
                       ServerCscDisconnected);
        if(pServerEntry->Server.IsFakeDfsServerForOfflineUse == TRUE)
        {
            HookKdPrint(TRANSITION, ("CscPrepareServerEntryForOnlineOperation: %x is a FAKE DFS entry, mark it for destruction \n", pServerEntry));
            pServerEntry->Header.State =  SMBCEDB_DESTRUCTION_IN_PROGRESS;
        }

        SmbCeLog(("Transition SE %lx %wZ fGoAllTheWay CscState=%x\n",pServerEntry, &pServerEntry->Name, CscState));
        SmbLog(LOG,
               CscPrepareServerEntryForOnlineOperation_2,
               LOGULONG(CscState)
               LOGPTR(pServerEntry)
               LOGUSTR(pServerEntry->Name));
    }

    if (!fGoAllTheWay || (CscState == ServerCscDisconnected)) {
        SmbCeLog(("Transition SE CO %lx, fGoAllTheWay=%d\n",pServerEntry, fGoAllTheWay));
        SmbLog(LOG,
               CscPrepareServerEntryForOnlineOperation_3,
               LOGULONG(fGoAllTheWay)
               LOGPTR(pServerEntry)
               LOGUSTR(pServerEntry->Name));

        InterlockedCompareExchange(
            &pServerEntry->Header.State,
            SMBCEDB_DESTRUCTION_IN_PROGRESS,
            SMBCEDB_ACTIVE);

        SmbCeReferenceServerEntry(pServerEntry);
        SmbCeResumeAllOutstandingRequestsOnError(pServerEntry);
        pServerEntry->ServerStatus = STATUS_CONNECTION_DISCONNECTED;

        if (fGoAllTheWay)
        {
            MRxSmbCSCResumeAllOutstandingOperations(pServerEntry);
            pServerEntry->Server.CscState = ServerCscShadowing;
            pServerEntry->Server.IsPinnedOffline = FALSE;
            SmbCeDereferenceServerEntry(pServerEntry);
        }
    }
}

VOID
CscPrepareServerEntryForOnlineOperationFull(
    PSMBCEDB_SERVER_ENTRY pServerEntry
    )
/*++

Routine Description:

   This routine transitions a given server entry for online operation

Arguments:

    pServerEntry - the server entry that needs to be transitioned
    NTSTATUS - The return status for the operation

--*/
{
    CscPrepareServerEntryForOnlineOperation(pServerEntry, TRUE);
}

VOID
CscPrepareServerEntryForOnlineOperationPartial(
    PSMBCEDB_SERVER_ENTRY pServerEntry
    )
/*++

Routine Description:

   This routine transitions a given server entry for online operation

Arguments:

    pServerEntry - the server entry that needs to be transitioned
    NTSTATUS - The return status for the operation

--*/
{
    CscPrepareServerEntryForOnlineOperation(pServerEntry, FALSE);
}

NTSTATUS
CscTransitionServerToOnline(
    HSHARE hShare)
/*++

Routine Description:

   This routine updates the RDR data structures based upon the decision of the
   agent

Arguments:

    hShare - the shadow handle to the server

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    SHAREINFOW sSR;
    NTSTATUS    Status=STATUS_INVALID_PARAMETER;

    if (hShare == 0) {

        Status=STATUS_SUCCESS;

        SmbCeLog(("Transtioning all servers online \n"));
        SmbLog(LOG,
               CscTransitionServerToOnline_1,
               LOGULONG(hShare));
        SmbCeAcquireResource();
        pServerEntry = SmbCeGetFirstServerEntry();
        while (pServerEntry != NULL) {
            PSMBCEDB_SERVER_ENTRY pNextServerEntry;

            pNextServerEntry = SmbCeGetNextServerEntry(pServerEntry);
            CscPrepareServerEntryForOnlineOperationFull(pServerEntry);
            pServerEntry = pNextServerEntry;
        }
        SmbCeReleaseResource();

    } else {
        int iRet;

        EnterShadowCrit();
        iRet = GetShareInfo(hShare, &sSR, NULL);
        LeaveShadowCrit();
        SmbCeLog(("Transtioning %ls online \n", sSR.rgSharePath));
        SmbLog(LOG,
               CscTransitionServerToOnline_2,
               LOGWSTR(sSR.rgSharePath));

        if (iRet >= 0)
        {
            Status = STATUS_SUCCESS;
            if ((FindServerEntryFromCompleteUNCPath(sSR.rgSharePath, &pServerEntry)) == STATUS_SUCCESS)
            {
                PSMBCEDB_SERVER_ENTRY pThisServerEntry;
                PSMBCEDB_SERVER_ENTRY pNextServerEntry;

//                DbgPrint("Close all open files on %wZ\n", &pServerEntry->Name);
                CloseOpenFiles(hShare, &pServerEntry->Name, 1); // skip one slash
                SmbCeAcquireResource();

                pThisServerEntry = SmbCeGetFirstServerEntry();
                while (pThisServerEntry != NULL) {
                    pNextServerEntry = SmbCeGetNextServerEntry(pThisServerEntry);

                    if (pThisServerEntry != pServerEntry &&
                        pThisServerEntry->DfsRootName.Length != 0) {
                        if (RtlEqualUnicodeString(&pThisServerEntry->DfsRootName,
                                                  &pServerEntry->Name,
                                                  TRUE)) {
                            SmbCeLog(("Go online ServerEntry With DFS name %x\n",pThisServerEntry));
                            SmbLog(LOG,
                                   CscTransitionServerToOnline_3,
                                   LOGPTR(pThisServerEntry)
                                   LOGUSTR(pThisServerEntry->Name));

                            CscPrepareServerEntryForOnlineOperationFull(pThisServerEntry);
                        }
                    }

                    pThisServerEntry = pNextServerEntry;
                }

                CscPrepareServerEntryForOnlineOperationFull(pServerEntry);
                SmbCeDereferenceServerEntry(pServerEntry);

                SmbCeReleaseResource();
            }
        }
    }

    return Status;
}

NTSTATUS
CscpTransitionServerEntryForDisconnectedOperation(
    RX_CONTEXT                  *RxContext,
    PSMBCEDB_SERVER_ENTRY       pServerEntry,
    PSMBCEDB_NET_ROOT_ENTRY     pNetRootEntry,
    NTSTATUS                    RemoteStatus,
    BOOLEAN                     fInvokeAutoDial,
    ULONG                       uFlags
    )
/*++

Routine Description:

   This routine transitions the server entry for disconnected mode of
   operation

Arguments:

    pServerEntry -- the server entry instance to be transitioned

    pNetRootEntry -- the net root entry instance

    RemoteStatus -- the failed status of the remote operation

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    If this routine returns STATUS_RETRY it implies that the associated server
    entry has been successfully trnaisitioned for disconnected operation.

--*/
{
    NTSTATUS Status;
    BOOLEAN  TransitionServerEntryToDisconnectedMode, fRetryFromUI=FALSE;
    ULONG    ulRootHintFlags=0;
    LONG     CscState, cntTransports=0;
    ULONG    SessionId = INVALID_SESSION_ID;

    SmbCeLog(("CscTrPSrv IN DFSFlgs %x\n",uFlags));
    SmbLog(LOG,
           CscpTransitionServerEntryForDisconnectedOperation_1,
           LOGULONG(uFlags));

    if(!MRxSmbIsCscEnabled ||
       !CscTransitnOKToGoOffline(RemoteStatus) ||
       !(uFlags & DFS_FLAG_LAST_ALTERNATE) ||
       pServerEntry->Server.IsLoopBack) {

        SmbCeLog(("CscTrPSrv Out RemoteStatus=%x\n",RemoteStatus));
        SmbLog(LOG,
               CscpTransitionServerEntryForDisconnectedOperation_2,
               LOGULONG(RemoteStatus));
        return(RemoteStatus);
    }

    // if we are supposed to invoke autodial, check if autodial service is running
    // this will ensure that we don't go up in usermode when we shouldn't.

    if (fInvokeAutoDial) {
        fInvokeAutoDial = CSCCheckForAcd();
    }

    SmbCeLog(("CscTrPSrv Autodial %x\n",fInvokeAutoDial));
    SmbLog(LOG,
           CscpTransitionServerEntryForDisconnectedOperation_3,
           LOGUCHAR(fInvokeAutoDial));

    if (!fInvokeAutoDial) {
        // Notify the CSC agent of any transport changes if required
        CscNotifyAgentOfNetStatusChangeIfRequired(FALSE);
    }

    // Ensure that we are never called to prepare for a transition if the remote
    // operation was successful.
    ASSERT(RemoteStatus != STATUS_SUCCESS);

    // The transition to disconnected operation is a three step process...
    // If the remote status is not one of the list of statuses that can signal
    // a transition to disconnected operation relect the remote status back.

    Status = RemoteStatus;

    if (CscDisableOfflineOperation) {
        return Status;
    }

    CscState = InterlockedCompareExchange(
                   &pServerEntry->Server.CscState,
                   ServerCscTransitioningToDisconnected,
                   ServerCscShadowing);

    if (CscState == ServerCscShadowing) {
        HSHARE  CscShareHandle = 0;

        if (pNetRootEntry != NULL) {
            CscShareHandle = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
        }

/***********************************************************************************************

        ACHTUNG !!! do not hold the shadow critical section here
        This may cause a deadlock, as a paging read could come down this way because
        a server has gone down. The guy doing the paging read may be holding the
        VCB and the FCB locks on FAT. Some other thread might own the shadowcritsect
        and may be trying to open a file. This would cause it to try to acquire the
        VCB and hence block. Thus we have classic deadlock situation.

        This happens only on FAT.

        The only consequence of not holding the critsect here is that we
        may get a false warning for a share that used to be in the database but has gotten
        deleted. It would be very difficult to hit that timing window so the
        chances of this happening are slim to none.

        There is another aspect to this solution, which is to make sure that handle for
        the shares inode is always kept open, so FAT will never have to hold the VCB


***********************************************************************************************/

        // do any CSC operations only if it is indeed enabled
        if (fShadow )
        {
            if (CscShareHandle == 0) {
                PDFS_NAME_CONTEXT pDfsNameContext = NULL;
                UNICODE_STRING uUncName = {0, 0, NULL};
                UNICODE_STRING uShareName = {0, 0, NULL};
                BOOL fIsShareName = FALSE;
                PIO_STACK_LOCATION IrpSp = NULL;
                PQUERY_PATH_REQUEST QpReq;
                ULONG cntSlashes = 0;
                ULONG i;

                if (RxContext != NULL && RxContext->CurrentIrpSp != NULL) {
                    IrpSp = RxContext->CurrentIrpSp;
                    //
                    // If this is a create AND a dfs path, use the dfs path passed in
                    //
                    if (IrpSp->MajorFunction == IRP_MJ_CREATE) {
                        pDfsNameContext = CscIsValidDfsNameContext(
                                             RxContext->Create.NtCreateParameters.DfsNameContext);
                        if (pDfsNameContext != NULL) {
                            // DbgPrint("DfsNameContext UNCFileName=[%wZ]\n",
                            //         &pDfsNameContext->UNCFileName);
                            uUncName = pDfsNameContext->UNCFileName;
                            fIsShareName = TRUE;
                        }
                    //
                    // If this is a query ioctl, use the path we're querying
                    //
                    } else if (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL
                            &&
                        IrpSp->MinorFunction == 0
                            &&
                        IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH
                    ) {
                        QpReq =
                            (PQUERY_PATH_REQUEST)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                        uUncName.Buffer = QpReq->FilePathName;
                        uUncName.Length = (USHORT) QpReq->PathNameLength;
                        uUncName.MaximumLength = uUncName.Length;
                        fIsShareName = TRUE;
                    }
                }
                //
                // Not a dfs create nor a query path - use the redir's netrootentry,
                // if we have one
                //
                if (uUncName.Buffer == NULL && pNetRootEntry && pNetRootEntry->Name.Length) {
                    uUncName = pNetRootEntry->Name;
                    fIsShareName = TRUE;
                }
                //
                // Bottom out using the server entry, either the dfsrootname
                // or the serverentry name.  This will take the server offline
                // w/o regard to which share the error was in reference to.
                //
                if (uUncName.Buffer == NULL) {
                    if (pServerEntry->DfsRootName.Buffer) {
                        uUncName = pServerEntry->DfsRootName;
                    } else {
                        uUncName = pServerEntry->Name;
                    }
                }
                //
                // Be sure all we have is \server\share, or \server,
                //
                for (cntSlashes = i = 0; i < uUncName.Length/sizeof(WCHAR); i++) {
                    if (uUncName.Buffer[i] == L'\\')
                        cntSlashes++;
                    if (cntSlashes >= 3) {
                        uUncName.Length = (USHORT) (sizeof(WCHAR) * i);
                        break;
                    }
                }
                //
                // If this is a special share (like IPC$), treat it as a valid
                // share to go offline against.  (IE, we go offline against
                // \server\IPC$)
                if (fIsShareName == TRUE) {
                    uShareName = uUncName;
                    for (cntSlashes = i = 0; i < uUncName.Length/sizeof(WCHAR); i++) {
                        uShareName.Buffer++;
                        uShareName.Length -= sizeof(WCHAR);
                        if (uUncName.Buffer[i] == L'\\')
                            cntSlashes++;
                        if (cntSlashes == 2)
                            break;
                    }
                    if (CscIsSpecialShare(&uShareName) == TRUE) {
                        fIsShareName = FALSE;
                        // revert to just \servername
                        uUncName.Length -= uShareName.Length + sizeof(WCHAR);
                    }
                }
                GetHShareFromUNCString(
                    uUncName.Buffer,
                    uUncName.Length,
                    1,
                    fIsShareName,
                    &CscShareHandle,
                    &ulRootHintFlags);

                ulRootHintFlags &= ~FLAG_CSC_HINT_PIN_SYSTEM;

                // DbgPrint("CscpTransitionServerEntry: [%wZ] CSCHandle=%x\n",
                //            &uUncName,
                //            CscShareHandle);
                RxDbgTrace(0, Dbg, ("CscpTransitionServerEntry: [%wZ] CSCHandle=%x\n",
                          &uUncName,
                          CscShareHandle));
            } else {
                ulRootHintFlags = 0;
            }
        } // if (fShadow)
        else
        {
            CscShareHandle = 0; // if the agent hasn't turned on CSC
                                 // then don't tell him for CSC shares
        }


        if (fInvokeAutoDial || // either autodial
            (CscShareHandle != 0)) {   // or CSC

            if (MRxSmbCscTransitionEnabledByDefault) {

                RxDbgTrace(0, Dbg, ("CscTransitionServerEntryForDisconnectedOperation: silently going offline on %wZ\r\n", CscShareHandle, ulRootHintFlags));

                InterlockedExchange(
                    &pServerEntry->Server.CscState,
                    ServerCscDisconnected);

                SmbCeReferenceServerEntry(pServerEntry);
                Status = STATUS_SUCCESS;
                RxDbgTrace(0, Dbg, ("Transitioning Server Entry for DC %lx Status %lx\n",pServerEntry,Status));
                SmbCeLog(("Transitioning Server Entry for DC %lx Status %lx\n",pServerEntry,Status));
                SmbLog(LOG,
                       CscpTransitionServerEntryForDisconnectedOperation_4,
                       LOGULONG(Status)
                       LOGPTR(pServerEntry)
                       LOGUSTR(pServerEntry->Name));

            } else {
                PSMBCEDB_SERVER_ENTRY       pDfsRootServerEntry = NULL;
                PIO_STACK_LOCATION IrpSp = NULL;

                if (RxContext != NULL && RxContext->CurrentIrpSp != NULL)
                    IrpSp = RxContext->CurrentIrpSp;

                // If the remote status was such that a transition to disconnected operation
                // should be triggerred we need to signal the agent to trigger the appropriate
                // mechanism for involving the client in this decision and decide based on the
                // result.

                cntTransports = vcntTransportsForCSC;

                SmbCeLog(("CscTrPSrv ChkAgnt %x\n",CscShareHandle));
                SmbLog(LOG,
                       CscpTransitionServerEntryForDisconnectedOperation_5,
                       LOGULONG(CscShareHandle));
                RxDbgTrace(0, Dbg, ("CscTransitionServerEntryForDisconnectedOperation: Checking with agent before going offline on CscShareHandle=%x HintFlags=%x\r\n", CscShareHandle, ulRootHintFlags));

                // if (RxContext != NULL && RxContext->CurrentIrpSp != NULL) {
                //     DbgPrint("** Transition: MJ/MN = 0x%x/0x%x\n",
                //             RxContext->CurrentIrpSp->MajorFunction,
                //             RxContext->CurrentIrpSp->MinorFunction);
                // }

                if (
                    RxContext
                        &&
                    RxContext->pRelevantSrvOpen
                        &&
                    RxContext->pRelevantSrvOpen->pVNetRoot
                ) {
                    SessionId = RxContext->pRelevantSrvOpen->pVNetRoot->SessionId;
                } else {
                    // DbgPrint("** pVnetRoot's sessionid not present\n");
                }

                if (
                    SessionId == INVALID_SESSION_ID
                        &&
                    IrpSp != NULL
                        &&
                    IrpSp->MajorFunction == IRP_MJ_CREATE
                ) {
                    PIO_SECURITY_CONTEXT pSecurityContext;
                    PACCESS_TOKEN        pAccessToken;

                    // DbgPrint("**CREATE\n");
                    pSecurityContext = RxContext->Create.NtCreateParameters.SecurityContext;
                    pAccessToken = SeQuerySubjectContextToken(
                                       &pSecurityContext->AccessState->SubjectSecurityContext);
                    if (!SeTokenIsRestricted(pAccessToken))
                        SeQuerySessionIdToken(pAccessToken, &SessionId);
                }

                if (
                    SessionId == INVALID_SESSION_ID
                        &&
                    IrpSp != NULL
                        &&
                    IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL
                        &&
                    IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH
                ) {
                    PQUERY_PATH_REQUEST QpReq;
                    PSECURITY_SUBJECT_CONTEXT pSecurityContext;

                    // DbgPrint("**QUERY_PATH\n");
                    QpReq = (PQUERY_PATH_REQUEST)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    pSecurityContext = &QpReq->SecurityContext->AccessState->SubjectSecurityContext;
                    if (pSecurityContext->ClientToken != NULL)
                        SeQuerySessionIdToken(pSecurityContext->ClientToken, &SessionId);
                    else
                        SeQuerySessionIdToken(pSecurityContext->PrimaryToken, &SessionId);
                }

                if (SessionId == INVALID_SESSION_ID) {
                    // DbgPrint("** Not CREATE or QUERY_PATH...\n");
                    if (RxContext != NULL && RxContext->CurrentIrp != NULL)
                        IoGetRequestorSessionId(RxContext->CurrentIrp, &SessionId);
                }

                if (SessionId == INVALID_SESSION_ID) {
                    // DbgPrint("All sessionid attempts failed, setting to 0..\n");
                    SessionId = 0;
                }

                // DbgPrint("** CscTrPSrv ChkAgnt SessionId: 0x%x\n", SessionId);

                if (CscCheckWithAgentForTransitioningServerEntry(
                        pServerEntry,
                        SessionId,
                        CscShareHandle,
                        fInvokeAutoDial,
                        &fRetryFromUI,
                        &pDfsRootServerEntry
                        )) {

                    SmbCeReferenceServerEntry(pServerEntry);

                    Status = STATUS_SUCCESS;
                    RxDbgTrace(0, Dbg, ("Transitioning Server Entry for DC %lx Status %lx\n",pServerEntry,Status));
                    SmbCeLog(("Transitioning Server Entry for DC %lx Status %lx\n",pServerEntry,Status));
                    SmbLog(LOG,
                           CscpTransitionServerEntryForDisconnectedOperation_4,
                           LOGULONG(Status)
                           LOGPTR(pServerEntry)
                           LOGUSTR(pServerEntry->Name));
                }
                else if (fRetryFromUI)
                {
                    LARGE_INTEGER interval;
                    int i;

                    SmbCeLog(("CscTrPSrv UIretry\n"));
                    SmbLog(LOG,
                           CscpTransitionServerEntryForDisconnectedOperation_6,
                           LOGUCHAR(fRetryFromUI));
                    RxDbgTrace(0, Dbg, ("UI sent us rerty, polling for %d seconds\n", CSC_AUTODIAL_POLL_COUNT));

                    for (i=0; i<CSC_AUTODIAL_POLL_COUNT; ++i)
                    {
                        if(cntTransports != vcntTransportsForCSC)
                        {
                            Status = STATUS_RETRY;
                            RxDbgTrace(0, Dbg, ("A new transport arrived \r\n"));
                            break;
                        }

                        interval.QuadPart = -1*10*1000*10*100; // 1 second

                        KeDelayExecutionThread( KernelMode, FALSE, &interval );
                    }


                    InterlockedExchange(
                        &pServerEntry->Server.CscState,
                        ServerCscShadowing);
                }
            }

        }
        else
        {
            InterlockedExchange(
                   &pServerEntry->Server.CscState,
                   ServerCscShadowing);

        }
    } else if (CscState == ServerCscDisconnected) {
        Status = STATUS_SUCCESS;
    }

    SmbCeLog(("CscTrPSrv Out St %x\n",Status));
    SmbLog(LOG,
           CscpTransitionServerEntryForDisconnectedOperation_7,
           LOGULONG(Status));

    return Status;
}

BOOLEAN
CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation(
    PRX_CONTEXT RxContext)
{
    BOOLEAN TransitionVNetRoot = FALSE;

    SmbCeLog(("CSCTrIsDfs IN %x\n", RxContext));
    SmbLog(LOG,
           CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_1,
           LOGPTR(RxContext));
    if ((RxContext != NULL) &&
        RxContext->CurrentIrpSp &&
        (RxContext->CurrentIrpSp->MajorFunction == IRP_MJ_CREATE)){

        NTSTATUS          Status;
        PDFS_NAME_CONTEXT pDfsNameContext;
        UNICODE_STRING    ShareName;

        pDfsNameContext = CscIsValidDfsNameContext(
                             RxContext->Create.NtCreateParameters.DfsNameContext);


        if (pDfsNameContext != NULL) {
            // Ensure that the server handles in the NET_ROOT instance
            // are initialized. This is because the DFS server munges
            // the names and the original DFS name needs to be presented
            // to the user for transitioning.

            SmbCeLog(("CSCTrIsDfs IsDsf %x\n", pDfsNameContext));
            SmbLog(LOG,
                   CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_2,
                   LOGPTR(pDfsNameContext)
                   LOGULONG(pDfsNameContext->NameContextType)
                   LOGULONG(pDfsNameContext->Flags)
                   LOGUSTR(pDfsNameContext->UNCFileName));

            Status = CscDfsParseDfsPath(
                         &pDfsNameContext->UNCFileName,
                         NULL,
                         &ShareName,
                         NULL);

            if (Status == STATUS_SUCCESS) {
                SHADOWINFO ShadowInfo;
                int        Result;

                SmbCeLog(("CSCTrDfs Parsed %wZ\n",&ShareName));
                SmbLog(LOG,
                       CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_3,
                       LOGUSTR(ShareName));

                EnterShadowCrit();

                TransitionVNetRoot = (FindCreateShareForNt(
                                         &ShareName,
                                         FALSE,     // do not create a new one
                                         &ShadowInfo,
                                         NULL) == SRET_OK);

                LeaveShadowCrit();
                if (!fShadow && TransitionVNetRoot)
                {
                    // DbgPrint("FindCreateServerForNt incorrectly returned TRUE for %wZ\n", &ShareName);
                    ASSERT(FALSE);
                }
                if (TransitionVNetRoot)
                {
                    SmbCeLog(("CSCTrDfs TrOffl \n"));
                    SmbLog(LOG,
                           CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_4,
                           LOGUCHAR(TransitionVNetRoot));

//                    DbgPrint("CSC:transitioning DFS share %wZ to offline hShare=%x shadowinfo=%x\n",&ShareName, ShadowInfo.hShare, &ShadowInfo);
                    ASSERT(ShadowInfo.hShare != 0);
                }
            }
        } else {
            TransitionVNetRoot = FALSE;
        }
    } else {
        TransitionVNetRoot = FALSE;
    }

    SmbCeLog(("CSCTrIsDfs Out %x\n", TransitionVNetRoot));
    SmbLog(LOG,
           CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_5,
           LOGUCHAR(TransitionVNetRoot));

    return TransitionVNetRoot;
}

NTSTATUS
CscPrepareDfsServerEntryForDisconnectedOperation(
    PSMBCEDB_SERVER_ENTRY pCurrentServerEntry,
    PRX_CONTEXT           RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PDFS_NAME_CONTEXT pDfsNameContext;

    PSMBCEDB_SERVER_ENTRY pServerEntry;
    BOOLEAN               fNewServerEntry;

    UNICODE_STRING    ServerName;

    if ((RxContext == NULL) ||
        (RxContext->CurrentIrp == NULL) ||
        (RxContext->CurrentIrpSp->MajorFunction != IRP_MJ_CREATE)) {
        return Status;
    }

    pDfsNameContext = CscIsValidDfsNameContext(
                         RxContext->Create.NtCreateParameters.DfsNameContext);

    if (pDfsNameContext == NULL) {
        return Status;
    }

    Status = CscDfsParseDfsPath(
                 &pDfsNameContext->UNCFileName,
                 &ServerName,
                 NULL,
                 NULL);

    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    if (!fShadow)
    {
        ASSERT(FALSE);
    }
    // Ensure that a server entry in the disconnected
    // state is created

    SmbCeAcquireResource();

    pServerEntry = SmbCeFindServerEntry(
                       &ServerName,
                       SMBCEDB_FILE_SERVER,
                       NULL);

    if (pServerEntry == NULL) {
        Status = SmbCeFindOrConstructServerEntry(
                     &ServerName,
                     SMBCEDB_FILE_SERVER,
                     &pServerEntry,
                     &fNewServerEntry,
                     NULL);
        if (pServerEntry && fNewServerEntry)
        {
            pServerEntry->Server.IsFakeDfsServerForOfflineUse = TRUE;
            // DbgPrint(
            //   "CscPrepareDfsServerEntryForDisconnectedOperation: 0x%x [%wZ] is a FAKE DFS entry\n",
            //     pServerEntry,
            //     &ServerName);
        }
    } else {
        if (pServerEntry == pCurrentServerEntry) {
            // The find routine references the server entry.
            // If this happens to be the same as the current server
            // entry then the appropriate referencing for disconnected
            // operaton has already been done,
            SmbCeDereferenceServerEntry(pServerEntry);
        }
    }

    if (pServerEntry != NULL) {
//        DbgPrint("CscPrepareDfsServerEntry %wZ \n", &pServerEntry->Name);
        InterlockedExchange(
            &pServerEntry->Server.CscState,
            ServerCscDisconnected);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SmbCeReleaseResource();

    if (Status == STATUS_SUCCESS) {
        Status = CscGrabPathFromDfs(
                     RxContext->CurrentIrpSp->FileObject,
                     pDfsNameContext);
    }

    return Status;
}


NTSTATUS
CscTransitionVNetRootForDisconnectedOperation(
    PRX_CONTEXT     RxContext,
    PMRX_V_NET_ROOT pVNetRoot,
    NTSTATUS        RemoteStatus)
/*++

Routine Description:

   This routine transitions the server entry for disconnected mode of
   operation

Arguments:

    pVNetRoot -- the net root instance

    RemoteStatus -- the failed status of the remote operation

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    If this routine returns STATUS_RETRY it implies that the associated server
    entry has been successfully tranisitioned for disconnected operation.

--*/
{
    NTSTATUS Status,ReturnStatus;
    PMRX_FOBX capFobx = NULL;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;

    if(!MRxSmbIsCscEnabled || !fShadow) {
        return(RemoteStatus);
    }

    // Notify the CSC agent of any transport changes if required
    CscNotifyAgentOfNetStatusChangeIfRequired(FALSE);

    ReturnStatus = RemoteStatus;

    if (!CscTransitnOKToGoOffline(RemoteStatus)) {
        return RemoteStatus;
    }

    if (pVNetRoot != NULL) {
        pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot);
    }

    SmbCeLog(("CSCTrVNR %x VNR\n", pVNetRootContext));
    SmbLog(LOG,
           CscTransitionVNetRootForDisconnectedOperation_1,
           LOGPTR(pVNetRootContext));

    if (pVNetRootContext == NULL ||
        pVNetRootContext->pServerEntry->Server.IsLoopBack) {
        return RemoteStatus;
    }

    if (RxContext != NULL) {
        capFobx = RxContext->pFobx;
    }

    pNetRootEntry = pVNetRootContext->pNetRootEntry;



    if (!FlagOn(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE) &&
        (pNetRootEntry != NULL) &&
        (pNetRootEntry->NetRoot.NetRootType == NET_ROOT_DISK ||
         pNetRootEntry->NetRoot.NetRootType == NET_ROOT_WILD)) {

        if (pNetRootEntry->NetRoot.CscFlags != SMB_CSC_NO_CACHING) {
            BOOLEAN           TransitionVNetRoot;
            UNICODE_STRING    ServerName;
            PDFS_NAME_CONTEXT pDfsNameContext = NULL;
            ULONG               uFlags = DFS_FLAG_LAST_ALTERNATE;

            TransitionVNetRoot = TRUE;

            if ((capFobx != NULL) &&
                (capFobx->pSrvOpen != NULL)) {
                PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

                if ((pVNetRootContext->pServerEntry->Server.Version -
                     smbSrvOpen->Version) > 1) {
                    TransitionVNetRoot = FALSE;
                }
            }

            if (TransitionVNetRoot) {
                PDFS_NAME_CONTEXT pDfsNameContext = NULL;
                ULONG   uFlags = DFS_FLAG_LAST_ALTERNATE;
                if (RxContext &&
                    RxContext->CurrentIrpSp &&
                    RxContext->CurrentIrpSp->MajorFunction == IRP_MJ_CREATE) {

                    pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

                    if (pDfsNameContext)
                    {
                        uFlags = pDfsNameContext->Flags;
                    }
                }

                SmbCeLog(("CSCTrVNR DfsFlgs %x\n", uFlags));
                SmbLog(LOG,
                       CscTransitionVNetRootForDisconnectedOperation_2,
                       LOGULONG(uFlags));

                Status = CscpTransitionServerEntryForDisconnectedOperation(
                             RxContext,
                             pVNetRootContext->pServerEntry,
                             pNetRootEntry,
                             RemoteStatus,
                             FALSE,   // to autodial or not to autodial
                             uFlags
                             );

                // If the DFS share is in the database and the agent says it is OK to go disconnected
                // then we want to create a DFS server entry and put that one in
                // disconnected state too

                if ((Status == STATUS_SUCCESS)  &&
                    ((pDfsNameContext != NULL)||(pNetRootEntry->NetRoot.DfsAware))) {

//                    DbgPrint("CSCTransitionVNETroot: Transitioning %wZ \n", &pVNetRootContext->pServerEntry->Name);
                    SmbCeLog(("CSCTrVNR try Tr %wZ \n", &pVNetRootContext->pServerEntry->Name));
                    SmbLog(LOG,
                           CscTransitionVNetRootForDisconnectedOperation_3,
                           LOGUSTR(pVNetRootContext->pServerEntry->Name));

                    Status = CscPrepareDfsServerEntryForDisconnectedOperation(
                                 pVNetRootContext->pServerEntry,
                                 RxContext);
                }

                if (Status != STATUS_SUCCESS) {
                    ReturnStatus = Status;
                } else {
                    ReturnStatus = STATUS_RETRY;
                }
            }
        }
    }

    return ReturnStatus;
}

NTSTATUS
CscTransitionServerEntryForDisconnectedOperation(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PRX_CONTEXT           RxContext,
    NTSTATUS              RemoteStatus,
    BOOLEAN               AutoDialRequired)
{
    NTSTATUS        TransitionStatus = STATUS_SUCCESS;
    PMRX_V_NET_ROOT pVNetRoot = NULL;

    ULONG   uFlags = DFS_FLAG_LAST_ALTERNATE;

    SmbCeLog(("CSCTrSvr IN %x %x %x %x\n", pServerEntry, RxContext, RemoteStatus, AutoDialRequired));
    SmbLog(LOG,
           CscTransitionServerEntryForDisconnectedOperation_1,
           LOGPTR(pServerEntry)
           LOGPTR(RxContext)
           LOGULONG(RemoteStatus)
           LOGUCHAR(AutoDialRequired)
           LOGUSTR(pServerEntry->Name));

    if ((RxContext != NULL) &&
        (RxContext->CurrentIrp != NULL) &&
        (RxContext->CurrentIrpSp->MajorFunction == IRP_MJ_CREATE)) {
        PDFS_NAME_CONTEXT pDfsNameContext;

        pDfsNameContext = CscIsValidDfsNameContext(
                             RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext != NULL) {
            uFlags = pDfsNameContext->Flags;
            SmbCeLog(("CSCTrSvr DFSFlgs %x\n", uFlags));
            SmbLog(LOG,
                   CscTransitionServerEntryForDisconnectedOperation_2,
                   LOGULONG(uFlags));
        }
    }

    if ((RxContext != NULL) &&
        (RxContext->pFobx != NULL) &&
        (RxContext->pFobx->pSrvOpen != NULL)) {
        pVNetRoot = RxContext->pFobx->pSrvOpen->pVNetRoot;
    }

    if (pVNetRoot != NULL) {
        TransitionStatus =
            CscTransitionVNetRootForDisconnectedOperation(
                RxContext,
                pVNetRoot,
                pServerEntry->ServerStatus);
    } else {
        TransitionStatus =
            CscpTransitionServerEntryForDisconnectedOperation(
                RxContext,
                pServerEntry,
                NULL,
                RemoteStatus,
                AutoDialRequired,
                uFlags
                );

        if ((TransitionStatus == STATUS_SUCCESS) &&
            (RxContext != NULL)) {
            BOOLEAN TransitionDfsVNetRoot = FALSE;

            TransitionDfsVNetRoot =
                CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation(
                    RxContext);

            if (TransitionDfsVNetRoot) {
  //              DbgPrint("CSCTransitionServerEntry: Transitioning DFS server for ServerEntry %x \n", pServerEntry);

                TransitionStatus = CscPrepareDfsServerEntryForDisconnectedOperation(
                                        pServerEntry,
                                        RxContext);
            }
        }
    }
    // Pulse the fill thread so it will start 10-min tries to reconnect
    // It will go back to sleep if it succeeds
    // DbgPrint("###CSCTransitionServerEntry: pulsing fill event\n");
    MRxSmbCscSignalFillAgent(NULL, 0);

    SmbCeLog(("CSCTrSvr Out %x\n", TransitionStatus));
    SmbLog(LOG,
           CscTransitionServerEntryForDisconnectedOperation_3,
           LOGULONG(TransitionStatus));

    return TransitionStatus;
}

BOOLEAN
CscPerformOperationInDisconnectedMode(
    PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine detects if the operation should be performed in a disconnected
   mode. Additionally if the operation needs to be performed in a disconnected
   mode it prepares the open accordingly.

Arguments:

    RxContext - the Wrapper context for the operation

Return Value:

    TRUE -- if the operation needs to be performed in the disconnected mode
    and FALSE otherwise

Notes:

    There are certain opens that are deferred by the SMB mini redirector in
    the connected mode. These modes need to be evaluated when the transition is
    made to disconnected mode, since in disconnected mode there are no
    deferred opens.

    The appropriate buffering change requests need to be done as well (TBI)
--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN     SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PSMBCEDB_SERVER_ENTRY       pServerEntry;
    PSMBCE_V_NET_ROOT_CONTEXT   pVNetRootContext;
    BOOLEAN PerformOperationInDisconnectedMode = FALSE;

    if(!MRxSmbIsCscEnabled) {
        return(FALSE);
    }

    SrvOpen    = RxContext->pRelevantSrvOpen;

    // check if SrvOpen is NULL. This could happen if a mailslot operation was passed in here
    if (!SrvOpen)
    {
        return(FALSE);
    }

    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (FlagOn(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_LOCAL_OPEN)) {
        return FALSE;
    }

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(capFobx->pSrvOpen->pVNetRoot);

    if (SmbCeIsServerInDisconnectedMode(pServerEntry) &&
        !FlagOn(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE)) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = MRxSmbGetFcbExtension(capFcb);
        if (smbFcb->hShadow == 0) {
            BOOLEAN FcbAcquired;
            BOOLEAN PreviouslyAcquiredShared = FALSE;

            // If the FCB resource has not been acquired, acquire it before
            // performing the create.

            if (!RxIsFcbAcquiredExclusive(capFcb)) {
                if (RxIsFcbAcquiredShared(capFcb)) {
                    RxDbgTrace(0, Dbg, ("Shared holding condition detected for disconnected operation\n"));
                    RxReleaseFcbResourceInMRx(capFcb);
                    PreviouslyAcquiredShared = TRUE;
                }

                RxAcquireExclusiveFcbResourceInMRx(capFcb );
                FcbAcquired = TRUE;
            } else {
                FcbAcquired = FALSE;
            }

            // This is a case of a deferred open for which the transition has
            // been made to disconnected operation.

            Status = MRxSmbDeferredCreate(RxContext);

            //RxIndicateChangeOfBufferingState(
            //    capFcb->pNetRoot->pSrvCall,
            //    MRxSmbMakeSrvOpenKey(smbFcb->Tid,smbSrvOpen->Fid),
            //    (PVOID)2);

            if (FcbAcquired) {
                RxReleaseFcbResourceInMRx(capFcb);
            }

            if (PreviouslyAcquiredShared) {
                RxAcquireSharedFcbResourceInMRx(capFcb );
            }
        }

        PerformOperationInDisconnectedMode = TRUE;
    }

    return PerformOperationInDisconnectedMode;
}

#if 0
int
AllPinnedFilesFilled(
    HSHARE hShare,
    BOOL    *lpfComplete
    )

/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    CSC_ENUMCOOKIE  hPQ;
    PQPARAMS sPQP;
    int iRet = SRET_ERROR;

    ASSERT(hShare);
    ASSERT(lpfComplete);


    // Open the priority q
    if (!(hPQ = HBeginPQEnum()))
    {
        RxDbgTrace(0, Dbg, ("AllPinnedFilesFilled: Error opening Priority Q database\r\n"));
        return SRET_ERROR;
    }

    *lpfComplete = TRUE;
    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;

    // go down the Q once
    do
    {
        if(NextPriSHADOW(&sPQP) < SRET_OK)
        {
            RxDbgTrace(0, Dbg, ("AllPinnedFilesFilled: PQ record read error\r\n"));
            goto bailout;
        }



        if (!sPQP.hShadow)
        {
            break;
        }

        // see if any of the pinned files for the specific
        // server is sparse
        if ((hShare == sPQP.hShare)
            && (sPQP.ulStatus & SHADOW_IS_FILE) // It is a file
            && ((sPQP.ulHintPri || mPinFlags(sPQP.ulHintFlags)))// it is a pinned file
            )
        {
            if (sPQP.ulStatus & SHADOW_SPARSE)
            {
                // we found a sparse file
                *lpfComplete = FALSE;
                break;
            }
        }

    }
    while (sPQP.uPos);

    iRet = SRET_OK;

bailout:
    if (hPQ)
    {
        EndPQEnum(hPQ);
    }
    if (iRet == SRET_ERROR)
    {
        *lpfComplete = FALSE;
    }
    return (iRet);
}
#endif

BOOLEAN
CscGetServerNameWaitingToGoOffline(
    OUT     PWCHAR      ServerName,
    IN OUT  LPDWORD     lpdwBufferSize,
    OUT     NTSTATUS    *lpStatus
    )
/*++

Routine Description:
                This routine returns the name of the server which has asked the agent to
                throw a popup to the user.
Arguments:
                ServerName  returns the name of the server
Return Value:
                Fails if no server is waiting for the popup to comeback
Notes:

--*/
{
    BOOLEAN fRet = FALSE;
    DWORD   dwSize = *lpdwBufferSize;
    *lpStatus = STATUS_UNSUCCESSFUL;

    if (CscServerEntryBeingTransitioned)
    {
        PWCHAR Name;
        ULONG  NameLength;

        if (!CscDfsRootServerEntryBeingTransitioned) {
            NameLength = CscServerEntryBeingTransitioned->Name.Length;
            Name = CscServerEntryBeingTransitioned->Name.Buffer;
        } else {
            NameLength = CscDfsRootServerEntryBeingTransitioned->Name.Length;
            Name = CscDfsRootServerEntryBeingTransitioned->Name.Buffer;
        }

        *lpdwBufferSize = (DWORD)(NameLength+2+2);

        if(dwSize >= (DWORD)(NameLength+2+2))
        {
            *ServerName='\\';

            memcpy(
                ServerName+1,
                Name,
                NameLength);

            memset(((LPBYTE)(ServerName+1))+NameLength, 0, 2);

            *lpStatus = STATUS_SUCCESS;
            fRet = TRUE;
        }
        else
        {
            *lpStatus = STATUS_BUFFER_TOO_SMALL;
        }
    }
    return fRet;
}

BOOLEAN
CscShareIdToShareName(
    IN      ULONG       hShare,
    OUT     PWCHAR      ShareName,
    IN OUT  LPDWORD     lpdwBufferSize,
    OUT     NTSTATUS    *lpStatus
    )
{
    SHAREREC sSR;
    DWORD   dwSize = *lpdwBufferSize;
    ULONG  NameLength;
    INT iRet;

    // DbgPrint("CscShareIdToShareName(%d)\n", hShare);

    *lpStatus = STATUS_OBJECT_NAME_NOT_FOUND;

    if (hShare == 0)
        goto AllDone;

    EnterShadowCrit();
    iRet = GetShareRecord(lpdbShadow, hShare, &sSR);
    LeaveShadowCrit();
    if (iRet >= 0 && sSR.uchType == (UCHAR)REC_DATA) {
        NameLength = (wcslen(sSR.rgPath)+1) * sizeof(WCHAR);
        *lpdwBufferSize = (DWORD)NameLength;
        if(dwSize >= (DWORD)(NameLength)) {
            memset(ShareName, 0, dwSize);
            if (NameLength > 0)
                memcpy(ShareName, sSR.rgPath, NameLength);
            *lpStatus = STATUS_SUCCESS;
        } else {
            *lpStatus = STATUS_BUFFER_TOO_SMALL;
        }
    }
AllDone:
    // DbgPrint("CscShareIdToShareName exit 0x%x\n", *lpStatus);
    return TRUE;
}

BOOLEAN
CSCCheckForAcd(VOID)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    BOOLEAN    fAutoDialON=FALSE;
    PIRP pIrp;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
               &nameString,
               SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
               &pAcdFileObject,
               &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
    {
        RxDbgTrace(0, Dbg, ("CSCCheckForAcd: failed with status=%x \r\n", status));
        return FALSE;
    }

    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);

    pIrp = IoBuildDeviceIoControlRequest(
             IOCTL_INTERNAL_ACD_QUERY_STATE,
             pAcdDeviceObject,
             NULL,
             0,
             &fAutoDialON,
             sizeof(fAutoDialON),
             TRUE,
             NULL,
             &ioStatusBlock);
    if (pIrp == NULL) {
        ObDereferenceObject(pAcdDeviceObject);
        return FALSE;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);

    ObDereferenceObject(pAcdDeviceObject);
    return fAutoDialON;
}

BOOLEAN
CscTransitnOKToGoOffline(
    NTSTATUS    RemoteStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{

    switch (RemoteStatus) {
    case STATUS_CONNECTION_DISCONNECTED:
    case STATUS_IO_TIMEOUT:
    case STATUS_NETWORK_UNREACHABLE:
    case STATUS_BAD_NETWORK_NAME:
    case STATUS_BAD_NETWORK_PATH:
    case STATUS_NETWORK_NAME_DELETED:
        return TRUE;
    default :
        return FALSE;
    }
}

BOOLEAN
CscIsSpecialShare(
    PUNICODE_STRING ShareName)
{
    ULONG i;
    BOOLEAN fSpecial = FALSE;

    // DbgPrint("CscIsSpecialShare(%wZ)\n", ShareName);
    for (i = 0;
            (i < (sizeof(CscSpecialShares) / sizeof(CscSpecialShares[0]))) &&
                !fSpecial;
                    i++) {
        if (CscSpecialShares[i].Length == ShareName->Length) {
            if (_wcsnicmp(
                    CscSpecialShares[i].Buffer,
                        ShareName->Buffer,
                            ShareName->Length/sizeof(WCHAR)) == 0) {
                fSpecial = TRUE;
            }
        }
    }
    // DbgPrint("CscIsSpecialShare returning %d\n", fSpecial);
    return fSpecial;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\block.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    block.c

Abstract:

    Block encryption functions implementation :

        RtlEncryptBlock
        RtlEncrypStdBlock


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Scott Field (sfield)    03-Nov-97
        Removed critical section around crypto calls.
    Adam Barr (adamba)      15-Dec-97
        Modified from private\security\lsa\crypt\dll

--*/

#include <rdrssp.h>



NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    )

/*++

Routine Description:

    Takes a block of data and encrypts it with a key producing
    an encrypted block of data.

Arguments:

    ClearBlock - The block of data that is to be encrypted.

    BlockKey - The key to use to encrypt data

    CypherBlock - Encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The data was encrypted successfully. The encrypted
                     data block is in CypherBlock

    STATUS_UNSUCCESSFUL - Something failed. The CypherBlock is undefined.
--*/

{
    unsigned Result;

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)ClearBlock,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
        KdPrint(("RDRSSP: RtlEncryptBlock failed %x\n\r", Result));
        return(STATUS_UNSUCCESSFUL);
    }
}



NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    )

/*++

Routine Description:

    Takes a block key encrypts the standard text block with it.
    The resulting encrypted block is returned.
    This is a One-Way-Function - the key cannot be recovered from the
    encrypted data block.

Arguments:

    BlockKey - The key to use to encrypt the standard text block.

    CypherBlock - The encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The encryption was successful.
                     The result is in CypherBlock

    STATUS_UNSUCCESSFUL - Something failed. The CypherBlock is undefined.
--*/

{
    unsigned Result;
    char StdEncrPwd[] = "KGS!@#$%";

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)StdEncrPwd,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
#if DBG
        DbgPrint("EncryptStd failed\n\r");
#endif
        return(STATUS_UNSUCCESSFUL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\connmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        connmgr.h
//
// Contents:    Connection Manager code for KSecDD
//
//
// History:     3 Jun 92    RichardW    Created
//              15 Dec 97   AdamBa      Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#ifndef __CONNMGR_H__
#define __CONNMGR_H__


typedef struct _KernelContext {
    struct _KernelContext * pNext;      // Link to next context
    struct _KernelContext * pPrev;      // Link to previous context
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    HANDLE TokenHandle;
    PACCESS_TOKEN AccessToken;
} KernelContext, *PKernelContext;


void            AddKernelContext(PKernelContext *, PKSPIN_LOCK, PKernelContext);
SECURITY_STATUS DeleteKernelContext(PKernelContext *, PKSPIN_LOCK, PKernelContext);

#endif // __CONNMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\context.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        context.cxx
//
// Contents:    context kernel-mode functions
//
//
// History:     3/17/94     MikeSw          Created
//              12/15/97    AdamBa          Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#include <rdrssp.h>


//+-------------------------------------------------------------------------
//
//  Function:   DeleteKernelContext
//
//  Synopsis:   Deletes a kernel context
//
//  Effects:    Frees memory, closes token handle.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
DeleteKernelContext(PKernelContext *    ppList,
                    PKSPIN_LOCK         pslLock,
                    PKernelContext      pContext)
{
    KIRQL OldIrql;

    //
    // First, find the record, then unlink the record from the list,
    // and fix up pointers.
    //

    KeAcquireSpinLock(pslLock, &OldIrql);


    if (!pContext)
    {
        KeReleaseSpinLock(pslLock, OldIrql);
        return(SEC_E_INVALID_HANDLE);
    }

    //
    // Now unlink from the list
    //

    if (pContext->pPrev)
    {
        pContext->pPrev->pNext = pContext->pNext;
    }
    else
    {
        *ppList = pContext->pNext;
    }


    if (pContext->pNext)
    {
        pContext->pNext->pPrev = pContext->pPrev;
    }

    //
    // copy out the package-specific context to return.
    // We are done with the list so we can release the spin lock
    //

    KeReleaseSpinLock(pslLock, OldIrql);


    if (pContext->TokenHandle != NULL)
    {
        NtClose(pContext->TokenHandle);
    }
    if (pContext->AccessToken != NULL)
    {
        ObDereferenceObject(pContext->AccessToken);
    }

    // And, finally, return the context record to our pool:

    FreeContextRec(pContext);

    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   AddKernelContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
AddKernelContext(   PKernelContext * ppList,
                    PKSPIN_LOCK     pslLock,
                    PKernelContext  pContext)
{
    KIRQL   OldIrql;


    KeAcquireSpinLock(pslLock, &OldIrql);

    pContext->pNext = *ppList;
    if (pContext->pNext)
    {
        pContext->pNext->pPrev = pContext;
    }
    pContext->pPrev = NULL;

    *ppList = pContext;

    KeReleaseSpinLock(pslLock, OldIrql);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\chal.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    nlmain.c

Abstract:

    This file contains the initialization and dispatch routines
    for the LAN Manager portions of the MSV1_0 authentication package.

Author:

    Jim Kelly 11-Apr-1991

Revision History:
    25-Apr-1991 (cliffv)
        Added interactive logon support for PDK.

    Chandana Surlu   21-Jul-1996
        Stolen from \\kernel\razzle3\src\security\msv1_0\nlmain.c
    Adam Barr        15-Dec-1997
        Modified from private\security\msv_sspi\nlmain.c

--*/


#include <rdrssp.h>

#include <nturtl.h>
#include <align.h>
#define NLP_ALLOCATE
#include "nlp.h"
#undef NLP_ALLOCATE

#include <md4.h>
#include <md5.h>
#include <hmac.h>


VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( Where != NULL && *Where != NULL);
    ASSERT( *Where == ROUND_UP_POINTER( *Where, sizeof(WCHAR) ) );
#ifdef notdef
    KdPrint(("NlpPutString: %ld %Z\n", InString->Length, InString ));
    KdPrint(("  InString: %lx %lx OutString: %lx Where: %lx\n", InString,
        InString->Buffer, OutString, *Where ));
#endif

    if ( InString->Length > 0 ) {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = (USHORT)(InString->Length + sizeof(WCHAR));

        RtlCopyUnicodeString( OutString, InString );

        *Where += InString->Length;
//        *((WCHAR *)(*Where)) = L'\0';
        *(*Where) = '\0';
        *(*Where + 1) = '\0';
        *Where += 2;

    } else {
        RtlInitUnicodeString(OutString, NULL);
    }
#ifdef notdef
    KdPrint(("  OutString: %ld %lx\n",  OutString->Length, OutString->Buffer));
#endif

    return;
}


NTSTATUS
NlpMakePrimaryCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize,
    IN BOOLEAN OwfPasswordProvided
    )


/*++

Routine Description:

    This routine makes a primary credential for the given user nam and
    password.

Arguments:

    LogonDomainName - Is a string representing the domain in which the user's
        account is defined.

    UserName - Is a string representing the user's account name.  The
        name may be up to 255 characters long.  The name is treated case
        insensitive.

    CleartextPassword - Is a string containing the user's cleartext password.
        The password may be up to 255 characters long and contain any
        UNICODE value.

    CredentialBuffer - Returns a pointer to the specified credential allocated
        on the LsaHeap.  It is the callers responsibility to deallocate
        this credential.

    CredentialSize - the size of the allocated credential buffer (in bytes).

    OwfPasswordProvided - If TRUE, then we assume the password is provided as the LM and NT OWF,
        passwords concatenated together.


Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    PMSV1_0_PRIMARY_CREDENTIAL Credential;
    NTSTATUS Status;
    PUCHAR Where;
    CHAR LmPassword[LM20_PWLEN+1];
    BOOLEAN LmPasswordPresent;
    STRING AnsiCleartextPassword;

    if (!OwfPasswordProvided) {

        //
        // Compute the Ansi version to the Cleartext password.
        //
        //  The Ansi version of the Cleartext password is at most 14 bytes long,
        //      exists in a trailing zero filled 15 byte buffer,
        //      is uppercased.
        //

        AnsiCleartextPassword.Buffer = LmPassword;
        AnsiCleartextPassword.MaximumLength = sizeof(LmPassword);

        RtlZeroMemory( &LmPassword, sizeof(LmPassword) );

        Status = RtlUpcaseUnicodeStringToOemString(
                                      &AnsiCleartextPassword,
                                      CleartextPassword,
                                      (BOOLEAN) FALSE );

         if ( !NT_SUCCESS(Status) ) {
            RtlZeroMemory( &LmPassword, sizeof(LmPassword) );
            AnsiCleartextPassword.Length = 0;
            LmPasswordPresent = FALSE;
         } else {

            LmPasswordPresent = TRUE;
        }
    }


    //
    // Build the credential
    //

    *CredentialSize = sizeof(MSV1_0_PRIMARY_CREDENTIAL) +
            LogonDomainName->Length + sizeof(WCHAR) +
            UserName->Length + sizeof(WCHAR);

    Credential = ExAllocatePool ( NonPagedPool, *CredentialSize );

    if ( Credential == NULL ) {
        KdPrint(("MSV1_0: NlpMakePrimaryCredential: No memory %ld\n",
            *CredentialSize ));
        return STATUS_QUOTA_EXCEEDED;
    }


    //
    // Put the LogonDomainName into the Credential Buffer.
    //

    Where = (PUCHAR)(Credential + 1);

    NlpPutString( &Credential->LogonDomainName, LogonDomainName, &Where );


    //
    // Put the UserName into the Credential Buffer.
    //

    NlpPutString( &Credential->UserName, UserName, &Where );


    if (OwfPasswordProvided) {

        RtlCopyMemory(&Credential->LmOwfPassword, CleartextPassword->Buffer, LM_OWF_PASSWORD_SIZE);
        Credential->LmPasswordPresent = TRUE;

        RtlCopyMemory(&Credential->NtOwfPassword, ((PUCHAR)CleartextPassword->Buffer) + LM_OWF_PASSWORD_SIZE, NT_OWF_PASSWORD_SIZE);
        Credential->NtPasswordPresent = TRUE;

    } else {

        //
        // Save the OWF encrypted versions of the passwords.
        //

        Status = RtlCalculateLmOwfPassword( LmPassword,
                                            &Credential->LmOwfPassword );

        ASSERT( NT_SUCCESS(Status) );

        Credential->LmPasswordPresent = LmPasswordPresent;

        Status = RtlCalculateNtOwfPassword( CleartextPassword,
                                            &Credential->NtOwfPassword );

        ASSERT( NT_SUCCESS(Status) );

        Credential->NtPasswordPresent = ( CleartextPassword->Length != 0 );

        //
        // Don't leave passwords around in the pagefile
        //

        RtlZeroMemory( &LmPassword, sizeof(LmPassword) );


    }

    //
    // Return the credential to the caller.
    //
    *CredentialBuffer = Credential;
    return STATUS_SUCCESS;
}

VOID
SspUpcaseUnicodeString(
    IN OUT UNICODE_STRING* pUnicodeString
    )

/*++

Routine Description:

    Upcase unicode string, modifying string in place.

Arguments:

    pUnicodeString - string

Return Value:

    none

--*/

{
    ULONG i;

    for (i = 0; i < pUnicodeString->Length / sizeof(WCHAR); i++)
    {
        pUnicodeString->Buffer[i] = RtlUpcaseUnicodeChar(pUnicodeString->Buffer[i]);
    }
}

#define MSV1_0_NTLMV2_OWF_LENGTH MSV1_0_NTLM3_RESPONSE_LENGTH

VOID
SspCalculateNtlmv2Owf(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    OUT UCHAR Ntlmv2Owf[MSV1_0_NTLMV2_OWF_LENGTH]
    )
/*++

Routine Description:

    Calculate Ntlm v2 OWF, salted with username and logon domain name

Arguments:

    pNtOwfPassword    - NT OWF
    pUserName         - user name
    pLogonDomainName  - logon domain name
    Ntlmv2Owf         - NTLM v2 OWF

Return Value:

    none

--*/

{
    HMACMD5_CTX HMACMD5Context;

    //
    // reserve a scratch buffer
    //

    WCHAR szUserName[(UNLEN + 4)] = {0};
    UNICODE_STRING UserName = {0, sizeof(szUserName), szUserName};

    //
    //  first make a copy then upcase it
    //

    UserName.Length = min(UserName.MaximumLength, pUserName->Length);

    ASSERT(UserName.Length == pUserName->Length);

    memcpy(UserName.Buffer, pUserName->Buffer, UserName.Length);

    SspUpcaseUnicodeString(&UserName);

    //
    // Calculate Ntlmv2 OWF -- HMAC(MD4(P), (UserName, LogonDomainName))
    //

    HMACMD5Init(
        &HMACMD5Context,
        (UCHAR *) pNtOwfPassword,
        sizeof(*pNtOwfPassword)
        );

    HMACMD5Update(
        &HMACMD5Context,
        (UCHAR *) UserName.Buffer,
        UserName.Length
        );

    HMACMD5Update(
        &HMACMD5Context,
        (UCHAR *) pLogonDomainName->Buffer,
        pLogonDomainName->Length
        );

    HMACMD5Final(
        &HMACMD5Context,
        Ntlmv2Owf
        );
}

#define MSV1_0_NTLMV2_RESPONSE_LENGTH MSV1_0_NTLM3_RESPONSE_LENGTH

VOID
SspGetLmv2Response(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT UCHAR Response[MSV1_0_NTLMV2_RESPONSE_LENGTH],
    OUT USER_SESSION_KEY* pUserSessionKey,
    OUT UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH]
    )

/*++

Routine Description:

    Get LMv2 response

Arguments:

    pNtOwfPassword       - NT OWF
    pUserName            - user name
    pLogonDomainName     - logon domain name
    ChallengeToClient    - challenge to client
    pLmv2Response        - Lm v2 response
    Routine              - response

Return Value:

    NTSTATUS

--*/

{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlmv2Owf[MSV1_0_NTLMV2_OWF_LENGTH];

    C_ASSERT(MD5DIGESTLEN == MSV1_0_NTLMV2_RESPONSE_LENGTH);

    //
    // get Ntlmv2 OWF
    //

    SspCalculateNtlmv2Owf(
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlmv2Owf
        );

    //
    // Calculate Ntlmv2 Response
    // HMAC(Ntlmv2Owf, (ChallengeToClient, ChallengeFromClient))
    //

    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLMV2_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Final(
        &HMACMD5Context,
        Response
        );

    // now compute the session keys
    //  HMAC(Kr, R)
    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        Response,
        MSV1_0_NTLM3_RESPONSE_LENGTH
        );

    ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);

    HMACMD5Final(
        &HMACMD5Context,
        (PUCHAR)pUserSessionKey
        );

    ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH <= MSV1_0_USER_SESSION_KEY_LENGTH);
    RtlCopyMemory(
        LanmanSessionKey,
        pUserSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH
        );
}

typedef struct {
        UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH];
        UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_LM3_RESPONSE, *PMSV1_0_LM3_RESPONSE;

#define NULL_SESSION_REQUESTED 0x10

NTSTATUS
MspLm20GetChallengeResponse (
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    IN BOOLEAN OwfPasswordProvided
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20GetChallengeResponse.  It is called by
    the LanMan redirector to determine the Challenge Response to pass to a
    server when trying to establish a connection to the server.

    This routine is passed a Challenge from the server.  This routine encrypts
    the challenge with either the specified password or with the password
    implied by the specified Logon Id.

    Two Challenge responses are returned.  One is based on the Unicode password
    as given to the Authentication package.  The other is based on that
    password converted to a multi-byte character set (e.g., ASCII) and upper
    cased.  The redirector should use whichever (or both) challenge responses
    as it needs them.

Arguments:

    The first four arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

    OwfPasswordProvided use is used to distinquish if the password is Owf or not.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PMSV1_0_GETCHALLENRESP_REQUEST GetRespRequest;

    PMSV1_0_GETCHALLENRESP_RESPONSE GetRespResponse;

    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;
    PMSV1_0_PRIMARY_CREDENTIAL BuiltCredential = NULL;

    PVOID ClientBuffer = NULL;
    PUCHAR ClientStrings;

    //
    // Responses to return to the caller.
    //
    MSV1_0_LM3_RESPONSE LmResp = {0};
    STRING LmResponseString;

    NT_RESPONSE NtResponse = {0};
    STRING NtResponseString;

    UNICODE_STRING NullUnicodeString = {0};
    USER_SESSION_KEY UserSessionKey;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];

    RtlZeroMemory( &UserSessionKey, sizeof(UserSessionKey) );
    RtlZeroMemory( LanmanSessionKey, sizeof(LanmanSessionKey) );

    //
    // If no credentials are associated with the client, a null session
    // will be used.  For a downlevel server, the null session response is
    // a 1-byte null string (\0).  Initialize LmResponseString to the
    // null session response.
    //

    RtlInitString( &LmResponseString, "" );
    LmResponseString.Length = 1;

    //
    // Initialize the NT response to the NT null session credentials,
    // which are zero length.
    //

    RtlInitString( &NtResponseString, NULL );

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_GETCHALLENRESP_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    GetRespRequest = (PMSV1_0_GETCHALLENRESP_REQUEST) ProtocolSubmitBuffer;

    ASSERT( GetRespRequest->MessageType == MsV1_0Lm20GetChallengeResponse );


    //
    // If the caller wants information from the credentials of a specified
    //  LogonId, get those credentials from the LSA.
    //
    // If there are no such credentials,
    //  tell the caller to use the NULL session.
    //

#define PRIMARY_CREDENTIAL_NEEDED \
        (RETURN_PRIMARY_USERNAME | \
        USE_PRIMARY_PASSWORD )

    if ( ((GetRespRequest->ParameterControl & PRIMARY_CREDENTIAL_NEEDED) != 0 ) && ((GetRespRequest->ParameterControl & NULL_SESSION_REQUESTED) == 0)) {

        ASSERT(FALSE);
    }

    //
    // If the caller passed in a password to use,
    //  use it to build a credential.
    //
    // The password is assumed to be the LM and NT OWF
    // passwords concatenated together.
    //

    if ( (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD) == 0 ) {
        ULONG CredentialSize;

        Status = NlpMakePrimaryCredential( &GetRespRequest->LogonDomainName,
                                           &GetRespRequest->UserName,
                                           &GetRespRequest->Password,
                                           &BuiltCredential,
                                           &CredentialSize,
                                           OwfPasswordProvided
                                         );

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        //
        // Use the newly allocated credential to get the password information
        // from.
        //

        Credential = BuiltCredential;
    }

    //
    // Build the appropriate response.
    //

    if ( Credential != NULL ) {

        ASSERT(Credential->UserName.Length);

        SspGetLmv2Response(
             &Credential->NtOwfPassword,
             &Credential->UserName,
             &Credential->LogonDomainName,
             GetRespRequest->ChallengeToClient,
             LmResp.ChallengeFromClient,
             LmResp.Response,
             &UserSessionKey,
             LanmanSessionKey
             );

        LmResponseString.Buffer = (UCHAR*) &LmResp;
        LmResponseString.Length = LmResponseString.MaximumLength = sizeof(LmResp);

        NtResponseString.Buffer = (CHAR*) L"";
        NtResponseString.Length = 0;
        NtResponseString.MaximumLength = sizeof(WCHAR);

        //
        // Compute the session keys
        //

        if ( GetRespRequest->ParameterControl & RETURN_NON_NT_USER_SESSION_KEY) {

            //
            // If the redir didn't negotiate an NT protocol with the server,
            //  use the lanman session key.
            //

            if ( Credential->LmPasswordPresent ) {

                ASSERT( sizeof(UserSessionKey) >= sizeof(LanmanSessionKey) );

                RtlCopyMemory( &UserSessionKey,
                               &Credential->LmOwfPassword,
                               sizeof(LanmanSessionKey) );
            }

            if ( Credential->LmPasswordPresent ) {
                RtlCopyMemory( LanmanSessionKey,
                               &Credential->LmOwfPassword,
                               sizeof(LanmanSessionKey) );
            }

        } else {

            if ( !Credential->NtPasswordPresent ) {

                RtlCopyMemory( &Credential->NtOwfPassword,
                            &NlpNullNtOwfPassword,
                            sizeof(Credential->NtOwfPassword) );
            }
        }
    }

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_GETCHALLENRESP_RESPONSE) +
                        Credential->LogonDomainName.Length + sizeof(WCHAR) +
                        Credential->UserName.Length + sizeof(WCHAR) +
                        NtResponseString.Length + sizeof(WCHAR) +
                        LmResponseString.Length + sizeof(WCHAR);

    ClientBuffer = ExAllocatePool(NonPagedPool, *ReturnBufferSize);
    if (ClientBuffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    GetRespResponse = (PMSV1_0_GETCHALLENRESP_RESPONSE) ClientBuffer;

    //
    // Fill in the return buffer.
    //

    GetRespResponse->MessageType = MsV1_0Lm20GetChallengeResponse;
    RtlCopyMemory( GetRespResponse->UserSessionKey,
                   &UserSessionKey,
                   sizeof(UserSessionKey));
    RtlCopyMemory( GetRespResponse->LanmanSessionKey,
                   LanmanSessionKey,
                   sizeof(LanmanSessionKey) );

    ClientStrings = ((PUCHAR)ClientBuffer) + sizeof(MSV1_0_GETCHALLENRESP_RESPONSE);


    //
    // Copy the logon domain name (the string may be empty)
    //

    NlpPutString(
        &GetRespResponse->LogonDomainName,
        &Credential->LogonDomainName,
        &ClientStrings );

    //
    // Copy the user name (the string may be empty)
    //

    NlpPutString(
        &GetRespResponse->UserName,
        &Credential->UserName,
        &ClientStrings );

    //
    // Copy the Challenge Responses to the client buffer.
    //

    NlpPutString(
        (PUNICODE_STRING)
            &GetRespResponse->CaseSensitiveChallengeResponse,
        (PUNICODE_STRING) &NtResponseString,
        &ClientStrings );

    NlpPutString(
        (PUNICODE_STRING)
            &GetRespResponse->CaseInsensitiveChallengeResponse,
        (PUNICODE_STRING)&LmResponseString,
        &ClientStrings );

    *ProtocolReturnBuffer = ClientBuffer;

Cleanup:

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status) && ( ClientBuffer != NULL ) ) {
        ExFreePool(ClientBuffer);
    }

    //
    // Cleanup locally used resources
    //

    if ( BuiltCredential != NULL ) {
        ExFreePool(BuiltCredential);
    }

    //
    // Return status to the caller.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\kfuncs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        KFUNCS.H
//
// Contents:    xxxK versions of SSPI functions.
//
//
// History:     15 Dec 97,  AdamBa      Created
//
//------------------------------------------------------------------------

#ifndef __KFUNCS_H__
#define __KFUNCS_H__

SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleK(
    PSECURITY_STRING pPrincipal,
    PSECURITY_STRING pPackage,
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pvLogonId,           // Pointer to logon ID
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PCredHandle phCredential,           // (out) Cred Handle
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandleK(
    PCredHandle phCredential            // Handle to free
    );

SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextK(
    PCredHandle phCredential,               // Cred to base context
    PCtxtHandle phContext,                  // Existing context (OPT)
    PSECURITY_STRING pTargetName,
    unsigned long fContextReq,              // Context Requirements
    unsigned long Reserved1,                // Reserved, MBZ
    unsigned long TargetDataRep,            // Data rep of target
    PSecBufferDesc pInput,                  // Input Buffers
    unsigned long Reserved2,                // Reserved, MBZ
    PCtxtHandle phNewContext,               // (out) New Context handle
    PSecBufferDesc pOutput,                 // (inout) Output Buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs
    PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextK(
    PCtxtHandle phContext               // Context to delete
    );

SECURITY_STATUS SEC_ENTRY
FreeContextBufferK(
    void SEC_FAR * pvContextBuffer      // buffer to free
    );

SECURITY_STATUS SEC_ENTRY
MapSecurityErrorK( SECURITY_STATUS hrValue );

#if 0
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesK(
    unsigned long SEC_FAR * pcPackages,     // Receives num. packages
    PSecPkgInfoW SEC_FAR * ppPackageInfo    // Receives array of info
    );

SECURITY_STATUS SEC_ENTRY
QuerySecurityContextTokenK(
    PCtxtHandle phContext,
    void SEC_FAR * SEC_FAR * Token
    );
#endif

#endif   // __KFUNCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\ksecdd.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        KSECDD.H
//
// Contents:    Structures and defines for the security device driver
//
//
// History:     19 May 92,  RichardW    Created
//              15 Dec 97,  AdamBa      Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#ifndef __KSECDD_H__
#define __KSECDD_H__

VOID * SEC_ENTRY
SecAllocate(ULONG cbMemory);

void SEC_ENTRY
SecFree(PVOID pvMemory);

BOOLEAN
GetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PVOID * TokenBuffer,
    OUT PULONG TokenSize,
    IN BOOLEAN ReadonlyOK
    );

BOOLEAN
GetSecurityToken(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PSecBuffer * TokenBuffer
    );

#define DEB_ERROR   0x1
#define DEB_WARN    0x2
#define DEB_TRACE   0x4


#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a, b, 'cesK')
#define ExAllocatePoolWithQuota(a,b)    ExAllocatePoolWithQuotaTag(a, b, 'cesK')
#endif


#if DBG
void
KsecDebugOut(unsigned long  Mask,
            const char *    Format,
            ...);

#define DebugStmt(x) x
#define DebugLog(x) KsecDebugOut x
#else
#define DebugStmt(x)
#define DebugLog(x)
#endif


#endif // __KSECDD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\memmgr.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        memmgr.c
//
// Contents:    Fast memory manager code for KSecDD
//
//
// History:     23 Feb 93   RichardW    Created
//              15 Dec 97   AdamBa      Modified from private\lsa\client\ssp
//               
//
//------------------------------------------------------------------------

#include <rdrssp.h>


#if DBG
ULONG               cActiveCtxtRecs = 0;
#endif


//+-------------------------------------------------------------------------
//
//  Function:   AllocContextRec
//
//  Synopsis:   Allocates a KernelContext structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
PKernelContext
AllocContextRec(void)
{
    PKernelContext  pContext = NULL;

    pContext = (PKernelContext)
                ExAllocatePool(NonPagedPool, sizeof(KernelContext));

    if (pContext == NULL)
    {
        DebugLog((DEB_ERROR,"Could not allocate from pool!\n"));
        return(NULL);
    }

    pContext->pNext = NULL;
    pContext->pPrev = NULL;

    DebugStmt(cActiveCtxtRecs++);

    return(pContext);
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeContextRec
//
//  Synopsis:   Returns a KernelContext record to the free list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
FreeContextRec(PKernelContext   pContext)
{
    //
    // Just return the context to the pool.
    //

    ExFreePool(pContext);

    DebugStmt(cActiveCtxtRecs--);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\ksecdd.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        KSecDD.C
//
// Contents:    Base level stuff for the device driver
//
//
// History:     19 May 92,  RichardW    Blatently stolen from DarrylH
//              15 Dec 97,  AdamBa      Modified from private\lsa\crypt\ssp
//
//------------------------------------------------------------------------

#include <rdrssp.h>


#if DBG
ULONG KsecInfoLevel;

void
KsecDebugOut(unsigned long  Mask,
            const char *    Format,
            ...)
{
    PETHREAD    pThread;
    PEPROCESS   pProcess;
    va_list     ArgList;
    char        szOutString[256];

    if (KsecInfoLevel & Mask)
    {
        pThread = PsGetCurrentThread();
        pProcess = PsGetCurrentProcess();

        va_start(ArgList, Format);
        DbgPrint("%#x.%#x> KSec:  ", pProcess, pThread);
        if (_vsnprintf(szOutString, sizeof(szOutString),Format, ArgList) < 0)
        {
                //
                // Less than zero indicates that the string could not be
                // fitted into the buffer.  Output a special message indicating
                // that:
                //

                DbgPrint("Error printing message\n");

        }
        else
        {
            DbgPrint(szOutString);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\memmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        memmgr.h
//
// Contents:    Memory Manager code for KSecDD
//
//
// History:     23 Feb 93   RichardW    Created
//              15 Dec 97   AdamBa      Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#ifndef __MEMMGR_H__
#define __MEMMGR_H__

PKernelContext  AllocContextRec(void);
void            FreeContextRec(PKernelContext);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\ntlm.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        ntlm.c
//
// Contents:    ntlm kernel-mode functions
//
//
// History:     3/17/94     MikeSw          Created
//              12/15/97    AdamBa          Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#include <rdrssp.h>


KSPIN_LOCK NtlmLock;
PKernelContext pNtlmList;
BOOLEAN NtlmInitialized = FALSE;


//+-------------------------------------------------------------------------
//
//  Function:   NtlmInitialize
//
//  Synopsis:   initializes the NTLM package functions
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NtlmInitialize(void)
{
    KeInitializeSpinLock(&NtlmLock);
    pNtlmList = NULL;
    return(STATUS_SUCCESS);
}


#if 0
//+-------------------------------------------------------------------------
//
//  Function:   NtlmGetToken
//
//  Synopsis:   returns the token from a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NtlmGetToken(   ULONG   ulContext,
                PHANDLE phToken,
                PACCESS_TOKEN * pAccessToken)
{
    PKernelContext  pContext;
    NTSTATUS Status;


    PAGED_CODE();

    pContext = (PKernelContext) ulContext;

    if (pContext == NULL)
    {
        DebugLog((DEB_ERROR,"Invalid handle 0x%x\n", ulContext));

        return(SEC_E_INVALID_HANDLE);
    }

    // Now, after all that checking, let's actually try and set the
    // thread impersonation token.


    if (phToken != NULL)
    {
        *phToken = pContext->TokenHandle;
    }

    if (pAccessToken != NULL)
    {
        if (pContext->TokenHandle != NULL)
        {
            if (pContext->AccessToken == NULL)
            {
                Status = ObReferenceObjectByHandle(
                            pContext->TokenHandle,
                            TOKEN_IMPERSONATE,
                            NULL,       
                            KeGetPreviousMode(),
                            (PVOID *) &pContext->AccessToken,
                            NULL                // no handle information
                            );

                if (!NT_SUCCESS(Status))
                {
                    return(Status);
                }
            }
        }

        *pAccessToken = pContext->AccessToken;
    }

    return(STATUS_SUCCESS);

}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   NtlmInitKernelContext
//
//  Synopsis:   Initializes a kernel context with the session key
//              and possible token handle.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
NtlmInitKernelContext(
    IN PUCHAR UserSessionKey,
    IN PUCHAR LanmanSessionKey,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PKernelContext pContext;
    KIRQL   OldIrql;

    if (!NtlmInitialized) {
        NtlmInitialize();
        NtlmInitialized = TRUE;
    }

    pContext = AllocContextRec();
    if (!pContext)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    RtlCopyMemory(
        pContext->UserSessionKey,
        UserSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );

    RtlCopyMemory(
        pContext->LanmanSessionKey,
        LanmanSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH
        );

    pContext->TokenHandle = TokenHandle;
    pContext->AccessToken = NULL;
    pContext->pPrev = NULL;

    ContextHandle->dwLower = (ULONG_PTR) pContext;
    ContextHandle->dwUpper = 0;

    //
    // Add it to the client record
    //

    AddKernelContext(&pNtlmList, &NtlmLock, pContext);
    return(STATUS_SUCCESS);
}




//+-------------------------------------------------------------------------
//
//  Function:   NtlmDeleteKernelContext
//
//  Synopsis:   Deletes a kernel context from the list of contexts
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
NtlmDeleteKernelContext( PCtxtHandle ContextHandle)
{
    SECURITY_STATUS scRet;


    scRet = DeleteKernelContext(
                    &pNtlmList,
                    &NtlmLock,
                    (PKernelContext) ContextHandle->dwLower );

    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\owf.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    owf.c

Abstract:

    Implentation of the one-way-functions used to implement password hashing.

        RtlCalculateLmOwfPassword
        RtlCalculateNtOwfPassword


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Adam Barr (AdamBa) 12-15-97
        Modified from private\security\lsa\crypt\dll

--*/

#include <rdrssp.h>



NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )

/*++

Routine Description:

    Takes the passed LmPassword and performs a one-way-function on it.
    The current implementation does this by using the password as a key
    to encrypt a known block of text.

Arguments:

    LmPassword - The password to perform the one-way-function on.

    LmOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in LmOwfPassword.

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/

{
    NTSTATUS    Status;
    BLOCK_KEY    Key[2];
    PCHAR       pKey;

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }


    // Use the keys to encrypt the standard text

    Status = RtlEncryptStdBlock(&Key[0], &(LmOwfPassword->data[0]));

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptStdBlock(&Key[1], &(LmOwfPassword->data[1]));

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    return(Status);
}




NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Takes the passed NtPassword and performs a one-way-function on it.
    Uses the RSA MD4 function

Arguments:

    NtPassword - The password to perform the one-way-function on.

    NtOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in NtOwfPassword.
--*/

{
    MD4_CTX     MD4_Context;


    MD4Init(&MD4_Context);

    MD4Update(&MD4_Context, (PCHAR)NtPassword->Buffer, NtPassword->Length);

    MD4Final(&MD4_Context);


    // Copy the digest into our return data area

    ASSERT(sizeof(*NtOwfPassword) == sizeof(MD4_Context.digest));

    RtlMoveMemory((PVOID)NtOwfPassword, (PVOID)MD4_Context.digest,
                  sizeof(*NtOwfPassword));

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\package.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        package.h
//
// Contents:    kernel package structures
//
//
// History:     3-18-94     MikeSw      Created
//
//------------------------------------------------------------------------

#ifndef __PACKAGE_H__
#define __PACKAGE_H__

typedef SECURITY_STATUS
(SEC_ENTRY KspInitPackageFn)(void);

typedef SECURITY_STATUS
(SEC_ENTRY KspDeleteContextFn)(PCtxtHandle ulContextId);

typedef SECURITY_STATUS
(SEC_ENTRY KspInitContextFn)(
    IN PUCHAR UserSessionKey,
    IN PUCHAR LanmanSessionKey,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
);

#if 0
typedef SECURITY_STATUS
(SEC_ENTRY KspGetTokenFn)(  ULONG               ulContextId,
                            HANDLE *            phImpersonationToken,
                            PACCESS_TOKEN *     pAccessToken);
#endif


KspInitPackageFn NtlmInitialize;
KspInitContextFn NtlmInitKernelContext;
KspDeleteContextFn NtlmDeleteKernelContext;
#if 0
KspGetTokenFn NtlmGetToken;
#endif



#endif __PACKAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\nlp.h ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    nlp.h

Abstract:

    NETLOGON private definitions.




Author:

    Jim Kelly 11-Apr-1991

Revision History:
   Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlp.h
   Adam Barr              15-Dec-97      Copied from private\security\msv_sspi

--*/

#ifndef _NLP_
#define _NLP_

#include <windef.h>
#include <winbase.h>
#include <crypt.h>
#include <lmcons.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <logonmsv.h>
#include <samrpc.h>
#include <align.h>
#include <dsgetdc.h>


//
// nlmain.c will #include this file with NLP_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef NLP_ALLOCATE
#define EXTERN
#define INIT(_X) = _X
#else
#define EXTERN extern
#define INIT(_X)
#endif

#define NETLOGON_STARTUP_TIME   900             

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private data structures                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Structure used to keep track of all private information related to a
//  particular LogonId.
//

typedef struct _PACTIVE_LOGON {

    LUID LogonId;               // The logon Id of this logon session

    ULONG EnumHandle;           // The enumeration handle of this logon session

    SECURITY_LOGON_TYPE LogonType;  // Type of logon (interactive or service)

    PSID UserSid;               // Sid of the logged on user

    UNICODE_STRING UserName;    // Name of the logged on user

    UNICODE_STRING LogonDomainName;  // Name of the domain logged onto

    UNICODE_STRING LogonServer; // Name of the server which logged this user on

    ULONG Flags;                    // Attributes of this entry.

#define LOGON_BY_NETLOGON   0x01    // Entry was validated by NETLOGON service
#define LOGON_BY_CACHE      0x02    // Entry was validated by local cache
#define LOGON_BY_OTHER_PACKAGE 0x04 // Entry was validated by another authentication package
#define LOGON_BY_LOCAL 0x08         // Entry was validated by local sam

    struct _PACTIVE_LOGON * Next;   // Next entry in linked list.

} ACTIVE_LOGON, *PACTIVE_LOGON;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       CREDENTIAL Related Data Structures                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//   Following is a description of the content and format of each type
//   of credential maintained by the MsV1_0 authentication package.
//
//   The MsV1_0 authentication package defines the following credential
//   primary key string values:
//
//       "Primary" - Is used to hold the primary credentials provided at
//           initial logon time.  This includes the username and both
//           case-sensitive and case-insensitive forms of the user's
//           password.
//
//   NOTE: All poitners stored in credentials must be
//   changed to be an offset to the body rather than a pointer.  This is
//   because credential fields are copied by the LSA and so the pointer
//   would become invalid.
//


//
// MsV1_0 Primary Credentials
//
//
//        The PrimaryKeyValue string of this type of credential contains the
//        following string:
//
//                  "Primary"
//
//        The Credential string of a Primary credential contains the following
//        values:
//
//             o  The user's username
//
//             o  A one-way function of the user's password as typed.
//
//             o  A one-way function of the user's password upper-cased.
//
//        These values are structured as follows:
//

#define MSV1_0_PRIMARY_KEY "Primary"

typedef struct _MSV1_0_PRIMARY_CREDENTIAL {
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    NT_OWF_PASSWORD NtOwfPassword;
    LM_OWF_PASSWORD LmOwfPassword;
    BOOLEAN NtPasswordPresent;
    BOOLEAN LmPasswordPresent;
} MSV1_0_PRIMARY_CREDENTIAL, *PMSV1_0_PRIMARY_CREDENTIAL;



//
// Structure describing a buffer in the clients address space.
//

typedef struct _CLIENT_BUFFER_DESC {
    PLSA_CLIENT_REQUEST ClientRequest;
    LPBYTE UserBuffer;      // Address of buffer in client's address space
    LPBYTE MsvBuffer;       // Address of mirror buffer in MSV's address space
    ULONG StringOffset;     // Current offset to variable length data
    ULONG TotalSize;        // Size (in bytes) of buffer
} CLIENT_BUFFER_DESC, *PCLIENT_BUFFER_DESC;


//
// Structure describing logon information and credential use flags
//

typedef struct _MS_LOGON_CREDENTIAL {
    LUID LogonId;
    ULONG_PTR CredentialUse;
} MS_LOGON_CREDENTIAL, *PMS_LOGON_CREDENTIAL;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal routine definitions                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// From nlmain.c.
//

NTSTATUS
NlSamInitialize(
    ULONG Timeout
    );

//
// From nlp.c.
//

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    );

VOID
NlpInitClientBuffer(
    OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PLSA_CLIENT_REQUEST ClientRequest
    );

NTSTATUS
NlpAllocateClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN ULONG FixedSize,
    IN ULONG TotalSize
    );

NTSTATUS
NlpFlushClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    OUT PVOID* UserBuffer
    );

VOID
NlpFreeClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc
    );

VOID
NlpPutClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

VOID
NlpMakeRelativeString(
    IN PUCHAR BaseAddress,
    IN OUT PUNICODE_STRING String
    );

VOID
NlpRelativeToAbsolute(
    IN PVOID BaseAddress,
    IN OUT PULONG RelativeValue
    );

BOOLEAN
NlpFindActiveLogon(
    IN PLUID LogonId,
    OUT PACTIVE_LOGON **ActiveLogon
    );

ULONG
NlpCountActiveLogon(
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING UserName
    );

NTSTATUS
NlpAllocateInteractiveProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO2 NlpUser
    );

NTSTATUS
NlpAllocateNetworkProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO2 NlpUser
    );

PSID
NlpMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

NTSTATUS
NlpMakeTokenInformationV1(
    IN  PNETLOGON_VALIDATION_SAM_INFO2 NlpUser,
    OUT PLSA_TOKEN_INFORMATION_V1 *TokenInformation
    );

NTSTATUS
NlpMakePrimaryCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize,
    IN BOOLEAN OwfPasswordProvided
    );

NTSTATUS
NlpAddPrimaryCredential(
    IN PLUID LogonId,
    IN PMSV1_0_PRIMARY_CREDENTIAL Credential,
    IN ULONG CredentialSize
    );

NTSTATUS
NlpGetPrimaryCredential(
    IN PLUID LogonId,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    );

NTSTATUS
NlpDeletePrimaryCredential(
    IN PLUID LogonId
    );

NTSTATUS
NlpChangePassword(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    );


//
// msvsam.c
//

BOOLEAN
MsvpPasswordValidate (
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN PUSER_INTERNAL1_INFORMATION Passwords,
    OUT PULONG UserFlags,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
);




//
// nlnetapi.c
//

VOID
NlpLoadNetapiDll (
    VOID
    );

VOID
NlpLoadNetlogonDll (
    VOID
    );

//
// subauth.c
//

VOID
Msv1_0SubAuthenticationInitialization(
    VOID
);


///////////////////////////////////////////////////////////////////////
//                                                                   //
// Global variables                                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ ONLY  Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////


//
// Null copies of Lanman and NT OWF password.
//
//

EXTERN LM_OWF_PASSWORD NlpNullLmOwfPassword;
EXTERN NT_OWF_PASSWORD NlpNullNtOwfPassword;

//
// Routines in NetApi32.dll
//


EXTERN BOOLEAN NlpNetapiDllLoaded;
EXTERN NET_API_STATUS  (NET_API_FUNCTION *NlpNetApiBufferFree)(LPVOID);
EXTERN NET_API_STATUS  (NET_API_FUNCTION *NlpRxNetUserPasswordSet)(LPWSTR, LPWSTR, LPWSTR, LPWSTR);
EXTERN NET_API_STATUS  (NET_API_FUNCTION *NlpDsGetDcName)(LPCWSTR, LPCWSTR, GUID *, LPCWSTR, ULONG, PDOMAIN_CONTROLLER_INFOW *);
EXTERN NTSTATUS (*NlpNetpApiStatusToNtStatus)( NET_API_STATUS );

//
// Routines in netlogon.dll
//

EXTERN HANDLE NlpNetlogonDllHandle;
EXTERN PNETLOGON_SAM_LOGON_PROCEDURE NlpNetLogonSamLogon;
EXTERN PNETLOGON_SAM_LOGOFF_PROCEDURE NlpNetLogonSamLogoff;

//
// TRUE if package is initialized
//

EXTERN BOOLEAN NlpMsvInitialized INIT(FALSE);

//
// TRUE if this is a workstation.
//

EXTERN BOOLEAN NlpWorkstation INIT(TRUE);

//
// TRUE once the MSV AP has initialized its connection to SAM.
//

EXTERN BOOLEAN NlpSamInitialized INIT(FALSE);

//
// TRUE if the MSV AP has initialized its connection to the NETLOGON service
//

EXTERN BOOLEAN NlpNetlogonInitialized INIT(FALSE);

//
// TRUE if LanMan is installed.
//

EXTERN BOOLEAN NlpLanmanInstalled INIT(FALSE);

//
// Computername of this computer.
//

EXTERN UNICODE_STRING NlpComputerName;

//
// Name and domain id of the SAM account database.
//

EXTERN UNICODE_STRING NlpSamDomainName;
EXTERN PSID NlpSamDomainId;
EXTERN SAMPR_HANDLE NlpSamDomainHandle;
EXTERN BOOLEAN NlpUasCompatibilityRequired INIT(TRUE);

//
// Trusted Handle to the Lsa database.
//

EXTERN LSA_HANDLE NlpPolicyHandle INIT(NULL);


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ/WRITE Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Define the list of active interactive logons.
//
// The NlpActiveLogonLock must be locked while referencing the list or
// any of its elements.
//

#define NlpLockActiveLogons()   RtlEnterCriticalSection(&NlpActiveLogonLock)
#define NlpUnlockActiveLogons() RtlLeaveCriticalSection(&NlpActiveLogonLock)

EXTERN RTL_CRITICAL_SECTION NlpActiveLogonLock;
EXTERN PACTIVE_LOGON NlpActiveLogons;

//
// Define the running enumeration handle.
//
// This variable defines the enumeration handle to assign to a logon
//  session.  It will be incremented prior to assigning it value to
//  the next created logon session.  Access is serialize using
//  NlpActiveLogonLocks.

EXTERN ULONG NlpEnumerationHandle;

//
// Define a running Session Number which is incremented once for each
// challenge given to the server.
//

EXTERN RTL_CRITICAL_SECTION NlpSessionCountLock;
EXTERN ULONG NlpSessionCount;
EXTERN ULONG NlpLogonAttemptCount;


#undef EXTERN
#undef INIT
#endif _NLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\rdrssp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        rdrssp.h
//
// Contents:    precompiled header include for rdrssp.lib
//
//
// History:     3-17-94     MikeSw      Created
//              12-15-97    AdamBa      Modified from private\lsa\client\ssp\sspdrv.h
//
//------------------------------------------------------------------------

#ifndef __RDRSSP_H__
#define __RDRSSP_H__


#include <stdio.h>
#include <ntos.h>
#include <ntlmsp.h>
#define SECURITY_NTLM
#include <security.h>
#include <ntmsv1_0.h>
#include <zwapi.h>
#include <windef.h>
#include <lmcons.h>
#include <crypt.h>
#include <engine.h>
#include "connmgr.h"
#include "ksecdd.h"
#include "package.h"
#include "memmgr.h"
#include "kfuncs.h"  // xxxK functions
#include "secret.h"



#endif // __RDRSSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\secret.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    secret.c

Abstract:

    This module contains the code to read and write secrets from disk.

Author:

    Adam Barr (adamba) 13-June-1997

Revision History:

    Adam Barr (adamba) 29-December-1997
        Modified from private\ntos\boot\lib\blsecret.c.

--*/

#include <rdrssp.h>
#include <rc4.h>
#include <wcstr.h>

#if defined(REMOTE_BOOT)

#if 0
VOID
RdrpDumpSector(
    PUCHAR Sector
    )
{
    int i, j;

    PUCHAR SectorChar = (PUCHAR)Sector;

    for (i = 0; i < 512; i+= 16) {

        for (j = 0; j < 16; j++) {
            DbgPrint("%2.2x ", SectorChar[i + j]);
        }
        DbgPrint("  ");
        for (j = 0; j < 16; j++) {
            if ((SectorChar[i+j] >= ' ') && (SectorChar[i+j] < '~')) {
                DbgPrint("%c", SectorChar[i+j]);
            } else {
                DbgPrint(".");
            }
        }
        DbgPrint("\n");
    }
}
#endif


NTSTATUS
RdrOpenRawDisk(
    PHANDLE Handle
    )

/*++

Routine Description:

    This routine opens the raw disk for read/write.

Arguments:

    Handle - returns the Handle if successful, for use in subsequent calls.

Return Value:

    The status return from the ZwOpenFile.

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING physicalDriveString;
    IO_STATUS_BLOCK ioStatus;

    RtlInitUnicodeString(&physicalDriveString, L"\\Device\\Harddisk0\\Partition0");

    InitializeObjectAttributes(
        &objectAttributes,
        &physicalDriveString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = ZwOpenFile(
                 Handle,
                 FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE,
                 &objectAttributes,
                 &ioStatus,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_NONALERT);

    if ((!NT_SUCCESS(status)) || (!NT_SUCCESS(ioStatus.Status))) {
 
        KdPrint(("RdrOpenRawDisk: status on ZwOpenFile: %x, %x\n", status, ioStatus.Status));
        if (NT_SUCCESS(status)) {
            status = ioStatus.Status;
        }

    }

    return status;

}


NTSTATUS
RdrCloseRawDisk(
    HANDLE Handle
    )

/*++

Routine Description:

    This routine closes the raw disk.

Arguments:

    Handle - The Handle returned by RdrOpenRawDisk.

Return Value:

    The status return from the ZwClose.

--*/

{

    return ZwClose(Handle);

}


NTSTATUS
RdrCheckForFreeSectors (
    HANDLE Handle
    )

/*++

Routine Description:

    This routine makes sure that the MBR looks correct and that there
    is nothing installed (OnTrack or EZ-Drive need to detect
    NT fault-tolerance also) that would prevent us from using the third
    sector for storing the password secret.

Arguments:

    Handle - The Handle returned by RdrOpenRawDisk.

Return Value:

    ESUCCESS if the disk is OK, or an error.

--*/

{
 
    NTSTATUS status;
    USHORT Sector[256];
    ULONG BytesRead;
    PPARTITION_DESCRIPTOR Partition;
    LARGE_INTEGER SeekPosition;
    IO_STATUS_BLOCK ioStatus;
 

    SeekPosition.QuadPart = 0;

    //
    // Read the MBR at the start of the disk.
    //

    status = ZwReadFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatus,
                 Sector,
                 512,
                 &SeekPosition,
                 NULL);

    if ((!NT_SUCCESS(status)) || (!NT_SUCCESS(ioStatus.Status))) {
 
        KdPrint(("RdrCheckForFreeSectors: status on ZwReadFile: %x, %x\n", status, ioStatus.Status));
        if (NT_SUCCESS(status)) {
            status = ioStatus.Status;
        }
        return status;

    }

#if 0
    RdrpDumpSector((PUCHAR)Sector);
#endif

    //
    // Make sure the signature is OK, and that the type of partition
    // 0 is not 0x54 (OnTrack) or 0x55 (EZ-Drive).
    //

    if (Sector[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {

        KdPrint(("RdrCheckForFreeSectors: Boot record signature %x not found (%x found)\n",
                BOOT_RECORD_SIGNATURE,
                Sector[BOOT_SIGNATURE_OFFSET] ));
        return STATUS_INVALID_PARAMETER;
    }

    Partition = (PPARTITION_DESCRIPTOR)&Sector[PARTITION_TABLE_OFFSET];

    if ((Partition->PartitionType == 0x54) ||
        (Partition->PartitionType == 0x55)) {

        KdPrint(("RdrCheckForFreeSectors: First partition has type %x, exiting\n", Partition->PartitionType));
        return STATUS_INVALID_PARAMETER;
    }

    KdPrint(("RdrCheckForFreeSectors: Partition type is %d\n", Partition->PartitionType));

    return STATUS_SUCCESS;

}


NTSTATUS
RdrReadSecret(
    HANDLE Handle,
    PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine reads the secret from the disk, if present.

Arguments:

    Handle - The Handle returned by RdrOpenRawDisk.

Return Value:

    ESUCCESS if the secret is OK, an error otherwise.

--*/

{

    NTSTATUS status;
    ULONG BytesRead;
    LARGE_INTEGER SeekPosition;
    IO_STATUS_BLOCK ioStatus;
    UCHAR Sector[512];
 

    //
    // Seek to the third sector. 
    
    // DEADISSUE 08/08/2000 -- this is in an #ifdef REMOTE_BOOT block,
    // which is dead code, left here in case it is ever resuurected:
    // I am pretty sure we can assume that the first disk has 512-byte sectors.
    //

    SeekPosition.QuadPart = 2 * 512;

    //
    // Read a full sector. The secret is at the beginning.
    //

    status = ZwReadFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatus,
                 Sector,
                 512,
                 &SeekPosition,
                 NULL);

    if ((!NT_SUCCESS(status)) || (!NT_SUCCESS(ioStatus.Status))) {
 
        KdPrint(("RdrReadSecret: status on ZwReadFile: %x, %x\n", status, ioStatus.Status));
        if (NT_SUCCESS(status)) {
            status = ioStatus.Status;
        }
        return status;

    }

    RtlMoveMemory(Secret, Sector, sizeof(RI_SECRET));

    if (memcmp(Secret->Signature, RI_SECRET_SIGNATURE, 4) != 0) {

        KdPrint(("RdrReadSecret: No signature found\n"));
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;

}



NTSTATUS
RdrWriteSecret(
    HANDLE Handle,
    PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine writes the secret to the disk.

Arguments:

    Handle - The Handle returned by RdrOpenRawDisk.

Return Value:

    ESUCCESS if the secret is written OK, an error otherwise.

--*/

{

    NTSTATUS status;
    ULONG BytesWritten;
    LARGE_INTEGER SeekPosition;
    IO_STATUS_BLOCK ioStatus;
    UCHAR Sector[512];
 

    //
    // Seek to the third sector.
    //

    SeekPosition.QuadPart = 2 * 512;

    //
    // Copy the secret to a full sector since the raw disk requires
    // reads/writes in sector multiples.
    //

    RtlZeroMemory(Sector, sizeof(Sector));
    RtlMoveMemory(Sector, Secret, sizeof(RI_SECRET));

    //
    // Write a secret-sized chunk.
    //

    status = ZwWriteFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatus,
                 Sector,
                 512,
                 &SeekPosition,
                 NULL);

    if ((!NT_SUCCESS(status)) || (!NT_SUCCESS(ioStatus.Status))) {
 
        KdPrint(("RdrWriteSecret: status on ZwWriteFile: %x, %x\n", status, ioStatus.Status));
        if (NT_SUCCESS(status)) {
            status = ioStatus.Status;
        }
        return status;

    }

    return STATUS_SUCCESS;

}



VOID
RdrInitializeSecret(
    IN PUCHAR Domain,
    IN PUCHAR User,
    IN PUCHAR LmOwfPassword1,
    IN PUCHAR NtOwfPassword1,
    IN PUCHAR LmOwfPassword2 OPTIONAL,
    IN PUCHAR NtOwfPassword2 OPTIONAL,
    IN PUCHAR Sid,
    IN OUT PRI_SECRET Secret
    )
{
    int Length;
    int i;
    struct RC4_KEYSTRUCT Key;

    memset(Secret, 0, sizeof(RI_SECRET));

    memcpy(Secret->Signature, RI_SECRET_SIGNATURE, 4);
    Secret->Version = 1;

    Length = strlen(Domain);
    memcpy(Secret->Domain, Domain, Length);

    Length = strlen(User);
    memcpy(Secret->User, User, Length);

    memcpy(Secret->Sid, Sid, RI_SECRET_SID_SIZE);

    //
    // Encrypt the passwords using the user name.
    //

#ifdef RDR_USE_LM_PASSWORD
    memcpy(Secret->LmEncryptedPassword1, LmOwfPassword1, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, Secret->LmEncryptedPassword1);

    if (LmOwfPassword2 != NULL) {
        memcpy(Secret->LmEncryptedPassword2, LmOwfPassword2, LM_OWF_PASSWORD_SIZE);
        rc4_key(&Key, strlen(User), User);
        rc4(&Key, LM_OWF_PASSWORD_SIZE, Secret->LmEncryptedPassword2);
    }
#endif

    memcpy(Secret->NtEncryptedPassword1, NtOwfPassword1, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, Secret->NtEncryptedPassword1);

    if (NtOwfPassword2 != NULL) {
        memcpy(Secret->NtEncryptedPassword2, NtOwfPassword2, NT_OWF_PASSWORD_SIZE);
        rc4_key(&Key, strlen(User), User);
        rc4(&Key, NT_OWF_PASSWORD_SIZE, Secret->NtEncryptedPassword2);
    }

}
#endif // defined(REMOTE_BOOT)



VOID
RdrParseSecret(
    IN OUT PUCHAR Domain,
    IN OUT PUCHAR User,
    IN OUT PUCHAR LmOwfPassword1,
    IN OUT PUCHAR NtOwfPassword1,
#if defined(REMOTE_BOOT)
    IN OUT PUCHAR LmOwfPassword2,
    IN OUT PUCHAR NtOwfPassword2,
#endif // defined(REMOTE_BOOT)
    IN OUT PUCHAR Sid,
    IN PRI_SECRET Secret
    )
{
    struct RC4_KEYSTRUCT Key;

    memcpy(Domain, Secret->Domain, RI_SECRET_DOMAIN_SIZE);
    Domain[RI_SECRET_DOMAIN_SIZE] = '\0';

    memcpy(User, Secret->User, RI_SECRET_USER_SIZE);
    User[RI_SECRET_USER_SIZE] = '\0';

    memcpy(Sid, Secret->Sid, RI_SECRET_SID_SIZE);

    //
    // Decrypt the passwords using the user name.
    //

#ifdef RDR_USE_LM_PASSWORD
    memcpy(LmOwfPassword1, Secret->LmEncryptedPassword1, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, LmOwfPassword1);

#if defined(REMOTE_BOOT)
    memcpy(LmOwfPassword2, Secret->LmEncryptedPassword2, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, LmOwfPassword2);
#endif // defined(REMOTE_BOOT)
#else
    memset(LmOwfPassword1, 0, LM_OWF_PASSWORD_SIZE);
#if defined(REMOTE_BOOT)
    memset(LmOwfPassword2, 0, LM_OWF_PASSWORD_SIZE);
#endif // defined(REMOTE_BOOT)
#endif

    memcpy(NtOwfPassword1, Secret->NtEncryptedPassword1, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, NtOwfPassword1);

#if defined(REMOTE_BOOT)
    memcpy(NtOwfPassword2, Secret->NtEncryptedPassword2, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, NtOwfPassword2);
#endif // defined(REMOTE_BOOT)

}



#if defined(REMOTE_BOOT)
VOID
RdrOwfPassword(
    IN PUNICODE_STRING Password,
    IN OUT PUCHAR LmOwfPassword,
    IN OUT PUCHAR NtOwfPassword
    )
{
    char TmpText[CLEAR_BLOCK_LENGTH*2];
    char TmpChar;
    int Length;
    int i;

#ifdef RDR_USE_LM_PASSWORD
    Length = Password.Length / sizeof(WCHAR);

    //
    // Convert the password to an upper-case ANSI buffer.
    //

    if (Length == 0) {
        TmpText[0] = '\0';
    } else {
        for (i = 0; i <= Length; i++) {
            wctomb(&TmpChar, Password.Buffer[i]);
            TmpText[i] = toupper(TmpChar);
        }
    }

    RtlCalculateLmOwfPassword((PLM_PASSWORD)TmpText, (PLM_OWF_PASSWORD)LmOwfPassword);
#else
    memset(LmOwfPassword, 0, LM_OWF_PASSWORD_SIZE);
#endif

    RtlCalculateNtOwfPassword(Password, (PNT_OWF_PASSWORD)NtOwfPassword);
}
#endif // defined(REMOTE_BOOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\response.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    response.c

Abstract:

    Contains functions that calculate the correct response to return
    to the server when logging on.

        RtlCalculateLmResponse
        RtlCalculateNtResponse


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Adam Barr (AdamBa) 12-15-97
        Modified from private\security\lsa\crypt\dll

--*/

#include <rdrssp.h>



NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    )

/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return to the server.

Arguments:

    LmChallenge - The challenge sent by the server

    LmOwfPassword - The hashed password.

    LmResponse - The response is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The response
                     is in LmResponse.

    STATUS_UNSUCCESSFUL - Something failed. The LmResponse is undefined.
--*/

{
    NTSTATUS    Status;
    BLOCK_KEY    Key;
    PCHAR       pKey, pData;

    // The first 2 keys we can get at by type-casting

    Status = RtlEncryptBlock(LmChallenge,
                             &(((PBLOCK_KEY)(LmOwfPassword->data))[0]),
                             &(LmResponse->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock(LmChallenge,
                             &(((PBLOCK_KEY)(LmOwfPassword->data))[1]),
                             &(LmResponse->data[1]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // To get the last key we must copy the remainder of the OwfPassword
    // and fill the rest of the key with 0s

    pKey = &(Key.data[0]);
    pData = (PCHAR)&(((PBLOCK_KEY)(LmOwfPassword->data))[2]);

    while (pData < (PCHAR)&(LmOwfPassword->data[2])) {
        *pKey++ = *pData++;
    }

    // Zero extend

    while (pKey < (PCHAR)&((&Key)[1])) {
        *pKey++ = 0;
    }

    // Use the 3rd key

    Status = RtlEncryptBlock(LmChallenge, &Key, &(LmResponse->data[2]));

    return(Status);
}







NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    )
/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return(to the server.

Arguments:

    NtChallenge - The challenge sent by the server

    NtOwfPassword - The hashed password.

    NtResponse - The response is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The response
                     is in NtResponse.

    STATUS_UNSUCCESSFUL - Something failed. The NtResponse is undefined.
--*/

{

    // Use the LM version until we change the definitions of any of
    // these data types

    return(RtlCalculateLmResponse((PLM_CHALLENGE)NtChallenge,
                                  (PLM_OWF_PASSWORD)NtOwfPassword,
                                  (PLM_RESPONSE)NtResponse));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\secret.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        SECRET.H
//
// Contents:    Redirector functions to read/write remote boot secrets
//
//
// History:     29 Dec 97,  AdamBa      Created
//
//------------------------------------------------------------------------

#ifndef __RDRSECRET_H__
#define __RDRSECRET_H__

#include <remboot.h>

#define SECPKG_CRED_OWF_PASSWORD  0x00000010

#if defined(REMOTE_BOOT)
NTSTATUS
RdrOpenRawDisk(
    PHANDLE Handle
    );

NTSTATUS
RdrCloseRawDisk(
    HANDLE Handle
    );

NTSTATUS
RdrCheckForFreeSectors (
    HANDLE Handle
    );

NTSTATUS
RdrReadSecret(
    HANDLE Handle,
    PRI_SECRET Secret
    );

NTSTATUS
RdrWriteSecret(
    HANDLE Handle,
    PRI_SECRET Secret
    );

VOID
RdrInitializeSecret(
    IN PUCHAR Domain,
    IN PUCHAR User,
    IN PUCHAR LmOwfPassword1,
    IN PUCHAR NtOwfPassword1,
    IN PUCHAR LmOwfPassword2 OPTIONAL,
    IN PUCHAR NtOwfPassword2 OPTIONAL,
    IN PUCHAR Sid,
    IN OUT PRI_SECRET Secret
    );
#endif // defined(REMOTE_BOOT)

VOID
RdrParseSecret(
    IN OUT PUCHAR Domain,
    IN OUT PUCHAR User,
    IN OUT PUCHAR LmOwfPassword1,
    IN OUT PUCHAR NtOwfPassword1,
#if defined(REMOTE_BOOT)
    IN OUT PUCHAR LmOwfPassword2,
    IN OUT PUCHAR NtOwfPassword2,
#endif // defined(REMOTE_BOOT)
    IN OUT PUCHAR Sid,
    IN PRI_SECRET Secret
    );

#if defined(REMOTE_BOOT)
VOID
RdrOwfPassword(
    IN PUNICODE_STRING Password,
    IN OUT PUCHAR LmOwfPassword,
    IN OUT PUCHAR NtOwfPassword
    );
#endif // defined(REMOTE_BOOT)


#endif // __RDRSECRET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\userkey.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    userkey.c

Abstract:

    Implentation of the functions that get and generate user session keys

        RtlCalculateUserSessionKeyLm
        RtlCalculateUserSessionKeyNt

Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Adam Barr (AdamBa) 12-15-97
        Modified from private\security\lsa\crypt\dll

--*/

#include <rdrssp.h>


//
// Define this if you want to know all about user session keys
//

// #define DEBUG_USER_SESSION_KEYS

//
// Define the user session key that represents an error.
// This value will be generated by other parts of the system on failure.
// We will check for it in our query code and return an error if it's found.
//

USER_SESSION_KEY ErrorSessionKey = { 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0
                                   };



NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

    The current implementation takes the one-way-function of the OwfPassword
    and returns this as the key.

Arguments:

    LmResponse - The response sent during session setup.

    LmOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    NTSTATUS Status;
    NT_PASSWORD NtPassword;

    //
    // Make the Owf password look like an NT password
    //

    NtPassword.Buffer = (PWSTR)LmOwfPassword; // We can do this cast because we
                                              // know the OWF routine treats this
                                              // pointer as a byte pointer.
    NtPassword.Length = sizeof(*LmOwfPassword);
    NtPassword.MaximumLength = sizeof(*LmOwfPassword);


    //
    // Calculate the OWF of the OwfPassword
    //

    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(*UserSessionKey));

    Status = RtlCalculateNtOwfPassword( &NtPassword,
                                        (PNT_OWF_PASSWORD)UserSessionKey
                                        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlCalculateUserSessionKeyLm : OWF calculation failed, status = 0x%lx\n", Status));
        return(Status);
    }

    //
    // Check if we've generated the error session key
    //

    if (RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) == sizeof(*UserSessionKey)) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlCalculateSessionKeyLm - generated error session key, modifying it\n"));
#endif
        //
        // Move away from the error session key
        //

        UserSessionKey->data[0].data[0] ++;

        ASSERT(RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) != sizeof(*UserSessionKey));
    }

#ifdef DEBUG_USER_SESSION_KEYS
    KdPrint(("RtlCalculateUserSessionKeyLm : Key = 0x%lx : %lx : %lx : %lx\n",
            ((PULONG)UserSessionKey)[0], ((PULONG)UserSessionKey)[1],
            ((PULONG)UserSessionKey)[2], ((PULONG)UserSessionKey)[3]));
#endif

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(LmResponse);
}



NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

Arguments:

    NtResponse - The response sent during session setup.

    NtOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    // Just call the LM version

    ASSERT(sizeof(NT_RESPONSE) == sizeof(LM_RESPONSE));
    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(LM_OWF_PASSWORD));

    return(RtlCalculateUserSessionKeyLm((PLM_RESPONSE)NtResponse,
                                        (PLM_OWF_PASSWORD)NtOwfPassword,
                                        UserSessionKey));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\support.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        support.cxx
//
// Contents:    support routines for ksecdd.sys
//
//
// History:     3-7-94      Created     MikeSw
//              12-15-97    Modified from private\lsa\client\ssp   AdamBa
//
//------------------------------------------------------------------------

#include <rdrssp.h>



//+-------------------------------------------------------------------------
//
//  Function:   SecAllocate
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID * SEC_ENTRY
SecAllocate(ULONG cbMemory)
{
    return(ExAllocatePool(NonPagedPool, cbMemory));
}



//+-------------------------------------------------------------------------
//
//  Function:   SecFree
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void SEC_ENTRY
SecFree(PVOID pvMemory)
{
    ExFreePool(pvMemory);
}



//+-------------------------------------------------------------------------
//
//  Function:   MapSecurityErrorK
//
//  Synopsis:   maps a HRESULT from the security interface to a NTSTATUS
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS SEC_ENTRY
MapSecurityErrorK(HRESULT Error)
{
    return((NTSTATUS) Error);
}


//+-------------------------------------------------------------------------
//
//  Function:   GetTokenBuffer
//
//  Synopsis:   
//
//    This routine parses a Token Descriptor and pulls out the useful
//    information.
//
//  Effects:    
//
//  Arguments:  
//
//    TokenDescriptor - Descriptor of the buffer containing (or to contain) the
//        token. If not specified, TokenBuffer and TokenSize will be returned
//        as NULL.
//
//    BufferIndex - Index of the token buffer to find (0 for first, 1 for
//        second).
//
//    TokenBuffer - Returns a pointer to the buffer for the token.
//
//    TokenSize - Returns a pointer to the location of the size of the buffer.
//
//    ReadonlyOK - TRUE if the token buffer may be readonly.
//
//  Requires:
//
//  Returns:    
//
//    TRUE - If token buffer was properly found.
//
//  Notes:  
//      
//
//--------------------------------------------------------------------------


BOOLEAN
GetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PVOID * TokenBuffer,
    OUT PULONG TokenSize,
    IN BOOLEAN ReadonlyOK
    )
{
    ULONG i, Index = 0;

    //
    // If there is no TokenDescriptor passed in,
    //  just pass out NULL to our caller.
    //

    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        *TokenBuffer = NULL;
        *TokenSize = 0;
        return TRUE;
    }

    //
    // Check the version of the descriptor.
    //

    if ( TokenDescriptor->ulVersion != SECBUFFER_VERSION ) {
        return FALSE;
    }

    //
    // Loop through each described buffer.
    //

    for ( i=0; i<TokenDescriptor->cBuffers ; i++ ) {
        PSecBuffer Buffer = &TokenDescriptor->pBuffers[i];
        if ( (Buffer->BufferType & (~SECBUFFER_READONLY)) == SECBUFFER_TOKEN ) {

            //
            // If the buffer is readonly and readonly isn't OK,
            //  reject the buffer.
            //

            if ( !ReadonlyOK && (Buffer->BufferType & SECBUFFER_READONLY) ) {
                return FALSE;
            }

            if (Index != BufferIndex)
            {
                Index++;
                continue;
            }

            //
            // Return the requested information
            //

            *TokenBuffer = Buffer->pvBuffer;
            *TokenSize = Buffer->cbBuffer;
            return TRUE;
        }

    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetSecurityToken
//
//  Synopsis:   
//    This routine parses a Token Descriptor and pulls out the useful
//    information.
//
//  Effects:    
//
//  Arguments:  
//    TokenDescriptor - Descriptor of the buffer containing (or to contain) the
//        token. If not specified, TokenBuffer and TokenSize will be returned
//        as NULL.
//
//    BufferIndex - Index of the token buffer to find (0 for first, 1 for
//        second).
//
//    TokenBuffer - Returns a pointer to the buffer for the token.
//
//  Requires:
//
//  Returns:    
//
//    TRUE - If token buffer was properly found.
//
//  Notes:  
//      
//
//--------------------------------------------------------------------------


BOOLEAN
GetSecurityToken(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PSecBuffer * TokenBuffer
    )
{
    ULONG i;
    ULONG Index = 0;

    PAGED_CODE();

    //
    // If there is no TokenDescriptor passed in,
    //  just pass out NULL to our caller.
    //

    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        *TokenBuffer = NULL;
        return TRUE;
    }

    //
    // Check the version of the descriptor.
    //

    if ( TokenDescriptor->ulVersion != SECBUFFER_VERSION ) {
        return FALSE;
    }

    //
    // Loop through each described buffer.
    //

    for ( i=0; i<TokenDescriptor->cBuffers ; i++ ) {
        PSecBuffer Buffer = &TokenDescriptor->pBuffers[i];
        if ( (Buffer->BufferType & (~SECBUFFER_READONLY)) == SECBUFFER_TOKEN ) {

            //
            // If the buffer is readonly and readonly isn't OK,
            //  reject the buffer.
            //

            if ( Buffer->BufferType & SECBUFFER_READONLY ) {
                return FALSE;
            }

            if (Index != BufferIndex)
            {
                Index++;
                continue;
            }
            //
            // Return the requested information
            //

            *TokenBuffer = Buffer;
            return TRUE;
        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\stubs.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        stubs.cxx
//
// Contents:    user-mode stubs for security API
//
//
// History:     3/5/94      MikeSw      Created
//              12/15/97    AdamBa      Modified from security\lsa\security\ntlm
//
//------------------------------------------------------------------------

#include <rdrssp.h>

#include <nturtl.h>
#include <align.h>
#include "nlp.h"


static CredHandle NullCredential = {0,0};

#define NTLMSSP_REQUIRED_NEGOTIATE_FLAGS (  NTLMSSP_NEGOTIATE_UNICODE | \
                                            NTLMSSP_REQUEST_INIT_RESPONSE )

NTSTATUS
MspLm20GetChallengeResponse (
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    IN BOOLEAN OwfPasswordProvided
    );


//+-------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleK(
    PSECURITY_STRING            pssPrincipal,       // Name of principal
    PSECURITY_STRING            pssPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet;
    SECURITY_STRING Principal;
    TimeStamp   OptionalTimeStamp;
    UNICODE_STRING PackageName;
    PMS_LOGON_CREDENTIAL LogonCredential;

    if (!pssPackageName)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    //
    // We don't accept principal names either.
    //

    if (pssPrincipal)
    {
        return(SEC_E_UNKNOWN_CREDENTIALS);
    }


    //
    // Make sure they want the NTLM security package
    //
    RtlInitUnicodeString(
        &PackageName,
        NTLMSP_NAME
        );


    if (!RtlEqualUnicodeString(
            pssPackageName,
            &PackageName,
            TRUE))
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

#if 0
    //
    // For the moment, only accept OWF passwords. This is the
    // easiest for now since there is no place to record the
    // flag otherwise. The password provided is assumed to
    // be the LM and NT OWF passwords concatenated together.
    //

    if ((fCredentialUse & SECPKG_CRED_OWF_PASSWORD) == 0) {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }
#endif

    //
    // The credential handle is the logon id
    //

    if (fCredentialUse & SECPKG_CRED_OUTBOUND)
    {
        if (pvLogonId != NULL)
        {
            LogonCredential = (PMS_LOGON_CREDENTIAL)SecAllocate(sizeof(MS_LOGON_CREDENTIAL));

            if (LogonCredential == NULL) {
                return(SEC_E_INSUFFICIENT_MEMORY);
            }

            LogonCredential->LogonId = *((PLUID)pvLogonId);
            LogonCredential->CredentialUse = fCredentialUse;

            *(PMS_LOGON_CREDENTIAL *)phCredential = LogonCredential;
        }
        else
        {
            return(SEC_E_UNKNOWN_CREDENTIALS);
        }

    }
    else if (fCredentialUse & SECPKG_CRED_INBOUND)
    {
        //
        // For inbound credentials, we will accept a logon id but
        // we don't require it.
        //

        if (pvLogonId != NULL)
        {
            LogonCredential = (PMS_LOGON_CREDENTIAL)SecAllocate(sizeof(MS_LOGON_CREDENTIAL));

            if (LogonCredential == NULL) {
                return(SEC_E_INSUFFICIENT_MEMORY);
            }

            LogonCredential->LogonId = *((PLUID)pvLogonId);
            LogonCredential->CredentialUse = fCredentialUse;
            *(PMS_LOGON_CREDENTIAL *)phCredential = LogonCredential;
        }
        else
        {
            *phCredential = NullCredential;
        }

    }
    else
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }


    return(SEC_E_OK);

}



//+-------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandleK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandleK(
    PCredHandle                 phCredential        // Handle to free
    )
{
    if ((phCredential != NULL) && (!RtlEqualMemory(phCredential, &NullCredential, sizeof(NullCredential)))) {

        PMS_LOGON_CREDENTIAL LogonCredential = *((PMS_LOGON_CREDENTIAL *)phCredential);

        if (LogonCredential != NULL) {
            SecFree(LogonCredential);
            *phCredential = NullCredential;
        }

    }

    return(SEC_E_OK);
}


VOID
PutString(
    OUT PSTRING32 Destination,
    IN PSTRING Source,
    IN PVOID Base,
    IN OUT PUCHAR * Where
    )
{
    Destination->Buffer = (ULONG)((ULONG_PTR) *Where - (ULONG_PTR) Base);
    Destination->Length =
        Source->Length;
    Destination->MaximumLength =
        Source->Length;

    RtlCopyMemory(
        *Where,
        Source->Buffer,
        Source->Length
        );
    *Where += Source->Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextK(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSECURITY_STRING            pssTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS scRet;
    PMSV1_0_GETCHALLENRESP_REQUEST ChallengeRequest = NULL;
    ULONG ChallengeRequestSize;
    PMSV1_0_GETCHALLENRESP_RESPONSE ChallengeResponse = NULL;
    ULONG ChallengeResponseSize;
    PCHALLENGE_MESSAGE ChallengeMessage = NULL;
    ULONG ChallengeMessageSize;
    PNTLM_CHALLENGE_MESSAGE NtlmChallengeMessage = NULL;
    ULONG NtlmChallengeMessageSize;
    PAUTHENTICATE_MESSAGE AuthenticateMessage = NULL;
    ULONG AuthenticateMessageSize;
    PNTLM_INITIALIZE_RESPONSE NtlmInitializeResponse = NULL;
    UNICODE_STRING PasswordToUse;
    UNICODE_STRING UserNameToUse;
    UNICODE_STRING DomainNameToUse;
    ULONG ParameterControl = USE_PRIMARY_PASSWORD |
                                RETURN_PRIMARY_USERNAME |
                                RETURN_PRIMARY_LOGON_DOMAINNAME;

    NTSTATUS FinalStatus = STATUS_SUCCESS;
    PUCHAR Where;
    PSecBuffer AuthenticationToken = NULL;
    PSecBuffer InitializeResponseToken = NULL;
    BOOLEAN UseSuppliedCreds = FALSE;


    RtlInitUnicodeString(
        &PasswordToUse,
        NULL
        );

    RtlInitUnicodeString(
        &UserNameToUse,
        NULL
        );

    RtlInitUnicodeString(
        &DomainNameToUse,
        NULL
        );

    //
    // Check for valid sizes, pointers, etc.:
    //


    if (!phCredential)
    {
        return(SEC_E_INVALID_HANDLE);
    }


    //
    // Locate the buffers with the input data
    //

    if (!GetTokenBuffer(
            pInput,
            0,          // get the first security token
            (PVOID *) &ChallengeMessage,
            &ChallengeMessageSize,
            TRUE        // may be readonly
            ))
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // If we are using supplied creds, get them now too.
    //


    if (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS)
    {
        if (!GetTokenBuffer(
            pInput,
            1,          // get the second security token
            (PVOID *) &NtlmChallengeMessage,
            &NtlmChallengeMessageSize,
            TRUE        // may be readonly
            ))
        {
            scRet = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }
        else
        {
            UseSuppliedCreds = TRUE;
        }

    }

    //
    // Get the output tokens
    //

    if (!GetSecurityToken(
            pOutput,
            0,
            &AuthenticationToken) ||
        !GetSecurityToken(
            pOutput,
            1,
            &InitializeResponseToken ) )
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Make sure the sizes are o.k.
    //

    if ((ChallengeMessageSize < sizeof(CHALLENGE_MESSAGE)) ||
        (UseSuppliedCreds &&
            !(NtlmChallengeMessageSize < sizeof(NTLM_CHALLENGE_MESSAGE))))
    {
        scRet = SEC_E_INVALID_TOKEN;
    }

    //
    // Make sure the caller wants us to allocate memory:
    //

    if (!(fContextReq & ISC_REQ_ALLOCATE_MEMORY))
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

   //
   // KB: allow calls requesting PROMPT_FOR_CREDS to go through.
   // We won't prompt, but we will setup a context properly.
   // This is OK because PROMPT_FOR_CREDS flag doesnt' do anything
   // in the NTLM package
   //

//    if ((fContextReq & ISC_REQ_PROMPT_FOR_CREDS) != 0)
//    {
//        scRet = SEC_E_UNSUPPORTED_FUNCTION;
//        goto Cleanup;
//    }

    //
    // Verify the validity of the challenge message.
    //

    if (strncmp(
            ChallengeMessage->Signature,
            NTLMSSP_SIGNATURE,
            sizeof(NTLMSSP_SIGNATURE)))
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if (ChallengeMessage->MessageType != NtLmChallenge)
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_REQUIRED_NEGOTIATE_FLAGS) !=
        NTLMSSP_REQUIRED_NEGOTIATE_FLAGS)
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_REQUEST_NON_NT_SESSION_KEY) != 0)
    {
        ParameterControl |= RETURN_NON_NT_USER_SESSION_KEY;
    }

    if ((fContextReq & ISC_REQ_USE_SUPPLIED_CREDS) != 0)
    {
        if ( NtlmChallengeMessage->Password.Buffer != 0)
        {
            ParameterControl &= ~USE_PRIMARY_PASSWORD;
            PasswordToUse.Length = NtlmChallengeMessage->Password.Length;
            PasswordToUse.MaximumLength = NtlmChallengeMessage->Password.MaximumLength;
            PasswordToUse.Buffer = (LPWSTR) (NtlmChallengeMessage->Password.Buffer +
                                              (PCHAR) NtlmChallengeMessage);
        }

        if (NtlmChallengeMessage->UserName.Length != 0)
        {
            UserNameToUse.Length = NtlmChallengeMessage->UserName.Length;
            UserNameToUse.MaximumLength = NtlmChallengeMessage->UserName.MaximumLength;
            UserNameToUse.Buffer = (LPWSTR) (NtlmChallengeMessage->UserName.Buffer +
                                              (PCHAR) NtlmChallengeMessage);
            ParameterControl &= ~RETURN_PRIMARY_USERNAME;
        }
        if (NtlmChallengeMessage->DomainName.Length != 0)
        {
            DomainNameToUse.Length = NtlmChallengeMessage->DomainName.Length;
            DomainNameToUse.MaximumLength = NtlmChallengeMessage->DomainName.MaximumLength;
            DomainNameToUse.Buffer = (LPWSTR) (NtlmChallengeMessage->DomainName.Buffer +
                                              (PCHAR) NtlmChallengeMessage);
            ParameterControl &= ~RETURN_PRIMARY_LOGON_DOMAINNAME;
        }

    }

    //
    // Package up the parameter for a call to the LSA.
    //

    ChallengeRequestSize = sizeof(MSV1_0_GETCHALLENRESP_REQUEST) +
                                PasswordToUse.Length + UserNameToUse.Length + DomainNameToUse.Length;

    ChallengeRequest = SecAllocate(ChallengeRequestSize);
    if (ChallengeRequest == NULL) {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }


    //
    // Build the challenge request message.
    //

    ChallengeRequest->MessageType = MsV1_0Lm20GetChallengeResponse;
    ChallengeRequest->ParameterControl = ParameterControl;
    if (RtlEqualMemory(phCredential, &NullCredential, sizeof(NullCredential))) {
        ChallengeRequest->LogonId = *((PLUID)&NullCredential);
    } else {
        ChallengeRequest->LogonId = (*((PMS_LOGON_CREDENTIAL *)phCredential))->LogonId;
    }
    RtlCopyMemory(
        ChallengeRequest->ChallengeToClient,
        ChallengeMessage->Challenge,
        MSV1_0_CHALLENGE_LENGTH
        );
    if ((ParameterControl & USE_PRIMARY_PASSWORD) == 0)
    {
        //
        // We assume the user specified SECPKG_CRED_OWF_PASSWORD when
        // AcquireSecurityContext was called, so the password is the
        // LM and NT OWF passwords concatenated together.
        //
        ChallengeRequest->Password.Buffer = (LPWSTR) (ChallengeRequest + 1);
        RtlCopyMemory(
            ChallengeRequest->Password.Buffer,
            PasswordToUse.Buffer,
            PasswordToUse.Length
            );
        ChallengeRequest->Password.Length = PasswordToUse.Length;
        ChallengeRequest->Password.MaximumLength = PasswordToUse.Length;

        //
        // need user name in NTLMv2
        //

        ChallengeRequest->UserName.Buffer = (PWSTR) (((UCHAR*) ChallengeRequest->Password.Buffer)
                          + ChallengeRequest->Password.MaximumLength);

        RtlCopyMemory(
            ChallengeRequest->UserName.Buffer,
            UserNameToUse.Buffer,
            UserNameToUse.Length
            );
        ChallengeRequest->UserName.Length = UserNameToUse.Length;
        ChallengeRequest->UserName.MaximumLength = UserNameToUse.Length;

        //
        // need logon domain in NTLMv2
        //

        ChallengeRequest->LogonDomainName.Buffer = (PWSTR) (((UCHAR*) ChallengeRequest->UserName.Buffer)
                  + ChallengeRequest->UserName.MaximumLength);

        RtlCopyMemory(
            ChallengeRequest->LogonDomainName.Buffer,
            DomainNameToUse.Buffer,
            DomainNameToUse.Length
            );
        ChallengeRequest->LogonDomainName.Length = DomainNameToUse.Length;
        ChallengeRequest->LogonDomainName.MaximumLength = DomainNameToUse.Length;
    }

    FinalStatus = MspLm20GetChallengeResponse(
                      ChallengeRequest,
                      ChallengeRequestSize,
                      &ChallengeResponse,
                      &ChallengeResponseSize,
                      (BOOLEAN)((RtlEqualMemory(phCredential, &NullCredential, sizeof(NullCredential))) ?
                                TRUE :
                                ((*((PMS_LOGON_CREDENTIAL *)phCredential))->CredentialUse & SECPKG_CRED_OWF_PASSWORD) != 0x0)
                      );

    if (!NT_SUCCESS(FinalStatus))
    {
        scRet = FinalStatus;
        goto Cleanup;
    }

    ASSERT(ChallengeResponse->MessageType == MsV1_0Lm20GetChallengeResponse);
    //
    // Now prepare the output message.
    //

    if (UserNameToUse.Buffer == NULL)
    {
        UserNameToUse = ChallengeResponse->UserName;
    }
    if (DomainNameToUse.Buffer == NULL)
    {
        DomainNameToUse = ChallengeResponse->LogonDomainName;
    }

    AuthenticateMessageSize = sizeof(AUTHENTICATE_MESSAGE) +
                                UserNameToUse.Length +
                                DomainNameToUse.Length +
                                ChallengeResponse->CaseSensitiveChallengeResponse.Length +
                                ChallengeResponse->CaseInsensitiveChallengeResponse.Length;

    AuthenticateMessage = (PAUTHENTICATE_MESSAGE) SecAllocate(AuthenticateMessageSize);
    if (AuthenticateMessage == NULL)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    Where = (PUCHAR) (AuthenticateMessage + 1);
    RtlCopyMemory(
        AuthenticateMessage->Signature,
        NTLMSSP_SIGNATURE,
        sizeof(NTLMSSP_SIGNATURE)
        );
    AuthenticateMessage->MessageType = NtLmAuthenticate;

    PutString(
        &AuthenticateMessage->LmChallengeResponse,
        &ChallengeResponse->CaseInsensitiveChallengeResponse,
        AuthenticateMessage,
        &Where
        );

    PutString(
        &AuthenticateMessage->NtChallengeResponse,
        &ChallengeResponse->CaseSensitiveChallengeResponse,
        AuthenticateMessage,
        &Where
        );

    PutString(
        &AuthenticateMessage->DomainName,
        (PSTRING) &DomainNameToUse,
        AuthenticateMessage,
        &Where
        );

    PutString(
        &AuthenticateMessage->UserName,
        (PSTRING) &UserNameToUse,
        AuthenticateMessage,
        &Where
        );

    //
    // KB. no workstation name to fill in.  This is
    // OK because the workstation name is only used
    // in loopback detection, and this is not relevant
    // to this implementation of NTLM.
    //

    AuthenticateMessage->Workstation.Length = 0;
    AuthenticateMessage->Workstation.MaximumLength = 0;
    AuthenticateMessage->Workstation.Buffer = 0;


    //
    // Build the initialize response.
    //

    NtlmInitializeResponse = (PNTLM_INITIALIZE_RESPONSE) SecAllocate(sizeof(NTLM_INITIALIZE_RESPONSE));
    if (NtlmInitializeResponse == NULL)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }


    RtlCopyMemory(
        NtlmInitializeResponse->UserSessionKey,
        ChallengeResponse->UserSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );

    RtlCopyMemory(
        NtlmInitializeResponse->LanmanSessionKey,
        ChallengeResponse->LanmanSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH
        );

    //
    // Fill in the output buffers now.
    //

    AuthenticationToken->pvBuffer = AuthenticateMessage;
    AuthenticationToken->cbBuffer = AuthenticateMessageSize;
    InitializeResponseToken->pvBuffer = NtlmInitializeResponse;
    InitializeResponseToken->cbBuffer = sizeof(NTLM_INITIALIZE_RESPONSE);


    //
    // Make a local context for this
    //

    scRet = NtlmInitKernelContext(
                NtlmInitializeResponse->UserSessionKey,
                NtlmInitializeResponse->LanmanSessionKey,
                NULL,           // no token,
                phNewContext
                );

    if (!NT_SUCCESS(scRet))
    {
        goto Cleanup;
    }
    scRet = SEC_E_OK;




Cleanup:

    if (ChallengeRequest != NULL)
    {
        SecFree(ChallengeRequest);
    }

    if (ChallengeResponse != NULL)
    {
        ExFreePool( ChallengeResponse );
    }

    if (!NT_SUCCESS(scRet))
    {
        if (AuthenticateMessage != NULL)
        {
            SecFree(AuthenticateMessage);
        }
        if (NtlmInitializeResponse != NULL)
        {
            SecFree(NtlmInitializeResponse);
        }
    }
    return(scRet);
}




//+-------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContextK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextK(
    PCtxtHandle                 phContext          // Context to delete
    )
{
    SECURITY_STATUS     scRet;

    // For now, just delete the LSA context:

    if (!phContext)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    scRet = NtlmDeleteKernelContext(phContext);


    return(scRet);

}


#if 0

//+-------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesK(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfo SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    ULONG PackageInfoSize;
    PSecPkgInfoW PackageInfo = NULL;
    PUCHAR Where;

    //
    // Figure out the size of the returned data
    //

    PackageInfoSize = sizeof(SecPkgInfoW) +
                        sizeof(NTLMSP_NAME) +
                        sizeof(NTLMSP_COMMENT);

    PackageInfo = (PSecPkgInfoW) SecAllocate(PackageInfoSize);

    if (PackageInfo == NULL)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    //
    // Fill in the fixed length fields
    //

    PackageInfo->fCapabilities = SECPKG_FLAG_CONNECTION |
                                 SECPKG_FLAG_TOKEN_ONLY;
    PackageInfo->wVersion = NTLMSP_VERSION;
    PackageInfo->wRPCID = NTLMSP_RPCID;
    PackageInfo->cbMaxToken = NTLMSSP_MAX_MESSAGE_SIZE;

    //
    // Fill in the fields
    //

    Where = (PUCHAR) (PackageInfo+1);
    PackageInfo->Name = (LPWSTR) Where;
    RtlCopyMemory(
        PackageInfo->Name,
        NTLMSP_NAME,
        sizeof(NTLMSP_NAME)
        );
    Where += sizeof(NTLMSP_NAME);

    PackageInfo->Comment = (LPWSTR) Where;
    RtlCopyMemory(
        PackageInfo->Comment,
        NTLMSP_COMMENT,
        sizeof(NTLMSP_COMMENT)
        );
    Where += sizeof(NTLMSP_COMMENT);


    *pcPackages = 1;
    *ppPackageInfo = PackageInfo;
    return(SEC_E_OK);
}



//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoK(
    PSECURITY_STRING pssPackageName,    // Name of package
    PSecPkgInfo * ppPackageInfo         // Receives package info
    )
{

    UNICODE_STRING PackageName;
    ULONG PackageCount;

    RtlInitUnicodeString(
        &PackageName,
        NTLMSP_NAME
        );


    if (!RtlEqualUnicodeString(
            pssPackageName,
            &PackageName,
            TRUE                    // case insensitive
            ))
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    return(EnumerateSecurityPackagesK(&PackageCount,ppPackageInfo));

}

#endif


//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBufferK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
FreeContextBufferK(
    void SEC_FAR *      pvContextBuffer
    )
{
    SecFree(pvContextBuffer);

    return(SEC_E_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdr2kd\kdextlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation











------------------------------
T H I S   F I L E   I S   O B S O L E T E .    I T   I S   B E I N G   K E P T
F O R   A   W H I L E   J U S T   T O   M A K E   S U R E
----------------------------
















Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rxovride.h" //common compile flags
#include "ntifs.h"
#include <nt.h>
//#include <ntrtl.h>
#include "ntverp.h"

#define KDEXTMODE

#include <windef.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>

PWINDBG_OUTPUT_ROUTINE                lpOutputRoutine;
PWINDBG_GET_EXPRESSION32              lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL32                  lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE   lpReadMemoryRoutine;

#define    PRINTF    lpOutputRoutine
#define    ERROR     lpOutputRoutine

#define    NL      1
#define    NONL    0

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        PRINTF( "Unable to read %u bytes at %p, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetString( ULONG_PTR dwAddress, PSZ buf )
{
    do {
        if( !GetData( dwAddress,buf, 1, "..stringfetch") )
            return FALSE;

        dwAddress++;
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING    AnsiString;
    BOOL           b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) puStr->Buffer,
                UnicodeString.Buffer,
                UnicodeString.Length,
                NULL);

    if (b)    {
        RtlUnicodeStringToAnsiString(&AnsiString, puStr, TRUE);
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
        RtlFreeAnsiString(&AnsiString);
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL        b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\umt_stff\umt_stff.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    startrx.c

Abstract:

    This module contains the support routines to start and initialize the RDBSS

Author:

    Joe Linn (JoeLinn) 21-jul-94

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#include <stdlib.h>
#include <stdio.h>
#include "string.h"
#include <stdarg.h>

BOOLEAN RxGlobalTraceSuppress = FALSE;

//.............sigh
NTSTATUS
SmbCeBuildSmbHeader(
      PSMB_EXCHANGE     pExchange,
      UCHAR             SmbCommand,
      PVOID             pBuffer,
      ULONG             BufferLength,
      PULONG            pBufferConsumed)
{
    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)pBuffer;
    RtlZeroMemory(NtSmbHeader,sizeof(NT_SMB_HEADER));
    *(PULONG)(&NtSmbHeader->Protocol) = SMB_HEADER_PROTOCOL;
    NtSmbHeader->Command = SMB_COM_NO_ANDX_COMMAND;
    SmbPutUshort (&NtSmbHeader->Pid, MRXSMB_PROCESS_ID_ZERO);
    SmbPutUshort (&NtSmbHeader->Mid, MRXSMB_MULTIPLX_ID_ZERO);
    SmbPutUshort (&NtSmbHeader->Uid, MRXSMB_USER_ID_ZERO);
    SmbPutUshort (&NtSmbHeader->Tid, MRXSMB_TREE_ID_ZERO);
    *pBufferConsumed = sizeof(SMB_HEADER);
    return(STATUS_SUCCESS);
}


ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    ULONG retval;

    //
    // Format the output into a buffer and then print it.
    //

    //printf("Here in debgprint\n");
    va_start(arglist, Format);
    retval = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);
    //*(Buffer+retval) = 0;
    printf("%s",Buffer);
    return(retval);
}


BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    )
//we aren't fancy in this test stub........just return print it out no matter what!
{
/*
This routine has the responsibility to determine if a particular dbgprint is going to be printed and ifso to
fiddle with the indent. so the return value is whether to print; it is also used for just fiddling with the indent
by setting the highoredr bit of the mask.

The Mask is now very complicated owing to the large number of dbgprints i'm trying to control...sigh.
The low order byte is the controlpoint....usually the file. each controlpoint has a current level associated
with it. if the level of a a debugtrace is less that then current control level then the debug is printed.
The next byte is the level of this particular call; again if the level is <= the current level for the control
you get printed. The next byte is the indent. indents are only processed if printing is done.
*/
#if DBG
    LONG Indent = ((NewMask>>RxDT_INDENT_SHIFT)&RxDT_INDENT_MASK) - RxDT_INDENT_EXCESS;
    LONG LevelOfThisWrite = (NewMask) & RxDT_LEVEL_MASK;
    BOOLEAN PrintIt = (NewMask&RxDT_SUPPRESS_PRINT)==0;
    BOOLEAN OverrideReturn = (NewMask&RxDT_OVERRIDE_RETURN)!=0;


    return PrintIt||OverrideReturn;
#else
    return(FALSE);
#endif
}



RDBSS_EXPORTS Junk;
PRDBSS_EXPORTS MRxSmbRxImports;
VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

{
    printf("Calling stufferdebug\n");
    //signal to assert login that we're in usermode
    MRxSmbRxImports = &Junk;
    MRxSmbRxImports->pRxNetNameTable = NULL;
    MRxSmbStufferDebug("");
}


#define Dbg                              (DEBUG_TRACE_ALWAYS)
VOID
RxAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    char STARS[] = "**************************************";

    RxDbgTrace(0,Dbg,("%s\n%s\n",STARS,STARS));
    RxDbgTrace (0,Dbg,("Failed Assertion %s\n",FailedAssertion));
    RxDbgTrace(0,Dbg,("%s at line %lu\n",FileName,LineNumber));
    if (Message) {
        RxDbgTrace (0,Dbg,("%s\n",Message));
    }
    RxDbgTrace(0,Dbg,("%s\n%s\n",STARS,STARS));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\wrapper.sav\flush.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Flush.c

Abstract:

    This module implements the File Flush buffers routine for Rx called by the
    dispatch driver.

    In a future version of the wrapper, it may be that flush will be routed thru lowio.

Author:

    Joe Linn     [JoeLinn]    15-dec-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FLUSH)

//RXSTATUS
//RxLowIoFlushShell (
//    IN PRX_CONTEXT RxContext
//    );
//
//RXSTATUS
//RxLowIoFlushShellCompletion (
//    IN PRX_CONTEXT RxContext
//    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonFlushBuffers)
#pragma alloc_text(PAGE, RxFlushFile)
#endif



NTSTATUS
RxCommonFlushBuffers ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for flushing file buffers.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock; RxCaptureFileObject;
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;


    BOOLEAN FcbAcquired = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonFlush...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));
    RxLog(("%s %lx %lx %lx\n","slF",RxContext,capFcb,capFobx));

    //
    //  CcFlushCache is always synchronous, so if we can't wait enqueue
    //  the irp to the Fsp.

    if ( !FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT) ) {

        Status = RxFsdPostRequest( RxContext );

        RxDbgTrace(-1, Dbg, ("RxCommonFlushBuffers -> %08lx\n", Status ));
        return Status;
    }

    Status = STATUS_SUCCESS;

    try {

        //
        //  Case on the type of open that we are trying to flush
        //

        switch (TypeOfOpen) {

        case RDBSS_NTC_STORAGE_TYPE_FILE:

            RxDbgTrace(0, Dbg, ("Flush User File Open\n", 0));

            Status = RxAcquireExclusiveFcb( RxContext, capFcb );

            if (Status != STATUS_SUCCESS) break;

            FcbAcquired = TRUE;

            //
            //  If the file is cached then flush its cache
            //

            Status = RxFlushFile( RxContext, capFcb );

            if (!NT_SUCCESS( Status )) break;

            //rdrs don't do this.....only local FSs
            ////
            ////  Check if we should be changing the time or file size
            //
            //RxAdjustFileTimesAndSize(RXCOMMON_ARGUMENTS);

            // if we make this lowio.........
            ////
            ////  Initialize LowIO_CONTEXT block in the RxContext and Calldown
            //
            //RxInitializeLowIoContext(LowIoContext,LOWIO_OP_FLUSH);
            //
            //Status = RxLowIoFlushShell(RxContext);

            MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxFlush,(RxContext));
            break;

        case RDBSS_NTC_SPOOLFILE:

            RxDbgTrace(0, Dbg, ("Flush Sppol File\n", 0));

            Status = RxAcquireExclusiveFcb( RxContext, capFcb );

            if (Status != STATUS_SUCCESS) break;

            FcbAcquired = TRUE;

            // should this be low io???
            ////
            ////  Initialize LowIO_CONTEXT block in the RxContext and Calldown
            //
            //RxInitializeLowIoContext(LowIoContext,LOWIO_OP_FLUSH);
            //
            //Status = RxLowIoFlushShell(RxContext);

            MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxFlush,(RxContext));
            break;

        default:

            Status = STATUS_INVALID_DEVICE_REQUEST;
        }


    } finally {

        DebugUnwind( RxCommonFlushBuffers );

        if (FcbAcquired) { RxReleaseFcb( RxContext, capFcb ); }

        //
        //  If this is a normal termination then pass the request on
        //  to the target device object.
        //

        if (!AbnormalTermination()) {

            NOTHING;

        }

    }

    RxDbgTrace(-1, Dbg, ("RxCommonFlushBuffers -> %08lx\n", Status));
    return Status;
}


#if 0
BUGBUG
THIS CODE WOULD BE USED IF THIS IS CHANGED TO LOWIO


NTSTATUS
RxLowIoFlushShellCompletion (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    these completion shells are pretty similar. BUT as the error handling gets more
    robust the routines will become increasingly dissimilar. for flush, everything is synchronous...that's
    a difference with read/write/lock; we keep the same declarations and format for later when we decide to roll up the
    common part of these routines.

    This routine postprocesses a flush request after it comes back from the
    minirdr. It is the complement of LowIoFlushShell.


Arguments:

    RxContext - the usual

Return Value:

    whatever value supplied by the caller or STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    BOOLEAN  SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
    BOOLEAN  PagingIo      = BooleanFlagOn(capReqPacket->Flags, IRP_PAGING_IO);
    ERESOURCE_THREAD ThisResourceThreadId;


    Status = RxContext->StoredStatus;
    RxDbgTrace(+1, Dbg, ("RxLowIoFlushShellCompletion  entry  Status = %08lx\n", Status));
    RxLog(("FlshShlComp %x\n",RxContext));

    //switch (Status) {
    //case STATUS_SUCCESS:
    //    break;
    //case STATUS_CONNECTION_INVALID:
    //    //joejoe here is where the failover will happen
    //    //first we give the local guy current minirdr another chance...then we go
    //    //to fullscale retry
    //    //return(RxStatus(DISCONNECTED));   //special....let LowIo get us back
    //    break;
    //}

    capReqPacket->IoStatus.Status = Status;

    RxDbgTrace(-1, Dbg, ("RxLowIoFlushShellCompletion  exit  Status = %08lx\n", Status));
    return(Status);
    //NOTE THAT THE ASYNC COMPLETION TAIL IS MISSING
}

#define RxSdwFlush(RXCONTEXT)  {NOTHING;}
}
NTSTATUS
RxLowIoFlushShell (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine preprocesses a Flush request before it goes down to the minirdr. It does callouts
    to handle compression, buffering and shadowing. It is the opposite number of LowIoFlushShellCompletion.
    By the time we get here, we are going to the wire.
    Flush buffering was already tried in the UncachedFlush strategy

Arguments:

    RxContext - the usual

Return Value:

    whatever value is returned by a callout....or by LowIo.

--*/

{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    RxDbgTrace(+1, Dbg, ("RxLowIoFlushShell  entry             %08lx\n", 0));
    RxLog(("FlshShl in%x\n",RxContext));
    if (FlagOn(Fcb->FcbState, FCB_STATE_FILE_IS_SHADOWED)) {
        RxSdwFlush(RxContext);
    }

    Status = RxLowIoSubmit(RxContext,RxLowIoFlushShellCompletion);
    RxDbgTrace(-1, Dbg, ("RxLowIoFlushShell  exit  Status = %08lx\n", Status));
    return(Status);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdr2kd\makefile.inc ===
copyforifskit:
# This is bogus.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\wrapper.sav\devctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the File System Device Control routines for Rx
    called by the dispatch driver.

Author:

Revision History:

   Balan Sethu Raman [19-July-95] -- Hook it up to the mini rdr call down.

--*/

#include "precomp.h"
#pragma hdrstop

#include "ntddmup.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVCTRL)

NTSTATUS
RxLowIoIoCtlShellCompletion( RXCOMMON_SIGNATURE );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonDeviceControl)
#pragma alloc_text(PAGE, RxLowIoIoCtlShellCompletion)
#endif


NTSTATUS
RxCommonDeviceControl ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for doing Device control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

    InFsp - Indicates if this is the fsp thread or someother thread

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    //RxCaptureFcb;
    //RxCaptureFobx;
    RxCaptureParamBlock;
    //RxCaptureFileObject;

    //NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    BOOLEAN SubmitLowIoRequest = TRUE;
    ULONG IoControlCode = capPARAMS->Parameters.DeviceIoControl.IoControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonDeviceControl\n", 0));
    RxDbgTrace( 0, Dbg, ("Irp           = %08lx\n", capReqPacket));
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", capPARAMS->MinorFunction));

    //
    //

    if (IoControlCode == IOCTL_REDIR_QUERY_PATH) {
        Status = (STATUS_INVALID_DEVICE_REQUEST);
        SubmitLowIoRequest = FALSE;
    }

    if (SubmitLowIoRequest) {
        RxInitializeLowIoContext(&RxContext->LowIoContext,LOWIO_OP_IOCTL);
        Status = RxLowIoSubmit(RxContext,RxLowIoIoCtlShellCompletion);
    }

    RxDbgTrace(-1, Dbg, ("RxCommonDeviceControl -> %08lx\n", Status));
    return Status;
}

NTSTATUS
RxLowIoIoCtlShellCompletion( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the completion routine for IoCtl requests passed down to the mini rdr

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    RxCaptureRequestPacket;
    //RxCaptureFcb;
    //RxCaptureFobx;
    //RxCaptureParamBlock;
    //RxCaptureFileObject;

    NTSTATUS       Status        = STATUS_SUCCESS;
    //NODE_TYPE_CODE TypeOfOpen    = NodeType(capFcb);
    PLOWIO_CONTEXT pLowIoContext  = &RxContext->LowIoContext;
    //ULONG          FsControlCode = capPARAMS->Parameters.FileSystemControl.FsControlCode;

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    RxDbgTrace(+1, Dbg, ("RxLowIoIoCtlShellCompletion  entry  Status = %08lx\n", Status));

    switch (Status) {   //maybe success vs warning vs error
    case STATUS_SUCCESS:
    case STATUS_BUFFER_OVERFLOW:
       //capReqPacket->IoStatus.Information = pLowIoContext->ParamsFor.IoCtl.OutputBufferLength;
       capReqPacket->IoStatus.Information = RxContext->InformationToReturn;
       break;
    //case STATUS(CONNECTION_INVALID:
    default:
       break;
    }

    capReqPacket->IoStatus.Status = Status;
    RxDbgTrace(-1, Dbg, ("RxLowIoIoCtlShellCompletion  exit  Status = %08lx\n", Status));
    return Status;
}

#if 0


THIS CODE IS NOT USED CURRENTLY....IT'S BEING SAVED HERE TO MAP OVER TO HAVING RDBSS LOAD/UNLOAD EACH MINIRDR UNDER IOCTL

NTSTATUS
RxLoadMiniRdrs(
    IN PUNICODE_STRING RegistryPath
    );
VOID
RxUnloadMiniRdrs(
    void
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
PWCHAR RxMiniRdrInfo = NULL;
ULONG RxMiniRdrsLoaded = 0;

//CODE.IMPROVEMENT this should be allocated dynamically
#define MAXIMUM_NUMBER_OF_MINIRDRS 16
UNICODE_STRING RxLoadedDrivers[MAXIMUM_NUMBER_OF_MINIRDRS];
PWCHAR RxLoadedDriversNameBuffer = NULL;
ULONG RxNextDriverLoaded = 0;


NTSTATUS
RxFabricateRegistryStringZZ(
    IN OUT PUNICODE_STRING RegistryNameString,
    IN     PUNICODE_STRING DriverName,
    IN OUT PVOID           Buffer,
    IN     ULONG           BufferLength
    )
{
    UNICODE_STRING RegistryServicePrefix;
    NTSTATUS Status;

    RegistryNameString->Buffer = (PWCHAR)Buffer;
    RegistryNameString->MaximumLength = (USHORT)BufferLength;

    RtlInitUnicodeString(&RegistryServicePrefix, SERVICE_REGISTRY_KEY);

    RtlCopyUnicodeString(RegistryNameString,&RegistryServicePrefix);

    Status = RtlAppendUnicodeStringToString(RegistryNameString,DriverName);
    return(Status);
}

NTSTATUS
RxLoadMiniRdrs(
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

     This routine does an enumeration from the registry to load the minirdrs. It saves what it finds so it
     can unload them later. It also initializes the structures that are used to scan over minirdrs.......

Arguments:

     None.

Return Value:

     STATUS_SUCCESS if at least one minirdr was loaded
     STATUS_INSUFFICIENT_RESOURCES if the buffer to save the names could not be allocated
     STATUS_UNSUCCESSFUL if no minirdrs were loaded

--*/
{
    ULONG Storage[256];
    WCHAR ServiceNameRegistryStringBuffer[256]; //bugbug allocate this!
    UNICODE_STRING UnicodeString;
    PCHAR NextNameBufferPosition;
    HANDLE RdbssHandle = INVALID_HANDLE_VALUE;
    HANDLE MiniRdrsHandle = INVALID_HANDLE_VALUE;
    NTSTATUS Status;
    KEY_FULL_INFORMATION KeyInformation;
    PKEY_VALUE_BASIC_INFORMATION ValueInformation;
    ULONG DummyLength,Index;
    //ULONG BytesRead;
    OBJECT_ATTRIBUTES ObjectAttributes;
    //PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;

    DbgPrint("here we go\n");
    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,               // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey (&RdbssHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("FirstOpenFailed: %08lx %wZ\n",Status,RegistryPath);
        RxLogFailure (
            RxFileSystemDeviceObject,
            NULL,
            EVENT_RDR_CANT_READ_REGISTRY,
            Status);

        goto FINALLY;
    }

    RtlInitUnicodeString(&UnicodeString, L"MiniRdrs");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        RdbssHandle,
        NULL
        );


    Status = ZwOpenKey (&MiniRdrsHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("2ndOpenFailed: %08lx %wZ\n",Status,&UnicodeString);
        RxLogFailure (
            RxFileSystemDeviceObject,
            NULL,
            EVENT_RDR_CANT_READ_REGISTRY,
            Status);

        goto FINALLY;
    }

    Status = ZwQueryKey (MiniRdrsHandle, KeyFullInformation, &KeyInformation,sizeof(KeyInformation),&DummyLength);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("QueryFailed: %08lx %wZ\n",Status,&UnicodeString);
        RxLogFailure (
            RxFileSystemDeviceObject,
            NULL,
            EVENT_RDR_CANT_READ_REGISTRY,
            Status);

        goto FINALLY;
    }

    DbgPrint("HandleInfo %08lx %08lx %08lx\n",
               KeyInformation.Values,
               KeyInformation.MaxValueNameLen,
               KeyInformation.MaxValueDataLen);

    RxLoadedDriversNameBuffer = RxAllocatePoolWithTag(PagedPool,
                                              KeyInformation.Values*KeyInformation.MaxValueNameLen,
                                              'xMxR');
    if (RxLoadedDriversNameBuffer==NULL) {
        DbgPrint("NameBufferAllocFailed: %08lx %wZ\n",Status,&UnicodeString);
        RxLogFailure (
            RxFileSystemDeviceObject,
            NULL,
            EVENT_RDR_CANT_READ_REGISTRY,
            Status);

        goto FINALLY;
    }

    NextNameBufferPosition = (PCHAR)RxLoadedDriversNameBuffer;
    ValueInformation = (PKEY_VALUE_BASIC_INFORMATION)(&Storage[0]); //this restricts the name length..we'll just skip long ones
    for (Index=0;Index<KeyInformation.Values;Index++) {
        UNICODE_STRING DriverName,RegistryNameString;
        NTSTATUS LoadStatus;
        ULONG ThisDriver;

        LoadStatus = ZwEnumerateValueKey(MiniRdrsHandle,
                                     Index,
                                     KeyValueBasicInformation,
                                     ValueInformation,
                                     sizeof(Storage),
                                     &DummyLength);
        if (!NT_SUCCESS(LoadStatus)) {
            continue;
        }

        DriverName.Length = DriverName.MaximumLength = (USHORT)(ValueInformation->NameLength);
        DriverName.Buffer = &(ValueInformation->Name[0]);

        LoadStatus = RxFabricateRegistryStringZZ(&RegistryNameString,
                                               &DriverName,
                                               &ServiceNameRegistryStringBuffer[0],
                                               sizeof(ServiceNameRegistryStringBuffer));
        if (!NT_SUCCESS(LoadStatus)) {
            continue;
        }

        DbgPrint(">>LOADING %wZ:%wZ\n",&DriverName,&RegistryNameString);
        LoadStatus = ZwLoadDriver(&RegistryNameString);
        if (!NT_SUCCESS(LoadStatus)) {
            continue;
        }

        ThisDriver = RxNextDriverLoaded;
        RxNextDriverLoaded++;
        RxLoadedDrivers[ThisDriver].Buffer = (PWCHAR)NextNameBufferPosition;
        RxLoadedDrivers[ThisDriver].Length = DriverName.MaximumLength;
        RxLoadedDrivers[ThisDriver].MaximumLength = DriverName.MaximumLength;
        RtlCopyMemory(NextNameBufferPosition,DriverName.Buffer,DriverName.MaximumLength);
        NextNameBufferPosition+=DriverName.MaximumLength;
        DbgPrint(">>SAVEDNAME %wZ:%wZ\n",&DriverName,&RxLoadedDrivers[ThisDriver]);

    }

FINALLY:
    if (MiniRdrsHandle!=INVALID_HANDLE_VALUE) ZwClose(MiniRdrsHandle);
    if (MiniRdrsHandle!=INVALID_HANDLE_VALUE) ZwClose(RdbssHandle);
    if (!NT_SUCCESS(Status)) {
        RxUnloadMiniRdrs();
    }
    return Status;
}



VOID
RxUnloadMiniRdrs(
    void
    )
{
    ULONG ThisDriver;
    WCHAR ServiceNameRegistryStringBuffer[256]; //bugbug allocate this!

    PAGED_CODE(); //not actually in use

    DbgPrint("here we ungo, drivertounload=%08lx\n",RxNextDriverLoaded);

    for (ThisDriver=0;ThisDriver<RxNextDriverLoaded;ThisDriver++) {
        NTSTATUS LoadStatus;
        UNICODE_STRING RegistryNameString;
        DbgPrint(">>Unloading %wZ\n",&RxLoadedDrivers[ThisDriver]);
        LoadStatus = RxFabricateRegistryStringZZ(&RegistryNameString,
                                               &RxLoadedDrivers[ThisDriver],
                                               &ServiceNameRegistryStringBuffer[0],
                                               sizeof(ServiceNameRegistryStringBuffer));
        LoadStatus = ZwUnloadDriver(&RegistryNameString);
        DbgPrint(">>Unloaded %wZ, status =%08lx\n",&RxLoadedDrivers[ThisDriver],LoadStatus);
        //no status check.....can't do anything anyway!
    }

    if (RxLoadedDriversNameBuffer!=NULL) RxFreePool(RxLoadedDriversNameBuffer);

    return;
}




#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdr2kd\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdr2kd.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

//#include <windef.h>

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeULongUnaligned,
    FieldTypeULongFlags,
    FieldTypeLong,
    FieldTypeLongUnaligned,
    FieldTypeUShort,
    FieldTypeUShortUnaligned,
    FieldTypeUShortFlags,
    FieldTypeShort,
    FieldTypePointer,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    //USHORT           Offset;      // The offset of the field in the structure
    LONG             Offset;      // The offset of the field in the structure
    union {
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRIPTOR_ {
    LPSTR 	          StructName;
    ULONG             StructSize;
    ULONG             EnumManifest;
    FIELD_DESCRIPTOR  *FieldDescriptors;
    USHORT            MatchMask;
    USHORT            MatchValue;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors,MatchMask,MatchValue) \
        { #StructTypeName,sizeof(StructTypeName), \
          StrEnum_##StructTypeName,               \
          FieldDescriptors,MatchMask,MatchValue}

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

//
// Support for displaying global variables
//

extern LPSTR GlobalBool[];
extern LPSTR GlobalShort[];
extern LPSTR GlobalLong[];
extern LPSTR GlobalPtrs[];

#endif // _KDEXTLIB_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\wrapper.sav\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Rx called by the
    dispatch driver.

Author:

    Joe Linn     [JoeLinn]    12-sep-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_CLEANUP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)


BOOLEAN
RxUninitializeCacheMap(
    IN OUT PRX_CONTEXT RxContext,
    IN     PFILE_OBJECT FileObject,
    IN     PLARGE_INTEGER TruncateSize
    );

#if DBG
//this is just a dbg thing
extern
BOOLEAN
RxLockEnumerator (
    IN OUT struct _MRX_SRV_OPEN_ * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    );

BOOLEAN
RxFakeLockEnumerator (
    IN OUT struct _SRV_OPEN * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    );

VOID
RxDumpSerializationQueue(
    PLIST_ENTRY SQ,
    PSZ         TagText1,
    PSZ         TagText2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxDumpSerializationQueue)
#endif

#endif //if DBG

VOID
RxCleanupPipeQueues (
    IN PRX_CONTEXT RxContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonCleanup)
#pragma alloc_text(PAGE, RxAdjustFileTimesAndSize)
#pragma alloc_text(PAGE, RxCleanupPipeQueues)
#pragma alloc_text(PAGE, RxUninitializeCacheMap)
#endif



NTSTATUS
RxCommonCleanup ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for cleanup of a file/directory called by
    both the fsd and fsp threads.

    Cleanup is invoked whenever the last handle to a file object is
    closed.  This is different than the Close operation which is invoked
    when the last reference to a file object is deleted.

    The function of cleanup is to essentially "cleanup" the
    file/directory after a user is done with it.  The Fcb/Dcb remains
    around (because MM still has the file object referenced) but is now
    available for another user to open (i.e., as far as the user is
    concerned the file object is now closed).  See close for a more complete
    description of what close does.

    Please see the discussion in openclos.txt.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    NODE_TYPE_CODE TypeOfOpen  = NodeType(capFcb);
    NET_ROOT_TYPE  NetRootType;
    PNET_ROOT      NetRoot;

    PSHARE_ACCESS ShareAccess = NULL;

    PLARGE_INTEGER TruncateSize = NULL;
    LARGE_INTEGER  LocalTruncateSize;

    BOOLEAN UninitializeCacheMap = FALSE;
    BOOLEAN LastUncleanOnGoodFcb = FALSE;
    BOOLEAN NeedPurge            = FALSE;
    BOOLEAN NeedDelete           = FALSE;

    BOOLEAN AcquiredFcb          = FALSE;
    BOOLEAN AcquiredTableLock    = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonCleanup IrpC/Fobx/Fcb/FileObj = %08lx %08lx %08lx %08lx\n",
                               RxContext,capFobx,capFcb,capFileObject));
    RxLog(("CommonCleanup %lx %lx %lx\n",RxContext,capFobx,capFcb));

    // If this cleanup is for the case of directories opened for renames etc.,
    // where there is no file object cleanup succeeds immediately.
    if (!capFobx) {
        if (capFcb->UncleanCount > 0) {
           InterlockedDecrement(&capFcb->UncleanCount);
        }
        //RxMarkFcbForScavengingAtCleanup(capFcb);
        RxDbgTrace(-1, Dbg, ("Cleanup nullfobx open\n", 0));
        return(STATUS_SUCCESS);
    }

    // Cleanup applies to certain types of opens. If it is not one of those
    // abort immediately.
    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_UNKNOWN) &&
        (TypeOfOpen != RDBSS_NTC_SPOOLFILE)) {
       RxLog(("RxCC Invalid Open %lx %lx %lx\n",RxContext,capFobx,capFcb));
       RxBugCheck( TypeOfOpen, 0, 0 );
    }

    // Ensure that the object has not been cleaned up before. This should
    // never occur.
    ASSERT( !FlagOn( capFileObject->Flags, FO_CLEANUP_COMPLETE ));

    RxMarkFobxOnCleanup(capFobx,&NeedPurge);

    // Acquire the FCB. In most cases no further resource acquisition is required
    // to complete the cleanup operation. The only exceptions are when the file
    // was initially opened with the DELETE_ON_CLOSE option. In such cases the
    // FCB table lock of the associated NET_ROOT instance is required.

    Status = RxAcquireExclusiveFcb( RxContext, capFcb );
    if (Status != STATUS_SUCCESS) {
       RxDbgTrace(-1, Dbg, ("RxCommonCleanup Failed to acquire FCB -> %lx\n)", Status));
       return Status;
    }

    AcquiredFcb = TRUE;


    if (FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) {
       ASSERT( capFcb->UncleanCount );
       InterlockedDecrement(&capFcb->UncleanCount);
       if (FlagOn(capFileObject->Flags,FO_NO_INTERMEDIATE_BUFFERING)) {
           capFcb->UncachedUncleanCount--;
       }

       MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxCleanupFobx,(RxContext));
       ASSERT( capFobx->SrvOpen->UncleanFobxCount );

       capFobx->SrvOpen->UncleanFobxCount--;
       RxReleaseFcb(RxContext,capFcb);
       return STATUS_SUCCESS;
    }

    NetRootType = capFcb->VNetRoot->NetRoot->Type ;
    NetRoot     = (PNET_ROOT)capFcb->VNetRoot->NetRoot;

    if ( FlagOn(capFobx->Flags, FOBX_FLAG_DELETE_ON_CLOSE) ) {
        SetFlag( capFcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );
    }

    ShareAccess = &capFcb->ShareAccess;
    LastUncleanOnGoodFcb = (capFcb->UncleanCount == 1);

    if (LastUncleanOnGoodFcb && FlagOn(capFcb->FcbState, FCB_STATE_DELETE_ON_CLOSE)) {
        //  if we can't get it right way, drop the Fcb and acquire/acquire
        //  to perserve lock order. No one else can change the counts while we have
        //  the fcb lock; neither can a file become DELETE_ON_CLOSE or be opened via
        //  CommonCreate. If we are not deleting, get rid of the tablelock after we
        //  verify the count.

        if ( RxAcquireFcbTableLockExclusive(&NetRoot->FcbTable, FALSE) ) {
            // this is the fast way....hope it works
            AcquiredTableLock = TRUE;
        } else {
            // Release the FCB and reqcquire the locks in the correct order.
            // PrefixTableLock followed by the FCB.
            RxReleaseFcb( RxContext, capFcb );
            AcquiredFcb = FALSE;

            (VOID)RxAcquireFcbTableLockExclusive(&NetRoot->FcbTable, TRUE);
            AcquiredTableLock = TRUE;

            Status = RxAcquireExclusiveFcb( RxContext, capFcb );
            if (Status != STATUS_SUCCESS) {
               RxDbgTrace(-1, Dbg, ("RxCommonCleanup Failed to acquire FCB -> %lx\n)", Status));
               return Status;
            }
            AcquiredFcb = TRUE;
        }

        if (capFcb->UncleanCount != 1) {
            RxReleaseFcbTableLock(&NetRoot->FcbTable);
            AcquiredTableLock = FALSE;
            NeedDelete = FALSE;
        } else {
            NeedDelete = TRUE;
        }
    }

    try {
        switch (NetRootType) {
        case NET_ROOT_PIPE:
        case NET_ROOT_PRINT:
           {
               // If the file object corresponds to a pipe or spool file additional
               // cleanup operations are required. This deals with the special
               // serialization mechanism for pipes.

               RxCleanupPipeQueues(RxContext);
           }
           break;
        case NET_ROOT_DISK:
           {
              switch (TypeOfOpen) {
              case RDBSS_NTC_STORAGE_TYPE_FILE :
                 {
                    // If the file object corresponds to a disk file, assert the locks
                    // and update the associated file times and sizes.

                    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

                    LowIoContext->Flags |= LOWIO_CONTEXT_FLAG_SAVEUNLOCKS;

                    FsRtlFastUnlockAll(
                              &capFcb->Specific.Fcb.FileLock,
                              capFileObject,
                              IoGetRequestorProcess( capReqPacket ),
                              RxContext );

                    if (LowIoContext->ParamsFor.Locks.LockList != NULL) {
                        RxDbgTrace(0, Dbg, ("--->before init, locklist=%08lx\n", LowIoContext->ParamsFor.Locks.LockList));
                        RxInitializeLowIoContext(LowIoContext,LOWIO_OP_UNLOCK_MULTIPLE);
                        LowIoContext->ParamsFor.Locks.Flags = 0;     //no flags
                        Status = RxLowIoLockControlShell(RxContext);
                    }

                    RxAdjustFileTimesAndSize(RXCOMMON_ARGUMENTS);

                    // If the file object corresponds to a disk file/directory and this
                    // is the last cleanup call for the FCB additional processing is required.
                    if (LastUncleanOnGoodFcb) {
                       try {
                           // If the file object was marked DELETE_ON_CLOSE set the file size to
                           // zero ( synchronizing with the paging resource)
                           if (NeedDelete) {
                              RxAcquirePagingIoResource( capFcb );

                              capFcb->Header.FileSize.QuadPart = 0;

                              if (TypeOfOpen == RDBSS_NTC_STORAGE_TYPE_FILE) {
                                 capFcb->Header.ValidDataLength.QuadPart = 0;
                              }

                              RxReleasePagingIoResource( capFcb );
                           } else {
                              // If the file object was not marked for deletion and it is not
                              // a paging file ensure that the portion between the valid data
                              // length and the file size is zero extended.
                              if (!FlagOn(capFcb->FcbState, FCB_STATE_PAGING_FILE) &&
                                  (capFcb->Header.ValidDataLength.QuadPart <
                                   capFcb->Header.FileSize.QuadPart)) {
                                  RxDbgTrace(0, Dbg, ("---------->zeroextend!!!!!!!\n", 0));
                                  MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxZeroExtend,(RxContext));

                                  capFcb->Header.ValidDataLength.QuadPart =
                                                              capFcb->Header.FileSize.QuadPart;
                              }
                           }

                           // If the file object was marked for truncation capture the
                           // sizes for uninitializing the cache maps subsequently.
                           if (FlagOn(capFcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE)) {

                               RxDbgTrace(0, Dbg, ("truncate file allocation\n", 0));

                               MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxTruncate,(RxContext));

                               //  Setup to truncate the Cache Map because
                               //  this is the only way we have of trashing the
                               //  truncated pages.

                               LocalTruncateSize = capFcb->Header.FileSize;
                               TruncateSize = &LocalTruncateSize;

                               //  Mark the Fcb as having now been truncated, just
                               //  in case we have to reprocess this later.

                               capFcb->FcbState &= ~FCB_STATE_TRUNCATE_ON_CLOSE;
                           }

                       } except ( CATCH_EXPECTED_EXCEPTIONS ) {

                           DbgPrint("!!! Handling Exceptions\n");
                           NOTHING;
                       }
                    }

                    // Purging can be done now if this FCB does not support collapsed opens
                    if (!NeedPurge) {
                        NeedPurge = (LastUncleanOnGoodFcb &&
                                     (NeedDelete ||
                                      !FlagOn(capFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED)));
                    }

                    UninitializeCacheMap = TRUE;
                 }
                 break;
              case RDBSS_NTC_STORAGE_TYPE_DIRECTORY :
              case RDBSS_NTC_STORAGE_TYPE_UNKNOWN :
              default:
                 break;
              }
           }
           break;
        default:
           break;
        }

        //  We've just finished everything associated with an unclean
        //  fcb so now decrement the unclean count before releasing
        //  the resource.

        ASSERT( capFcb->UncleanCount );
        InterlockedDecrement(&capFcb->UncleanCount);

        if (FlagOn(capFileObject->Flags,FO_NO_INTERMEDIATE_BUFFERING)) {
            capFcb->UncachedUncleanCount--;
        }

        MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxCleanupFobx,(RxContext));

        ASSERT( capFobx->SrvOpen->UncleanFobxCount );
        capFobx->SrvOpen->UncleanFobxCount--;

        //  If this was the last cached open, and there are open
        //  non-cached handles, attempt a flush and purge operation
        //  to avoid cache coherency overhead from these non-cached
        //  handles later.  We ignore any I/O errors from the flush.

        if (capFcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL) {
            RxFlushFile( RxContext, capFcb );
        }

        if (!FlagOn( capFileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            (capFcb->UncachedUncleanCount != 0) &&
            (capFcb->UncachedUncleanCount == capFcb->UncleanCount) &&
            (capFcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL)) {

            RxFlushFile( RxContext, capFcb );
            CcPurgeCacheSection(
                &capFcb->NonPaged->SectionObjectPointers,
                NULL,
                0,
                FALSE );
        }

        // do we need a flush?
        if (!NeedDelete && NeedPurge) {
            RxDbgTrace(0, Dbg, ("CleanupPurge:CCFlush\n", 0));
            RxFlushFile( RxContext, capFcb );
        }

        // cleanup the cache map to get rid of pages that are no longer part
        // of the file. amazingly, this works even if we didn't init the Cachemap!!!!!

        if (UninitializeCacheMap) {
            RxUninitializeCacheMap( RxContext, capFileObject, TruncateSize );
        }

        //  finish up a delete...we have to purge because MM is holding the file open....
        //  just for the record, NeedPurge is set for files and clear for directories......

        if (NeedDelete || NeedPurge) {

            RxDbgTrace(0, Dbg, ("CleanupPurge:MmFlushImage\n", 0));
            MmFlushImageSection(&capFcb->NonPaged->SectionObjectPointers,
                                MmFlushForWrite);

            ASSERT((AcquiredFcb));
            RxReleaseFcb( RxContext, capFcb );
            AcquiredFcb = FALSE;

            MmForceSectionClosed(&capFcb->NonPaged->SectionObjectPointers, TRUE);

            RxAcquireExclusiveFcb(RxContext,capFcb);
            AcquiredFcb = TRUE;

            RxDbgTrace(0, Dbg, ("CleanupPurge:PurgingFinished\n", 0));

            if (NeedDelete) {
                RxRemoveNameNetFcb( capFcb );
                RxReleaseFcbTableLock(&NetRoot->FcbTable);
                AcquiredTableLock = FALSE;
            }
        }

        //  The Close Call and the Cleanup Call may be far apart. The share access
        //  must be cleaned up if the file was mapped through this File Object.
        if ((ShareAccess != NULL) &&
            (NetRootType == NET_ROOT_DISK)) {
            ASSERT (NetRootType == NET_ROOT_DISK);
            RxRemoveShareAccess( capFileObject, ShareAccess, "Cleanup the Share access", "ClnUpShr" );
        }

        if (TypeOfOpen == RDBSS_NTC_STORAGE_TYPE_FILE) {
            //  Coordinate the cleanup operation with the oplock state.
            //  Cleanup operations can always cleanup immediately.

            FsRtlCheckOplock( &capFcb->Specific.Fcb.Oplock, capReqPacket,
                              RxContext, NULL, NULL );

            //capFcb->Header.IsFastIoPossible = RxIsFastIoPossible( capFcb );
        }

        if (AcquiredFcb) {
            RxReleaseFcb( RxContext, capFcb );
            AcquiredFcb = FALSE;
        }

        //  A local filesystem would do this..........
        //  If the NET_ROOT is on a removeable media, flush the volume.  We do
        //  this in lieu of write through for removeable media for
        //  performance considerations.  That is, data is guaranteed
        //  to be out when NtCloseFile returns.
        //  The file needs to  be flushed

        // The cleanup for this file object has been successfully completed at
        // this point.

        SetFlag( capFileObject->Flags, FO_CLEANUP_COMPLETE );
        Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( RxCommonCleanup );

        if (AcquiredFcb) {
           RxReleaseFcb( RxContext, capFcb );
        }

        if (AcquiredTableLock) {
            RxReleaseFcbTableLock(&NetRoot->FcbTable);
        }

        IF_DEBUG {
           if (AbnormalTermination()) {
              RxDbgTrace(-1, Dbg, ("RxCommonCleanup -> Abnormal Termination %08lx\n", Status));
           } else {
              RxDbgTrace(-1, Dbg, ("RxCommonCleanup -> %08lx\n", Status));
           }
        }
    }

    return Status;
}

VOID
RxAdjustFileTimesAndSize  ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This routine is used to adjust the times and the filesize on a cleanup
    or a flush.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    BOOLEAN UpdateFileSize;
    BOOLEAN UpdateLastWriteTime;
    BOOLEAN UpdateLastAccessTime;
    BOOLEAN UpdateLastChangeTime;

    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    //if there's no cachemap then we don't have to send because the guy is
    //tracking everything on the other end.
    //LOCAL.MINI for a localminiFS we would still have to do this; so the answer to this question
    // (whether to do it or not) should be exposed in the fcb/fobx
    if ( capFileObject->PrivateCacheMap == NULL ) return;

    KeQuerySystemTime( &CurrentTime );

    //
    //  Note that we HAVE to use BooleanFlagOn() here because
    //  FO_FILE_SIZE_CHANGED > 0x80 (i.e., not in the first byte).
    //

    UpdateFileSize = BooleanFlagOn(capFileObject->Flags, FO_FILE_SIZE_CHANGED);

    UpdateLastWriteTime = FlagOn(capFileObject->Flags, FO_FILE_MODIFIED) &&
                          !FlagOn(capFobx->Flags, FOBX_FLAG_USER_SET_LAST_WRITE);

    UpdateLastChangeTime = FlagOn(capFileObject->Flags, FO_FILE_MODIFIED) &&
                          !FlagOn(capFobx->Flags, FOBX_FLAG_USER_SET_LAST_CHANGE);

    UpdateLastAccessTime =
        (UpdateLastWriteTime ||
         (FlagOn(capFileObject->Flags, FO_FILE_FAST_IO_READ) &&
          !FlagOn(capFobx->Flags, FOBX_FLAG_USER_SET_LAST_ACCESS)));

    if (UpdateFileSize      ||
        UpdateLastWriteTime ||
        UpdateLastChangeTime ||
        UpdateLastAccessTime ) {

        ULONG    NotifyFilter = 0;
        BOOLEAN  DoTheTimeUpdate = FALSE;

        FILE_BASIC_INFORMATION       BasicInformation;
        FILE_END_OF_FILE_INFORMATION EofInformation;

        RxDbgTrace(0, Dbg, ("Update Time and/or file size on File\n", 0));
        RtlZeroMemory(&BasicInformation,sizeof(BasicInformation));

        try {     //for finally
            try {   //for exceptions

                if (UpdateLastWriteTime) {

                    //
                    //  Update its time of last write

                    DoTheTimeUpdate = TRUE;
                    capFcb->LastWriteTime = CurrentTime;
                    BasicInformation.LastWriteTime = CurrentTime;

                    NotifyFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES
                                    | FILE_NOTIFY_CHANGE_LAST_WRITE;

                }

                if (UpdateLastChangeTime) {

                    //
                    //  Update its time of last write

                    DoTheTimeUpdate = TRUE;
                    BasicInformation.ChangeTime = capFcb->LastChangeTime;

                    //NotifyFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES
                    //                | FILE_NOTIFY_CHANGE_LAST_CHANGE;

                }

                if (UpdateLastAccessTime) {

                    DoTheTimeUpdate = TRUE;
                    capFcb->LastAccessTime = CurrentTime;
                    BasicInformation.LastAccessTime = CurrentTime;

                    NotifyFilter |= FILE_NOTIFY_CHANGE_LAST_ACCESS;

                }

                if (DoTheTimeUpdate) {
                    NTSTATUS Status;  //if it doesn't work.....sigh
                    RxContext->Info.FileInformationClass = (FileBasicInformation);
                    RxContext->Info.Buffer = &BasicInformation;
                    RxContext->Info.Length = sizeof(BasicInformation);
                    MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxSetFileInfoAtCleanup,(RxContext));
                }

                if (UpdateFileSize) {
                    NTSTATUS Status;  //if it doesn't work.....sigh
                    EofInformation.EndOfFile = capFcb->Header.FileSize;
                    RxContext->Info.FileInformationClass = (FileEndOfFileInformation);
                    RxContext->Info.Buffer = &EofInformation;
                    RxContext->Info.Length = sizeof(EofInformation);
                    MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxSetFileInfoAtCleanup,(RxContext));
                    NotifyFilter |= FILE_NOTIFY_CHANGE_SIZE;
                }

                //RxNotifyReportChange( RxContext, Vcb, Fcb,
                //                       NotifyFilter,
                //                       FILE_ACTION_MODIFIED );

                //MINIRDR_CALL(Status,capFcb->MRxDispatch,MRxSetTimeAndSize,(RxContext));
            } except( CATCH_EXPECTED_EXCEPTIONS ) {
                NOTHING;
            }
        } finally {
            NOTHING;
        }
    }
}


#define RxMoveAllButFirstToAnotherList(List1,List2) { \
        PLIST_ENTRY FrontListEntry = (List1)->Flink;       \
        if (FrontListEntry->Flink == (List1)) {            \
            (List2)->Flink = (List2)->Blink = (List2);     \
        } else {                                           \
            (List2)->Blink = (List1)->Blink;               \
            (List2)->Blink->Flink = (List2);               \
            (List1)->Blink = FrontListEntry;               \
            (List2)->Flink = FrontListEntry->Flink;        \
            FrontListEntry->Flink = (List1);               \
            (List2)->Flink->Blink = (List2);               \
        }                                                  \
}
#if DBG
PSZ RxDSQTagText[FOBX_NUMBER_OF_SERIALIZATION_QUEUES] = {"read","write"};
VOID
RxDumpSerializationQueue(
    PLIST_ENTRY SQ,
    PSZ         TagText1,
    PSZ         TagText2
    )
{
    PLIST_ENTRY ListEntry;
    PAGED_CODE();

    if (IsListEmpty(SQ)) {
        RxDbgTrace(0, Dbg, ("RxDumpSerializationQueue %s%s is empty\n", TagText1, TagText2));
        return;
    }

    RxDbgTrace(0, Dbg, ("RxDumpSerializationQueue %s%s:\n", TagText1, TagText2));
    for (ListEntry=SQ->Flink;
         ListEntry!=SQ;
         ListEntry=ListEntry->Flink) {
        //print out the contexts and the major op for validation
        PRX_CONTEXT RxContext = CONTAINING_RECORD( ListEntry,RX_CONTEXT,RxContextSerializationQLinks);
        RxDbgTrace(0, Dbg, ("        rxc=%08lx op=%02lx\n", RxContext, RxContext->MajorFunction));
    }
}
#else
#define RxDumpSerializationQueue(___r,___t12,___t13) {NOTHING;}
#endif

VOID
RxCleanupPipeQueues (
    IN PRX_CONTEXT RxContext
    )
{
    RxCaptureFcb; RxCaptureFobx;
    LIST_ENTRY SecondaryBlockedQs[FOBX_NUMBER_OF_SERIALIZATION_QUEUES];
    PLIST_ENTRY PrimaryBlockedQs = &capFobx->Specific.NamedPipe.ReadSerializationQueue;
    ULONG i;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCleanupPipeQueues \n"));

    //for pipes there are two sources of unhappiness...........
    //first, we have to get rid of any blocked operations.
    //second, if there are blocking operations that have already gone by then we have to send the
    //        close smb early so that the server will, in turn, complete the outstanding
    ExAcquireFastMutexUnsafe(&RxContextPerFileSerializationMutex);

    for (i=0;i<FOBX_NUMBER_OF_SERIALIZATION_QUEUES;i++) {
        RxDumpSerializationQueue(&PrimaryBlockedQs[i],RxDSQTagText[i],"Primary");
        if (!IsListEmpty(&PrimaryBlockedQs[i])) {
            RxMoveAllButFirstToAnotherList(
                   &PrimaryBlockedQs[i],
                   &SecondaryBlockedQs[i]);
            RxDumpSerializationQueue(&PrimaryBlockedQs[i],RxDSQTagText[i],"Primary");
            RxDumpSerializationQueue(&SecondaryBlockedQs[i],RxDSQTagText[i],"Secondary");
        } else {
            InitializeListHead(&SecondaryBlockedQs[i]);
        }
    }


    ExReleaseFastMutexUnsafe(&RxContextPerFileSerializationMutex);

    for (i=0;i<FOBX_NUMBER_OF_SERIALIZATION_QUEUES;i++) {
        for (;!IsListEmpty(&SecondaryBlockedQs[i]);) {
            PLIST_ENTRY FrontListEntry = (&SecondaryBlockedQs[i])->Flink;
            PRX_CONTEXT FrontRxContext = CONTAINING_RECORD( FrontListEntry,RX_CONTEXT,RxContextSerializationQLinks);
            RemoveEntryList(FrontListEntry);
            if (!FlagOn(FrontRxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                RxDbgTrace(0, Dbg, ("  unblocking %08lx\n",FrontRxContext));
                RxContext->StoredStatus = STATUS_PIPE_CLOSING;
                RxSignalSynchronousWaiter(FrontRxContext);
            } else {
                RxDbgTrace(0, Dbg, ("  completing %08lx\n",FrontRxContext));
                RxCompleteAsynchronousRequest( RxContext, STATUS_PIPE_CLOSING );
            }
        }
    }

    RxDbgTrace(-1, Dbg, ("RxCleanupPipeQueues exit\n"));
    return;
}


BOOLEAN
RxFakeLockEnumerator (
    IN OUT struct _SRV_OPEN * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    )
/*++

Routine Description:

    THIS ROUTINE IS A FAKE THAT IS JUST USED FOR TESTING PURPOSES!

    This routine is called from a minirdr to enumerate the filelocks on an FCB; it gets
    one lock on each call. currently, we just pass thru to the fsrtl routine which is very funky
    because it keeps the enumeration state internally; as a result, only one enumeration can be in progress
    at any time. we can change over to something better if it's ever required.


Arguments:

    SrvOpen - a srvopen on the fcb to be enumerated.

    ContinuationHandle - a handle passed back and forth representing the state of the enumeration.
                         if a NULL is passed in, then we are to start at the beginning.

    FileOffset,LockRange,IsLockExclusive - the description of the returned lock

Return Value:

    a BOOLEAN. FALSE means you've reached the end of the list; TRUE means the returned lock data is valid

--*/
{
    ULONG LockNumber;

    LockNumber = (ULONG)(*ContinuationHandle);
    if (LockNumber>=12) {
        return(FALSE);
    }
    LockNumber++;
    RxDbgTrace(0, Dbg, ("Rxlockenum %08lx\n", LockNumber ));
    FileOffset->QuadPart = LockNumber;
    LockRange->QuadPart = 1;
    *IsLockExclusive = (LockNumber&0x4)==0;
    *ContinuationHandle = (PVOID)LockNumber;
}

BOOLEAN
RxUninitializeCacheMap(
    IN OUT PRX_CONTEXT RxContext,
    IN     PFILE_OBJECT FileObject,
    IN     PLARGE_INTEGER TruncateSize
    )
/*++

Routine Description:

    This routine is a wrapper for CcUninitializeCacheMap.

Arguments:

    IN PFILE_OBJECT FileObject - Supplies the file object for the file to purge.
    IN PLARGE_INTEGER TruncateSize - Specifies the new size for the file.


Return Value:

    BOOLEAN - TRUE if file has been immediately purged, FALSE if we had to wait.

Note:
    The file must be locked exclusively before calling this routine.


--*/
{
    BOOLEAN CacheReturnValue;
    CACHE_UNINITIALIZE_EVENT PurgeCompleteEvent;
    PFCB Fcb = FileObject->FsContext;

    PAGED_CODE();

    ASSERT ( NodeTypeIsFcb(Fcb) );

    //
    //  Make sure that this thread owns the FCB.
    //

    ASSERT  ( RxIsFcbAcquiredExclusive ( Fcb )  );

#if 0
BUGBUG do we need this part too? [joejoe]   of course we do. or something similar. we have to synchronize openers
with this piece of code.
    //
    //  In order to guarantee that only one thread is calling
    //  RxPurgeCacheFile, we reset this event to the
    //  not-signalled state before calling CcUninitializeCacheMap,
    //  and then set it when we exit.  If any other threads come in
    //  while we are waiting on the event, they will find that
    //  CacheFileObject is NULL, and thus wait until the cache purge
    //  completes.
    //

    KeClearEvent(&Fcb->NonPagedFcb->PurgeCacheSynchronizer);
#endif

    //
    //  Now uninitialize the cache managers own file object.  This is
    //  done basically simply to allow us to wait until the cache purge
    //  is complete.
    //

    KeInitializeEvent(&PurgeCompleteEvent.Event, SynchronizationEvent, FALSE);

    //
    //  Release the lock on the FCB that our caller applied.
    //

    RxReleaseFcb( RxContext, Fcb );

    //RxLog(( "ccunini1", &Fcb->FileName, 2,
    //        (TruncateSize == NULL) ? 0xffffffff : TruncateSize->LowPart,
    //        (ULONG)&PurgeCompleteEvent ));
    CacheReturnValue = CcUninitializeCacheMap(FileObject, TruncateSize, &PurgeCompleteEvent);

#if 0
    //
    //  Make sure that this thread doesn't own the FCB.
    //

    ASSERT (!ExIsResourceAcquiredExclusive(Fcb->Header.Resource));
#endif
    //
    //  Now wait for the cache manager to finish purging the file.
    //

    KeWaitForSingleObject(&PurgeCompleteEvent.Event,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL);

    //
    //  Re-acquire the FCB lock once we've waited for the
    //  cache manager to finish the uninitialize.
    //

    RxAcquireExclusiveFcb( RxContext, Fcb );
#if 0
    //
    //  Now set the purge cache event to the signalled state to allow
    //  other threads waiting on the cache purge to continue.
    //

    KeSetEvent(&Fcb->NonPagedFcb->PurgeCacheSynchronizer, 0, FALSE);
#endif
    return(CacheReturnValue);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\wrapper.sav\fsctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Rdbss. Fsctls on the device
    fcb are handled in another module.

Author:

   Joe Linn [JoeLinn] 7-mar-95

Revision History:

   Balan Sethu Raman 18-May-95 -- Integrated with mini rdrs

--*/

#include "precomp.h"
#pragma hdrstop
#include <dfsfsctl.h>

//  The local debug trace level

#define Dbg                              (DEBUG_TRACE_FSCTRL)


//  Local procedure prototypes

NTSTATUS
RxUserFsCtrl ( RXCOMMON_SIGNATURE );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonFileSystemControl)
#pragma alloc_text(PAGE, RxUserFsCtrl)
#pragma alloc_text(PAGE, RxLowIoFsCtlShell)
#pragma alloc_text(PAGE, RxLowIoFsCtlShellCompletion)
#endif

NTSTATUS
RxCommonFileSystemControl ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads. What happens is that we pick off fsctls that we know about
    and remote the rest....remoting means sending them thru the lowio stuff which may/will pick off
    a few more. the ones that we pick off here (and currently return STATUS_NOT_IMPLEMENTED) and the
    ones for being an oplock provider and for doing volume mounts....we don't even have volume fcbs
    yet since this is primarily a localFS concept. nevertheless, these are not passed thru to the mini.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation
--*/
{
   RxCaptureRequestPacket;
   RxCaptureParamBlock;
   RxCaptureFcb;
   RxCaptureFobx;
   RxCaptureFileObject;

   NTSTATUS       Status;
   NODE_TYPE_CODE TypeOfOpen;
   BOOLEAN TryLowIo = TRUE;
   ULONG FsControlCode = capPARAMS->Parameters.FileSystemControl.FsControlCode;

    PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("RxCommonFileSystemControl %08lx\n", RxContext));
   RxDbgTrace( 0, Dbg, ("Irp           = %08lx\n", capReqPacket));
   RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", capPARAMS->MinorFunction));
   RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode));

   RxLog(("FsCtl %x %x %x %x",RxContext,capReqPacket,capPARAMS->MinorFunction,FsControlCode));

   ASSERT(capPARAMS->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL);

   switch (capPARAMS->MinorFunction) {
   case IRP_MN_USER_FS_REQUEST:
      {

         RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode));
         switch (FsControlCode) {
         case FSCTL_REQUEST_OPLOCK_LEVEL_1:
         case FSCTL_REQUEST_OPLOCK_LEVEL_2:
         case FSCTL_REQUEST_BATCH_OPLOCK:
         case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
         case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
         case FSCTL_OPLOCK_BREAK_NOTIFY:
         case FSCTL_OPLOCK_BREAK_ACK_NO_2:
            {
               // fsrtl oplock package is handled in common for all minirdrs

               //Status = RxOplockRequest( RXCOMMON_ARGUMENTS, &PostToFsp );
               Status = STATUS_NOT_IMPLEMENTED;
               TryLowIo = FALSE;
            }
            break;

         case FSCTL_LOCK_VOLUME:
         case FSCTL_UNLOCK_VOLUME:
         case FSCTL_DISMOUNT_VOLUME:
         case FSCTL_MARK_VOLUME_DIRTY:
         case FSCTL_IS_VOLUME_MOUNTED:
            {
               //  Decode the file object, the only type of opens we accept are
               //  user volume opens.
               TypeOfOpen    = NodeType(capFcb);

               if (TypeOfOpen != RDBSS_NTC_VOLUME_FCB) {
                   Status = STATUS_INVALID_PARAMETER;
               } else {
                   //Status = RxFsdPostRequestWithResume(RxContext,RxCommonDevFCBFsCtl);
                   Status = STATUS_NOT_IMPLEMENTED;
               }
               TryLowIo = FALSE;
            }
            break;
         case FSCTL_DFS_GET_REFERRALS:
         case FSCTL_DFS_REPORT_INCONSISTENCY:
            {
               if (!BooleanFlagOn(capFcb->pVNetRoot->pNetRoot->pSrvCall->Flags,SRVCALL_FLAG_DFS_AWARE_SERVER)) {
                  TryLowIo = FALSE;
                  Status = STATUS_DFS_UNAVAILABLE;
               }
            }
            break;
         default:
            break;
         }
      }
      break;
    default:
       break;
    }

    if (TryLowIo) {
        Status = RxLowIoFsCtlShell(RxContext);
    }

    if (RxContext->PostRequest) {
       Status = RxFsdPostRequest(RxContext);
    }

   RxDbgTrace(-1, Dbg, ("RxCommonFileSystemControl -> %08lx\n", Status));

   return Status;
}

ULONG RxEnablePeekBackoff = 1;

NTSTATUS
RxLowIoFsCtlShell( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    RxCaptureFcb;
    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    RxCaptureFobx;
    RxCaptureFileObject;

    NTSTATUS       Status        = STATUS_SUCCESS;
    BOOLEAN        PostToFsp     = FALSE;
    //BOOLEAN        TryToRemoteIt = TRUE;
    NODE_TYPE_CODE TypeOfOpen    = NodeType(capFcb);
    PLOWIO_CONTEXT pLowIoContext  = &RxContext->LowIoContext;
    ULONG          FsControlCode = capPARAMS->Parameters.FileSystemControl.FsControlCode;
    BOOLEAN        SubmitLowIoRequest = TRUE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxLowIoFsCtlShell...\n", 0));
    RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode));

    RxInitializeLowIoContext(pLowIoContext,LOWIO_OP_FSCTL);

    switch (capPARAMS->MinorFunction) {
    case IRP_MN_USER_FS_REQUEST:
        {
        //  The RDBSS filters out those FsCtls that can be handled without the intervention
        //  of the mini rdr's. Currently all FsCtls are forwarded down to the mini rdr.
        switch (FsControlCode) {
        case FSCTL_PIPE_PEEK:
           {
              if (RxShouldRequestBeThrottled(&capFobx->Specific.NamedPipe.ThrottlingState)
                       && RxEnablePeekBackoff) {
                    PFILE_PIPE_PEEK_BUFFER pPeekBuffer;

                    ASSERT(capReqPacket->UserBuffer != NULL);

                    pPeekBuffer = (PFILE_PIPE_PEEK_BUFFER)capReqPacket->UserBuffer;

                    SubmitLowIoRequest = FALSE;
                    RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShell: Throttling Peek Request\n"));

                    capReqPacket->IoStatus.Information = FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER,Data);
                    pPeekBuffer->ReadDataAvailable = 0;
                    pPeekBuffer->NamedPipeState    = FILE_PIPE_CONNECTED_STATE;
                    pPeekBuffer->NumberOfMessages  = MAXULONG;
                    pPeekBuffer->MessageLength     = 0;

                    Status = STATUS_SUCCESS;
                    RxContext->StoredStatus = Status;
              } else {

                  RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShell: Throttling queries %ld\n",
                                       capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));

                  RxLog(("ThrottlQs %lx %lx %lx %ld\n",
                                       RxContext,capFobx,&capFobx->Specific.NamedPipe.ThrottlingState,
                                       capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));

              }


           }
           break;
        default:
           break;
        } //end of the inner switch
        } //end of the case
        break;
    default:
        break;
    }

    if (SubmitLowIoRequest) {
       Status = RxLowIoSubmit(RxContext,RxLowIoFsCtlShellCompletion);
    }

    RxDbgTrace(-1, Dbg, ("RxLowIoFsCtlShell -> %08lx\n", Status ));
    return Status;
}

NTSTATUS
RxLowIoFsCtlShellCompletion( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the completion routine for FSCTL requests passed down to the mini rdr

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;

    NTSTATUS       Status;
    //NODE_TYPE_CODE TypeOfOpen    = NodeType(capFcb);
    PLOWIO_CONTEXT pLowIoContext  = &RxContext->LowIoContext;
    ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    RxDbgTrace(+1, Dbg, ("RxLowIoFsCtlShellCompletion  entry  Status = %08lx\n", Status));

    switch (FsControlCode) {
    case FSCTL_PIPE_PEEK:
       {
          if ((Status == STATUS_SUCCESS) ||
              (Status == STATUS_BUFFER_OVERFLOW)) {
             // In the case of Peek operations a throttle mechanism is in place to
             // prevent the network from being flodded with requests which return 0
             // bytes.

             PFILE_PIPE_PEEK_BUFFER pPeekBuffer;

             pPeekBuffer = (PFILE_PIPE_PEEK_BUFFER)pLowIoContext->ParamsFor.FsCtl.pOutputBuffer;

             if (pPeekBuffer->ReadDataAvailable == 0) {

                 // The peek request returned zero bytes.

                 RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShellCompletion: Enabling Throttling for Peek Request\n"));
                 RxInitiateOrContinueThrottling(&capFobx->Specific.NamedPipe.ThrottlingState);
                 RxLog(("ThrottlYes %lx %lx %lx %ld\n",
                                   RxContext,capFobx,&capFobx->Specific.NamedPipe.ThrottlingState,
                                   capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));

             } else {

                 RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShellCompletion: Disabling Throttling for Peek Request\n"));
                 RxTerminateThrottling(&capFobx->Specific.NamedPipe.ThrottlingState);
                 RxLog(("ThrottlNo %lx %lx %lx %ld\n",
                                   RxContext,capFobx,&capFobx->Specific.NamedPipe.ThrottlingState,
                                   capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
             }

             capReqPacket->IoStatus.Information = RxContext->InformationToReturn;
          }
       }
       break;
    default:
       if ((Status == STATUS_BUFFER_OVERFLOW) ||
           (Status == STATUS_SUCCESS)) {
          //ASSERT( RxContext->InformationToReturn == pLowIoContext->ParamsFor.FsCtl.OutputBufferLength);
          //capReqPacket->IoStatus.Information = pLowIoContext->ParamsFor.FsCtl.OutputBufferLength;
          capReqPacket->IoStatus.Information = RxContext->InformationToReturn;
       }
       break;
    }

    capReqPacket->IoStatus.Status = Status;
    RxDbgTrace(-1, Dbg, ("RxLowIoFsCtlShellCompletion  exit  Status = %08lx\n", Status));
    return Status;
}

//
//  Local support routine
//

//OPLOCKS we will want this eventually....don't take it out
//        there are embedded #ifs so it is not trivial to do this
#if 0
NTSTATUS
RxOplockRequest (
                  RXCOMMON_SIGNATURE,
                  IN PBOOLEAN PostToFsp
                )
/*++

Routine Description:

    This is the common routine to handle oplock requests made via the
    NtFsControlFile call.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    ULONG FsControlCode = capPARAMS->Parameters.FileSystemControl.FsControlCode;

    ULONG OplockCount;

    BOOLEAN AcquiredVcb = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxOplockRequest...\n", 0));
    RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode));

    //
    //  We only permit oplock requests on files.
    //

    if ( TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE ) {
        //RxCompleteRequest( RxContext, RxStatus(INVALID_PARAMETER) );
        RxDbgTrace(-1, Dbg, ("RxOplockRequest -> RxStatus(INVALID_PARAMETER\n)", 0));
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Switch on the function control code.  We grab the Fcb exclusively
    //  for oplock requests, shared for oplock break acknowledgement.
    //

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:

        //joejoe don't be an oplock filesystem yet
        RxCompleteContextAndReturn( STATUS_OPLOCK_NOT_GRANTED );
//BUGBUG move this code down to wrapper.sav
//BUGBUG should we return NOT_IMPLEMENTED instead???
//i removed this code by #if so that we can see what we'll have to put in for oplocks
#if 0
        if ( !RxAcquireSharedVcb( RxContext, capFcb->Vcb )) {

            //
            //  If we can't acquire the Vcb, then this is an invalid
            //  operation since we can't post Oplock requests.
            //

            RxDbgTrace(0, Dbg, ("Cannot acquire exclusive Vcb\n", 0));

            //RxCompleteRequest( RxContext, RxStatus(OPLOCK_NOT_GRANTED) );
            RxDbgTrace(-1, Dbg, ("RxOplockRequest -> RxStatus(OPLOCK_NOT_GRANTED\n)", 0));
            return STATUS_OPLOCK_NOT_GRANTED;
        }

        AcquiredVcb = TRUE;

        //
        //  We set the wait parameter in the RxContext to FALSE.  If this
        //  request can't grab the Fcb and we are in the Fsp thread, then
        //  we fail this request.
        //

        ClearFlag(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);

        if ( !RxAcquireExclusiveFcb( RxContext, capFcb )) {

            RxDbgTrace(0, Dbg, ("Cannot acquire exclusive Fcb\n", 0));

            RxReleaseVcb( RxContext, capFcb->Vcb );

            //
            //  We fail this request.
            //

            Status = STATUS_OPLOCK_NOT_GRANTED;

            //RxCompleteRequest( RxContext, Status );

            RxDbgTrace(-1, Dbg, ("RxOplockRequest -> %08lx\n", Status ));
            return Status;
        }

        if (FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {

            OplockCount = (ULONG) FsRtlAreThereCurrentFileLocks( &capFcb->Specific.Fcb.FileLock );

        } else {

            OplockCount = capFcb->UncleanCount;
        }

        break;
#endif
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:

        //joejoe don't be an oplock filesystem yet
        RxCompleteContextAndReturn( STATUS_INVALID_OPLOCK_PROTOCOL );
#if 0
//just keep it for a model
        if ( !RxAcquireSharedFcb( RxContext, capFcb )) {

            RxDbgTrace(0, Dbg, ("Cannot acquire shared Fcb\n", 0));

            Status = RxFsdPostRequest( RxContext );

            RxDbgTrace(-1, Dbg, ("RxOplockRequest -> %08lx\n", Status ));
            return Status;
        }

        break;
#endif
    default:

        RxBugCheck( FsControlCode, 0, 0 );
    }

    //
    //  Use a try finally to free the Fcb.
    //

    try {

        ////
        ////  Call the FsRtl routine to grant/acknowledge oplock.
        ////
        //
        //Status = FsRtlOplockFsctrl( &capFcb->Specific.Fcb.Oplock,
        //                            capReqPacket,
        //                            OplockCount );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        capFcb->Header.IsFastIoPossible = RxIsFastIoPossible( capFcb );

    } finally {

        DebugUnwind( RxOplockRequest );

        //
        //  Release all of our resources
        //

        if (AcquiredVcb) {

            RxReleaseVcb( RxContext, capFcb->Vcb );
        }

        RxReleaseFcb( RxContext, capFcb );

        if (!AbnormalTermination()) {

            //RxCompleteRequest_OLD( RxContext, RxNull, 0 );
        }

        RxDbgTrace(-1, Dbg, ("RxOplockRequest -> %08lx\n", Status ));
    }

    return Status;
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\wrapper.sav\shutdown.c ===
/*++
Copyright (c) 1989  Microsoft Corporation

Module Name:

    Shutdown.c

Abstract:

    This module implements the file system shutdown routine for Rx

Author:

    Gary Kimura     [GaryKi]    19-Aug-1991

Revision History:

DANGER   DANGER   DANGER

THIS IS THE OLD FAT CODE....MINIMAL MODIFICATIONS HAVE BEEN MADE TO MAKE IT COMPILE.........
CODE.IMPROVEMENT
--*/

#include "precomp.h"
#pragma hdrstop


#define RxFlushVolume( __x, __y) (RtlAssert("dont call rxflushvolume", __FILE__, __LINE__, NULL))


//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_SHUTDOWN)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonShutdown)
#endif


NTSTATUS
RxCommonShutdown ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for shutdown called by both the fsd and
    fsp threads.

Arguments:

    Irp - Supplies the Irp being processed
Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    //PKEVENT Event;

    //PLIST_ENTRY Links;
    //PVCB Vcb;
    //PIRP NewIrp;
    //IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    //
    //  Make sure we don't get any pop-ups, and write everything through.
    //
    ASSERT(!"Shutdown is not implemented");

#if 0
//BUGBUG
// we should do a forced finalize here! i wonder what rdr1 does...............

    SetFlag(RxContext->Flags, RX_CONTEXT_FLAG_DISABLE_POPUPS |
                               RX_CONTEXT_FLAG_WRITE_THROUGH);

    //
    //  Allocate an initialize an event for doing calls down to
    //  our target deivce objects
    //

    Event = RxAllocatePoolWithTag( NonPagedPool, sizeof(KEVENT), RX_MISC_POOLTAG );
    KeInitializeEvent( Event, NotificationEvent, FALSE );

    //
    //  Get everyone else out of the way
    //

    (VOID) RxAcquireExclusiveGlobal( RxContext );

    try {

        //
        //  For every volume that is mounted we will flush the
        //  volume and then shutdown the target device objects.
        //

        for (Links = RxData.VcbQueue.Flink;
             Links != &RxData.VcbQueue;
             Links = Links->Flink) {

            Vcb = CONTAINING_RECORD(Links, VCB, VcbLinks);

            //
            //  If we have already been called before for this volume
            //  (and yes this does happen), skip this volume as no writes
            //  have been allowed since the first shutdown.
            //

            if ( FlagOn( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN) ||
                 (Vcb->VcbCondition != VcbGood) ) {

                continue;
            }

            //joejoe an underlying routine for this macro has been removed
            // this code is never executed in the remote case because we never haver a
            // VCB queue formed!
            //RxAcquireExclusiveVolume( RxContext, Vcb );

            try {

                if ( (Vcb->VcbCondition == VcbGood) &&
                     (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_FLOPPY)) ) {

                    (VOID)RxFlushVolume( RxContext, Vcb );

                    NewIrp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                           Vcb->TargetDeviceObject,
                                                           NULL,
                                                           0,
                                                           NULL,
                                                           Event,
                                                           &Iosb );

                    if (NewIrp != NULL) {

                        if (NT_SUCCESS(IoCallDriver( Vcb->TargetDeviceObject, NewIrp ))) {

                            (VOID) KeWaitForSingleObject( Event,
                                                          Executive,
                                                          KernelMode,
                                                          FALSE,
                                                          NULL );

                            (VOID) KeResetEvent( Event );
                        }
                    }
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                NOTHING;
            }

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN );

            //joejoe see comment above
            //RxReleaseVolume( RxContext, Vcb );
        }

    } finally {

        RxFreePool( Event );

        RxReleaseGlobal( RxContext );

        //RxCompleteRequest( RxContext, RxStatus(SUCCESS) );
    }

    //
    //  And return to our caller
    //

#endif
    //RxCompleteRequest( RxContext, RxStatus(SUCCESS) );
    return STATUS_SUCCESS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdr2kd\rdr2kd.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdr2kd.c

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _RDR2KD_H_
#define _RDR2KD_H_

typedef enum _FOLLOWON_HELPER_RETURNS {
    FOLLOWONHELPER_CALLTHRU,
    FOLLOWONHELPER_DUMP,
    FOLLOWONHELPER_ERROR,
    FOLLOWONHELPER_DONE
} FOLLOWON_HELPER_RETURNS;

typedef struct _PERSISTENT_RDR2KD_INFO {
    DWORD OpenCount;
    ULONG_PTR LastAddressDumped[100];
    ULONG IdOfLastDump;
    ULONG IndexOfLastDump;
    BYTE StructDumpBuffer[2048];
} PERSISTENT_RDR2KD_INFO, *PPERSISTENT_RDR2KD_INFO;

PPERSISTENT_RDR2KD_INFO LocatePersistentInfoFromView ();
VOID
FreePersistentInfoView (
    PPERSISTENT_RDR2KD_INFO p
    );


typedef
FOLLOWON_HELPER_RETURNS
(NTAPI *PFOLLOWON_HELPER_ROUTINE) (
    IN OUT PPERSISTENT_RDR2KD_INFO p,
    OUT    PBYTE Name,
    OUT    PBYTE Buffer2
    );

#define DECLARE_FOLLOWON_HELPER_CALLEE(s) \
    FOLLOWON_HELPER_RETURNS s (           \
    IN OUT PPERSISTENT_RDR2KD_INFO p,     \
    OUT    PBYTE Name,                    \
    OUT    PBYTE Buffer2       \
    )

#endif // _RDR2KD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdr2kd\strucsup.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    strucsup.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <rdr2kd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>

//need this for unaligned smbget macros
#include <smbgtpt.h>

extern WINDBG_EXTENSION_APIS ExtensionApis;
//EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf
#define    PRINTF     dprintf

#define    NL      1
#define    NONL    0

BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
#ifndef RXKD_2col
ULONG s_NoOfColumns = 1;
#else
ULONG s_NoOfColumns = 2;
#endif

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */

char *NewLine  = "\n";
char *FieldSeparator = " ";
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
#define FIELD_NAME_LENGTH 30

/*
 * Print out an optional message, a UNICODE_STRING, and maybe a new-line
 */
BOOL
wPrintStringU( IN LPSTR PrefixMsg OPTIONAL, IN PUNICODE_STRING puStr, IN LPSTR SuffixMsg OPTIONAL )
{
    PWCHAR    StringData;
    UNICODE_STRING UnicodeString;
    ULONG BytesRead;

    if (PrefixMsg == NULL) {
        PrefixMsg = "";
    }
    if (SuffixMsg == NULL) {
        SuffixMsg = "";
    }

    StringData = (PWCHAR)LocalAlloc( LPTR, puStr->Length + sizeof(UNICODE_NULL));
    if( StringData == NULL ) {
        dprintf( "Out of memory!\n" );
        return FALSE;
    }
    UnicodeString.Buffer =  StringData; //puStr->Buffer;
    UnicodeString.Length =  puStr->Length;
    UnicodeString.MaximumLength =  puStr->MaximumLength;

    ReadMemory( (ULONG_PTR)puStr->Buffer,
               StringData,
               puStr->Length,
               &BytesRead);

    if (BytesRead)  {
        dprintf("%s%wZ%s", PrefixMsg, &UnicodeString, SuffixMsg );
    } else {
        dprintf("MEMORYREAD FAILED %s%s",PrefixMsg,SuffixMsg);
    }

    LocalFree( (HLOCAL)StringData );

    return BytesRead;
}

VOID
SetFlagString(
    ULONG Value,
    PCHAR FlagString
    )
{
    ULONG i,t,mask;
    *FlagString = '('; FlagString++;
    for (i=t=0,mask=1;i<32;i++,mask<<=1) {
        //PRINTF("hithere %08lx %08lx %08lx\n",Value,mask,i);
        if (i==t+10) {
            *FlagString = ':'; FlagString++;
            t=t+10;
        }
        if (Value&mask) {
            *FlagString = '0'+(UCHAR)(i-t); FlagString++;
        }
    }

    *FlagString = ')'; FlagString++;
    *FlagString = 0;
}

VOID
PrintStructFields( ULONG_PTR dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16X%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLineForFields(i) );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLineForFields(i));
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLineForFields(i));
            break;
        case FieldTypePointer:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULong:
        case FieldTypeLong:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongUnaligned:
        case FieldTypeLongUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUlong( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShortUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUshort( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongFlags:{ULONG Value; char FlagString[60];
            Value = *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset );
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUShortFlags:{USHORT Value; char FlagString[60];
            Value = *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUnicodeString:
            wPrintStringU( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NULL );
            PRINTF( NewLine );
            break;
        //case FieldTypeAnsiString:
        //    //PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
        //    //PRINTF( NewLine );
        //    PRINTF( NewLine );
        //    break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG_PTR Displacement;
                PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ));

                GetSymbol( sym, SymbolName, &Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLineForFields(i) );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numericla value.

               EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"@$#%^&*");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
            }
            break;
        case FieldTypeStruct:
            PRINTF( "@%-15X%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeLargeInteger:
        case FieldTypeFileTime:
        default:
            ERRPRT( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }
}

DECLARE_API( columns )
{
    ULONG NoOfColumns;
    int   i;

    //SETCALLBACKS();

    //sscanf(lpArgumentString,"%ld",&NoOfColumns);
    sscanf(args,"%ld",&NoOfColumns);

    if (NoOfColumns > s_MaxNoOfColumns) {
        // PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
    } else {
        s_NoOfColumns = NoOfColumns;
    }

    PRINTF("Not Yet Implemented\n");

    return;
}

#define NAME_DELIMITER '@'
#define NAME_DELIMITERS "@"
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG             ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbigous = FALSE;


    while ((pStructs->StructName != 0)) {
        int Result = _strnicmp(lpArgument,
                              pStructs->StructName,
                              MIN(strlen(pStructs->StructName),ArgumentLength));

        if (Result == 0) {
            if (NameIndex != INVALID_INDEX) {
                // We have encountered duplicate matches. Print out the
                // matching strings and let the user disambiguate.
               fAmbigous = TRUE;
               break;
            } else {
               NameIndex = i;
            }

        }
        pStructs++;i++;
    }

    if (fAmbigous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

PPERSISTENT_RDR2KD_INFO
LocatePersistentInfoFromView()
/*
    the purpose of this routine is to allocate or find the named section that holds the
    data we expect to find across calls. the way that we make this persitent is that we
    do not close the handle used to create the view. it will go away when the process does.
*/
{
    BYTE SectionName[128];
    DWORD SectionSize;
    DWORD ProcessId;
    HANDLE h;
    BOOLEAN CreatedSection = FALSE;
    PPERSISTENT_RDR2KD_INFO p;

    ProcessId = GetCurrentProcessId();
    SectionSize = sizeof(PERSISTENT_RDR2KD_INFO);
    sprintf(SectionName,"Rdr2KdSection_%08lx",ProcessId);
    //PRINTF("sectionname=%s, size=%x\n",SectionName,SectionSize);

    h = OpenFileMappingA(
           FILE_MAP_WRITE, //DWORD  dwDesiredAccess,	// access mode
           FALSE,           //BOOL  bInheritHandle,	// inherit flag
           SectionName     //LPCTSTR  lpName 	// address of name of file-mapping object
           );

    if (h==NULL) {
        h = CreateFileMappingA(
                   (HANDLE)IntToPtr(0xFFFFFFFF), // HANDLE  hFile,	// handle of file to map
                    NULL,              //LPSECURITY_ATTRIBUTES  lpFileMappingAttributes,	// optional security attributes
                    PAGE_READWRITE,    //DWORD  flProtect,	// protection for mapping object
                    0,                 //DWORD  dwMaximumSizeHigh,	// high-order 32 bits of object size
                    SectionSize,       //DWORD  dwMaximumSizeLow,	// low-order 32 bits of object size
                    SectionName        //LPCTSTR  lpName 	// name of file-mapping object
                    );
        if (h==NULL) {
            return(FALSE);
        }
        CreatedSection = TRUE;
    }

    //now we have a filemapping....get a view.....
    p = MapViewOfFile(h,FILE_MAP_WRITE,0,0,0);
    if (p==NULL) {
        CloseHandle(h);
        return(NULL);
    }

    if (CreatedSection) {
        //zero the stuff that needs to be zeroed....
        ULONG i;
        p->IdOfLastDump = 0;
        for (i=0;i<100;i++) {
            p->LastAddressDumped[i] = 0;
        }
        p->OpenCount = 100;
    } else {
        CloseHandle(h);
        p->OpenCount++;
    }

    //PRINTF("Opencount for persistent section = %08lx\n",p->OpenCount);
    return(p);
}

VOID
FreePersistentInfoView (
    PPERSISTENT_RDR2KD_INFO p
    )
{
    UnmapViewOfFile(p);
}

VOID
DumpAStruct (
    ULONG_PTR dwAddress,
    STRUCT_DESCRIPTOR *pStruct
    )
{
    DWORD Index = (DWORD)(pStruct - Structs);
    DWORD SizeToRead = min(pStruct->StructSize,2048);
    PPERSISTENT_RDR2KD_INFO p;

    p = LocatePersistentInfoFromView();

    PRINTF("top @ %lx and %lx for %s(%d,%d)\n",dwAddress,p,pStruct->StructName,Index,p->IdOfLastDump);
    if (!p) {
        PRINTF("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    if ((dwAddress==0) &&(Index<100)) {
        dwAddress = p->LastAddressDumped[Index];
        PRINTF("setting @ %lx and %lx for %s\n",dwAddress,p->LastAddressDumped[Index],pStruct->StructName);
    }

    if (wGetData(dwAddress,&p->StructDumpBuffer[0],SizeToRead,pStruct->StructName)) {

        p->LastAddressDumped[Index] = dwAddress;
        p->IdOfLastDump = pStruct->EnumManifest;
        p->IndexOfLastDump = Index;

        PRINTF("++++++++++++++++ %s(%d/%d)@%lx ---+++++++++++++\n",
            pStruct->StructName,
            p->IdOfLastDump,p->IndexOfLastDump,
            dwAddress);
        PrintStructFields(
            dwAddress,
            &p->StructDumpBuffer[0],
            pStruct->FieldDescriptors);
        PRINTF("---------------- %s@%lx ----------------\n",
            pStruct->StructName,
            dwAddress);
    }

    if (p!= NULL) FreePersistentInfoView(p);
    return;
}


DECLARE_API( dump )
{
    ULONG_PTR dwAddress;

    //SETCALLBACKS();

    if( args && *args ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (PSTR)args;
        LPSTR lpArgs = strpbrk(args, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            for (;*lpName==' ';) { lpName++; } //skip leading blanks

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {
                BYTE DataBuffer[512];

                dwAddress = GetExpression( ++lpArgs );
                DumpAStruct(dwAddress,&Structs[Index]);
                //if (wGetData(dwAddress,DataBuffer,Structs[Index].StructSize,"..structure")) {
                //
                //    PRINTF(
                //        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //    PrintStructFields(
                //        dwAddress,
                //        &DataBuffer,
                //        Structs[Index].FieldDescriptors);
                //    PRINTF(
                //        "---------------- %s@%lx ----------------\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //} else {
                //    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                //}
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
#if 0
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
#endif
            //
            // here we try to figure out what to display based on the context....whoa, nellie!
            //
            USHORT Tag;
            STRUCT_DESCRIPTOR *pStructs = Structs;
            ULONG             NameIndex = INVALID_INDEX;
            BYTE DataBuffer[512];
            //ULONG             ArgumentLength = strlen(lpArgument);
            //BOOLEAN           fAmbigous = FALSE;



            dwAddress = GetExpression( args );
            if (!wGetData(dwAddress,&Tag,sizeof(Tag),"..structure TAG")) return;

            PRINTF("here's the tag: %04lx\n",Tag);

            //look thru the table for matching structs

            while ((pStructs->StructName != 0)) {
                int Result = (Tag&pStructs->MatchMask)==pStructs->MatchValue;

                if (Result != 0) {

                    DumpAStruct(dwAddress,pStructs);
                    break;
                }


                pStructs++;
            }

        }
    } else {
            DisplayStructs();
    }

    return;
}


DECLARE_API( ddd )
{
    dump( hCurrentProcess,
          hCurrentThread,
          dwCurrentPc,
          dwProcessor,
          args
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdr2kd\rdr2kd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdr2kd.c

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rx.h"       // NT network file system driver include file
#include "ntddnfs2.h" // new stuff device driver definitions
#include "smbmrx.h"   // smbmini rdr global include file

#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <rdr2kd.h>


VOID
DumpAStruct (
    ULONG_PTR dwAddress,
    STRUCT_DESCRIPTOR *pStruct);

VOID
MyDprintf(PCSTR, ULONG_PTR);

ULONG
MyCheckControlC(VOID);

ULONG_PTR
MyGetExpression(PCSTR);

/*
 * RDR2 global variables.
 *
 */

LPSTR GlobalBool[]  = {
            "mrxsmb!MRxSmbDeferredOpensEnabled",
            "mrxsmb!MRxSmbOplocksDisabled",
             0};

LPSTR GlobalShort[] = {0};
LPSTR GlobalLong[]  = {
            0};

LPSTR GlobalPtrs[]  = {
            "rdbss!RxExpCXR",
            "rdbss!RxExpEXR",
            "rdbss!RxExpAddr",
            "rdbss!RxExpCode",
            "rdbss!RxActiveContexts",
            "rdbss!RxNetNameTable",
            "rdbss!RxProcessorArchitecture",
            "rdbss!RxBuildNumber",
            "rdbss!RxPrivateBuild",
            "mrxsmb!SmbMmExchangesInUse",
            "mrxsmb!MRxSmbBuildNumber",
            "mrxsmb!MRxSmbPrivateBuild",
            0};


/*
 * IRP_CONTEXT debugging.
 *
 */

FIELD_DESCRIPTOR RxContextFields[] =
   {
      FIELD3(FieldTypeUShort,RX_CONTEXT,NodeTypeCode),
      FIELD3(FieldTypeShort,RX_CONTEXT,NodeByteSize),
      FIELD3(FieldTypeULong,RX_CONTEXT,ReferenceCount),
      FIELD3(FieldTypeULong,RX_CONTEXT,SerialNumber),
      FIELD3(FieldTypeStruct,RX_CONTEXT,WorkQueueItem),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrp),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrpSp),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFcb),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFobx),
      //FIELD3(FieldTypePointer,RX_CONTEXT,pRelevantSrvOpen),
      FIELD3(FieldTypePointer,RX_CONTEXT,LastExecutionThread),
#ifdef RDBSS_TRACKER
      FIELD3(FieldTypePointer,RX_CONTEXT,AcquireReleaseFcbTrackerX),
#endif
      FIELD3(FieldTypePointer,RX_CONTEXT,MRxContext[2]),
      FIELD3(FieldTypeSymbol,RX_CONTEXT,ResumeRoutine),
      FIELD3(FieldTypePointer,RX_CONTEXT,RealDevice),
      FIELD3(FieldTypeULongFlags,RX_CONTEXT,Flags),
      FIELD3(FieldTypeChar,RX_CONTEXT,MajorFunction),
      FIELD3(FieldTypeChar,RX_CONTEXT,MinorFunction),
      FIELD3(FieldTypeULong,RX_CONTEXT,StoredStatus),
      FIELD3(FieldTypeStruct,RX_CONTEXT,SyncEvent),
      FIELD3(FieldTypeStruct,RX_CONTEXT,RxContextSerializationQLinks),
      FIELD3(FieldTypeStruct,RX_CONTEXT,Create),
      FIELD3(FieldTypeStruct,RX_CONTEXT,LowIoContext),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.NetNamePrefixEntry),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvCall),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pNetRoot),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pVNetRoot),
      //FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvOpen),
      0
   };

/*
 * SRV_CALL debugging.
 *
 */

//CODE.IMPROVEMENT we should have a fieldtype for prefixentry that
//                 will print out the names

FIELD_DESCRIPTOR SrvCallFields[] =
   {
      FIELD3(FieldTypeUShort,SRV_CALL,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_CALL,NodeByteSize),
      FIELD3(FieldTypeStruct,SRV_CALL,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,SRV_CALL,PrefixEntry.Prefix),
      FIELD3(FieldTypePointer,SRV_CALL,Context),
      FIELD3(FieldTypePointer,SRV_CALL,Context2),
      FIELD3(FieldTypeULong,SRV_CALL,Flags),
      0
   };

/*
 * NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR NetRootFields[] =
   {
      FIELD3(FieldTypeUShort,NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeStruct,NET_ROOT,FcbTable),
      //FIELD3(FieldTypePointer,NET_ROOT,Dispatch),
      FIELD3(FieldTypePointer,NET_ROOT,Context),
      FIELD3(FieldTypePointer,NET_ROOT,Context2),
      FIELD3(FieldTypePointer,NET_ROOT,SrvCall),
      FIELD3(FieldTypeULong,NET_ROOT,Flags),
      0
   };


/*
 * V_NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR VNetRootFields[] =
   {
      FIELD3(FieldTypeUShort,V_NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,V_NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,V_NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,V_NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,NamePrefix),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context2),
      FIELD3(FieldTypePointer,V_NET_ROOT,NetRoot),
      0
   };


/*
 * FCB debugging.
 *
 */

FIELD_DESCRIPTOR FcbFields[] =
   {
      FIELD3(FieldTypeUShort,FCB,Header.NodeTypeCode),
      FIELD3(FieldTypeShort,FCB,Header.NodeByteSize),
      FIELD3(FieldTypeULong,FCB,NodeReferenceCount),
      FIELD3(FieldTypeULong,FCB,FcbState),
      FIELD3(FieldTypeULong,FCB,OpenCount),
      FIELD3(FieldTypeULong,FCB,UncleanCount),
      FIELD3(FieldTypePointer,FCB,Header.Resource),
      FIELD3(FieldTypePointer,FCB,Header.PagingIoResource),
      FIELD3(FieldTypeStruct,FCB,FcbTableEntry),
      FIELD3(FieldTypeUnicodeString,FCB,PrivateAlreadyPrefixedName),
      FIELD3(FieldTypePointer,FCB,VNetRoot),
      FIELD3(FieldTypePointer,FCB,NetRoot),
      FIELD3(FieldTypePointer,FCB,Context),
      FIELD3(FieldTypePointer,FCB,Context2),
      FIELD3(FieldTypeStruct,FCB,SrvOpenList),
      0
   };

FIELD_DESCRIPTOR FcbTableEntry[]=
   {

    FIELD3(FieldTypeUShort,RX_FCB_TABLE_ENTRY,NodeTypeCode),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE_ENTRY,NodeByteSize),
    FIELD3(FieldTypeULong, RX_FCB_TABLE_ENTRY,HashValue),
    FIELD3(FieldTypeUnicodeString,RX_FCB_TABLE_ENTRY,Path),
    FIELD3(FieldTypeULong,RX_FCB_TABLE_ENTRY,HashLinks),
    FIELD3(FieldTypeLong,RX_FCB_TABLE_ENTRY,Lookups),
    0
   };

FIELD_DESCRIPTOR FcbTable[] =
   {

    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NodeTypeCode),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NodeByteSize),
    FIELD3(FieldTypeULong,RX_FCB_TABLE,Version),
    FIELD3(FieldTypeBoolean,RX_FCB_TABLE,CaseInsensitiveMatch),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NumberOfBuckets),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,Lookups),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,FailedLookups),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,Compares),
    FIELD3(FieldTypePointer,RX_FCB_TABLE,pTableEntryForNull),
    FIELD3(FieldTypePointer,RX_FCB_TABLE,HashBuckets),
    0
   };

/*
 * SRV_OPEN debugging.
 *
 */

FIELD_DESCRIPTOR SrvOpenFields[] =
   {
      FIELD3(FieldTypeShort,SRV_OPEN,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_OPEN,NodeByteSize),
      FIELD3(FieldTypeULong,SRV_OPEN,NodeReferenceCount),
      FIELD3(FieldTypePointer,SRV_OPEN,Fcb),
      FIELD3(FieldTypeULong,SRV_OPEN,Flags),
      0
   };


/*
 * FOBX debugging.
 *
 */

FIELD_DESCRIPTOR FobxFields[] =
   {
      FIELD3(FieldTypeShort,FOBX,NodeTypeCode),
      FIELD3(FieldTypeShort,FOBX,NodeByteSize),
      FIELD3(FieldTypeULong,FOBX,NodeReferenceCount),
      FIELD3(FieldTypePointer,FOBX,SrvOpen),
      0
   };



#define SMBCE_ENTRY_FIELDS(__TYPE__) \
      FIELD3(FieldTypeULong,__TYPE__,Header.SwizzleCount),    \
      FIELD3(FieldTypeChar,__TYPE__,Header.Flags),    \
      FIELD3(FieldTypeLong,__TYPE__,Header.State),



FIELD_DESCRIPTOR ServerEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_SERVER_ENTRY)
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,Name),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,DomainName),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,Sessions),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,NetRoots),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,VNetRootContexts),
        FIELD3(FieldTypePointer,SMBCEDB_SERVER_ENTRY,pTransport),
        FIELD3(FieldTypeULong,SMBCEDB_SERVER_ENTRY,ServerStatus),
        FIELD3(FieldTypePointer,SMBCEDB_SERVER_ENTRY,pMidAtlas),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,Server),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,DfsRootName),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,DnsName),
        0
    };

FIELD_DESCRIPTOR SessionEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_SESSION_ENTRY)
        FIELD3(FieldTypePointer,SMBCEDB_SESSION_ENTRY,pServerEntry),
        FIELD3(FieldTypePointer,SMBCEDB_SESSION_ENTRY,pServerEntry),
        FIELD3(FieldTypeStruct,SMBCEDB_SESSION_ENTRY,Session),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SESSION_ENTRY,pNetRootName),
        0
    };

FIELD_DESCRIPTOR NetRootEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_NET_ROOT_ENTRY)
        FIELD3(FieldTypeUnicodeString,SMBCEDB_NET_ROOT_ENTRY,Name),
        FIELD3(FieldTypePointer,SMBCEDB_NET_ROOT_ENTRY,pServerEntry),
        FIELD3(FieldTypePointer,SMBCEDB_NET_ROOT_ENTRY,pRdbssNetRoot),
        FIELD3(FieldTypeStruct,SMBCEDB_NET_ROOT_ENTRY,NetRoot),
        FIELD3(FieldTypeBoolean,SMBCEDB_NET_ROOT_ENTRY,NetRoot.DfsAware),
        FIELD3(FieldTypeULong,SMBCEDB_NET_ROOT_ENTRY,NetRoot.sCscRootInfo.hShare),
        FIELD3(FieldTypeULong,SMBCEDB_NET_ROOT_ENTRY,NetRoot.sCscRootInfo.hRootDir),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.CscEnabled),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.CscShadowable),
        FIELD3(FieldTypeBoolean,SMBCEDB_NET_ROOT_ENTRY,NetRoot.Disconnected),
        0
    };

FIELD_DESCRIPTOR VNetRootContextFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCE_V_NET_ROOT_CONTEXT)
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pRdbssVNetRoot),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pServerEntry),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pSessionEntry),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pNetRootEntry),
        FIELD3(FieldTypeUShort,SMBCE_V_NET_ROOT_CONTEXT,Flags),
        FIELD3(FieldTypeULong,SMBCE_V_NET_ROOT_CONTEXT,TreeId),
        0
    };

FIELD_DESCRIPTOR ServerTransportFields[] =
    {
        FIELD3(FieldTypePointer,SMBCE_SERVER_TRANSPORT,pDispatchVector),
        FIELD3(FieldTypePointer,SMBCE_SERVER_TRANSPORT,pTransport),
        FIELD3(FieldTypeULong,SMBCE_SERVER_TRANSPORT,MaximumSendSize),
        0
    };

FIELD_DESCRIPTOR TransportFields[] =
    {
        FIELD3(FieldTypeStruct,SMBCE_TRANSPORT,RxCeTransport),
        FIELD3(FieldTypeStruct,SMBCE_TRANSPORT,RxCeAddress),
        FIELD3(FieldTypeULong,SMBCE_TRANSPORT,Priority),
        0
    };

#define EXCHANGE_FIELDS(__TYPE__) \
      FIELD3(FieldTypePointer,__TYPE__,RxContext),  \
      FIELD3(FieldTypePointer,__TYPE__,SmbCeContext.pServerEntry),  \
      FIELD3(FieldTypeULong,__TYPE__,Status),       \
      FIELD3(FieldTypeULong,__TYPE__,SmbStatus),    \
      FIELD3(FieldTypeUShort,__TYPE__,SmbCeState),    \
      FIELD3(FieldTypeULong,__TYPE__,SmbCeFlags),   \
      FIELD3(FieldTypeStruct,__TYPE__,WorkQueueItem),



FIELD_DESCRIPTOR OrdinaryExchangeFields[] =
   {
      EXCHANGE_FIELDS(SMB_PSE_ORDINARY_EXCHANGE)
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,StufferStateDbgPtr),
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,DataPartialMdl),
      FIELD3(FieldTypeChar,SMB_PSE_ORDINARY_EXCHANGE,OpSpecificFlags),
      FIELD3(FieldTypeChar,SMB_PSE_ORDINARY_EXCHANGE,OpSpecificState),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,ParseResumeState),
      FIELD3(FieldTypeUShortFlags,SMB_PSE_ORDINARY_EXCHANGE,Flags),
      FIELD3(FieldTypeULong,SMB_PSE_ORDINARY_EXCHANGE,MessageLength),
      FIELD3(FieldTypeSymbol,SMB_PSE_ORDINARY_EXCHANGE,ContinuationRoutine),
      FIELD3(FieldTypeULong,SMB_PSE_ORDINARY_EXCHANGE,StartEntryCount),
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,AsyncResumptionRoutine),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,ReadWrite),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,AssociatedStufferState),
      0
   };

FIELD_DESCRIPTOR TransactExchangeFields[] =
   {
      EXCHANGE_FIELDS(SMB_TRANSACT_EXCHANGE)
      0
   };

typedef struct _ZZEXCHANGE {
    SMB_EXCHANGE;
} ZZEXCHANGE, *PZZEXCHANGE;

FIELD_DESCRIPTOR GeneralExchangeFields[] =
   {
      EXCHANGE_FIELDS(ZZEXCHANGE)
      0
   };


typedef struct _ZZSMB_HEADER {
    union {
        SMB_HEADER;
        NT_SMB_HEADER Nt;
    };
} ZZSMB_HEADER, *PZZSMB_HEADER;

FIELD_DESCRIPTOR SmbHeaderFields[] =
   {
      FIELD3(FieldTypeByte,ZZSMB_HEADER,Command),
      FIELD3(FieldTypeByte,ZZSMB_HEADER,ErrorClass),
      FIELD3(FieldTypeUShortUnaligned,ZZSMB_HEADER,Error),
      FIELD3(FieldTypeULongUnaligned,ZZSMB_HEADER,Nt.Status.NtStatus),
      FIELD3(FieldTypeByte,ZZSMB_HEADER,Flags),
      FIELD3(FieldTypeUShortUnaligned,ZZSMB_HEADER,Flags2),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,PidHigh),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Pid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Tid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Uid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Mid),
      0
   };

FIELD_DESCRIPTOR StufferStateFields[] =
   {
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,SpecificProblem),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,RxContext),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,Exchange),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,HeaderMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,HeaderPartialMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,ActualBufferBase),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,BufferBase),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,BufferLimit),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,DataMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentPosition),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentWct),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentBcc),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentDataOffset),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,PreviousCommand),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,CurrentCommand),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,FlagsCopy),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,Flags2Copy),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,DataSize),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,Started),
      0
   };


FIELD_DESCRIPTOR IrpList[] =
   {
      FIELD3(FieldTypePointer,RX_IRP_LIST_ITEM,pIrp),
      FIELD3(FieldTypePointer,RX_IRP_LIST_ITEM,CopyDataBuffer),
      FIELD3(FieldTypeULong,RX_IRP_LIST_ITEM,Completed),
      0
   };

//this enum is used in the definition of the structures that can be dumped....the order here
//is not important, only that there is a definition for each dumpee structure.....

typedef enum _STRUCTURE_IDS {
    StrEnum_RX_CONTEXT = 1,
    StrEnum_FCB,
    StrEnum_SRV_OPEN,
    StrEnum_FOBX,
    StrEnum_SRV_CALL,
    StrEnum_NET_ROOT,
    StrEnum_V_NET_ROOT,
    StrEnum_SMBCEDB_SERVER_ENTRY,
    StrEnum_SMBCEDB_SESSION_ENTRY,
    StrEnum_SMBCEDB_NET_ROOT_ENTRY,
    StrEnum_SMBCE_V_NET_ROOT_CONTEXT,
    StrEnum_SMB_PSE_ORDINARY_EXCHANGE,
    StrEnum_SMB_TRANSACT_EXCHANGE,
    StrEnum_ZZEXCHANGE,
    StrEnum_SMBSTUFFER_BUFFER_STATE,
    StrEnum_SMBCE_TRANSPORT,
    StrEnum_SMBCE_SERVER_TRANSPORT,
    StrEnum_ZZSMB_HEADER,
    StrEnum_RX_FCB_TABLE_ENTRY,
    StrEnum_RX_FCB_TABLE,
    StrEnum_RX_IRP_LIST_ITEM,
    StrEnum_last
};


//
// List of structs currently handled by the debugger extensions
//

STRUCT_DESCRIPTOR Structs[] =
   {
       STRUCT(RX_CONTEXT,RxContextFields,0xffff,RDBSS_NTC_RX_CONTEXT),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0)),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0xf0)),
       STRUCT(SRV_OPEN,SrvOpenFields,0xffff,RDBSS_NTC_SRVOPEN),
       STRUCT(FOBX,FobxFields,0xffff,RDBSS_NTC_FOBX),
       STRUCT(SRV_CALL,SrvCallFields,0xffff,RDBSS_NTC_SRVCALL),
       STRUCT(NET_ROOT,NetRootFields,0xffff,RDBSS_NTC_NETROOT),
       STRUCT(V_NET_ROOT,VNetRootFields,0xffff,RDBSS_NTC_V_NETROOT),
       STRUCT(SMBCEDB_SERVER_ENTRY,ServerEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SERVER)),
       STRUCT(SMBCEDB_SESSION_ENTRY,SessionEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SESSION)),
       STRUCT(SMBCEDB_NET_ROOT_ENTRY,NetRootEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_NETROOT)),
       STRUCT(SMBCE_V_NET_ROOT_CONTEXT,VNetRootContextFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_VNETROOTCONTEXT)),
       STRUCT(SMB_PSE_ORDINARY_EXCHANGE,OrdinaryExchangeFields,0xffff,SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE)),
       STRUCT(SMB_TRANSACT_EXCHANGE,TransactExchangeFields,0xffff,SMB_EXCHANGE_NTC(TRANSACT_EXCHANGE)),
       STRUCT(ZZEXCHANGE,GeneralExchangeFields,0xfff0,SMB_EXCHANGE_NTC(0)),
       STRUCT(SMBSTUFFER_BUFFER_STATE,StufferStateFields,0xffff,SMB_NTC_STUFFERSTATE),
       STRUCT(SMBCE_TRANSPORT,TransportFields,0x0,0xffff),
       STRUCT(SMBCE_SERVER_TRANSPORT,ServerTransportFields,0x0,0xffff),
       STRUCT(ZZSMB_HEADER,SmbHeaderFields,0x0,0xffff),
       STRUCT(RX_FCB_TABLE_ENTRY,FcbTableEntry,0xffff,RDBSS_NTC_FCB_TABLE_ENTRY),
       STRUCT(RX_FCB_TABLE,FcbTable,0xffff,RDBSS_NTC_FCB_TABLE),
       STRUCT(RX_IRP_LIST_ITEM,IrpList,0x0,0xffff),
       0
   };


ULONG_PTR FieldOffsetOfContextListEntryInRxC(){ return FIELD_OFFSET(RX_CONTEXT,ContextListEntry);}


PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture){
    switch (DebugeeArchitecture) {
    case RX_PROCESSOR_ARCHITECTURE_INTEL:
        return L"kdextx86.dll";
    case RX_PROCESSOR_ARCHITECTURE_MIPS:
        return L"kdextmip.dll";
    case RX_PROCESSOR_ARCHITECTURE_ALPHA:
        return L"kdextalp.dll";
    case RX_PROCESSOR_ARCHITECTURE_PPC:
        return L"kdextppc.dll";
    default:
        return(NULL);
    }
}

//CODE.IMPROVEMENT it is poor to try to structure along the lines of "this routine knows
//                 rxstructures" versus "this routine knows debugger extensions". also we
//                 need a precomp.h

BOOLEAN wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2)
{
    RX_CONTEXT RxContextBuffer;
    if (!wGetData(RxContext,&RxContextBuffer,sizeof(RxContextBuffer),"RxContextFieldss")) return;
    *pFcb = (ULONG_PTR)(RxContextBuffer.pFcb);
    *pThread = (ULONG_PTR)(RxContextBuffer.LastExecutionThread);
    *pMiniCtx2 = (ULONG_PTR)(RxContextBuffer.MRxContext[2]);
}


FOLLOWON_HELPER_RETURNS
__FollowOnError (
    OUT    PBYTE Buffer2,
    IN     PBYTE followontext,
    ULONG LastId,
    ULONG Index)
{
    if (LastId==0) {
        sprintf(Buffer2,"Cant dump a %s. no previous dump.\n",
                 followontext,Index);
    } else {
        sprintf(Buffer2,"Cant dump a %s from a %s\n",
                 followontext,Structs[Index].StructName);
    }
    return(FOLLOWONHELPER_ERROR);
}
#define FollowOnError(A) (__FollowOnError(Buffer2,A,p->IdOfLastDump,p->IndexOfLastDump))

VOID dprintfsprintfbuffer(BYTE *Buffer);


DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn)
{
    //BYTE DbgBuf[200];
    //sprintf(DbgBuf,"top p,id=%08lx,%d",p,p->IdOfLastDump);
    //dprintfsprintfbuffer(DbgBuf);

    switch (p->IdOfLastDump) {
    case StrEnum_RX_CONTEXT:{
        PRX_CONTEXT RxContext = (PRX_CONTEXT)(&p->StructDumpBuffer[0]);
        sprintf(Buffer2," %08p\n",RxContext->pFcb);
        return(FOLLOWONHELPER_DUMP);
        }
        break;
    default:
        return FollowOnError("irp");
    }
}

VOID
DumpList(
    ULONG_PTR dwListEntryAddress,
    DWORD linkOffset,
    VOID (*dumpRoutine)(ULONG_PTR dwStructAddress, STRUCT_DESCRIPTOR *pStruct),
    STRUCT_DESCRIPTOR *pStruct
)
{
    LIST_ENTRY listHead, listNext;

    //
    // Get the value in the LIST_ENTRY at dwAddress
    //

    MyDprintf( "Dumping list @ %08lx\n", dwListEntryAddress );

    if (wGetData(dwListEntryAddress, &listHead, sizeof(LIST_ENTRY),"")) {

        ULONG_PTR dwNextLink = (ULONG_PTR) listHead.Flink;

        if (dwNextLink == 0) {
            MyDprintf( "Uninitialized list!\n", 0 );
        } else if (dwNextLink == dwListEntryAddress) {
            MyDprintf( "Empty list!\n", 0);
        } else {
            while( dwNextLink != dwListEntryAddress) {
                ULONG_PTR dwStructAddress;

                if (MyCheckControlC())
                    return;
                dwStructAddress = dwNextLink - linkOffset;

                dumpRoutine(dwStructAddress, pStruct);

                if (wGetData( dwNextLink, &listNext, sizeof(LIST_ENTRY),"")) {
                    dwNextLink = (ULONG_PTR) listNext.Flink;
                } else {
                    MyDprintf( "Unable to get next item @%08lx\n", dwNextLink );
                    break;
                }

            }
        }

    } else {

        MyDprintf("Unable to read list head @ %08lx\n", dwListEntryAddress);

    }

}

//
// All the DoXXXlist routines could be collapsed into one routine, but I
// have left them separate in case future changes are structure-specific.
//


VOID
DoServerlist(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("SMBCEDB_SERVER_ENTRY", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(SMBCEDB_SERVER_ENTRY, ServersList),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoNetRootlist(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("SMBCEDB_NET_ROOT_ENTRY", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(SMBCEDB_NET_ROOT_ENTRY, NetRootsList),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoSessionlist(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("SMBCEDB_SESSION_ENTRY", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(SMBCEDB_SESSION_ENTRY, SessionsList),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoVNetRootContextlist(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("SMBCE_V_NET_ROOT_CONTEXT", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(SMBCE_V_NET_ROOT_CONTEXT, ListEntry),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoCscFcbsList(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("FCB", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(MRX_SMB_FCB, ShadowReverseTranslationLinks),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoRxIrpsList(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("RX_IRP_LIST_ITEM", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(RX_IRP_LIST_ITEM, IrpsList),
        DumpAStruct,
        &Structs[i]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdr2kd\wdbgxlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    wdbgxlib.c

Abstract:

    This module realizes most of the routines needed for the rdbss/smbmini debugger extension.

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created
    11-Nov-1995         Changed to newer windbg apis

--*/

#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <rdr2kd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>


WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?

VOID
DoServerlist(ULONG_PTR);

VOID
DoNetRootlist(ULONG_PTR);

VOID
DoSessionlist(ULONG_PTR);

VOID
DoVNetRootContextlist(ULONG_PTR);

VOID
DoCscFcbsList(ULONG_PTR dwAddress);

VOID
DoRxIrpsList(ULONG_PTR dwAddress);

/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Fetches the data at the given address
 */
BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = ReadMemory( dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
wGetString( ULONG_PTR dwAddress, PSZ buf )
{
    for(;;) {
        if( !wGetData( dwAddress,buf, 1, "..stringfetch") ){
            //dprintf("readfailure at %08lx\n",dwAddress);
            return FALSE;
        }

        //dprintf ("stringing %08lx %08lx %c\n", dwAddress, buf,
        //                                     ((*buf==0)?'.':*buf) );

        if ( *buf == '\0' ) { break; }

        dwAddress++;
        buf++;

    };

    return TRUE;
}

#if 0
/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
wGetData_srv( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = min( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !wGetData_srv( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !wGetData_srv( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}
#endif

/*
 * Print out a single HEX character
 */
VOID
wPrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
wPrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        wPrintHexChar( *buf++ );
        dprintf( " " );
    }
}

#if 0
/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !wGetData_srv( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}
#endif

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s RDBSS+SMBmini Extension dll for Build %d debugging %s kernel for Build %d\n",
                    kind,
                    VER_PRODUCTBUILD,
                    SavedMajorVersion == 0x0c ? "Checked" : "Free",
                    SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

LPSTR LibCommands[] = {
    "dump <Struct Type Name>@<address expr> ",
    "ddd <address expr> -- dump using context"
    "columns <d> -- controls the number of columns in the display ",
    "lg [<logentries>][@filename] -- dump the log",
    "gv -- dump out important variables",
    "activerx [fcbtomatch]-- dump the list of active contexts",
    "flags <value>-- print which flags are actually set (no text yet)",
    "cxr -- looks up cxr value from memory and does !cxr/!kb",
    "irp,thread,fcb,fobx,srvopen,exchange,stuff,smbbuf -- dumps the named item from the last dumpee",
    "version",
    "serverlist -- dump the list of server entries",
    "netrootlist <address expr> -- dump the netroot entries on a list",
    "sessionlist <address expr> -- dump the session entries on a list",
    "vnetrootcontextlist <address expr> -- dump the vnetroot context entries on a list",
    "cscfcbslist -- dump the csc fcb list",
    "rxirpslist -- dump the irps waiting on transports",
    0
};

DECLARE_API( help )
{
    int i;

    dprintf( "\nRDBSS debugger extensions:\n");

    for( i=0; LibCommands[i]; i++ )
        dprintf( "   %s\n", LibCommands[i] );
}


ULONG FieldOffsetOfContextListEntryInRxC();
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2);
DECLARE_API( dump );
DECLARE_API( activerx )
{
    //ULONG dwAddress;
    LIST_ENTRY LEbuffer;
    PLIST_ENTRY pRxActiveContexts,pListEntry;
    ULONG_PTR RxContext,CapturedFcb,LastThread,MinirdrCtx2;
    ULONG_PTR MatchFcb = 0x1badf00d;

    pRxActiveContexts = pListEntry = (PLIST_ENTRY)GetExpression("rdbss!RxActiveContexts");

    if( args && *args ) {
        MatchFcb = GetExpression( args );
    }

    dprintf("\n Firstplentry: %08lx\n", pListEntry);

    for (;;) {
        if (!wGetData((ULONG_PTR)pListEntry,&LEbuffer,sizeof(LEbuffer),"RxActiveContexts")) return;
        if (LEbuffer.Flink == pRxActiveContexts) {
            if (pRxActiveContexts == pListEntry){
                dprintf("Active RxContext List Empty!\n");
            }
            return;
        }
        RxContext = ((ULONG_PTR)LEbuffer.Flink)-FieldOffsetOfContextListEntryInRxC();
        CapturedFcb = LastThread = 0x0badf00d;
        ReadRxContextFields(RxContext,&CapturedFcb,&LastThread,&MinirdrCtx2);
        if (MatchFcb == 0x1badf00d) {
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
        } else if ((MatchFcb == CapturedFcb)
                         || (MatchFcb == LastThread) ) {
            // if a matchfcb is specified and we have a match, the print and dump
            char Bufferqq[100];
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
            sprintf(Bufferqq," %08lx ",RxContext);
            dump( hCurrentProcess,
                  hCurrentThread,
                  dwCurrentPc,
                  dwProcessor,
                  Bufferqq
                  );

        }
        pListEntry = LEbuffer.Flink;
    }
}


#define GV_dprintf(__FORMAT__,__NAME__,__VALUE__) { \
        dprintf( "%s%-30s %08lx " __FORMAT__ "%s",  \
            c&1 ? "    " : "",                      \
            __NAME__,                               \
            dwAddress,                              \
            __VALUE__,                              \
            c&1 ? "\n" : "" );                      \
}
DECLARE_API( gv )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 100 ];
    int i;
    int c=0;

    //CODE.IMPROVEMENT maybe we should hallucinate the moduleprefix instead
    // of having to specify it
    //CODE.IMPROVEMENT if we're not doing that, we shouldn't copy the name!

    //cause stuff to be loaded before we start printing
    dwAddress = GetExpression( "rdbss!RxExpCXR" );
    dwAddress = GetExpression( "mrxsmb!SmbMmExchangesInUse" );

    for( i=0; GlobalBool[i]; i++, c++ ) {
        BOOL b;

        strcpy( &buf[0], GlobalBool[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalBool[i] );
            continue;
        }
        if( !wGetData( dwAddress,&b, sizeof(b), "global BOOL") ) continue;

        GV_dprintf("%10s",GlobalBool[i],(b ? " TRUE" : "FALSE"));
    }

    for( i=0; GlobalShort[i]; i++, c++ ) {
        SHORT s;

        strcpy( &buf[0], GlobalShort[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalShort[i] );
            continue;
        }
        if( !wGetData( dwAddress,&s,sizeof(s), "global SHORT") )  continue;

        GV_dprintf("%10d",GlobalShort[i],s);
    }

    for( i=0; GlobalLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[0], GlobalLong[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalLong[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global LONG") )  continue;

        GV_dprintf("%10d",GlobalLong[i],l);
    }

    for( i=0; GlobalPtrs[i]; i++, c++ ) {
        LONG l;

        //ERRPRT( "zaaaaa %s\n", GlobalPtrs[i] );
        strcpy( &buf[0], GlobalPtrs[i] );
        dwAddress = GetExpression( buf );
        //ERRPRT( "zbbbbb %s %08lx\n", GlobalPtrs[i], dwAddress );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalPtrs[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global PTR") )  continue;
        //ERRPRT( "zccccc %s %08lx\n", GlobalPtrs[i], dwAddress );

        GV_dprintf("  %08lx",GlobalPtrs[i],l);
    }

    dprintf( "\n" );
}



HANDLE DumpFile;
CHAR wwDumpFormat[] = "-%06d:  %s\n";
VOID DumpRoutine(
    ULONG EntryNumber,
    PSZ   OriginalStringToPrint
    )
{
    UCHAR Buffer[200];
    UCHAR StringToPrint[160];
    PUCHAR p,q,r; LONG i;
    ULONG n,l3,l2,l1,l0; UCHAR Numbuf[32];
    ULONG ReturnedSize;

    //dprintf("before %d\n",EntryNumber);
    for (p=OriginalStringToPrint,q=StringToPrint,i=160;;) {
        PSZ format=NULL;

        if (*p==0) break;

        if (*p==0x4) {
            format = "%lx";
        } else if (*p==0x5) {
            format = "%ld";
        } else if (*p < ' ') {
            p++;i--;continue;
        }

        if (format!=NULL) {
            LONG Length;
            //translate the number
            p++;
            l0=*p++;
            l1=(*p++)<<8;
            l2=(*p++)<<16;
            l3=(*p++)<<24;
            n = l0 + l1 + l2 + l3;
            //dprintf("yaya %d %08lx %08lx %08lx %08lx %08lx\n",n,n,l0,l1,l2,l3);
            Length = sprintf(Numbuf,format,n);
            if (Length <= i) {
                for (r=Numbuf;*r;) { *q++ = *r++; }
                i -= Length;
            } else {
                i = 0;
            }
            if (i>0) continue;
        }
        if (i<=0) break;
        *q++ = *p++; i--;
    }
    *q = 0;

    //dprintf("after %d\n",EntryNumber);
    if (DumpFile == INVALID_HANDLE_VALUE) {
        dprintf(wwDumpFormat,EntryNumber,StringToPrint);
        return;
    }
    sprintf(Buffer,wwDumpFormat,EntryNumber,StringToPrint);
    WriteFile(DumpFile,Buffer,strlen(Buffer),&ReturnedSize,NULL);
    //should i check??
    return;
}


DECLARE_API( lg )
{
    ULONG_PTR dwAddress;
    BYTE DataBuffer[MAX_RX_LOG_ENTRY_SIZE];
    BYTE AlternateLine[110];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    BOOLEAN LogEntriesSpecified = FALSE;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();
    dwAddress = GetExpression("rdbss!s_RxLog");
    if (!wGetData(dwAddress,&RxLog,sizeof(RX_LOG),"RxLog")) return;


    DumpFile = INVALID_HANDLE_VALUE;
    if( args && *args ) {
        LPSTR lpArgs;
        for (;*args;) {
            if (*args=='@') { break;}
            if ((*args>='0') && (*args<='9')) {
                sscanf(args,"%ld",&LogEntries);
                LogEntriesSpecified = TRUE;
                break;
            }
            args++;
        }
        lpArgs = strpbrk(args, "@");
        if (lpArgs) {
            DumpFile = CreateFileA(lpArgs+1,
                       GENERIC_READ|GENERIC_WRITE,0,
                       NULL,
                       CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
            if (DumpFile == INVALID_HANDLE_VALUE){
                ULONG rc = LOWORD(GetLastError());
                dprintf("Error Opening <%s> is %d.",lpArgs+1,rc);
                return;
            }
            if (!LogEntriesSpecified) {
                LogEntries = 99999999; //this will be reset to the right size
            }
        }
    }


    // Dump the log header followed by the log entries ...

    dprintf("s_RxLog.State                    %lx\n",RxLog.State);
    dprintf("s_RxLog.CurrentEntry             %lx\n",RxLog.CurrentEntry);
    dprintf("s_RxLog.BaseEntry                %lx\n",RxLog.BaseEntry);
    dprintf("s_RxLog.EntryLimit               %lx\n",RxLog.EntryLimit);
    dprintf("s_RxLog.LogBufferSizeInEntries   %ld\n",RxLog.LogBufferSizeInEntries);
    dprintf("s_RxLog.NumberOfEntriesIgnored   %ld\n",RxLog.NumberOfEntriesIgnored);
    dprintf("s_RxLog.NumberOfLogWriteAttempts %ld\n",RxLog.NumberOfLogWriteAttempts);
    dprintf("s_RxLog.NumberOfLogWraps         %ld\n",RxLog.NumberOfLogWraps);

    if (LogEntries > RxLog.LogBufferSizeInEntries) {
        LogEntries = RxLog.LogBufferSizeInEntries;
    }
    if (LogEntries < 1) {
        LogEntries = 1;
    }

    CurrentEntry = RxLog.CurrentEntry;
    CurrentEntry -= (LogEntries-1);
    if (CurrentEntry < RxLog.BaseEntry) {
        CurrentEntry += (RxLog.EntryLimit - RxLog.BaseEntry);
    }

    for (;;) {
        ULONG TextPtr;
        BOOLEAN ExtraOrdinaryLogEntry;
        LogEntries--;
        if ( CheckControlC() ) {
            return;
        }
        if (!wGetData((ULONG_PTR)CurrentEntry,&TextPtr,sizeof(TextPtr),"TextPtr")) return;
        if (!wGetData(TextPtr,&DataBuffer[0],sizeof(DataBuffer),"LogEntryBuffer")) return;

        ExtraOrdinaryLogEntry = (DataBuffer[0] == '#')&&(DataBuffer[1] == '>')&&(DataBuffer[3] == 0);

        if (!ExtraOrdinaryLogEntry) {
            //dprintf("-%06d:  %s\n",LogEntries,DataBuffer);
            DumpRoutine(LogEntries,DataBuffer);
        } else {
            ULONG BinaryArgs = DataBuffer[2]-'0';
            PULONG_PTR x = (PULONG_PTR)&DataBuffer[sizeof(ULONG_PTR)];
            char Buffers[12*100]; //CODE.IMPROVEMENT this is poor but effective
            ULONG i;
            ULONG_PTR BinaryStringMask;
            PSZ ffFormat;

            //dprintf("textptr = %08lx, binaryString = %08lx\n", TextPtr, x[0]);
            for (i=1,BinaryStringMask=x[0];i<=BinaryArgs;i++) {
                if (BinaryStringMask & (1<<(i-1))) {
                    //dprintf("Stringing %d\n",i);
                    wGetString(x[i],&Buffers[i*100]); //this could fail!!!!
                    x[i] = ((ULONG_PTR)&Buffers[i*100]);
                    //dprintf("    string is %s\n",x[i]);
                }
            }

            ffFormat = (PSZ)(x[1]);

            switch (BinaryArgs) {
            case 9:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9]);
                break;
            case 8:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8]);
                break;
            case 7:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7]);
                break;
            case 6:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6]);
                break;
            case 5:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5]);
                break;
            case 4:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4]);
                break;
            case 3:
                sprintf(AlternateLine,ffFormat,x[2],x[3]);
                break;
            case 2:
                sprintf(AlternateLine,ffFormat,x[2]);
                break;
            case 1:
                sprintf(AlternateLine,ffFormat);
                break;
            }
            DumpRoutine(LogEntries,AlternateLine);
        }
        if (LogEntries==0) break;
        CurrentEntry++;
        if (CurrentEntry==RxLog.EntryLimit) {
            CurrentEntry = RxLog.BaseEntry;
        }
    }

    if (DumpFile != INVALID_HANDLE_VALUE) {
        CloseHandle(DumpFile);
        DumpFile = INVALID_HANDLE_VALUE;
    }
}


PCWSTR   ExtensionLib   = NULL;
HANDLE   hExtensionMod  = NULL;
ULONG    DebugeeArchitecture = 0;

PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture);

PWINDBG_EXTENSION_ROUTINE
GetKdExtProcAddress(
    IN PCSTR FuncName
    )
{
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = NULL;
    //dprintf( "yaya\n");
    if (hExtensionMod == NULL) {
        if (DebugeeArchitecture == 0) {
            ULONG_PTR pArchitecture;
            ReloadSymbols(" rdbss.sys");
            pArchitecture = GetExpression("rdbss!RxProcessorArchitecture");
            if (pArchitecture==0) {
                dprintf("couldn't get architecture value...\n");
                return NULL;
            }
            if (!wGetData(pArchitecture,&DebugeeArchitecture,sizeof(DebugeeArchitecture),"RxArch")) return NULL;
            if ((DebugeeArchitecture&0x0fff0000) != 0xabc0000) {
                dprintf("\n Bad DebugeeArchitecture %08lx\n", DebugeeArchitecture);
                return(NULL);
            }
            DebugeeArchitecture &= 0xffff;
        }

        ExtensionLib = GetExtensionLibPerDebugeeArchitecture(DebugeeArchitecture);
        if (ExtensionLib == NULL) {
            dprintf( "bad debuggee arch\n");
            return(NULL);
        }

        hExtensionMod = LoadLibrary( ExtensionLib );
        if (hExtensionMod == NULL) {
            dprintf( "couldn't load %ws\n", ExtensionLib );
            return(NULL);
        }

    }

    WindbgExtRoutine = (PWINDBG_EXTENSION_ROUTINE)GetProcAddress( hExtensionMod, FuncName );
    if (WindbgExtRoutine == NULL) {
        dprintf( "couldn't find %ws%s\n", ExtensionLib, FuncName );
    }
    return WindbgExtRoutine;
}

#define CALL_THRU(NAME,ARGS) { \
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = GetKdExtProcAddress(NAME); \
    if (WindbgExtRoutine != NULL) {                                                   \
        (WindbgExtRoutine)( hCurrentProcess,                                          \
                            hCurrentThread,                                           \
                            dwCurrentPc,                                              \
                            dwProcessor,                                              \
                            ARGS                                                      \
                            );                                                        \
    }                                                                                 \
}

DECLARE_API( testr )
{

    CALL_THRU ( "threadfields", "");
}

DECLARE_API( dump );
VOID
__FollowOnHelper (
     PFOLLOWON_HELPER_ROUTINE Callee,
     HANDLE                 hCurrentProcess,
     HANDLE                 hCurrentThread,
     ULONG                  dwCurrentPc,
     ULONG                  dwProcessor,
     PCSTR                  args
     )
{
    BYTE Name[100], Buffer2[200];
    FOLLOWON_HELPER_RETURNS ret;
    PPERSISTENT_RDR2KD_INFO p;

    p = LocatePersistentInfoFromView();

    if (!p) {
        dprintf("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    ret = Callee(p,Name,Buffer2);
    if (p!= NULL) FreePersistentInfoView(p);
    p = NULL;

    switch (ret) {

    case FOLLOWONHELPER_DUMP:
        dump(hCurrentProcess,
             hCurrentThread,
             dwCurrentPc,
             dwProcessor,
             Buffer2
             );
        break;

    case FOLLOWONHELPER_CALLTHRU:
        CALL_THRU ( Name, Buffer2);
        break;

    case FOLLOWONHELPER_ERROR:
        dprintf("%s",Buffer2);
        break;

    case FOLLOWONHELPER_DONE:
        break;
    }

    return;
}
#define FollowOnHelper(a) {            \
    __FollowOnHelper(a,                \
                     hCurrentProcess,  \
                     hCurrentThread,   \
                     dwCurrentPc,      \
                     dwProcessor,      \
                     args);            \
}

DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn);
DECLARE_API( fcb )
{
    FollowOnHelper(FcbFollowOn);
}


DECLARE_API( flags )
{
    ULONG i,mask,newline,value;

    if( args && *args ) {
        sscanf(args,"%lx",&value);
        dprintf("Flags for %08lx\n",value);
    } else {
        dprintf("error in flags: no value presented\n");
        return;
    }

    for (i=newline=0,mask=1;i<32;i++,mask<<=1) {
        if (value&mask) {
            dprintf("    %02d 0x%08lx%c",i,mask,(newline==0)?' ':'\n');
            newline ^= 1;
        }
    }
    if (newline) {
        dprintf("\n");
    }
}

DECLARE_API( cxr )
{
    ULONG_PTR dwAddress,cxr;
    BYTE NumBuffer[16];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();


    dwAddress = GetExpression("rdbss!RxExpCXR");
    if (!wGetData(dwAddress,&cxr,sizeof(cxr),"cxr")) return;

    dprintf("\nRxExpCXR=%08lx\n",cxr);
    sprintf(NumBuffer,"%08lx \n",cxr);

    CALL_THRU ( "cxr", NumBuffer);
    if (DebugeeArchitecture==0) {
        CALL_THRU ( "kb", "");
    }

}

DECLARE_API( serverlist )
{
    ULONG_PTR dwAddress;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dwAddress = GetExpression("mrxsmb!s_DbServers");
    }
    dprintf("mrxsmb!s_DbServers @ 0x%x\n", dwAddress);
    DoServerlist(dwAddress);
}

DECLARE_API( netrootlist )
{
    ULONG_PTR dwAddress;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dprintf("netrootlist <address>\n");
    }
    DoNetRootlist(dwAddress);
}

DECLARE_API( sessionlist )
{
    ULONG_PTR dwAddress = 0;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dprintf("sessionlist <address>\n");
    }
    
    if (dwAddress)
    {
        DoSessionlist(dwAddress);
    }
}

DECLARE_API( vnetrootcontextlist )
{
    ULONG_PTR dwAddress = 0;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dprintf("vnetrootcontextlist <address>\n");
    }
    if (dwAddress)
    {
        DoVNetRootContextlist(dwAddress);
    }
}

DECLARE_API( cscfcbslist )
{
    ULONG_PTR dwAddress;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dwAddress = GetExpression("mrxsmb!xCscFcbsList");
    }
    dprintf("mrxsmb!xCscFcbsList @ 0x%x\n", dwAddress);
    DoCscFcbsList(dwAddress);
}

DECLARE_API( rxirpslist )
{
    ULONG_PTR dwAddress;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dwAddress = GetExpression("rdbss!RxIrpsList");
    }
    dprintf("rdbss!RxIrpsList @ 0x%x\n", dwAddress);
    DoRxIrpsList(dwAddress);
}

VOID dprintfsprintfbuffer(BYTE *Buffer)
{
    dprintf("%s\n",Buffer);
}

ULONG_PTR
MyGetExpression(PCSTR Expression)
{
    return GetExpression(Expression);
}

ULONG
MyCheckControlC(VOID)
{
    return CheckControlC();
}

VOID
MyDprintf(PSTR s, ULONG_PTR a)
{
    dprintf(s, a);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\wrapper.sav\ntfsd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxInit.c

Abstract:

    This module implements the FSD-level dispatch routine for the RDBSS.

Author:

    Joe Linn [JoeLinn]    2-dec-1994

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs.h>
#include "NtDspVec.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DISPATCH)

// the difference between dispatch problem and unimplemented is my judgement as to whether
// this represents a likely application error or not. in a free build, there's no difference.

NTSTATUS
RxCommonDispatchProblem ( RXCOMMON_SIGNATURE );

NTSTATUS
RxCommonUnimplemented ( RXCOMMON_SIGNATURE );


RX_FSD_DISPATCH_VECTOR RxFsdDispatchVector[IRP_MJ_MAXIMUM_FUNCTION + 1] = {
           DISPVECENTRY_NEW(CREATE,                    TRUE,    Create, 0x10),                  // 0x00
           DISPVECENTRY_NEW(CREATE_NAMED_PIPE,         TRUE,    Unimplemented, 0x10),           // 0x01
           DISPVECENTRY_NEW(CLOSE,                     TRUE,    Close, 0x10),                   // 0x02
           DISPVECENTRY_NEW(READ,                      TRUE,    Read, 0x10),                    // 0x03
           DISPVECENTRY_NEW(WRITE,                     TRUE,    Write, 0x10),                   // 0x04
           DISPVECENTRY_NEW(QUERY_INFORMATION,         TRUE,    QueryInformation, 0x10),        // 0x05
           DISPVECENTRY_NEW(SET_INFORMATION,           TRUE,    SetInformation, 0x10),          // 0x06
           DISPVECENTRY_NEW(QUERY_EA,                  TRUE,    QueryEa, 0x10),                 // 0x07
           DISPVECENTRY_NEW(SET_EA,                    TRUE,    SetEa, 0x10),                   // 0x08
           DISPVECENTRY_NEW(FLUSH_BUFFERS,             TRUE,    FlushBuffers, 0x10),            // 0x09
           DISPVECENTRY_NEW(QUERY_VOLUME_INFORMATION,  TRUE,    QueryVolumeInformation, 0x10),  // 0x0a
           DISPVECENTRY_NEW(SET_VOLUME_INFORMATION,   FALSE,    SetVolumeInformation, 0x10),    // 0x0b   //BUGBUG
           DISPVECENTRY_NEW(DIRECTORY_CONTROL,         TRUE,    DirectoryControl, 0x10),        // 0x0c
           DISPVECENTRY_NEW(FILE_SYSTEM_CONTROL,       TRUE,    FileSystemControl, 0x10),       // 0x0d
           DISPVECENTRY_NEW(DEVICE_CONTROL,            TRUE,    DeviceControl, 0x10),           // 0x0e
           DISPVECENTRY_NEW(INTERNAL_DEVICE_CONTROL,   TRUE,    DeviceControl, 0x10),           // 0x0f
           DISPVECENTRY_NEW(SHUTDOWN,                 FALSE,    Shutdown, 0x10),                // 0x10   //BUGBUG
           DISPVECENTRY_NEW(LOCK_CONTROL,              TRUE,    LockControl, 0x10),             // 0x11
           DISPVECENTRY_NEW(CLEANUP,                   TRUE,    Cleanup, 0x10),                 // 0x12
           DISPVECENTRY_NEW(CREATE_MAILSLOT,           TRUE,    Unimplemented, 0x10),           // 0x13
           DISPVECENTRY_NEW(QUERY_SECURITY,            TRUE,    QuerySecurity, 0x10),           // 0x14
           DISPVECENTRY_NEW(SET_SECURITY,              TRUE,    SetSecurity, 0x10),             // 0x15
           DISPVECENTRY_NEW(QUERY_POWER,               TRUE,    Unimplemented, 0x10),           // 0x16
           DISPVECENTRY_NEW(NOT_DEFINED,               TRUE,    Unimplemented, 0x10),           // 0x17
           DISPVECENTRY_NEW(DEVICE_CHANGE,             TRUE,    Unimplemented, 0x10),           // 0x18
           DISPVECENTRY_NEW(QUERY_QUOTA,               TRUE,    Unimplemented, 0x10),           // 0x19
           DISPVECENTRY_NEW(SET_QUOTA,                 TRUE,    Unimplemented, 0x10),           // 0x1a
           DISPVECENTRY_NEW(PNP_POWER,                 TRUE,    Unimplemented, 0x10)            // 0x1b
           };

RX_FSD_DISPATCH_VECTOR RxDeviceFCBVector[IRP_MJ_MAXIMUM_FUNCTION + 1] = {
           DISPVECENTRY_NEW(CREATE,                   TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(CREATE_NAMED_PIPE,        TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(CLOSE,                    TRUE, DevFCBClose, 0x10),
           DISPVECENTRY_NEW(READ,                     TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(WRITE,                    TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(QUERY_INFORMATION,        TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(SET_INFORMATION,          TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(QUERY_EA,                 TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(SET_EA,                   TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(FLUSH_BUFFERS,            TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(QUERY_VOLUME_INFORMATION, TRUE, DevFCBQueryVolInfo, 0x10),
           DISPVECENTRY_NEW(SET_VOLUME_INFORMATION,   TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(DIRECTORY_CONTROL,        TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(FILE_SYSTEM_CONTROL,      TRUE, DevFCBFsCtl, 0x10),
           DISPVECENTRY_NEW(DEVICE_CONTROL,           TRUE, DevFCBIoCtl, 0x10),
           DISPVECENTRY_NEW(INTERNAL_DEVICE_CONTROL,  TRUE, DevFCBIoCtl, 0x10),
           DISPVECENTRY_NEW(SHUTDOWN,                 TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(LOCK_CONTROL,             TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(CLEANUP,                  TRUE, DevFCBCleanup, 0x10),
           DISPVECENTRY_NEW(CREATE_MAILSLOT,          TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(QUERY_SECURITY,           TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(SET_SECURITY,             TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(QUERY_POWER,              TRUE, Unimplemented, 0x10),           // 0x16
           DISPVECENTRY_NEW(NOT_DEFINED,              TRUE, Unimplemented, 0x10),           // 0x17
           DISPVECENTRY_NEW(DEVICE_CHANGE,            TRUE, Unimplemented, 0x10),           // 0x18
           DISPVECENTRY_NEW(QUERY_QUOTA,              TRUE, Unimplemented, 0x10),           // 0x19
           DISPVECENTRY_NEW(SET_QUOTA,                TRUE, Unimplemented, 0x10),           // 0x1a
           DISPVECENTRY_NEW(PNP_POWER,                TRUE, Unimplemented, 0x10)            // 0x1b
           };

FAST_IO_DISPATCH RxFastIoDispatch;


NTSTATUS
RxFsdCommonDispatch (
    PRX_FSD_DISPATCH_VECTOR DispatchVector,
    IN UCHAR MajorFunctionCode,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxObject
    );

VOID
RxInitializeDispatchVectors(
    OUT PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, RxInitializeDispatchVectors)
//not pageable SPINLOCK #pragma alloc_text(PAGE, RxFsdCommonDispatch)
#pragma alloc_text(PAGE, RxCommonDispatchProblem)
#pragma alloc_text(PAGE, RxCommonUnimplemented)
#pragma alloc_text(PAGE, RxFsdDispatch)
#endif


VOID
RxInitializeDispatchVectors(
    OUT PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine initializes the dispatch table for the driver object

Arguments:

    DriverObject - Supplies the driver object

--*/
{
    ULONG i;
    PAGED_CODE();

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)RxFsdDispatch;
    }

    //      Set Dispatch Vector for the DevFCB

    RxDeviceFCB.PrivateDispatchVector = &RxDeviceFCBVector[0];

    ASSERT (RxFsdDispatchVector[IRP_MJ_MAXIMUM_FUNCTION].CommonRoutine != NULL);
    ASSERT (RxDeviceFCBVector[IRP_MJ_MAXIMUM_FUNCTION].CommonRoutine != NULL);

    DriverObject->FastIoDispatch = &RxFastIoDispatch;  //this is dangerous!!!

    RxFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);
    RxFastIoDispatch.FastIoCheckIfPossible =   RxFastIoCheckIfPossible;  //  CheckForFastIo
    RxFastIoDispatch.FastIoRead =              RxFastIoRead;              //  Read
    RxFastIoDispatch.FastIoWrite =             RxFastIoWrite;             //  Write
    RxFastIoDispatch.FastIoQueryBasicInfo =    NULL; //RxFastQueryBasicInfo;     //  QueryBasicInfo
    RxFastIoDispatch.FastIoQueryStandardInfo = NULL; //RxFastQueryStdInfo;       //  QueryStandardInfo
    RxFastIoDispatch.FastIoLock =              NULL; //RxFastLock;               //  Lock
    RxFastIoDispatch.FastIoUnlockSingle =      NULL; //RxFastUnlockSingle;       //  UnlockSingle
    RxFastIoDispatch.FastIoUnlockAll =         NULL; //RxFastUnlockAll;          //  UnlockAll
    RxFastIoDispatch.FastIoUnlockAllByKey =    NULL; //RxFastUnlockAllByKey;     //  UnlockAllByKey
    RxFastIoDispatch.FastIoDeviceControl =     NULL;                      //  IoDeviceControl

    RxFastIoDispatch.AcquireFileForNtCreateSection = RxAcquireFileForNtCreateSection;
    RxFastIoDispatch.ReleaseFileForNtCreateSection = RxReleaseFileForNtCreateSection;

    //  Initialize the global netname table and export

    RxInitializePrefixTable( &RxNetNameTable, 0, FALSE);

    RxExports.pRxNetNameTable = &RxNetNameTable;
    RxNetNameTable.IsNetNameTable = TRUE;


    //  Initialize the cache manager callback routines

    RxData.CacheManagerCallbacks.AcquireForLazyWrite  = &RxAcquireFcbForLazyWrite;
    RxData.CacheManagerCallbacks.ReleaseFromLazyWrite = &RxReleaseFcbFromLazyWrite;
    RxData.CacheManagerCallbacks.AcquireForReadAhead  = &RxAcquireFcbForReadAhead;
    RxData.CacheManagerCallbacks.ReleaseFromReadAhead = &RxReleaseFcbFromReadAhead;

    RxData.CacheManagerNoOpCallbacks.AcquireForLazyWrite  = &RxNoOpAcquire;
    RxData.CacheManagerNoOpCallbacks.ReleaseFromLazyWrite = &RxNoOpRelease;
    RxData.CacheManagerNoOpCallbacks.AcquireForReadAhead  = &RxNoOpAcquire;
    RxData.CacheManagerNoOpCallbacks.ReleaseFromReadAhead = &RxNoOpRelease;
}


NTSTATUS
RxCommonDispatchProblem ( RXCOMMON_SIGNATURE )
{
   // if we get here then something is awry. this is used to initialize fields that SHOULD
   // not be accessed....like the create field in any vector but the highest level

    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxFsdDispatchPROBLEM: IrpC =%08lx,Code=", RxContext, RxContext->MajorFunction ));
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("---------------------PROBLEM-----%s\n", "" ));
    RxLog(("%s %lx %ld\n","pDX", RxContext, RxContext->MajorFunction));

    // RxCompleteContextAndReturn( RxStatus(NOT_IMPLEMENTED) );
    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
RxCommonUnimplemented ( RXCOMMON_SIGNATURE )
{
    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxFsdDispatRxFsdUnImplementedchPROBLEM: IrpC =%08lx,Code=",
                        RxContext, RxContext->MajorFunction ));
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("---------------------UNIMLEMENTED-----%s\n", "" ));
    // RxCompleteContextAndReturn( RxStatus(NOT_IMPLEMENTED) );
    return STATUS_NOT_IMPLEMENTED;
}



RxDbgTraceDoit(ULONG RxDbgTraceEnableCommand = 0xffff;)

NTSTATUS
RxFsdDispatch (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD dispatch for the RDBSS.
Arguments:

    RxDeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );  //ok4ioget

    UCHAR MajorFunctionCode  = IrpSp->MajorFunction;
    PFILE_OBJECT FileObject  = IrpSp->FileObject;  //ok4->fileobj

    PRX_FSD_DISPATCH_VECTOR DispatchVector;

    PAGED_CODE();

    RxDbgTraceDoit(
        if (MajorFunctionCode == RxDbgTraceEnableCommand) {
            RxNextGlobalTraceSuppress =  RxGlobalTraceSuppress =  FALSE;
        }
        if (0) {
            RxNextGlobalTraceSuppress =  RxGlobalTraceSuppress =  FALSE;
        }
    );

    RxDbgTrace( 0, Dbg, ("RxFsdDispatch: Code =%02lx (%lu)  ----------%s-----------\n",
                                    MajorFunctionCode,
                                    ++RxIrpCodeCount[IrpSp->MajorFunction],
                                    RxIrpCodeToName[MajorFunctionCode] ));

    //  get a private dispatch table if there is one
    if (FileObject->FsContext != NULL) {
        if (((PFCB)(FileObject->FsContext))->PrivateDispatchVector != NULL) {  //ok4fscontext
            RxDbgTraceLV( 0, Dbg, 2500, ("Using Private Dispatch Vector\n"));
            DispatchVector = ((PFCB)(FileObject->FsContext))->PrivateDispatchVector;
        } else {
           DispatchVector = RxFsdDispatchVector;
        }
    } else if (MajorFunctionCode == IRP_MJ_CREATE) {
       DispatchVector = RxFsdDispatchVector;
    } else {
       DispatchVector = NULL;

       RxDbgTrace(
           0,
           Dbg,
           ("RxFsdDispatch: Code =%02lx (%lu)  ----------%s-----------\n",
            MajorFunctionCode,
            ++RxIrpCodeCount[IrpSp->MajorFunction],
            RxIrpCodeToName[MajorFunctionCode]));
    }

    if (DispatchVector != NULL) {

        status = RxFsdCommonDispatch( DispatchVector,
                                     MajorFunctionCode,
                                     IrpSp,
                                     FileObject,
                                     Irp,
                                     RxDeviceObject );

        RxDbgTrace( 0, Dbg, ("RxFsdDispatch: Status =%02lx  %s....\n",
                             status,
                             RxIrpCodeToName[MajorFunctionCode] ));

        RxDbgTraceDoit(
            if (RxGlobalTraceIrpCount > 0) {
                RxGlobalTraceIrpCount -= 1;
                RxGlobalTraceSuppress = FALSE;
            } else {
                RxGlobalTraceSuppress = RxNextGlobalTraceSuppress;
            }
       );

    } else {
       status = STATUS_INVALID_HANDLE;
    }

    return status;
}

NTSTATUS
RxFsdCommonDispatch (
    PRX_FSD_DISPATCH_VECTOR DispatchVector,
    IN UCHAR MajorFunctionCode,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine implements the FSD part of dispatch for IRP's

Arguments:

    DispatchVector    - the dispatch vector

    MajorFunctionCode - the IRP major function

    IrpSp             - the IRP stack

    FileObject        - the file object

    Irp               - the IRP

Return Value:

    RXSTATUS - The FSD status for the IRP

Notes:


--*/
{  //not currently pageable.......
    NTSTATUS    Status = STATUS_SUCCESS;

    PRX_CONTEXT RxContext = NULL;
    UCHAR       MinorFunctionCode  = IrpSp->MinorFunction;

    BOOLEAN TopLevel;
    ULONG ContextFlags = 0;
    BOOLEAN Wait;
    BOOLEAN Cancellable;
    BOOLEAN ModWriter          = FALSE;
    BOOLEAN fCleanupOrClose    = FALSE;
    BOOLEAN fContinueOperation = TRUE;

    KIRQL          SavedIrql;
    BOOLEAN        PostRequest = FALSE;
    PRX_DISPATCH   DispatchRoutine = NULL;
    PDRIVER_CANCEL CancelRoutine = NULL;

    //RxDbgTraceLV(+1, Dbg, 1500, ("RxFsd[%s]\n", RxIrpCodeToName[MajorFunctionCode]));

    //TimerStart(Dbg);

    FsRtlEnterFileSystem();

    TopLevel = RxTryToBecomeTheTopLevelIrp( Irp );

    try {
        // Treat all operations as being cancellable and waitable.
        Wait          = RX_CONTEXT_FLAG_WAIT;
        Cancellable   = TRUE;
        CancelRoutine = RxCancelRoutine;

        // Retract the capability based upon the operation
        switch (MajorFunctionCode) {
        case IRP_MJ_FILE_SYSTEM_CONTROL:
            //  Call the common FileSystem Control routine, with blocking allowed if
            //  synchronous.  This opeation needs to special case the mount
            //  and verify suboperations because we know they are allowed to block.
            //  We identify these suboperations by looking at the file object field
            //  and seeing if its null.

            Wait = (FileObject == NULL) ? TRUE : CanFsdWait( Irp );
            break;

        case IRP_MJ_READ:
        case IRP_MJ_LOCK_CONTROL:
        case IRP_MJ_DIRECTORY_CONTROL:
        case IRP_MJ_QUERY_VOLUME_INFORMATION:
        case IRP_MJ_WRITE:
        case IRP_MJ_QUERY_INFORMATION:
        case IRP_MJ_SET_INFORMATION:
        case IRP_MJ_QUERY_EA:
        case IRP_MJ_SET_EA:
        case IRP_MJ_QUERY_SECURITY:
        case IRP_MJ_SET_SECURITY:
        case IRP_MJ_FLUSH_BUFFERS:
        case IRP_MJ_DEVICE_CONTROL:
        case IRP_MJ_SET_VOLUME_INFORMATION:

            Wait = CanFsdWait( Irp );
            break;

        case IRP_MJ_CLEANUP:
        case IRP_MJ_CLOSE:
            Cancellable     = FALSE;
            fCleanupOrClose = TRUE;
            break;
        default:
            break;
        }

        KeAcquireSpinLock(&RxStrucSupSpinLock,&SavedIrql);
        fContinueOperation = TRUE;

        switch (RxDeviceObject->StartStopContext.State) {
        case RDBSS_STARTABLE: //here only device creates and device operations can go thru
           {
              if (((FileObject->FileName.Length == 0) &&
                                (FileObject->RelatedFileObject == NULL))
                    || (DispatchVector == RxDeviceFCBVector)){
                 NOTHING;
              } else {
                 fContinueOperation = FALSE;
                 Status = STATUS_REDIRECTOR_NOT_STARTED;
              }
           }
           break;
        case RDBSS_STOP_IN_PROGRESS:
           if (!fCleanupOrClose) {
              fContinueOperation = FALSE;
              Status = STATUS_REDIRECTOR_NOT_STARTED;
           }
           break;
        //case RDBSS_STOPPED:
        //   {
        //      if ((MajorFunctionCode == IRP_MJ_FILE_SYSTEM_CONTROL) &&
        //          (MinorFunctionCode == IRP_MN_USER_FS_REQUEST) &&
        //          (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_LMR_START)) {
        //         RxDeviceObject->StartStopContext.State = RDBSS_START_IN_PROGRESS;
        //         RxDeviceObject->StartStopContext.Version++;
        //         fContinueOperation = TRUE;
        //      } else {
        //         fContinueOperation = FALSE;
        //         Status = STATUS_REDIRECTOR_NOT_STARTED);
        //      }
        //   }
        case RDBSS_STARTED:
           // intentional break;
        default:
           break;
        }

        KeReleaseSpinLock(&RxStrucSupSpinLock,SavedIrql);

        if ((IrpSp->FileObject != NULL) &&
            (IrpSp->FileObject->FsContext != NULL)) {
           PFCB pFcb = (PFCB)IrpSp->FileObject->FsContext;
           if (FlagOn(pFcb->FcbState,FCB_STATE_ORPHANED)) {
               if (!fCleanupOrClose) {
                  DbgPrint("Ignoring operation on ORPHANED FCB %lx %lx %lx\n",pFcb,MajorFunctionCode,MinorFunctionCode);
                  fContinueOperation = FALSE;
                  Status = STATUS_UNEXPECTED_NETWORK_ERROR;
               } else {
                  DbgPrint("Delayed Close/Cleanup on ORPHANED FCB %lx\n",pFcb);
                  fContinueOperation = TRUE;
               }
           }
        }

        if (RxDeviceObject->StartStopContext.State == RDBSS_STOP_IN_PROGRESS) {
            if (fCleanupOrClose) {
                PFILE_OBJECT pFileObject = IrpSp->FileObject;
                PFCB         pFcb        = (PFCB)pFileObject->FsContext;

                DbgPrint("RDBSS -- Close after Stop");
                DbgPrint("RDBSS: Irp(%lx) MJ %ld MN %ld FileObject(%lx) FCB(%lx) \n",
                       Irp,IrpSp->MajorFunction,IrpSp->MinorFunction,pFileObject,pFcb);

                if ((pFileObject != NULL)
                       && (pFcb != NULL)
                       && (pFcb != &RxDeviceFCB)
                       && NodeTypeIsFcb(pFcb)) {
                    DbgPrint(
                        "RDBSS: OpenCount(%ld) UncleanCount(%ld) Name(%wZ)\n",
                         pFcb->OpenCount,
                         pFcb->UncleanCount,
                         &pFcb->FcbTableEntry.Path);
                }
             }
        }

        if (!fContinueOperation) {
            try_return(Status);
        }

        if (Wait) {
            SetFlag(ContextFlags,RX_CONTEXT_FLAG_WAIT);
        }
        RxContext = RxCreateRxContext( Irp, RxDeviceObject, ContextFlags );
        if (RxContext == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            RxCompleteRequest_OLD( RxNull, Irp, Status );
            try_return( Status );
        }

        // Assume ownership of the Irp by setting the cancelling routine.
        if (Cancellable) {
           RxSetCancelRoutine(Irp,CancelRoutine);
        } else {
           // Ensure that those operations regarded as non cancellable will
           // not be cancelled.
           RxSetCancelRoutine(Irp,NULL);
        }

        ASSERT(MajorFunctionCode <= IRP_MJ_MAXIMUM_FUNCTION);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status      = STATUS_SUCCESS;

        DispatchRoutine = DispatchVector[MajorFunctionCode].CommonRoutine;

        switch (MajorFunctionCode) {
        case IRP_MJ_READ:
        case IRP_MJ_WRITE:
            //  If this is an Mdl complete request, don't go through
            //  common read.
            if ( FlagOn(MinorFunctionCode, IRP_MN_COMPLETE) ) {
                DispatchRoutine = RxCompleteMdl;
            } else if ( FlagOn(MinorFunctionCode, IRP_MN_DPC) ) {
               //  Post all DPC calls.
                RxDbgTrace(0, Dbg, ("Passing DPC call to Fsp\n", 0 ));
                PostRequest = TRUE;
            } else if ((MajorFunctionCode == IRP_MJ_READ) &&
                       (IoGetRemainingStackSize() < 0xe00)) {
               //
               //  Check if we have enough stack space to process this request.  If there
               //  isn't enough then we will pass the request off to the stack overflow thread.
               //
               // joejoe  where did the number come from......
               // this number should come from the minirdr....only he knows how much he needs
               // and in my configuration it should definitely be bigger than for FAT!
               // plus......i can't go to the net on the hypercrtical thread!!! this will have to be
               // reworked! maybe we should have our own hypercritical thread............
               RxDbgTrace(0, Dbg, ("Passing StackOverflowRead off\n", 0 ));
               try_return( Status = RxPostStackOverflowRead( RxContext) );
            }
            break;
        default:
            NOTHING;
        }

        //
        // set the resume routine for the fsp to be the dispatch routine and then either post immediately
        // or calldow to the common dispatch as appropriate

        RxContext->ResumeRoutine = DispatchRoutine;

        if( DispatchRoutine != NULL ) {

            if (PostRequest) {
               Status = RxFsdPostRequest(RxContext);
            } else {

                do {

                     Status = DispatchRoutine( RXCOMMON_ARGUMENTS );

                } while (Status == STATUS_RETRY);

                if (Status != STATUS_PENDING) {
                    if (! ((RxContext->CurrentIrp    == Irp)               &&
                           (RxContext->CurrentIrpSp  == IrpSp)             &&
                           (RxContext->MajorFunction == MajorFunctionCode) &&
                           (RxContext->MinorFunction == MinorFunctionCode) )
                           ) {
                        DbgPrint("RXCONTEXT CONTAMINATED!!!! rxc=%08lx\n", RxContext);
                        DbgPrint("-irp> %08lx %08lx\n",RxContext->CurrentIrp,Irp);
                        DbgPrint("--sp> %08lx %08lx\n",RxContext->CurrentIrpSp,IrpSp);
                        DbgPrint("--mj> %08lx %08lx\n",RxContext->MajorFunction,MajorFunctionCode);
                        DbgPrint("--mn> %08lx %08lx\n",RxContext->MinorFunction,MinorFunctionCode);
                        DbgBreakPoint();
                    }
                    Status = RxCompleteRequest( RxContext, Status );
                }

            }
        } else {
            Status = STATUS_NOT_IMPLEMENTED;
        }

    try_exit: NOTHING;
    } except(RxExceptionFilter( RxContext, GetExceptionInformation() )) {

        //  The I/O request was not handled successfully, abort the I/O request with
        //  the error status that we get back from the execption code

        Status = RxProcessException( RxContext, GetExceptionCode() );
    }

    if (TopLevel) {
       IoSetTopLevelIrp( NULL );
    }

    FsRtlExitFileSystem();

    //RxDbgTraceLV(-1, Dbg, 1500, ("RxFsd[%s] Status-> %08lx\n", RxIrpCodeToName[MajorFunctionCode],Status));

    //TimerStop(Dbg,"RxFsdCreate");

    return Status;

#if DBG
    NOTHING;
#else
    UNREFERENCED_PARAMETER( IrpSp );
#endif
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\fcbtable.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fcbtable.c

Abstract:

    This module implements the data structures that facilitate management of the
    collection of FCB's associated with a NET_ROOT

Author:

    Balan Sethu Raman (SethuR)    10/17/96

Revision History:

    This was derived from the original implementation of prefix tables done
    by Joe Linn.

--*/


#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxTableComputePathHashValue)
#pragma alloc_text(PAGE, RxInitializeFcbTable)
#pragma alloc_text(PAGE, RxFinalizeFcbTable)
#pragma alloc_text(PAGE, RxFcbTableLookupFcb)
#pragma alloc_text(PAGE, RxFcbTableInsertFcb)
#pragma alloc_text(PAGE, RxFcbTableRemoveFcb)
#endif

//
// The debug trace level
//

#define Dbg              (DEBUG_TRACE_PREFIX)

ULONG
RxTableComputePathHashValue (
    IN  PUNICODE_STRING  Name
    )
/*++

Routine Description:

   here, we compute a caseinsensitive hashvalue.  we want to avoid a call/char to
   the unicodeupcase routine but we want to still have some reasonable spread on
   the hashvalues.  many rules just dont work for known important cases.  for
   example, the (use the first k and the last n) rule that old c compilers used
   doesn't pickup the difference among \nt\private\......\slm.ini and that would be
   nice.  note that the underlying comparison used already takes cognizance of the
   length before comparing.

   the rule we have selected is to use the 2nd, the last 4, and three selected
   at 1/4 points

Arguments:

    Name      - the name to be hashed

Return Value:

    ULONG which is a hashvalue for the name given.

--*/
{
    ULONG HashValue;
    LONG i,j;
    LONG length = Name->Length/sizeof(WCHAR);
    PWCHAR Buffer = Name->Buffer;
    LONG Probe[8];

    PAGED_CODE();

    HashValue = 0;

    Probe[0] = 1;
    Probe[1] = length - 1;
    Probe[2] = length - 2;
    Probe[3] = length - 3;
    Probe[4] = length - 4;
    Probe[5] = length >> 2;
    Probe[6] = (2 * length) >> 2;
    Probe[7] = (3 * length) >> 2;

    for (i = 0; i < 8; i++) {
        j = Probe[i];
        if ((j < 0) || (j >= length)) {
            continue;
        }
        HashValue = (HashValue << 3) + RtlUpcaseUnicodeChar(Buffer[j]);
    }

    RxDbgTrace(0, Dbg, ("RxTableComputeHashValue Hashv=%ld Name=%wZ\n",
                       HashValue, Name));
    return(HashValue);
}


#define HASH_BUCKET(TABLE,HASHVALUE) &((TABLE)->HashBuckets[(HASHVALUE) % (TABLE)->NumberOfBuckets])

VOID
RxInitializeFcbTable(
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN     BOOLEAN       CaseInsensitiveMatch)
/*++

Routine Description:

    The routine initializes the RX_FCB_TABLE data structure

Arguments:

    pFcbTable - the table instance to be initialized.

    CaseInsensitiveMatch - indicates if all the lookups will be case
                           insensitive

--*/

{
    ULONG i;

    PAGED_CODE();

    // this is not zero'd so you have to be careful to init everything
    pFcbTable->NodeTypeCode = RDBSS_NTC_FCB_TABLE;
    pFcbTable->NodeByteSize = sizeof(RX_PREFIX_TABLE);

    ExInitializeResourceLite( &pFcbTable->TableLock );

    pFcbTable->Version = 0;
    pFcbTable->pTableEntryForNull = NULL;

    pFcbTable->CaseInsensitiveMatch = CaseInsensitiveMatch;

    pFcbTable->NumberOfBuckets = RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS;
    for (i=0; i < pFcbTable->NumberOfBuckets; i++) {
        InitializeListHead(&pFcbTable->HashBuckets[i]);
    }

    pFcbTable->Lookups = 0;
    pFcbTable->FailedLookups = 0;
    pFcbTable->Compares = 0;
}

VOID
RxFinalizeFcbTable(
    IN OUT PRX_FCB_TABLE pFcbTable)
/*++

Routine Description:

    The routine deinitializes a prefix table.

Arguments:

    pFcbTable - the table to be finalized.

Return Value:

    None.

--*/
{
    ULONG i;

    PAGED_CODE();

    ExDeleteResourceLite(&pFcbTable->TableLock);

    IF_DEBUG {
        for (i=0; i < pFcbTable->NumberOfBuckets; i++) {
            ASSERT(IsListEmpty(&pFcbTable->HashBuckets[i]));
        }
    }
}



PFCB
RxFcbTableLookupFcb(
    IN  PRX_FCB_TABLE    pFcbTable,
    IN  PUNICODE_STRING  pPath)
/*++

Routine Description:

    The routine looks up a path in the RX_FCB_TABLE instance.

Arguments:

    pFcbTable - the table to be looked in.

    pPath    - the name to be looked up

Return Value:

    a pointer to an FCB instance if successful, otherwise NULL

--*/
{
    ULONG HashValue;

    PLIST_ENTRY pHashBucket, pListEntry;

    PRX_FCB_TABLE_ENTRY pFcbTableEntry;

    PFCB        pFcb = NULL;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFcbTableLookupName %lx %\n",pFcbTable));

    if (pPath->Length == 0) {
        pFcbTableEntry = pFcbTable->pTableEntryForNull;
    } else {
        HashValue = RxTableComputePathHashValue(pPath);

        pHashBucket = HASH_BUCKET(pFcbTable,HashValue);

        for (pListEntry =  pHashBucket->Flink;
             pListEntry != pHashBucket;
             pListEntry =  pListEntry->Flink) {
            (PVOID)pFcbTableEntry = CONTAINING_RECORD(
                                        pListEntry,
                                        RX_FCB_TABLE_ENTRY,
                                        HashLinks);

            InterlockedIncrement(&pFcbTable->Compares);

            if ((pFcbTableEntry->HashValue == HashValue) &&
                (pFcbTableEntry->Path.Length == pPath->Length) &&
                (RtlEqualUnicodeString(
                     pPath,
                     &pFcbTableEntry->Path,
                     pFcbTable->CaseInsensitiveMatch))) {

                break;
            }
        }

        if (pListEntry == pHashBucket) {
            pFcbTableEntry = NULL;
        }
    }

    InterlockedIncrement(&pFcbTable->Lookups);

    if (pFcbTableEntry == NULL) {
        InterlockedIncrement(&pFcbTable->FailedLookups);
    } else {
        pFcb = (PFCB)CONTAINING_RECORD(
                    pFcbTableEntry,
                    FCB,
                    FcbTableEntry);

        RxReferenceNetFcb(pFcb);
    }

    RxDbgTraceUnIndent(-1,Dbg);

    return pFcb;
}

NTSTATUS
RxFcbTableInsertFcb(
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN OUT PFCB          pFcb)
/*++

Routine Description:

    This routine inserts a FCB  in the RX_FCB_TABLE instance.

Arguments:

    pFcbTable - the table to be looked in.

    pFcb      - the FCB instance to be inserted

Return Value:

    STATUS_SUCCESS if successful

Notes:

    The insertion routine combines the semantics of an insertion followed by
    lookup. This is the reason for the additional reference. Otherwise an
    additional call to reference the FCB inserted in the table needs to
    be made

--*/
{
    PRX_FCB_TABLE_ENTRY pFcbTableEntry;
    ULONG HashValue;
    PLIST_ENTRY pListEntry,pHashBucket;

    PAGED_CODE();

    ASSERT( RxIsFcbTableLockExclusive( pFcbTable )  );

    pFcbTableEntry = &pFcb->FcbTableEntry;

    pFcbTableEntry->HashValue = RxTableComputePathHashValue(
                                    &pFcbTableEntry->Path);

    pHashBucket = HASH_BUCKET(
                      pFcbTable,
                      pFcbTableEntry->HashValue);

    RxReferenceNetFcb(pFcb);

    if (pFcbTableEntry->Path.Length){
        InsertHeadList(
            pHashBucket,
            &pFcbTableEntry->HashLinks);
    } else {
        pFcbTable->pTableEntryForNull = pFcbTableEntry;
    }

    InterlockedIncrement(&pFcbTable->Version);

    return STATUS_SUCCESS;
}

NTSTATUS
RxFcbTableRemoveFcb(
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN OUT PFCB          pFcb)
/*++

Routine Description:

    This routine deletes an instance from the table

Arguments:

    pFcbTable - the table to be looked in.

    pFcb      - the FCB instance to be inserted

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    PRX_FCB_TABLE_ENTRY pFcbTableEntry;

    PAGED_CODE();

    ASSERT( RxIsPrefixTableLockExclusive(pFcbTable));

    pFcbTableEntry = &pFcb->FcbTableEntry;

    if (pFcbTableEntry->Path.Length) {
        RemoveEntryList(&pFcbTableEntry->HashLinks);
    } else {
        pFcbTable->pTableEntryForNull = NULL;
    }

    InitializeListHead(&pFcbTableEntry->HashLinks);

    InterlockedIncrement(&pFcbTable->Version);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\buffring.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    buffring.c

Abstract:

    This module defines the implementation for changing buffering states in the RDBSS

Author:

    Balan Sethu Raman (SethuR) 11-Nov-95    Created

Notes:

    The RDBSS provides a mechanism for providing distributed cache coherency in conjunction with
    the various mini redirectors. This service is encapsulated in the BUFFERING_MANAGER which
    processes CHANGE_BUFFERING_STATE_REQUESTS.

    In the SMB protocol OPLOCK's ( Oppurtunistic Locks ) provide the necessary infrastructure for
    cache coherency.

    There are three components in the implementation of cache coherency protocol's in any mini
    redirector.

      1) The first constitutes the modifications to the CREATE/OPEN path. In this path the
      type of buffering to be requested is determined and the appropriate request is made to the
      server. On the return path the buffering state associated with the FCB is updated based
      on the result of the CREATE/OPEN.

      2) The receive indication code needs to modified to handle change buffering state notifications
      from the server. If such a request is detected then the local mechanism to coordinate the
      buffering states needs to be triggered.

      3) The mechanism for changing the buffering state which is implemented as part of the
      RDBSS.

    Any change buffering state request must identify the SRV_OPEN to which the request applies.
    The amount of computational effort involved in identifying the SRV_OPEN depends upon the
    protocol. In the SMB protocol the Server gets to pick the id's used for identifying files
    opened at the server. These are relative to the NET_ROOT(share) on which they are opened.
    Thus every change buffering state request is identified by two keys, the NetRootKey and the
    SrvOpenKey which need to be translated to the appropriate NET_ROOT and SRV_OPEN instance
    respectively. In order to provide better integration with the resource acquisition/release
    mechanism and to avoid duplication of this effort in the various mini redirectors the RDBSS
    provides this service.

    There are two mechanisms provided in the wrapper for indicating buffering state
    changes to SRV_OPEN's. They are

         1) RxIndicateChangeOfBufferingState

         2) RxIndicateChangeOfBufferingStateForSrvOpen.

    The mini rediretors that need an auxillary mechanism for establishing the mapping
    from the id's to the SRV_OPEN instance employ (1) while the mini redirectors that
    do not require this assistance employ (2).

    The buffering manager processes these requests in different stages. It maintains the
    requests received from the various underlying mini redirectors in one of three lists.

    The Dispatcher list contains all the requests for which the appropriate mapping to a
    SRV_OPEN instance has not been established. The Handler list contains all the requests
    for which the appropriate mapping has been established and have not yet been processed.
    The LastChanceHandlerList contains all the requests for which the initial processing was
    unsuccessful.

    This typically happens when the FCB was accquired in a SHARED mode at the time the
    change buffering state request was received. In such cases the Oplock break request
    can only be processed by a delayed worker thread.

    The Change buffering state request processing in the redirector is intertwined with
    the FCB accqusition/release protocol. This helps in ensuring shorter turn around times.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxTearDownBufferingManager)
#pragma alloc_text(PAGE, RxIndicateChangeOfBufferingStateForSrvOpen)
#pragma alloc_text(PAGE, RxPrepareRequestForHandling)
#pragma alloc_text(PAGE, RxPrepareRequestForReuse)
#pragma alloc_text(PAGE, RxpDiscardChangeBufferingStateRequests)
#pragma alloc_text(PAGE, RxProcessFcbChangeBufferingStateRequest)
#pragma alloc_text(PAGE, RxPurgeChangeBufferingStateRequestsForSrvOpen)
#pragma alloc_text(PAGE, RxProcessChangeBufferingStateRequestsForSrvOpen)
#pragma alloc_text(PAGE, RxInitiateSrvOpenKeyAssociation)
#pragma alloc_text(PAGE, RxpLookupSrvOpenForRequestLite)
#pragma alloc_text(PAGE, RxChangeBufferingState)
#pragma alloc_text(PAGE, RxFlushFcbInSystemCache)
#pragma alloc_text(PAGE, RxPurgeFcbInSystemCache)
#endif

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_CACHESUP)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_CACHESUP)

//
// Forward declarations
//

extern NTSTATUS
RxRegisterChangeBufferingStateRequest(
    PSRV_CALL pSrvCall,
    PSRV_OPEN pSrvOpen,
    PVOID     SrvOpenKey,
    PVOID     pMRxContext);

extern VOID
RxDispatchChangeBufferingStateRequests(
    PSRV_CALL pSrvCall);

extern VOID
RxpDispatchChangeBufferingStateRequests(
    IN OUT PSRV_CALL   pSrvCall,
    IN OUT PSRV_OPEN   pSrvOpen,
    OUT    PLIST_ENTRY pDiscardedRequests);

extern VOID
RxpDiscardChangeBufferingStateRequests(
    IN OUT PLIST_ENTRY pDiscardedRequests);

extern VOID
RxLastChanceHandlerForChangeBufferingStateRequests(
    PSRV_CALL pSrvCall);

extern NTSTATUS
RxpLookupSrvOpenForRequestLite(
    IN     PSRV_CALL                       pSrvCall,
    IN OUT PCHANGE_BUFFERING_STATE_REQUEST pRequest);

extern VOID
RxGatherRequestsForSrvOpen(
    IN OUT PSRV_CALL     pSrvCall,
    IN     PSRV_OPEN     pSrvOpen,
    IN OUT PLIST_ENTRY   pRequestsListHead);

NTSTATUS
RxInitializeBufferingManager(
    PSRV_CALL   pSrvCall)
/*++

Routine Description:

    This routine initializes the buffering manager associated with a SRV_CALL
    instance.

Arguments:

    pSrvCall    - the SRV_CALL instance

Return Value:

    STATUS_SUCCESS if successful

Notes:

    The buffering manager consists of three lists .....

        1) the dispatcher list which contains all the requests that need to be
        processed.

        2) the handler list contains all the requests for which the SRV_OPEN
        instance has been found and referenced.

        3) the last chance handler list contains all the requests for which
        an unsuccessful attempt to process the request was made, i.e., the
        FCB could not be acquired exclusively.

    The manipulation of these lists are done under the control of the spin lock
    associated with the buffering manager. A Mutex will not suffice since these
    lists are manipulated at DPC level.

    All buffering manager operations at non DPC level are serialized using the
    Mutex associated with the buffering manager.

--*/
{
    PRX_BUFFERING_MANAGER pBufferingManager;

    pBufferingManager = &pSrvCall->BufferingManager;

    KeInitializeSpinLock( &pBufferingManager->SpinLock );

    InitializeListHead(&pBufferingManager->HandlerList);
    InitializeListHead(&pBufferingManager->LastChanceHandlerList);
    InitializeListHead(&pBufferingManager->DispatcherList);

    pBufferingManager->fNoWaitHandlerActive = FALSE;
    pBufferingManager->fLastChanceHandlerActive = FALSE;
    pBufferingManager->fDispatcherActive = FALSE;

    pBufferingManager->NumberOfOutstandingOpens = 0;

    InitializeListHead(&pBufferingManager->SrvOpenLists[0]);
    ExInitializeFastMutex(&pBufferingManager->Mutex);

    return STATUS_SUCCESS;
}

NTSTATUS
RxTearDownBufferingManager(
    PSRV_CALL pSrvCall)
/*++

Routine Description:

    This routine tears down the buffering manager associated with a SRV_CALL
    instance.

Arguments:

    pSrvCall    - the SRV_CALL instance

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    PRX_BUFFERING_MANAGER pBufferingManager;

    PAGED_CODE();

    pBufferingManager = &pSrvCall->BufferingManager;

    // Ensure that all the work items in the buffering manager are not in use.
    if (pBufferingManager->DispatcherWorkItem.List.Flink != NULL) {
        //DbgBreakPoint();
    }

    if (pBufferingManager->HandlerWorkItem.List.Flink != NULL) {
        //DbgBreakPoint();
    }

    if (pBufferingManager->LastChanceHandlerWorkItem.List.Flink != NULL) {
        //DbgBreakPoint();
    }

    return STATUS_SUCCESS;
}

VOID
RxIndicateChangeOfBufferingState(
    PMRX_SRV_CALL pSrvCall,
    PVOID         SrvOpenKey,
    PVOID         pMRxContext)
/*++

Routine Description:

    This routine registers an oplock break indication.

Arguments:

    pSrvCall    - the SRV_CALL instance

    SrvOpenKey  - the key for the SRV_OPEN instance.

    pMRxContext - the context to be passed back to the mini rdr during callbacks for
                  processing the oplock break.

Return Value:

    none.

Notes:

    This is an instance in which the buffering state change request from the
    server identifies the SRV_OPEN instance using the key generated by the server

    This implies that the key needs to be mapped onto the SRV_OPEN instance locally.

--*/
{
    RxRegisterChangeBufferingStateRequest(
        (PSRV_CALL)pSrvCall,
        NULL,
        SrvOpenKey,
        pMRxContext);
}


VOID
RxIndicateChangeOfBufferingStateForSrvOpen(
    PMRX_SRV_CALL pSrvCall,
    PMRX_SRV_OPEN pMRxSrvOpen,
    PVOID         SrvOpenKey,
    PVOID         pMRxContext)
/*++

Routine Description:

    This routine registers an oplock break indication. If the necessary preconditions
    are satisfied the oplock is processed further.

Arguments:

    pSrvCall    - the SRV_CALL instance

    pMRxSrvOpen    - the SRV_OPEN instance.

    pMRxContext - the context to be passed back to the mini rdr during callbacks for
                  processing the oplock break.

Return Value:

    none.

Notes:

    This is an instance where in the buffering state change indications from the server
    use the key generated by the client. ( the SRV_OPEN address in itself is the best
    key that can be used ). This implies that no further lookup is required.

    However if this routine is called at DPC level, the indication is processed as if
    the lookup needs to be done.

--*/
{
    PAGED_CODE();

    if (KeGetCurrentIrql() <= APC_LEVEL) {
        PSRV_OPEN pSrvOpen = (PSRV_OPEN)pMRxSrvOpen;

        // If the resource for the FCB has already been accquired by this thread
        // the buffering state change indication can be processed immediately
        // without further delay.

        if (ExIsResourceAcquiredExclusiveLite(pSrvOpen->pFcb->Header.Resource)) {
            RxChangeBufferingState(pSrvOpen,pMRxContext,TRUE);
        } else {
            RxRegisterChangeBufferingStateRequest(
                (PSRV_CALL)pSrvCall,
                pSrvOpen,
                pSrvOpen->Key,
                pMRxContext);
        }
    } else {
        RxRegisterChangeBufferingStateRequest(
            (PSRV_CALL)pSrvCall,
            NULL,
            SrvOpenKey,
            pMRxContext);
    }
}

NTSTATUS
RxRegisterChangeBufferingStateRequest(
    PSRV_CALL pSrvCall,
    PSRV_OPEN pSrvOpen,
    PVOID     SrvOpenKey,
    PVOID     pMRxContext)
/*++

Routine Description:

    This routine registers a change buffering state requests. If necessary the worker thread
    routines for further processing are activated.

Arguments:

    pRequest -- change buffering state request to be regsitered

Return Value:

    STATUS_SUCCESS if successful.

Notes:

    This routine registers the change buffering state request by either inserting it in the
    registration list (DPC Level processing ) or the appropriate(dispatcher/handler list).

    This is the common routine for processing both kinds of callbacks, i.e, the ones in
    which the SRV_OPEN instance has been located and the ones in which only the SRV_OPEN
    key is available.

--*/
{
    NTSTATUS  Status;

    KIRQL     SavedIrql;

    PCHANGE_BUFFERING_STATE_REQUEST pRequest;
    PRX_BUFFERING_MANAGER           pBufferingManager = &pSrvCall->BufferingManager;

    // Ensure that either the SRV_OPEN instance for this request has not been
    // passed in or the call is not at DPC level.

    ASSERT((pSrvOpen == NULL) ||
           (KeGetCurrentIrql() <= APC_LEVEL));

    pRequest = RxAllocatePoolWithTag(
                   NonPagedPool,
                   sizeof(CHANGE_BUFFERING_STATE_REQUEST),
                   RX_BUFFERING_MANAGER_POOLTAG);

    if (pRequest != NULL) {
        BOOLEAN ActivateHandler    = FALSE;
        BOOLEAN ActivateDispatcher = FALSE;

        pRequest->Flags          = 0;

        pRequest->pSrvCall    = pSrvCall;
        pRequest->pSrvOpen    = pSrvOpen;
        pRequest->SrvOpenKey  = SrvOpenKey;
        pRequest->pMRxContext = pMRxContext;

        // If the SRV_OPEN instance for the request is known apriori the request can
        // be directly inserted into the buffering manager's HandlerList as opposed
        // to the DispatcherList for those instances in which only the SRV_OPEN key
        // is available. The insertion into the HandlerList ust be accompanied by an
        // additional reference to prevent finalization of the instance while a request
        // is still active.

        if (pSrvOpen != NULL) {
            RxReferenceSrvOpen((PSRV_OPEN)pSrvOpen);
        }

        KeAcquireSpinLock(
            &pSrvCall->BufferingManager.SpinLock,
            &SavedIrql);

        if (pRequest->pSrvOpen != NULL) {
            InsertTailList(&pBufferingManager->HandlerList,&pRequest->ListEntry);

            if (!pBufferingManager->fNoWaitHandlerActive) {
                pBufferingManager->fNoWaitHandlerActive = TRUE;
                ActivateHandler = TRUE;
            }

            RxLog(("Req %lx SrvOpenKey %lx in Handler List\n",pRequest,pRequest->pSrvOpen));
            RxWmiLog(LOG,
                     RxRegisterChangeBufferingStateRequest_1,
                     LOGPTR(pRequest)
                     LOGPTR(pRequest->pSrvOpen));
        } else {
            InsertTailList(&pBufferingManager->DispatcherList,&pRequest->ListEntry);

            if (!pBufferingManager->fDispatcherActive) {
                pBufferingManager->fDispatcherActive = TRUE;
                ActivateDispatcher = TRUE;
            }

            RxDbgTrace(0,Dbg,("Request %lx SrvOpenKey %lx in Registartion List\n",pRequest,pRequest->SrvOpenKey));
            RxLog(("Req %lx SrvOpenKey %lx in Reg. List\n",pRequest,pRequest->SrvOpenKey));
            RxWmiLog(LOG,
                     RxRegisterChangeBufferingStateRequest_2,
                     LOGPTR(pRequest)
                     LOGPTR(pRequest->SrvOpenKey));
        }

        KeReleaseSpinLock(
            &pSrvCall->BufferingManager.SpinLock,
            SavedIrql);

        InterlockedIncrement(&pSrvCall->BufferingManager.CumulativeNumberOfBufferingChangeRequests);

        if (ActivateHandler) {
            // Reference the SRV_CALL instance to ensure that it will not be
            // finalized while the worker thread request is in the scheduler
            RxReferenceSrvCallAtDpc(pSrvCall);

            RxPostToWorkerThread(
                RxFileSystemDeviceObject,
                HyperCriticalWorkQueue,
                &pBufferingManager->HandlerWorkItem,
                RxProcessChangeBufferingStateRequests,
                pSrvCall);
        }

        if (ActivateDispatcher) {
            // Reference the SRV_CALL instance to ensure that it will not be
            // finalized while the worker thread request is in the scheduler
            RxReferenceSrvCallAtDpc(pSrvCall);

            RxPostToWorkerThread(
                RxFileSystemDeviceObject,
                HyperCriticalWorkQueue,
                &pBufferingManager->DispatcherWorkItem,
                RxDispatchChangeBufferingStateRequests,
                pSrvCall);
        }

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;

        RxLog(("!!CBSReq. %lx %lx %lx %lx %lx\n", pSrvCall,pSrvOpen,SrvOpenKey,pMRxContext,Status));
        RxWmiLogError(Status,
                      LOG,
                      RxRegisterChangeBufferingStateRequest_3,
                      LOGPTR(pSrvCall)
                      LOGPTR(pSrvOpen)
                      LOGPTR(SrvOpenKey)
                      LOGPTR(pMRxContext)
                      LOGULONG(Status));
        RxDbgTrace(0, Dbg, ("Change Buffering State Request Ignored %lx %lx %lx\n", pSrvCall,pSrvOpen,SrvOpenKey,pMRxContext,Status));
    }

    RxDbgTrace(0,
               Dbg,
               ("Register SrvCall(%lx) SrvOpen (%lx) Key(%lx) Status(%lx)\n",
                pSrvCall,pSrvOpen,SrvOpenKey,Status));

    return Status;
}

NTSTATUS
RxPrepareRequestForHandling(
    PCHANGE_BUFFERING_STATE_REQUEST pRequest)
/*++

Routine Description:

    This routine preprocesses the request before initiating buffering state change
    processing. In addition to obtaining the references on the FCB abd the associated
    SRV_OPEN, an event is allocated as part of the FCB. This helps establish a priority
    mechanism for servicing buffering state change requests.

    The FCB accquisition is a two step process, i.e, wait for this event to be set followed
    by a wait for the resource.

Arguments:

    pRequest - the buffering state change request

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

Notes:

    Not all the FCB's have the space for the buffering state change event allocated when the
    FCB instance is created. The upside is that space is conserved and the downside is that
    a separate allocation needs to be made when it is required.

    This event associated with the FCB provides a two step mechanism for accelerating the
    processing of buffering state change requests. Ordinary operations get delayed in favour
    of the buffering state change requests. The details are in resrcsup.c

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PKEVENT   pEvent;
    PSRV_OPEN pSrvOpen = pRequest->pSrvOpen;

    PAGED_CODE();

    if (!FlagOn(pRequest->Flags,RX_REQUEST_PREPARED_FOR_HANDLING)) {
        SetFlag(pRequest->Flags,RX_REQUEST_PREPARED_FOR_HANDLING);

        RxAcquireSerializationMutex();

        if ((pEvent = pSrvOpen->Fcb->pBufferingStateChangeCompletedEvent) == NULL) {
            pEvent = RxAllocatePoolWithTag(
                         NonPagedPool,
                         sizeof(KEVENT),
                         RX_BUFFERING_MANAGER_POOLTAG);

            if (pEvent != NULL) {
                pSrvOpen->Fcb->pBufferingStateChangeCompletedEvent = pEvent;
                KeInitializeEvent(
                    pEvent,
                    NotificationEvent,
                    FALSE );
            }
        } else {
            KeResetEvent(pEvent);
        }

        if (pEvent != NULL) {
            SetFlag(pSrvOpen->Fcb->FcbState,FCB_STATE_BUFFERING_STATE_CHANGE_PENDING);
            SetFlag(pSrvOpen->Flags,SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING);
            SetFlag(pSrvOpen->Flags,SRVOPEN_FLAG_COLLAPSING_DISABLED);
            RxDbgTrace(0,Dbg,("3333 Request %lx SrvOpenKey %lx in Handler List\n",pRequest,pRequest->SrvOpenKey));
            RxLog(("3333 Req %lx SrvOpenKey %lx in Hndlr List\n",pRequest,pRequest->SrvOpenKey));
            RxWmiLog(LOG,
                     RxPrepareRequestForHandling_1,
                     LOGPTR(pRequest)
                     LOGPTR(pRequest->SrvOpenKey));
        } else {
            RxDbgTrace(0,Dbg,("4444 Ignoring Request %lx SrvOpenKey %lx \n",pRequest,pRequest->SrvOpenKey));
            RxLog(("Chg. Buf. State Ignored %lx %lx %lx\n",
                pRequest->SrvOpenKey,
                pRequest->pMRxContext,STATUS_INSUFFICIENT_RESOURCES));
            RxWmiLog(LOG,
                     RxPrepareRequestForHandling_2,
                     LOGPTR(pRequest->SrvOpenKey)
                     LOGPTR(pRequest->pMRxContext));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        RxReleaseSerializationMutex();
    }

    return Status;
}

VOID
RxPrepareRequestForReuse(
    PCHANGE_BUFFERING_STATE_REQUEST pRequest)
/*++

Routine Description:

    This routine postprocesses the request before destroying it. This involves
    dereferencing and setting the appropriate state flags.

Arguments:

    pRequest - the buffering state change request

Notes:

--*/
{
    PAGED_CODE();

    if (FlagOn(pRequest->Flags,RX_REQUEST_PREPARED_FOR_HANDLING)) {
        PFCB pFcb = pRequest->pSrvOpen->Fcb;

        // We should never clear the SrvOpen flag unless we are also clearing the FCB flag
        // and setting the event!
        //ClearFlag(pRequest->pSrvOpen->Flags,SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING);
        if (RxIsFcbAcquiredExclusive(pFcb)) {
            RxDereferenceSrvOpen(pRequest->pSrvOpen,LHS_ExclusiveLockHeld);
        } else {
            RxDereferenceSrvOpen(pRequest->pSrvOpen,LHS_LockNotHeld);
        }
    } else if (pRequest->pSrvOpen != NULL) {
        RxDereferenceSrvOpen(pRequest->pSrvOpen,LHS_LockNotHeld);
    }

    pRequest->pSrvOpen = NULL;
}

VOID
RxpDiscardChangeBufferingStateRequests(
    PLIST_ENTRY pDiscardedRequests)
/*++

Routine Description:

    This routine discards a list of change buffering state requests one at a time

Arguments:

    pDiscardedRequests - the requests to be discarded

Notes:

--*/
{
    PAGED_CODE();

    // Process the discarded requests,i.e, free the memory
    while (!IsListEmpty(pDiscardedRequests)) {
        PLIST_ENTRY                     pListEntry;
        PCHANGE_BUFFERING_STATE_REQUEST pRequest;

        pListEntry = RemoveHeadList(pDiscardedRequests);

        pRequest        = (PCHANGE_BUFFERING_STATE_REQUEST)
                          CONTAINING_RECORD(
                              pListEntry,
                              CHANGE_BUFFERING_STATE_REQUEST,
                              ListEntry);

        RxDbgTrace(0,Dbg,("**** (2)Discarding Request(%lx) SrvOpenKey(%lx) \n",
                pRequest,pRequest->SrvOpenKey));
        RxLog(("**** (2)Disc Req(%lx) SOKey(%lx) \n",
                pRequest,pRequest->SrvOpenKey));
        RxWmiLog(LOG,
                 RxpDiscardChangeBufferingStateRequests,
                 LOGPTR(pRequest)
                 LOGPTR(pRequest->SrvOpenKey));

        RxPrepareRequestForReuse(pRequest);
        RxFreePool(pRequest);
    }
}

VOID
RxpDispatchChangeBufferingStateRequests(
    PSRV_CALL   pSrvCall,
    PSRV_OPEN   pSrvOpen,
    PLIST_ENTRY pDiscardedRequests)
/*++

Routine Description:

    This routine dispatches the request before destroying it. This involves looking up
    the SRV_OPEN instance associated with a given SrvOpenKey.

Arguments:

    pSrvCall - the associated SRV_CALL instance

    pSrvOpen - the associated SRV_OPEN instance.

Notes:

    There are two flavours of this routine. When pSrvOpen is NULL this routine walks
    through the list of outstanding requests and establishes the mapping between the
    SrvOpenKey and the SRV_OPEN instance. On the other hand when pSrvOpen is a valid
    SRV_OPEN instance it merely traverses the list to gather together the requests
    corresponding to the given SRV_OPEN and transfer them enmasse to to the handler
    list.

    The buffering manager mutex must have been accquired on entry to this routine
    and the mutex ownership will remain invariant on exit.

--*/
{
    NTSTATUS Status;

    KIRQL  SavedIrql;

    PLIST_ENTRY pListEntry;

    LIST_ENTRY  DispatcherList;
    LIST_ENTRY  HandlerList;

    BOOLEAN     ActivateDispatcher;

    PRX_BUFFERING_MANAGER pBufferingManager = &pSrvCall->BufferingManager;

    PCHANGE_BUFFERING_STATE_REQUEST pRequest;

    InitializeListHead(pDiscardedRequests);
    InitializeListHead(&HandlerList);

    ActivateDispatcher = FALSE;

    // Since the buffering manager lists are subject to modifications while
    // the requests on the list are being processed, the requests are transferred
    // enmasse onto a temporary list. This prevents multiple acquisition/release of
    // the spinlock for each individual request.

    KeAcquireSpinLock(&pBufferingManager->SpinLock,&SavedIrql);

    RxTransferList(&DispatcherList,&pBufferingManager->DispatcherList);

    KeReleaseSpinLock(&pBufferingManager->SpinLock,SavedIrql);

    // Process the list of requests.

    pListEntry = DispatcherList.Flink;
    while (pListEntry != &DispatcherList) {
        PLIST_ENTRY pListHead;

        pRequest = (PCHANGE_BUFFERING_STATE_REQUEST)
                   CONTAINING_RECORD(
                       pListEntry,
                       CHANGE_BUFFERING_STATE_REQUEST,
                       ListEntry);

        pListEntry = pListEntry->Flink;

        if (pSrvOpen == NULL) {
            Status = RxpLookupSrvOpenForRequestLite(
                         pSrvCall,
                         pRequest);
        } else {
            if (pRequest->SrvOpenKey == pSrvOpen->Key) {
                pRequest->pSrvOpen = pSrvOpen;
                RxReferenceSrvOpen(pSrvOpen);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_PENDING;
            }
        }

        // The result of a lookup for a SRV_OPEN instance can yield
        // either STATUS_PENDING, STATUS_SUCCESS or STATUS_NOT_FOUND.

        switch (Status) {
        case STATUS_SUCCESS:
            {
                RemoveEntryList(&pRequest->ListEntry);
                InsertTailList(
                    &HandlerList,
                    &pRequest->ListEntry);
            }
            break;

        default:
            ASSERT(!"Valid Status Code from RxpLookupSrvOpenForRequestLite");

        case STATUS_NOT_FOUND:
            {
                RemoveEntryList(&pRequest->ListEntry);
                InsertTailList(
                    pDiscardedRequests,
                    &pRequest->ListEntry);
            }
            break;

        case STATUS_PENDING:
            break;
        }
    }

    // Splice back the list of requests that cannot be dispatched onto the
    // buffering manager's list and prepare for posting to another thread
    // to resume processing later.

    KeAcquireSpinLock(
        &pBufferingManager->SpinLock,
        &SavedIrql);

    if (!IsListEmpty(&DispatcherList)) {
        DispatcherList.Flink->Blink = pBufferingManager->DispatcherList.Blink;
        pBufferingManager->DispatcherList.Blink->Flink = DispatcherList.Flink;

        DispatcherList.Blink->Flink = &pBufferingManager->DispatcherList;
        pBufferingManager->DispatcherList.Blink = DispatcherList.Blink;

        if (ActivateDispatcher = !pBufferingManager->fDispatcherActive) {
            pBufferingManager->fDispatcherActive = ActivateDispatcher;
        }
    }

    if (!IsListEmpty(&HandlerList)) {
        HandlerList.Flink->Blink = pBufferingManager->HandlerList.Blink;
        pBufferingManager->HandlerList.Blink->Flink = HandlerList.Flink;

        HandlerList.Blink->Flink = &pBufferingManager->HandlerList;
        pBufferingManager->HandlerList.Blink = HandlerList.Blink;
    }

    KeReleaseSpinLock(&pBufferingManager->SpinLock,SavedIrql);

    // if resumption at a later time is desired because of unprocessed requests
    // post to a worker thread.

    if (ActivateDispatcher) {
        // Reference the SRV_CALL to ensure that finalization will not occur
        // while the worker thread request is in the scheduler.
        RxReferenceSrvCall(pSrvCall);

        RxLog(("***** Activating Dispatcher\n"));
        RxWmiLog(LOG,
                 RxpDispatchChangeBufferingStateRequests,
                 LOGPTR(pSrvCall));

        RxPostToWorkerThread(
            RxFileSystemDeviceObject,
            HyperCriticalWorkQueue,
            &pBufferingManager->DispatcherWorkItem,
            RxDispatchChangeBufferingStateRequests,
            pSrvCall);
    }
}

VOID
RxDispatchChangeBufferingStateRequests(
    PSRV_CALL pSrvCall)
/*++

Routine Description:

    This routine dispatches the request. This involves looking up
    the SRV_OPEN instance associated with a given SrvOpenKey.

Arguments:

    pSrvCall - the associated SRV_CALL instance

--*/
{
    KIRQL SavedIrql;

    BOOLEAN    ActivateHandler = FALSE;

    LIST_ENTRY DiscardedRequests;

    PRX_BUFFERING_MANAGER pBufferingManager;

    RxUndoScavengerFinalizationMarking(
        pSrvCall);

    pBufferingManager = &pSrvCall->BufferingManager;

    RxAcquireBufferingManagerMutex(pBufferingManager);

    KeAcquireSpinLock(&pBufferingManager->SpinLock,&SavedIrql);

    pBufferingManager->fDispatcherActive = FALSE;

    KeReleaseSpinLock(&pBufferingManager->SpinLock,SavedIrql);

    RxpDispatchChangeBufferingStateRequests(pSrvCall,NULL,&DiscardedRequests);

    RxReleaseBufferingManagerMutex(pBufferingManager);

    // If requests have been transferred from the dispatcher list to the handler
    // list ensure that the handler is activated.

    KeAcquireSpinLock(&pBufferingManager->SpinLock,&SavedIrql);

    if (!IsListEmpty(&pBufferingManager->HandlerList) &&
        (ActivateHandler = !pBufferingManager->fNoWaitHandlerActive)) {
        pBufferingManager->fNoWaitHandlerActive = ActivateHandler;
    }

    KeReleaseSpinLock(&pBufferingManager->SpinLock,SavedIrql);

    // Note that in this case we have a continuation of processing, from the
    // dispatcher to the handler. The reference that was taken to protect the
    // dispatcher is transferred to the handling routine. If continuation
    // is not required the SRV_CALL instance is dereferenced.

    if (ActivateHandler) {
        RxProcessChangeBufferingStateRequests(pSrvCall);
    } else {
        RxDereferenceSrvCall(pSrvCall,LHS_LockNotHeld);
    }

    // Discard the requests for which the SRV_OPEN instance cannot be located.
    // This will cover all the instances for which a buffering change request
    // and a close crossed on the wire.

    RxpDiscardChangeBufferingStateRequests(&DiscardedRequests);
}

VOID
RxpProcessChangeBufferingStateRequests(
    PSRV_CALL  pSrvCall,
    BOOLEAN    UpdateHandlerState)
/*++

Routine Description:

    This routine initiates the actual processing of change buffering state requests.

Arguments:

    pSrvCall   - the SRV_CALL instance

Return Value:

    none.

Notes:

    The change buffering requests are received for different FCB's. If the attempt
    is made to handle these requests in the order they are received teh average
    response time for completing a change buffering state request can be arbitratily
    high. This is because the FCB needs to be acquired exclusively to complete
    processing the request. In order to avoid this case the buffering manager
    adopts a two pronged strategy -- a first attempt is made to acquire the FCB
    exclusively without waiting. If this attempt fails the requests are transferred
    to a last chance handler list. This combined with the processing of change
    buffering state requests on FCB acquisition/release ensures that most requests
    are processed with a very short turn around time.

--*/
{
    KIRQL SavedIrql;

    PLIST_ENTRY pLastChanceHandlerListEntry;
    PLIST_ENTRY pListEntry;

    PCHANGE_BUFFERING_STATE_REQUEST pRequest = NULL;
    PRX_BUFFERING_MANAGER pBufferingManager;

    PSRV_OPEN pSrvOpen;

    BOOLEAN ActivateLastChanceHandler;

    RxLog(("RPCBSR Entry SrvCall(%lx) \n", pSrvCall));
    RxWmiLog(LOG,
             RxpProcessChangeBufferingStateRequests_1,
             LOGPTR(pSrvCall));

    pBufferingManager = &pSrvCall->BufferingManager;

    pLastChanceHandlerListEntry = pListEntry = NULL;

    for (;;) {
        pListEntry                = NULL;
        ActivateLastChanceHandler = FALSE;

        RxAcquireBufferingManagerMutex(pBufferingManager);

        KeAcquireSpinLock(&pBufferingManager->SpinLock,&SavedIrql);

        // Pick a request from the handler list for change buffering state
        // processing.

        if (!IsListEmpty(&pBufferingManager->HandlerList)) {
            pListEntry = RemoveHeadList(&pBufferingManager->HandlerList);
        }

        // If the FCB fro the previously picked request could not be acquired
        // exclusively without waiting it needs to be transferred to the last
        // chance handler list and the last chance handler activated if
        // required.

        if (pLastChanceHandlerListEntry != NULL) {
            // Insert the entry into the last chance handler list.
            InsertTailList(
                &pBufferingManager->LastChanceHandlerList,
                pLastChanceHandlerListEntry);

            // reinitialize for the next pass.
            pLastChanceHandlerListEntry = NULL;

            // prepare for spinning up the last chance handler.
            if (!pBufferingManager->fLastChanceHandlerActive &&
                !IsListEmpty(&pBufferingManager->LastChanceHandlerList)) {
                pBufferingManager->fLastChanceHandlerActive = TRUE;
                ActivateLastChanceHandler = TRUE;
            }
        }

        // No more requests to be handled. Prepare for wind down.

        if ((pListEntry == NULL) &&
            UpdateHandlerState) {
            pBufferingManager->fNoWaitHandlerActive = FALSE;
        }

        KeReleaseSpinLock(&pBufferingManager->SpinLock,SavedIrql);

        RxReleaseBufferingManagerMutex(pBufferingManager);

        // spin up the last chance handler for processing the requests if required.
        if (ActivateLastChanceHandler) {
            // Reference the SRV_CALL instance to ensure that it will not be
            // finalized while the worker thread request is in the scheduler
            RxReferenceSrvCall(pSrvCall);
            RxPostToWorkerThread(
                RxFileSystemDeviceObject,
                DelayedWorkQueue,
                &pBufferingManager->LastChanceHandlerWorkItem,
                RxLastChanceHandlerForChangeBufferingStateRequests,
                pSrvCall);

            ActivateLastChanceHandler = FALSE;
        }

        if (pListEntry == NULL) {
            break;
        }

        pRequest = (PCHANGE_BUFFERING_STATE_REQUEST)
                   CONTAINING_RECORD(
                       pListEntry,
                       CHANGE_BUFFERING_STATE_REQUEST,
                       ListEntry);

        RxLog(("Proc. Req. SrvOpen (%lx) \n",pRequest->pSrvOpen));
        RxWmiLog(LOG,
                 RxpProcessChangeBufferingStateRequests_2,
                 LOGPTR(pRequest->pSrvOpen));

        if (RxPrepareRequestForHandling(pRequest) == STATUS_SUCCESS) {
            // Try to acquire the FCB without waiting. If the FCB is currently unavailable
            // then it is guaranteed that this request will be processed when the FCB
            // resource is released.

            ASSERT(pRequest->pSrvOpen != NULL);

            if (RxAcquireExclusiveFcb(
                    CHANGE_BUFFERING_STATE_CONTEXT,
                    pRequest->pSrvOpen->Fcb) == STATUS_SUCCESS) {
                BOOLEAN FcbFinalized;
                PFCB    pFcb;

                RxLog(("Proc. Req. SrvOpen FCB (%lx) \n",pRequest->pSrvOpen->Fcb));
                RxWmiLog(LOG,
                         RxpProcessChangeBufferingStateRequests_3,
                         LOGPTR(pRequest->pSrvOpen->Fcb));

                pSrvOpen           = pRequest->pSrvOpen;
                pFcb               = pSrvOpen->Fcb;

                RxReferenceNetFcb(pFcb);

                if (!FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_CLOSED)) {
                    RxDbgTrace(0,Dbg,("SrvOpenKey(%lx) being processed(Last Resort)\n",pRequest->SrvOpenKey));

                    RxLog(("SOKey(%lx) processed(Last Resort)\n",pRequest->SrvOpenKey));
                    RxWmiLog(LOG,
                             RxpProcessChangeBufferingStateRequests_4,
                             LOGPTR(pRequest->SrvOpenKey));

                    RxChangeBufferingState(pSrvOpen,pRequest->pMRxContext,TRUE);
                }

                RxAcquireSerializationMutex();

                ClearFlag(pSrvOpen->Flags,SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING);
                ClearFlag(pSrvOpen->Fcb->FcbState,FCB_STATE_BUFFERING_STATE_CHANGE_PENDING);
                KeSetEvent(pSrvOpen->Fcb->pBufferingStateChangeCompletedEvent,IO_NETWORK_INCREMENT,FALSE);

                RxReleaseSerializationMutex();

                RxPrepareRequestForReuse(pRequest);

                FcbFinalized = RxDereferenceAndFinalizeNetFcb(
                                   pFcb,
                                   CHANGE_BUFFERING_STATE_CONTEXT_WAIT,
                                   FALSE,
                                   FALSE);

                if (!FcbFinalized) {
                    RxReleaseFcb(CHANGE_BUFFERING_STATE_CONTEXT,pFcb);
                }

                RxFreePool(pRequest);
            } else {
                // The FCB has been currently accquired. Transfer the change buffering state
                // request to the last chance handler list. This will ensure that the
                // change buffering state request is processed in all cases, i.e.,
                // accquisition of the resource in shared mode as well as the acquistion
                // of the FCB resource by other components ( cache manager/memory manager )
                // without going through the wrapper.

                pLastChanceHandlerListEntry = &pRequest->ListEntry;
            }
        } else {
            RxPrepareRequestForReuse(pRequest);
            RxFreePool(pRequest);
        }
    }

    // Dereference the SRV_CALL instance.
    RxDereferenceSrvCall(pSrvCall,LHS_LockNotHeld);

    RxLog(("RPCBSR Exit SrvCall(%lx)\n",pSrvCall));
    RxWmiLog(LOG,
             RxpProcessChangeBufferingStateRequests_5,
             LOGPTR(pSrvCall));
}

VOID
RxProcessChangeBufferingStateRequests(
    PSRV_CALL  pSrvCall)
/*++

Routine Description:

    This routine is the last chance handler for processing change buffering state
    requests

Arguments:

    pSrvCall -- the SrvCall instance

Notes:

    Since the reference for the srv call instance was accquired at DPC undo
    the scavenger marking if required.

--*/
{
    RxUndoScavengerFinalizationMarking(
        pSrvCall);

    RxpProcessChangeBufferingStateRequests(
        pSrvCall,
        TRUE);
}

VOID
RxLastChanceHandlerForChangeBufferingStateRequests(
    PSRV_CALL pSrvCall)
/*++

Routine Description:

    This routine is the last chance handler for processing change buffering state
    requests

Arguments:


Return Value:

    none.

Notes:

    This routine exists because Mm/Cache manager manipulate the header resource
    associated with the FCB directly in some cases. In such cases it is not possible
    to determine whether the release is done through the wrapper. In such cases it
    is important to have a thread actually wait on the FCB resource to be released
    and subsequently process the buffering state request as a last resort mechanism.

    This also handles the case when the FCB is accquired shared. In such cases the
    change buffering state has to be completed in the context of a thread which can
    accquire it exclusively.

    The filtering of the requests must be further optimized by marking the FCB state
    during resource accquisition by the wrapper so that requests do not get downgraded
    easily. ( TO BE IMPLEMENTED )

--*/
{
    KIRQL SavedIrql;

    PLIST_ENTRY pListEntry;

    LIST_ENTRY  FinalizationList;

    PRX_BUFFERING_MANAGER           pBufferingManager;
    PCHANGE_BUFFERING_STATE_REQUEST pRequest = NULL;

    PSRV_OPEN pSrvOpen;
    BOOLEAN   FcbFinalized,FcbAcquired;
    PFCB      pFcb;

    RxLog(("RLCHCBSR Entry SrvCall(%lx)\n",pSrvCall));
    RxWmiLog(LOG,
             RxLastChanceHandlerForChangeBufferingStateRequests_1,
             LOGPTR(pSrvCall));

    InitializeListHead(&FinalizationList);

    pBufferingManager = &pSrvCall->BufferingManager;

    for (;;) {
        RxAcquireBufferingManagerMutex(pBufferingManager);
        KeAcquireSpinLock(&pBufferingManager->SpinLock,&SavedIrql);

        if (!IsListEmpty(&pBufferingManager->LastChanceHandlerList)) {
            pListEntry = RemoveHeadList(&pBufferingManager->LastChanceHandlerList);
        } else {
            pListEntry = NULL;
            pBufferingManager->fLastChanceHandlerActive = FALSE;
        }

        KeReleaseSpinLock(&pBufferingManager->SpinLock,SavedIrql);
        RxReleaseBufferingManagerMutex(pBufferingManager);

        if (pListEntry == NULL) {
            break;
        }

        pRequest = (PCHANGE_BUFFERING_STATE_REQUEST)
                   CONTAINING_RECORD(
                       pListEntry,
                       CHANGE_BUFFERING_STATE_REQUEST,
                       ListEntry);

        pSrvOpen = pRequest->pSrvOpen;
        pFcb     = pSrvOpen->Fcb;

        RxReferenceNetFcb(pFcb);

        FcbAcquired = (RxAcquireExclusiveFcb(
                          CHANGE_BUFFERING_STATE_CONTEXT_WAIT,
                          pRequest->pSrvOpen->Fcb) == STATUS_SUCCESS);

        if (FcbAcquired && !FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_CLOSED)) {
            RxDbgTrace(0,Dbg,("SrvOpenKey(%lx) being processed(Last Resort)\n",pRequest->SrvOpenKey));

            RxLog(("SOKey(%lx) processed(Last Resort)\n",pRequest->SrvOpenKey));
            RxWmiLog(LOG,
                     RxLastChanceHandlerForChangeBufferingStateRequests_2,
                     LOGPTR(pRequest->SrvOpenKey));

            RxChangeBufferingState(pSrvOpen,pRequest->pMRxContext,TRUE);
        }

        RxAcquireSerializationMutex();
        ClearFlag(pSrvOpen->Flags,SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING);
        ClearFlag(pSrvOpen->Fcb->FcbState,FCB_STATE_BUFFERING_STATE_CHANGE_PENDING);
        KeSetEvent(pSrvOpen->Fcb->pBufferingStateChangeCompletedEvent,IO_NETWORK_INCREMENT,FALSE);
        RxReleaseSerializationMutex();

        InsertTailList(&FinalizationList,pListEntry);

        if (FcbAcquired) {
            RxReleaseFcb(CHANGE_BUFFERING_STATE_CONTEXT,pFcb);
        }
    }

    while (!IsListEmpty(&FinalizationList)) {
        pListEntry = RemoveHeadList(&FinalizationList);

        pRequest = (PCHANGE_BUFFERING_STATE_REQUEST)
                   CONTAINING_RECORD(
                       pListEntry,
                       CHANGE_BUFFERING_STATE_REQUEST,
                       ListEntry);

        pSrvOpen = pRequest->pSrvOpen;
        pFcb     = pSrvOpen->Fcb;

        FcbAcquired = (RxAcquireExclusiveFcb(
                          CHANGE_BUFFERING_STATE_CONTEXT_WAIT,
                          pRequest->pSrvOpen->Fcb) == STATUS_SUCCESS);

        ASSERT(FcbAcquired == TRUE);

        RxPrepareRequestForReuse(pRequest);

        FcbFinalized = RxDereferenceAndFinalizeNetFcb(
                           pFcb,
                           CHANGE_BUFFERING_STATE_CONTEXT_WAIT,
                           FALSE,
                           FALSE);

        if (!FcbFinalized && FcbAcquired) {
            RxReleaseFcb(CHANGE_BUFFERING_STATE_CONTEXT,pFcb);
        }

        RxFreePool(pRequest);
    }

    RxLog(("RLCHCBSR Exit SrvCall(%lx)\n",pSrvCall));
    RxWmiLog(LOG,
             RxLastChanceHandlerForChangeBufferingStateRequests_3,
             LOGPTR(pSrvCall));

    // Dereference the SRV_CALL instance.
    RxDereferenceSrvCall(pSrvCall, LHS_LockNotHeld);
}


VOID
RxProcessFcbChangeBufferingStateRequest(
    PFCB  pFcb)
/*++

Routine Description:

    This routine processes all the outstanding change buffering state request for a
    FCB.

Arguments:

    pFcb - the FCB instance

Return Value:

    none.

Notes:

    The FCB instance must be acquired exclusively on entry to this routine and
    its ownership will remain invariant on exit.

--*/
{
    PSRV_CALL   pSrvCall;

    LIST_ENTRY  FcbRequestList;
    PLIST_ENTRY pListEntry;

    PRX_BUFFERING_MANAGER           pBufferingManager;
    PCHANGE_BUFFERING_STATE_REQUEST pRequest = NULL;

    PAGED_CODE();

    RxLog(("RPFcbCBSR Entry FCB(%lx)\n",pFcb));
    RxWmiLog(LOG,
             RxProcessFcbChangeBufferingStateRequest_1,
             LOGPTR(pFcb));

    pSrvCall = (PSRV_CALL)pFcb->VNetRoot->NetRoot->SrvCall;
    pBufferingManager = &pSrvCall->BufferingManager;

    InitializeListHead(&FcbRequestList);

    // Walk through the list of SRV_OPENS associated with this FCB and pick up
    // the requests that can be dispatched.

    RxAcquireBufferingManagerMutex(pBufferingManager);

    pListEntry = pFcb->SrvOpenList.Flink;
    while (pListEntry != &pFcb->SrvOpenList) {
        PSRV_OPEN pSrvOpen;

        pSrvOpen = (PSRV_OPEN)
                   (CONTAINING_RECORD(
                        pListEntry,
                        SRV_OPEN,
                        SrvOpenQLinks));
        pListEntry = pListEntry->Flink;

        RxGatherRequestsForSrvOpen(pSrvCall,pSrvOpen,&FcbRequestList);
    }

    RxReleaseBufferingManagerMutex(pBufferingManager);

    if (!IsListEmpty(&FcbRequestList)) {
        // Initiate buffering state change processing.
        pListEntry = FcbRequestList.Flink;
        while (pListEntry != &FcbRequestList) {
            NTSTATUS Status = STATUS_SUCCESS;

            pRequest = (PCHANGE_BUFFERING_STATE_REQUEST)
                       CONTAINING_RECORD(
                           pListEntry,
                           CHANGE_BUFFERING_STATE_REQUEST,
                           ListEntry);

            pListEntry = pListEntry->Flink;

            if (RxPrepareRequestForHandling(pRequest) == STATUS_SUCCESS) {
                if (!FlagOn(pRequest->pSrvOpen->Flags,SRVOPEN_FLAG_CLOSED)) {
                    RxDbgTrace(0,Dbg,("****** SrvOpenKey(%lx) being processed\n",pRequest->SrvOpenKey));
                    RxLog(("****** SOKey(%lx) being processed\n",pRequest->SrvOpenKey));
                    RxWmiLog(LOG,
                             RxProcessFcbChangeBufferingStateRequest_2,
                             LOGPTR(pRequest->SrvOpenKey));
                    RxChangeBufferingState(pRequest->pSrvOpen,pRequest->pMRxContext,TRUE);
                } else {
                    RxDbgTrace(0,Dbg,("****** 123 SrvOpenKey(%lx) being ignored\n",pRequest->SrvOpenKey));
                    RxLog(("****** 123 SOKey(%lx) ignored\n",pRequest->SrvOpenKey));
                    RxWmiLog(LOG,
                             RxProcessFcbChangeBufferingStateRequest_3,
                             LOGPTR(pRequest->SrvOpenKey));
                }
            }
        }

        // Discard the requests.
        RxpDiscardChangeBufferingStateRequests(&FcbRequestList);
    }

    RxLog(("RPFcbCBSR Exit FCB(%lx)\n",pFcb));
    RxWmiLog(LOG,
             RxProcessFcbChangeBufferingStateRequest_4,
             LOGPTR(pFcb));


    // All buffering state change requests have been processed, clear the flag
    // and signal the event as necessary.
    RxAcquireSerializationMutex();

    // update the FCB state.
    ClearFlag(pFcb->FcbState,FCB_STATE_BUFFERING_STATE_CHANGE_PENDING);
    if( pFcb->pBufferingStateChangeCompletedEvent )
        KeSetEvent(pFcb->pBufferingStateChangeCompletedEvent,IO_NETWORK_INCREMENT,FALSE);

    RxReleaseSerializationMutex();
}

VOID
RxGatherRequestsForSrvOpen(
    IN OUT PSRV_CALL   pSrvCall,
    IN     PSRV_OPEN   pSrvOpen,
    IN OUT PLIST_ENTRY pRequestsListHead)
/*++

Routine Description:

    This routine gathers all the change buffering state requests associated with a SRV_OPEN.
    This routine provides the mechanism for gathering all the requests for a SRV_OPEN which
    is then used bu routines which process them

Arguments:

    pSrvCall - the SRV_CALL instance

    pSrvOpen - the SRV_OPEN instance

    pRequestsListHead - the list of requests which is constructed by this routine

Notes:

    On Entry to thir routine the buffering manager Mutex must have been acquired
    and the ownership remains invariant on exit

--*/
{
    PLIST_ENTRY  pListEntry;
    LIST_ENTRY   DiscardedRequests;

    PCHANGE_BUFFERING_STATE_REQUEST pRequest;
    PRX_BUFFERING_MANAGER           pBufferingManager;

    PVOID        SrvOpenKey;

    KIRQL        SavedIrql;

    pBufferingManager = &pSrvCall->BufferingManager;

    SrvOpenKey = pSrvOpen->Key;

    // gather all the requests from the dispatcher list
    RxpDispatchChangeBufferingStateRequests(pSrvCall,pSrvOpen,&DiscardedRequests);

    KeAcquireSpinLock(
        &pSrvCall->BufferingManager.SpinLock,
        &SavedIrql);

    // gather all the requests with the given SrvOpenKey in the handler list
    pListEntry = pBufferingManager->HandlerList.Flink;
    while (pListEntry != &pBufferingManager->HandlerList) {
        pRequest = (PCHANGE_BUFFERING_STATE_REQUEST)
                   CONTAINING_RECORD(
                       pListEntry,
                       CHANGE_BUFFERING_STATE_REQUEST,
                       ListEntry);
        pListEntry = pListEntry->Flink;

        if (pRequest->SrvOpenKey == SrvOpenKey) {
            RemoveEntryList(&pRequest->ListEntry);
            InsertHeadList(pRequestsListHead,&pRequest->ListEntry);
        }
    }

    KeReleaseSpinLock(
        &pSrvCall->BufferingManager.SpinLock,
        SavedIrql);

    // gather all the requests from the last chance handler list
    pListEntry = pBufferingManager->LastChanceHandlerList.Flink;
    while (pListEntry != &pBufferingManager->LastChanceHandlerList) {
        pRequest = (PCHANGE_BUFFERING_STATE_REQUEST)
                   CONTAINING_RECORD(
                       pListEntry,
                       CHANGE_BUFFERING_STATE_REQUEST,
                       ListEntry);
        pListEntry = pListEntry->Flink;

        if (pRequest->SrvOpenKey == pSrvOpen->Key) {
            RemoveEntryList(&pRequest->ListEntry);
            InsertHeadList(pRequestsListHead,&pRequest->ListEntry);
        }
    }

    RxpDiscardChangeBufferingStateRequests(&DiscardedRequests);
}

VOID
RxPurgeChangeBufferingStateRequestsForSrvOpen(
    IN PSRV_OPEN pSrvOpen)
/*++

Routine Description:

    The routine purges all the requests associated with a given SRV_OPEN. This will ensure
    that all buffering state change requests received while the SRV_OPEN was being closed
    will be flushed out.

Arguments:

    pSrvOpen - the SRV_OPEN instance

Notes:

--*/
{
    PSRV_CALL             pSrvCall          = (PSRV_CALL)pSrvOpen->Fcb->VNetRoot->NetRoot->SrvCall;
    PRX_BUFFERING_MANAGER pBufferingManager = &pSrvCall->BufferingManager;

    LIST_ENTRY   DiscardedRequests;

    PAGED_CODE();

    ASSERT(RxIsFcbAcquiredExclusive(pSrvOpen->Fcb));

    InitializeListHead(&DiscardedRequests);

    RxAcquireBufferingManagerMutex(pBufferingManager);

    RemoveEntryList(&pSrvOpen->SrvOpenKeyList);

    InitializeListHead(&pSrvOpen->SrvOpenKeyList);
    SetFlag(pSrvOpen->Flags,SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_REQUESTS_PURGED);

    RxGatherRequestsForSrvOpen(pSrvCall,pSrvOpen,&DiscardedRequests);

    RxReleaseBufferingManagerMutex(pBufferingManager);

    if (!IsListEmpty(&DiscardedRequests)) {
        if (BooleanFlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING)) {

            RxAcquireSerializationMutex();

            ClearFlag(
                pSrvOpen->Fcb->FcbState,
                FCB_STATE_BUFFERING_STATE_CHANGE_PENDING);

            if (pSrvOpen->Fcb->pBufferingStateChangeCompletedEvent != NULL) {
                KeSetEvent(
                    pSrvOpen->Fcb->pBufferingStateChangeCompletedEvent,
                    IO_NETWORK_INCREMENT,
                    FALSE);
            }

            RxReleaseSerializationMutex();
        }

        RxpDiscardChangeBufferingStateRequests(&DiscardedRequests);
    }
}

VOID
RxProcessChangeBufferingStateRequestsForSrvOpen(
    PSRV_OPEN pSrvOpen)
/*++

Routine Description:

    The routine processes all the requests associated with a given SRV_OPEN.
    Since this routine is called from a fastio path it tries to defer lock accquistion
    till it is required

Arguments:

    pSrvOpen - the SRV_OPEN instance

Notes:

--*/
{
    LONG      OldBufferingToken;
    PSRV_CALL pSrvCall;
    PFCB      pFcb;

    pSrvCall = (PSRV_CALL)pSrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    pFcb     = (PFCB)pSrvOpen->pFcb;

    // If change buffering state requests have been received for this srvcall
    // since the last time the request was processed ensure that we process
    // all these requests now.
    OldBufferingToken = pSrvOpen->BufferingToken;

    if (InterlockedCompareExchange(
            &pSrvOpen->BufferingToken,
            pSrvCall->BufferingManager.CumulativeNumberOfBufferingChangeRequests,
            pSrvCall->BufferingManager.CumulativeNumberOfBufferingChangeRequests)
        != OldBufferingToken) {
        if (RxAcquireExclusiveFcb(NULL,pFcb) == STATUS_SUCCESS) {

            RxProcessFcbChangeBufferingStateRequest(pFcb);

            RxReleaseFcb(NULL,pFcb);
        }
    }
}

VOID
RxInitiateSrvOpenKeyAssociation(
    IN OUT PSRV_OPEN pSrvOpen)
/*++

Routine Description:

    This routine prepares a SRV_OPEN instance for SrvOpenKey association.

Arguments:

    pSrvOpen - the SRV_OPEN instance

Notes:

    The process of key association is a two phase protocol. In the initialization process
    a sequence number is stowed away in the SRV_OPEN. When the
    RxCompleteSrvOpenKeyAssociation routine is called the sequence number is used to
    update the data structures associated with the SRV_CALL instance. This is required
    because of the asynchronous nature of receiving buffering state change indications
    (oplock breaks in SMB terminology ) before the open is completed.

--*/
{
    KIRQL SavedIrql;

    PSRV_CALL             pSrvCall          = (PSRV_CALL)pSrvOpen->Fcb->VNetRoot->NetRoot->SrvCall;
    PRX_BUFFERING_MANAGER pBufferingManager = &pSrvCall->BufferingManager;

    PAGED_CODE();

    pSrvOpen->Key = NULL;

    InterlockedIncrement(&pBufferingManager->NumberOfOutstandingOpens);

    InitializeListHead(&pSrvOpen->SrvOpenKeyList);
}

VOID
RxCompleteSrvOpenKeyAssociation(
    IN OUT PSRV_OPEN    pSrvOpen)
/*++

Routine Description:

    The routine associates the given key with the SRV_OPEN instance

Arguments:

    pMRxSrvOpen - the SRV_OPEN instance

    SrvOpenKey  - the key to be associated with the instance

Notes:

    This routine in addition to establishing the mapping also ensures that any pending
    buffering state change requests are handled correctly. This ensures that change
    buffering state requests received during the duration of SRV_OPEN construction
    will be handled immediately.

--*/
{
    KIRQL SavedIrql;

    BOOLEAN ActivateHandler = FALSE;

    ULONG Index = 0;

    PSRV_CALL             pSrvCall          = (PSRV_CALL)pSrvOpen->Fcb->VNetRoot->NetRoot->SrvCall;
    PRX_BUFFERING_MANAGER pBufferingManager = &pSrvCall->BufferingManager;

    LIST_ENTRY            DiscardedRequests;

    // Associate the SrvOpenKey with the SRV_OPEN instance and also dispatch the
    // associated change buffering state request if any.

    InterlockedDecrement(&pBufferingManager->NumberOfOutstandingOpens);

    if (pSrvOpen->Condition == Condition_Good) {
        InitializeListHead(&DiscardedRequests);

        RxAcquireBufferingManagerMutex(pBufferingManager);

        InsertTailList(
            &pBufferingManager->SrvOpenLists[Index],
            &pSrvOpen->SrvOpenKeyList);

        RxpDispatchChangeBufferingStateRequests(
            pSrvCall,
            pSrvOpen,
            &DiscardedRequests);

        RxReleaseBufferingManagerMutex(pBufferingManager);

        KeAcquireSpinLock(
            &pBufferingManager->SpinLock,
            &SavedIrql);

        if (!IsListEmpty(&pBufferingManager->HandlerList) &&
            (ActivateHandler = !pBufferingManager->fNoWaitHandlerActive)) {
            pBufferingManager->fNoWaitHandlerActive = ActivateHandler;
        }

        KeReleaseSpinLock(
            &pBufferingManager->SpinLock,
            SavedIrql);

        if (ActivateHandler) {
            // Reference the SRV_CALL instance to ensure that it will not be
            // finalized while the worker thread request is in the scheduler
            RxReferenceSrvCall(pSrvCall);

            RxPostToWorkerThread(
                RxFileSystemDeviceObject,
                HyperCriticalWorkQueue,
                &pBufferingManager->HandlerWorkItem,
                RxProcessChangeBufferingStateRequests,
                pSrvCall);
        }

        RxpDiscardChangeBufferingStateRequests(&DiscardedRequests);
    }
}

NTSTATUS
RxpLookupSrvOpenForRequestLite(
    IN  PSRV_CALL                       pSrvCall,
    IN  PCHANGE_BUFFERING_STATE_REQUEST pRequest)
/*++

Routine Description:

    The routine looks up the SRV_OPEN instance associated with a buffering state change
    request.

Arguments:

    pSrvCall - the SRV_CALL instance

    pRequest - the buffering state change request

Return Value:

    STATUS_SUCCESS - the SRV_OPEN instance was found

    STATUS_PENDING - the SRV_OPEN instance was not found but there are open requests
                     outstanding

    STATUS_NOT_FOUND - the SRV_OPEN instance was not found.

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRX_BUFFERING_MANAGER pBufferingManager = &pSrvCall->BufferingManager;

    ULONG       Index = 0;

    PSRV_OPEN   pSrvOpen = NULL;
    PLIST_ENTRY pListHead,pListEntry;

    PAGED_CODE();

    pListHead = &pBufferingManager->SrvOpenLists[Index];

    pListEntry = pListHead->Flink;
    while (pListEntry != pListHead) {
        pSrvOpen = (PSRV_OPEN)
                   CONTAINING_RECORD(
                       pListEntry,
                       SRV_OPEN,
                       SrvOpenKeyList);

        if ((pSrvOpen->Key == pRequest->SrvOpenKey) &&
            (!FlagOn(pSrvOpen->pFcb->FcbState,FCB_STATE_ORPHANED))) {
            RxReferenceSrvOpen(pSrvOpen);
            break;
        }

        pListEntry = pListEntry->Flink;
    }

    if (pListEntry == pListHead) {
        pSrvOpen = NULL;

        if (pBufferingManager->NumberOfOutstandingOpens == 0) {
            Status = STATUS_NOT_FOUND;
        } else {
            Status = STATUS_PENDING;
        }
    }

    pRequest->pSrvOpen = pSrvOpen;

    return Status;
}

#define RxIsFcbOpenedExclusively(FCB) ( ((FCB)->ShareAccess.SharedRead \
                                            + (FCB)->ShareAccess.SharedWrite \
                                            + (FCB)->ShareAccess.SharedDelete) == 0 )

NTSTATUS
RxChangeBufferingState (
    PSRV_OPEN SrvOpen,
    PVOID     Context,
    BOOLEAN   ComputeNewState)
/*++

Routine Description:

    This routine is called to process a buffering state change request.

Arguments:

    SrvOpen - the SrvOpen to be changed;

    Context - the context parameter for mini rdr callback.

    ComputeNewState - determines if the new state is to be computed.

Return Value:

Notes:

    On entry to this routine the FCB must have been accquired exclusive.

    On exit there is no change in resource ownership

--*/
{
    ULONG    NewBufferingState, OldBufferingState;
    PFCB     Fcb = SrvOpen->Fcb;
    NTSTATUS FlushStatus = STATUS_SUCCESS;

    PAGED_CODE();

#define LOSING_CAPABILITY(a) ((NewBufferingState&(a))<(OldBufferingState&(a)))

    RxDbgTrace(+1, Dbg, ("RxChangeBufferingState   SrvOpen=%08lx, Context=%08lx\n", SrvOpen, Context ));
    RxLog(("ChangeBufferState %lx %lx\n", SrvOpen, Context ));
    RxWmiLog(LOG,
             RxChangeBufferingState_1,
             LOGPTR(SrvOpen)
             LOGPTR(Context));
    ASSERT ( NodeTypeIsFcb(Fcb) );

    SetFlag(Fcb->FcbState,FCB_STATE_BUFFERSTATE_CHANGING); //this is informational for error recovery

    try {

        if (ComputeNewState) {
            NTSTATUS Status;

            RxDbgTrace(0,Dbg,("RxChangeBufferingState FCB(%lx) Compute New State\n",Fcb));
            // Compute the new buffering state with the help of the mini redirector
            MINIRDR_CALL_THROUGH(
                Status,
                Fcb->MRxDispatch,
                MRxComputeNewBufferingState,
                ((PMRX_SRV_OPEN)SrvOpen,Context,&NewBufferingState));

            if (Status != STATUS_SUCCESS) {
                NewBufferingState = 0;
            }
        } else {
            NewBufferingState = SrvOpen->BufferingFlags;
        }

        if (RxIsFcbOpenedExclusively(Fcb) &&
            !ComputeNewState){
            NewBufferingState |= (FCB_STATE_WRITECACHEING_ENABLED  |
                                  FCB_STATE_FILESIZECACHEING_ENABLED  |
                                  FCB_STATE_FILETIMECACHEING_ENABLED  |
                                  FCB_STATE_WRITEBUFFERING_ENABLED |
                                  FCB_STATE_LOCK_BUFFERING_ENABLED |
                                  FCB_STATE_READBUFFERING_ENABLED  |
                                  FCB_STATE_READCACHEING_ENABLED);
        }

        if (Fcb->OutstandingLockOperationsCount != 0) {
            NewBufferingState &= ~FCB_STATE_LOCK_BUFFERING_ENABLED;
        }

        OldBufferingState = Fcb->FcbState & FCB_STATE_BUFFERING_STATE_MASK;
        RxDbgTrace(0, Dbg, ("-->   OldBS=%08lx, NewBS=%08lx, SrvOBS = %08lx\n",
                             OldBufferingState, NewBufferingState, SrvOpen->BufferingFlags ));
        RxLog(("CBS-2 %lx %lx %lx\n", OldBufferingState, NewBufferingState, SrvOpen->BufferingFlags ));
        RxWmiLog(LOG,
                 RxChangeBufferingState_2,
                 LOGULONG(OldBufferingState)
                 LOGULONG(NewBufferingState)
                 LOGULONG(SrvOpen->BufferingFlags));

        RxDbgTrace(0,Dbg,("RxChangeBufferingState FCB(%lx) Old (%lx)  New (%lx)\n",Fcb,OldBufferingState,NewBufferingState));

        // Fcb->FcbState &= ~FCB_STATE_BUFFERING_STATE_MASK;
        if(LOSING_CAPABILITY(FCB_STATE_WRITECACHEING_ENABLED)){
            RxDbgTrace(0, Dbg, ("-->flush\n", 0 ));
            RxLog(("CBS-Flush"));
            RxWmiLog(LOG,
                     RxChangeBufferingState_3,
                     LOGPTR(Fcb));
            //CcFlushCache(&Fcb->NonPaged->SectionObjectPointers,NULL,0,NULL );
            FlushStatus = RxFlushFcbInSystemCache(Fcb,FALSE);
        }

        // If there are no handles to this file or it the read caching capability
        // is lost the file needs to be purged. This will force the memory
        // manager to relinquish the additional reference on the file.

        if ((Fcb->UncleanCount == 0) ||
            (LOSING_CAPABILITY(FCB_STATE_READCACHEING_ENABLED)
               || FlagOn(NewBufferingState, MINIRDR_BUFSTATE_COMMAND_FORCEPURGE))) {
            RxDbgTrace(0, Dbg, ("-->purge\n", 0 ));
            RxLog(("CBS-purge\n"));
            RxWmiLog(LOG,
                     RxChangeBufferingState_4,
                     LOGPTR(Fcb));
            if( !NT_SUCCESS(FlushStatus) )
            {
                RxCcLogError( (PDEVICE_OBJECT)Fcb->RxDeviceObject,
                            &Fcb->PrivateAlreadyPrefixedName,
                            IO_LOST_DELAYED_WRITE,
                            FlushStatus,
                            IRP_MJ_WRITE,
                            Fcb );
            }
            CcPurgeCacheSection(
                &Fcb->NonPaged->SectionObjectPointers,
                NULL,
                0,
                FALSE );
        }

        // the wrapper does not use these flags yet

        if(LOSING_CAPABILITY(FCB_STATE_WRITEBUFFERING_ENABLED)) NOTHING;
        if(LOSING_CAPABILITY(FCB_STATE_READBUFFERING_ENABLED)) NOTHING;
        if(LOSING_CAPABILITY(FCB_STATE_OPENSHARING_ENABLED)) NOTHING;
        if(LOSING_CAPABILITY(FCB_STATE_COLLAPSING_ENABLED)) NOTHING;
        if(LOSING_CAPABILITY(FCB_STATE_FILESIZECACHEING_ENABLED)) NOTHING;
        if(LOSING_CAPABILITY(FCB_STATE_FILETIMECACHEING_ENABLED)) NOTHING;

        if (ComputeNewState &&
            FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING) &&
            !IsListEmpty(&SrvOpen->FobxList)) {
            NTSTATUS Status;
            PRX_CONTEXT RxContext = NULL;

            RxContext = RxCreateRxContext(
                            NULL,
                            SrvOpen->Fcb->RxDeviceObject,
                            RX_CONTEXT_FLAG_WAIT|RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING);

            if (RxContext != NULL) {
                RxContext->pFcb  = (PMRX_FCB)Fcb;
                RxContext->pFobx = (PMRX_FOBX)
                                   (CONTAINING_RECORD(
                                       SrvOpen->FobxList.Flink,
                                       FOBX,
                                       FobxQLinks));

                RxContext->pRelevantSrvOpen = RxContext->pFobx->pSrvOpen;

                if (FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_CLOSE_DELAYED)) {
                    RxLog(("  ##### Oplock brk close %lx\n",RxContext->pFobx));
                    RxWmiLog(LOG,
                             RxChangeBufferingState_4,
                             LOGPTR(RxContext->pFobx));
                    Status = RxCloseAssociatedSrvOpen(
                                 (PFOBX)RxContext->pFobx,
                                 RxContext);
                } else {
                    MINIRDR_CALL_THROUGH(
                        Status,
                        Fcb->MRxDispatch,
                        MRxCompleteBufferingStateChangeRequest,
                        (RxContext,(PMRX_SRV_OPEN)SrvOpen,Context));
                }


                RxDereferenceAndDeleteRxContext(RxContext);
            }

            RxDbgTrace(0,Dbg,("RxChangeBuffering State FCB(%lx) Completeing buffering state change\n",Fcb));
        }

        Fcb->FcbState = ((Fcb->FcbState & ~(FCB_STATE_BUFFERING_STATE_MASK)) |
                         (FCB_STATE_BUFFERING_STATE_MASK & NewBufferingState));

    } finally {

        ClearFlag(Fcb->FcbState,FCB_STATE_BUFFERSTATE_CHANGING); //this is informational for error recovery
        ClearFlag(Fcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET);
    }

    RxDbgTrace(-1, Dbg, ("-->exit\n"));
    RxLog(("Exit-CBS\n"));
    RxWmiLog(LOG,
             RxChangeBufferingState_5,
             LOGPTR(Fcb));
    return STATUS_SUCCESS;
}


NTSTATUS
RxFlushFcbInSystemCache(
    IN PFCB     Fcb,
    IN BOOLEAN  SynchronizeWithLazyWriter
    )

/*++

Routine Description:

    This routine simply flushes the data section on a file.
    Then, it does an acquire-release on the pagingIO resource in order to
    synchronize behind any other outstanding writes if such synchronization is
    desired by the caller

Arguments:

    Fcb - Supplies the file being flushed

    SynchronizeWithLazyWriter  -- set to TRUE if the flush needs to be
                                  synchronous

Return Value:

    NTSTATUS - The Status from the flush.

--*/
{
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    //  Make sure that this thread owns the FCB.
    //  This assert is not valid because the flushing of the cache can be called from a routine
    //  that was posted to a worker thread.  Thus the FCB is acquired exclusively, but not by the
    //  current thread and this will fail.
    // ASSERT  ( RxIsFcbAcquiredExclusive ( Fcb )  );

    CcFlushCache(
        &Fcb->NonPaged->SectionObjectPointers,
        NULL,
        0,
        &Iosb ); //ok4flush

    if (SynchronizeWithLazyWriter &&
        NT_SUCCESS(Iosb.Status)) {

        RxAcquirePagingIoResource(Fcb,NULL);
        RxReleasePagingIoResource(Fcb,NULL);
    }

    RxLog(("Flushing %lx Status %lx\n",Fcb,Iosb.Status));
    RxWmiLogError(Iosb.Status,
                  LOG,
                  RxFlushFcbInSystemCache,
                  LOGPTR(Fcb)
                  LOGULONG(Iosb.Status));

    return Iosb.Status;
}

NTSTATUS
RxPurgeFcbInSystemCache(
    IN PFCB             Fcb,
    IN PLARGE_INTEGER   FileOffset OPTIONAL,
    IN ULONG            Length,
    IN BOOLEAN          UninitializeCacheMaps,
    IN BOOLEAN          FlushFile )

/*++

Routine Description:

    This routine purges the data section on a file. Before purging it flushes
    the file and ensures that there are no outstanding writes by
    Then, it does an acquire-release on the pagingIO resource in order to
    synchronize behind any other outstanding writes if such synchronization is
    desired by the caller

Arguments:

    Fcb - Supplies the file being flushed

    SynchronizeWithLazyWriter  -- set to TRUE if the flush needs to be
                                  synchronous

Return Value:

    NTSTATUS - The Status from the flush.

--*/
{
    BOOLEAN         fResult;
    NTSTATUS        Status;
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    //  Make sure that this thread owns the FCB.
    ASSERT( RxIsFcbAcquiredExclusive ( Fcb )  );

    // Flush if we need to
    if( FlushFile )
    {
        Status = RxFlushFcbInSystemCache(
                     Fcb,
                     TRUE);

        if( !NT_SUCCESS(Status) )
        {
            PVOID p1, p2;
            RtlGetCallersAddress( &p1, &p2 );
            RxLogRetail(("Flush failed %x %x, Purging anyway\n", Fcb, Status ));
            RxLogRetail(("Purge Caller = %x %x\n", p1, p2 ));

            RxCcLogError( (PDEVICE_OBJECT)Fcb->RxDeviceObject,
                        &Fcb->PrivateAlreadyPrefixedName,
                        IO_LOST_DELAYED_WRITE,
                        Status,
                        IRP_MJ_WRITE,
                        Fcb );

        }
    }

//    if (Status == STATUS_SUCCESS) {
        fResult = CcPurgeCacheSection(
                      &Fcb->NonPaged->SectionObjectPointers,
                      FileOffset,
                      Length,
                      UninitializeCacheMaps);

        if (!fResult) {
            MmFlushImageSection(
                &Fcb->NonPaged->SectionObjectPointers,
                MmFlushForWrite);

            RxReleaseFcb( NULL, Fcb );

            fResult = MmForceSectionClosed(&Fcb->NonPaged->SectionObjectPointers, TRUE);

            RxAcquireExclusiveFcb(NULL,Fcb);
        }

        Status = (fResult ? STATUS_SUCCESS
                          : STATUS_UNSUCCESSFUL);
//    }

    RxLog(("Purging %lx Status %lx\n",Fcb,Status));
    RxWmiLogError(Status,
                  LOG,
                  RxPurgeFcbInSystemCache,
                  LOGPTR(Fcb)
                  LOGULONG(Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\lowio.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LowIo.c

Abstract:

    This module implements buffer locking and mapping; also synchronous waiting for a lowlevelIO.

Author:

    JoeLinn     [JoeLinn]    12-Oct-94

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOWIO)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxLockUserBuffer)
#pragma alloc_text(PAGE, RxNewMapUserBuffer)
#pragma alloc_text(PAGE, RxMapSystemBuffer)
#pragma alloc_text(PAGE, RxInitializeLowIoContext)
#pragma alloc_text(PAGE, RxLowIoGetBufferAddress)
#pragma alloc_text(PAGE, RxLowIoSubmitRETRY)
#pragma alloc_text(PAGE, RxLowIoCompletionTail)
#pragma alloc_text(PAGE, RxLowIoCompletion)
#pragma alloc_text(PAGE, RxLowIoPopulateFsctlInfo)
#pragma alloc_text(PAGE, RxLowIoSubmit)
#pragma alloc_text(PAGE, RxInitializeLowIoPerFcbInfo)
#pragma alloc_text(PAGE, RxInitializeLowIoPerFcbInfo)
#endif

//this is a crude implementation of the insertion, deletion, and coverup operations for wimp lowio
//we'll just use a linked list for now.........
#define RxInsertIntoOutStandingPagingOperationsList(RxContext,Operation) {     \
    PLIST_ENTRY WhichList = (Operation==LOWIO_OP_READ)                        \
                               ?&capFcb->Specific.Fcb.PagingIoReadsOutstanding  \
                               :&capFcb->Specific.Fcb.PagingIoWritesOutstanding;\
    InsertTailList(WhichList,&RxContext->RxContextSerializationQLinks);      \
}
#define RxRemoveFromOutStandingPagingOperationsList(RxContext) { \
    RemoveEntryList(&RxContext->RxContextSerializationQLinks);      \
    RxContext->RxContextSerializationQLinks.Flink = NULL;        \
    RxContext->RxContextSerializationQLinks.Blink = NULL;        \
}

#ifndef WIN9X

FAST_MUTEX RxLowIoPagingIoSyncMutex;

//here we hiding the IO access flags
#define RxLockAndMapUserBufferForLowIo(RXCONTEXT,LOWIOCONTEXT,OPERATION) {\
      RxLockUserBuffer( RXCONTEXT,                                            \
                        (OPERATION==LOWIO_OP_READ)?IoWriteAccess:IoReadAccess,\
                        LOWIOCONTEXT->ParamsFor.ReadWrite.ByteCount );        \
      if (RxNewMapUserBuffer(RXCONTEXT) == NULL) Status = STATUS_INSUFFICIENT_RESOURCES; \
      LOWIOCONTEXT->ParamsFor.ReadWrite.Buffer = RxUserBufferFromContext(RXCONTEXT); \
}




//these next macros are a bit strange. the macro parameter is the RxContext.....people who have
//    not defined appropriate capture macros can access out from there. on NT, we will just use the
//    captured entities but we hide the actual field designators

#define RxIsPagingIo(RXCONTEXT) (FlagOn(capReqPacket->Flags,IRP_PAGING_IO))

#define RxUserBufferFromContext(RXCONTEXT) (capReqPacket->MdlAddress)

#if 0
//if capFcb->NetRoot is NULL, then this must be the device FCB!
#define RxGetMiniRdrDispatchForLowIo(RXCONTEXT) {\
      if (capFcb->VNetRoot != NULL) {                                          \
         pMiniRdrDispatch = capFcb->MRxDispatch;                               \
      } else {                                                                 \
         PV_NET_ROOT pVirtualNetRoot = (PV_NET_ROOT)capFileObject->FsContext2; \
         pMiniRdrDispatch = pVirtualNetRoot->NetRoot->Dispatch;                \
      }                                                                        \
}
#endif 0
#define RxGetMiniRdrDispatchForLowIo(RXCONTEXT) {\
    pMiniRdrDispatch = RxContext->RxDeviceObject->Dispatch;    \
    }

#define RxMarkPendingForLowIo(RXCONTEXT) IoMarkIrpPending(capReqPacket)
#define RxUnmarkPendingForLowIo(RXCONTEXT) {\
    capPARAMS->Control &= ~SL_PENDING_RETURNED;  \
}


#define RxGetCurrentResourceThreadForLowIo(RXCONTEXT) \
    (ExGetCurrentResourceThread())


//NT specific routines

VOID
RxLockUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )
/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

Arguments:

    RxContext - Pointer to the pointer Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    None

--*/
{
    RxCaptureRequestPacket;
    PMDL Mdl = NULL;

    PAGED_CODE();

    if (capReqPacket->MdlAddress == NULL) {

        ASSERT(!(capReqPacket->Flags & IRP_INPUT_OPERATION));

        // Allocate the Mdl, and Raise if we fail.
        if (BufferLength > 0) {
            Mdl = IoAllocateMdl(
                      capReqPacket->UserBuffer,
                      BufferLength,
                      FALSE,
                      FALSE,
                      capReqPacket );

            if (Mdl == NULL) {
                RxRaiseStatus(
                    RxContext,
                    STATUS_INSUFFICIENT_RESOURCES );
            } else {
                // Now probe the buffer described by the Irp.  If we get an exception,
                // deallocate the Mdl and return the appropriate "expected" status.

                try {
                    MmProbeAndLockPages(
                        Mdl,
                        capReqPacket->RequestorMode,
                        Operation );
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NTSTATUS Status;

                    Status = GetExceptionCode();

                    IoFreeMdl( Mdl );
                    capReqPacket->MdlAddress = NULL;

                    SetFlag(
                        RxContext->Flags,
                        RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT);

                    RxRaiseStatus(
                        RxContext,
                        (FsRtlIsNtstatusExpected(Status) ?
                            Status :
                            STATUS_INVALID_USER_BUFFER));
                }
            }
        }
    } else {
        Mdl = capReqPacket->MdlAddress;
        ASSERT(RxLowIoIsMdlLocked(Mdl));
    }
}


NTSTATUS
RxLockBuffer (
    IN PRX_CONTEXT    RxContext,
    IN PVOID          pBuffer,
    IN ULONG          BufferLength,
    IN LOCK_OPERATION Operation,
    OUT PMDL          *pBufferMdlPtr
    )
/*++

Routine Description:

    This routine locks the input buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.

Arguments:

    RxContext - Pointer to the pointer Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    pBufferMdl - a placeholder for a pointer to the locked down MDL

Return Value:

    RxStatus(SUCCESS) - if the operation was successful

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureRequestPacket;

    *pBufferMdlPtr = NULL;

    // Allocate the Mdl, and Raise if we fail.
    *pBufferMdlPtr = IoAllocateMdl(
                         pBuffer,
                         BufferLength,
                         FALSE,
                         FALSE,
                         capReqPacket);

    if (*pBufferMdlPtr == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        // probe and lock down the buffer
        try {
            MmProbeAndLockPages(
                *pBufferMdlPtr,
                capReqPacket->RequestorMode,
                Operation );

            RxProtectMdlFromFree(*pBufferMdlPtr);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NTSTATUS Status;

            Status = GetExceptionCode();

            IoFreeMdl(*pBufferMdlPtr);

            Status = FsRtlIsNtstatusExpected(Status) ?
                     Status :
                     STATUS_INVALID_USER_BUFFER;
        }
    }

    return Status;
}

PVOID
RxMapSystemBuffer (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine returns the system buffer address from the irp. the way that the code is written
    it may also decide to get the buffer address from the mdl. that is wrong because the systembuffer is
    always nonpaged so no locking/mapping is needed. thus, the mdl path now contains an assert.

Arguments:

    RxContext - Pointer to the IrpC for the request.

Return Value:

    Mapped address

--*/
{
    RxCaptureRequestPacket;

    PAGED_CODE();

    if (capReqPacket->MdlAddress == NULL) {
       return capReqPacket->AssociatedIrp.SystemBuffer;
    } else {
       ASSERT (!"there should not be an MDL in this irp!!!!!");
       return MmGetSystemAddressForMdlSafe(
                  capReqPacket->MdlAddress, NormalPagePriority );
    }
}

PVOID
RxNewMapUserBuffer (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine returns the address of the userbuffer. if an MDL exists then the assumption is that
    the mdl describes the userbuffer and the system address for the mdl is returned. otherwise, the userbuffer
    is returned directly.

Arguments:

    RxContext - Pointer to the IrpC for the request.

Return Value:

    Mapped address

--*/
{
    RxCaptureRequestPacket;

    PAGED_CODE();

    if (capReqPacket->MdlAddress == NULL) {
       return capReqPacket->UserBuffer;
    } else {
       return MmGetSystemAddressForMdlSafe(
                  capReqPacket->MdlAddress,
                  NormalPagePriority );
    }
}
#else

#define RxMarkPendingForLowIo(RXCONTEXT)
#define RxUnmarkPendingForLowIo(RXCONTEXT)

//CIA figure out how paging io works on win9x

#define RxIsPagingIo(RXCONTEXT)     FALSE
#define RxGetCurrentResourceThreadForLowIo(RXCONTEXT) 11

#define RxLockAndMapUserBufferForLowIo(RXCONTEXT,LOWIOCONTEXT,OPERATION) {\
      if(((LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer = \
         RxAllocateMdl(capReqPacket->ir_data, capReqPacket->ir_length)) \
            != NULL) {\
              NTSTATUS __Status = _RxProbeAndLockPages((LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer, \
                        KernelMode,\
                        (OPERATION==LOWIO_OP_READ)?IoWriteAccess:IoReadAccess\
                        );    \
            if (__Status != STATUS_SUCCESS) {                               \
                IoFreeMdl((LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer);      \
                (LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer = NULL;          \
            }                                                               \
      }\
}

#define RxGetMiniRdrDispatchForLowIo(RXCONTEXT) {\
         PV_NET_ROOT pVirtualNetRoot = (PV_NET_ROOT)capReqPacket->ir_rh;       \
         pMiniRdrDispatch = pVirtualNetRoot->NetRoot->Dispatch;                \
}


#endif //#ifndef WIN9X

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  from here down (except for fsctl buffer determination), everything is available for either wrapper. we may
//  decide that the fsctl stuff should be moved as well
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

VOID
RxInitializeLowIoContext(
    PLOWIO_CONTEXT LowIoContext,
    ULONG Operation
    )
/*++

Routine Description:

    This routine initializes the LowIO context in the RxContext.

Arguments:

    RxContext - context of irp being processed.

Return Value:

    none

--*/
{
    PRX_CONTEXT RxContext = CONTAINING_RECORD(LowIoContext,RX_CONTEXT,LowIoContext);
    RxCaptureRequestPacket; RxCaptureParamBlock;

    PAGED_CODE();

    ASSERT (LowIoContext = &RxContext->LowIoContext);

    KeInitializeEvent(
        &RxContext->SyncEvent,
        NotificationEvent,
        FALSE );

    //this ID is used to release the resource on behalf of another thread....
    // e.g. it is used when an async routine completes to release the thread
    //      acquired by the first acquirer.
    LowIoContext->ResourceThreadId = RxGetCurrentResourceThreadForLowIo(RxContext);

    LowIoContext->Operation = (USHORT)Operation;

    switch (Operation) {
    case LOWIO_OP_READ:
    case LOWIO_OP_WRITE:
        IF_DEBUG {
            LowIoContext->ParamsFor.ReadWrite.ByteOffset = 0xffffffee; //no operation should start there!
            LowIoContext->ParamsFor.ReadWrite.ByteCount  = 0xeeeeeeee; //no operation should start there!
        }
        ASSERT (&capPARAMS->Parameters.Read.Length == &capPARAMS->Parameters.Write.Length);
        ASSERT (&capPARAMS->Parameters.Read.Key == &capPARAMS->Parameters.Write.Key);
        LowIoContext->ParamsFor.ReadWrite.Key  = capPARAMS->Parameters.Read.Key;
        LowIoContext->ParamsFor.ReadWrite.Flags  = 0
                 | (RxIsPagingIo(RxContext)?LOWIO_READWRITEFLAG_PAGING_IO:0)
                 ;
        break;

    case LOWIO_OP_FSCTL:
    case LOWIO_OP_IOCTL:
        LowIoContext->ParamsFor.FsCtl.Flags              = 0;
        LowIoContext->ParamsFor.FsCtl.InputBufferLength  = 0;
        LowIoContext->ParamsFor.FsCtl.pInputBuffer       = NULL;
        LowIoContext->ParamsFor.FsCtl.OutputBufferLength = 0;
        LowIoContext->ParamsFor.FsCtl.pOutputBuffer      = NULL;
        LowIoContext->ParamsFor.FsCtl.MinorFunction      = 0;
        break;

    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
    case LOWIO_OP_UNLOCK_MULTIPLE:
    case LOWIO_OP_CLEAROUT:
    case LOWIO_OP_NOTIFY_CHANGE_DIRECTORY:
        break;
    default:
        ASSERT(FALSE);
    }
}

PVOID
RxLowIoGetBufferAddress (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine gets the buffer corresponding to the Mdl in the LowIoContext.

Arguments:

    RxContext - context for the request.

Return Value:

    Mapped address

--*/
{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    if (LowIoContext->ParamsFor.ReadWrite.ByteCount > 0) {
        ASSERT(LowIoContext->ParamsFor.ReadWrite.Buffer);
        return MmGetSystemAddressForMdlSafe(
                   LowIoContext->ParamsFor.ReadWrite.Buffer,
                   NormalPagePriority);
    } else {
        return NULL;
    }
}

NTSTATUS
RxLowIoSubmitRETRY (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine just calls LowIoSubmit; the completion routine was previously
    stored so we just extract it and pass it in. This is called out of the Fsp
    dispatcher for retrying at the low level.


Arguments:

    RxContext - the usual

Return Value:

    whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED).

--*/
{
    PAGED_CODE();

    return(RxLowIoSubmit(RxContext,RxContext->LowIoContext.CompletionRoutine));
}

NTSTATUS
RxLowIoCompletionTail (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine is called by lowio routines at the very end...i.e. after the individual completion
    routines are called.


Arguments:

    RxContext - the RDBSS context

Return Value:

    whatever value supplied by the caller.

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG          Operation     = LowIoContext->Operation;
    BOOLEAN  SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxLowIoCompletionTail, Operation=%08lx\n",LowIoContext->Operation));

    if (( KeGetCurrentIrql() < DISPATCH_LEVEL )
          || (FlagOn(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_CAN_COMPLETE_AT_DPC_LEVEL))  ) {
        Status = RxContext->LowIoContext.CompletionRoutine(RxContext);
    } else {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    if ( (Status == STATUS_MORE_PROCESSING_REQUIRED) || (Status == STATUS_RETRY) ) {
        RxDbgTrace(-1, Dbg, ("RxLowIoCompletionTail wierdstatus, Status=%08lx\n",Status));
        return(Status);
    }

    switch (Operation) {
    case LOWIO_OP_READ:
    case LOWIO_OP_WRITE:
        if (FlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_PAGING_IO)) {
            RxDbgTrace(0, Dbg, ("RxLowIoCompletionTail pagingio unblock\n"));

            ExAcquireFastMutexUnsafe(&RxLowIoPagingIoSyncMutex);
            RxRemoveFromOutStandingPagingOperationsList(RxContext);
            ExReleaseFastMutexUnsafe(&RxLowIoPagingIoSyncMutex);

            RxResumeBlockedOperations_ALL(RxContext);
        }
        break;

    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
    case LOWIO_OP_UNLOCK_MULTIPLE:
    case LOWIO_OP_CLEAROUT:
        break;

    case LOWIO_OP_FSCTL:
    case LOWIO_OP_IOCTL:
    case LOWIO_OP_NOTIFY_CHANGE_DIRECTORY:
        break;

    default:
        ASSERT(!"Valid Low Io Op Code");
    }

    if (!FlagOn(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_SYNCCALL)){

        //if we're being called from lowiosubmit then just get out otherwise...do the completion

        RxCompleteAsynchronousRequest( RxContext, Status );
    }

    RxDbgTrace(-1, Dbg, ("RxLowIoCompletionTail, Status=%08lx\n",Status));
    return(Status);
}

NTSTATUS
RxLowIoCompletion (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine must be called by the minirdr lowio routines when they
    complete IF THEY HAVE INITIALLY RETURNED PENDING.

    It behaves a bit differently depending on whether it's sync or
    async IO. for sync, we just get back into the user's thread. for async,
    we first try the completion routine directly....if we get MORE_PROCESSING...
    then we flip to a thread and the routine will be recalled.


Arguments:

    RxContext - the RDBSS context

Return Value:

    whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED). the value M_P_R is very handy
    if this is being called for a Irp completion; M_P_R causes the Irp completion guy to stop processing....which
    is good since the called completion routine may complete the packet!

--*/
{
    RxCaptureParamBlock;

#ifndef WIN9X
    NTSTATUS Status;
#endif
    BOOLEAN  SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    if (SynchronousIo) {
        RxSignalSynchronousWaiter(RxContext);
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

#ifdef WIN9X
    RxDbgTrace(0, Dbg, ("We SHOULD NEVER GET HERE\n"));
    ASSERT(FALSE);
#else
    RxDbgTrace(0, Dbg, ("RxLowIoCompletion ASYNC\n"));
    ASSERT (RxLowIoIsBufferLocked(&RxContext->LowIoContext));

    Status = RxLowIoCompletionTail(RxContext);

    //the called routine makes the decision as to whether it can continue.....many will ask for
    //a post if we're at DPC level.....some will not.
    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        RxFsdPostRequestWithResume(RxContext,RxLowIoCompletion);
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //i'm not too sure about this
    if (Status == STATUS_RETRY) {
        RxFsdPostRequestWithResume(RxContext,RxLowIoSubmitRETRY);
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    return(Status);
#endif
}
#if DBG
VOID
RxAssertFsctlIsLikeIoctl ()
{
    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION,Parameters.FileSystemControl.OutputBufferLength)
            == FIELD_OFFSET(IO_STACK_LOCATION,Parameters.DeviceIoControl.OutputBufferLength) );
    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION,Parameters.FileSystemControl.InputBufferLength)
            == FIELD_OFFSET(IO_STACK_LOCATION,Parameters.DeviceIoControl.InputBufferLength) );
    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION,Parameters.FileSystemControl.FsControlCode)
            == FIELD_OFFSET(IO_STACK_LOCATION,Parameters.DeviceIoControl.IoControlCode) );
    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION,Parameters.FileSystemControl.Type3InputBuffer)
            == FIELD_OFFSET(IO_STACK_LOCATION,Parameters.DeviceIoControl.Type3InputBuffer) );
}
#else
#define RxAssertFsctlIsLikeIoctl()
#endif //if DBG


NTSTATUS
NTAPI
RxLowIoPopulateFsctlInfo (
    IN PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PAGED_CODE();

    RxAssertFsctlIsLikeIoctl();

    LowIoContext->ParamsFor.FsCtl.FsControlCode =
             capPARAMS->Parameters.FileSystemControl.FsControlCode;

    LowIoContext->ParamsFor.FsCtl.InputBufferLength =
             capPARAMS->Parameters.FileSystemControl.InputBufferLength;

    LowIoContext->ParamsFor.FsCtl.OutputBufferLength =
             capPARAMS->Parameters.FileSystemControl.OutputBufferLength;


    LowIoContext->ParamsFor.FsCtl.MinorFunction = capPARAMS->MinorFunction;

    switch (LowIoContext->ParamsFor.FsCtl.FsControlCode & 3) {
    case METHOD_BUFFERED:
        {
           LowIoContext->ParamsFor.FsCtl.pInputBuffer  = capReqPacket->AssociatedIrp.SystemBuffer;
           LowIoContext->ParamsFor.FsCtl.pOutputBuffer = capReqPacket->AssociatedIrp.SystemBuffer;
        }
        break;

    case METHOD_IN_DIRECT:
    case METHOD_OUT_DIRECT:
        {
           LowIoContext->ParamsFor.FsCtl.pInputBuffer  = capReqPacket->AssociatedIrp.SystemBuffer;
           if (capReqPacket->MdlAddress!=NULL) {
               LowIoContext->ParamsFor.FsCtl.pOutputBuffer =
                   MmGetSystemAddressForMdlSafe(
                       capReqPacket->MdlAddress,
                       NormalPagePriority);

               if (LowIoContext->ParamsFor.FsCtl.pOutputBuffer == NULL) {
                   Status = STATUS_INSUFFICIENT_RESOURCES;
               }
           } else {
               LowIoContext->ParamsFor.FsCtl.pOutputBuffer = NULL;
           }
        }
        break;

    case METHOD_NEITHER:
        {
           LowIoContext->ParamsFor.FsCtl.pInputBuffer  = capPARAMS->Parameters.FileSystemControl.Type3InputBuffer;
           LowIoContext->ParamsFor.FsCtl.pOutputBuffer = capReqPacket->UserBuffer;
        }
        break;

    default:
        ASSERT(!"Valid Method for Fs Control");
        break;
    }

    return Status;
}

NTSTATUS
RxLowIoSubmit (
    IN PRX_CONTEXT RxContext,
    PLOWIO_COMPLETION_ROUTINE CompletionRoutine
    )
/*++

Routine Description:

    This routine passes the request to the minirdr after setting up for completion. it then waits
    or pends as appropriate.

Arguments:

    RxContext - the usual

Return Value:

    whatever value is returned by a callout....or by LowIoCompletion.

--*/
{
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    NTSTATUS       Status        = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG          Operation     = LowIoContext->Operation;
    BOOLEAN        SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    LowIoContext->CompletionRoutine = CompletionRoutine;

    RxDbgTrace(+1, Dbg, ("RxLowIoSubmit, Operation=%08lx\n",LowIoContext->Operation));

    switch (Operation) {
    case LOWIO_OP_READ:
    case LOWIO_OP_WRITE:
        ASSERT(LowIoContext->ParamsFor.ReadWrite.ByteOffset != 0xffffffee);
        ASSERT(LowIoContext->ParamsFor.ReadWrite.ByteCount  != 0xeeeeeeee);
        RxLockAndMapUserBufferForLowIo(RxContext,LowIoContext,Operation);
    #ifndef WIN9X
    // NT paging IO is different from WIN9X so this may be different
        if (FlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_PAGING_IO)) {
            ExAcquireFastMutexUnsafe(&RxLowIoPagingIoSyncMutex);
            RxContext->BlockedOpsMutex = &RxLowIoPagingIoSyncMutex;
            RxInsertIntoOutStandingPagingOperationsList(RxContext,Operation);
            ExReleaseFastMutexUnsafe(&RxLowIoPagingIoSyncMutex);
        }
    #else
        if (!LowIoContext->ParamsFor.ReadWrite.Buffer) {
            //
            // Couldn't get mdl for data!
            //

            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    #endif //ifndef WIN9X
            break;

    //can't do much to make this OS independent
    case LOWIO_OP_FSCTL:
    case LOWIO_OP_IOCTL:

        Status = RxLowIoPopulateFsctlInfo(RxContext);

        if (Status == STATUS_SUCCESS) {
            if ((LowIoContext->ParamsFor.FsCtl.InputBufferLength > 0) &&
                (LowIoContext->ParamsFor.FsCtl.pInputBuffer == NULL)) {
                Status = STATUS_INVALID_PARAMETER;
            }
    
            if ((LowIoContext->ParamsFor.FsCtl.OutputBufferLength > 0) &&
                (LowIoContext->ParamsFor.FsCtl.pOutputBuffer == NULL)) {
                Status = STATUS_INVALID_PARAMETER;
            }
        }

        break;

    case LOWIO_OP_NOTIFY_CHANGE_DIRECTORY:
    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
    case LOWIO_OP_UNLOCK_MULTIPLE:
    case LOWIO_OP_CLEAROUT:
        break;

    default:
        ASSERT(!"Valid Low Io Op Code");
        Status = STATUS_INVALID_PARAMETER;
    }

    SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED);

    if (Status==STATUS_SUCCESS) {
        PMINIRDR_DISPATCH pMiniRdrDispatch;

        if (!SynchronousIo) {
            //get ready for any arbitrary finish order...assume return of pending
            InterlockedIncrement(&RxContext->ReferenceCount);

            if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP)) {
                RxMarkPendingForLowIo(RxContext);
            }

            RxDbgTrace( 0, Dbg, ("RxLowIoSubmit, Operation is ASYNC!\n"));
        }

        pMiniRdrDispatch = NULL;
        RxGetMiniRdrDispatchForLowIo(RxContext);

        if (pMiniRdrDispatch != NULL) {
            do {
                RxContext->InformationToReturn = 0;
                MINIRDR_CALL(
                    Status,
                    RxContext,
                    pMiniRdrDispatch,
                    MRxLowIOSubmit[LowIoContext->Operation],
                    (RxContext));

                if (Status == STATUS_PENDING){
                    if (!SynchronousIo) {
                        goto FINALLY;
                    }
                    RxWaitSync(RxContext);
                    Status = RxContext->StoredStatus;
                } else {
                    if (!SynchronousIo && Status != STATUS_RETRY) {
                        //we were wrong about pending..so clear the bit and deref
                        if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP)) {
                            RxUnmarkPendingForLowIo(RxContext);
                        }

                        InterlockedDecrement(&RxContext->ReferenceCount);
                    }
                }
            } while (Status == STATUS_RETRY);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    //you do not come here for pended,async IO
    RxContext->StoredStatus = Status;
    SetFlag(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_SYNCCALL);
    Status = RxLowIoCompletionTail(RxContext);

FINALLY:
    RxDbgTrace(-1, Dbg, ("RxLowIoSubmit, Status=%08lx\n",Status));
    return(Status);
}


VOID
RxInitializeLowIoPerFcbInfo(
    PLOWIO_PER_FCB_INFO LowIoPerFcbInfo
    )
/*++

Routine Description:

    This routine is called in FcbInitialization to initialize the LowIo part of the structure.



Arguments:

    LowIoPerFcbInfo - the struct to be initialized

Return Value:


--*/
{
    PAGED_CODE();

    InitializeListHead(&LowIoPerFcbInfo->PagingIoReadsOutstanding);
    InitializeListHead(&LowIoPerFcbInfo->PagingIoWritesOutstanding);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\calldown.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    calldown.c

Abstract:

    This module implements the calldown routines for coordinating between multiple
    calldowns/callouts.

    Calldowns refer to invocation of a mini rdr routine by the wrapper while callouts
    refer to invocations made by the wrapper to other components, e.g., TDI.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

    There are a number of instances in which the same function needs to be invoked
    on all the mini redirectors that have been registered. The RDBSS needs to be
    synchronized with the completion of the invocation of all these calls. It
    will be beneficial to invoke these calls in parallel when more than one
    mini redirectors are registered. This module provides the framework for such
    calldowns. This is provided by the routine RxCalldownMiniRedirectors.

    An instance of coordination between multiple callouts occurs when a connect
    request is initiated across multiple instances in parallel. The data structures
    corresponding to this are defined in rxcep.h for now since the usage is restricted
    to the connection engine. It would be a suitable candidate for migration if more uses
    are found later.

--*/

#include "precomp.h"
#pragma  hdrstop

#include "mrx.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeMRxCalldownContext)
#pragma alloc_text(PAGE, RxCompleteMRxCalldownRoutine)
#pragma alloc_text(PAGE, RxCalldownMRxWorkerRoutine)
#pragma alloc_text(PAGE, RxCalldownMiniRedirectors)
#endif

VOID
RxInitializeMRxCalldownContext(
   PMRX_CALLDOWN_CONTEXT    pContext,
   PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
   PMRX_CALLDOWN_ROUTINE pRoutine,
   PVOID                    pParameter)
/*++

Routine Description:

    This routine initializes a mini redirector calldown context.

Arguments:

    pContext - the MRx calldown context

Notes:

--*/
{
   PAGED_CODE();

   pContext->pMRxDeviceObject   = pMRxDeviceObject;
   pContext->pRoutine           = pRoutine;
   pContext->pParameter         = pParameter;
   pContext->pCompletionContext = NULL;
}

VOID
RxCompleteMRxCalldownRoutine(
   PMRX_CALLDOWN_COMPLETION_CONTEXT pCompletionContext)
/*++

Routine Description:

    This routine constitutes the tail of a mini redirector calldown completion.
    It encapsulates the synchronization mechanism for the resumption of RDBSS

Arguments:

    pCompletionContext - the MRx calldown completion context

Notes:

--*/
{
   PAGED_CODE();

   if (pCompletionContext != NULL) {
      LONG WaitCount;

      WaitCount = InterlockedDecrement(&pCompletionContext->WaitCount);
      if (WaitCount == 0) {
         KeSetEvent(
            &pCompletionContext->Event,
            IO_NO_INCREMENT,
            FALSE);
      }
   }
}

VOID
RxCalldownMRxWorkerRoutine(
   PMRX_CALLDOWN_CONTEXT pContext)
/*++

Routine Description:

    This is the calldown worker routine that invokes the appropriate mini
    redirector routine and follows it up with a call to the completion routine.

Arguments:

    pContext - the MRx calldown context

Notes:

--*/
{
    PRDBSS_DEVICE_OBJECT pMRxDeviceObject = pContext->pMRxDeviceObject;

    PAGED_CODE();

    if ( pContext->pRoutine != NULL) {
        pContext->CompletionStatus = (pContext->pRoutine)(pContext->pParameter);
    }

    RxCompleteMRxCalldownRoutine(pContext->pCompletionContext);
}

NTSTATUS
RxCalldownMiniRedirectors(
   LONG                  NumberOfMiniRdrs,
   PMRX_CALLDOWN_CONTEXT pCalldownContext,
   BOOLEAN               PostCalldowns)
/*++

Routine Description:

    This routine encapsulates the multiple mini redirector calldown.

Arguments:

    NumberOfMiniRdrs  - the number of mini redirectors

    pCalldownContext  - the MRx calldown context array for the mini redirectors

    PostCalldowns     - if TRUE the calldown employs multiple threads

Notes:

    The three parameters for this routine constitute an effort to provide
    maximum flexibility. The values should be carefully specified for
    utmost efficiency.

    Since the different calldowns can choose to employ a subset of the
    mini redirectors registered at any time the calldown mechanism accepts an
    array of calldown contexts and the appropriate number.

    In most cases when there is only one mini redirector registered it is
    necessary that the context switches be minimized. The routine provides
    for this by having an explicit specification (PostCalldowns ) parameter.

--*/
{
   LONG     Index;
   PMRX_CALLDOWN_CONTEXT pContext;

   MRX_CALLDOWN_COMPLETION_CONTEXT CompletionContext;

   PAGED_CODE();

   if (NumberOfMiniRdrs == 0) {
      return STATUS_SUCCESS;
   }

   pContext = pCalldownContext;

   CompletionContext.WaitCount = NumberOfMiniRdrs;
   KeInitializeEvent(
         &CompletionContext.Event,
         NotificationEvent,
         FALSE);

   for (Index = 0,pContext = pCalldownContext;
        Index < NumberOfMiniRdrs;
        Index++,pContext++) {
      pContext->pCompletionContext = &CompletionContext;
   }

   if (PostCalldowns) {
      for (Index = 0, pContext = pCalldownContext;
           Index < NumberOfMiniRdrs;
           Index++,pContext++) {
         RxPostToWorkerThread(
               RxFileSystemDeviceObject,
               CriticalWorkQueue,
               &pContext->WorkQueueItem,
               RxCalldownMRxWorkerRoutine,
               pContext);
      }
   } else {
      for (Index = 0, pContext = pCalldownContext;
           Index < NumberOfMiniRdrs;
           Index++,pContext++) {
         RxCalldownMRxWorkerRoutine(&pCalldownContext[Index]);
      }
   }

   KeWaitForSingleObject(
      &CompletionContext.Event,
      Executive,
      KernelMode,
      FALSE,
      NULL);

   return STATUS_SUCCESS;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\fcbstruc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FcbStruc.c

Abstract:

    This module implements functions for to create and dereference fcbs
    and all of the surrounding paraphenalia. Please read the abstract in
    fcb.h. Please see the note about what locks to need to call what.
    There are asserts to enforce these conventions.


Author:

    Joe Linn (JoeLinn)    8-8-94

Revision History:

    Balan Sethu Raman --

--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs2.h>
#include <ntddmup.h>
#ifdef RDBSSLOG
#include <stdio.h>
#endif
#include <dfsfsctl.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxDereference)
#pragma alloc_text(PAGE, RxReference)
#pragma alloc_text(PAGE, RxpReferenceNetFcb)
#pragma alloc_text(PAGE, RxpDereferenceNetFcb)
#pragma alloc_text(PAGE, RxpDereferenceAndFinalizeNetFcb)
#pragma alloc_text(PAGE, RxWaitForStableCondition)
#pragma alloc_text(PAGE, RxUpdateCondition)
#pragma alloc_text(PAGE, RxAllocateObject)
#pragma alloc_text(PAGE, RxFreeObject)
#pragma alloc_text(PAGE, RxFinalizeNetTable)
#pragma alloc_text(PAGE, RxFinalizeConnection)
#pragma alloc_text(PAGE, RxInitializeSrvCallParameters)
#pragma alloc_text(PAGE, RxCreateSrvCall)
#pragma alloc_text(PAGE, RxSetSrvCallDomainName)
#pragma alloc_text(PAGE, RxFinalizeSrvCall)
#pragma alloc_text(PAGE, RxCreateNetRoot)
#pragma alloc_text(PAGE, RxFinalizeNetRoot)
#pragma alloc_text(PAGE, RxAddVirtualNetRootToNetRoot)
#pragma alloc_text(PAGE, RxRemoveVirtualNetRootFromNetRoot)
#pragma alloc_text(PAGE, RxInitializeVNetRootParameters)
#pragma alloc_text(PAGE, RxUninitializeVNetRootParameters)
#pragma alloc_text(PAGE, RxCreateVNetRoot)
#pragma alloc_text(PAGE, RxOrphanSrvOpens)
#pragma alloc_text(PAGE, RxFinalizeVNetRoot)
#pragma alloc_text(PAGE, RxAllocateFcbObject)
#pragma alloc_text(PAGE, RxFreeFcbObject)
#pragma alloc_text(PAGE, RxCreateNetFcb)
#pragma alloc_text(PAGE, RxInferFileType)
#pragma alloc_text(PAGE, RxFinishFcbInitialization)
#pragma alloc_text(PAGE, RxRemoveNameNetFcb)
#pragma alloc_text(PAGE, RxPurgeFcb)
#pragma alloc_text(PAGE, RxFinalizeNetFcb)
#pragma alloc_text(PAGE, RxSetFileSizeWithLock)
#pragma alloc_text(PAGE, RxGetFileSizeWithLock)
#pragma alloc_text(PAGE, RxCreateSrvOpen)
#pragma alloc_text(PAGE, RxFinalizeSrvOpen)
#pragma alloc_text(PAGE, RxCreateNetFobx)
#pragma alloc_text(PAGE, RxFinalizeNetFobx)
#pragma alloc_text(PAGE, RxCheckFcbStructuresForAlignment)
#pragma alloc_text(PAGE, RxOrphanThisFcb)
#pragma alloc_text(PAGE, RxOrphanSrvOpensForThisFcb)
#pragma alloc_text(PAGE, RxForceFinalizeAllVNetRoots)
#endif


//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_FCBSTRUC)

//struct _RX_PREFIX_TABLE  RxNetNameTable;
ULONG SerialNumber = 1;     //zero doesn't work!!!

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FCBSTRUCTS)


// SRV_CALL,NET_ROOT,VNET_ROOT,FCB,SRV_OPEN,FOBX are the six key data structures in the RDBSS
// They are organized in the following hierarchy
//
//       SRV_CALL
//          NET_ROOT
//             VNET_ROOT
//                FCB
//                   SRV_OPEN
//                      FOBX
//
// All these data structures are reference counted. The reference count associated with
// any data structure is atleast 1 + the number of instances of the data structure at the next
// level associated with it, e.g., the reference count associated with a SRV_CALL which
// has two NET_ROOT's associated with it is atleast 3. In addition to the references held
// by the NameTable and the data structure at the next level there are additional references
// acquired as and when required.
//
// These restrictions ensure that a data structure at any given level cannot be finalized till
// all the data structures at the next level have been finalized or have released their
// references, i.e., if a reference to a FCB is held, then it is safe to access the VNET_ROOT,
// NET_ROOT and SRV_CALL associated with it.
//
// The SRV_CALL,NET_ROOT and VNET_ROOT creation/finalization are governed by the acquistion/
// release of the RxNetNameTable lock.
//
// The FCB creation/finalization is governed by the acquistion/release of the NetNameTable
// lock associated with the NET_ROOT.
//
// The FOBX/SRVOPEN creation/finalization is governed by the acquistion/release of the FCB
// resource.
//
// The following table summarizes the locks and the modes in which they need to be acquired
// for creation/finalization of the various data structures.
//
//
//                    L O C K I N G   R E Q U I R E M E N T S
//
// Locking requirements are as follows:
//
// where Xy means Exclusive-on-Y, Sy mean at least Shared-on-Y
// and  NNT means global NetNameTable, TL means NetRoot TableLock, and FCB means FCBlock
//
//
//
//                            SRVCALL NETROOT   FCB   SRVOPEN   FOBX
//
//                Create      XNNT    XNNT      XTL    XFCB     XFCB
//                Finalize    XNNT    XNNT      XFCB   XFCB     XFCB
//                                              & XTL
//
// Referencing and Dereferencing these data structures need to adhere to certain conventions
// as well.
//
// When the reference count associated with any of these data structures drops to 1 ( the sole
// reference being held by the name table in most cases) the data structure is a potential
// candidate for finalization. The data structure can be either finalized immediately or it
// can be marked for scavenging. Both of these methods are implemented. When the locking
// requirements are met during dereferencing the data structures are finalized immediately
// ( the one exception being that when delayed operation optimization is implemented, e.g., FCB)
// otherwise the data structure is marked for scavenging.
//
//
//    You are supposed to have the tablelock exclusive to be calling this routine.......I can't
//    take it here because you are already supposed to have it. To do a create, you should
//    done something like
//
//         getshared();lookup();
//         if (failed) {
//             release(); getexclusive(); lookup();
//             if ((failed) { create(); }
//         }
//         deref();
//         release();
//
//    so you will already have the lock. what you do is to insert the node into the table, release
//    the lock, and then go and see if the server's there. if so, set up the rest of the stuff and unblock
//    anyone who's waiting on the same server (or netroot)...i guess i could enforce this by releasing here
//   but i do not.


// Forward declarations -- These routines are not meant for use in other
// modules

BOOLEAN
RxFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize,
    IN  LONG      ReferenceCount
    );

VOID
RxPurgeFcb(
    IN  PFCB pFcb);

BOOLEAN
RxIsThisACscAgentOpen(
    IN PRX_CONTEXT RxContext
    );

VOID
RxDereference(
    IN OUT PVOID              pInstance,
    IN     LOCK_HOLDING_STATE LockHoldingState)
/*++

Routine Description:

    The routine adjust the reference count on an instance of the reference counted data
    structures in RDBSS exlcuding the FCB.

Arguments:

    pInstance        - the instance being dereferenced

    LockHoldingState - the mode in which the appropriate lock is held.

Return Value:

    none.

--*/
{
    LONG FinalRefCount;
    NODE_TYPE_CODE_AND_SIZE *pNode = (PNODE_TYPE_CODE_AND_SIZE)pInstance;
    BOOLEAN fFinalizeInstance = FALSE;

    PAGED_CODE();

    RxAcquireScavengerMutex();

    ASSERT((NodeType(pInstance) == RDBSS_NTC_SRVCALL ) ||
           (NodeType(pInstance) == RDBSS_NTC_NETROOT ) ||
           (NodeType(pInstance) == RDBSS_NTC_V_NETROOT ) ||
           (NodeType(pInstance) == RDBSS_NTC_SRVOPEN ) ||
           (NodeType(pInstance) == RDBSS_NTC_FOBX ));

    FinalRefCount = InterlockedDecrement(&pNode->NodeReferenceCount);

    ASSERT(FinalRefCount >= 0);

    IF_DEBUG {
        switch (NodeType(pInstance)) {
        case RDBSS_NTC_SRVCALL :
            {
                PSRV_CALL ThisSrvCall = (PSRV_CALL)pInstance;

                PRINT_REF_COUNT(SRVCALL,ThisSrvCall->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxDereferenceSrvCall %08lx  %wZ RefCount=%lx\n", ThisSrvCall
                                   , &ThisSrvCall->PrefixEntry.Prefix
                                   , ThisSrvCall->NodeReferenceCount));
            }
            break;

        case RDBSS_NTC_NETROOT :
            {
                PNET_ROOT ThisNetRoot = (PNET_ROOT)pInstance;

                PRINT_REF_COUNT(NETROOT,ThisNetRoot->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxDereferenceNetRoot %08lx  %wZ RefCount=%lx\n", ThisNetRoot
                                  , &ThisNetRoot->PrefixEntry.Prefix
                                  , ThisNetRoot->NodeReferenceCount));
            }
            break;

        case RDBSS_NTC_V_NETROOT:
            {
                PV_NET_ROOT ThisVNetRoot = (PV_NET_ROOT)pInstance;

                PRINT_REF_COUNT(VNETROOT,ThisVNetRoot->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxDereferenceVNetRoot %08lx  %wZ RefCount=%lx\n", ThisVNetRoot
                                  , &ThisVNetRoot->PrefixEntry.Prefix
                                  , ThisVNetRoot->NodeReferenceCount));
            }
            break;

        case RDBSS_NTC_SRVOPEN :
            {
                PSRV_OPEN ThisSrvOpen = (PSRV_OPEN)pInstance;

                PRINT_REF_COUNT(SRVOPEN,ThisSrvOpen->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxDereferenceSrvOpen %08lx  %wZ RefCount=%lx\n", ThisSrvOpen
                                  , &ThisSrvOpen->Fcb->FcbTableEntry.Path
                                  , ThisSrvOpen->NodeReferenceCount));
            }
            break;

        case RDBSS_NTC_FOBX:
            {
                PFOBX ThisFobx = (PFOBX)pInstance;

                PRINT_REF_COUNT(NETFOBX,ThisFobx->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxDereferenceFobx %08lx  %wZ RefCount=%lx\n", ThisFobx
                                  , &ThisFobx->SrvOpen->Fcb->FcbTableEntry.Path
                                  , ThisFobx->NodeReferenceCount));
            }
            break;

        default:
            break;
        }
    }

    // if the final reference count was greater then one no finalization is required.
    if (FinalRefCount <= 1) {
        if (LockHoldingState == LHS_ExclusiveLockHeld) {
            // if the reference count was 1 and the lock modes were satisfactory,
            // the instance can be finalized immediately.
            fFinalizeInstance = TRUE;

            if ((pNode->NodeTypeCode & RX_SCAVENGER_MASK) != 0) {
                RxpUndoScavengerFinalizationMarking(pInstance);
            }
        } else {
            switch (NodeType(pInstance)) {
            case RDBSS_NTC_FOBX:
                if (FinalRefCount != 0) {
                    break;
                }
                // fall thru intentional if refcount == 1 for FOBXs
            case RDBSS_NTC_SRVCALL:
            case RDBSS_NTC_NETROOT:
            case RDBSS_NTC_V_NETROOT:
                // the data structure cannot be freed at this time owing to the mode in which
                // the lock has been acquired ( or not having the lock at all ).

                RxpMarkInstanceForScavengedFinalization(pInstance);
                break;
            default:
                break;
            }
        }
    }

    RxReleaseScavengerMutex();

    if (fFinalizeInstance) {
        switch (NodeType(pInstance)) {
        case RDBSS_NTC_SRVCALL:
            {
                //ASSERT( RxIsPrefixTableLockAcquired( &RxNetNameTable ));
                IF_DEBUG {
                    PRDBSS_DEVICE_OBJECT RxDeviceObject = ((PSRV_CALL)pInstance)->RxDeviceObject;
                    ASSERT( RxDeviceObject != NULL );
                    ASSERT( RxIsPrefixTableLockAcquired( RxDeviceObject->pRxNetNameTable ));
                }

                RxFinalizeSrvCall((PSRV_CALL)pInstance,TRUE,TRUE);
            }
            break;

        case RDBSS_NTC_NETROOT:
            {
                //ASSERT( RxIsPrefixTableLockAcquired( &RxNetNameTable ));
                IF_DEBUG {
                    PSRV_CALL SrvCall =  ((PNET_ROOT)pInstance)->SrvCall;
                    PRDBSS_DEVICE_OBJECT RxDeviceObject = SrvCall->RxDeviceObject;
                    ASSERT( RxDeviceObject != NULL );
                    ASSERT( RxIsPrefixTableLockAcquired( RxDeviceObject->pRxNetNameTable ));
                }

                RxFinalizeNetRoot((PNET_ROOT)pInstance,TRUE,TRUE);
            }
            break;

        case RDBSS_NTC_V_NETROOT:
            {
                //ASSERT( RxIsPrefixTableLockAcquired( &RxNetNameTable ));
                IF_DEBUG {
                    PSRV_CALL SrvCall =  ((PV_NET_ROOT)pInstance)->NetRoot->SrvCall;
                    PRDBSS_DEVICE_OBJECT RxDeviceObject = SrvCall->RxDeviceObject;
                    ASSERT( RxDeviceObject != NULL );
                    ASSERT( RxIsPrefixTableLockAcquired( RxDeviceObject->pRxNetNameTable ));
                }

                RxFinalizeVNetRoot((PV_NET_ROOT)pInstance,TRUE,TRUE);
            }
            break;

        case RDBSS_NTC_SRVOPEN:
            {
                PSRV_OPEN ThisSrvOpen = (PSRV_OPEN)pInstance;

                ASSERT(RxIsFcbAcquired(ThisSrvOpen->Fcb));
                if (ThisSrvOpen->OpenCount == 0) {
                    RxFinalizeSrvOpen(ThisSrvOpen,FALSE,FALSE);
                }
            }
            break;

        case RDBSS_NTC_FOBX:
            {
                PFOBX ThisFobx = (PFOBX)pInstance;

                ASSERT(RxIsFcbAcquired( ThisFobx->SrvOpen->Fcb));
                RxFinalizeNetFobx(ThisFobx,TRUE,FALSE);
            }
            break;

        default:
            break;
        }
    }
}

VOID
RxReference(
    OUT PVOID pInstance)
/*++

Routine Description:

    The routine adjusts the reference count on the instance.

Arguments:

    pInstance - the instance being referenced

Return Value:

    RxStatus(SUCESS) is successful

    RxStatus(UNSUCCESSFUL) otherwise.

--*/
{
    LONG     FinalRefCount;

    NODE_TYPE_CODE_AND_SIZE *pNode = (PNODE_TYPE_CODE_AND_SIZE)pInstance;

    USHORT InstanceType;

    PAGED_CODE();

    RxAcquireScavengerMutex();

    InstanceType = pNode->NodeTypeCode & ~RX_SCAVENGER_MASK;
    ASSERT((InstanceType == RDBSS_NTC_SRVCALL ) ||
           (InstanceType == RDBSS_NTC_NETROOT ) ||
           (InstanceType == RDBSS_NTC_V_NETROOT ) ||
           (InstanceType == RDBSS_NTC_SRVOPEN ) ||
           (InstanceType == RDBSS_NTC_FOBX ));

    FinalRefCount = InterlockedIncrement(&pNode->NodeReferenceCount);

    IF_DEBUG {
        if (pNode->NodeTypeCode & RX_SCAVENGER_MASK) {
            RxDbgTrace(0,Dbg,("Referencing Scavenged instance -- Type %lx\n",InstanceType));
        }

        switch (InstanceType) {
        case RDBSS_NTC_SRVCALL :
            {
                PSRV_CALL ThisSrvCall = (PSRV_CALL)pInstance;

                PRINT_REF_COUNT(SRVCALL,ThisSrvCall->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxReferenceSrvCall %08lx  %wZ RefCount=%lx\n", ThisSrvCall
                                   , &ThisSrvCall->PrefixEntry.Prefix
                                   , ThisSrvCall->NodeReferenceCount));
            }
            break;

        case RDBSS_NTC_NETROOT :
            {
                PNET_ROOT ThisNetRoot = (PNET_ROOT)pInstance;

                PRINT_REF_COUNT(NETROOT,ThisNetRoot->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxReferenceNetRoot %08lx  %wZ RefCount=%lx\n", ThisNetRoot
                                  , &ThisNetRoot->PrefixEntry.Prefix
                                  , ThisNetRoot->NodeReferenceCount));
            }
            break;

        case RDBSS_NTC_V_NETROOT:
            {
                PV_NET_ROOT ThisVNetRoot = (PV_NET_ROOT)pInstance;

                PRINT_REF_COUNT(VNETROOT,ThisVNetRoot->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxReferenceVNetRoot %08lx  %wZ RefCount=%lx\n", ThisVNetRoot
                                  , &ThisVNetRoot->PrefixEntry.Prefix
                                  , ThisVNetRoot->NodeReferenceCount));
            }
            break;

        case RDBSS_NTC_SRVOPEN :
            {
                PSRV_OPEN ThisSrvOpen = (PSRV_OPEN)pInstance;

                PRINT_REF_COUNT(SRVOPEN,ThisSrvOpen->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxReferenceSrvOpen %08lx  %wZ RefCount=%lx\n", ThisSrvOpen
                                  , &ThisSrvOpen->Fcb->FcbTableEntry.Path
                                  , ThisSrvOpen->NodeReferenceCount));
            }
            break;

        case RDBSS_NTC_FOBX:
            {
                PFOBX ThisFobx = (PFOBX)pInstance;

                PRINT_REF_COUNT(NETFOBX,ThisFobx->NodeReferenceCount);
                RxDbgTrace( 0, Dbg, (" RxReferenceFobx %08lx  %wZ RefCount=%lx\n", ThisFobx
                                  , &ThisFobx->SrvOpen->Fcb->FcbTableEntry.Path
                                  , ThisFobx->NodeReferenceCount));
            }
            break;

        default:
            {
                ASSERT(!"Valid node type for referencing");
            }
            break;
        }
    }

    RxpUndoScavengerFinalizationMarking(pInstance);

    RxReleaseScavengerMutex();
}

VOID
RxpReferenceNetFcb(
    PFCB pFcb)
/*++

Routine Description:

    The routine adjusts the reference count on the FCB.

Arguments:

    pFcb  - the SrvCall being referenced

Return Value:

    RxStatus(SUCESS) is successful

    RxStatus(UNSUCCESSFUL) otherwise.

--*/
{
    LONG FinalRefCount;

    PAGED_CODE();

    ASSERT(NodeTypeIsFcb(pFcb));

    FinalRefCount = InterlockedIncrement(&pFcb->NodeReferenceCount);

    IF_DEBUG {
        PRINT_REF_COUNT(NETFCB,pFcb->NodeReferenceCount);
        RxDbgTrace( 0, Dbg, (" RxReferenceNetFcb %08lx  %wZ RefCount=%lx\n", pFcb
                            , &pFcb->FcbTableEntry.Path
                            , pFcb->NodeReferenceCount));
    }
}

LONG
RxpDereferenceNetFcb(
    PFCB                pFcb)
/*++

Routine Description:

    The routine adjust the reference count on an instance of the reference counted data
    structures in RDBSS exlcuding the FCB.

Arguments:

    pFcb                         -- the FCB being dereferenced

Return Value:

    none.

Notes:

    The referencing and dereferencing of FCB's is different from those of the other data
    structures because of the embedded resource in the FCB. This implies that the caller
    requires information regarding the status of the FCB ( whether it was finalized or not )

    In order to finalize the FCB two locks need to be held, the NET_ROOT's name table lock as
    well as the FCB resource.

    These considerations lead us to adopt a different approach in dereferencing FCB's. The
    dereferencing routine does not even attempt to finalize the FCB

--*/
{
    LONG FinalRefCount;

    PAGED_CODE();

    ASSERT(NodeTypeIsFcb(pFcb));

    FinalRefCount = InterlockedDecrement(&pFcb->NodeReferenceCount);

    ASSERT(FinalRefCount >= 0);

    IF_DEBUG {
        PRINT_REF_COUNT(NETFCB,pFcb->NodeReferenceCount);
        RxDbgTrace( 0, Dbg, (" RxDereferenceNetFcb %08lx  %wZ RefCount=%lx\n", pFcb
                            , &pFcb->FcbTableEntry.Path
                            , pFcb->NodeReferenceCount));
    }

    return(FinalRefCount);
}

BOOLEAN
RxpDereferenceAndFinalizeNetFcb(
    PFCB        pFcb,
    PRX_CONTEXT RxContext,
    BOOLEAN     RecursiveFinalize,
    BOOLEAN     ForceFinalize)
/*++

Routine Description:

    The routine adjust the reference count aw well as finalizes the FCB if required

Arguments:

    pFcb                         -- the FCB being dereferenced

    RxContext                    -- the context for releasing/acquiring FCB.

    RecursiveFinalize            -- recursive finalization

    ForceFinalize                -- force finalization

Return Value:

    none.

Notes:

    The referencing and dereferencing of FCB's is different from those of the other data
    structures because of the embedded resource in the FCB. This implies that the caller
    requires information regarding the status of the FCB ( whether it was finalized or not )

    In order to finalize the FCB two locks need to be held, the NET_ROOT's name table lock as
    well as the FCB resource.

    This routine acquires the additional lock if required.

--*/
{
    BOOLEAN NodeActuallyFinalized   = FALSE;

    LONG    FinalRefCount;

    PAGED_CODE();

    ASSERT(!ForceFinalize);
    ASSERT(NodeTypeIsFcb(pFcb));
    ASSERT(RxIsFcbAcquiredExclusive(pFcb));

    FinalRefCount = InterlockedDecrement(&pFcb->NodeReferenceCount);


    if (ForceFinalize ||
        RecursiveFinalize ||
        ((pFcb->OpenCount == 0) &&
         (pFcb->UncleanCount == 0) &&
         (FinalRefCount <= 1))) {
        BOOLEAN   PrefixTableLockAcquired = FALSE;
        PNET_ROOT pNetRoot;
        NTSTATUS  Status = (STATUS_SUCCESS);

        if (!FlagOn(pFcb->FcbState,FCB_STATE_ORPHANED)) {
            pNetRoot = (PNET_ROOT)pFcb->VNetRoot->NetRoot;

            // An insurance reference to ensure that the NET ROOT does not dissapear
            RxReferenceNetRoot(pNetRoot);

            // In all these cases the FCB is likely to be finalized
            if (!RxIsFcbTableLockExclusive(&pNetRoot->FcbTable)) {
                RxReferenceNetFcb(pFcb); // get ready to refresh the finalrefcount after we get the tablelock
                if (!RxAcquireFcbTableLockExclusive(&pNetRoot->FcbTable, FALSE) ) {

                    if ((RxContext != NULL) &&
                        (RxContext != CHANGE_BUFFERING_STATE_CONTEXT) &&
                        (RxContext != CHANGE_BUFFERING_STATE_CONTEXT_WAIT)) {
                        SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK);
                    }

                    RxReleaseFcb(RxContext,pFcb );

                    (VOID)RxAcquireFcbTableLockExclusive(&pNetRoot->FcbTable, TRUE);

                    Status = RxAcquireExclusiveFcb(RxContext, pFcb);
                }

                FinalRefCount = RxDereferenceNetFcb(pFcb);
                PrefixTableLockAcquired = TRUE;
            }
        } else {
            pNetRoot = NULL;
        }

        if (Status == (STATUS_SUCCESS)) {
            NodeActuallyFinalized = RxFinalizeNetFcb(pFcb,RecursiveFinalize,ForceFinalize,FinalRefCount);
        }

        if (PrefixTableLockAcquired) {
            RxReleaseFcbTableLock(&pNetRoot->FcbTable);
        }

        if (pNetRoot != NULL) {
            RxDereferenceNetRoot(pNetRoot,LHS_LockNotHeld);
        }
    }

    return NodeActuallyFinalized;
}

VOID
RxWaitForStableCondition(
    IN     PRX_BLOCK_CONDITION pCondition,
    IN OUT PLIST_ENTRY         pTransitionWaitList,
    IN OUT PRX_CONTEXT         pRxContext,
    OUT    NTSTATUS            *AsyncStatus OPTIONAL)
/*++

Routine Description:

    The routine checks to see if the condition is stable. If not, it
    is suspended till a stable condition is attained. when a stable condition is
    obtained, either the rxcontext sync event is set or the context is posted...depending
    on the POST_ON_STABLE_CONDITION context flag. the flag is cleared on a post.

Arguments:

    Condition - the condition variable we're waiting on

    Resource - the resrouce used to control access to the containing block

    RxContext - the RX context

Return Value:

    RXSTATUS - PENDING if notstable and the context will be posted
               SUCCESS otherwise

--*/
{
    NTSTATUS DummyStatus;
    BOOLEAN Wait = FALSE;

    PAGED_CODE();

    if (AsyncStatus == NULL) {
        AsyncStatus = &DummyStatus;
    }
    *AsyncStatus = (STATUS_SUCCESS);

    if (StableCondition(*pCondition))
        return; //early out could macroize

#ifndef WIN9X
    RxAcquireSerializationMutex();
#endif

    if (!StableCondition(*pCondition)) {
        RxInsertContextInSerializationQueue(pTransitionWaitList,pRxContext);
        if (!FlagOn(pRxContext->Flags,RX_CONTEXT_FLAG_POST_ON_STABLE_CONDITION)){
            Wait = TRUE;
        } else {
            *AsyncStatus = (STATUS_PENDING);
        }
    }

#ifndef WIN9X
    RxReleaseSerializationMutex();
#endif WIN9X

    if (Wait) {
        RxWaitSync(pRxContext);
    }

    return;
}

VOID
RxUpdateCondition (
    IN     RX_BLOCK_CONDITION  NewCondition,
    OUT    PRX_BLOCK_CONDITION pCondition,
    IN OUT PLIST_ENTRY         pTransitionWaitList)
/*++

Routine Description:

    The routine unwaits the guys waiting on the transition event and the condition is set
    according to the parameter passed.

Arguments:

    NewConditionValue - the new value of the condition variable

    pCondition - variable (i.e. a ptr) to the transitioning condition

    pTransitionWaitList - list of contexts waiting for the transition.

Notes:

    The resource associated with the data structure instance being modified must have been
    acquired exclusively before invoking this routine, i.e., for SRV_CALL,NET_ROOT and V_NET_ROOT
    the net name table lock must be acquired and for FCB's the associated resource.

--*/
{
    LIST_ENTRY  TargetListHead;
    PRX_CONTEXT pRxContext;

    PAGED_CODE();

#ifndef WIN9X
    RxAcquireSerializationMutex();
#endif

    ASSERT(NewCondition != Condition_InTransition);

    *pCondition = NewCondition;
    RxTransferList(&TargetListHead,pTransitionWaitList);

#ifndef WIN9X
    RxReleaseSerializationMutex();
#endif

    while (pRxContext = RxRemoveFirstContextFromSerializationQueue(&TargetListHead)) {
        if (!FlagOn(pRxContext->Flags,RX_CONTEXT_FLAG_POST_ON_STABLE_CONDITION)){
            RxSignalSynchronousWaiter(pRxContext);
        } else {
            ClearFlag(pRxContext->Flags,RX_CONTEXT_FLAG_POST_ON_STABLE_CONDITION);
            RxFsdPostRequest(pRxContext);
        }
    }
}

PVOID
RxAllocateObject(
    NODE_TYPE_CODE    NodeType,
    PMINIRDR_DISPATCH pMRxDispatch,
    ULONG             NameLength)
/*++

Routine Description:

    The routine allocates and constructs the skeleton of a SRV_CALL/NET_ROOT/V_NET_ROOT
    instance.

Arguments:

    NodeType     - the node type

    pMRxDispatch - the Mini redirector dispatch vector

    NameLength   - name size.

Notes:

    The reasons as to why the allocation/freeing of these data structures have been
    centralized are as follows

      1) The construction of these three data types have a lot in common with the exception
      of the initial computation of sizes. Therefore centralization minimizes the footprint.

      2) It allows us to experiment with different clustering/allocation strategies.

      3) It allows the incorporation of debug support in an easy way.

    There are two special cases of interest in the allocation strategy ...

    1) The data structures for the wrapper as well as the corresponding mini redirector
    are allocated adjacent to each other. This ensures spatial locality.

    2) The one exception to the above rule is the SRV_CALL data structure. This is because
    of the bootstrapping problem. A SRV_CALL skeleton needs to be created which is then passed
    around to each of the mini redirectors. Therefore adoption of rule (1) is not possible.

    Further there can be more than one mini redirector laying claim to a particular server. In
    consideration of these things SRV_CALL's need to be treated as an exception to (1). However
    once a particular mini redirector has been selected as the winner it would be advantageous
    to colocate the data structure to derive the associated performance benefits. This has not
    been implemented as yet.

--*/
{
    ULONG    PoolTag;
    ULONG    RdbssNodeSize,MRxNodeSize;
    BOOLEAN  fInitializeContextFields = FALSE;

    PNODE_TYPE_CODE_AND_SIZE   pNode;

    PAGED_CODE();

    RdbssNodeSize = MRxNodeSize = 0;

    switch (NodeType) {
    case RDBSS_NTC_SRVCALL :
        {
            PoolTag = RX_SRVCALL_POOLTAG;

            RdbssNodeSize = QuadAlign(sizeof(SRV_CALL));

            if (pMRxDispatch != NULL) {
                if (pMRxDispatch->MRxFlags & RDBSS_MANAGE_SRV_CALL_EXTENSION) {
                    MRxNodeSize = QuadAlign(pMRxDispatch->MRxSrvCallSize);
                }
            }
        }
        break;

    case RDBSS_NTC_NETROOT:
        {
            PoolTag = RX_NETROOT_POOLTAG;
            RdbssNodeSize = QuadAlign(sizeof(NET_ROOT));

            if (pMRxDispatch->MRxFlags & RDBSS_MANAGE_NET_ROOT_EXTENSION) {
                MRxNodeSize = QuadAlign(pMRxDispatch->MRxNetRootSize);
            }
        }
        break;

    case RDBSS_NTC_V_NETROOT:
        {
            PoolTag = RX_V_NETROOT_POOLTAG;
            RdbssNodeSize = QuadAlign(sizeof(V_NET_ROOT));

            if (pMRxDispatch->MRxFlags & RDBSS_MANAGE_V_NET_ROOT_EXTENSION) {
                MRxNodeSize = QuadAlign(pMRxDispatch->MRxVNetRootSize);
            }
        }
        break;

    default:
        ASSERT(!"Invalid Node Type for allocation/Initialization");
        return NULL;
    }

    pNode = RxAllocatePoolWithTag(
                NonPagedPool,
                (RdbssNodeSize + MRxNodeSize + NameLength),
                PoolTag);

    if (pNode != NULL) {
        ULONG              NodeSize;
        PVOID              *pContextPtr;
        PRX_PREFIX_ENTRY   pPrefixEntry = NULL;

        NodeSize = RdbssNodeSize + MRxNodeSize;
        ZeroAndInitializeNodeType(pNode, NodeType, (NodeSize + NameLength));

        switch (NodeType) {
        case RDBSS_NTC_SRVCALL:
            {
                PSRV_CALL pSrvCall = (PSRV_CALL)pNode;

                pContextPtr  = &pSrvCall->Context;
                pPrefixEntry = &pSrvCall->PrefixEntry;

                // Set up the name pointer in the MRX_SRV_CALL structure ..
                pSrvCall->pSrvCallName = &pSrvCall->PrefixEntry.Prefix;
            }
            break;

        case RDBSS_NTC_NETROOT:
            {
                PNET_ROOT pNetRoot = (PNET_ROOT)pNode;

                pContextPtr  = &pNetRoot->Context;
                pPrefixEntry = &pNetRoot->PrefixEntry;

                // Set up the net root name pointer in the MRX_NET_ROOT structure
                pNetRoot->pNetRootName = &pNetRoot->PrefixEntry.Prefix;
            }
            break;

        case RDBSS_NTC_V_NETROOT:
            {
                PV_NET_ROOT pVNetRoot = (PV_NET_ROOT)pNode;

                pContextPtr  = &pVNetRoot->Context;
                pPrefixEntry = &pVNetRoot->PrefixEntry;
            }
            break;

        default:
            break;
        }

        if (pPrefixEntry != NULL) {
            ZeroAndInitializeNodeType(
                pPrefixEntry,
                RDBSS_NTC_PREFIX_ENTRY,
                sizeof( RX_PREFIX_ENTRY ));

            pPrefixEntry->Prefix.Buffer = (PWCH)((PCHAR)pNode + NodeSize);
            pPrefixEntry->Prefix.Length = (USHORT)NameLength;
            pPrefixEntry->Prefix.MaximumLength = (USHORT)NameLength;
        }

        if (MRxNodeSize > 0) {
            *pContextPtr = (PBYTE)pNode + RdbssNodeSize;
        }
    }

    return pNode;
}

VOID
RxFreeObject(PVOID pObject)
/*++

Routine Description:

    The routine frees a SRV_CALL/V_NET_ROOT/NET_ROOT instance

Arguments:

    pObject - the instance to be freed

Notes:

--*/
{
    PAGED_CODE();

    IF_DEBUG {
        switch (NodeType(pObject)) {
        case RDBSS_NTC_SRVCALL :
            {
                PSRV_CALL pSrvCall = (PSRV_CALL)pObject;

                if (pSrvCall->RxDeviceObject != NULL) {
                    if (!(pSrvCall->RxDeviceObject->Dispatch->MRxFlags & RDBSS_MANAGE_SRV_CALL_EXTENSION)) {
                        ASSERT(pSrvCall->Context == NULL);
                    }
                    ASSERT(pSrvCall->Context2 == NULL);
                    pSrvCall->RxDeviceObject = NULL;
                }
            }
            break;

        case RDBSS_NTC_NETROOT :
            {
                PNET_ROOT pNetRoot = (PNET_ROOT)pObject;

                pNetRoot->SrvCall = NULL;
                //pNetRoot->Dispatch = NULL;
                pNetRoot->NodeTypeCode |= 0xf000;
            }
            break;

        case RDBSS_NTC_V_NETROOT :
            {
            }
            break;

        default:
            break;
        }
    }

    RxFreePool(pObject);
}

VOID
RxFinalizeNetTable (
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    BOOLEAN fForceFinalization
    )
/*++
Routine Description:

   This routine finalizes the net table.

--*/
{
    BOOLEAN        fMorePassesRequired = TRUE;
    PLIST_ENTRY    pListEntry;
    NODE_TYPE_CODE DesiredNodeType;
    PRX_PREFIX_TABLE  pRxNetNameTable = RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxForceNetTableFinalization at the TOP\n"));
    RxLog(("FINALNETT\n"));
    RxWmiLog(LOG,
             RxFinalizeNetTable_1,
             LOGPTR(RxDeviceObject));

    RxAcquirePrefixTableLockExclusive( pRxNetNameTable, TRUE); //could be hosed if rogue!

    DesiredNodeType = RDBSS_NTC_V_NETROOT;

    RxAcquireScavengerMutex();

    while (fMorePassesRequired) {
        for (pListEntry = pRxNetNameTable->MemberQueue.Flink;
             pListEntry !=  &(pRxNetNameTable->MemberQueue); ) {
            BOOLEAN          NodeFinalized;
            PVOID            pContainer;
            PRX_PREFIX_ENTRY PrefixEntry;
            PLIST_ENTRY      pPrevEntry;

            PrefixEntry = CONTAINING_RECORD( pListEntry, RX_PREFIX_ENTRY, MemberQLinks );
            ASSERT (NodeType(PrefixEntry) == RDBSS_NTC_PREFIX_ENTRY);
            pContainer = (PrefixEntry->ContainingRecord);
            RxDbgTrace(0, Dbg, ("RxForceNetTableFinalization ListEntry PrefixEntry Container"
                              "=-->     %08lx %08lx %08lx\n", pListEntry, PrefixEntry, pContainer));
            RxLog(("FINALNETT: %lx %wZ\n", pContainer, &PrefixEntry->Prefix));
            RxWmiLog(LOG,
                     RxFinalizeNetTable_2,
                     LOGPTR(pContainer)
                     LOGUSTR(PrefixEntry->Prefix));

            pListEntry = pListEntry->Flink;

            if (pContainer != NULL) {
                RxpUndoScavengerFinalizationMarking(pContainer);

                if (NodeType(pContainer) == DesiredNodeType) {
                    switch (NodeType(pContainer)) {
                    case RDBSS_NTC_SRVCALL :
                        NodeFinalized = RxFinalizeSrvCall((PSRV_CALL)pContainer,TRUE,fForceFinalization);
                        break;

                    case RDBSS_NTC_NETROOT :
                        NodeFinalized = RxFinalizeNetRoot((PNET_ROOT)pContainer,TRUE,fForceFinalization);
                        break;

                    case RDBSS_NTC_V_NETROOT :
                        {
                            PV_NET_ROOT pVNetRoot = (PV_NET_ROOT)pContainer;
                            ULONG AdditionalReferenceTaken;

                            AdditionalReferenceTaken = InterlockedCompareExchange(
                                                           &pVNetRoot->AdditionalReferenceForDeleteFsctlTaken,
                                                           0,
                                                           1);

                            if (AdditionalReferenceTaken) {
                               RxDereferenceVNetRoot(pVNetRoot,LHS_ExclusiveLockHeld);
                               NodeFinalized = TRUE;
                            } else {
                                NodeFinalized = RxFinalizeVNetRoot((PV_NET_ROOT)pContainer,TRUE,fForceFinalization);
                            }
                        }

                        break;
                    }
                }
            }
        }

        switch (DesiredNodeType) {
        case RDBSS_NTC_SRVCALL :
            fMorePassesRequired = FALSE;
            break;
        case RDBSS_NTC_NETROOT :
            DesiredNodeType = RDBSS_NTC_SRVCALL;
            break;
        case RDBSS_NTC_V_NETROOT :
            DesiredNodeType = RDBSS_NTC_NETROOT;
            break;
        }
    }

    RxDbgTrace(-1,Dbg,("RxFinalizeNetTable -- Done\n"));

    RxReleaseScavengerMutex();

    RxReleasePrefixTableLock( pRxNetNameTable );
}

NTSTATUS
RxFinalizeConnection(
    IN OUT PNET_ROOT NetRoot,
    IN OUT PV_NET_ROOT VNetRoot,
    IN BOOLEAN Level
    )
/*++

Routine Description:

    The routine deletes a connection FROM THE USER's PERSPECTIVE. It doesn't disconnect
    but it does (with force) close open files. disconnecting is handled either by timeout or by
    srvcall finalization.

Arguments:

    NetRoot      - the NetRoot being finalized

    VNetRoot     - the VNetRoot being finalized

    Level        - This is a tri-state 
                    FALSE - fail if files or changenotifications are open
                    TRUE  - succeed no matter waht. orphan files and remove change notifies forcefully
                    0xff  - take away extra reference on the vnetroot due to add_connection
                            but otherwise act like FALSE 
Return Value:

    RxStatus(SUCCESS) if successful.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NumberOfOpenDirectories = 0;
    ULONG NumberOfOpenNonDirectories = 0;
    ULONG NumberOfFobxs = 0;
    LONG  AdditionalReferenceForDeleteFsctlTaken = 0;
    PLIST_ENTRY ListEntry, NextListEntry;
    BOOLEAN PrefixTableLockAcquired,FcbTableLockAcquired;
    PRX_PREFIX_TABLE  pRxNetNameTable;
    BOOLEAN ForceFilesClosed = FALSE;
    
    if (Level==TRUE)
    {
        ForceFilesClosed = TRUE;        
    }

    PAGED_CODE();

    ASSERT( NodeType(NetRoot) == RDBSS_NTC_NETROOT );
    pRxNetNameTable = NetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;

    Status = RxCancelNotifyChangeDirectoryRequestsForVNetRoot(VNetRoot, ForceFilesClosed);

    // either changenotifications were cancelled, or they weren't but we still want to
    // do go through in order to either forceclose the files or atleast deref the vnetroot
    // of the extra ref taken during ADD_CONNECTION
    
    if ((Status == STATUS_SUCCESS) || (Level != FALSE))
    {

        // reset the status
        Status = STATUS_SUCCESS;
        
        PrefixTableLockAcquired = RxAcquirePrefixTableLockExclusive(
                                      pRxNetNameTable,
                                      TRUE);

        //don't let the netroot be finalized yet.......
        RxReferenceNetRoot(NetRoot);

        FcbTableLockAcquired = RxAcquireFcbTableLockExclusive(
                                   &NetRoot->FcbTable,
                                   TRUE);

        try {

            if ((Status == STATUS_SUCCESS) && (!VNetRoot->ConnectionFinalizationDone)) {
                USHORT BucketNumber;

                RxDbgTrace(+1, Dbg, ("RxFinalizeConnection<+> NR= %08lx VNR= %08lx %wZ\n",
                                      NetRoot,VNetRoot,&NetRoot->PrefixEntry.Prefix));
                RxLog(("FINALCONN: %lx  %wZ\n",NetRoot,&NetRoot->PrefixEntry.Prefix));
                RxWmiLog(LOG,
                         RxFinalizeConnection,
                         LOGPTR(NetRoot)
                         LOGUSTR(NetRoot->PrefixEntry.Prefix));

                for (BucketNumber = 0;
                     (BucketNumber < NetRoot->FcbTable.NumberOfBuckets);
                     BucketNumber++) {
                    PLIST_ENTRY ListHeader;

                    ListHeader = &NetRoot->FcbTable.HashBuckets[BucketNumber];

                    for (ListEntry = ListHeader->Flink;
                         ListEntry != ListHeader;
                         ListEntry = NextListEntry ) {
                        PFCB Fcb;
                        PRX_FCB_TABLE_ENTRY FcbTableEntry;

                        NextListEntry = ListEntry->Flink;

                        FcbTableEntry = CONTAINING_RECORD(
                                         ListEntry,
                                         RX_FCB_TABLE_ENTRY,
                                         HashLinks );

                        Fcb = CONTAINING_RECORD(
                                  FcbTableEntry,
                                  FCB,
                                  FcbTableEntry);

                        if (Fcb->VNetRoot != VNetRoot) {
                            continue;
                        }

                        if (Fcb->UncleanCount>0 && !ForceFilesClosed) {
                            Status = STATUS_CONNECTION_IN_USE; //this is changed later
                            if (NodeType(Fcb)==RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {
                                NumberOfOpenDirectories++;
                            } else {
                                NumberOfOpenNonDirectories++;
                            }
                            continue;
                        }

                        ASSERT( NodeTypeIsFcb(Fcb));
                        RxDbgTrace( 0, Dbg, ("                    AcquiringFcbLock%c!!\n", '!'));
                        Status = RxAcquireExclusiveFcb(NULL,Fcb);
                        ASSERT(Status == STATUS_SUCCESS);
                        RxDbgTrace( 0, Dbg, ("                    AcquiredFcbLock%c!!\n", '!'));

                        // Ensure that no more file objects will be marked for a delayed close
                        // on this FCB.

                        ClearFlag(Fcb->FcbState,FCB_STATE_COLLAPSING_ENABLED);

                        RxScavengeRelatedFobxs(Fcb);

                        // a small complication here is that this fcb MAY have an open
                        // section against it caused by our cacheing the file. if so,
                        // we need to purge to get to the close

                        RxPurgeFcb(Fcb);
                    }
                }

                if (VNetRoot->NumberOfFobxs == 0) {
                    VNetRoot->ConnectionFinalizationDone = TRUE;
                }
            }

            NumberOfFobxs = VNetRoot->NumberOfFobxs;
            AdditionalReferenceForDeleteFsctlTaken = VNetRoot->AdditionalReferenceForDeleteFsctlTaken;

            if (ForceFilesClosed) {
                RxFinalizeVNetRoot(VNetRoot,FALSE,TRUE);
            }
        } finally {
            if (FcbTableLockAcquired) {
                RxReleaseFcbTableLock( &NetRoot->FcbTable );
            }

            // We should not delete the remote connection with the file opened.
            if (!ForceFilesClosed && (Status == STATUS_SUCCESS) && (NumberOfFobxs > 0)) {
                Status = STATUS_FILES_OPEN;
            }

            if (Status != STATUS_SUCCESS) {
                if (NumberOfOpenNonDirectories) {
                    Status = STATUS_FILES_OPEN;
                }
            } 
            
            if ((Status == STATUS_SUCCESS)||(Level==0xff)){
                // the corresponding reference for this is in RxCreateTreeConnect...
                // please see the comment there...
                if (AdditionalReferenceForDeleteFsctlTaken != 0) {
                    VNetRoot->AdditionalReferenceForDeleteFsctlTaken = 0;
                    RxDereferenceVNetRoot(VNetRoot,LHS_ExclusiveLockHeld);
                }
            }

            if (PrefixTableLockAcquired) {
                RxDereferenceNetRoot(NetRoot,LHS_ExclusiveLockHeld);
                RxReleasePrefixTableLock( pRxNetNameTable );
            }
        }

        RxDbgTrace(-1, Dbg, ("RxFinalizeConnection<-> Status=%08lx\n", Status));
    }
    return(Status);
}

NTSTATUS
RxInitializeSrvCallParameters(
    PRX_CONTEXT RxContext,
    PSRV_CALL   SrvCall)
/*++

Routine Description:

    This routine initializes the server call parameters passed in through EA's
    Currently this routine initializes the Server principal name which is passed
    in by the DFS driver.

Arguments:

    RxContext  -- the associated context

    SrvCall    -- the Srv Call Instance

Return Value:

    RxStatus(SUCCESS) if successfull

Notes:

    The current implementation maps out of memory situations into an error and
    passes it back. If the global strategy is to raise an exception this
    redundant step can be avoided.

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    ULONG EaInformationLength;

    PAGED_CODE();

    SrvCall->pPrincipalName = NULL;

    if (RxContext->MajorFunction != IRP_MJ_CREATE) {
        return STATUS_SUCCESS;
    }

    EaInformationLength = RxContext->Create.EaLength;

    if (EaInformationLength > 0) {
        PFILE_FULL_EA_INFORMATION pEaEntry;

        pEaEntry = (PFILE_FULL_EA_INFORMATION)RxContext->Create.EaBuffer;
        ASSERT(pEaEntry != NULL);

        for(;;) {
            RxDbgTrace(0,Dbg,("RxExtractSrvCallParams: Processing EA name %s\n",
                            pEaEntry->EaName));

            if (strcmp(pEaEntry->EaName, EA_NAME_PRINCIPAL) == 0) {
                if (pEaEntry->EaValueLength > 0) {
                    SrvCall->pPrincipalName = (PUNICODE_STRING)
                                             RxAllocatePoolWithTag(
                                                  NonPagedPool,
                                                  (sizeof(UNICODE_STRING) + pEaEntry->EaValueLength),
                                                  RX_SRVCALL_PARAMS_POOLTAG);

                    if (SrvCall->pPrincipalName != NULL) {
                        SrvCall->pPrincipalName->Length        = pEaEntry->EaValueLength;
                        SrvCall->pPrincipalName->MaximumLength = pEaEntry->EaValueLength;
                        SrvCall->pPrincipalName->Buffer        = (PWCHAR)((PCHAR)SrvCall->pPrincipalName + sizeof(UNICODE_STRING));
                        RtlCopyMemory(
                            SrvCall->pPrincipalName->Buffer,
                            pEaEntry->EaName + pEaEntry->EaNameLength + 1,
                            SrvCall->pPrincipalName->Length);
                    } else {
                        Status = (STATUS_INSUFFICIENT_RESOURCES);
                    }
                }
                break;
            }

            if (pEaEntry->NextEntryOffset == 0) {
                break;
            } else {
                pEaEntry = (PFILE_FULL_EA_INFORMATION)
                           ((PCHAR) pEaEntry + pEaEntry->NextEntryOffset);
            }
        }
    }

    return Status;
}

PSRV_CALL
RxCreateSrvCall (
    IN  PRX_CONTEXT       RxContext,
    IN  PUNICODE_STRING   Name,
    IN  PUNICODE_STRING   InnerNamePrefix       OPTIONAL,
    IN  PRX_CONNECTION_ID RxConnectionId
    )
/*++

Routine Description:

    The routine builds a node representing a server call context and inserts the name into the net
    name table. Optionally, it "co-allocates" a netroot structure as well. Appropriate alignment is
    respected for the enclosed netroot. The name(s) is(are) allocated at the end of the block. The
    reference count on the block is set to 1 (2 if enclosed netroot) on this create to account for
    ptr returned.

Arguments:

    RxContext - the RDBSS context
    Name      - the name to be inserted
    Dispatch  - pointer to the minirdr dispatch table

Return Value:

    Ptr to the created srvcall.

--*/
{
    PSRV_CALL ThisSrvCall;
    PRX_PREFIX_ENTRY ThisEntry;

    ULONG          NameSize,PrefixNameSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxSrvCallCreate-->     Name = %wZ\n", Name));

    ASSERT ( RxIsPrefixTableLockExclusive ( RxContext->RxDeviceObject->pRxNetNameTable )  );

    NameSize = Name->Length + sizeof(WCHAR) * 2;

    if (InnerNamePrefix) {
        PrefixNameSize = InnerNamePrefix->Length;
    } else {
        PrefixNameSize = 0;
    }

    ThisSrvCall = RxAllocateObject(RDBSS_NTC_SRVCALL,NULL,(NameSize + PrefixNameSize));
    if (ThisSrvCall != NULL) {
        ThisSrvCall->SerialNumberForEnum = SerialNumber++;
        ThisSrvCall->RxDeviceObject = RxContext->RxDeviceObject;

        RxInitializeBufferingManager(ThisSrvCall);

        InitializeListHead(&ThisSrvCall->ScavengerFinalizationList);
        InitializeListHead(&ThisSrvCall->TransitionWaitList);

        RxInitializePurgeSyncronizationContext(
            &ThisSrvCall->PurgeSyncronizationContext);

#ifndef WIN9X
        RxInitializeSrvCallParameters(RxContext,ThisSrvCall);
#endif

        RtlMoveMemory(
            ThisSrvCall->PrefixEntry.Prefix.Buffer,
            Name->Buffer,
            Name->Length);

        ThisEntry = &ThisSrvCall->PrefixEntry;
        ThisEntry->Prefix.MaximumLength = (USHORT)NameSize;
        ThisEntry->Prefix.Length = Name->Length;

        RxPrefixTableInsertName (
            RxContext->RxDeviceObject->pRxNetNameTable,
            ThisEntry,
            (PVOID)ThisSrvCall,
            &ThisSrvCall->NodeReferenceCount,
            Name->Length,
            RxConnectionId); //make the whole srvcallname case insensitive

        RxDbgTrace(-1, Dbg, ("RxSrvCallCreate -> RefCount = %08lx\n", ThisSrvCall->NodeReferenceCount));
    }

    return ThisSrvCall;
}

NTSTATUS
RxSetSrvCallDomainName(
    PMRX_SRV_CALL   pSrvCall,
    PUNICODE_STRING pDomainName)
/*++

Routine Description:

    The routine sets the domain name associated with any given server.

Arguments:

    pSrvCall - the SrvCall

    pDomainName - the DOMAIN to which the server belongs.

Return Value:

    RxStatus(SUCCESS) if successful

Notes:

    This is one of the callback routines provided in the wrapper for the mini redirectors.
    Since the Domain name is not often known at the beginning this mechanism has to be
    adopted once it is found.

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);

    PAGED_CODE();

    if (pSrvCall->pDomainName != NULL) {
        RxFreePool(pSrvCall->pDomainName);
    }

    if (pDomainName != NULL && pDomainName->Length > 0) {
        pSrvCall->pDomainName = (PUNICODE_STRING)
                                RxAllocatePoolWithTag(
                                    NonPagedPool,
                                    sizeof(UNICODE_STRING) + pDomainName->Length + sizeof(WCHAR),
                                    RX_SRVCALL_PARAMS_POOLTAG);

        if (pSrvCall->pDomainName != NULL) {
            pSrvCall->pDomainName->Buffer = (PWCHAR)((PCHAR)pSrvCall->pDomainName + sizeof(UNICODE_STRING));
            pSrvCall->pDomainName->Length = pDomainName->Length;
            pSrvCall->pDomainName->MaximumLength = pDomainName->Length;

            *pSrvCall->pDomainName->Buffer = 0;

            if (pSrvCall->pDomainName->Length > 0) {
                RtlCopyMemory(
                    pSrvCall->pDomainName->Buffer,
                    pDomainName->Buffer,
                    pDomainName->Length);
            }
        } else {
            Status = (STATUS_INSUFFICIENT_RESOURCES);
        }
    } else {
        pSrvCall->pDomainName = NULL;
    }

    return Status;
}

VOID
RxpDestroySrvCall(
    PSRV_CALL ThisSrvCall)
/*++

Routine Description:

    This routine is used to tear down a SRV_CALL entry. This code is offloaded
    from the RxFinalizeCall routine to avoid having to hold the Name Table Lock
    for extended periods of time while the mini redirector is finalizing its
    data structures.

Arguments:

    ThisSrvCall      - the SrvCall being finalized

Notes:

    there is no recursive part because i don't have a list of srvcalls and a list
    of netroots i only have a combined list. thus, recursive finalization of
    netroots is directly from the top level. however, all netroots should already
    have been done when i get here..

--*/
{
    NTSTATUS Status;
    BOOLEAN  ForceFinalize;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = ThisSrvCall->RxDeviceObject;
    PRX_PREFIX_TABLE pRxNetNameTable = RxDeviceObject->pRxNetNameTable;

    ASSERT(ThisSrvCall->UpperFinalizationDone);

    ForceFinalize = BooleanFlagOn(
                        ThisSrvCall->Flags,
                        SRVCALL_FLAG_FORCE_FINALIZED);

    //we have to protect this call since the srvcall may never have been claimed
    MINIRDR_CALL_THROUGH(
           Status,
           RxDeviceObject->Dispatch,
           MRxFinalizeSrvCall,((PMRX_SRV_CALL)ThisSrvCall,ForceFinalize)
       );


    RxAcquirePrefixTableLockExclusive( pRxNetNameTable, TRUE);

    InterlockedDecrement(&ThisSrvCall->NodeReferenceCount);

    RxFinalizeSrvCall(
        ThisSrvCall,
        FALSE,
        ForceFinalize);

    RxReleasePrefixTableLock(pRxNetNameTable);
}

BOOLEAN
RxFinalizeSrvCall (
    OUT PSRV_CALL ThisSrvCall,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given netroot. You should have exclusive on
    the netname tablelock.

Arguments:

    ThisSrvCall      - the SrvCall being finalized

Return Value:

    BOOLEAN - tells whether finalization actually occured

Notes:

    there is no recursive part because i don't have a list of srvcalls and a list
    of netroots i only have a combined list. thus, recursive finalization of
    netroots is directly from the top level. however, all netroots should already
    have been done when i get here..

--*/
{
    BOOLEAN NodeActuallyFinalized = FALSE;
    PRX_PREFIX_TABLE  pRxNetNameTable;

    PAGED_CODE();

    ASSERT( NodeType(ThisSrvCall) == RDBSS_NTC_SRVCALL );
    pRxNetNameTable = ThisSrvCall->RxDeviceObject->pRxNetNameTable;
    ASSERT( RxIsPrefixTableLockExclusive( pRxNetNameTable ));

    RxDbgTrace(+1, Dbg, ("RxFinalizeSrvCall<+> %08lx %wZ RefC=%ld\n",
                               ThisSrvCall,&ThisSrvCall->PrefixEntry.Prefix,
                               ThisSrvCall->NodeReferenceCount));

    if( ThisSrvCall->NodeReferenceCount == 1 || ForceFinalize ) {
        BOOLEAN DeferFinalizationToWorkerThread = FALSE;

        RxLog(("FINALSRVC: %lx  %wZ\n",ThisSrvCall,&ThisSrvCall->PrefixEntry.Prefix));
        RxWmiLog(LOG,
                 RxFinalizeSrvCall,
                 LOGPTR(ThisSrvCall)
                 LOGUSTR(ThisSrvCall->PrefixEntry.Prefix));

        if (!ThisSrvCall->UpperFinalizationDone) {
            NTSTATUS Status;
            RxRemovePrefixTableEntry ( pRxNetNameTable, &ThisSrvCall->PrefixEntry);

            if (ForceFinalize) {
                ThisSrvCall->Flags |= SRVCALL_FLAG_FORCE_FINALIZED;
            }

            ThisSrvCall->UpperFinalizationDone = TRUE;

            if (ThisSrvCall->NodeReferenceCount == 1) {
                NodeActuallyFinalized = TRUE;
            }

            if (ThisSrvCall->RxDeviceObject != NULL) {
                if (IoGetCurrentProcess() != RxGetRDBSSProcess()) {
                    InterlockedIncrement(&ThisSrvCall->NodeReferenceCount);

                    RxDispatchToWorkerThread(
                        ThisSrvCall->RxDeviceObject,
                        DelayedWorkQueue,
                        RxpDestroySrvCall,
                        ThisSrvCall);

                    DeferFinalizationToWorkerThread = TRUE;
                } else {
                    MINIRDR_CALL_THROUGH(
                           Status,
                           ThisSrvCall->RxDeviceObject->Dispatch,
                           MRxFinalizeSrvCall,((PMRX_SRV_CALL)ThisSrvCall,ForceFinalize)
                       );
                }
            }
        }

        if (!DeferFinalizationToWorkerThread) {
            if( ThisSrvCall->NodeReferenceCount == 1 ) {
                if (ThisSrvCall->pDomainName != NULL) {
                   RxFreePool(ThisSrvCall->pDomainName);
                }

                RxTearDownBufferingManager(ThisSrvCall);

                RxFreeObject(ThisSrvCall);
                NodeActuallyFinalized = TRUE;
            }
        }
    } else {
        RxDbgTrace(0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!'));
    }

    RxDbgTrace(-1, Dbg, ("RxFinalizeSrvCall<-> %08lx\n", ThisSrvCall, NodeActuallyFinalized));

    return NodeActuallyFinalized;
}

PNET_ROOT
RxCreateNetRoot (
    IN  PSRV_CALL        SrvCall,
    IN  PUNICODE_STRING  Name,
    IN  ULONG            NetRootFlags,
    IN  PRX_CONNECTION_ID RxConnectionId
    )
/*++

Routine Description:

    The routine builds a node representing a netroot  and inserts the name into the net
    name table. The name is allocated at the end of the block. The reference count on the block
    is set to 1 on this create....

Arguments:

    SrvCall - the associated server call context; may be NULL!!  (but not right now.........)
    Dispatch - the minirdr dispatch table
    Name - the name to be inserted

Return Value:

    Ptr to the created net root.

--*/
{
    PNET_ROOT       ThisNetRoot;
    PRX_PREFIX_TABLE  pRxNetNameTable;


    ULONG           NameSize,SrvCallNameSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxNetRootCreate-->     Name = %wZ\n", Name));

    ASSERT  (SrvCall != NULL);
    pRxNetNameTable = SrvCall->RxDeviceObject->pRxNetNameTable;
    ASSERT  ( RxIsPrefixTableLockExclusive ( pRxNetNameTable )  );

    SrvCallNameSize = SrvCall->PrefixEntry.Prefix.Length;
    NameSize        = Name->Length + SrvCallNameSize;

    ThisNetRoot = RxAllocateObject(
                      RDBSS_NTC_NETROOT,
                      SrvCall->RxDeviceObject->Dispatch,
                      NameSize);

    if (ThisNetRoot != NULL) {
        USHORT CaseInsensitiveLength;

        RtlMoveMemory(
            (PCHAR)(ThisNetRoot->PrefixEntry.Prefix.Buffer) + SrvCallNameSize,
            Name->Buffer,
            Name->Length);

        if (SrvCallNameSize) {
            RtlMoveMemory(
                ThisNetRoot->PrefixEntry.Prefix.Buffer,
                SrvCall->PrefixEntry.Prefix.Buffer,
                SrvCallNameSize);
        }

        if (FlagOn(SrvCall->Flags,SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS)) {
            CaseInsensitiveLength = (USHORT)NameSize;
        } else {
            CaseInsensitiveLength = SrvCall->PrefixEntry.CaseInsensitiveLength;
        }

        RxPrefixTableInsertName (
            pRxNetNameTable,
            &ThisNetRoot->PrefixEntry,
            (PVOID)ThisNetRoot,
            &ThisNetRoot->NodeReferenceCount,
            CaseInsensitiveLength,
            RxConnectionId);

        RxInitializeFcbTable(&ThisNetRoot->FcbTable, TRUE);

        InitializeListHead(&ThisNetRoot->VirtualNetRoots);
        InitializeListHead(&ThisNetRoot->TransitionWaitList);
        InitializeListHead(&ThisNetRoot->ScavengerFinalizationList);

        RxInitializePurgeSyncronizationContext(
            &ThisNetRoot->PurgeSyncronizationContext);

        ThisNetRoot->SerialNumberForEnum = SerialNumber++;
        ThisNetRoot->Flags   |= NetRootFlags;
        ThisNetRoot->DiskParameters.ClusterSize = 1;
        ThisNetRoot->DiskParameters.ReadAheadGranularity = DEFAULT_READ_AHEAD_GRANULARITY;

        ThisNetRoot->SrvCall  = SrvCall;

        //already have the lock
        RxReferenceSrvCall((PSRV_CALL)ThisNetRoot->SrvCall);
    }

    return ThisNetRoot;
}

BOOLEAN
RxFinalizeNetRoot (
    OUT PNET_ROOT ThisNetRoot,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given netroot. You must be exclusive on
    the NetName tablelock.

Arguments:

    ThisNetRoot      - the NetRoot being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

--*/
{
    NTSTATUS Status;
    BOOLEAN  NodeActuallyFinalized = FALSE;
    PRX_PREFIX_TABLE  pRxNetNameTable;

    PAGED_CODE();

    ASSERT( NodeType(ThisNetRoot) == RDBSS_NTC_NETROOT );
    pRxNetNameTable = ThisNetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;
    ASSERT  ( RxIsPrefixTableLockExclusive ( pRxNetNameTable )  );

    if (ThisNetRoot->Flags & NETROOT_FLAG_FINALIZATION_IN_PROGRESS) {
        return FALSE;
    }

    // Since the table lock has been acquired exclusive the flags can be modified
    // without any further synchronization since the protection is against recursive
    // invocations.

    ThisNetRoot->Flags |= NETROOT_FLAG_FINALIZATION_IN_PROGRESS;

    RxDbgTrace(+1, Dbg, ("RxFinalizeNetRoot<+> %08lx %wZ RefC=%ld\n",
                               ThisNetRoot,&ThisNetRoot->PrefixEntry.Prefix,
                               ThisNetRoot->NodeReferenceCount));

    if (RecursiveFinalize) {
        PLIST_ENTRY ListEntry;
        USHORT      BucketNumber;

        RxAcquireFcbTableLockExclusive(&ThisNetRoot->FcbTable,TRUE);

        IF_DEBUG{
            if ( FALSE && ThisNetRoot->NodeReferenceCount){
                RxDbgTrace(0, Dbg, ("     BAD!!!!!ReferenceCount = %08lx\n", ThisNetRoot->NodeReferenceCount));
            }
        }


        for (BucketNumber = 0;
             (BucketNumber < ThisNetRoot->FcbTable.NumberOfBuckets);
             BucketNumber++) {
            PLIST_ENTRY ListHeader;

            ListHeader = &ThisNetRoot->FcbTable.HashBuckets[BucketNumber];

            for (ListEntry = ListHeader->Flink;
                 ListEntry != ListHeader;
                ) {
                PFCB Fcb;
                PRX_FCB_TABLE_ENTRY pFcbTableEntry;

                pFcbTableEntry = CONTAINING_RECORD(
                                    ListEntry,
                                    RX_FCB_TABLE_ENTRY,
                                    HashLinks);

                Fcb = CONTAINING_RECORD(
                          pFcbTableEntry,
                          FCB,
                          FcbTableEntry);

                ListEntry = ListEntry->Flink;

                ASSERT( NodeTypeIsFcb(Fcb));

                if (!FlagOn(Fcb->FcbState,FCB_STATE_ORPHANED)) {

                    Status = RxAcquireExclusiveFcb(NULL,Fcb);
                    ASSERT(Status == (STATUS_SUCCESS));

                    // a small complication here is that this fcb MAY have an open section against it caused
                    // by our cacheing the file. if so, we need to purge to get to the close

                    // wrong//if so, we have to get rid of it and then standoff to let
                    // the close go thru. sigh.............

                    RxPurgeFcb(Fcb);
                }
            }
        }

        RxReleaseFcbTableLock( &ThisNetRoot->FcbTable );
    }

    if ( ThisNetRoot->NodeReferenceCount == 1  || ForceFinalize ){
        RxLog(("FINALNETROOT: %lx  %wZ\n",ThisNetRoot,&ThisNetRoot->PrefixEntry.Prefix));
        RxWmiLog(LOG,
                 RxFinalizeNetRoot,
                 LOGPTR(ThisNetRoot)
                 LOGUSTR(ThisNetRoot->PrefixEntry.Prefix));
        //if (!ThisNetRoot->UpperFinalizationDone) {
        //    NOTHING;
        //    ThisNetRoot->UpperFinalizationDone = TRUE;
        //}

        if ( ThisNetRoot->NodeReferenceCount == 1 ){
            PSRV_CALL SrvCall = (PSRV_CALL)ThisNetRoot->SrvCall;

            RxFinalizeFcbTable(&ThisNetRoot->FcbTable);

            if (!FlagOn(ThisNetRoot->Flags,NETROOT_FLAG_NAME_ALREADY_REMOVED)) {
                RxRemovePrefixTableEntry ( pRxNetNameTable, &ThisNetRoot->PrefixEntry);
            }

            RxFreeObject(ThisNetRoot);

            if (SrvCall != NULL) {
                RxDereferenceSrvCall(SrvCall,LHS_ExclusiveLockHeld);   //already have the lock
            }

            NodeActuallyFinalized = TRUE;
        }
    } else {
        RxDbgTrace(0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!'));
    }

    RxDbgTrace(-1, Dbg, ("RxFinalizeNetRoot<-> %08lx\n", ThisNetRoot, NodeActuallyFinalized));

    return NodeActuallyFinalized;
}

VOID
RxAddVirtualNetRootToNetRoot(
    PNET_ROOT   pNetRoot,
    PV_NET_ROOT pVNetRoot)
/*++

Routine Description:

    The routine adds a VNetRoot to the list of VNetRoot's associated with a NetRoot

Arguments:

    pNetRoot   - the NetRoot

    pVNetRoot  - the new VNetRoot to be added to the list.

Notes:

    The reference count associated with a NetRoot will be equal to the number of VNetRoot's
    associated with it plus 1. the last one being for the prefix name table. This ensures
    that a NetRoot cannot be finalized till all the VNetRoots associated with it have been
    finalized.

--*/
{
    PAGED_CODE();

    ASSERT(RxIsPrefixTableLockExclusive( pNetRoot->SrvCall->RxDeviceObject->pRxNetNameTable ));

    pVNetRoot->NetRoot = pNetRoot;
    pNetRoot->NumberOfVirtualNetRoots++;

    if (pNetRoot->DefaultVNetRoot == NULL) {
        //pNetRoot->DefaultVNetRoot = pVNetRoot;
    }

    InsertTailList(&pNetRoot->VirtualNetRoots,&pVNetRoot->NetRootListEntry);
}

VOID
RxRemoveVirtualNetRootFromNetRoot(
    PNET_ROOT   pNetRoot,
    PV_NET_ROOT pVNetRoot)
/*++

Routine Description:

    The routine removes a VNetRoot to the list of VNetRoot's associated with a NetRoot

Arguments:

    pNetRoot   - the NetRoot

    pVNetRoot  - the VNetRoot to be removed from the list.

Notes:

    The reference count associated with a NetRoot will be equal to the number of VNetRoot's
    associated with it plus 1. the last one being for the prefix name table. This ensures
    that a NetRoot cannot be finalized till all the VNetRoots associated with it have been
    finalized.

--*/
{
    PRX_PREFIX_TABLE  pRxNetNameTable =  pNetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;
    PAGED_CODE();

    ASSERT(RxIsPrefixTableLockExclusive( pRxNetNameTable ));

    pNetRoot->NumberOfVirtualNetRoots--;
    RemoveEntryList(&pVNetRoot->NetRootListEntry);

    if (pNetRoot->DefaultVNetRoot == pVNetRoot) {
        if (!IsListEmpty(&pNetRoot->VirtualNetRoots)) {
            // Traverse the list and pick another default net root.
            PV_NET_ROOT pTempVNetRoot;

            pTempVNetRoot = (PV_NET_ROOT)
                            CONTAINING_RECORD(
                                pNetRoot->VirtualNetRoots.Flink,
                                V_NET_ROOT,
                                NetRootListEntry);

            pNetRoot->DefaultVNetRoot = pTempVNetRoot;
        } else {
            pNetRoot->DefaultVNetRoot = NULL;
        }
    }

    if (IsListEmpty(&pNetRoot->VirtualNetRoots)) {
        NTSTATUS Status;

        if (!FlagOn(pNetRoot->Flags,NETROOT_FLAG_NAME_ALREADY_REMOVED)) {
            RxRemovePrefixTableEntry(pRxNetNameTable, &pNetRoot->PrefixEntry);
            SetFlag(pNetRoot->Flags,NETROOT_FLAG_NAME_ALREADY_REMOVED);
        }

        //ASSERT(pNetRoot->Dispatch != NULL);
        if ((pNetRoot->SrvCall != NULL)
            && (pNetRoot->SrvCall->RxDeviceObject!=NULL)) {
            MINIRDR_CALL_THROUGH(
                Status,
                pNetRoot->SrvCall->RxDeviceObject->Dispatch,
                MRxFinalizeNetRoot,((PMRX_NET_ROOT)pNetRoot,NULL)
                );
        }
    }
}

NTSTATUS
RxInitializeVNetRootParameters(
    PRX_CONTEXT      RxContext,
    LUID             *pLogonId,
    ULONG            *pSessionId,
    PUNICODE_STRING  *pUserNamePtr,
    PUNICODE_STRING  *pUserDomainNamePtr,
    PUNICODE_STRING  *pPasswordPtr,
    ULONG            *pFlags
    )
/*++

Routine Description:

    This routine extracts the ea parameters specified

Arguments:

    RxContext          -- the RxContext

    pLogonId           -- the logon Id.

    pUserNamePtr       -- pointer to the User Name

    pUserDomainNamePtr -- pointer to the user domain name

    pPasswordPtr       -- the password.

Return Value:

    STATUS_SUCCESS -- successful,

    appropriate NTSTATUS code otherwise

Notes:



--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    PIO_SECURITY_CONTEXT pSecurityContext;
    PACCESS_TOKEN        pAccessToken;

    PAGED_CODE();

    pSecurityContext = RxContext->Create.NtCreateParameters.SecurityContext;
    pAccessToken     = SeQuerySubjectContextToken(
                           &pSecurityContext->AccessState->SubjectSecurityContext);

    *pPasswordPtr       = NULL;
    *pUserDomainNamePtr = NULL;
    *pUserNamePtr       = NULL;
    *pFlags &= ~VNETROOT_FLAG_CSCAGENT_INSTANCE;

    if (!SeTokenIsRestricted(pAccessToken)) {
        Status = SeQueryAuthenticationIdToken(
                    pAccessToken,
                    pLogonId);

        if (Status == STATUS_SUCCESS) {
            Status = SeQuerySessionIdToken(
                        pAccessToken,
                        pSessionId);
        }

        if ((Status == STATUS_SUCCESS) &&
            (RxContext->Create.UserName.Buffer != NULL)) {
            PUNICODE_STRING pTargetString;

            pTargetString = RxAllocatePoolWithTag(
                                NonPagedPool,
                                (sizeof(UNICODE_STRING) + RxContext->Create.UserName.Length),
                                RX_SRVCALL_PARAMS_POOLTAG);

            if (pTargetString != NULL) {
                pTargetString->Length = RxContext->Create.UserName.Length;
                pTargetString->MaximumLength = RxContext->Create.UserName.MaximumLength;

                if (pTargetString->Length > 0) {
                    pTargetString->Buffer = (PWCHAR)((PCHAR)pTargetString + sizeof(UNICODE_STRING));
                    RtlCopyMemory(
                        pTargetString->Buffer,
                        RxContext->Create.UserName.Buffer,
                        pTargetString->Length);
                } else {
                    pTargetString->Buffer = NULL;
                }

                *pUserNamePtr = pTargetString;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if ((RxContext->Create.UserDomainName.Buffer != NULL) && (Status == STATUS_SUCCESS)) {
            PUNICODE_STRING pTargetString;

            pTargetString = RxAllocatePoolWithTag(
                                NonPagedPool,
                                (sizeof(UNICODE_STRING) + RxContext->Create.UserDomainName.Length + sizeof(WCHAR)),
                                RX_SRVCALL_PARAMS_POOLTAG);

            if (pTargetString != NULL) {
                pTargetString->Length = RxContext->Create.UserDomainName.Length;
                pTargetString->MaximumLength = RxContext->Create.UserDomainName.MaximumLength;

                pTargetString->Buffer = (PWCHAR)((PCHAR)pTargetString + sizeof(UNICODE_STRING));

                // in case of UPN name, domain name will be a NULL string
                *pTargetString->Buffer = 0;

                if (pTargetString->Length > 0) {
                    RtlCopyMemory(
                        pTargetString->Buffer,
                        RxContext->Create.UserDomainName.Buffer,
                        pTargetString->Length);
                }

                *pUserDomainNamePtr = pTargetString;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if ((RxContext->Create.Password.Buffer != NULL) && (Status == STATUS_SUCCESS)) {
            PUNICODE_STRING pTargetString;

            pTargetString = RxAllocatePoolWithTag(
                                NonPagedPool,
                                (sizeof(UNICODE_STRING) + RxContext->Create.Password.Length),
                                RX_SRVCALL_PARAMS_POOLTAG);

            if (pTargetString != NULL) {
                pTargetString->Length = RxContext->Create.Password.Length;
                pTargetString->MaximumLength = RxContext->Create.Password.MaximumLength;

                if (pTargetString->Length > 0) {
                    pTargetString->Buffer = (PWCHAR)((PCHAR)pTargetString + sizeof(UNICODE_STRING));
                    RtlCopyMemory(
                        pTargetString->Buffer,
                        RxContext->Create.Password.Buffer,
                        pTargetString->Length);
                } else {
                    pTargetString->Buffer = NULL;
                }

                *pPasswordPtr = pTargetString;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (Status == STATUS_SUCCESS)
        {
            if(RxIsThisACscAgentOpen(RxContext))
            {
                *pFlags |= VNETROOT_FLAG_CSCAGENT_INSTANCE;
            }
        }

        if (Status != STATUS_SUCCESS) {
            if (*pUserNamePtr != NULL) {
                RxFreePool(*pUserNamePtr);
                *pUserNamePtr = NULL;
            }
            if (*pUserDomainNamePtr != NULL) {
                RxFreePool(*pUserDomainNamePtr);
                *pUserDomainNamePtr = NULL;
            }
            if (*pPasswordPtr != NULL) {
                RxFreePool(*pPasswordPtr);
                *pPasswordPtr = NULL;
            }
        }
    } else {
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;
}

VOID
RxUninitializeVNetRootParameters(
    PUNICODE_STRING  pUserName,
    PUNICODE_STRING  pUserDomainName,
    PUNICODE_STRING  pPassword,
    ULONG            *lpFlags
    )
/*++

Routine Description:

    This routine unintializes the parameters ( logon ) associated with  a VNetRoot

Arguments:

    pVNetRoot -- the VNetRoot

--*/
{
    PAGED_CODE();

    if (pUserName != NULL) {
        RxFreePool(pUserName);
    }

    if (pUserDomainName != NULL) {
        RxFreePool(pUserDomainName);
    }

    if (pPassword != NULL) {
        RxFreePool(pPassword);
    }

    if (lpFlags)
    {
        *lpFlags &= ~VNETROOT_FLAG_CSCAGENT_INSTANCE;
    }
}

PV_NET_ROOT
RxCreateVNetRoot (
    IN  PRX_CONTEXT      RxContext,
    IN  PNET_ROOT        NetRoot,
    IN  PUNICODE_STRING  CanonicalName,
    IN  PUNICODE_STRING  LocalNetRootName,
    IN  PUNICODE_STRING  FilePath,
    IN  PRX_CONNECTION_ID RxConnectionId
    )
/*++

Routine Description:

    The routine builds a node representing a virtual netroot  and inserts the name into
    the net name table. The name is allocated at the end of the block. The reference
    count on the block is set to 1 on this create....

    Virtual netroots provide a mechanism for mapping "into" a share....i.e. having a
    user drive that points not at the root of the associated share point.  The format
    of a name is either

        \server\share\d1\d2.....
    or
        \;m:\server\share\d1\d2.....

    depending on whether there is a local device ("m:") associated with this vnetroot.
    In the latter case is that \d1\d2.. gets prefixed onto each createfile that is
    opened on this vnetroot.

    vnetroot's are also used to supply alternate credentials. the point of the former
    kind of vnetroot is to propagate the credentials into the netroot as the default.
    for this to work, there must be no other references.

    You need to have the lock exclusive to call....see RxCreateSrvCall.......

Arguments:

    RxContext - the RDBSS context

    NetRoot - the associated net root context

    Name - the name to be inserted

    NamePrefixOffsetInBytes - offset into the name where the prefix starts

Return Value:

    Ptr to the created v net root.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PV_NET_ROOT ThisVNetRoot;
    UNICODE_STRING VNetRootName;
    PUNICODE_STRING ThisNamePrefix;
    ULONG NameSize;
    BOOLEAN fCscAgent = FALSE;

    PRX_PREFIX_ENTRY ThisEntry;

    PAGED_CODE();

    ASSERT  (RxIsPrefixTableLockExclusive( RxContext->RxDeviceObject->pRxNetNameTable ));

    NameSize = NetRoot->PrefixEntry.Prefix.Length + LocalNetRootName->Length;

    ThisVNetRoot = RxAllocateObject(RDBSS_NTC_V_NETROOT,NetRoot->SrvCall->RxDeviceObject->Dispatch,NameSize);
    if (ThisVNetRoot != NULL) {
        USHORT CaseInsensitiveLength;
        PMRX_SRV_CALL SrvCall;

        if (Status == STATUS_SUCCESS) {
            // Initialize the Create Parameters
            Status = RxInitializeVNetRootParameters(
                         RxContext,
                         &ThisVNetRoot->LogonId,
                         &ThisVNetRoot->SessionId,
                         &ThisVNetRoot->pUserName,
                         &ThisVNetRoot->pUserDomainName,
                         &ThisVNetRoot->pPassword,
                         &ThisVNetRoot->Flags
                         );
        }

        if (Status == STATUS_SUCCESS) {
            VNetRootName = ThisVNetRoot->PrefixEntry.Prefix;

            RtlMoveMemory(
                VNetRootName.Buffer,
                CanonicalName->Buffer,
                VNetRootName.Length);

            ThisVNetRoot->PrefixOffsetInBytes = LocalNetRootName->Length +
                                                NetRoot->PrefixEntry.Prefix.Length;

            RxDbgTrace(+1, Dbg, ("RxVNetRootCreate-->     Name = <%wZ>, offs=%08lx\n",
                              CanonicalName, ThisVNetRoot->PrefixOffsetInBytes));

            ThisNamePrefix = &ThisVNetRoot->NamePrefix;
            ThisNamePrefix->Buffer = (PWCH)((PCHAR)VNetRootName.Buffer + ThisVNetRoot->PrefixOffsetInBytes);
            ThisNamePrefix->Length =
            ThisNamePrefix->MaximumLength =
                VNetRootName.Length - (USHORT)ThisVNetRoot->PrefixOffsetInBytes;

            InitializeListHead(&ThisVNetRoot->TransitionWaitList);
            InitializeListHead(&ThisVNetRoot->ScavengerFinalizationList);

            // Now, insert into the netrootQ and the net name table
            ThisEntry = &ThisVNetRoot->PrefixEntry;
            SrvCall = NetRoot->pSrvCall;
            if (FlagOn(SrvCall->Flags,SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES)) {
                //here is insensitive length  is the whole thing
                CaseInsensitiveLength = (USHORT)NameSize;
            } else {
                //here is insensitive length is determined by the netroot or srvcall
                //plus we have to account for the device, if present
                ULONG ComponentsToUpcase,wcLength,i;
                if (FlagOn(SrvCall->Flags,SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS)) {
                    CaseInsensitiveLength = NetRoot->PrefixEntry.CaseInsensitiveLength;
                } else {
                    CaseInsensitiveLength = ((PSRV_CALL)SrvCall)->PrefixEntry.CaseInsensitiveLength;
                }

                wcLength = CanonicalName->Length/sizeof(WCHAR);
                for (i=1;;i++) { //note: don't start at zero
                    if (i>=wcLength)
                        break;
                    if (CanonicalName->Buffer[i]!=OBJ_NAME_PATH_SEPARATOR)
                        break;
                }
                CaseInsensitiveLength += (USHORT)(i*sizeof(WCHAR));
            }

            RxPrefixTableInsertName(
                RxContext->RxDeviceObject->pRxNetNameTable,
                ThisEntry,
                (PVOID)ThisVNetRoot,
                &ThisVNetRoot->NodeReferenceCount,
                CaseInsensitiveLength,
                RxConnectionId);

            RxReferenceNetRoot(NetRoot);

            RxAddVirtualNetRootToNetRoot(NetRoot,ThisVNetRoot);

            ThisVNetRoot->SerialNumberForEnum = SerialNumber++;
            ThisVNetRoot->UpperFinalizationDone = FALSE;
            ThisVNetRoot->ConnectionFinalizationDone = FALSE;
            ThisVNetRoot->AdditionalReferenceForDeleteFsctlTaken = 0;

            RxDbgTrace(-1, Dbg, ("RxVNetRootCreate -> RefCount = %08lx\n", ThisVNetRoot->NodeReferenceCount));
        }

        if (Status != STATUS_SUCCESS) {
            RxUninitializeVNetRootParameters(
                ThisVNetRoot->pUserName,
                ThisVNetRoot->pUserDomainName,
                ThisVNetRoot->pPassword,
                &ThisVNetRoot->Flags
                );

            RxFreeObject(ThisVNetRoot);
            ThisVNetRoot = NULL;
        }
    }

    return ThisVNetRoot;
}

VOID
RxOrphanSrvOpens(
    IN  PV_NET_ROOT ThisVNetRoot
    )
/*++

Routine Description:

    The routine iterates through all the FCBs that belong to the netroot to which this VNetRoot
    belongs and orphans all SrvOpens that belong to the VNetRoot. The caller must have acquired
    the NetName tablelock.

Arguments:

    ThisVNetRoot      - the VNetRoot

Return Value:
    None

Notes:

    On Entry -- RxNetNameTable lock must be acquired exclusive.

    On Exit  -- no change in lock ownership.

--*/
{
    PLIST_ENTRY pListEntry;
    USHORT      BucketNumber;
    PNET_ROOT   NetRoot = (PNET_ROOT)(ThisVNetRoot->NetRoot);
    PRX_PREFIX_TABLE  pRxNetNameTable = NetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;


    PAGED_CODE();

    //
    //  MAILSLOT FCBs don't have SrvOpens
    //

    if(NetRoot->Type == NET_ROOT_MAILSLOT) return;
    
    ASSERT(RxIsPrefixTableLockExclusive(pRxNetNameTable));

    RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE);

    try {
        for (BucketNumber = 0;
             (BucketNumber < NetRoot->FcbTable.NumberOfBuckets);
             BucketNumber++) {
            PLIST_ENTRY pListHeader;

            pListHeader = &NetRoot->FcbTable.HashBuckets[BucketNumber];

            pListEntry = pListHeader->Flink;

            while (pListEntry != pListHeader) {

                PFCB                pFcb;
                PRX_FCB_TABLE_ENTRY pFcbTableEntry;

                pFcbTableEntry = CONTAINING_RECORD(
                                     pListEntry,
                                     RX_FCB_TABLE_ENTRY,
                                     HashLinks );

                pListEntry = pListEntry->Flink;

                pFcb = CONTAINING_RECORD(
                           pFcbTableEntry,
                           FCB,
                           FcbTableEntry);

                ASSERT(NodeTypeIsFcb(pFcb));

                RxOrphanSrvOpensForThisFcb(pFcb, ThisVNetRoot, FALSE);  // don't force orphan the FCB
                                                                        // orphan only those srvopens
                                                                        // that belong to this VNetRoot
            }
        }
        if (NetRoot->FcbTable.pTableEntryForNull)
        {
            PFCB                pFcb;

            pFcb = CONTAINING_RECORD(
                       NetRoot->FcbTable.pTableEntryForNull,
                       FCB,
                       FcbTableEntry);

            ASSERT(NodeTypeIsFcb(pFcb));

            RxOrphanSrvOpensForThisFcb(pFcb, ThisVNetRoot, FALSE);
        }
    } finally {
        RxReleaseFcbTableLock( &NetRoot->FcbTable );
    }
}



BOOLEAN
RxFinalizeVNetRoot(
    OUT PV_NET_ROOT ThisVNetRoot,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given netroot. You must be exclusive on
    the NetName tablelock.

Arguments:

    ThisVNetRoot      - the VNetRoot being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN NodeActuallyFinalized = FALSE;
    PRX_PREFIX_TABLE  pRxNetNameTable;
    PAGED_CODE();

    ASSERT( NodeType(ThisVNetRoot) == RDBSS_NTC_V_NETROOT );
    pRxNetNameTable = ThisVNetRoot->NetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;
    ASSERT  ( RxIsPrefixTableLockExclusive ( pRxNetNameTable )  );

    RxDbgTrace(+1, Dbg, ("RxFinalizeVNetRoot<+> %08lx %wZ RefC=%ld\n",
                               ThisVNetRoot,&ThisVNetRoot->PrefixEntry.Prefix,
                               ThisVNetRoot->NodeReferenceCount));

    //The actual finalization is divided into two parts:
    //  1) if we're at the end (refcount==1) or being forced, we do the one-time only stuff
    //  2) if the refcount goes to zero, we actually do the free

    if( ThisVNetRoot->NodeReferenceCount == 1  || ForceFinalize ){
        PNET_ROOT NetRoot = (PNET_ROOT)ThisVNetRoot->NetRoot;

        RxLog(("FINALVNETROOT: %lx  %wZ\n",ThisVNetRoot,&ThisVNetRoot->PrefixEntry.Prefix));
        RxWmiLog(LOG,
                 RxFinalizeVNetRoot,
                 LOGPTR(ThisVNetRoot)
                 LOGUSTR(ThisVNetRoot->PrefixEntry.Prefix));

        if (!ThisVNetRoot->UpperFinalizationDone) {

            ASSERT( NodeType(NetRoot) == RDBSS_NTC_NETROOT );

            RxReferenceNetRoot(NetRoot);

            RxOrphanSrvOpens(ThisVNetRoot);

            RxRemoveVirtualNetRootFromNetRoot(NetRoot,ThisVNetRoot);

            RxDereferenceNetRoot(NetRoot,LHS_ExclusiveLockHeld);

            RxDbgTrace(0, Dbg, ("Mini Rdr VNetRoot finalization returned %lx\n", Status));

            RxRemovePrefixTableEntry ( pRxNetNameTable, &ThisVNetRoot->PrefixEntry);
            ThisVNetRoot->UpperFinalizationDone = TRUE;
        }

        if (ThisVNetRoot->NodeReferenceCount == 1) {
            if (NetRoot->SrvCall->RxDeviceObject != NULL) {
                MINIRDR_CALL_THROUGH(
                    Status,
                    NetRoot->SrvCall->RxDeviceObject->Dispatch,
                    MRxFinalizeVNetRoot,((PMRX_V_NET_ROOT)ThisVNetRoot,NULL)
                    );
            }

            RxUninitializeVNetRootParameters(
                ThisVNetRoot->pUserName,
                ThisVNetRoot->pUserDomainName,
                ThisVNetRoot->pPassword,
                &ThisVNetRoot->Flags
                );

            RxDereferenceNetRoot(NetRoot,LHS_ExclusiveLockHeld);

            RxFreePool(ThisVNetRoot);
            NodeActuallyFinalized = TRUE;
        }
    } else {
        RxDbgTrace(0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!'));
    }

    RxDbgTrace(-1, Dbg, ("RxFinalizeVNetRoot<-> %08lx\n", ThisVNetRoot, NodeActuallyFinalized));
    return NodeActuallyFinalized;
}

PVOID
RxAllocateFcbObject(
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    NODE_TYPE_CODE    NodeType,
    POOL_TYPE         PoolType,
    ULONG             NameSize,
    PVOID             pAlreadyAllocatedObject)
/*++

Routine Description:

    The routine allocates and constructs the skeleton of a FCB/SRV_OPEN and FOBX instance

Arguments:

    pMRxDispatch - the Mini redirector dispatch vector

    NodeType     - the node type

    PoolType     - the pool type to be used ( for paging file data structures NonPagedPool is
                   used.

    NameLength   - name size.

Notes:

    The reasons as to why the allocation/freeing of these data structures have been
    centralized are as follows

      1) The construction of these three data types have a lot in common with the exception
      of the initial computation of sizes. Therefore centralization minimizes the footprint.

      2) It allows us to experiment with different clustering/allocation strategies.

      3) It allows the incorporation of debug support in an easy way.

--*/
{
    ULONG  FcbSize,NonPagedFcbSize,SrvOpenSize,FobxSize;
    PMINIRDR_DISPATCH pMRxDispatch = RxDeviceObject->Dispatch;

    PVOID          pObject;
    PNON_PAGED_FCB pNonPagedFcb = NULL;
    PFCB           pFcb         = NULL;
    PSRV_OPEN      pSrvOpen     = NULL;
    PFOBX          pFobx        = NULL;
    PWCH           pName        = NULL;

    PAGED_CODE();

    FcbSize = SrvOpenSize = FobxSize = NonPagedFcbSize = 0;

    switch (NodeType) {
    default:
        {
            FcbSize = QuadAlign(sizeof(FCB));

            if (pMRxDispatch->MRxFlags & RDBSS_MANAGE_FCB_EXTENSION) {
                FcbSize += QuadAlign(pMRxDispatch->MRxFcbSize);
            }

            if (PoolType == NonPagedPool) {
                NonPagedFcbSize = QuadAlign(sizeof(NON_PAGED_FCB));
            }

            if (NodeType == RDBSS_NTC_OPENTARGETDIR_FCB) {
                break;
            }
        }
        // lack of break intentional

    case RDBSS_NTC_SRVOPEN :
    case RDBSS_NTC_INTERNAL_SRVOPEN:
        {
            SrvOpenSize = QuadAlign(sizeof(SRV_OPEN));

            if (pMRxDispatch->MRxFlags & RDBSS_MANAGE_SRV_OPEN_EXTENSION) {
                SrvOpenSize += QuadAlign(pMRxDispatch->MRxSrvOpenSize);
            }
        }
        // lack of break intentional

    case RDBSS_NTC_FOBX :
        {
            FobxSize = QuadAlign(sizeof(FOBX));

            if (pMRxDispatch->MRxFlags & RDBSS_MANAGE_FOBX_EXTENSION) {
                FobxSize += QuadAlign(pMRxDispatch->MRxFobxSize);
            }
        }
    }

    if (pAlreadyAllocatedObject == NULL) {
        pObject = RxAllocatePoolWithTag(
                      PoolType,
                      (FcbSize + SrvOpenSize + FobxSize + NonPagedFcbSize + NameSize),
                      RX_FCB_POOLTAG);

        //ASSERT(pObject != NULL);
        if (pObject==NULL) {
            return(NULL);
        }
    } else {
        pObject = pAlreadyAllocatedObject;
    }

    switch (NodeType) {
    case RDBSS_NTC_FOBX:
        {
            pFobx = (PFOBX)pObject;
        }
        break;

    case RDBSS_NTC_SRVOPEN:
        {
            pSrvOpen = (PSRV_OPEN)pObject;
            pFobx    = (PFOBX)((PBYTE)pSrvOpen + SrvOpenSize);
        }
        break;

    case RDBSS_NTC_INTERNAL_SRVOPEN:
        {
            pSrvOpen = (PSRV_OPEN)pObject;
        }
        break;

    default :
        {
            pFcb         = (PFCB)pObject;
            if (NodeType != RDBSS_NTC_OPENTARGETDIR_FCB) {
                pSrvOpen     = (PSRV_OPEN)((PBYTE)pFcb + FcbSize);
                pFobx        = (PFOBX)((PBYTE)pSrvOpen + SrvOpenSize);
            }

            if (PoolType == NonPagedPool) {
                pNonPagedFcb = (PNON_PAGED_FCB)((PBYTE)pFobx + FobxSize);
                pName        = (PWCH)((PBYTE)pNonPagedFcb + NonPagedFcbSize);
            } else {
                pName        = (PWCH)((PBYTE)pFcb + FcbSize + SrvOpenSize + FobxSize);
                pNonPagedFcb = RxAllocatePoolWithTag(
                                   NonPagedPool,
                                   sizeof(NON_PAGED_FCB),
                                   RX_NONPAGEDFCB_POOLTAG);

                if (pNonPagedFcb == NULL) {
                    RxFreePool(pFcb);
                    return NULL;
                }
            }
        }
        break;
    }

    if (pFcb != NULL) {
        ZeroAndInitializeNodeType(pFcb, RDBSS_NTC_STORAGE_TYPE_UNKNOWN, (NODE_BYTE_SIZE) FcbSize);

        pFcb->NonPaged = pNonPagedFcb;
        ZeroAndInitializeNodeType(pFcb->NonPaged, RDBSS_NTC_NONPAGED_FCB, ((NODE_BYTE_SIZE) sizeof( NON_PAGED_FCB )));

        IF_DEBUG {
            //make a copy of NonPaged so we can zap the real pointer and still find it
            DbgDoit(pFcb->CopyOfNonPaged = pNonPagedFcb);
            DbgDoit(pNonPagedFcb->FcbBackPointer = pFcb);
        }

        // Set up  the pointers to the preallocated SRV_OPEN and FOBX if required
        pFcb->InternalSrvOpen = pSrvOpen;
        pFcb->InternalFobx    = pFobx;

        pFcb->PrivateAlreadyPrefixedName.Buffer = pName;
        pFcb->PrivateAlreadyPrefixedName.Length = (USHORT)NameSize;
        pFcb->PrivateAlreadyPrefixedName.MaximumLength = pFcb->PrivateAlreadyPrefixedName.Length;

        if (pMRxDispatch->MRxFlags & RDBSS_MANAGE_FCB_EXTENSION) {
            pFcb->Context = ((PBYTE)pFcb +  QuadAlign(sizeof(FCB)));
        }

        ZeroAndInitializeNodeType(
            &pFcb->FcbTableEntry,
            RDBSS_NTC_FCB_TABLE_ENTRY,
            sizeof(RX_FCB_TABLE_ENTRY));

        InterlockedIncrement(&RxNumberOfActiveFcbs);
        InterlockedIncrement(&RxDeviceObject->NumberOfActiveFcbs);

        // Initialize the Advanced FCB header
        ExInitializeFastMutex(&pNonPagedFcb->AdvancedFcbHeaderMutex);
        FsRtlSetupAdvancedHeader(&pFcb->Header,&pNonPagedFcb->AdvancedFcbHeaderMutex);
    }

    if (pSrvOpen != NULL) {
        ZeroAndInitializeNodeType(
            pSrvOpen,
            RDBSS_NTC_SRVOPEN,
            (NODE_BYTE_SIZE)SrvOpenSize);

        if ((NodeType != RDBSS_NTC_SRVOPEN) ) {
            //here the srvopen has no internal fobx....set the "used" flag
            SetFlag(pSrvOpen->Flags,SRVOPEN_FLAG_FOBX_USED);

            pSrvOpen->InternalFobx    = NULL;
        } else {
            pSrvOpen->InternalFobx    = pFobx;
        }

        if (pMRxDispatch->MRxFlags & RDBSS_MANAGE_SRV_OPEN_EXTENSION) {
            pSrvOpen->Context = ((PBYTE)pSrvOpen + QuadAlign(sizeof(SRV_OPEN)));
        }

        InitializeListHead( &pSrvOpen->SrvOpenQLinks);
    }

    if (pFobx != NULL) {
        ZeroAndInitializeNodeType(
            pFobx,
            RDBSS_NTC_FOBX,
            (NODE_BYTE_SIZE)FobxSize);

        if (pMRxDispatch->MRxFlags & RDBSS_MANAGE_FOBX_EXTENSION) {
            pFobx->Context = ((PBYTE)pFobx + QuadAlign(sizeof(FOBX)));
        }
    }

    return pObject;
}



VOID
RxFreeFcbObject(PVOID pObject)
/*++

Routine Description:

    The routine frees  a FCB/SRV_OPEN and FOBX instance

Arguments:

    pObject      - the instance to be freed

Notes:

--*/
{
    PAGED_CODE();

    switch (NodeType(pObject)) {
    case RDBSS_NTC_FOBX:
    case RDBSS_NTC_SRVOPEN:
        {
            RxFreePool(pObject);
        }
        break;

    default:
        if (NodeTypeIsFcb(pObject)) {
            PFCB pFcb = (PFCB)pObject;
            PRDBSS_DEVICE_OBJECT RxDeviceObject = pFcb->RxDeviceObject;

            //  Release any Filter Context structures associated with this structure
            FsRtlTeardownPerStreamContexts( &pFcb->Header );

            DbgDoit((pFcb->Header.NodeTypeCode |= 0x1000));

            if (pFcb->FcbState & FCB_STATE_PAGING_FILE) {
                RxFreePool(pFcb);
            } else {
                RxFreePool(pFcb->NonPaged);
                RxFreePool(pFcb);
            }

            InterlockedDecrement(&RxNumberOfActiveFcbs);
            InterlockedDecrement(&RxDeviceObject->NumberOfActiveFcbs);
        } else {
            //ASSERT(!"Valid Object Type for RxFreeFcbObject");
        }
    }
}

PFCB
RxCreateNetFcb (
    OUT PRX_CONTEXT    RxContext,
    IN  PV_NET_ROOT    VNetRoot,
    IN PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Fcb record into
    the in memory data structures. The structure allocated has space for a srvopen
    and a fobx. The size for all these things comes from the net root; they have
    already been aligned.

    An additional complication is that i use the same routine to initialize a
    fake fcb for renames. in this case, i don't want it inserted into the tree.
    You get a fake FCB with IrpSp->Flags|SL_OPEN_TAGET_DIRECTORY.

Arguments:

    RxContext - an RxContext describing a create............

    NetRoot - the net root that this FCB is being opened on

    Name - The name of the FCB. the netroot MAY contain a nameprefix that is to be prepended here.

Return Value:

    PFCB - Returns a pointer to the newly allocated FCB

--*/
{
    PFCB      Fcb;

    POOL_TYPE      PoolType;
    NODE_TYPE_CODE NodeType;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    BOOLEAN IsPagingFile;
    BOOLEAN FakeFcb;

    PNET_ROOT NetRoot;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    PRX_FCB_TABLE_ENTRY ThisEntry;

    ULONG   NameSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCreateNetFcb\n", 0));

    ASSERT( VNetRoot && (NodeType(VNetRoot) == RDBSS_NTC_V_NETROOT) );
    NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
    ASSERT( NodeType(NetRoot) == RDBSS_NTC_NETROOT );
    ASSERT( ((PMRX_NET_ROOT)NetRoot) == RxContext->Create.pNetRoot );

    RxDeviceObject = NetRoot->SrvCall->RxDeviceObject;
    ASSERT( RxDeviceObject == RxContext->RxDeviceObject);

    IsPagingFile = BooleanFlagOn( capPARAMS->Flags, SL_OPEN_PAGING_FILE );
    FakeFcb      = (BooleanFlagOn(capPARAMS->Flags,SL_OPEN_TARGET_DIRECTORY) &&
                    !BooleanFlagOn(NetRoot->Flags,NETROOT_FLAG_SUPPORTS_SYMBOLIC_LINKS));

    ASSERT( FakeFcb || RxIsFcbTableLockExclusive ( &NetRoot->FcbTable )  );

    NodeType = (FakeFcb) ? RDBSS_NTC_OPENTARGETDIR_FCB : RDBSS_NTC_STORAGE_TYPE_UNKNOWN;
    PoolType = (IsPagingFile) ? NonPagedPool : PagedPool;

    NameSize = Name->Length + NetRoot->InnerNamePrefix.Length;

    Fcb = RxAllocateFcbObject(RxDeviceObject, NodeType, PoolType, NameSize, NULL);

    if (Fcb != NULL) {
        Fcb->CachedNetRootType = NetRoot->Type;

        //Fcb->MRxDispatch = NetRoot->Dispatch;
        Fcb->RxDeviceObject = RxDeviceObject;
        Fcb->MRxDispatch    = RxDeviceObject->Dispatch;
        Fcb->VNetRoot       = VNetRoot;
        Fcb->pNetRoot       = (PMRX_NET_ROOT)VNetRoot->pNetRoot;

        InitializeListHead(&Fcb->SrvOpenList);

        Fcb->SrvOpenListVersion = 0;

        Fcb->FcbTableEntry.Path.Buffer = (PWCH)((PCHAR)Fcb->PrivateAlreadyPrefixedName.Buffer
                                                 + NetRoot->InnerNamePrefix.Length);
        Fcb->FcbTableEntry.Path.Length = Name->Length;
        Fcb->FcbTableEntry.Path.MaximumLength = Name->Length;

        //  finally, copy in the name, including the netroot prefix
        ThisEntry = &Fcb->FcbTableEntry;

        RxDbgTrace(0, Dbg, ("RxCreateNetFcb name buffer/length %08lx/%08lx\n",
                        ThisEntry->Path.Buffer, ThisEntry->Path.Length));
        RxDbgTrace(0, Dbg, ("RxCreateNetFcb  prefix/name %wZ/%wZ\n",
                        &NetRoot->InnerNamePrefix, Name));

        RtlMoveMemory(
            Fcb->PrivateAlreadyPrefixedName.Buffer,
            NetRoot->InnerNamePrefix.Buffer,
            NetRoot->InnerNamePrefix.Length);

        RtlMoveMemory(
            ThisEntry->Path.Buffer,
            Name->Buffer,
            Name->Length);

        RxDbgTrace(0, Dbg, ("RxCreateNetFcb  apname %wZ\n", &Fcb->PrivateAlreadyPrefixedName));
        RxDbgTrace(0, Dbg, ("RxCreateNetFcb  finalname %wZ\n", &Fcb->FcbTableEntry.Path));

        if (FlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_ADDEDBACKSLASH)) {
            SetFlag(Fcb->FcbState,FCB_STATE_ADDEDBACKSLASH);
        }

        InitializeListHead(&Fcb->NonPaged->TransitionWaitList);

        //  Check to see if we need to set the Fcb state to indicate that this
        //  is a paging file

        if (IsPagingFile) {
            Fcb->FcbState |= FCB_STATE_PAGING_FILE;
        }

        //  Check to see whether this was marked for reparse
        if( (RxContext->MajorFunction == IRP_MJ_CREATE) &&
            (RxContext->Create.Flags & RX_CONTEXT_CREATE_FLAG_SPECIAL_PATH) )
        {
            Fcb->FcbState |= FCB_STATE_SPECIAL_PATH;
        }

        //  The initial state, open count, and segment objects fields are already
        //  zero so we can skip setting them
        //

        //Initialize the resources
        Fcb->Header.Resource = &Fcb->NonPaged->HeaderResource;
        ExInitializeResourceLite(Fcb->Header.Resource);
        Fcb->Header.PagingIoResource = &Fcb->NonPaged->PagingIoResource;
        ExInitializeResourceLite(Fcb->Header.PagingIoResource);

        //Initialize the filesize lock
        FILESIZE_LOCK_DISABLED(
            Fcb->Specific.Fcb.FileSizeLock = &Fcb->NonPaged->FileSizeLock;
            ExInitializeFastMutex(Fcb->Specific.Fcb.FileSizeLock);
            )

        if (!FakeFcb) {
            // everything worked.... insert into netroot table
            RxFcbTableInsertFcb(
                &NetRoot->FcbTable,
                Fcb);
        } else {
            Fcb->FcbState |= FCB_STATE_FAKEFCB|FCB_STATE_NAME_ALREADY_REMOVED;
            InitializeListHead(&Fcb->FcbTableEntry.HashLinks);
            RxLog(("FakeFinally %lx\n",RxContext));
            RxWmiLog(LOG,
                     RxCreateNetFcb_1,
                     LOGPTR(RxContext));
            RxDbgTrace(0, Dbg, ("FakeFcb !!!!!!! Irpc=%08lx\n", RxContext));
        }

        RxReferenceVNetRoot(VNetRoot);
        InterlockedIncrement(&Fcb->pNetRoot->NumberOfFcbs);
        Fcb->ulFileSizeVersion=0;

#ifdef RDBSSLOG
        RxLog(("Fcb nm %lx %wZ",Fcb,&(Fcb->FcbTableEntry.Path)));
        RxWmiLog(LOG,
                 RxCreateNetFcb_2,
                 LOGPTR(Fcb)
                 LOGUSTR(Fcb->FcbTableEntry.Path));
        {
            char buffer[20];
            ULONG len,remaining;
            UNICODE_STRING jPrefix,jSuffix;
            sprintf(buffer,"Fxx nm %p ",Fcb);
            len = strlen(buffer);
            remaining = MAX_RX_LOG_ENTRY_SIZE -1 - len;
            if (remaining<Fcb->FcbTableEntry.Path.Length) {
                jPrefix.Buffer = Fcb->FcbTableEntry.Path.Buffer;
                jPrefix.Length = (USHORT)(sizeof(WCHAR)*(remaining-17));
                jSuffix.Buffer = Fcb->FcbTableEntry.Path.Buffer-15+(Fcb->FcbTableEntry.Path.Length/sizeof(WCHAR));
                jSuffix.Length = sizeof(WCHAR)*15;
                RxLog(("%s%wZ..%wZ",buffer,&jPrefix,&jSuffix));
                RxWmiLog(LOG,
                         RxCreateNetFcb_3,
                         LOGARSTR(buffer)
                         LOGUSTR(jPrefix)
                         LOGUSTR(jSuffix));
            }
        }
#endif
        RxLoudFcbMsg("Create: ",&(Fcb->FcbTableEntry.Path));
        RxDbgTrace(0, Dbg, ("RxCreateNetFcb nm.iso.ifox  %08lx  %08lx %08lx\n",
                        Fcb->FcbTableEntry.Path.Buffer, Fcb->InternalSrvOpen, Fcb->InternalFobx));
        RxDbgTrace(-1, Dbg, ("RxCreateNetFcb  %08lx  %wZ\n", Fcb, &(Fcb->FcbTableEntry.Path)));
    }

    if (Fcb != NULL) {
        RxReferenceNetFcb(Fcb);

#ifdef RX_WJ_DBG_SUPPORT
        RxdInitializeFcbWriteJournalDebugSupport(Fcb);
#endif
    }

    return Fcb;
}

RX_FILE_TYPE
RxInferFileType(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine tries to infer the filetype from the createoptions.

Arguments:

    RxContext      - the context of the Open

Return Value:

    the storagetype implied by the open.

--*/
{
    ULONG CreateOptions = RxContext->Create.NtCreateParameters.CreateOptions;

    PAGED_CODE();

    switch (CreateOptions & (FILE_DIRECTORY_FILE|FILE_NON_DIRECTORY_FILE)) {
    case FILE_DIRECTORY_FILE:
        return(FileTypeDirectory);

    case FILE_NON_DIRECTORY_FILE:
        return(FileTypeFile);

    default:
    case 0:
        return(FileTypeNotYetKnown);  //0 => i don't know the storage type
    }
}

VOID
RxFinishFcbInitialization(
    IN OUT PMRX_FCB MrxFcb,
    IN RDBSS_STORAGE_TYPE_CODES RdbssStorageType,
    IN PFCB_INIT_PACKET InitPacket OPTIONAL
    )
/*++

Routine Description:

    This routine is used to finish initializing an FCB after
    we find out what kind it is.

Arguments:

    Fcb      - the Fcb being initialzed

    StorageType - the type of entity that the FCB refers to

    InitPacket - extra data that is required depending on the type of entity

Return Value:

    none.

--*/
{
    PFCB Fcb = (PFCB)MrxFcb;
    USHORT OldStorageType;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxFcbInit %x  %08lx  %wZ\n",
         RdbssStorageType, Fcb, &(Fcb->FcbTableEntry.Path)));
    OldStorageType = Fcb->Header.NodeTypeCode;
    Fcb->Header.NodeTypeCode =  (CSHORT)RdbssStorageType;

    // only update the information in the Fcb if it's not already set
    if ( !FlagOn(Fcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET) ) {
        if (InitPacket != NULL) {
                Fcb->Attributes = *(InitPacket->pAttributes);
                Fcb->NumberOfLinks = *(InitPacket->pNumLinks);
                Fcb->CreationTime = *(InitPacket-> pCreationTime);
                Fcb->LastAccessTime  = *(InitPacket->pLastAccessTime);
                Fcb->LastWriteTime  = *(InitPacket->pLastWriteTime);
                Fcb->LastChangeTime  = *(InitPacket->pLastChangeTime);
                Fcb->ActualAllocationLength  = InitPacket->pAllocationSize->QuadPart;
                Fcb->Header.AllocationSize  = *(InitPacket->pAllocationSize);
                Fcb->Header.FileSize  = *(InitPacket->pFileSize);
                Fcb->Header.ValidDataLength  = *(InitPacket->pValidDataLength);
                //don't do this yet RxAdjustAllocationSizeforCC(Fcb);
                SetFlag(Fcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET);
            }
        } else {
            if (RdbssStorageType == RDBSS_NTC_MAILSLOT){
                Fcb->Attributes = 0;
                Fcb->NumberOfLinks = 0;
                Fcb->CreationTime.QuadPart =  0;
                Fcb->LastAccessTime.QuadPart  = 0;
                Fcb->LastWriteTime.QuadPart  = 0;
                Fcb->LastChangeTime.QuadPart  = 0;
                Fcb->ActualAllocationLength  = 0;
                Fcb->Header.AllocationSize.QuadPart  = 0;
                Fcb->Header.FileSize.QuadPart  = 0;
                Fcb->Header.ValidDataLength.QuadPart  = 0;
                SetFlag(Fcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET);
            }
        }

    switch (RdbssStorageType) {
    case RDBSS_NTC_MAILSLOT:
    case RDBSS_NTC_SPOOLFILE:
        break;

    case RDBSS_STORAGE_NTC(FileTypeDirectory):
    case RDBSS_STORAGE_NTC(FileTypeNotYetKnown):
        break;

    case RDBSS_STORAGE_NTC(FileTypeFile):

        if (OldStorageType == RDBSS_STORAGE_NTC(FileTypeFile)) break;

        RxInitializeLowIoPerFcbInfo(&Fcb->Specific.Fcb.LowIoPerFcbInfo);

        FsRtlInitializeFileLock(
            &Fcb->Specific.Fcb.FileLock,
            RxLockOperationCompletion,
            RxUnlockOperation );

        //
        //  Initialize the oplock structure. NOT YET IMPLEMENTED!!!

        //FsRtlInitializeOplock( &Fcb->Specific.Fcb.Oplock );

        //
        //  Indicate that we want to be consulted on whether Fast I/O is possible

        Fcb->Header.IsFastIoPossible = FastIoIsQuestionable;
        break;


    default:
       ASSERT(FALSE);
        break;
    }

    return;
}

VOID
RxRemoveNameNetFcb (
    OUT PFCB ThisFcb
    )
/*++

Routine Description:

    The routine removes the name from the table and sets a flag indicateing
    that it has done so. You must have already acquired the netroot
    tablelock and have the fcblock as well.

Arguments:

    ThisFcb      - the Fcb being dereferenced

Return Value:

    none.

--*/
{
    PNET_ROOT NetRoot;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("RxRemoveNameNetFcb<+> %08lx %wZ RefC=%ld\n",
                               ThisFcb,&ThisFcb->FcbTableEntry.Path,
                               ThisFcb->NodeReferenceCount));

    ASSERT( NodeTypeIsFcb(ThisFcb));

    NetRoot = (PNET_ROOT)ThisFcb->VNetRoot->NetRoot;

    ASSERT( RxIsFcbTableLockExclusive( &NetRoot->FcbTable ));
    ASSERT( RxIsFcbAcquiredExclusive( ThisFcb ));

    RxFcbTableRemoveFcb(
        &NetRoot->FcbTable,
        ThisFcb);

    RxLoudFcbMsg("RemoveName: ",&(ThisFcb->FcbTableEntry.Path));

    SetFlag(ThisFcb->FcbState, FCB_STATE_NAME_ALREADY_REMOVED);

    RxDbgTrace(-1, Dbg, ("RxRemoveNameNetFcb<-> %08lx\n", ThisFcb));
}

VOID
RxPurgeFcb(
    PFCB pFcb)
/*++

Routine Description:

    The routine purges a given FCB instance. If the FCB has an open section
    against it caused by cacheing the file then we need to purge to get
    the close

Arguments:

    pFcb      - the Fcb being dereferenced

Notes:

    On Entry to this routine the FCB must be accquired exclusive.

    On Exit the FCB resource will be released and the FCB finalized if possible

--*/
{
    PAGED_CODE();

    ASSERT(RxIsFcbAcquiredExclusive(pFcb));

    //make sure that it doesn't disappear
    RxReferenceNetFcb(pFcb);

    if (pFcb->OpenCount) {
        RxPurgeFcbInSystemCache(
            pFcb,
            NULL,
            0,
            TRUE,
            TRUE);
    }

    if (!RxDereferenceAndFinalizeNetFcb(pFcb,NULL,FALSE,FALSE)) {
        //if it remains, then release else, you can't!!
        RxReleaseFcb(NULL,pFcb);
    }
}

BOOLEAN
RxFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize,
    IN  LONG      ReferenceCount
    )
/*++

Routine Description:

    The routine finalizes the given Fcb. This routine needs
    the netroot tablelock; get it beforehand.

Arguments:

    ThisFcb      - the Fcb being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

--*/
{
    BOOLEAN NodeActuallyFinalized = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFinalizeNetFcb<+> %08lx %wZ RefC=%ld\n",
                               ThisFcb,&ThisFcb->FcbTableEntry.Path,
                               ReferenceCount));
    RxLoudFcbMsg("Finalize: ",&(ThisFcb->FcbTableEntry.Path));

    ASSERT_CORRECT_FCB_STRUCTURE(ThisFcb);

    ASSERT(RxIsFcbAcquiredExclusive( ThisFcb ));
    ASSERT(!ForceFinalize);

    if (!RecursiveFinalize) {
        if ((ThisFcb->OpenCount != 0) || (ThisFcb->UncleanCount != 0)) {
            // The FCB cannot be finalized because there are outstanding refrences to it.
            ASSERT(ReferenceCount > 0);
            return NodeActuallyFinalized;
        }
    } else {
        PSRV_OPEN SrvOpen;
        PLIST_ENTRY ListEntry;

        IF_DEBUG{
            if ( FALSE && ReferenceCount){
                RxDbgTrace(0, Dbg, ("    BAD!!!!!ReferenceCount = %08lx\n", ReferenceCount));
            }
        }

        ListEntry = ThisFcb->SrvOpenList.Flink;
        while (ListEntry != &ThisFcb->SrvOpenList) {
            SrvOpen = CONTAINING_RECORD( ListEntry, SRV_OPEN, SrvOpenQLinks );
            ListEntry = ListEntry->Flink;
            RxFinalizeSrvOpen(SrvOpen,TRUE,ForceFinalize);
        }
    }

    RxDbgTrace(0, Dbg, ("   After Recursive Part, REfC=%lx\n", ReferenceCount));

    // After the recursive finalization the reference count associated with the FCB
    // could be atmost 1 for further finalization to occur. This final reference count
    // belongs to the prefix name table of the NetRoot.

    //The actual finalization is divided into two parts:
    //  1) if we're at the end (refcount==1) or being forced, we do the one-time only stuff
    //  2) if the refcount goes to zero, we actually do the free

    ASSERT(ReferenceCount >= 1);
    if (ReferenceCount == 1  || ForceFinalize ) {

        PV_NET_ROOT VNetRoot = ThisFcb->VNetRoot;

        ASSERT(ForceFinalize ||
              (ThisFcb->OpenCount == 0) && (ThisFcb->UncleanCount == 0));

        RxLog(("FinalFcb %lx %lx %lx %lx",
                ThisFcb,ForceFinalize,ReferenceCount,ThisFcb->OpenCount));
        RxWmiLog(LOG,
                 RxFinalizeNetFcb,
                 LOGPTR(ThisFcb)
                 LOGUCHAR(ForceFinalize)
                 LOGULONG(ReferenceCount)
                 LOGULONG(ThisFcb->OpenCount));

        RxDbgTrace(0, Dbg, ("   Before Phase 1, REfC=%lx\n", ReferenceCount));
        if (!ThisFcb->UpperFinalizationDone) {

            switch (NodeType(ThisFcb)) {
            case RDBSS_STORAGE_NTC(FileTypeFile):
                //FsRtlUninitializeOplock( &ThisFcb->Specific.Fcb.Oplock ); //NOT YET IMPLEMENTED
                FsRtlUninitializeFileLock( &ThisFcb->Specific.Fcb.FileLock );
                break;

            default:
                break;
            }

            if (!FlagOn(ThisFcb->FcbState,FCB_STATE_ORPHANED)) {
                PNET_ROOT NetRoot = VNetRoot->NetRoot;

                ASSERT(RxIsFcbTableLockExclusive ( &NetRoot->FcbTable ));

                if (!FlagOn(ThisFcb->FcbState, FCB_STATE_NAME_ALREADY_REMOVED)){
                    RxFcbTableRemoveFcb(
                        &NetRoot->FcbTable,
                        ThisFcb);
                }
            }

            RxDbgTrace(0, Dbg, ("   EndOf  Phase 1, REfC=%lx\n", ReferenceCount));
            ThisFcb->UpperFinalizationDone = TRUE;
        }

        RxDbgTrace(0, Dbg, ("   After  Phase 1, REfC=%lx\n", ReferenceCount));
        ASSERT(ReferenceCount >= 1);
        if (ReferenceCount==1) {
            if (ThisFcb->pBufferingStateChangeCompletedEvent != NULL) {
                RxFreePool(ThisFcb->pBufferingStateChangeCompletedEvent);
            }

            if (ThisFcb->MRxDispatch != NULL) {
                ThisFcb->MRxDispatch->MRxDeallocateForFcb((PMRX_FCB)ThisFcb);
            }

            DbgDoit(ThisFcb->NonPaged->NodeTypeCode &= ~0x4000);

            ExDeleteResourceLite(ThisFcb->Header.Resource);
            ExDeleteResourceLite(ThisFcb->Header.PagingIoResource);

            InterlockedDecrement(&ThisFcb->pNetRoot->NumberOfFcbs);
            RxDereferenceVNetRoot(VNetRoot,LHS_LockNotHeld);

            ASSERT(IsListEmpty(&ThisFcb->FcbTableEntry.HashLinks));

#ifdef RX_WJ_DBG_SUPPORT
        RxdTearDownFcbWriteJournalDebugSupport(ThisFcb);
#endif

            NodeActuallyFinalized = TRUE;
            ASSERT(!(ThisFcb->fMiniInited));
            RxFreeFcbObject(ThisFcb);
        }


    } else {
        RxDbgTrace(0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!'));
    }

    RxDbgTrace(-1, Dbg, ("RxFinalizeNetFcb<-> %08lx\n", ThisFcb, NodeActuallyFinalized));

    return NodeActuallyFinalized;
}

VOID
RxSetFileSizeWithLock (
    IN OUT PFCB Fcb,
    IN     PLONGLONG FileSize
    )
/*++

Routine Description:

    This routine sets the filesize in the fcb header, taking a lock to ensure
    that the 64-bit value is set and read consistently.

Arguments:

    Fcb        - the associated fcb

    FileSize   - ptr to the new filesize

Return Value:

    none

Notes:

--*/
{
    PAGED_CODE();

    FILESIZE_LOCK_DISABLED(RxAcquireFileSizeLock(Fcb);)
    Fcb->Header.FileSize.QuadPart = *FileSize;
    Fcb->ulFileSizeVersion++;
    FILESIZE_LOCK_DISABLED(RxReleaseFileSizeLock(Fcb);)
}


VOID
RxGetFileSizeWithLock (
    IN     PFCB Fcb,
    OUT    PLONGLONG FileSize
    )
/*++

Routine Description:

    This routine gets the filesize in the fcb header, taking a lock to ensure
    that the 64-bit value is set and read consistently.

Arguments:

    Fcb        - the associated fcb

    FileSize   - ptr to the new filesize

Return Value:

    none

Notes:

--*/
{
    PAGED_CODE();

    FILESIZE_LOCK_DISABLED(RxAcquireFileSizeLock(Fcb);)
    *FileSize = Fcb->Header.FileSize.QuadPart;
    FILESIZE_LOCK_DISABLED(RxReleaseFileSizeLock(Fcb);)
}



PSRV_OPEN
RxCreateSrvOpen (
    IN     PV_NET_ROOT pVNetRoot,
    IN OUT PFCB        Fcb)
/*++

Routine Description:

    This routine allocates, initializes, and inserts a new srv_open record into
    the in memory data structures. If a new structure has to be allocated, it
    has space for a fobx. This routine sets the refcount to 1 and leaves the
    srv_open in Condition_InTransition.

Arguments:

    pVNetRoot  - the V_NET_ROOT instance

    Fcb        - the associated fcb

Return Value:

    the new SRV_OPEN instance

Notes:

    On Entry : The FCB associated with the SRV_OPEN must have been acquired exclusive

    On Exit  : No change in resource ownership

--*/
{
    PSRV_OPEN SrvOpen = NULL;
    PNET_ROOT NetRoot;
    POOL_TYPE PoolType;
    ULONG     SrvOpenFlags;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCreateNetSrvOpen\n", 0));

    ASSERT ( NodeTypeIsFcb(Fcb) );
    ASSERT ( RxIsFcbAcquiredExclusive ( Fcb )  );

    NetRoot = (PNET_ROOT)Fcb->VNetRoot->NetRoot;

    try {
        PoolType = (Fcb->FcbState & FCB_STATE_PAGING_FILE) ? NonPagedPool : PagedPool;
        SrvOpen = Fcb->InternalSrvOpen;

        if ((SrvOpen != NULL) &&
            !(FlagOn(Fcb->FcbState,FCB_STATE_SRVOPEN_USED)) &&
            !(FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_ENCLOSED_ALLOCATED)) &&
            IsListEmpty(&SrvOpen->SrvOpenQLinks)) {

            RxAllocateFcbObject(
                NetRoot->SrvCall->RxDeviceObject,
                RDBSS_NTC_INTERNAL_SRVOPEN,
                PoolType,
                0,
                SrvOpen); //this just initializes

            SetFlag(Fcb->FcbState,FCB_STATE_SRVOPEN_USED);
            SrvOpenFlags = SRVOPEN_FLAG_FOBX_USED | SRVOPEN_FLAG_ENCLOSED_ALLOCATED;
        } else {
            SrvOpen  = RxAllocateFcbObject(NetRoot->SrvCall->RxDeviceObject,RDBSS_NTC_SRVOPEN,PoolType,0, NULL);
            SrvOpenFlags = 0;
        }

        if (SrvOpen != NULL) {
            SrvOpen->Flags = SrvOpenFlags;
            SrvOpen->Fcb   = Fcb;
            SrvOpen->pAlreadyPrefixedName = &Fcb->PrivateAlreadyPrefixedName;

            SrvOpen->pVNetRoot = (PMRX_V_NET_ROOT)pVNetRoot;
            RxReferenceVNetRoot(pVNetRoot);
            InterlockedIncrement(&pVNetRoot->pNetRoot->NumberOfSrvOpens);

            SrvOpen->NodeReferenceCount = 1;

            RxReferenceNetFcb(Fcb); //already have the lock
            InsertTailList(&Fcb->SrvOpenList,&SrvOpen->SrvOpenQLinks);
            Fcb->SrvOpenListVersion++;

            InitializeListHead(&SrvOpen->FobxList);
            InitializeListHead(&SrvOpen->TransitionWaitList);
            InitializeListHead(&SrvOpen->ScavengerFinalizationList);
            InitializeListHead(&SrvOpen->SrvOpenKeyList);
        }
    } finally {

       DebugUnwind( RxCreateFcb );

       if (AbnormalTermination()) {

           //  If this is an abnormal termination then undo our work; this is
           //  one of those happy times when the existing code will work

           if (SrvOpen != NULL) {
               RxFinalizeSrvOpen( SrvOpen,TRUE,TRUE );
           }
       } else {
           if (SrvOpen != NULL) {
               RxLog(("SrvOp %lx %lx\n",SrvOpen,SrvOpen->Fcb));
               RxWmiLog(LOG,
                        RxCreateSrvOpen,
                        LOGPTR(SrvOpen)
                        LOGPTR(SrvOpen->Fcb));
           }
       }
   }

   RxDbgTrace(-1, Dbg, ("RxCreateNetSrvOpen -> %08lx\n", SrvOpen));

   return SrvOpen;
}

BOOLEAN
RxFinalizeSrvOpen (
    OUT PSRV_OPEN ThisSrvOpen,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given SrvOpen.

Arguments:

    ThisSrvOpen      - the SrvOpen being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

Notes:

    On Entry : 1) The FCB associated with the SRV_OPEN must have been acquired exclusive
               2) The tablelock associated with FCB's NET_ROOT instance must have been
                  acquired shared(atleast)

    On Exit  : No change in resource ownership

--*/
{
    NTSTATUS Status;
    BOOLEAN  NodeActuallyFinalized = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFinalizeSrvOpen<+> %08lx %wZ RefC=%ld\n",
                               ThisSrvOpen,&ThisSrvOpen->Fcb->FcbTableEntry.Path,
                               ThisSrvOpen->NodeReferenceCount));

    ASSERT(NodeType(ThisSrvOpen) == RDBSS_NTC_SRVOPEN );

    if (RecursiveFinalize) {
        PFOBX Fobx;
        PLIST_ENTRY ListEntry;

        IF_DEBUG{
            if ( FALSE && ThisSrvOpen->NodeReferenceCount){
                RxDbgTrace(0, Dbg, ("    BAD!!!!!ReferenceCount = %08lx\n", ThisSrvOpen->NodeReferenceCount));
            }
        }

        ListEntry = ThisSrvOpen->FobxList.Flink;
        while (ListEntry != &ThisSrvOpen->FobxList) {
            Fobx = CONTAINING_RECORD( ListEntry, FOBX, FobxQLinks );
            ListEntry = ListEntry->Flink;
            RxFinalizeNetFobx(Fobx,TRUE,ForceFinalize);
        }
    }



    if( ThisSrvOpen->NodeReferenceCount == 0  || ForceFinalize ){
        BOOLEAN FreeSrvOpen;
        PFCB     Fcb;

        Fcb = ThisSrvOpen->Fcb;

        RxLog(("FinalSrvOp %lx %lx %lx",
                ThisSrvOpen,ForceFinalize,ThisSrvOpen->NodeReferenceCount
                 ));
        RxWmiLog(LOG,
                 RxFinalizeSrvOpen,
                 LOGPTR(ThisSrvOpen)
                 LOGUCHAR(ForceFinalize)
                 LOGULONG(ThisSrvOpen->NodeReferenceCount));

        FreeSrvOpen = !FlagOn(ThisSrvOpen->Flags,SRVOPEN_FLAG_ENCLOSED_ALLOCATED);

        if ((!ThisSrvOpen->UpperFinalizationDone) &&
            ((ThisSrvOpen->Condition != Condition_Good) ||
             (ThisSrvOpen->Flags & SRVOPEN_FLAG_CLOSED))) {

            ASSERT(NodeType(Fcb) != RDBSS_NTC_OPENTARGETDIR_FCB );
            ASSERT(RxIsFcbAcquiredExclusive ( Fcb )  );

            RxPurgeChangeBufferingStateRequestsForSrvOpen(ThisSrvOpen);

            if (!FlagOn(Fcb->FcbState,FCB_STATE_ORPHANED)) {
               // close the file.
               MINIRDR_CALL_THROUGH(Status,Fcb->MRxDispatch,MRxForceClosed,((PMRX_SRV_OPEN)ThisSrvOpen));
            }

            RemoveEntryList ( &ThisSrvOpen->SrvOpenQLinks);
            InitializeListHead( &ThisSrvOpen->SrvOpenQLinks);

            Fcb->SrvOpenListVersion++;

            if (ThisSrvOpen->pVNetRoot != NULL) {
                InterlockedDecrement(&ThisSrvOpen->pVNetRoot->pNetRoot->NumberOfSrvOpens);
                RxDereferenceVNetRoot(
                    (PV_NET_ROOT)ThisSrvOpen->pVNetRoot,
                    LHS_LockNotHeld);
                ThisSrvOpen->pVNetRoot = NULL;
            }

            ThisSrvOpen->UpperFinalizationDone = TRUE;
        }

        if (ThisSrvOpen->NodeReferenceCount == 0) {
            ASSERT(IsListEmpty(&ThisSrvOpen->SrvOpenKeyList));

            if (!IsListEmpty(&ThisSrvOpen->SrvOpenQLinks)) {
                RemoveEntryList(&ThisSrvOpen->SrvOpenQLinks);
                InitializeListHead(&ThisSrvOpen->SrvOpenQLinks);
            }

            if (FreeSrvOpen ) {
                RxFreeFcbObject(ThisSrvOpen);
            }

            if (!FreeSrvOpen){
               ClearFlag(Fcb->FcbState,FCB_STATE_SRVOPEN_USED);
            }

            RxDereferenceNetFcb(Fcb);
        }

        NodeActuallyFinalized = TRUE;
    } else {
        RxDbgTrace(0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!'));
    }

    RxDbgTrace(-1, Dbg, ("RxFinalizeSrvOpen<-> %08lx\n", ThisSrvOpen, NodeActuallyFinalized));

    return NodeActuallyFinalized;
}

ULONG RxPreviousFobxSerialNumber = 0;

PMRX_FOBX
RxCreateNetFobx (
    OUT PRX_CONTEXT    RxContext,
    IN  PMRX_SRV_OPEN  mrxSrvOpen
    )
/*++

Routine Description:

    This routine allocates, initializes, and inserts a new file object extension instance.

Arguments:

    RxContext - an RxContext describing a create............

    pSrvOpen - the associated SrvOpen

Return Value:

    none

Notes:

    On Entry : FCB associated with the FOBX instance have been acquired exclusive.

    On Exit  : No change in resource ownership

--*/
{
    PFCB      pFcb;
    PFOBX     pFobx;
    PSRV_OPEN pSrvOpen = (PSRV_OPEN)mrxSrvOpen;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    ULONG     FobxFlags;
    POOL_TYPE PoolType;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCreateFobx<+>\n", 0));

    ASSERT(NodeType(pSrvOpen) == RDBSS_NTC_SRVOPEN);
    ASSERT( NodeTypeIsFcb(pSrvOpen->Fcb) );
    ASSERT(RxIsFcbAcquiredExclusive(pSrvOpen->Fcb));

    pFcb = pSrvOpen->Fcb;

    PoolType = (pFcb->FcbState & FCB_STATE_PAGING_FILE) ? NonPagedPool : PagedPool;
    if (!(FlagOn(pFcb->FcbState,FCB_STATE_FOBX_USED)) &&
        (pSrvOpen == pFcb->InternalSrvOpen)){
        // Try and use the FOBX allocated as part of the FCB if it is available
        pFobx = pFcb->InternalFobx;
        RxAllocateFcbObject(
            pFcb->RxDeviceObject,
            RDBSS_NTC_FOBX,PoolType,
            0,
            pFobx);//just initialize

        SetFlag(pFcb->FcbState,FCB_STATE_FOBX_USED);
        FobxFlags = FOBX_FLAG_ENCLOSED_ALLOCATED;
    } else if (!(FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_FOBX_USED))){
        // Try and use the FOBX allocated as part of the SRV_OPEN if it is available
        pFobx = pSrvOpen->InternalFobx;
        RxAllocateFcbObject(
            pFcb->RxDeviceObject,
            RDBSS_NTC_FOBX,
            PoolType,
            0,
            pFobx);//just initialize
        SetFlag(pSrvOpen->Flags,SRVOPEN_FLAG_FOBX_USED);
        FobxFlags = FOBX_FLAG_ENCLOSED_ALLOCATED;
    } else {
        pFobx = RxAllocateFcbObject(
                    pFcb->RxDeviceObject,
                    RDBSS_NTC_FOBX,
                    PoolType,
                    0,
                    NULL);
        FobxFlags = 0;
    }

    if (pFobx != NULL) {
        PMRX_NET_ROOT pNetRoot;
        pFobx->Flags = FobxFlags;

        if ((pNetRoot = RxContext->Create.pNetRoot) != NULL) {
            switch (pNetRoot->DeviceType) {
            case RxDeviceType(NAMED_PIPE):
                RxInitializeThrottlingState(
                        &pFobx->Specific.NamedPipe.ThrottlingState,
                        pNetRoot->NamedPipeParameters.PipeReadThrottlingParameters.Increment,
                        pNetRoot->NamedPipeParameters.PipeReadThrottlingParameters.MaximumDelay
                        );
                break;
            case RxDeviceType(DISK):
                RxInitializeThrottlingState(
                        &pFobx->Specific.DiskFile.LockThrottlingState,
                        pNetRoot->DiskParameters.LockThrottlingParameters.Increment,
                        pNetRoot->DiskParameters.LockThrottlingParameters.MaximumDelay
                        );
                break;
            }
        }

        if (FlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_UNC_NAME)){
            SetFlag(pFobx->Flags,FOBX_FLAG_UNC_NAME);
            //DbgPrint("setting UNC flag in fobx\n");
        }

        if (FlagOn(RxContext->Create.NtCreateParameters.CreateOptions,FILE_OPEN_FOR_BACKUP_INTENT)) {
            SetFlag(pFobx->Flags,FOBX_FLAG_BACKUP_INTENT);
        }

        pFobx->FobxSerialNumber = 0;
        pFobx->SrvOpen = pSrvOpen;
        pFobx->NodeReferenceCount = 1;
        pFobx->fOpenCountDecremented = FALSE;
        RxReferenceSrvOpen(pSrvOpen);
        InterlockedIncrement(&pSrvOpen->pVNetRoot->NumberOfFobxs);
        InsertTailList(&pSrvOpen->FobxList,&pFobx->FobxQLinks);

        InitializeListHead(&pFobx->ClosePendingList);
        InitializeListHead(&pFobx->ScavengerFinalizationList);
        RxLog(("Fobx %lx %lx %lx\n",pFobx,pFobx->SrvOpen,pFobx->SrvOpen->Fcb));
        RxWmiLog(LOG,
                 RxCreateNetFobx,
                 LOGPTR(pFobx)
                 LOGPTR(pFobx->SrvOpen)
                 LOGPTR(pFobx->SrvOpen->Fcb));
    }

    RxDbgTrace(-1, Dbg, ("RxCreateNetFobx<-> %08lx\n", pFobx));
    return (PMRX_FOBX)pFobx;
}

BOOLEAN
RxFinalizeNetFobx (
    OUT PFOBX ThisFobx,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given Fobx. you need exclusive fcblock.

Arguments:

    ThisFobx - the Fobx being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

Notes:

    On Entry : FCB associated with the FOBX instance must have been acquired exclusive.

    On Exit  : No change in resource ownership

--*/
{
    BOOLEAN NodeActuallyFinalized = FALSE;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("RxFinalizeFobx<+> %08lx %wZ RefC=%ld\n",
                               ThisFobx,&ThisFobx->SrvOpen->Fcb->FcbTableEntry.Path,
                               ThisFobx->NodeReferenceCount));

    ASSERT( NodeType(ThisFobx) == RDBSS_NTC_FOBX );

    if( ThisFobx->NodeReferenceCount == 0  || ForceFinalize ){
        NTSTATUS  Status;
        PSRV_OPEN SrvOpen  = ThisFobx->SrvOpen;
        PFCB Fcb = SrvOpen->Fcb;
        BOOLEAN FreeFobx = !FlagOn(ThisFobx->Flags,FOBX_FLAG_ENCLOSED_ALLOCATED);

        RxLog(("FinalFobx %lx %lx %lx",
                ThisFobx,ForceFinalize,ThisFobx->NodeReferenceCount
                 ));
        RxWmiLog(LOG,
                 RxFinalizeNetFobx_1,
                 LOGPTR(ThisFobx)
                 LOGUCHAR(ForceFinalize)
                 LOGULONG(ThisFobx->NodeReferenceCount));

        if (!ThisFobx->UpperFinalizationDone) {

            ASSERT(NodeType(ThisFobx->SrvOpen->Fcb) != RDBSS_NTC_OPENTARGETDIR_FCB );
            ASSERT( RxIsFcbAcquiredExclusive ( ThisFobx->SrvOpen->Fcb )  );

            RemoveEntryList ( &ThisFobx->FobxQLinks);

            if (FlagOn(ThisFobx->Flags,FOBX_FLAG_FREE_UNICODE)){
                RxFreePool(ThisFobx->UnicodeQueryTemplate.Buffer);
            }

            if ((Fcb->MRxDispatch != NULL) && (Fcb->MRxDispatch->MRxDeallocateForFobx != NULL)) {
                Fcb->MRxDispatch->MRxDeallocateForFobx((PMRX_FOBX)ThisFobx);
            }

            if (!FlagOn(ThisFobx->Flags,FOBX_FLAG_SRVOPEN_CLOSED)) {
                // DbgPrint("@@@@ CloseAssociatedSrvOpen FOBX(%lx) SrvOpen(%lx) %wZ\n",ThisFobx,SrvOpen,&SrvOpen->Fcb->FcbTableEntry.Path);
                Status = RxCloseAssociatedSrvOpen(ThisFobx,NULL);
                RxLog(("$$ScCl FOBX %lx SrvOp %lx %lx\n",ThisFobx,ThisFobx->SrvOpen,Status));
                RxWmiLog(LOG,
                         RxFinalizeNetFobx_2,
                         LOGPTR(ThisFobx)
                         LOGPTR(ThisFobx->SrvOpen)
                         LOGULONG(Status));
            }

            ThisFobx->UpperFinalizationDone = TRUE;
        }

        if (ThisFobx->NodeReferenceCount == 0){
            ASSERT(IsListEmpty(&ThisFobx->ClosePendingList));

            if (ThisFobx == Fcb->InternalFobx) {
                ClearFlag(Fcb->FcbState,FCB_STATE_FOBX_USED);
            } else if (ThisFobx == SrvOpen->InternalFobx) {
                ClearFlag(SrvOpen->Flags,SRVOPEN_FLAG_FOBX_USED);
            }

            if (SrvOpen != NULL) {
                ThisFobx->SrvOpen = NULL;
                InterlockedDecrement(&SrvOpen->pVNetRoot->NumberOfFobxs);
                RxDereferenceSrvOpen(SrvOpen,LHS_ExclusiveLockHeld);
            }

            if (FreeFobx){
                RxFreeFcbObject(ThisFobx);
            }

            NodeActuallyFinalized = TRUE;
        }

    } else {
        RxDbgTrace(0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!'));
    }

    RxDbgTrace(-1, Dbg, ("RxFinalizeFobx<-> %08lx\n", ThisFobx, NodeActuallyFinalized));

    return NodeActuallyFinalized;

}

//#define RDBSS_ENABLELOUDFCBOPSBYDEFAULT
#if DBG
#ifdef RDBSS_ENABLELOUDFCBOPSBYDEFAULT
BOOLEAN RxLoudFcbOpsOnExes = TRUE;
#else
BOOLEAN RxLoudFcbOpsOnExes = FALSE;
#endif // RDBSS_ENABLELOUDFCBOPSBYDEFAULT
BOOLEAN
RxLoudFcbMsg(
    PUCHAR msg,
    PUNICODE_STRING   Name
    )
{
    PWCHAR Buffer;
    ULONG Length;

    if (!RxLoudFcbOpsOnExes) {
        return FALSE;
    }

    Length = (Name->Length)/sizeof(WCHAR);
    Buffer = Name->Buffer + Length;

    if (
          ( Length < 4 )
         || ( (Buffer[-1]&'E') != 'E' )
         || ( (Buffer[-2]&'X') != 'X' )
         || ( (Buffer[-3]&'E') != 'E' )
         || ( (Buffer[-4]&'.') != '.' )
       ) { return FALSE; }

    DbgPrint("--->%s %wZ\n",msg,Name);
    return(TRUE);
}
#endif


VOID
RxCheckFcbStructuresForAlignment(void)
{
    ULONG StructureId;

    PAGED_CODE();

    if (FIELD_OFFSET(NET_ROOT,SrvCall) != FIELD_OFFSET(NET_ROOT,pSrvCall)) {
        StructureId = 'RN'; goto DO_A_BUGCHECK;
    }
    if (FIELD_OFFSET(V_NET_ROOT,NetRoot) != FIELD_OFFSET(V_NET_ROOT,pNetRoot)) {
        StructureId = 'RNV'; goto DO_A_BUGCHECK;
    }
    if (FIELD_OFFSET(FCB,VNetRoot) != FIELD_OFFSET(FCB,VNetRoot)) {
        StructureId = 'BCF'; goto DO_A_BUGCHECK;
    }
    if (FIELD_OFFSET(SRV_OPEN,Fcb) != FIELD_OFFSET(SRV_OPEN,pFcb)) {
        StructureId = 'NPOS'; goto DO_A_BUGCHECK;
    }
    if (FIELD_OFFSET(FOBX,SrvOpen) != FIELD_OFFSET(FOBX,pSrvOpen)) {
        StructureId = 'XBOF'; goto DO_A_BUGCHECK;
    }

    return;
DO_A_BUGCHECK:
    RxBugCheck( StructureId, 0, 0 );
}

BOOLEAN
RxIsThisACscAgentOpen(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the open was made by the user mode CSC agent.

Arguments:

    RxContext - the RDBSS context

Return Value:

    TRUE - if it is an agent open, FALSE otherwise

Notes:

    The agent opens are always satisfied by going to the server. They are never
    satisfied from the cached copies. This enables reintegration using snapshots
    even when the files are being currently used.

--*/
{
    BOOLEAN AgentOpen = FALSE;
    ULONG   EaInformationLength;

    PDFS_NAME_CONTEXT pDfsNameContext;

    if (RxContext->Create.EaLength > 0) {
        PFILE_FULL_EA_INFORMATION pEaEntry;

        pEaEntry = (PFILE_FULL_EA_INFORMATION)RxContext->Create.EaBuffer;
        ASSERT(pEaEntry != NULL);

        for(;;) {
            if (strcmp(pEaEntry->EaName, EA_NAME_CSCAGENT) == 0) {
                AgentOpen = TRUE;
                break;
            }

            if (pEaEntry->NextEntryOffset == 0) {
                break;
            } else {
                pEaEntry = (PFILE_FULL_EA_INFORMATION)
                           ((PCHAR) pEaEntry + pEaEntry->NextEntryOffset);
            }
        }
    }

    pDfsNameContext = RxContext->Create.NtCreateParameters.DfsNameContext;

    if ((pDfsNameContext != NULL) &&
        (pDfsNameContext->NameContextType == DFS_CSCAGENT_NAME_CONTEXT)) {
        AgentOpen = TRUE;
    }

    return AgentOpen;
}

VOID
RxOrphanThisFcb(
    PFCB    pFcb
    )
/*++

Routine Description:

    This routine orphans an FCB

Arguments:

    pFcb - the fcb to be orphaned

Return Value:

    None

Notes:


--*/
{
    // force orphan all SrvOpens for this FCB and orphan the FCB itself
    RxOrphanSrvOpensForThisFcb(pFcb, NULL, TRUE);
}

VOID
RxOrphanSrvOpensForThisFcb(
    PFCB            pFcb,
    IN PV_NET_ROOT  ThisVNetRoot,
    BOOLEAN         fOrphanAll
    )
/*++

Routine Description:

    This routine orphans all srvopens for a file belonging to a particular VNetRoot. The
    SrvOpen collapsing routine elsewhere makes sure that srvopens for different vnetroots
    are not collapsed.

Arguments:

    pFcb            - the fcb whose srvopens need to be orphaned

    ThisVNetRoot    - the VNetRoot for which the SrvOpens have to be orphaned

    fOrphanAll      - Orphan all SrvOpens, ie ignore the ThisVNetRoot parameter

Return Value:

    None

Notes:



--*/
{

    NTSTATUS    Status;
    PLIST_ENTRY pListEntry;
    BOOLEAN    fAllSrvOpensOrphaned = TRUE;

//    fOrphanAll = TRUE; // temporarily force the old behaviour

    Status = RxAcquireExclusiveFcb(NULL,pFcb);
    ASSERT(Status == STATUS_SUCCESS);
    RxReferenceNetFcb(pFcb);

    pListEntry = pFcb->SrvOpenList.Flink;
    while (pListEntry != &pFcb->SrvOpenList) {
        PSRV_OPEN pSrvOpen;

        pSrvOpen = (PSRV_OPEN)
                   (CONTAINING_RECORD(
                        pListEntry,
                        SRV_OPEN,
                        SrvOpenQLinks));

        pListEntry = pSrvOpen->SrvOpenQLinks.Flink;
        if (!FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_ORPHANED))
        {
            // NB check fOrphanAll first as if it is TRUE, the ThisVNetRoot
            // parameter maybe NULL
            if (fOrphanAll || ((PV_NET_ROOT)(pSrvOpen->pVNetRoot) == ThisVNetRoot))
            {
                PLIST_ENTRY pEntry;
                PFOBX       pFobx;

                SetFlag(pSrvOpen->Flags, SRVOPEN_FLAG_ORPHANED);

                RxAcquireScavengerMutex();

                pEntry = pSrvOpen->FobxList.Flink;

                while (pEntry != &pSrvOpen->FobxList) {
                    pFobx  = (PFOBX)CONTAINING_RECORD(
                                 pEntry,
                                 FOBX,
                                 FobxQLinks);

                    if (!pFobx->fOpenCountDecremented) {
                        InterlockedDecrement(&pFcb->OpenCount);
                        pFobx->fOpenCountDecremented = TRUE;
                    }

                    pEntry = pEntry->Flink;
                }

                RxReleaseScavengerMutex();

                if (!FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_CLOSED) &&
                    !IsListEmpty(&pSrvOpen->FobxList)) {
                    PLIST_ENTRY pEntry;
                    NTSTATUS Status;
                    PFOBX    pFobx;

                    pEntry = pSrvOpen->FobxList.Flink;

                    pFobx  = (PFOBX)CONTAINING_RECORD(
                                 pEntry,
                                 FOBX,
                                 FobxQLinks);

                    RxReferenceNetFobx(pFobx);

                    RxPurgeChangeBufferingStateRequestsForSrvOpen(pSrvOpen);

                    Status = RxCloseAssociatedSrvOpen(pFobx,NULL);

                    RxDereferenceNetFobx(pFobx,LHS_ExclusiveLockHeld);

                    pListEntry = pFcb->SrvOpenList.Flink;
                }
            }
            else
            {
                // we found atleast one SrvOpen which is a) Not Orphaned and
                // b) doesn't belong to this VNetRoot
                // hence we cannot orphan this FCB
                fAllSrvOpensOrphaned = FALSE;
            }
        }
    }

    // if all srvopens for this FCB are in orphaned state, orphan the FCB as well.
    if (fAllSrvOpensOrphaned)
    {
        // remove the FCB from the netname table
        // so that any new opens/creates for this file will create a new FCB.
        RxRemoveNameNetFcb(pFcb);
        SetFlag(pFcb->FcbState,FCB_STATE_ORPHANED);
        ClearFlag(pFcb->FcbState,FCB_STATE_WRITECACHEING_ENABLED);

        if (!RxDereferenceAndFinalizeNetFcb(pFcb,NULL,FALSE,FALSE)) {
            RxReleaseFcb(NULL,pFcb);
        }
    }
    else
    {
        // some srvopens are still active, just remove the refcount and release the FCB
        RxDereferenceNetFcb(pFcb);
        RxReleaseFcb(NULL,pFcb);
    }

}

VOID
RxForceFinalizeAllVNetRoots(
    PNET_ROOT   pNetRoot
    )
/*++

Routine Description:

    The routine foce finalizes all the vnetroots from the given netroot. You must be exclusive on
    the NetName tablelock.

Arguments:

    pNetRoot      - the NetRoot

Return Value:

    VOID

--*/
{
    PLIST_ENTRY pListEntry;


    pListEntry = pNetRoot->VirtualNetRoots.Flink;

    while (pListEntry != &pNetRoot->VirtualNetRoots)
    {
        PV_NET_ROOT pTempVNetRoot;

        pTempVNetRoot = (PV_NET_ROOT)
                        CONTAINING_RECORD(
                            pListEntry,
                            V_NET_ROOT,
                            NetRootListEntry);

        if (NodeType(pTempVNetRoot) == RDBSS_NTC_V_NETROOT)
        {
            RxFinalizeVNetRoot(pTempVNetRoot, TRUE, TRUE);
        }

        pListEntry = pListEntry->Flink;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\midatlsp.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the private data structures used in mapping MIDS
    to the corresponding requests/contexts associated with them. it's
    separated from the .c portion so the debugger extension can see it.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/


#ifndef _MIDATLAS_PRIVATE_H_
#define _MIDATLAS_PRIVATE_H_

typedef struct _MID_MAP_ {
   LIST_ENTRY  MidMapList;             // the list of MID maps in the MID atlas
   USHORT      MaximumNumberOfMids;    // the maximum number of MIDs in this map
   USHORT      NumberOfMidsInUse;      // the number of MIDs in use
   USHORT      BaseMid;                // the base MID associated with the map
   USHORT      IndexMask;              // the index mask for this map
   UCHAR       IndexAlignmentCount;    // the bits by which the index field is to be shifted
   UCHAR       IndexFieldWidth;        // the index field width
   UCHAR       Flags;                  // flags ...
   UCHAR       Level;                  // the level associated with this map ( useful for expansion )
   PVOID       *pFreeMidListHead;      // the list of free mid entries in this map
   PVOID       Entries[1];             // the MID map entries.
} MID_MAP, *PMID_MAP;

#endif //_MIDATLAX_PRIVATE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\midatlas.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "midatlsp.h"

VOID
RxInitializeMidMapFreeList (
    struct _MID_MAP_ *pMidMap
    );

VOID
RxUninitializeMidMap (
    struct _MID_MAP_    *pMidMap,
    PCONTEXT_DESTRUCTOR pContextDestructor
    );



#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeMidMapFreeList)
#pragma alloc_text(PAGE, RxCreateMidAtlas)
#pragma alloc_text(PAGE, RxUninitializeMidMap)
#pragma alloc_text(PAGE, RxDestroyMidAtlas)
#endif

#define ENTRY_TYPE_FREE_MID_LIST  (0x1)
#define ENTRY_TYPE_VALID_CONTEXT  (0x2)
#define ENTRY_TYPE_MID_MAP        (0x3)

#define ENTRY_TYPE_MASK           (0x3)

#define MID_MAP_FLAGS_CAN_BE_EXPANDED (0x1)
#define MID_MAP_FLAGS_FREE_POOL       (0x2)


//INLINE ULONG _GetEntryType(PVOID pEntry)

#define _GetEntryType(pEntry)                               \
        ((ULONG)((ULONG_PTR)(pEntry)) & ENTRY_TYPE_MASK)

//INLINE PVOID _GetEntryPointer(PVOID pEntry)

#define _GetEntryPointer(pEntry)                            \
        ((PVOID)((ULONG_PTR)(pEntry) & ~ENTRY_TYPE_MASK))

#define _MakeEntry(pContext,EntryType)                      \
        (PVOID)((ULONG_PTR)(pContext) | (EntryType))

//INLINE PMID_MAP _GetFirstMidMap()
/*++

Routine Description:

    This first MID_MAP instance in the list

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetFirstMidMap(pListHead)                        \
               (IsListEmpty(pListHead)                    \
                ? NULL                                    \
                : (PMID_MAP)                              \
                  (CONTAINING_RECORD((pListHead)->Flink,  \
                                     MID_MAP,             \
                                     MidMapList)))

//INLINE PSMBCEDB_SERVER_ENTRY GetNextMidMap(PLIST_ENTRY pListHead, PMID_MAP pMidMap)
/*++

Routine Description:

    This routine returns the next MID_MAP in the list

Arguments:

    pListHead    - the list of MID_MAP's

    pMidMap      - the current instance

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetNextMidMap(pListHead,pMidMap)                      \
           (((pMidMap)->MidMapList.Flink == pListHead)         \
            ? NULL                                             \
            : (PMID_MAP)                                       \
              (CONTAINING_RECORD((pMidMap)->MidMapList.Flink,  \
                                 MID_MAP,                      \
                                 MidMapList)))


//INLINE VOID _AddMidMap(
//            PLIST_ENTRY pListHead,
//            PMID_MAP    pMidMap)
/*++

Routine Description:

    This routine adds a MID_MAP instance to a list

Arguments:

    pListHead  - the list of MID_MAP's

    pMidMap    - the MID_MAP to be added

--*/

#define _AddMidMap(pListHead,pMidMap)                                       \
        {                                                                   \
           PMID_MAP pPredecessor;                                           \
           pPredecessor = _GetFirstMidMap(pListHead);                       \
           while (pPredecessor != NULL) {                                   \
              if (pPredecessor->Level < pMidMap->Level) {                   \
                 pPredecessor = _GetNextMidMap(pListHead,pPredecessor);     \
              } else {                                                      \
                 pPredecessor = (PMID_MAP)                                  \
                                CONTAINING_RECORD(                          \
                                     pPredecessor->MidMapList.Blink,        \
                                     MID_MAP,                               \
                                     MidMapList);                           \
                 break;                                                     \
              }                                                             \
           }                                                                \
                                                                            \
           if (pPredecessor == NULL) {                                      \
              InsertTailList(pListHead,&((pMidMap)->MidMapList));         \
           } else {                                                         \
              (pMidMap)->MidMapList.Flink = pPredecessor->MidMapList.Flink; \
              pPredecessor->MidMapList.Flink = &(pMidMap)->MidMapList;      \
                                                                            \
              (pMidMap)->MidMapList.Blink = &pPredecessor->MidMapList;      \
              (pMidMap)->MidMapList.Flink->Blink = &(pMidMap)->MidMapList;  \
           }                                                                \
        }


//INLINE VOID _RemoveMidMap(PMID_MAP pMidMap)
/*++

Routine Description:

    This routine removes a MID_MAP instance from the list

Arguments:

    pMidMap - the MID_MAP instance to be removed

--*/

#define _RemoveMidMap(pMidMap)   \
            RemoveEntryList(&(pMidMap)->MidMapList)



VOID
RxInitializeMidMapFreeList(PMID_MAP pMidMap)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Notes:

--*/
{
   USHORT i;

   PVOID  *pEntryValue     = (PVOID *)&pMidMap->Entries[1];
   PVOID  *pEntriesPointer = (PVOID *)&pMidMap->Entries;

   PAGED_CODE();

   //DbgPrint("RxInitializeMidMapFreeList .. Entry\n");

   if (pMidMap->MaximumNumberOfMids > 0) {
       pMidMap->pFreeMidListHead = pMidMap->Entries;
       for (i = 1; i <= pMidMap->MaximumNumberOfMids - 1;i++,pEntryValue++) {
          *pEntriesPointer++ = _MakeEntry(pEntryValue,ENTRY_TYPE_FREE_MID_LIST);
       }

       *pEntriesPointer = _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST);
   }

   //DbgPrint("RxInitializeMidMapFreeList .. Exit\n");
}


PRX_MID_ATLAS
RxCreateMidAtlas(
   USHORT MaximumNumberOfMids,
   USHORT MidsAllocatedAtStart)
/*++

Routine Description:

   This routine allocates a new instance of MID_ATLAS data structure.

Arguments:

    MaximumNumberOfMids  - the maximum number of MIDS in the atlas.

    MidsAllocatedAtStart - the number of MIDS allocated at start

Notes:

--*/
{
    PRX_MID_ATLAS pMidAtlas;
    PMID_MAP   pMidMap;
    ULONG      AtlasSize;
    USHORT     MidsAllocatedRoundedToPowerOf2;
    USHORT     MaximumMidsRoundedToPowerOf2;
    UCHAR      MidFieldWidth,MaximumMidFieldWidth;

    PAGED_CODE();

    // Round off the Mids allocated at Start to a power of two
    MaximumMidsRoundedToPowerOf2 = 0x100;
    MaximumMidFieldWidth = 8;

    if (MaximumMidsRoundedToPowerOf2 != MaximumNumberOfMids) {
        if (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
            while (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
                MaximumMidFieldWidth++;
            }
        } else {
            while (MaximumNumberOfMids < MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> 1;
                MaximumMidFieldWidth--;
            }

            MaximumMidFieldWidth++;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
        }
    }

    MidsAllocatedRoundedToPowerOf2 = 0x100;
    MidFieldWidth = 8;

    if (MidsAllocatedRoundedToPowerOf2 != MidsAllocatedAtStart) {
        if (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
            while (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
                MidFieldWidth++;
            }
        } else {
            while (MidsAllocatedAtStart < MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 >> 1;
                MidFieldWidth--;
            }

            MidFieldWidth++;
            MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
        }
    }

    AtlasSize = sizeof(RX_MID_ATLAS) +
                FIELD_OFFSET(MID_MAP,Entries);

    if (MaximumNumberOfMids == MidsAllocatedAtStart) {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedAtStart);
    } else {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedRoundedToPowerOf2);
    }

    pMidAtlas = (PRX_MID_ATLAS)RxAllocatePoolWithTag(
                              NonPagedPool,
                              AtlasSize,
                              RXCE_MIDATLAS_POOLTAG);
    if (pMidAtlas != NULL) {
        pMidMap = (PMID_MAP)(pMidAtlas + 1);

        pMidMap->Flags                 = 0;
        pMidAtlas->MaximumNumberOfMids = MaximumNumberOfMids;
        pMidAtlas->MidsAllocated       = MidsAllocatedAtStart;
        pMidAtlas->NumberOfMidsInUse = 0;
        pMidAtlas->NumberOfMidsDiscarded = 0;
        pMidAtlas->MaximumMidFieldWidth = MaximumMidFieldWidth;

        pMidMap->MaximumNumberOfMids = MidsAllocatedAtStart;
        pMidMap->NumberOfMidsInUse   = 0;
        pMidMap->BaseMid             = 0;
        pMidMap->IndexMask           = MidsAllocatedRoundedToPowerOf2 - 1;
        pMidMap->IndexAlignmentCount = 0;
        pMidMap->IndexFieldWidth     = MidFieldWidth;
        pMidMap->Level               = 1;

        InitializeListHead(&pMidAtlas->MidMapFreeList);
        InitializeListHead(&pMidAtlas->MidMapExpansionList);
        RxInitializeMidMapFreeList(pMidMap);

        _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
        pMidAtlas->pRootMidMap = pMidMap;

        if (MaximumNumberOfMids > MidsAllocatedAtStart) {
            // Round off the maximum number of MIDS to determine the level and the
            // size of the quantum ( allocation increments)

            pMidMap->Flags |= MID_MAP_FLAGS_CAN_BE_EXPANDED;

            pMidAtlas->MidQuantum           = 32;
            pMidAtlas->MidQuantumFieldWidth = 5;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> (pMidMap->IndexAlignmentCount + 5);

            if (MaximumMidsRoundedToPowerOf2 > 0) {
                pMidAtlas->NumberOfLevels = 3;
            } else {
                pMidAtlas->NumberOfLevels = 2;
            }
        } else {
            pMidAtlas->MidQuantum     = 0;
            pMidAtlas->NumberOfLevels = 1;
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
        }
    }

    //DbgPrint("RxAllocatMidAtlas .. Exit (pMidAtlas) %lx\n",pMidAtlas);
    return pMidAtlas;
}

VOID
RxUninitializeMidMap(
         PMID_MAP            pMidMap,
         PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine uninitializes a MID_MAP data structure.

Arguments:

    pMidMap            -- the MID_MAP instance to be uninitialized.

    pContextDestructor -- the context destructor
Notes:

--*/
{
   USHORT i;
   ULONG  EntryType;

   PAGED_CODE();

   //DbgPrint("RxUninitializeMidMap .. Entry No.Of MIDS in Use %ld\n",pMidMap->NumberOfMidsInUse);
   RxLog(("_UninitMidMap .. num= %ld\n",pMidMap->NumberOfMidsInUse));
   RxWmiLog(LOG,
            RxUninitializeMidMap,
            LOGXSHORT(pMidMap->NumberOfMidsInUse));

   for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
      PMID_MAP pChildMidMap;

      EntryType = _GetEntryType(pMidMap->Entries[i]);
      switch (EntryType) {
      case ENTRY_TYPE_MID_MAP :
         {
            pChildMidMap = (PMID_MAP)_GetEntryPointer(pMidMap->Entries[i]);
            RxUninitializeMidMap(pChildMidMap,pContextDestructor);
         }
         break;
      case ENTRY_TYPE_VALID_CONTEXT :
         {
            if (pContextDestructor != NULL) {
               PVOID pContext;

               pContext = _GetEntryPointer(pMidMap->Entries[i]);

               (pContextDestructor)(pContext);
            }
         }
         break;
      default:
         break;
      }
   }

   if (pMidMap->Flags & MID_MAP_FLAGS_FREE_POOL) {
      RxFreePool(pMidMap);
   }

   //DbgPrint("RxUninitializeMidMap .. Exit\n");
}

VOID
RxDestroyMidAtlas(
   PRX_MID_ATLAS          pMidAtlas,
   PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine frees a MID_ATLAS instance. As a side effect it invokes the
   passed in context destructor on every valid context in the MID_ATLAS

Arguments:

    pMidAtlas           - the MID_ATLAS instance to be freed.

    PCONTEXT_DESTRUCTOR - the associated context destructor

Notes:

--*/
{
   PAGED_CODE();

   //DbgPrint("RxFreeMidAtlas .. Entry\n");
   RxUninitializeMidMap(pMidAtlas->pRootMidMap,pContextDestructor);

   RxFreePool(pMidAtlas);
   //DbgPrint("RxFreeMidAtlas .. Exit\n");
}

PVOID
RxMapMidToContext(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;
   ULONG     Index;

   //DbgPrint("RxMapMidToContext Mid %lx ",Mid);

   for (;;) {
      Index = (Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount;

      if( Index >= pMidMap->MaximumNumberOfMids ) {
          pContext = NULL;
          break;
      }

      pContext = pMidMap->Entries[Index];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      } else {
         pContext = NULL;
         break;
      }
   }

   //DbgPrint("Context %lx \n",pContext);

   return pContext;
}

NTSTATUS
RxMapAndDissociateMidFromContext(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      *pContextPointer)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;
   PVOID     *pEntry;

   //DbgPrint("RxMapAndDissociateMidFromContext Mid %lx ",Mid);

   for (;;) {
      pEntry    = &pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      pContext  = *pEntry;
      EntryType = _GetEntryType(pContext);
      pContext  = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->NumberOfMidsInUse--;

         if (pMidMap->pFreeMidListHead == NULL) {
            _RemoveMidMap(pMidMap);
            _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
         }

         *pEntry = _MakeEntry(pMidMap->pFreeMidListHead,ENTRY_TYPE_FREE_MID_LIST);
         pMidMap->pFreeMidListHead = pEntry;


         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   pMidAtlas->NumberOfMidsInUse--;
   //DbgPrint("Context %lx\n",pContext);
   *pContextPointer = pContext;
   return STATUS_SUCCESS;
}

NTSTATUS
RxReassociateMid(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      pNewContext)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

    pNewContext - the new context

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   //DbgPrint("RxReassociateMid Mid %lx ",Mid);

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount]
               = _MakeEntry(pNewContext,ENTRY_TYPE_VALID_CONTEXT);
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         ASSERT(!"Valid MID Atlas");
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   //DbgPrint("New COntext  %lx\n",pNewContext);

   return STATUS_SUCCESS;
}

NTSTATUS
RxAssociateContextWithMid(
      PRX_MID_ATLAS     pMidAtlas,
      PVOID          pContext,
      PUSHORT        pNewMid)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

         STATUS_INSUFFICIENT_RESOURCES
         STATUS_UNSUCCESSFUL  -- no mid could be associated

Notes:

--*/
{
   NTSTATUS Status;
   PMID_MAP pMidMap;
   PVOID    *pContextPointer;

   //DbgPrint("RxAssociateContextWithMid Context %lx ",pContext);

   // Scan the list of MID_MAP's which have free entries in them.
   if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapFreeList)) != NULL) {
      ASSERT(pMidMap->pFreeMidListHead != _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST));

      pMidMap->NumberOfMidsInUse++;
      pContextPointer           = pMidMap->pFreeMidListHead;
      pMidMap->pFreeMidListHead = _GetEntryPointer(*(pMidMap->pFreeMidListHead));
      *pContextPointer          = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
      *pNewMid                  = ((USHORT)
                                   (pContextPointer - (PVOID *)&pMidMap->Entries)
                                    << pMidMap->IndexAlignmentCount) |
                                    pMidMap->BaseMid;

      // Check if the MID_MAP needs to be removed from the list of MID_MAP's with
      // free entries
      if (pMidMap->pFreeMidListHead ==  NULL) {
         _RemoveMidMap(pMidMap);

         // Check if it can be added to the expansion list.
         if (pMidAtlas->NumberOfLevels > pMidMap->Level) {
            _AddMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      Status = STATUS_SUCCESS;
   } else if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList)) != NULL) {
      PMID_MAP pNewMidMap;

      USHORT   i;
      ULONG    NewMidMapSize;

      // Locate the index in the mid map for the new mid map
      pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList);
      while (pMidMap != NULL) {
         for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
            if (_GetEntryType(pMidMap->Entries[i]) != ENTRY_TYPE_MID_MAP) {
               break;
            }
         }

         if (i < pMidMap->MaximumNumberOfMids) {
            break;
         } else {
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
            _RemoveMidMap(pMidMap);
            pMidMap = _GetNextMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      if (pMidMap != NULL) {
         USHORT NumberOfEntriesInMap = pMidAtlas->MaximumNumberOfMids -
                                       pMidAtlas->NumberOfMidsInUse;

         if (NumberOfEntriesInMap > pMidAtlas->MidQuantum) {
            NumberOfEntriesInMap = pMidAtlas->MidQuantum;
         }
         else if( NumberOfEntriesInMap == 1 )
         {
             // The MID_MAP design does not allow for maps of length 1.  Extend to 2
             NumberOfEntriesInMap++;
         }

         if (NumberOfEntriesInMap > 0) {
             NewMidMapSize = FIELD_OFFSET(MID_MAP,Entries) +
                             NumberOfEntriesInMap * sizeof(PVOID);
             pNewMidMap = (PMID_MAP)RxAllocatePoolWithTag(
                                        NonPagedPool,
                                        NewMidMapSize,
                                        RXCE_MIDATLAS_POOLTAG);

             if (pNewMidMap != NULL) {
                 pNewMidMap->Flags = MID_MAP_FLAGS_FREE_POOL;
                 pNewMidMap->MaximumNumberOfMids = NumberOfEntriesInMap;
                 pNewMidMap->NumberOfMidsInUse   = 0;
                 pNewMidMap->BaseMid             = (pMidMap->BaseMid |
                                                    i << pMidMap->IndexAlignmentCount);
                 pNewMidMap->IndexAlignmentCount = pMidMap->IndexAlignmentCount +
                                                   pMidMap->IndexFieldWidth;

                 pNewMidMap->IndexMask           = (pMidAtlas->MidQuantum - 1) << pNewMidMap->IndexAlignmentCount;
                 pNewMidMap->IndexFieldWidth     = pMidAtlas->MidQuantumFieldWidth;

                 RxInitializeMidMapFreeList(pNewMidMap);

                 //
                 // After the RxInitializeMidMapFreeList call above the
                 // pFreeMidListHead points to Entries[0]. We will be storing
                 // the value pMidMap->Entries[i] at this location so we need
                 // to make pFreeMidListHead point to Entries[1].
                 //
                 pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));

                 //
                 // Set up the mid map appropriately.
                 //
                 pNewMidMap->NumberOfMidsInUse = 1;
                 pNewMidMap->Entries[0] = pMidMap->Entries[i];
                 pNewMidMap->Level = pMidMap->Level + 1;

                 //
                 // The new MinMap is stored at the pMidMap->Entries[i] location.
                 //
                 pMidMap->Entries[i] = _MakeEntry(pNewMidMap,ENTRY_TYPE_MID_MAP);

                 //
                 // Update the free list and the expansion list respectively.
                 //
                 _AddMidMap(&pMidAtlas->MidMapFreeList,pNewMidMap);

                 pNewMidMap->NumberOfMidsInUse++;
                 pContextPointer = pNewMidMap->pFreeMidListHead;
                 pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));
                 *pContextPointer = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
                 *pNewMid = ((USHORT)
                             (pContextPointer - (PVOID *)&pNewMidMap->Entries)
                             << pNewMidMap->IndexAlignmentCount) |
                             pNewMidMap->BaseMid;

                 Status = STATUS_SUCCESS;
             } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
             }
         } else {
             Status = STATUS_UNSUCCESSFUL;
         }
      } else {
         Status = STATUS_UNSUCCESSFUL;
      }
   } else {
      Status = STATUS_UNSUCCESSFUL;
   }

   if (Status == (STATUS_SUCCESS)) {
      pMidAtlas->NumberOfMidsInUse++;
   }

   //DbgPrint("Mid %lx\n",*pNewMid);

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\namcache.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    namcache.c

Abstract:

The following functions are provided to support name cache management in
mini-rdrs.  See namcache.h for a more complete description of how a mini-rdr
could use name caches to help eliminate trips to the server.


Author:

    David Orbits          [davidor]   9-Sep-1996

Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


#include "prefix.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxNameCacheInitialize)
#pragma alloc_text(PAGE, RxNameCacheCreateEntry)
#pragma alloc_text(PAGE, RxNameCacheFetchEntry)
#pragma alloc_text(PAGE, RxNameCacheCheckEntry)
#pragma alloc_text(PAGE, RxNameCacheActivateEntry)
#pragma alloc_text(PAGE, RxNameCacheExpireEntry)
#pragma alloc_text(PAGE, RxNameCacheFreeEntry)
#pragma alloc_text(PAGE, RxNameCacheFinalize)
#pragma alloc_text(PAGE, RxNameCacheExpireEntryWithShortName)
#endif

#define Dbg (DEBUG_TRACE_NAMECACHE)


VOID
RxNameCacheInitialize(
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN ULONG MRxNameCacheSize,
    IN ULONG MaximumEntries
    )

/*++

Routine Description:

    This routine initializes a NAME_CACHE structure.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL from which to
                          allocate the entry.

    MRxNameCacheSize    - The size in bytes of the mini-rdr portion of the name
                          cache entry.

    MaximumEntries      - The maximum number of entries that will ever be
                          allocated.  E.g. This prevents an errant program which
                          opens tons of files with bad names from chewing up
                          paged pool.

Return Value:

    None.

--*/
{

    PAGED_CODE();

    ExInitializeFastMutex(&NameCacheCtl->NameCacheLock);

    InitializeListHead(&NameCacheCtl->ActiveList);
    InitializeListHead(&NameCacheCtl->FreeList);

    NameCacheCtl->NumberActivates = 0;
    NameCacheCtl->NumberChecks = 0;
    NameCacheCtl->NumberNameHits = 0;
    NameCacheCtl->NumberNetOpsSaved = 0;
    NameCacheCtl->EntryCount = 0;
    NameCacheCtl->MaximumEntries = MaximumEntries;
    NameCacheCtl->MRxNameCacheSize = MRxNameCacheSize;

    return;
}


PNAME_CACHE
RxNameCacheCreateEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name,
    IN BOOLEAN CaseInsensitive
    )
/*++

Routine Description:

    This routine allocates and initializes a NAME_CACHE structure with the
    given name string, Lifetime (in seconds) and MRxContext.
    It returns a pointer to the name cache structure or NULL if no entry was
    available.  It is expected that the caller will then initialize any
    additional mini-rdr portion of the name cache context and then put the
    entry on the name cache active list by calling RxNameCacheActivateEntry().

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL from which to
                          allocate the entry.

    Name                - A pointer to the unicode name string to initialize the
                          the entry with.

    CaseInsensitive     - True if need case insensitive compare on name.

Return Value:

    PNAME_CACHE - returns a pointer to the newly allocated NAME_CACHE struct
                  or NULL if allocation fails.


--*/
{
    LONG i;
    PNAME_CACHE *NameCacheArray;
    PNAME_CACHE NameCache;
    ULONG NameCacheSize;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxNameCacheCreateEntry: %wZ\n", Name ));
    //
    // Grab an entry off the free list.
    //

    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);

    if (!IsListEmpty(&NameCacheCtl->FreeList)) {
        NameCache = (PNAME_CACHE) RemoveHeadList(&NameCacheCtl->FreeList);
    } else {
        NameCache = NULL;
    }

    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

    if (NameCache != NULL) {
        NameCache = CONTAINING_RECORD(NameCache, NAME_CACHE, Link);
        RxDbgTrace(0, Dbg, ("took from free list\n"));

    } else {
        //
        // Didn't get an entry off the free list, allocate one.
        // Don't exceed Max but we could go over a little if multiple threads
        // are allocating.
        //
        if (NameCacheCtl->EntryCount < NameCacheCtl->MaximumEntries) {

            NameCacheSize = QuadAlign(sizeof(NAME_CACHE)) +
                            QuadAlign(NameCacheCtl->MRxNameCacheSize);
            NameCache = RxAllocatePoolWithTag(
                            PagedPool,
                            NameCacheSize,
                            RX_NAME_CACHE_POOLTAG);

            if (NameCache != NULL) {
                //
                // Init standard header fields, bump entry count & setup
                // mini-rdr context extension.
                //
                ZeroAndInitializeNodeType(
                    NameCache,
                    RDBSS_NTC_STORAGE_TYPE_UNKNOWN,
                    (NODE_BYTE_SIZE) NameCacheSize);

                InterlockedIncrement(&NameCacheCtl->EntryCount);

                NameCache->Name.Buffer = NULL;
                NameCache->Name.Length = 0;
                NameCache->Name.MaximumLength = 0;

                if (NameCacheCtl->MRxNameCacheSize > 0) {
                    NameCache->ContextExtension = (PBYTE)NameCache +
                                         QuadAlign(sizeof(NAME_CACHE));
                RxDbgTrace(0, Dbg, ("allocated new entry\n"));
                }
            }
        }

        //
        // If still no entry then bag it.
        //
        if (NameCache == NULL) {
            RxDbgTrace(-1, Dbg, ("Fail no entry allocated!\n"));
            return NULL;
        }

    }

    //
    // If name won't fit in current string, free it and allocate new string.
    //
    if (Name->Length > NameCache->Name.MaximumLength) {
        if (NameCache->Name.Buffer != NULL) {
            RxFreePool(NameCache->Name.Buffer);
        }

        if (Name->Length > 0) {
            NameCache->Name.Buffer = RxAllocatePoolWithTag(
                                         PagedPool,
                                         (ULONG) Name->Length,
                                         RX_NAME_CACHE_POOLTAG);

        } else {
            NameCache->Name.Buffer = NULL;
        }

        if (Name->Length > 0 &&
            NameCache->Name.Buffer == NULL) {
            //
            // if didn't get the storage.  Zero the string length and put entry
            // back on the free list.  Otherwise save allocation in max length.
            //
            NameCache->Name.Length = 0;
            NameCache->Name.MaximumLength = 0;

            ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);
            InsertHeadList(&NameCacheCtl->FreeList, &NameCache->Link);
            ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

            RxDbgTrace(-1, Dbg, ("Fail no pool for name!\n"));
            return NULL;
        } else {
            NameCache->Name.MaximumLength = Name->Length;
        }
    }

    //
    // Save the name & length.  Set the case matching flag.  Set the hash field.
    //
    NameCache->Name.Length = Name->Length;
    NameCache->CaseInsensitive = CaseInsensitive;

    if (Name->Length > 0) {
        RtlMoveMemory(NameCache->Name.Buffer, Name->Buffer, Name->Length);
        NameCache->HashValue = RxTableComputeHashValue(&NameCache->Name);
    }else {
        NameCache->HashValue = 0;
    }

    RxDbgTrace(-1, Dbg, ("Success!\n"));
    return NameCache;

}


PNAME_CACHE
RxNameCacheFetchEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine looks for a match in the name cache for Name.
    If found the entry is removed from the Name Cache active list and
    a pointer to the NAME_CACHE struct is returned.  Otherwise NULL is returned.
    The entry is removed to avoid problems with another thread trying to
    update the same entry or observing that it expired and putting it on the
    free list.  We could get multiple entries with the same name by different
    threads but eventually they will expire.

    If a matching entry is found no check is made for expiration.  That is left
    to the caller since it is likely the caller would want to take a special
    action.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL to scan.

    Name                - A pointer to the unicode name string to scan for.

Return Value:

    PNAME_CACHE - returns a pointer to the NAME_CACHE struct if found or NULL.

Side Effects:

    As the active list is scanned any non-matching entries that have expired are
    put on the free list.

--*/
{
    PNAME_CACHE NameCache = NULL;
    PLIST_ENTRY pListEntry;
    PLIST_ENTRY ExpiredEntry;
    ULONG HashValue;
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheFetchEntry: Lookup %wZ\n", Name ));

    if (Name->Length > 0) {
        HashValue = RxTableComputeHashValue(Name);
    } else {
        HashValue = 0;
    }

    KeQueryTickCount( &CurrentTime );

    NameCacheCtl->NumberChecks += 1;
    //
    // Get the lock and scan the active list.
    //

    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);

    pListEntry = NameCacheCtl->ActiveList.Flink;

    while (pListEntry != &NameCacheCtl->ActiveList) {

        NameCache = (PNAME_CACHE) CONTAINING_RECORD(pListEntry, NAME_CACHE, Link);
        //
        // Do initial match on the hash value and the length.  Then do full string.
        //
        if ((NameCache->HashValue == HashValue) &&
            (Name->Length == NameCache->Name.Length)) {

            if (Name->Length == 0 ||
                RtlEqualUnicodeString(
                    Name,
                    &NameCache->Name,
                    NameCache->CaseInsensitive) ) {
                //
                // Found a match.
                //
                NameCacheCtl->NumberNameHits += 1;
                break;
            }
        }
        //
        // No match. If the entry is expired, put it on the free list.
        //
        ExpiredEntry = pListEntry;
        pListEntry = pListEntry->Flink;

        if (CurrentTime.QuadPart >= NameCache->ExpireTime.QuadPart) {
            RemoveEntryList(ExpiredEntry);
            InsertHeadList(&NameCacheCtl->FreeList, ExpiredEntry);
            RxDbgTrace( 0, Dbg, ("RxNameCacheFetchEntry: Entry expired %wZ\n", &NameCache->Name ));
        }

        NameCache = NULL;
    }
    //
    // If we found something pull it off the active list and give it to caller.
    //
    if (NameCache != NULL) {
        RemoveEntryList(pListEntry);
    }

    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);


    if (NameCache != NULL) {
        RxDbgTrace( 0, Dbg, ("RxNameCacheFetchEntry: Entry found %wZ\n", &NameCache->Name ));
    }

    return NameCache;

}


RX_NC_CHECK_STATUS
RxNameCacheCheckEntry (
    IN PNAME_CACHE NameCache,
    IN ULONG MRxContext
    )
/*++

Routine Description:

    This routine checks a name cache entry for validity.  A valid entry
    means that the lifetime has not expired and the MRxContext passes
    the equality check.

Arguments:

    NameCache           - pointer to NAME_CACHE struct to check.

    MRxContext          - A ULONG worth of mini-rdr supplied context for
                          equality checking when making a valid entry check.

Return Value:

    RX_NC_CHECK_STATUS:  RX_NC_SUCCESS - The entry is valid
                         RX_NC_TIME_EXPIRED - The Lifetime on the entry expired
                         RX_NC_MRXCTX_FAIL - The MRxContext equality test failed


--*/
{

    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    //
    // Check for Mini-rdr context equality.
    //
    if (NameCache->Context != MRxContext) {
        RxDbgTrace( 0, Dbg, ("RxNameCacheCheckEntry: MRxContext_Fail %08lx,%08lx %wZ\n",
           NameCache->Context,
           MRxContext,
           &NameCache->Name ));

        return RX_NC_MRXCTX_FAIL;
    }

    //
    // Check for lifetime expired.
    //
    KeQueryTickCount( &CurrentTime );
    if (CurrentTime.QuadPart >= NameCache->ExpireTime.QuadPart) {
        RxDbgTrace( 0, Dbg, ("RxNameCacheCheckEntry: Expired %wZ\n", &NameCache->Name ));
        return RX_NC_TIME_EXPIRED;
    }

    RxDbgTrace( 0, Dbg, ("RxNameCacheCheckEntry: Success %wZ\n", &NameCache->Name ));
    return RX_NC_SUCCESS;

}

VOID
RxNameCacheExpireEntry(
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache
    )
/*++

Routine Description:

    This routine puts the entry on the free list.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL on which to
                          activate the entry.

    NameCache           - pointer to NAME_CACHE struct to activate.


Return Value:

    None.

Assumes:

    The name cache entry is not on either the free or active list.

--*/
{
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheExpireEntry: %wZ\n", &NameCache->Name ));

    //
    // Put the entry on free list for recycle.
    //
    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);
    InsertHeadList(&NameCacheCtl->FreeList, &NameCache->Link);
    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

    //
    // Update stats.
    //
    NameCacheCtl->NumberActivates -= 1;

    return;
}


VOID
RxNameCacheExpireEntryWithShortName (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine expires all the name cache whose name prefix matches the given short file name.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL to scan.

    Name                - A pointer to the unicode name string to scan for.

Return Value:

    PNAME_CACHE - returns a pointer to the NAME_CACHE struct if found or NULL.

Side Effects:

    As the active list is scanned any non-matching entries that have expired are
    put on the free list.

--*/
{
    PNAME_CACHE NameCache = NULL;
    PLIST_ENTRY pListEntry;
    PLIST_ENTRY ExpiredEntry;
    ULONG HashValue;
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheFetchEntry: Lookup %wZ\n", Name ));

    KeQueryTickCount( &CurrentTime );

    NameCacheCtl->NumberChecks += 1;
    //
    // Get the lock and scan the active list.
    //

    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);

    pListEntry = NameCacheCtl->ActiveList.Flink;

    while (pListEntry != &NameCacheCtl->ActiveList) {
        USHORT SavedNameLength;

        NameCache = (PNAME_CACHE) CONTAINING_RECORD(pListEntry, NAME_CACHE, Link);

        ExpiredEntry = pListEntry;
        pListEntry = pListEntry->Flink;

        //
        // Do initial match on the hash value and the length.  Then do full string.
        //
        if (Name->Length <= NameCache->Name.Length) {
            SavedNameLength = NameCache->Name.Length;
            NameCache->Name.Length = Name->Length;

            if (Name->Length == 0 ||
                RtlEqualUnicodeString(
                    Name,
                    &NameCache->Name,
                    NameCache->CaseInsensitive) ) {
                //
                // Found a match.
                //
                RemoveEntryList(ExpiredEntry);
                InsertHeadList(&NameCacheCtl->FreeList, ExpiredEntry);
                RxDbgTrace( 0, Dbg, ("RxNameCacheExpireEntryWithShortName: Entry expired %wZ\n", &NameCache->Name ));

                continue;
            }

            NameCache->Name.Length = SavedNameLength;
        }
    }

    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);
}

VOID
RxNameCacheActivateEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache,
    IN ULONG LifeTime,
    IN ULONG MRxContext
    )
/*++

Routine Description:

    This routine takes a name cache entry and updates the expiration time and
    the mini rdr context.  It then puts the entry on the active list.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL on which to
                          activate the entry.

    NameCache           - pointer to NAME_CACHE struct to activate.

    LifeTime            - The valid lifetime of the cache entry (in seconds).
                          A lifetime of zero means leave current value unchanged.
                          This is for reactivations after a match where you
                          want the original lifetime preserved.

    MRxContext          - A ULONG worth of mini-rdr supplied context for
                          equality checking when making a valid entry check.
                          An MRxContext of zero means leave current value unchanged.
                          This is for reactivations after a match where you
                          want the original MRxContext preserved.

Return Value:

    None.

Assumes:

    The name cache entry is not on either the free or active list.

--*/
{
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheActivateEntry: %wZ\n", &NameCache->Name ));
    //
    // Set new expiration time on the entry and save the mini-rdr context.
    // A lifetime of zero or a MRxContext of zero implies leave value unchanged.
    //
    if (LifeTime != 0) {
        KeQueryTickCount( &CurrentTime );
        NameCache->ExpireTime.QuadPart = CurrentTime.QuadPart +
            (LONGLONG) ((LifeTime * 10*1000*1000) / KeQueryTimeIncrement());
    }

    if (MRxContext != 0) {
        NameCache->Context = MRxContext;
    }

    //
    // Put the entry on active list.
    //
    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);
    InsertHeadList(&NameCacheCtl->ActiveList, &NameCache->Link);
    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

    //
    // Update stats.
    //
    NameCacheCtl->NumberActivates += 1;

    return;
}

VOID
RxNameCacheFreeEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache
    )
/*++

Routine Description:

    This routine releases the storage for a name cache entry and decrements the
    count of name cache entries for this name cache.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL for the name cache.

    NameCache           - pointer to the NAME_CACHE struct to free.

Return Value:

    None.

Assumes:

    The name cache entry is not on either the free or active list.

--*/
{
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheFreeEntry: %wZ\n", &NameCache->Name ));
    //
    // Release storage for name
    //
    if (NameCache->Name.Buffer != NULL) {
        RxFreePool(NameCache->Name.Buffer);
    }
    //
    // Release storage for NAME_CACHE entry (includes context ext., if any)
    //
    RxFreePool(NameCache);

    InterlockedDecrement(&NameCacheCtl->EntryCount);


    return;
}

VOID
RxNameCacheFinalize (
    IN PNAME_CACHE_CONTROL NameCacheCtl
    )
/*++

Routine Description:

    This routine releases the storage for all the name cache entries.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL for the name cache.

Return Value:

    None.


--*/
{
    PNAME_CACHE NameCache;
    PLIST_ENTRY pListEntry;

    PAGED_CODE();

    //
    // Get the lock and remove entries from the active list.
    //

    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);


    while (!IsListEmpty(&NameCacheCtl->ActiveList)) {

        pListEntry = RemoveHeadList(&NameCacheCtl->ActiveList);
        NameCache = (PNAME_CACHE) CONTAINING_RECORD(pListEntry, NAME_CACHE, Link);

        RxNameCacheFreeEntry(NameCacheCtl, NameCache);
    }
    //
    // scan free list and remove entries.
    //
    while (!IsListEmpty(&NameCacheCtl->FreeList)) {

        pListEntry = RemoveHeadList(&NameCacheCtl->FreeList);
        NameCache = (PNAME_CACHE) CONTAINING_RECORD(pListEntry, NAME_CACHE, Link);

        RxNameCacheFreeEntry(NameCacheCtl, NameCache);
    }

    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

    //
    // At this point the entry count should be zero.  If not then there is
    // a memory leak since someone didn't call free.
    //
    ASSERT(NameCacheCtl->EntryCount == 0);

    return;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\prefix.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefix.c

Abstract:

    This module implements table functions for the net name prefix table and the per-netroot fcb table.


Author:

    Joe Linn (JoeLinn)    8-8-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxTableComputeHashValue)
#pragma alloc_text(PAGE, RxpAcquirePrefixTableLockShared)
#pragma alloc_text(PAGE, RxpAcquirePrefixTableLockExclusive)
#pragma alloc_text(PAGE, RxExclusivePrefixTableLockToShared)
#pragma alloc_text(PAGE, RxpReleasePrefixTableLock)
#pragma alloc_text(PAGE, RxIsPrefixTableEmpty)
#pragma alloc_text(PAGE, RxPrefixTableLookupName)
#pragma alloc_text(PAGE, RxTableLookupName_ExactLengthMatch)
#pragma alloc_text(PAGE, RxTableLookupName)
#pragma alloc_text(PAGE, RxPrefixTableInsertName)
#pragma alloc_text(PAGE, RxRemovePrefixTableEntry)
#pragma alloc_text(PAGE, RxInitializePrefixTable)
#pragma alloc_text(PAGE, RxFinalizePrefixTable)
#endif

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_PREFIX)

PUNICODE_PREFIX_TABLE_ENTRY
RxTrivialPrefixFind (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    IN  ULONG            Flags
    );

VOID
RxCheckTableConsistency_actual (
    IN PRX_PREFIX_TABLE Table,
    IN ULONG Tag
    );

PVOID
RxTableLookupName (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID RxConnectionId
    );

PRX_PREFIX_ENTRY
RxTableInsertEntry (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    );

VOID
RxTableRemoveEntry (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, RxPrefixTableLookupName )
#pragma alloc_text( PAGE, RxPrefixTableInsertName )
#pragma alloc_text( PAGE, RxRemovePrefixTableEntry )
#pragma alloc_text( PAGE, RxInitializePrefixTable )
#pragma alloc_text( PAGE, RxFinalizePrefixTable )
#endif

ULONG
RxTableComputeHashValue (
    IN  PUNICODE_STRING  Name
    )
/*++

Routine Description:

   here, we compute a caseinsensitive hashvalue.  we want to avoid a call/char to
   the unicodeupcase routine but we want to still have some reasonable spread on
   the hashvalues.  many rules just dont work for known important cases.  for
   example, the (use the first k and the last n) rule that old c compilers used
   doesn't pickup the difference among \nt\private\......\slm.ini and that would be
   nice.  note that the underlying comparison used already takes cognizance of the
   length before comparing.

   the rule we have selected is to use the 2nd, the last 4, and three selected
   at 1/4 points

Arguments:

    Name      - the name to be hashed

Return Value:

    ULONG which is a hashvalue for the name given.

--*/
{
    ULONG HashValue;
    LONG i,j;
    LONG length = Name->Length/sizeof(WCHAR);
    PWCHAR Buffer = Name->Buffer;
    LONG Probe[8];

    PAGED_CODE();

    HashValue = 0;

    Probe[0] = 1;
    Probe[1] = length - 1;
    Probe[2] = length - 2;
    Probe[3] = length - 3;
    Probe[4] = length - 4;
    Probe[5] = length >> 2;
    Probe[6] = (2 * length) >> 2;
    Probe[7] = (3 * length) >> 2;

    for (i = 0; i < 8; i++) {
        j = Probe[i];
        if ((j < 0) || (j >= length)) {
            continue;
        }
        HashValue = (HashValue << 3) + RtlUpcaseUnicodeChar(Buffer[j]);
    }

    RxDbgTrace(0, Dbg, ("RxTableComputeHashValue Hashv=%ld Name=%wZ\n",
                       HashValue, Name));
    return(HashValue);
}


#define HASH_BUCKET(TABLE,HASHVALUE) &((TABLE)->HashBuckets[(HASHVALUE) % (TABLE)->TableSize])

//#if DBG
//#define RxCheckTableConsistency(_xx,_yy) RxCheckTableConsistency_actual(_xx,_yy)
//#else
//#define RxCheckTableConsistency(_xx,_yy)
//#endif
#define RxCheckTableConsistency(_xx,_yy)

#if 0
ULONG RxLoudPrefixTableOperations = 0; //1;
#define RxLoudPrefixTableOperation(x) {              \
    if (RxLoudPrefixTableOperations) {               \
        DbgPrint("rdr2:%s on %08lx from %d:%s\n",    \
              x,pTable,LineNumber,FileName);         \
    }}
#else
#define RxLoudPrefixTableOperation(x) {NOTHING;}
#endif

BOOLEAN
RxpAcquirePrefixTableLockShared (
    PRX_PREFIX_TABLE pTable,
    BOOLEAN          Wait,
    BOOLEAN          ProcessBufferingStateChangeRequests
    RX_PREFIXTABLELOCK_PARAMS
    )
{
    BOOLEAN fResult;

    PAGED_CODE();

    RxLoudPrefixTableOperation("RxpAcquirePrefixTableLockShared");
    fResult = ExAcquireResourceSharedLite(&pTable->TableLock,Wait);

    return fResult;
}

BOOLEAN
RxpAcquirePrefixTableLockExclusive (
    PRX_PREFIX_TABLE pTable,
    BOOLEAN          Wait,
    BOOLEAN          ProcessBufferingStateChangeRequests
    RX_PREFIXTABLELOCK_PARAMS
    )
{
    BOOLEAN fResult;

    PAGED_CODE();

    RxLoudPrefixTableOperation("RxpAcquirePrefixTableLockExclusive");
    fResult = ExAcquireResourceExclusiveLite(&pTable->TableLock,Wait);

    return fResult;
}

VOID
RxExclusivePrefixTableLockToShared (
    PRX_PREFIX_TABLE pTable
    )
{
    PAGED_CODE();

    ExConvertExclusiveToSharedLite(&pTable->TableLock);
}

VOID
RxpReleasePrefixTableLock(
    PRX_PREFIX_TABLE pTable,
    BOOLEAN          ProcessBufferingStateChangeRequests
    RX_PREFIXTABLELOCK_PARAMS
    )
{
    PAGED_CODE();

    RxLoudPrefixTableOperation("RxpReleasePrefixTableLock");
    ExReleaseResourceLite(&pTable->TableLock);
}

BOOLEAN
RxIsPrefixTableEmpty(
    IN PRX_PREFIX_TABLE   ThisTable)
{
    BOOLEAN IsEmpty;

    PAGED_CODE();
    ASSERT  ( RxIsPrefixTableLockAcquired ( ThisTable )  );

    RxCheckTableConsistency(ThisTable,' kue');

    IsEmpty = IsListEmpty(&ThisTable->MemberQueue);

    return IsEmpty;
}

PVOID
RxPrefixTableLookupName (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  CanonicalName,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID OPTIONAL RxConnectionId
    )
/*++

Routine Description:

    The routine looks up a name in a prefix table and converts from the underlying pointer to the containing
    record. The table lock should be held AT LEAST shared for this operation.

Arguments:

    ThisTable      - the table to be looked in.

    CanonicalName  - the name to be looked up

    RemainingName  - the portion of the name unmatched.
Return Value:

    Ptr to the found node or NULL.

--*/
{
    PVOID pContainer = NULL;
    PRX_PREFIX_ENTRY ThisEntry;

    PAGED_CODE();
    ASSERT  ( RxIsPrefixTableLockAcquired ( ThisTable )  );

    RxDbgTrace( +1, Dbg, ("RxPrefixTableLookupName  Name = %wZ \n", CanonicalName));
    RxCheckTableConsistency(ThisTable,' kul');

    ASSERT(CanonicalName->Length > 0);

    pContainer = RxTableLookupName(ThisTable, CanonicalName,RemainingName, RxConnectionId);

    if (pContainer ==  NULL){
        RxDbgTrace(-1, Dbg, ("RxPrefixTableLookupName  Name = %wZ   F A I L E D  !!\n", CanonicalName));
        return NULL;
    } else {
        IF_DEBUG {
           if (RdbssReferenceTracingValue != 0) {
              switch (NodeType(pContainer) & ~RX_SCAVENGER_MASK) {
              case RDBSS_NTC_SRVCALL :
                 {
                    RxpTrackReference(RDBSS_REF_TRACK_SRVCALL,__FILE__,__LINE__,pContainer);
                 }
                 break;
              case RDBSS_NTC_NETROOT :
                 {
                    RxpTrackReference(RDBSS_REF_TRACK_NETROOT,__FILE__,__LINE__,pContainer);
                 }
                 break;
              case RDBSS_NTC_V_NETROOT:
                 {
                    RxpTrackReference(RDBSS_REF_TRACK_VNETROOT,__FILE__,__LINE__,pContainer);
                 }
                 break;
              default:
                 {
                    ASSERT(!"Valid node type for referencing");
                 }
                 break;
              }
           }
        }

        RxReference(pContainer);

        RxDbgTrace(-1, Dbg, ("RxPrefixTableLookupName  Name = %wZ Container = 0x%8lx\n", CanonicalName, pContainer));
    }

    return pContainer;
}


PRX_PREFIX_ENTRY
RxTableLookupName_ExactLengthMatch (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    IN  ULONG            HashValue,
    IN  PRX_CONNECTION_ID RxConnectionId
    )
/*++

Routine Description:

    The routine looks up a name in a rxtable; whether or not to do case insensitive is a property
    of the table. The table lock should be held AT LEAST
    shared for this operation; the routine may boost itself to exclusive on the lock if it wants to rearrange the table.

Arguments:

    ThisTable - the table to be looked in.
    Name      - the name to be looked up
    HashValue - the precomputed hashvalue

Return Value:

    Ptr to the found node or NULL.

--*/
{
    PLIST_ENTRY HashBucket, ListEntry;
    BOOLEAN CaseInsensitiveMatch = ThisTable->CaseInsensitiveMatch;

    PAGED_CODE();

    ASSERT( RxConnectionId );

    HashBucket = HASH_BUCKET(ThisTable,HashValue);

    for (ListEntry = HashBucket->Flink;
         ListEntry != HashBucket;
         ListEntry = ListEntry->Flink
        ) {
        PRX_PREFIX_ENTRY PrefixEntry;
        PVOID Container;

        ASSERT(ListEntry!=NULL);
        PrefixEntry = CONTAINING_RECORD( ListEntry, RX_PREFIX_ENTRY, HashLinks );

        RxDbgTrace(0,Dbg,("Considering <%wZ> hashv=%d \n",&PrefixEntry->Prefix,PrefixEntry->SavedHashValue));
        DbgDoit(ThisTable->Considers++);

        ASSERT(HashBucket == HASH_BUCKET(ThisTable,PrefixEntry->SavedHashValue));

        ASSERT(PrefixEntry!=NULL);
        Container = PrefixEntry->ContainingRecord;

        ASSERT(Container!=NULL);

        if ( (PrefixEntry->SavedHashValue == HashValue)
             && (PrefixEntry->Prefix.Length==Name->Length) ){
            USHORT CaseInsensitiveLength = PrefixEntry->CaseInsensitiveLength;
            DbgDoit(ThisTable->Compares++);
            if (CaseInsensitiveLength == 0) {
                RxDbgTrace(0,Dbg,("Comparing <%wZ> with <%wZ>, ins=%x\n",Name,&PrefixEntry->Prefix,CaseInsensitiveMatch));
                if (RtlEqualUnicodeString(Name,&PrefixEntry->Prefix,CaseInsensitiveMatch) ) {
                    if( !ThisTable->IsNetNameTable || RxEqualConnectionId( RxConnectionId, &PrefixEntry->ConnectionId ) )
                    {
                        return PrefixEntry;
                    }
                }
            } else {
                //part of the compare will be case insensitive and part controlled by the flag
                UNICODE_STRING PartOfName,PartOfPrefix;
                ASSERT( CaseInsensitiveLength <= Name->Length );
                PartOfName.Buffer = Name->Buffer;
                PartOfName.Length = CaseInsensitiveLength;
                PartOfPrefix.Buffer = PrefixEntry->Prefix.Buffer;
                PartOfPrefix.Length = CaseInsensitiveLength;
                RxDbgTrace(0,Dbg,("InsensitiveComparing <%wZ> with <%wZ>\n",&PartOfName,&PartOfPrefix));
                if (RtlEqualUnicodeString(&PartOfName,&PartOfPrefix,TRUE) ) {
                    if (Name->Length == CaseInsensitiveLength ) {
                        if( !ThisTable->IsNetNameTable || RxEqualConnectionId( RxConnectionId, &PrefixEntry->ConnectionId ) )
                        {
                            return PrefixEntry;
                        }
                    }
                    PartOfName.Buffer = (PWCHAR)(((PCHAR)PartOfName.Buffer)+CaseInsensitiveLength);
                    PartOfName.Length = Name->Length - CaseInsensitiveLength;
                    PartOfPrefix.Buffer = (PWCHAR)(((PCHAR)PartOfPrefix.Buffer)+CaseInsensitiveLength);
                    PartOfPrefix.Length = PrefixEntry->Prefix.Length - CaseInsensitiveLength;
                    RxDbgTrace(0,Dbg,("AndthenComparing <%wZ> with <%wZ>\n",&PartOfName,&PartOfPrefix));
                    if (RtlEqualUnicodeString(&PartOfName,&PartOfPrefix,FALSE) ) {
                        if( !ThisTable->IsNetNameTable || RxEqualConnectionId( RxConnectionId, &PrefixEntry->ConnectionId ) )
                        {
                            return PrefixEntry;
                        }
                    }
                }
            }
        }
    }

    return NULL;
}

PVOID
RxTableLookupName (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID OPTIONAL RxConnectionId
    )
/*++

Routine Description:

    The routine looks up a name in a prefix table. The table lock should be held AT LEAST shared for this operation; the routine
    may boost itself to exclusive on the lock if it wants to rearrange the table.

    This routine conducts itself differently depending on whether the table is the netroot table. if so, it actually does
    a prefix match; if not, it actually does an exact match and fails immediately if the exact match fails. Eventually, we may want
    to actually point to different routines...what a concept.

Arguments:

    ThisTable - the table to be looked in.
    Name      - the name to be looked up

Return Value:

    Ptr to the found node or NULL.

--*/
{
    ULONG HashValue;

    UNICODE_STRING Prefix;

    PRX_PREFIX_ENTRY pFoundPrefixEntry;
    PVOID            pContainer = NULL;

    ULONG i,length;

    PRX_PREFIX_ENTRY pPrefixEntry;

    RX_CONNECTION_ID LocalId;

    PAGED_CODE();

    if( ThisTable->IsNetNameTable && !RxConnectionId )
    {
        RtlZeroMemory( &LocalId, sizeof(RX_CONNECTION_ID) );
        RxConnectionId = &LocalId;
    }

    ASSERT(Name->Buffer[0]==L'\\');

    RxDbgTrace(+1, Dbg, ("RxTableLookupName\n"));

    //
    //the code below takes cognizance of what it knows is stored in the netname table,
    //i.e. netroots and vnetroots cause an immediate return, and srvcalls which require that we continue looking
    //to see if we will find a netroot/vnetroot that is longer.  so, we go down the table looking at each possible
    //prefix. if we exhaust the list w/o finding a hit, it's a failure. if we find a v/netroot, instant out. if
    //we find a srvcall we keep looking
    //

    length = Name->Length / sizeof(WCHAR);
    Prefix.Buffer = Name->Buffer;
    pFoundPrefixEntry = NULL;

    for (i=1;;i++) {
        if ((i>=length) ||
            (Prefix.Buffer[i]==OBJ_NAME_PATH_SEPARATOR) ||
            (Prefix.Buffer[i]==L':')) {

            //we have a prefix...lookit up
            Prefix.Length=(USHORT)(i*sizeof(WCHAR));
            HashValue = RxTableComputeHashValue(&Prefix);
            pPrefixEntry = RxTableLookupName_ExactLengthMatch(ThisTable, (&Prefix), HashValue, RxConnectionId);
            DbgDoit(ThisTable->Lookups++);

            if (pPrefixEntry!=NULL) {
                pFoundPrefixEntry = pPrefixEntry;
                pContainer = pFoundPrefixEntry->ContainingRecord;

                ASSERT (pPrefixEntry->ContainingRecord != NULL);
                if ((NodeType(pPrefixEntry->ContainingRecord) & ~RX_SCAVENGER_MASK)
                     == RDBSS_NTC_V_NETROOT) {
                    break;
                }

                if ((NodeType(pPrefixEntry->ContainingRecord) & ~RX_SCAVENGER_MASK)
                     == RDBSS_NTC_NETROOT) {
                    PNET_ROOT pNetRoot = (PNET_ROOT)pPrefixEntry->ContainingRecord;
                    if (pNetRoot->DefaultVNetRoot != NULL) {
                        pContainer = pNetRoot->DefaultVNetRoot;
                    } else if (!IsListEmpty(&pNetRoot->VirtualNetRoots)) {
                        pContainer = CONTAINING_RECORD(
                                         pNetRoot->VirtualNetRoots.Flink,
                                         V_NET_ROOT,
                                         NetRootListEntry);
                    } else {
                        ASSERT(!"Invalid Net Root Entry in Prefix Table");
                        pFoundPrefixEntry = NULL;
                        pContainer = NULL;
                    }
                    break;
                }

                ASSERT ((NodeType(pPrefixEntry->ContainingRecord) & ~RX_SCAVENGER_MASK)
                        == RDBSS_NTC_SRVCALL );

                //in this case we have to go around again to try to extend to the netroot
            } else {
                DbgDoit(ThisTable->FailedLookups++);
            }

            //dont do this because of long netroots
            //if ((pPrefixEntry == NULL) && (pFoundPrefixEntry != NULL)) {
            //    break;
            //}
        }

        if (i>=length) {
            break;
        }
    }


    // Update the remaining Name
    if (pFoundPrefixEntry != NULL) {
        RxDbgTrace(0,Dbg,("Found Container(%lx) Node Type(%lx) Length Matched (%ld)",
                         pFoundPrefixEntry,
                         NodeType(pFoundPrefixEntry->ContainingRecord),
                         pFoundPrefixEntry->Prefix.Length));
        ASSERT(Name->Length >= pFoundPrefixEntry->Prefix.Length);

        RemainingName->Buffer = (PWCH)((PCHAR)Name->Buffer + pFoundPrefixEntry->Prefix.Length);
        RemainingName->Length = Name->Length - pFoundPrefixEntry->Prefix.Length;
        RemainingName->MaximumLength = RemainingName->Length;
    } else {
        *RemainingName = *Name;
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return pContainer;
}


PRX_PREFIX_ENTRY
RxPrefixTableInsertName (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry,
    IN     PVOID            Container,
    IN     PULONG           ContainerRefCount,
    IN     USHORT           CaseInsensitiveLength,
    IN     PRX_CONNECTION_ID RxConnectionId
    )

/*++

Routine Description:

    The routine inserts the name into the table. The tablelock should be held
    exclusive for this operation.

Arguments:

    ThisTable - the table to be looked in.
    ThisEntry - the prefixtable entry to use for the insertion.
    Container - is a backptr to the enclosing structure. (can't use CONTAINING_RECORD....sigh)
    ContainerRefCount - is a backptr to the refcount.....a different offset for fcbs from netroots
    Name      - the name to be inserted

Return Value:

    Ptr to the inserted node.

--*/
{
    ULONG HashValue;
    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("RxPrefixTableInsert Name = %wZ(%x/%x)\n", &ThisEntry->Prefix,
                             CaseInsensitiveLength,ThisEntry->Prefix.Length));
    RxLoudFcbMsg("Insert: ",&ThisEntry->Prefix);

    ASSERT  ( RxIsPrefixTableLockExclusive ( ThisTable )  );
    ASSERT( CaseInsensitiveLength <= ThisEntry->Prefix.Length );

    ThisEntry->ContainingRecord = Container;
    ThisEntry->ContainerRefCount = ContainerRefCount;
    ThisEntry->CaseInsensitiveLength = CaseInsensitiveLength;

    InterlockedIncrement(ContainerRefCount); //note: not set =1. should already be zero

    HashValue = RxTableComputeHashValue(&ThisEntry->Prefix);
    ThisEntry->SavedHashValue = HashValue;

    if (ThisEntry->Prefix.Length){
        ULONG HashValue = ThisEntry->SavedHashValue;
        PLIST_ENTRY HashBucket;

        HashBucket = HASH_BUCKET(ThisTable,HashValue);
        RxDbgTrace(0,Dbg,("RxTableInsertEntry %wZ hashv=%d\n",&ThisEntry->Prefix,ThisEntry->SavedHashValue));
        InsertHeadList(HashBucket,&ThisEntry->HashLinks);
    } else {
        ThisTable->TableEntryForNull = ThisEntry;
    }

    if( RxConnectionId )
    {
        RtlCopyMemory( &ThisEntry->ConnectionId, RxConnectionId, sizeof(RX_CONNECTION_ID) );
    }
    else
    {
        RtlZeroMemory( &ThisEntry->ConnectionId, sizeof(RX_CONNECTION_ID) );
    }

    InsertTailList(&ThisTable->MemberQueue,&ThisEntry->MemberQLinks);
    ThisTable->Version++;

    RxCheckTableConsistency(ThisTable,' tup');

    RxDbgTrace(-1, Dbg, ("RxPrefixTableInsert  Entry = %08lx Container = %08lx\n",
                             ThisEntry, ThisEntry->ContainingRecord));

    return ThisEntry;

}

VOID
RxRemovePrefixTableEntry(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    )

/*++

Routine Description:

    The routine to remove entry from the table. The table lock should be held exclusive during
    this operation. Please note that we do NOT dereference the node; this may seem strange since we
    ref the node in lookup and insert. The reason is that people are supposed to deref themselves after
    a lookup/insert.

Arguments:

    ThisTable - the table associated with the entry.
    ThisEntry - the entry being removed.

Return Value:

    None.

--*/
{
    PAGED_CODE();
    RxDbgTrace( 0, Dbg, (" RxRemovePrefixTableEntry, Name = %wZ\n", &ThisEntry->Prefix));
    RxLoudFcbMsg("Remove: ",&ThisEntry->Prefix);

    ASSERT( NodeType(ThisEntry) == RDBSS_NTC_PREFIX_ENTRY );
    ASSERT  ( RxIsPrefixTableLockExclusive ( ThisTable )  );

    if (ThisEntry->Prefix.Length) {
        RemoveEntryList(&ThisEntry->HashLinks);
    } else {
        ThisTable->TableEntryForNull = NULL;
    }

    ThisEntry->ContainingRecord = NULL;
    RemoveEntryList( &ThisEntry->MemberQLinks );
    ThisTable->Version++;

    RxCheckTableConsistency(ThisTable,' mer');

    return;
}

VOID
RxInitializePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN     ULONG            TableSize OPTIONAL, //0=>use default
    IN     BOOLEAN          CaseInsensitiveMatch
    )

/*++

Routine Description:

    The routine initializes the inner table linkage and the corresponding lock.

Arguments:

    ThisTable - the table to be initialized.

Return Value:

    None.

--*/

{
    ULONG i;

    PAGED_CODE();

    if (TableSize==0) {
        TableSize = RX_PREFIX_TABLE_DEFAULT_LENGTH;
    }

    // this is not zero'd so you have to be careful to init everything
    ThisTable->NodeTypeCode = RDBSS_NTC_PREFIX_TABLE;
    ThisTable->NodeByteSize = sizeof(RX_PREFIX_TABLE);

    InitializeListHead(&ThisTable->MemberQueue);
    ExInitializeResourceLite( &ThisTable->TableLock );
    ThisTable->Version = 0;
    ThisTable->TableEntryForNull = NULL;
    ThisTable->IsNetNameTable = FALSE;

    ThisTable->CaseInsensitiveMatch = CaseInsensitiveMatch;

    ThisTable->TableSize = TableSize;
    for (i=0;i<TableSize;i++) {
        InitializeListHead(&ThisTable->HashBuckets[i]);
    }

#if DBG
    ThisTable->Lookups = 0;
    ThisTable->FailedLookups = 0;
    ThisTable->Considers = 0;
    ThisTable->Compares = 0;
#endif
}

VOID
RxFinalizePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable
    )

/*++

Routine Description:

    The routine deinitializes a prefix table.

Arguments:

    ThisTable - the table to be finalized.

Return Value:

    None.

--*/

{
    ExDeleteResourceLite(&ThisTable->TableLock);
}


//#if DBG
#if 0
//the purpose of this routine is to catch errors in table manipulation; apparently, stuff is being deleted
//and not removed from the table. what we do is to keep a log of all the entries that we pass; if one of the
//entries is bad then it should be straightforward to compare this log with the previous log to see who did what.
//it probably happens on a failure case or something
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#define RX_PCTC_ENTRY_LENGTH 64
#define RX_PCTC_LOG_LENGTH (128*RX_PCTC_ENTRY_LENGTH)
#define RX_PCTC_LOG_LENGTH_PLUS (RX_PCTC_LOG_LENGTH+100) //the slop is 16 for the ----- and the rest for protection
UCHAR RxPCTC1[RX_PCTC_LOG_LENGTH_PLUS];
UCHAR RxPCTC2[RX_PCTC_LOG_LENGTH_PLUS];
PUCHAR RxPCTCCurrentLog = NULL;
VOID
RxCheckTableConsistency_actual (
    IN PRX_PREFIX_TABLE Table,
    IN ULONG Tag
    )
{
    ULONG i;
    PLIST_ENTRY ListEntry, NextListEntry;

    PAGED_CODE();

    if (Table->IsNetNameTable) { return; }

    ExAcquireResourceExclusiveLite(&Table->LoggingLock,TRUE);

    if (RxPCTCCurrentLog==&RxPCTC2[0]) {
        RxPCTCCurrentLog = &RxPCTC1[0];
    } else {
        RxPCTCCurrentLog = &RxPCTC2[0];
    }

    sprintf(RxPCTCCurrentLog,"----------");

    for (i=0,ListEntry = Table->MemberQueue.Flink;
         ListEntry != &Table->MemberQueue;
         i+=RX_PCTC_ENTRY_LENGTH,ListEntry = NextListEntry
        ) {
        PRX_PREFIX_ENTRY PrefixEntry;
        PVOID Container;

        ASSERT(ListEntry!=NULL);

        NextListEntry = ListEntry->Flink;
        PrefixEntry = CONTAINING_RECORD( ListEntry, RX_PREFIX_ENTRY, MemberQLinks );

        ASSERT(PrefixEntry!=NULL);
        Container = PrefixEntry->ContainingRecord;

        ASSERT(Container!=NULL);
        ASSERT(NodeTypeIsFcb(Container));

        if (i>=RX_PCTC_LOG_LENGTH ) { continue; }

        sprintf(&RxPCTCCurrentLog[i],"%4s %4s>> %-32.32wZ!!",&Tag,&Container,&PrefixEntry->Prefix);
        sprintf(&RxPCTCCurrentLog[i+16],"----------");

    }

    RxDbgTrace(0, Dbg, ("RxCheckTableConsistency_actual %d entries\n", i/RX_PCTC_ENTRY_LENGTH));
    ExReleaseResourceLite(&Table->LoggingLock);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxce.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxce.c

Abstract:

    This module implements the RXCE routines related to binding/unbinding, dynamic
    enabling/disabling of transports.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

    The number of transport bindings are in all probability very few ( mostly one or two).

--*/

#include "precomp.h"
#pragma  hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCeBuildTransport)
#pragma alloc_text(PAGE, RxCeTearDownTransport)
#pragma alloc_text(PAGE, RxCeQueryAdapterStatus)
#pragma alloc_text(PAGE, RxCeQueryTransportInformation)
#pragma alloc_text(PAGE, DuplicateTransportAddress)
#pragma alloc_text(PAGE, RxCeBuildAddress)
#pragma alloc_text(PAGE, RxCeTearDownAddress)
#endif

//
//  The debug trace level
//

#define Dbg  (DEBUG_TRACE_RXCEBINDING)


NTSTATUS
RxCeBuildTransport(
    IN  OUT PRXCE_TRANSPORT pTransport,
    IN      PUNICODE_STRING pTransportName,
    IN      ULONG           QualityOfService)
/*++

Routine Description:

    This routine binds to the transport specified.

Arguments:


    pTransportName - the binding string for the desired transport

    QualityOfService - the quality of service desired from the transport.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

     The RDBSS or RXCE do not paticipate in the computation of quality
     of service. They essentially use it as a magic number that needs
     to be passed to the underlying transport provider.

     At present we ignore the QualityOfService parameter. How should a request for
     binding to a transport that has been currently bound to with a lower quality of
     service be handled?

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeBinding,RxCeBindToTransport);

    try {
        pTransport->Signature = RXCE_TRANSPORT_SIGNATURE;

        pTransport->ConnectionCount = 0;
        pTransport->VirtualCircuitCount = 0;
        pTransport->pDeviceObject = NULL;
        pTransport->ControlChannel = INVALID_HANDLE_VALUE;
        pTransport->pControlChannelFileObject = NULL;

        pTransport->Name.MaximumLength = pTransportName->Length;
        pTransport->Name.Length = pTransportName->Length;

        pTransport->pProviderInfo
            = RxAllocatePoolWithTag(
                  PagedPool,
                  sizeof(RXCE_TRANSPORT_PROVIDER_INFO),
                  RXCE_TRANSPORT_POOLTAG);


        pTransport->Name.Buffer = RxAllocatePoolWithTag(
                                      NonPagedPool,
                                      pTransport->Name.Length,
                                      RXCE_TRANSPORT_POOLTAG);

        if ((pTransport->pProviderInfo != NULL) &&
            (pTransport->Name.Buffer != NULL)) {
            RtlCopyMemory(
                pTransport->Name.Buffer,
                pTransportName->Buffer,
                pTransport->Name.Length);

            // Initialize the transport information.
            Status = RxTdiBindToTransport(
                         pTransport);

            // Ensure that the quality of service criterion is met.

            // Cleanup if the operation was not successfull.
            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg, ("RxTdiBindToTransport returned %lx\n",Status));
                RxCeTearDownTransport(pTransport);
            } else {
                pTransport->QualityOfService = QualityOfService;
            }
        } else {
            RxCeTearDownTransport(pTransport);

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeBindToTransport T: %lx\n",pTransport));
            RxWmiLog(LOG,
                     RxCeBuildTransport,
                     LOGPTR(pTransport));
        }
    }

    return Status;
}

NTSTATUS
RxCeTearDownTransport(
    IN PRXCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine unbinds from the transport specified.

Arguments:

    pTransport - the transport instance

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

    if a transport that has not been bound to is specified no error is
    returned. The operation trivially succeeds.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeBinding,RxCeUnbindFromTransport);

    try {
        if (RxCeIsTransportValid(pTransport)) {
            if (pTransport->pDeviceObject != NULL) {
                Status = RxTdiUnbindFromTransport(pTransport);
            }

            RxDbgTrace(0, Dbg,("RxTdiUnbindFromTransport returned %lx\n",Status));

            if (pTransport->Name.Buffer != NULL) {
                RxFreePool(pTransport->Name.Buffer);
            }

            if (pTransport->pProviderInfo != NULL ) {
                RxFreePool(pTransport->pProviderInfo);
            }

            pTransport->ConnectionCount = 0;
            pTransport->VirtualCircuitCount = 0;
            pTransport->pProviderInfo = NULL;
            pTransport->pDeviceObject = NULL;
            pTransport->ControlChannel = INVALID_HANDLE_VALUE;
            pTransport->pControlChannelFileObject = NULL;

            Status = STATUS_SUCCESS;
        }
    } finally {
        if (AbnormalTermination()) {
            RxLog(("RxCeTdT: T: %lx\n",pTransport));
            RxWmiLog(LOG,
                     RxCeTearDownTransport,
                     LOGPTR(pTransport));
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


NTSTATUS
RxCeQueryAdapterStatus(
    PRXCE_TRANSPORT pTransport,
    PADAPTER_STATUS pAdapterStatus)
/*++

Routine Description:

    This routine returns the name of a given transport in a caller allocated buffer

Arguments:

    pTransport     - the RXCE_TRANSPORT instance

    pAdapterStatus - the adapter status of the transport

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();

    try {
        if (RxCeIsTransportValid(pTransport)) {
            Status = RxTdiQueryAdapterStatus(pTransport,pAdapterStatus);
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RXCeQAS: T: %lx\n",pTransport));
            RxWmiLog(LOG,
                     RxCeQueryAdapterStatus,
                     LOGPTR(pTransport));
        }
    }

    return Status;
}

NTSTATUS
RxCeQueryTransportInformation(
    PRXCE_TRANSPORT             pTransport,
    PRXCE_TRANSPORT_INFORMATION pTransportInformation)
/*++

Routine Description:

    This routine returns the transport information for a given transport

Arguments:

    pTransport            - the RXCE_TRANSPORT

    pTransportInformation - the information for the transport

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

    PAGED_CODE();

    try {
        if (RxCeIsTransportValid(pTransport)) {
            pProviderInfo = (PRXCE_TRANSPORT_PROVIDER_INFO)pTransportInformation;

            *pProviderInfo = *(pTransport->pProviderInfo);
            pTransportInformation->ConnectionCount  = pTransport->ConnectionCount;
            pTransportInformation->QualityOfService = pTransport->QualityOfService;

            Status = STATUS_SUCCESS;
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RXCeQTI: T: %lx\n",pTransport));
            RxWmiLog(LOG,
                     RxCeQueryTransportInformation,
                     LOGPTR(pTransport));
        }
    }

    return Status;
}

NTSTATUS
DuplicateTransportAddress(
    PTRANSPORT_ADDRESS *pCopy,
    PTRANSPORT_ADDRESS pOriginal,
    POOL_TYPE          PoolType)
/*++

Routine Description:

    This routine duplicates a transport addresses.

Arguments:

    pCopy  - the pointer to the new copy

    pOriginal - the original.

    PoolType - type of pool for memory allocation

Return Value:

    STATUS_SUCCESS if successful.

Notes:

--*/
{
    ULONG Size = ComputeTransportAddressLength(pOriginal);

    PAGED_CODE();

    *pCopy = (PTRANSPORT_ADDRESS)
             RxAllocatePoolWithTag(
                 PoolType,
                 Size,
                 RXCE_TRANSPORT_POOLTAG);

    if (*pCopy != NULL) {

        RtlCopyMemory(*pCopy,pOriginal,Size);

        return STATUS_SUCCESS;
    } else
        return STATUS_INSUFFICIENT_RESOURCES;
}

NTSTATUS
RxCeBuildAddress(
    IN OUT PRXCE_ADDRESS               pAddress,
    IN     PRXCE_TRANSPORT             pTransport,
    IN     PTRANSPORT_ADDRESS          pTransportAddress,
    IN     PRXCE_ADDRESS_EVENT_HANDLER pHandler,
    IN     PVOID                       pEventContext)
/*++

Routine Description:

    This routine associated a transport address with a transport binding.

Arguments:

    pAddress           - the address instance

    pTransport         - the transport with whihc this address is to be associated

    pTransportAddress  - the transport address to be associated with the binding

    pHandler           - the event handler associated with the registration.

    pEventContext      - the context parameter to be passed back to the event handler

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS        Status       = STATUS_INVALID_PARAMETER;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeRegisterClientAddress);

    try {
        if (RxCeIsTransportValid(pTransport)) {
            pAddress->Signature = RXCE_ADDRESS_SIGNATURE;

            pAddress->pTransport = pTransport;
            pAddress->hAddress = INVALID_HANDLE_VALUE;
            pAddress->pFileObject = NULL;
            pAddress->pHandler = NULL;
            pAddress->pTransportAddress = NULL;
            pAddress->pReceiveMdl = NULL;

            // Allocate the mmeory for the event handling dispatch vector
            pAddress->pHandler = (PRXCE_ADDRESS_EVENT_HANDLER)
                                 RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     sizeof(RXCE_ADDRESS_EVENT_HANDLER),
                                     RXCE_ADDRESS_POOLTAG);

            if (pAddress->pHandler != NULL) {
                RtlZeroMemory(
                    pAddress->pHandler,
                    sizeof(RXCE_ADDRESS_EVENT_HANDLER));

                // Duplicate the transport address for future searches
                Status = DuplicateTransportAddress(
                             &pAddress->pTransportAddress,
                             pTransportAddress,
                             PagedPool);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(Status)) {
                // Open the address w.r.t a transport provider
                Status = RxTdiOpenAddress(
                             pTransport,
                             pTransportAddress,
                             pAddress);

                if (NT_SUCCESS(Status)) {
                    // Initialize the handler and the associated context
                    if (pHandler != NULL) {
                        *(pAddress->pHandler) = *pHandler;
                        pAddress->pContext = pEventContext;
                    }
                } else {
                    RxCeTearDownAddress(pAddress);
                    RxDbgTrace(0, Dbg,("RxTdiOpenAddress returned %lx\n",Status));
                }
            } else {
                RxDbgTrace(0, Dbg,("RxCeOpenAddress returned %lx\n",Status));
            }
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeBA: T: %lx A: %lx\n",pTransport,pAddress));
            RxWmiLog(LOG,
                     RxCeBuildAddress,
                     LOGPTR(pTransport)
                     LOGPTR(pAddress));
        }
    }

    return Status;
}

NTSTATUS
RxCeTearDownAddress(
    IN PRXCE_ADDRESS pAddress)
/*++

Routine Description:

    This routine deregisters a transport address from a transport binding

Arguments:

    pAddress - the RxCe address denoting the transport binding/Transport address
               tuple.

Return Value:

    STATUS_SUCCESS if successful.

Notes:

--*/
{
    NTSTATUS        Status = STATUS_INVALID_PARAMETER;
    PRXCE_TRANSPORT pTransport;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeDeregisterClientAddress);

    try {
        pTransport = pAddress->pTransport;

        if (RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {
            // close the address object.

            if (pAddress->hAddress != INVALID_HANDLE_VALUE) {
                Status = RxTdiCloseAddress(pAddress);

                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(0, Dbg,("RxTdiCloseAddress returned %lx\n",Status));
                }
            }

            if (pAddress->pHandler != NULL) {
                RxFreePool(pAddress->pHandler);
            }

            if (pAddress->pTransportAddress != NULL) {
                RxFreePool(pAddress->pTransportAddress);
            }

            pAddress->pTransport = pTransport;
            pAddress->hAddress = INVALID_HANDLE_VALUE;
            pAddress->pFileObject = NULL;
            pAddress->pHandler = NULL;
            pAddress->pTransportAddress = NULL;
            pAddress->pReceiveMdl = NULL;
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

   return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxassert.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxAssert.c

Abstract:

    This module implements the normal assert routine so that it can be used even on a debug build.

Author:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

// i just got the stuff that i need from ntrtl.h because not it doesn't
// protect against multiple include

#if DBG
ULONG RxContinueFromAssert = 1;
#else
ULONG RxContinueFromAssert = 0;
#endif //DBG

VOID
RxDbgBreakPoint(
    ULONG LineNumber)
{
    DbgBreakPoint();
}

ULONG
NTAPI
DbgPrompt(
    PCH Prompt,
    PCH Response,
    ULONG MaximumResponseLength
    );

//#if DBG

VOID
RxAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    char    Response[ 2 ];
    CONTEXT Context;


#ifndef BLDR_KERNEL_RUNTIME
///    RtlCaptureContext( &Context );
#endif

    if (!RxContinueFromAssert) {

        //
        // we're outta here
        KeBugCheckEx (RDBSS_FILE_SYSTEM,
                      0xa55a0000|LineNumber,
                      0,0,0);
    }

    while (TRUE) {
        DbgPrint(
            "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
            Message ? Message : "",
            FailedAssertion,
            FileName ? FileName : "",
            LineNumber
            );

        DbgPrompt( "Break, Ignore (bi)? ",
                   Response,
                   sizeof( Response )
                 );

        switch (Response[0]) {
            case 'B':
            case 'b':

                DbgPrint( "Execute '!cxr %lx' to dump context\n", &Context);
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            }
        }

    DbgBreakPoint();
}
//#endif //if DBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxcexmit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxcexmit.c

Abstract:

    This module implements the data transmission routines along a connection as well as
    datagram transmissions

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

--*/

#include "precomp.h"
#pragma  hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCeSend)
#pragma alloc_text(PAGE, RxCeSendDatagram)
#endif

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCEXMIT)


NTSTATUS
RxCeSend(
    IN PRXCE_VC pVc,
    IN ULONG    SendOptions,
    IN PMDL     pMdl,
    IN ULONG    SendLength,
    IN PVOID    pCompletionContext)
/*++

Routine Description:

    This routine sends a TSDU along the specified connection.

Arguments:

    hConnection - the connection on which the TSDU is to be sent

    hVc         - the virtual circuit Id. along which the TSDU is to be sent

    SendOptions - the options for the send operation

    pMdl        - the buffer to be sent.

    SendLength  - length of data to be sent

    pCompletionContext - the context passed back to the caller during SendCompletion

Return Value:

    STATUS_SUCCESS if successfull

Notes:

--*/
{
    NTSTATUS Status;

    PRXCE_TRANSPORT  pTransport = NULL;
    PRXCE_ADDRESS    pAddress = NULL;
    PRXCE_CONNECTION pConnection = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeXmit,RxCeSend);

    try {
        Status = STATUS_CONNECTION_DISCONNECTED;

        // reference the objects
        pConnection = pVc->pConnection;
        pAddress    = pConnection->pAddress;
        pTransport  = pAddress->pTransport;

        if (RxCeIsVcValid(pVc) &&
            RxCeIsConnectionValid(pConnection) &&
            RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {

            if (pVc->State == RXCE_VC_ACTIVE) {
                Status = RxTdiSend(
                             pTransport,
                             pAddress,
                             pConnection,
                             pVc,
                             SendOptions,
                             pMdl,
                             SendLength,
                             pCompletionContext);
            }

            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg,("RxTdiSend returned %lx\n",Status));
            }
        }
    } finally {
        if (AbnormalTermination()) {
            RxLog(("RxCeSend: T: %lx A: %lx C: %lx VC: %lx\n",pTransport,pAddress,pConnection,pVc));
            RxWmiLog(LOG,
                     RxCeSend,
                     LOGPTR(pTransport)
                     LOGPTR(pAddress)
                     LOGPTR(pConnection)
                     LOGPTR(pVc));
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
    }

    return Status;
}

NTSTATUS
RxCeSendDatagram(
    IN PRXCE_ADDRESS                pAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext)
/*++

Routine Description:

    This routine sends a TSDU to a specified transport address.

Arguments:

    pLocalAddress  - the local address

    pConnectionInformation - the remote address

    SendOptions    - the options for the send operation

    pMdl           - the buffer to be sent.

    SendLength     - length of data to be sent

    pCompletionContext - the context passed back to the caller during Send completion.

Return Value:

    STATUS_SUCCESS if successfull

Notes:

--*/
{
    NTSTATUS Status;

    PRXCE_TRANSPORT  pTransport = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeXmit,RxCeSendDatagram);

    try {
        Status = STATUS_CONNECTION_DISCONNECTED;

        pTransport = pAddress->pTransport;

        if (RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {
            Status = RxTdiSendDatagram(
                         pTransport,
                         pAddress,
                         pConnectionInformation,
                         SendOptions,
                         pMdl,
                         SendLength,
                         pCompletionContext);

            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg,("RxTdiSendDatagram returned %lx\n",Status));
            }
        }
    } finally {
        if (AbnormalTermination()) {
            RxLog(("RxCeSendDg: T: %lx A: %lx\n",pTransport,pAddress));
            RxWmiLog(LOG,
                     RxCeSendDatagram,
                     LOGPTR(pTransport)
                     LOGPTR(pAddress));
            Status = STATUS_UNEXPECTED_NETWORK_ERROR;
        }
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxcep.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxcep.h

Abstract:

    This is the include file that defines all constants and types for
    implementing the redirector file system connection engine.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:
    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

--*/

#ifndef _RXCEP_H_
#define _RXCEP_H_

//
//  The following definition provide a rudimentary profiling mechanism by having a counter
//  associated with each of the procedure definitions. This counter is incremented for every
//  invocation.
//
//  Notes: we should think about some means of sorting all the counts so as to provide a global
//  picture of the redirector.
//

#define RxProfile(CATEGORY,ProcName)  {\
        RxDbgTrace(0,(DEBUG_TRACE_ALWAYS), ("%s@IRQL %d\n", #ProcName , KeGetCurrentIrql() )); \
        }

#include <rxworkq.h>
#include <rxce.h>       // Rx Connection Engine
#include <rxcehdlr.h>   // Rx Connection engine handler definitions
#include <mrx.h>        // RDBSS related definitions

//
// The following data structures are related to coordination between multiple callout
// ( calls by wrappers to other components ) made by the wrapper.

typedef struct _RX_CALLOUT_PARAMETERS_BLOCK_ {
    struct _RX_CALLOUT_PARAMETERS_BLOCK_ *pNextCallOutParameterBlock;
    struct _RX_CALLOUT_CONTEXT_ *pCallOutContext;

    NTSTATUS    CallOutStatus;
    ULONG       CallOutId;
} RX_CALLOUT_PARAMETERS_BLOCK,
 *PRX_CALLOUT_PARAMETERS_BLOCK;


typedef
VOID
(NTAPI *PRX_CALLOUT_ROUTINE) (
    IN OUT PRX_CALLOUT_PARAMETERS_BLOCK pParametersBlock);

typedef struct _RX_CALLOUT_CONTEXT_ {
    PRX_CALLOUT_ROUTINE pRxCallOutInitiation;
    PRX_CALLOUT_ROUTINE pRxCallOutCompletion;

    LONG  NumberOfCallOuts;
    LONG  NumberOfCallOutsInitiated;
    LONG  NumberOfCallOutsCompleted;

    KSPIN_LOCK  SpinLock;

    PRDBSS_DEVICE_OBJECT pRxDeviceObject;

    PRX_CALLOUT_PARAMETERS_BLOCK pCallOutParameterBlock;
} RX_CALLOUT_CONTEXT,
  *PRX_CALLOUT_CONTEXT;


// The following data structures implement the mechanism for initiating callouts to
// multiple transports for setting up a connection. The mini redirectors specify
// a number of local address handles for which they want to initiate a connection
// setup request to a remote server. They are in the desired order of importance.
//
// This mechanism allows for initiating all the callouts asynchronously and waiting
// for the best one to complete. Once it is done the connect request is completed
//
// This mechanism also provides the necessary infrastructure to cleanup the
// connection engine data structures after a connect request was completed. In other
// words the mini redirector need not wait for all the transports to complete, it
// merely waits for the best one to complete.
//
// These data structures are based on the generic Callout data structures defined in
// rxcep.h

typedef struct _RX_CREATE_CONNECTION_CALLOUT_CONTEXT_ {
    RX_CALLOUT_CONTEXT;

    RXCE_CONNECTION_CREATE_OPTIONS CreateOptions;

    // Results to be passed back to the original callout request
    PRXCE_CONNECTION_COMPLETION_ROUTINE  pCompletionRoutine;
    PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext;

    // TDI Connection context
    PRXCE_VC  pConnectionContext;

    // Callout id of the desired winner. It is originally set to the callout Id
    // associated with the first address and later modified depending upon the
    // completion status.
    ULONG   BestPossibleWinner;

    // The callout that was selected as the winner.
    ULONG   WinnerCallOutId;

    // The winner was found and the Completion event was signalled. This enables the
    // hystersis between the completion of the callout request and cleanup.
    BOOLEAN WinnerFound;

    // Once the winner is found we ensure that all callouts have been properly
    // initiated before the request is completed.
    BOOLEAN CompletionRoutineInvoked;

    RX_WORK_QUEUE_ITEM  WorkQueueItem;

    PKEVENT pCleanUpEvent;

} RX_CREATE_CONNECTION_CALLOUT_CONTEXT,
  *PRX_CREATE_CONNECTION_CALLOUT_CONTEXT;

typedef struct _RX_CREATE_CONNECTION_PARAMETERS_BLOCK_ {
    RX_CALLOUT_PARAMETERS_BLOCK;

    RXCE_CONNECTION     Connection;
    RXCE_VC             Vc;

    // TDI context for async continuation
    PIRP                pConnectIrp;
    PULONG              IrpRefCount;
} RX_CREATE_CONNECTION_PARAMETERS_BLOCK,
  *PRX_CREATE_CONNECTION_PARAMETERS_BLOCK;

//
// Miscellanous routines to support constuction/destruction of connection engine
// data structures
//

extern NTSTATUS
NTAPI
RxCeInit();

extern VOID
NTAPI
RxCeTearDown();


#endif  // _RXCEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxcecnct.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxcemgmt.c

Abstract:

    This module implements the RXCE routines related to connection management.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

--*/

#include "precomp.h"
#pragma  hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCepInitializeVC)
#pragma alloc_text(PAGE, RxCeBuildVC)
#pragma alloc_text(PAGE, RxCeTearDownVC)
#pragma alloc_text(PAGE, RxCeInitiateVCDisconnect)
#pragma alloc_text(PAGE, DuplicateConnectionInformation)
#pragma alloc_text(PAGE, RxCepInitializeConnection)
#pragma alloc_text(PAGE, RxCeBuildConnection)
#pragma alloc_text(PAGE, RxCeCleanupConnectCallOutContext)
#pragma alloc_text(PAGE, RxCeBuildConnectionOverMultipleTransports)
#pragma alloc_text(PAGE, RxCeTearDownConnection)
#pragma alloc_text(PAGE, RxCeCancelConnectRequest)
#pragma alloc_text(PAGE, RxCeQueryInformation)
#endif

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCEMANAGEMENT)

NTSTATUS
RxCepInitializeVC(
    PRXCE_VC         pVc,
    PRXCE_CONNECTION pConnection)
/*++

Routine Description:

    This routine initializes a VCdata structure

Arguments:

    pVc            - the VC instance.

    pConnection    - the connection.

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    PAGED_CODE();

    ASSERT(RxCeIsConnectionValid(pConnection));

    RtlZeroMemory(
        pVc,
        sizeof(RXCE_VC));

    pVc->Signature   = RXCE_VC_SIGNATURE;
    pVc->pConnection = pConnection;
    pVc->hEndpoint   = INVALID_HANDLE_VALUE;
    pVc->State       = RXCE_VC_DISCONNECTED;

    return STATUS_SUCCESS;
}

NTSTATUS
RxCeBuildVC(
    IN OUT PRXCE_VC            pVc,
    IN     PRXCE_CONNECTION    pConnection)
/*++

Routine Description:

    This routine adds a virtual circuit to a specified connection

Arguments:

    pConnection  - the connection for which a VC is to be added

    pVcPointer    - the handle of the new virtual circuit

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_INVALID_PARAMETER;

    PRXCE_TRANSPORT  pTransport = NULL;
    PRXCE_ADDRESS    pAddress   = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeBuildVc);

    try {
        pAddress = pConnection->pAddress;
        pTransport = pAddress->pTransport;

        if (RxCeIsConnectionValid(pConnection) &&
            RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {

            Status = RxCepInitializeVC(
                         pVc,
                         pConnection);

            if (NT_SUCCESS(Status)) {
                Status = RxTdiConnect(
                             pTransport,    // the associated transport
                             pAddress,      // the RxCe address
                             pConnection,   // the RxCe connection
                             pVc);          // the RxCe virtual circuit associated with the connection

                if (Status == STATUS_SUCCESS) {
                    pVc->State       = RXCE_VC_ACTIVE;
                }
            }
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeAddVC: VC: %lx Status %lx\n",pVc,Status));
            RxWmiLog(LOG,
                     RxCeBuildVC,
                     LOGPTR(pVc)
                     LOGULONG(Status));
        }
    }

    return Status;
}


NTSTATUS
RxCeInitiateVCDisconnect(
    IN PRXCE_VC pVc)
/*++

Routine Description:

    This routine initiates a disconnect on the VC.

Arguments:

    pVc - the VC instance to be disconnected

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_SUCCESS;

    PRXCE_TRANSPORT  pTransport  = NULL;
    PRXCE_ADDRESS    pAddress    = NULL;
    PRXCE_CONNECTION pConnection = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeTearDownVc);

    try {
        if ((pVc->pEndpointFileObject != NULL)  &&
            (pVc->hEndpoint != INVALID_HANDLE_VALUE)) {
            pConnection = pVc->pConnection;
            pAddress = pConnection->pAddress;
            pTransport = pAddress->pTransport;

            if (RxCeIsVcValid(pVc) &&
                RxCeIsConnectionValid(pConnection) &&
                RxCeIsAddressValid(pAddress) &&
                RxCeIsTransportValid(pTransport)) {

                LONG VcState = InterlockedExchange(
                                   &pVc->State,
                                   RXCE_VC_TEARDOWN);

                if (VcState != RXCE_VC_TEARDOWN) {
                    Status = RxTdiDisconnect(
                                 pTransport,    // the associated transport
                                 pAddress,      // the RxCe address
                                 pConnection,   // the RxCe connection
                                 pVc,           // the RxCe virtual circuit associated with the connection
                                 RXCE_DISCONNECT_ABORT); // disconnect options

                    if (!NT_SUCCESS(Status)) {
                        RxDbgTrace(0, Dbg,("RxCeTearDownVC returned %lx\n",Status));
                    }
                } else {
                    Status = STATUS_SUCCESS;
                }
            } else {
                RxDbgTrace(0, Dbg,("RxCeTearDownVC -- Invalid VC %lx\n",pVc));
            }
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeInitiateVCDisconnect: VC: %lx Status %lx\n",pVc,Status));
            RxWmiLog(LOG,
                     RxCeInitiateVCDisconnect,
                     LOGPTR(pVc)
                     LOGULONG(Status));
        }
    }

    return Status;
}

NTSTATUS
RxCeTearDownVC(
    IN PRXCE_VC pVc)
/*++

Routine Description:

    This routine tears down the VC instance.

Arguments:

    pVc - the VC instance to be torn down

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_SUCCESS;

    PRXCE_TRANSPORT  pTransport  = NULL;
    PRXCE_ADDRESS    pAddress    = NULL;
    PRXCE_CONNECTION pConnection = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeTearDownVc);

    try {
        if (pVc->pCleanUpEvent != NULL) {
            // wait for the clean up of connections over other transports to be completed
            KeWaitForSingleObject(
                       pVc->pCleanUpEvent,
                       Executive,
                       KernelMode,
                       FALSE,
                       NULL);

            RxFreePool(pVc->pCleanUpEvent);
            pVc->pCleanUpEvent = NULL;
        }

        if ((pVc->pEndpointFileObject != NULL)  &&
            (pVc->hEndpoint != INVALID_HANDLE_VALUE)) {
            pConnection = pVc->pConnection;
            pAddress = pConnection->pAddress;
            pTransport = pAddress->pTransport;

            if (RxCeIsVcValid(pVc) &&
                RxCeIsConnectionValid(pConnection) &&
                RxCeIsAddressValid(pAddress) &&
                RxCeIsTransportValid(pTransport)) {

                LONG VcState = InterlockedExchange(
                                   &pVc->State,
                                   RXCE_VC_TEARDOWN);

                if (VcState != RXCE_VC_TEARDOWN) {
                    Status = RxTdiDisconnect(
                                 pTransport,    // the associated transport
                                 pAddress,      // the RxCe address
                                 pConnection,   // the RxCe connection
                                 pVc,           // the RxCe virtual circuit associated with the connection
                                 RXCE_DISCONNECT_ABORT); // disconnect options

                    if (!NT_SUCCESS(Status)) {
                        RxDbgTrace(0, Dbg,("RxCeTearDownVC returned %lx\n",Status));
                    }
                } else {
                    Status = STATUS_SUCCESS;
                }
            } else {
                RxDbgTrace(0, Dbg,("RxCeTearDownVC -- Invalid VC %lx\n",pVc));
            }

            // Dereference the endpoint file object.
            ObDereferenceObject(pVc->pEndpointFileObject);

            // Close the endpoint file object handle
            Status = ZwClose(pVc->hEndpoint);

            ASSERT(Status == STATUS_SUCCESS);

            pVc->hEndpoint = INVALID_HANDLE_VALUE;
            pVc->pEndpointFileObject = NULL;
        }

        RtlZeroMemory(pVc,sizeof(RXCE_VC));
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeTearDownVC: VC: %lx Status %lx\n",pVc,Status));
            RxWmiLog(LOG,
                     RxCeTearDownVC,
                     LOGPTR(pVc)
                     LOGULONG(Status));
        }
    }
    
    return Status;
}


NTSTATUS
DuplicateConnectionInformation(
    PRXCE_CONNECTION_INFORMATION *pCopy,
    PRXCE_CONNECTION_INFORMATION pOriginal,
    POOL_TYPE                    PoolType)
/*++

Routine Description:

    This routine duplicates a connection information addresses.

Arguments:

    pCopy  - the pointer to the new copy

    pOriginal - the original.

    PoolType - type of pool for memory allocation

Return Value:

    STATUS_SUCCESS if successful.

Notes:

--*/
{
    PVOID pUserData = NULL;
    PVOID pRemoteAddress = NULL;
    PVOID pOptions = NULL;
    PRXCE_CONNECTION_INFORMATION pConnectionInformation = NULL;
    BOOLEAN fFailed = FALSE;

    PAGED_CODE();

    pConnectionInformation = RxAllocatePoolWithTag(
                                 PoolType,
                                 sizeof(RXCE_CONNECTION_INFORMATION),
                                 RXCE_CONNECTION_POOLTAG);
    if (pConnectionInformation != NULL) {
        RtlCopyMemory(
            pConnectionInformation,
            pOriginal,
            sizeof(RXCE_CONNECTION_INFORMATION));
    } else
        fFailed = TRUE;

    if (!fFailed && pOriginal->UserDataLength > 0) {
        pUserData = RxAllocatePoolWithTag(
                        PoolType,
                        pOriginal->UserDataLength,
                        RXCE_CONNECTION_POOLTAG);
        if (pUserData != NULL) {
            RtlCopyMemory(
                pUserData,
                pOriginal->UserData,
                pOriginal->UserDataLength);
        } else
            fFailed = TRUE;
    }

    if (!fFailed && pOriginal->RemoteAddressLength > 0) {
        pRemoteAddress = RxAllocatePoolWithTag(
                             PoolType,
                             pOriginal->RemoteAddressLength,
                             RXCE_CONNECTION_POOLTAG);
        if (pRemoteAddress != NULL) {
            PTA_ADDRESS pTaAdress;
            PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)pRemoteAddress;
            LONG NoOfAddress;

            RtlCopyMemory(
                pRemoteAddress,
                pOriginal->RemoteAddress,
                pOriginal->RemoteAddressLength);

            pTaAdress = &pTransportAddress->Address[0];

            for (NoOfAddress=0; NoOfAddress<pTransportAddress->TAAddressCount;NoOfAddress++) {
                if (pTaAdress->AddressType == TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX) {
                    PTDI_ADDRESS_NETBIOS_UNICODE_EX pTdiNetbiosUnicodeExAddress;

                    pTdiNetbiosUnicodeExAddress = (PTDI_ADDRESS_NETBIOS_UNICODE_EX)pTaAdress->Address;
                    pTdiNetbiosUnicodeExAddress->EndpointName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->EndpointBuffer;
                    pTdiNetbiosUnicodeExAddress->RemoteName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->RemoteNameBuffer;

                    //DbgPrint("Rdbss copy NETBIOS_UNICODE_EX on TA %lx UA %lx %wZ %wZ\n",
                    //         pTaAdress,
                    //         pTdiNetbiosUnicodeExAddress,
                    //         &pTdiNetbiosUnicodeExAddress->EndpointName,
                    //         &pTdiNetbiosUnicodeExAddress->RemoteName);
                    break;
                } else {
                    pTaAdress = (PTA_ADDRESS)((PCHAR)pTaAdress +
                                    FIELD_OFFSET(TA_ADDRESS,Address) +
                                    pTaAdress->AddressLength);
                }
            }
        } else
            fFailed = TRUE;
    }

    if (!fFailed && pOriginal->OptionsLength > 0) {
        pOptions = RxAllocatePoolWithTag(
                       PoolType,
                       pOriginal->OptionsLength,
                       RXCE_CONNECTION_POOLTAG);

        if (pOptions != NULL) {
            RtlCopyMemory(
                pOptions,
                pOriginal->Options,
                pOriginal->OptionsLength);
        } else
            fFailed = TRUE;
    }

    if (!fFailed) {
        pConnectionInformation->UserData = pUserData;
        pConnectionInformation->RemoteAddress = pRemoteAddress;
        pConnectionInformation->Options = pOptions;
        *pCopy = pConnectionInformation;
        return STATUS_SUCCESS;
    } else {
        if (pOptions != NULL) {
            RxFreePool(pOptions);
        }

        if (pRemoteAddress != NULL) {
            RxFreePool(pRemoteAddress);
        }

        if (pUserData != NULL) {
            RxFreePool(pUserData);
        }

        if (pConnectionInformation != NULL) {
            RxFreePool(pConnectionInformation);
        }

        *pCopy = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}

NTSTATUS
RxCepInitializeConnection(
    IN OUT PRXCE_CONNECTION             pConnection,
    IN     PRXCE_ADDRESS                pAddress,
    IN     PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext)
/*++

Routine Description:

    This routine initializes a connection data structure

Arguments:

    pConnection    - the newly created connection.

    pAddress       - the local address

    pConnectionInformation - the connection information specifying the remote address.

    pHandler       - the handler for processing receive indications

    pEventContext  - the context to be used for indications

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    // Initialize the new connection
    RtlZeroMemory(
        pConnection,
        sizeof(RXCE_CONNECTION));

    pConnection->Signature = RXCE_CONNECTION_SIGNATURE;
    pConnection->pAddress = pAddress;

    // Duplicate the connection information if successful
    if (pConnectionInformation != NULL) {
        Status = DuplicateConnectionInformation(
                     &pConnection->pConnectionInformation,
                     pConnectionInformation,
                     NonPagedPool);
    }

    if (NT_SUCCESS(Status) &&
        (pHandler != NULL)) {
        pConnection->pHandler = (PRXCE_CONNECTION_EVENT_HANDLER)
                                 RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     sizeof(RXCE_CONNECTION_EVENT_HANDLER),
                                     RXCE_CONNECTION_POOLTAG);

        if (pConnection->pHandler != NULL) {
            RtlZeroMemory(
                pConnection->pHandler,
                sizeof(RXCE_CONNECTION_EVENT_HANDLER));

            *(pConnection->pHandler) = *pHandler;
            pConnection->pContext    = pEventContext;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return Status;
}

NTSTATUS
RxCeBuildConnection(
    IN  PRXCE_ADDRESS                  pAddress,
    IN  PRXCE_CONNECTION_INFORMATION   pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER pHandler,
    IN  PVOID                          pEventContext,
    IN OUT PRXCE_CONNECTION            pConnection,
    IN OUT PRXCE_VC                    pVc)
/*++

Routine Description:

    This routine establishes a connection between a local RxCe address and a given remote address

Arguments:

    pAddress       - the local address

    pConnectionInformation - the connection information specifying the remote address.

    pHandler       - the handler for processing receive indications

    pEventContext  - the context to be used for indications

    pConnection    - the newly created connection.

    pVc            - the VC associated with the connection.

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS          Status;

    PRXCE_TRANSPORT   pTransport     = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeBuildConnection);

    try {
        pTransport = pAddress->pTransport;

        if (RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {

            Status = RxCepInitializeConnection(
                         pConnection,
                         pAddress,
                         pConnectionInformation,
                         pHandler,
                         pEventContext);

            if (NT_SUCCESS(Status)) {
                Status = RxCeBuildVC(pVc,pConnection);
            }

            if (!NT_SUCCESS(Status)) {
                RxCeTearDownVC(pVc);
                RxCeTearDownConnection(pConnection);
                RxDbgTrace(0, Dbg,("RxCeOpenConnection returned %lx\n",Status));
            } else {
                // NetBT may return the DNS name on Remote Address
                RtlCopyMemory(pConnectionInformation->RemoteAddress,
                              pConnection->pConnectionInformation->RemoteAddress,
                              pConnection->pConnectionInformation->RemoteAddressLength);
            }
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeCreateConnection %lx \n",pAddress));
            RxWmiLog(LOG,
                     RxCeBuildConnection,
                     LOGPTR(pAddress));
        }
    }

    return Status;
}

extern
NTSTATUS
RxCeCompleteConnectRequest(
    PRX_CALLOUT_PARAMETERS_BLOCK pParameterBlock);

NTSTATUS
RxCeInitiateConnectRequest(
    PRX_CALLOUT_PARAMETERS_BLOCK pParameterBlock)
/*++

Routine Description:

    This routine initiates a connection callout request to a particular transport

Arguments:

    pParameterBlock  - the parameter block for initaiting the connection.

Notes:

--*/
{
    NTSTATUS Status;

    KIRQL   OldIrql;

    BOOLEAN InitiateConnectionRequest;

    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT   pCreateConnectionContext;

    pCreateConnectionContext =  (PRX_CREATE_CONNECTION_CALLOUT_CONTEXT)
                                pParameterBlock->pCallOutContext;

    KeAcquireSpinLock(&pCreateConnectionContext->SpinLock,&OldIrql);

    InitiateConnectionRequest = (!pCreateConnectionContext->WinnerFound);

    KeReleaseSpinLock(&pCreateConnectionContext->SpinLock,OldIrql);

    if (InitiateConnectionRequest) {
        Status = RxTdiInitiateAsynchronousConnect(
                     (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)pParameterBlock);
    } else {
        Status = STATUS_CANCELLED;
    }

    if (Status != STATUS_PENDING) {
        pParameterBlock->CallOutStatus = Status;

        RxCeCompleteConnectRequest(pParameterBlock);
    }
    return Status;
}

VOID
RxCeCleanupConnectCallOutContext(
    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT pCreateConnectionContext)
/*++

Routine Description:

    This routine cleansup a connection callout request. This cannot be done in
    the context of any of the transport callback routines because of environmental
    constraints, i.e., Transports can callback at DPC level.

Arguments:

    pCreateConnectionContext - the connection context.

Notes:

--*/
{
    NTSTATUS Status;

    // Walk through the list of parameter blocks associated with this
    // callout context and initiate the appropriate tear down action.

    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pTempParameterBlock;
    PRDBSS_DEVICE_OBJECT pRxDeviceObject = NULL;

    
    PAGED_CODE();
    
    pRxDeviceObject = pCreateConnectionContext->pRxDeviceObject;

    pTempParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                          pCreateConnectionContext->pCallOutParameterBlock;

    while (pTempParameterBlock != NULL) {
        if (pTempParameterBlock->CallOutId != pCreateConnectionContext->WinnerCallOutId) {
            RxTdiCleanupAsynchronousConnect(
                pTempParameterBlock);
        }

        RxCeTearDownVC(
            &pTempParameterBlock->Vc);

        RxCeTearDownConnection(
            &pTempParameterBlock->Connection);

        pTempParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                              pTempParameterBlock->pNextCallOutParameterBlock;
    }

    if (pCreateConnectionContext->pCallOutParameterBlock != NULL) {
        RxLog(("Freeparamblock %x, %x\n",
                pCreateConnectionContext->pCallOutParameterBlock, KeGetCurrentThread()));
        RxWmiLog(LOG,
                 RxCeCleanupConnectCallOutContext,
                 LOGPTR(pCreateConnectionContext->pCallOutParameterBlock));
        RxFreePool(pCreateConnectionContext->pCallOutParameterBlock);
    }

    if (pCreateConnectionContext->pCleanUpEvent != NULL) {
        RxFreePool(pCreateConnectionContext->pCleanUpEvent);
    } else {
        PRXCE_VC pVc = pCreateConnectionContext->pConnectionContext;
        
        KeSetEvent(pVc->pCleanUpEvent, 0, FALSE);
    }

    RxFreePool(pCreateConnectionContext);

    if (pRxDeviceObject != NULL) {
        RxDeregisterAsynchronousRequest(pRxDeviceObject);
    }
}

NTSTATUS
RxCeCompleteConnectRequest(
    PRX_CALLOUT_PARAMETERS_BLOCK pParameterBlock)
/*++

Routine Description:

    This routine completes a connection callout request

Arguments:

    pParameterBlock - the parameter block instance.

Notes:

--*/
{
    BOOLEAN  AllCallOutsCompleted = FALSE;
    BOOLEAN  AllCallOutsInitiated = FALSE;
    BOOLEAN  InvokeCompletionRoutine = FALSE;
    BOOLEAN  WinnerFound          = FALSE;
    NTSTATUS    Status = STATUS_SUCCESS;

    KIRQL OldIrql;

    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pWinningParameterBlock;

    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT   pCreateConnectionContext;
    PRXCE_CONNECTION_COMPLETION_CONTEXT     pCompletionContext;
    PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine;

    pCreateConnectionContext =  (PRX_CREATE_CONNECTION_CALLOUT_CONTEXT)
                                pParameterBlock->pCallOutContext;

    // save the two values below as the pCreateConnectionContext may be freed

    pCompletionContext = pCreateConnectionContext->pCompletionContext;
    pCompletionRoutine = pCreateConnectionContext->pCompletionRoutine;

    pWinningParameterBlock = NULL;

    KeAcquireSpinLock(&pCreateConnectionContext->SpinLock,&OldIrql);

    if (!pCreateConnectionContext->WinnerFound) {
        if (pParameterBlock->CallOutStatus == STATUS_SUCCESS) {
            // This instance of the call out was successful. Determine if this
            // instance is the winner.

            // In those cases in which the option was to select the best possible transport
            // the callout id of this instance must be less than the previously recorded
            // winner for the expectations to be revised.

            switch (pCreateConnectionContext->CreateOptions) {
            case RxCeSelectBestSuccessfulTransport:
                if (pParameterBlock->CallOutId != pCreateConnectionContext->BestPossibleWinner) {
                    break;
                }
                // lack of break intentional. The processing for the winner in the best transport case
                // and the first transport case is identical and have been folded together
            case RxCeSelectFirstSuccessfulTransport:
                {
                    pWinningParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                                             pParameterBlock;
                }
                break;

            case RxCeSelectAllSuccessfulTransports:
            default:
                ASSERT(!"RXCE connection create option not yet implemented");
                break;
            }
        } else {
            switch (pCreateConnectionContext->CreateOptions) {
            case RxCeSelectBestSuccessfulTransport:
                {
                    // This instance was not successful. This implies one of two things
                    // -- a previously completed transport can be the winner or we can
                    // adjust our expectations as regards the eventual winner.

                    if (pParameterBlock->CallOutId == pCreateConnectionContext->BestPossibleWinner) {
                        // The transport that was regarded as the best transport has reported
                        // failure. Revise our expectations as regards the best transport.

                        PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pTempParameterBlock;

                        pTempParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                                              pCreateConnectionContext->pCallOutParameterBlock;

                        while (pTempParameterBlock != NULL) {
                            PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pNextParameterBlock;

                            pNextParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                                                  pTempParameterBlock->pNextCallOutParameterBlock;

                            if (pTempParameterBlock->CallOutId < pCreateConnectionContext->BestPossibleWinner) {
                                ASSERT(pTempParameterBlock->CallOutStatus != STATUS_SUCCESS);
                            } else {
                                if (pNextParameterBlock != NULL) {
                                    if (pNextParameterBlock->CallOutStatus
                                         == STATUS_PENDING) {
                                        pCreateConnectionContext->BestPossibleWinner =
                                            pNextParameterBlock->CallOutId;
                                        break;
                                    } else if (pNextParameterBlock->CallOutStatus
                                         == STATUS_SUCCESS ) {
                                        pWinningParameterBlock = pNextParameterBlock;
                                        break;
                                    }
                                }
                            }

                            pTempParameterBlock = pNextParameterBlock;
                        }
                    }

                }
                break;

            case RxCeSelectAllSuccessfulTransports:
            case RxCeSelectFirstSuccessfulTransport:
            default:
                break;
            }
        }

        if (pWinningParameterBlock != NULL) {
            // Transfer the parameters associated with the winning parameter block
            // onto the original connection and prepare the call out parameter block
            // for cleanup.

            pCreateConnectionContext->WinnerFound = TRUE;
            pCreateConnectionContext->WinnerCallOutId = pWinningParameterBlock->CallOutId;

            pCompletionContext->Status = STATUS_SUCCESS;
            pCompletionContext->AddressIndex = pWinningParameterBlock->CallOutId;

            pCompletionContext->pConnection->pAddress =
                pWinningParameterBlock->Connection.pAddress;

            pCompletionContext->pVc->hEndpoint =
                pWinningParameterBlock->Vc.hEndpoint;

            pCompletionContext->pVc->pEndpointFileObject =
                pWinningParameterBlock->Vc.pEndpointFileObject;

            pCompletionContext->pVc->State = RXCE_VC_ACTIVE;

            pCompletionContext->pVc->pCleanUpEvent = pCreateConnectionContext->pCleanUpEvent;
            pCreateConnectionContext->pCleanUpEvent = NULL;

            pWinningParameterBlock->Vc.hEndpoint = INVALID_HANDLE_VALUE;
            pWinningParameterBlock->Vc.pEndpointFileObject = NULL;

            //DbgPrint("Remote address src %lx target %lx\n",
            //         pWinningParameterBlock->Connection.pConnectionInformation->RemoteAddress,
            //         pCompletionContext->pConnectionInformation->RemoteAddress);

            if (pCompletionContext->pConnectionInformation)
            {
                // Copy the buffer which may contain the DNS name returned back from TDI
                RtlCopyMemory(pCompletionContext->pConnectionInformation->RemoteAddress,
                              pWinningParameterBlock->Connection.pConnectionInformation->RemoteAddress,
                              pWinningParameterBlock->Connection.pConnectionInformation->RemoteAddressLength);
            }
                    
           //{
           //    PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)pWinningParameterBlock->Connection.pConnectionInformation->RemoteAddress;
           //    DbgPrint("Number of TA returned %d %lx\n",pTransportAddress->TAAddressCount,pTransportAddress->Address); 
           //}
        }
    }

    AllCallOutsInitiated = (pCreateConnectionContext->NumberOfCallOutsInitiated
                            == pCreateConnectionContext->NumberOfCallOuts);

    ((PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)pParameterBlock)->pConnectIrp = NULL;
    
    KeReleaseSpinLock(&pCreateConnectionContext->SpinLock,OldIrql);

    // The winning transport has been located. Cancel all the other requests.
    if (pWinningParameterBlock != NULL) {
        PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pTempParameterBlock, pNextTempBlock;

        pTempParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                              pCreateConnectionContext->pCallOutParameterBlock;

        RxLog(("Use paramblock %x %x\n", pTempParameterBlock, KeGetCurrentThread()));
        RxWmiLog(LOG,
                 RxCeCompleteConnectRequest,
                 LOGPTR(pTempParameterBlock));
        while (pTempParameterBlock != NULL) {

            pNextTempBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                                      pTempParameterBlock->pNextCallOutParameterBlock;

            if (pTempParameterBlock->CallOutStatus == STATUS_PENDING) {

                // get the next block becfore we do the cancel and set the
                // current guys status to cacncelled
                // Don't touch it after cancellation as he may have gone away
                // by then

                pTempParameterBlock->CallOutStatus = STATUS_CANCELLED;

                RxTdiCancelAsynchronousConnect(pTempParameterBlock);
            }

            pTempParameterBlock = pNextTempBlock;
        }
    }

    KeAcquireSpinLock(&pCreateConnectionContext->SpinLock,&OldIrql);
    
    AllCallOutsCompleted =
        (InterlockedIncrement(&pCreateConnectionContext->NumberOfCallOutsCompleted) ==
         pCreateConnectionContext->NumberOfCallOuts);

    if (AllCallOutsCompleted) {
        if (!pCreateConnectionContext->WinnerFound) {
            pCompletionContext->Status = pParameterBlock->CallOutStatus;
        }
    }

    if (AllCallOutsInitiated &&
        (AllCallOutsCompleted || pCreateConnectionContext->WinnerFound) &&
        !pCreateConnectionContext->CompletionRoutineInvoked) {
        InvokeCompletionRoutine = TRUE;
        pCreateConnectionContext->CompletionRoutineInvoked = TRUE;
    } 
    
    KeReleaseSpinLock(&pCreateConnectionContext->SpinLock,OldIrql);

    if ((Status == STATUS_SUCCESS) && AllCallOutsCompleted) {
        Status = RxPostToWorkerThread(
            RxFileSystemDeviceObject,
            HyperCriticalWorkQueue,
            &pCreateConnectionContext->WorkQueueItem,
            RxCeCleanupConnectCallOutContext,
            pCreateConnectionContext);
    }

    if (InvokeCompletionRoutine) {
        if ((IoGetCurrentProcess() == RxGetRDBSSProcess()) &&
            !RxShouldPostCompletion()) {
            (pCompletionRoutine)(pCompletionContext);
        } else {
            Status = RxPostToWorkerThread(
                RxFileSystemDeviceObject,
                CriticalWorkQueue,
                &pCompletionContext->WorkQueueItem,
                pCompletionRoutine,
                pCompletionContext);
        }
    }
    
    return Status;
}

NTSTATUS
RxCeBuildConnectionOverMultipleTransports(
    IN OUT PRDBSS_DEVICE_OBJECT         pMiniRedirectorDeviceObject,
    IN  RXCE_CONNECTION_CREATE_OPTIONS  CreateOptions,
    IN  ULONG                           NumberOfAddresses,
    IN  PRXCE_ADDRESS                   *pLocalAddressPointers,
    IN  PUNICODE_STRING                 pServerName,
    IN  PRXCE_CONNECTION_INFORMATION    pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext,
    IN  PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine,
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext)
/*++

Routine Description:

    This routine establishes a connection between a local RxCe address and a given remote address

Arguments:

    pMiniRedirectorDeviceObject - the mini redriector device object

    CreateOptions          - the create options

    NumberOfAddresses      - the number of local addresses(transports)

    pLocalAddressPointers  - the local address handles

    pServerName            - the name of the server ( for connection enumeration )

    pConnectionInformation - the connection information specifying the remote address.

    pHandler               - the connection handler

    pEventContext          - the connection handler context

    pLocalAddressHandleIndex - the index of the successful address/transport

    pConnectionHandle      - the handle to the newly created connection.

    pVcHandle              - the handle to the VC associated with the connection.

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;

    NTSTATUS Status;

    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT  pCallOutContext=NULL;
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameterBlocks=NULL;

    ULONG   NumberOfCallOuts,i;
    BOOLEAN InitiateCleanup = FALSE;
    BOOLEAN AsynchronousRequestRegistered = FALSE;

    KEVENT  CompletionEvent;
    BOOLEAN     fCompletionContextFreed = FALSE;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    pConnection = pCompletionContext->pConnection;
    pVc         = pCompletionContext->pVc;

    pCallOutContext = (PRX_CREATE_CONNECTION_CALLOUT_CONTEXT)
                      RxAllocatePoolWithTag(
                          NonPagedPool,
                          sizeof(RX_CREATE_CONNECTION_CALLOUT_CONTEXT),
                          RXCE_CONNECTION_POOLTAG);

    if (pCallOutContext != NULL) {
        // Allocate one more parameter block then the number of addresses.
        // This sentinel block is used in completing the connect request
        // after ensuring that all of them have been initiated. This
        // ensures that race conditions when a transport completes before
        // the requests have been initiated on some transports are avoided.

        pCallOutContext->pCleanUpEvent = (PKEVENT)RxAllocatePoolWithTag(
                                            NonPagedPool,
                                            sizeof(KEVENT),
                                            RXCE_CONNECTION_POOLTAG);

        pParameterBlocks = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                           RxAllocatePoolWithTag(
                               NonPagedPool,
                               sizeof(RX_CREATE_CONNECTION_PARAMETERS_BLOCK) *
                               (NumberOfAddresses + 1),
                               RXCE_CONNECTION_POOLTAG);
    }


    if ((pParameterBlocks == NULL) ||
        (pCallOutContext ==  NULL) ||
        (pCallOutContext->pCleanUpEvent == NULL)) {
        if (pCallOutContext != NULL) {
            if (pCallOutContext->pCleanUpEvent != NULL) {
                RxFreePool(pCallOutContext->pCleanUpEvent);
            }

            RxFreePool(pCallOutContext);
            pCallOutContext = NULL;
        }
        if (pParameterBlocks)
        {
            RxFreePool(pParameterBlocks);
            pParameterBlocks = NULL;
        }
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto bailout;
    }

    // Before initiating the callouts ensure that the asynchronous
    // request is registered. this will ensure that the mini
    // redirector cannot be unloaded till the asynchronous request
    // has been completed.
    Status = RxRegisterAsynchronousRequest(pMiniRedirectorDeviceObject);
    
    if (Status == STATUS_SUCCESS) {
        AsynchronousRequestRegistered = TRUE;
    }

    KeInitializeEvent(
        pCallOutContext->pCleanUpEvent,
        SynchronizationEvent,
        FALSE);

    if (Status == STATUS_SUCCESS) {
        Status = RxCepInitializeConnection(
                     pConnection,
                     NULL,
                     pConnectionInformation,
                     pHandler,
                     pEventContext);

        if (Status == STATUS_SUCCESS) {
            Status = RxCepInitializeVC(
                         pVc,
                         pConnection);
        }
    }

    if (Status == STATUS_SUCCESS) {
        try {
            NumberOfCallOuts = 0;

            // Fill up each of the parameter blocks
            for (i = 0; i < NumberOfAddresses; i++) {
                PRXCE_TRANSPORT pTransport;
                PRXCE_ADDRESS pAddress;

                pAddress = pLocalAddressPointers[i];
                pTransport = pAddress->pTransport;

                if (RxCeIsAddressValid(pAddress) &&
                    RxCeIsTransportValid(pTransport)) {

                    Status = RxCepInitializeConnection(
                                 &pParameterBlocks[NumberOfCallOuts].Connection,
                                 pAddress,
                                 pConnectionInformation,
                                 NULL,
                                 NULL);

                    if (Status == STATUS_SUCCESS) {
                        Status = RxCepInitializeVC(
                                     &pParameterBlocks[NumberOfCallOuts].Vc,
                                     &pParameterBlocks[NumberOfCallOuts].Connection);

                        if (Status != STATUS_SUCCESS) {
                            RxCeTearDownConnection(
                                &pParameterBlocks[NumberOfCallOuts].Connection);
                        }
                    }

                    if (Status == STATUS_SUCCESS) {
                        pParameterBlocks[NumberOfCallOuts].pConnectIrp = NULL;
                        pParameterBlocks[NumberOfCallOuts].IrpRefCount = NULL;
                        pParameterBlocks[NumberOfCallOuts].CallOutId = i;
                        pParameterBlocks[NumberOfCallOuts].pCallOutContext =
                            (PRX_CALLOUT_CONTEXT)pCallOutContext;
                        pParameterBlocks[NumberOfCallOuts].CallOutStatus = STATUS_PENDING;
                        NumberOfCallOuts++;
                    }
                }
            }

            if (NumberOfCallOuts > 0) {
                NTSTATUS LocalStatus = STATUS_SUCCESS;

                // Increment the number of callouts for the sentinel callout to
                // ensure that all initiation is completed before we complete
                // the connect request. Notice that the sentinel is not the very
                // last one but the one after the number of callouts.
                NumberOfCallOuts++;

                // Also exclude the sentinel from the list
                for (i = 0;  i < NumberOfCallOuts - 1; i++) {
                    pParameterBlocks[i].pNextCallOutParameterBlock =
                        (PRX_CALLOUT_PARAMETERS_BLOCK)&pParameterBlocks[i + 1];
                }

                pParameterBlocks[NumberOfCallOuts - 2].pNextCallOutParameterBlock = NULL;
                pParameterBlocks[NumberOfCallOuts - 1].pNextCallOutParameterBlock = NULL;

                // Initialize the callout context.
                pCallOutContext->CreateOptions   = CreateOptions;
                pCallOutContext->WinnerCallOutId = NumberOfCallOuts + 1;
                pCallOutContext->BestPossibleWinner = 0;
                pCallOutContext->NumberOfCallOuts = NumberOfCallOuts;
                pCallOutContext->NumberOfCallOutsInitiated = 0;
                pCallOutContext->NumberOfCallOutsCompleted = 0;
                pCallOutContext->pRxCallOutInitiation = RxCeInitiateConnectRequest;
                pCallOutContext->pRxCallOutCompletion = RxCeCompleteConnectRequest;
                pCallOutContext->WinnerFound = FALSE;
                pCallOutContext->CompletionRoutineInvoked = FALSE;
                pCallOutContext->pCallOutParameterBlock =
                    (PRX_CALLOUT_PARAMETERS_BLOCK)pParameterBlocks;

                pCompletionContext->AddressIndex =  NumberOfCallOuts + 1;

                pCallOutContext->pCompletionContext = pCompletionContext;
                pCallOutContext->pCompletionRoutine = pCompletionRoutine;
                pCallOutContext->pConnectionContext = pCompletionContext->pVc;
                 
                pCallOutContext->pRxDeviceObject = pMiniRedirectorDeviceObject;

                KeInitializeSpinLock(
                    &pCallOutContext->SpinLock);

                // Exclude the sentinel from the chain of parameter blocks
                for (i = 0; i < NumberOfCallOuts - 1; i++) {
                    pCallOutContext->pRxCallOutInitiation(
                                 (PRX_CALLOUT_PARAMETERS_BLOCK)&pParameterBlocks[i]);
                }

                pParameterBlocks[NumberOfCallOuts - 1].pConnectIrp = NULL;
                pParameterBlocks[NumberOfCallOuts - 1].CallOutId = NumberOfCallOuts;
                pParameterBlocks[NumberOfCallOuts - 1].pCallOutContext =
                    (PRX_CALLOUT_CONTEXT)pCallOutContext;
                pParameterBlocks[NumberOfCallOuts - 1].CallOutStatus = STATUS_NETWORK_UNREACHABLE;

                pCallOutContext->NumberOfCallOutsInitiated = NumberOfCallOuts;


                if((LocalStatus = RxCeCompleteConnectRequest(
                    (PRX_CALLOUT_PARAMETERS_BLOCK)&pParameterBlocks[NumberOfCallOuts - 1])) != STATUS_SUCCESS)
                {
                    InitiateCleanup = TRUE;
                    Status = LocalStatus;
                    RxLog(("LocalStatus %x\n", LocalStatus));
                    RxWmiLog(LOG,
                             RxCeBuildConnectionOverMultipleTransports_1,
                             LOGULONG(LocalStatus));
                }
                else
                {
                    Status = STATUS_PENDING;
                }

                fCompletionContextFreed = TRUE;
            } else {
                InitiateCleanup = TRUE;
                Status = STATUS_INVALID_HANDLE;
            }
        } finally {
            if (AbnormalTermination()) {
                InitiateCleanup = TRUE;
                Status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    if (InitiateCleanup) {
        RxFreePool(pParameterBlocks);
        RxFreePool(pCallOutContext);
    }

    if (Status != STATUS_PENDING) {
        NTSTATUS LocalStatus;

        ASSERT(Status != STATUS_SUCCESS);

        LocalStatus = RxCeTearDownVC(pVc);
        ASSERT(LocalStatus == STATUS_SUCCESS);

        LocalStatus = RxCeTearDownConnection(pConnection);
        ASSERT(LocalStatus == STATUS_SUCCESS);

        if (!fCompletionContextFreed)
        {
            pCompletionContext->Status = Status;

            if ((IoGetCurrentProcess() == RxGetRDBSSProcess()) &&
                !RxShouldPostCompletion()) {
                (pCompletionRoutine)(pCompletionContext);
            } else {
                LocalStatus = RxPostToWorkerThread(
                    RxFileSystemDeviceObject,
                    CriticalWorkQueue,
                    &pCompletionContext->WorkQueueItem,
                    pCompletionRoutine,
                    pCompletionContext);

            }
        }

        if (LocalStatus == STATUS_SUCCESS)
        {
            if (AsynchronousRequestRegistered) {
                RxDeregisterAsynchronousRequest(pMiniRedirectorDeviceObject);
            }

            Status = STATUS_PENDING;
        }
        else
        {
            Status = LocalStatus;
            RxLog(("RxCeBldOvrMult: Failed Status %lx\n", Status));
            RxWmiLog(LOG,
                     RxCeBuildConnectionOverMultipleTransports_2,
                     LOGULONG(Status));
        }
    }
bailout:

    return Status;
}

NTSTATUS
RxCeTearDownConnection(
    IN PRXCE_CONNECTION pConnection)
/*++

Routine Description:

    This routine tears down a given connection

Arguments:

    pConnection - the connection to be torn down

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_SUCCESS;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeTearDownConnection);

    try {
        if (RxCeIsConnectionValid(pConnection)) {
            if (pConnection->pConnectionInformation != NULL) {
                if (pConnection->pConnectionInformation->UserDataLength > 0) {
                    RxFreePool(pConnection->pConnectionInformation->UserData);
                }

                if (pConnection->pConnectionInformation->RemoteAddressLength > 0) {
                    RxFreePool(pConnection->pConnectionInformation->RemoteAddress);
                }

                if (pConnection->pConnectionInformation->OptionsLength > 0) {
                    RxFreePool(pConnection->pConnectionInformation->Options);
                }

                RxFreePool(pConnection->pConnectionInformation);
            }

            // free the memory allocated for the handler
            if (pConnection->pHandler != NULL) {
                RxFreePool(pConnection->pHandler);
            }

            RtlZeroMemory(
                pConnection,
                sizeof(RXCE_CONNECTION));
        }

    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeTearDownConnection: C: %lx\n",pConnection));
            RxWmiLog(LOG,
                     RxCeTearDownConnection,
                     LOGPTR(pConnection));
        }
    }

    return Status;
}

NTSTATUS
RxCeCancelConnectRequest(
    IN  PRXCE_ADDRESS                pLocalAddress,
    IN  PUNICODE_STRING              pServerName,
    IN  PRXCE_CONNECTION_INFORMATION pConnectionInformation)
/*++

Routine Description:

    This routine cancels a previously issued connection request.

Arguments:

    pConnectionInformation - the connection information pertaining to a previsouly issued
                             connection request

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
RxCeQueryInformation(
    IN PRXCE_VC                          pVc,
    IN RXCE_CONNECTION_INFORMATION_CLASS InformationClass,
    OUT PVOID                            pInformation,
    IN ULONG                             Length)
/*++

Routine Description:

    This routine queries information pertaining to a connection

Arguments:

    pConnection - the connection for which the information is desired

    InformationClass - the desired information class.

    pInformation - the buffer for returning the information

    Length       - the length of the buffer.

Return Value:

    STATUS_SUCCESS if successfull.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    PRXCE_TRANSPORT  pTransport  = NULL;
    PRXCE_ADDRESS    pAddress    = NULL;
    PRXCE_CONNECTION pConnection = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeQueryInformation);

    try {
        pConnection = pVc->pConnection;
        pAddress = pConnection->pAddress;
        pTransport = pAddress->pTransport;

        if (RxCeIsVcValid(pVc)                 &&
            RxCeIsConnectionValid(pConnection) &&
            RxCeIsAddressValid(pAddress)       &&
            RxCeIsTransportValid(pTransport)) {

            switch (InformationClass) {
            case RxCeTransportProviderInformation:
                if (sizeof(RXCE_TRANSPORT_PROVIDER_INFO) <= Length) {
                    // Copy the necessary provider information.
                    RtlCopyMemory(
                        pInformation,
                        pTransport->pProviderInfo,
                        sizeof(RXCE_TRANSPORT_PROVIDER_INFO));

                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }
                break;

            case RxCeConnectionInformation:
                if (sizeof(RXCE_CONNECTION_INFORMATION) <= Length) {
                    RtlCopyMemory(
                        pInformation,
                        pConnection->pConnectionInformation,
                        sizeof(RXCE_CONNECTION_INFORMATION));

                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }
                break;

            case RxCeConnectionEndpointInformation:
                if (sizeof(RXCE_CONNECTION_INFO) <= Length) {
                    Status = RxTdiQueryInformation(
                                 pTransport,
                                 pAddress,
                                 pConnection,
                                 pVc,
                                 RXCE_QUERY_CONNECTION_INFO,
                                 pInformation,
                                 Length);
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }
                break;

            case RxCeRemoteAddressInformation:
                {
                    Status = RxTdiQueryInformation(
                                 pTransport,
                                 pAddress,
                                 pConnection,
                                 pVc,
                                 RXCE_QUERY_ADDRESS_INFO,
                                 pInformation,
                                 Length);
                }
                break;

            default:
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxcemm.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxcemm.h

Abstract:

    This module contains the memory management functions for RxCe entities.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:


--*/

#include <rxcep.h>

PRXCEDB_TRANSPORT_ENTRY RxCeDbAllocateTransportEntry()
/*++

Routine Description:

    This routine allocates and initializes a RXCEDB_TRANSPORT_ENTRY structure.

--*/
{
   PRXCE_TRANSPORT pTransport = (PRXCE_TRANSPORT)_RxCeAllocate(
                                                      sizeof(RXCEDB_TRANSPORT_ENTRY));

   if (pTransportEntry != NULL) {
      // Initialize the object header
      RxCeDbInitializeObjectHeader();
   }

   return pTransportEntry;
}

PRXCEDB_ADDRESS_ENTRY RxCeDbAllocateAddressEntry()
/*++

Routine Description:

    This routine allocates and initializes a RXCEDB_ADDRESS_ENTRY structure.

--*/
{
   PRXCEDB_ADDRESS_ENTRY pAddressEntry = (PRXCEDB_ADDRESS_ENTRY)_RxCeAllocate(
                                                         sizeof(RXCEDB_ADDRESS_ENTRY));

   if (pAddressEntry != NULL) {
      RxCeDbInitializeObjectHeader();
   }

   return pAddressEntry;
}

PRXCEDB_CONNECTION_ENTRY RxCeAllocateConnectionEntry()
/*++

Routine Description:

    This routine allocates and initializes a RXCEDB_CONNECTION_ENTRY structure.

--*/
{
   PRXCEDB_CONNECTION_ENTRY pConnection = (PRXCE_CONNECTION)_RxCeAllocate(
                                                         sizeof(RXCE_CONNECTION),
                                                         &s_NoOfConnectionsAllocated);

   if (pConnection != NULL) {
      InitializeStructHeader(pConnection,,sizeof(RXCE_CONNECTION));
   }

   return pConnection;
}

PRXCE_VC RxCeAllocateVc()
/*++

Routine Description:

    This routine allocates and initializes a RXCE_VC structure.

--*/
{
   PRXCE_VC pVc = (PRXCE_VC)_RxCeAllocate(
                                 sizeof(RXCE_VC),
                                 &s_NoOfVcsAllocated);

   if (pVc != NULL) {
      InitializeStructHeader(pVc,,sizeof(RXCE_VC));
   }

   return pVc;
}

VOID RxCeFreeTransport(PRXCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine frees the memory allocated for a  RXCE_TRANSPORT structure.

Arguments:

    pTransport - the RXCE_TRANSPORT instance to be freed.

--*/
{
   _RxCeFree(pTransport,&s_NoOfTransportsFreed);
}

VOID RxCeFreeAddress(PRXCE_ADDRESS pAddress)
/*++

Routine Description:

    This routine frees the memory allocated for a RXCE_ADDRESS structure.

Arguments:

    pAddress - the RXCE_ADDRESS instance to be freed.

--*/
{
   _RxCeFree(pAddress,&s_NoOfAddressesFreed);
}

VOID RxCeFreeConnection(PRXCE_CONNECTION pConnection)
/*++

Routine Description:

    This routine frees the memory allocated for a RXCE_CONNECTION structure.

Arguments:

    pConnection - the RXCE_CONNECTION instance to be freed.

--*/
{
   _RxCeFree(pConnection,&s_NoOfConnectionsFreed);
}

VOID RxCeFreeVc(PRXCE_VC pVc)
/*++

Routine Description:

    This routine frees the memory allocated for a RXCE_VC structure.

Arguments:

    pVc - the RXCE_VC instance to be freed.

--*/
{
   _RxCeFree(pVc,&s_NoOfVcsFreed);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\resrcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the Rx Resource acquisition routines

Author:

    Joe Linn    [JoeLi]    22-Mar-1995

Revision History:

    Balan Sethu Raman [SethuR] 7-June-95

      Modified return value of resource acquistion routines to RXSTATUS to incorporate
      aborts of cancelled requests.

    Balan Sethu Raman [SethuR] 8-Nov-95

      Unified FCB resource acquistion routines and incorporated the two step process
      for handling change buffering state requests in progress.

--*/

#include "precomp.h"
#pragma hdrstop

//
// no special bug check id for this module

#define BugCheckFileId                   (0)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_RESRCSUP)

#ifdef RDBSS_TRACKER
#define TRACKER_Doit(XXX__) XXX__
#define TRACKER_ONLY_DECL(XXX__) XXX__

VOID RxTrackerUpdateHistory(
    PRX_CONTEXT pRxContext,
    IN OUT PMRX_FCB MrxFcb,
    ULONG Operation
    RX_FCBTRACKER_PARAMS
    )
{
    PFCB pFcb = (PFCB)MrxFcb;
    ULONG i;
    RX_FCBTRACKER_CASES TrackerType;

    //boy this is some great code!
    if (pRxContext == NULL) {
        TrackerType = (RX_FCBTRACKER_CASE_NULLCONTEXT);
    } else if (pRxContext == CHANGE_BUFFERING_STATE_CONTEXT) {
        TrackerType = (RX_FCBTRACKER_CASE_CBS_CONTEXT);
    }  else if (pRxContext == CHANGE_BUFFERING_STATE_CONTEXT_WAIT) {
        TrackerType = (RX_FCBTRACKER_CASE_CBS_WAIT_CONTEXT);
    }  else {
        ASSERT(NodeType(pRxContext) == RDBSS_NTC_RX_CONTEXT);
        TrackerType = (RX_FCBTRACKER_CASE_NORMAL);
    }

    if (pFcb!=NULL) {
        ASSERT(NodeTypeIsFcb(pFcb));
        if (Operation == 'aaaa') {
            pFcb->FcbAcquires[TrackerType]++;
        } else {
            pFcb->FcbReleases[TrackerType]++;
        }
    }

    if (TrackerType != RX_FCBTRACKER_CASE_NORMAL) {
        return;
    }

    if (Operation == 'aaaa') {
        InterlockedIncrement(&pRxContext->AcquireReleaseFcbTrackerX);
    } else {
        InterlockedDecrement(&pRxContext->AcquireReleaseFcbTrackerX);
    }

    i = InterlockedIncrement(&pRxContext->TrackerHistoryPointer) - 1;
    if (i < RDBSS_TRACKER_HISTORY_SIZE) {
        pRxContext->TrackerHistory[i].AcquireRelease = Operation;
        pRxContext->TrackerHistory[i].LineNumber = (USHORT)LineNumber;
        pRxContext->TrackerHistory[i].FileName = FileName;
        pRxContext->TrackerHistory[i].SavedTrackerValue = (USHORT)(pRxContext->AcquireReleaseFcbTrackerX);
        pRxContext->TrackerHistory[i].Flags = (ULONG)(pRxContext->Flags);
    }

    ASSERT(pRxContext->AcquireReleaseFcbTrackerX>=0);

}
#else

#define TRACKER_Doit(XXX__)
#define TRACKER_ONLY_DECL(XXX__)

#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxAcquireExclusiveFcbResourceInMRx)
#pragma alloc_text(PAGE, RxAcquireSharedFcbResourceInMRx)
#pragma alloc_text(PAGE, RxReleaseFcbResourceInMRx)
#pragma alloc_text(PAGE, __RxAcquireFcb)
#pragma alloc_text(PAGE, RxAcquireFcbForLazyWrite)
#pragma alloc_text(PAGE, RxAcquireFcbForReadAhead)
#pragma alloc_text(PAGE, RxNoOpAcquire)
#pragma alloc_text(PAGE, RxNoOpRelease)
#pragma alloc_text(PAGE, RxReleaseFcbFromLazyWrite)
#pragma alloc_text(PAGE, RxReleaseFcbFromReadAhead)
#pragma alloc_text(PAGE, RxVerifyOperationIsLegal)
#pragma alloc_text(PAGE, RxAcquireFileForNtCreateSection)
#pragma alloc_text(PAGE, RxReleaseFileForNtCreateSection)
#endif

NTSTATUS
RxAcquireExclusiveFcbResourceInMRx(
    PMRX_FCB pFcb)
{
    return RxAcquireExclusiveFcb(NULL,pFcb);
}

NTSTATUS
RxAcquireSharedFcbResourceInMRx(
    PMRX_FCB pFcb)
{
    return RxAcquireSharedFcb(NULL,pFcb);
}

VOID
RxReleaseFcbResourceInMRx(
    PMRX_FCB pFcb)
{
    RxReleaseFcb(NULL,pFcb);
}

NTSTATUS
__RxAcquireFcb(
    IN OUT PMRX_FCB MrxFcb,
    IN PRX_CONTEXT   pRxContext,
    IN ULONG         Mode
    RX_FCBTRACKER_PARAMS
    )
/*++

Routine Description:

    This routine acquires the Fcb in the specified mode and ensures that the desired
    operation is legal. If it is not legal the resource is released and the
    appropriate error code is returned.

Arguments:

    pFcb      - the FCB

    RxContext - supplies the context of the operation for special treatement
                particularly of async, noncached writes. if NULL, you don't do
                the special treatment.

    Mode      - the mode in which the FCB is to be acquired.

Return Value:

    STATUS_SUCCESS          -- the Fcb was acquired
    STATUS_LOCK_NOT_GRANTED -- the resource was not acquired
    STATUS_CANCELLED        -- the associated RxContext was cancelled.

Notes:

    There are three kinds of resource acquistion patterns folded into this routine.
    These are all dependent upon the context passed in.

    1) When the context parameter is NULL the resource acquistion routines wait for the
    the FCB resource to be free, i.e., this routine does not return control till the
    resource has been accquired.

    2) When the context is CHANGE_BUFFERING_STATE_CONTEXT the resource acquistion routines
    do not wait for the resource to become free. The control is returned if the resource is not
    available immmediately.

    2) When the context is CHANGE_BUFFERING_STATE_CONTEXT_WAIT the resource acquistion routines
    wait for the resource to become free but bypass the wait for the buffering state change

    3) When the context parameter represents a valid context the behaviour is dictated
    by the flags associated with the context. If the context was cancelled while
    waiting the control is returned immediately with the appropriate erroc code
    (STATUS_CANCELLED). If not the waiting behaviour is dictated by the wait flag in
    the context.

--*/
{
    PFCB pFcb = (PFCB)MrxFcb;
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN  ResourceAcquired;
    BOOLEAN  UncachedAsyncWrite;
    BOOLEAN  Wait;
    BOOLEAN  fValidContext = FALSE;
    BOOLEAN  fRecursiveAcquire;
    BOOLEAN  fChangeBufferingStateContext;


   PAGED_CODE();

   fChangeBufferingStateContext = (pRxContext == CHANGE_BUFFERING_STATE_CONTEXT) ||
                                  (pRxContext == CHANGE_BUFFERING_STATE_CONTEXT_WAIT);

   fRecursiveAcquire = RxIsFcbAcquiredExclusive(pFcb) || (RxIsFcbAcquiredShared(pFcb) > 0);

   if (!fRecursiveAcquire &&
       !fChangeBufferingStateContext) {
      // Ensure that no change buffering requests are currently being processed
      if (FlagOn(pFcb->FcbState,FCB_STATE_BUFFERING_STATE_CHANGE_PENDING)) {
         BOOLEAN WaitForChangeBufferingStateProcessing;

         // A buffering change state request is pending which gets priority
         // over all other FCB resource acquistion requests. Hold this request
         // till the buffering state change request has been completed.

         RxAcquireSerializationMutex();

         WaitForChangeBufferingStateProcessing =
                  BooleanFlagOn(pFcb->FcbState,FCB_STATE_BUFFERING_STATE_CHANGE_PENDING);

         RxReleaseSerializationMutex();

         if (WaitForChangeBufferingStateProcessing) {
            RxLog(("_RxAcquireFcb CBS wait %lx\n",pFcb));
            RxWmiLog(LOG,
                     RxAcquireFcb_1,
                     LOGPTR(pFcb));
            
                     ASSERT(pFcb->pBufferingStateChangeCompletedEvent != NULL);
            KeWaitForSingleObject(pFcb->pBufferingStateChangeCompletedEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  (PLARGE_INTEGER) NULL );
            RxLog(("_RxAcquireFcb CBS wait over %lx\n",pFcb));
            RxWmiLog(LOG,
                     RxAcquireFcb_2,
                     LOGPTR(pFcb));
         }
      }
   }

   // Set up the parameters for acquiring the resource.
   if (fChangeBufferingStateContext) {
      // An acquisition operation initiated for changing the buffering state will
      // not wait.
      Wait               = (pRxContext == CHANGE_BUFFERING_STATE_CONTEXT_WAIT);
      UncachedAsyncWrite = FALSE;
   } else if (pRxContext == NULL) {
      Wait               = TRUE;
      UncachedAsyncWrite = FALSE;
   } else {
      fValidContext = TRUE;

      Wait = BooleanFlagOn(pRxContext->Flags, RX_CONTEXT_FLAG_WAIT);

      UncachedAsyncWrite = (pRxContext->MajorFunction == IRP_MJ_WRITE) &&
                           BooleanFlagOn(pRxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION) &&
                           (FlagOn(pRxContext->CurrentIrp->Flags,IRP_NOCACHE) ||
                            !RxWriteCacheingAllowed(pFcb,((PFOBX)(pRxContext->pFobx))->SrvOpen));

      Status = (BooleanFlagOn(pRxContext->Flags, RX_CONTEXT_FLAG_CANCELLED))
                ? STATUS_CANCELLED
                : STATUS_SUCCESS;
   }

   if (Status == STATUS_SUCCESS) {
      do {
         Status = STATUS_LOCK_NOT_GRANTED;

         switch (Mode) {
         case FCB_MODE_EXCLUSIVE:
            ResourceAcquired = ExAcquireResourceExclusiveLite(pFcb->Header.Resource, Wait);
            break;
         case FCB_MODE_SHARED:
            ResourceAcquired = ExAcquireResourceSharedLite(pFcb->Header.Resource, Wait);
            break;
         case FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE:
            ResourceAcquired = ExAcquireSharedWaitForExclusive(pFcb->Header.Resource, Wait);
            break;
         case FCB_MODE_SHARED_STARVE_EXCLUSIVE:
            ResourceAcquired = ExAcquireSharedStarveExclusive(pFcb->Header.Resource, Wait);
            break;
         default:
            ASSERT(!"Valid Mode for acquiring FCB resource");
            ResourceAcquired = FALSE;
            break;
         }

         if (ResourceAcquired) {
            Status = STATUS_SUCCESS;

            // If the resource was acquired and it is an async. uncached write operation
            // if the number of outstanding writes operations are greater than zero and there
            // are outstanding waiters,

            ASSERT_CORRECT_FCB_STRUCTURE(pFcb);

            if ((pFcb->NonPaged->OutstandingAsyncWrites != 0) &&
                (!UncachedAsyncWrite ||
                 (pFcb->Header.Resource->NumberOfSharedWaiters != 0) ||
                 (pFcb->Header.Resource->NumberOfExclusiveWaiters != 0)) ) {

               KeWaitForSingleObject( pFcb->NonPaged->OutstandingAsyncEvent,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );

               ASSERT_CORRECT_FCB_STRUCTURE(pFcb);

               RxReleaseFcb( NULL, pFcb );    //this is not a contextful release;
#ifdef RDBSS_TRACKER
               //in fact, this doesn't count as a release at all; dec the count
               pFcb->FcbReleases[RX_FCBTRACKER_CASE_NULLCONTEXT]--;
#endif
               ResourceAcquired = FALSE;

               if (fValidContext) {
                   ASSERT((NodeType(pRxContext) == RDBSS_NTC_RX_CONTEXT));
                   // if the context is still valid, i.e., it has not been cancelled
                   Status = (BooleanFlagOn(pRxContext->Flags, RX_CONTEXT_FLAG_CANCELLED))
                            ? STATUS_CANCELLED
                            : STATUS_SUCCESS;
               }
            }
         }
      } while (!ResourceAcquired && (Status == STATUS_SUCCESS));

      if (ResourceAcquired &&
          fValidContext &&
          !FlagOn(pRxContext->Flags,RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK)) {

         try {

             RxVerifyOperationIsLegal( pRxContext );

         } finally {
             if ( AbnormalTermination() ) {
                ExReleaseResourceLite(pFcb->Header.Resource);
                Status = STATUS_LOCK_NOT_GRANTED;
             }
         }

      }
   }

   if (Status == STATUS_SUCCESS) {
       RxTrackerUpdateHistory(pRxContext,MrxFcb,'aaaa',LineNumber,FileName,SerialNumber);
   }

   return Status;
}

VOID
__RxReleaseFcb(
    IN PRX_CONTEXT pRxContext,
    IN OUT PMRX_FCB MrxFcb
    RX_FCBTRACKER_PARAMS
    )
{
    PFCB pFcb = (PFCB)MrxFcb;
    BOOLEAN ChangeBufferingStateRequestsPending;
    BOOLEAN ResourceExclusivelyOwned;

    RxAcquireSerializationMutex();

    ChangeBufferingStateRequestsPending =  BooleanFlagOn(pFcb->FcbState,FCB_STATE_BUFFERING_STATE_CHANGE_PENDING);
    ResourceExclusivelyOwned = RxIsResourceOwnershipStateExclusive(pFcb->Header.Resource);

    if (!ChangeBufferingStateRequestsPending) {
        RxTrackerUpdateHistory(pRxContext,MrxFcb,'rrrr',LineNumber,FileName,SerialNumber);
        ExReleaseResourceLite( pFcb->Header.Resource );
    } else if (!ResourceExclusivelyOwned) {
       RxTrackerUpdateHistory(pRxContext,MrxFcb,'rrr0',LineNumber,FileName,SerialNumber);
       ExReleaseResourceLite( pFcb->Header.Resource );
    }

    RxReleaseSerializationMutex();

    if (ChangeBufferingStateRequestsPending) {
       if (ResourceExclusivelyOwned) {
          ASSERT(RxIsFcbAcquiredExclusive(pFcb));

          // If there are any buffering state change requests process them.
          RxProcessFcbChangeBufferingStateRequest(pFcb);

          RxTrackerUpdateHistory(pRxContext,MrxFcb,'rrr1',LineNumber,FileName,SerialNumber);
          ExReleaseResourceLite( pFcb->Header.Resource );
       }
    }
}


VOID
__RxReleaseFcbForThread(
    IN PRX_CONTEXT      pRxContext,
    IN OUT PMRX_FCB MrxFcb,
    IN ERESOURCE_THREAD ResourceThreadId
    RX_FCBTRACKER_PARAMS
    )
{
    PFCB pFcb = (PFCB)MrxFcb;
    BOOLEAN ChangeBufferingStateRequestsPending;
    BOOLEAN ResourceExclusivelyOwned;

    RxAcquireSerializationMutex();

    ChangeBufferingStateRequestsPending =  BooleanFlagOn(pFcb->FcbState,FCB_STATE_BUFFERING_STATE_CHANGE_PENDING);
    ResourceExclusivelyOwned = RxIsResourceOwnershipStateExclusive(pFcb->Header.Resource);

    if (!ChangeBufferingStateRequestsPending) {
       RxTrackerUpdateHistory(pRxContext,MrxFcb,'rrtt',LineNumber,FileName,SerialNumber);
       ExReleaseResourceForThreadLite( pFcb->Header.Resource, ResourceThreadId );
    } else if (!ResourceExclusivelyOwned) {
       RxTrackerUpdateHistory(pRxContext,MrxFcb,'rrt0',LineNumber,FileName,SerialNumber);
       ExReleaseResourceForThreadLite( pFcb->Header.Resource, ResourceThreadId );
    }

    RxReleaseSerializationMutex();


    if (ChangeBufferingStateRequestsPending) {
       if (ResourceExclusivelyOwned) {
          // If there are any buffering state change requests process them.
          RxTrackerUpdateHistory(pRxContext,MrxFcb,'rrt1',LineNumber,FileName,SerialNumber);

          RxProcessFcbChangeBufferingStateRequest(pFcb);

          ExReleaseResourceForThreadLite( pFcb->Header.Resource, ResourceThreadId );
       }
    }
}

BOOLEAN
RxAcquireFcbForLazyWrite (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )
/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing lazy writes to the file.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Fcb has been acquired

--*/
{
    BOOLEAN AcquiredFile;
    //
    // We assume the Lazy Writer only acquires this Fcb once.
    // Therefore, it should be guaranteed that this flag is currently
    // clear (the ASSERT), and then we will set this flag, to insure
    // that the Lazy Writer will never try to advance Valid Data, and
    // also not deadlock by trying to get the Fcb exclusive.
    //


    PAGED_CODE();

    ASSERT( NodeType(((PFCB)Fcb)) == RDBSS_NTC_FCB );
    ASSERT_CORRECT_FCB_STRUCTURE(((PFCB)Fcb));
    ASSERT( ((PFCB)Fcb)->Specific.Fcb.LazyWriteThread == NULL );

    AcquiredFile = RxAcquirePagingIoResourceShared(Fcb, Wait, NULL);

    if (AcquiredFile) {

        ((PFCB)Fcb)->Specific.Fcb.LazyWriteThread = PsGetCurrentThread();

        //
        //  This is a kludge because Cc is really the top level.  When it
        //  enters the file system, we will think it is a resursive call
        //  and complete the request with hard errors or verify.  It will
        //  then have to deal with them, somehow....
        //

        ASSERT(RxIsThisTheTopLevelIrp(NULL));
        AcquiredFile = RxTryToBecomeTheTopLevelIrp( 
                           NULL,
                           (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP,
                           ((PFCB)Fcb)->RxDeviceObject,
                           TRUE ); //force

        if (!AcquiredFile) {
            RxReleasePagingIoResource(Fcb,NULL);
            ((PFCB)Fcb)->Specific.Fcb.LazyWriteThread = NULL;
        }
    }

    return AcquiredFile;
}

VOID
RxReleaseFcbFromLazyWrite (
    IN PVOID Fcb
    )
/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    performing lazy writes to the file.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/
{
    PAGED_CODE();

    ASSERT( NodeType(((PFCB)Fcb)) == RDBSS_NTC_FCB );
    ASSERT_CORRECT_FCB_STRUCTURE(((PFCB)Fcb));

    ((PFCB)Fcb)->Specific.Fcb.LazyWriteThread = NULL;

    //
    //  Clear the kludge at this point.
    //

    //  NTBUG #61902 this is a paged pool leak if the test fails....in fastfat, they assert
    //  that the condition is true.
    
    if(RxGetTopIrpIfRdbssIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP){
        RxUnwindTopLevelIrp( NULL );
    }

    RxReleasePagingIoResource(Fcb,NULL);
    return;
}


BOOLEAN
RxAcquireFcbForReadAhead (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )
/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing read ahead to the file.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Fcb has been acquired

--*/
{
    BOOLEAN AcquiredFile;

    PAGED_CODE();

    ASSERT_CORRECT_FCB_STRUCTURE(((PFCB)Fcb));
    //
    //  We acquire the normal file resource shared here to synchronize
    //  correctly with purges.
    //

    if (!ExAcquireResourceSharedLite( ((PFCB)Fcb)->Header.Resource,
                                  Wait )) {

        return FALSE;
    }

    //
    //  This is a kludge because Cc is really the top level.  We it
    //  enters the file system, we will think it is a resursive call
    //  and complete the request with hard errors or verify.  It will
    //  have to deal with them, somehow....
    //

    ASSERT(RxIsThisTheTopLevelIrp(NULL));
    AcquiredFile = RxTryToBecomeTheTopLevelIrp( 
                       NULL,
                       (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP,
                       ((PFCB)Fcb)->RxDeviceObject,
                       TRUE ); //force

    if (!AcquiredFile) {
        ExReleaseResourceLite( ((PFCB)Fcb)->Header.Resource );
    }

    return AcquiredFile;
}


VOID
RxReleaseFcbFromReadAhead (
    IN PVOID Fcb
    )
/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    read ahead.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/
{
    PAGED_CODE();

    ASSERT_CORRECT_FCB_STRUCTURE(((PFCB)Fcb));
    //
    //  Clear the kludge at this point.
    //

    ASSERT(RxGetTopIrpIfRdbssIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);
    RxUnwindTopLevelIrp( NULL );

    ExReleaseResourceLite( ((PFCB)Fcb)->Header.Resource );

    return;
}


BOOLEAN
RxNoOpAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Dcb/Vcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    TRUE

--*/
{
    BOOLEAN AcquiredFile;

    UNREFERENCED_PARAMETER( Wait );

    PAGED_CODE();

    //
    //  This is a kludge because Cc is really the top level.  We it
    //  enters the file system, we will think it is a resursive call
    //  and complete the request with hard errors or verify.  It will
    //  have to deal with them, somehow....
    //

    ASSERT(RxIsThisTheTopLevelIrp(NULL));
    AcquiredFile = RxTryToBecomeTheTopLevelIrp( 
                       NULL,
                       (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP,
                       ((PFCB)Fcb)->RxDeviceObject,
                       TRUE ); //force

    return AcquiredFile;
}

VOID
RxNoOpRelease (
    IN PVOID Fcb
    )
/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Dcb/Vcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/
{
    PAGED_CODE();

    //
    //  Clear the kludge at this point.
    //

    ASSERT(RxGetTopIrpIfRdbssIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);
    RxUnwindTopLevelIrp( NULL );

    UNREFERENCED_PARAMETER( Fcb );

    return;
}


VOID
RxVerifyOperationIsLegal ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This routine determines is the requested operation should be allowed to
    continue.  It either returns to the user if the request is Okay, or
    raises an appropriate status.

Arguments:

    Irp - Supplies the Irp to check

Return Value:

    None.

--*/
{
    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    RxCaptureFileObject;
    RxCaptureFobx;

#if DBG
    ULONG SaveExceptionFlag;   //to save the state of breakpoint-on-exception for this context
#endif

    PAGED_CODE();

    //
    //  If the Irp is not present, then we got here via close.
    //
    //

    if ( capReqPacket == NULL ) {

        return;
    }

    //
    //  If there is not a file object, we cannot continue.
    //

    if ( capFileObject == NULL ) {

        return;
    }

    RxSaveAndSetExceptionNoBreakpointFlag(RxContext,SaveExceptionFlag);

    if (capFobx) {
       PSRV_OPEN pSrvOpen = (PSRV_OPEN)capFobx->SrvOpen;

       ////
       ////  If this fileobject is messed up for some reason--such as a
       ////  disconnection or a deferredopen that failed--then just get out.
       ////
       //
       //if (FlagOn(capFobx->Flags,FOBX_FLAG_BAD_HANDLE)) {
       //
       //    RxRaiseStatus( RxContext, STATUS_INVALID_HANDLE );
       //}

       //
       //  If we are trying to do any other operation than close on a file
       //  object that has been renamed, raise RxStatus(FILE_RENAMED).
       //

       if ((pSrvOpen != NULL) &&
           ( RxContext->MajorFunction != IRP_MJ_CLEANUP ) &&
           ( RxContext->MajorFunction != IRP_MJ_CLOSE   ) &&
           ( FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED))) {

           RxRaiseStatus( RxContext, STATUS_FILE_RENAMED );
       }

       //
       //  If we are trying to do any other operation than close on a file
       //  object that has been deleted, raise RxStatus(FILE_DELETED).
       //

       if ((pSrvOpen != NULL) &&
           ( RxContext->MajorFunction != IRP_MJ_CLEANUP )  &&
           ( RxContext->MajorFunction != IRP_MJ_CLOSE )    &&
           ( FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_FILE_DELETED))) {

           RxRaiseStatus( RxContext, STATUS_FILE_DELETED );
       }
    }

    //
    //  If we are doing a create, and there is a related file object, and
    //  it it is marked for delete, raise RxStatus(DELETE_PENDING).
    //

    if ( RxContext->MajorFunction == IRP_MJ_CREATE ) {

        PFILE_OBJECT RelatedFileObject;

        RelatedFileObject = capFileObject->RelatedFileObject;

        if ( (RelatedFileObject != NULL) &&
             FlagOn(((PFCB)RelatedFileObject->FsContext)->FcbState,
                    FCB_STATE_DELETE_ON_CLOSE) )  {

            RxRaiseStatus( RxContext, STATUS_DELETE_PENDING );
        }
    }

    //
    //  If the file object has already been cleaned up, and
    //
    //  A) This request is a paging io read or write, or
    //  B) This request is a close operation, or
    //  C) This request is a set or query info call (for Lou)
    //  D) This is an MDL complete
    //
    //  let it pass, otherwise return RxStatus(FILE_CLOSED).
    //

    if ( FlagOn(capFileObject->Flags, FO_CLEANUP_COMPLETE) ) {

        if ( (FlagOn(capReqPacket->Flags, IRP_PAGING_IO)) ||
             (capPARAMS->MajorFunction == IRP_MJ_CLOSE ) ||
             (capPARAMS->MajorFunction == IRP_MJ_SET_INFORMATION) ||
             (capPARAMS->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
             ( ( (capPARAMS->MajorFunction == IRP_MJ_READ) ||
                 (capPARAMS->MajorFunction == IRP_MJ_WRITE) ) &&
               FlagOn(capPARAMS->MinorFunction, IRP_MN_COMPLETE) ) ) {

            NOTHING;

        } else {

            RxRaiseStatus( RxContext, STATUS_FILE_CLOSED );
        }
    }

    RxRestoreExceptionNoBreakpointFlag(RxContext,SaveExceptionFlag);
    return;
}

VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    )

{
    NTSTATUS Status;
    PMRX_FCB pFcb = (PMRX_FCB)FileObject->FsContext;

    PAGED_CODE();

    Status = RxAcquireExclusiveFcb( NULL, pFcb );

    //DbgPrint("came thru RxAcquireFileForNtCreateSection\n");

    DbgDoit(
        if (Status != STATUS_SUCCESS) {
            RxBugCheck((ULONG_PTR)pFcb, 0, 0);
        }
    )

    ((PFCB)pFcb)->CreateSectionThread = PsGetCurrentThread();
}

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    )

{
    PMRX_FCB pFcb = (PMRX_FCB)FileObject->FsContext;

    PAGED_CODE();

    ((PFCB)pFcb)->CreateSectionThread = NULL;

    RxReleaseFcb( NULL, pFcb );

}

NTSTATUS
RxAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
RxReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return STATUS_INVALID_DEVICE_REQUEST;
}

VOID 
RxTrackPagingIoResource(
    PVOID       pInstance,
    ULONG       Type,
    ULONG       Line,
    PCHAR       File)
{
    PFCB Fcb = (PFCB)pInstance;

    switch(Type) {
    case 1:
    case 2:
        Fcb->PagingIoResourceFile = File;
        Fcb->PagingIoResourceLine = Line;
        break;
    case 3:
        Fcb->PagingIoResourceFile = NULL;
        Fcb->PagingIoResourceLine = 0;
        break;
    }

    /*
    switch (Type) {
    case 1:
        RxWmiLog(PAGEIORES,
                 RxTrackPagingIoResource_1,
                 LOGPTR(pInstance)
                 LOGULONG(Line)
                 LOGARSTR(File));
       break;
    case 2:
        RxWmiLog(PAGEIORES,
                 RxTrackPagingIoResource_2,
                 LOGPTR(pInstance)
                 LOGULONG(Line)
                 LOGARSTR(File));
       break;
    case 3:
        RxWmiLog(PAGEIORES,
                 RxTrackPagingIoResource_3,
                 LOGPTR(pInstance)
                 LOGULONG(Line)
                 LOGARSTR(File));
       break;
    } */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rxce\rxcontx.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxContx.c

Abstract:

    This module implements routine to allocate/initialize and to delete an Irp
    Context. These structures are very important because they link Irps with the
    RDBSS. They encapsulate all the context required to process an IRP.

Author:

    Joe Linn          [JoeLinn]  21-aug-1994

Revision History:

    Balan Sethu Raman [SethuR]   07-June-1995  Included support for cancelling
                                               requests

--*/

#include "precomp.h"
#pragma hdrstop

#include <dfsfsctl.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeContext)
#pragma alloc_text(PAGE, RxReinitializeContext)
#pragma alloc_text(PAGE, RxPrepareContextForReuse)
#pragma alloc_text(PAGE, RxCompleteRequest)
#pragma alloc_text(PAGE, __RxSynchronizeBlockingOperationsMaybeDroppingFcbLock)
#pragma alloc_text(PAGE, RxResumeBlockedOperations_Serially)
#pragma alloc_text(PAGE, RxResumeBlockedOperations_ALL)
#pragma alloc_text(PAGE, RxCancelBlockingOperation)
#pragma alloc_text(PAGE, RxRemoveOperationFromBlockingQueue)
#endif

BOOLEAN RxSmallContextLogEntry = FALSE;

FAST_MUTEX RxContextPerFileSerializationMutex;

//
//  The debug trace level
//

#define Dbg (DEBUG_TRACE_RXCONTX)

ULONG RxContextSerialNumberCounter = 0;

#ifdef RDBSSLOG
//this stuff must be in nonpaged memory
                             ////       1 2 3 4 5 6 7 8 9
char RxInitContext_SurrogateFormat[] = "%S%S%N%N%N%N%N%N%N";
                             ////             2  3   4         5        6   7   8    9
char RxInitContext_ActualFormat[]    = "Irp++ %s/%lx %08lx irp %lx thrd %lx %lx:%lx #%lx";

#endif //ifdef RDBSSLOG

VOID
ValidateBlockingIoQ(
    PLIST_ENTRY BlockingIoQ
);


VOID
RxInitializeContext(
    IN PIRP                 Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG                InitialContextFlags,
    IN OUT PRX_CONTEXT      RxContext)
{
    PDEVICE_OBJECT TopLevelDeviceObject;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxInitializeContext\n"));

    // some asserts that we need. This ensures that the two values that are
    // packaged together as an IoStatusBlock can be manipulated independently
    // as well as together.

    ASSERT(
        FIELD_OFFSET(RX_CONTEXT,StoredStatus) ==
        FIELD_OFFSET(RX_CONTEXT,IoStatusBlock.Status));

    ASSERT(
        FIELD_OFFSET(RX_CONTEXT,InformationToReturn) ==
        FIELD_OFFSET(RX_CONTEXT,IoStatusBlock.Information));

    //  Set the proper node type code, node byte size and the flags
    RxContext->NodeTypeCode   = RDBSS_NTC_RX_CONTEXT;
    RxContext->NodeByteSize   = sizeof(RX_CONTEXT);
    RxContext->ReferenceCount = 1;
    RxContext->SerialNumber   = InterlockedIncrement(&RxContextSerialNumberCounter);
    RxContext->RxDeviceObject = RxDeviceObject;

    // Initialize the Sync Event.
    KeInitializeEvent(
        &RxContext->SyncEvent,
        SynchronizationEvent,
        FALSE);

    // Initialize the associated scavenger entry
    RxInitializeScavengerEntry(&RxContext->ScavengerEntry);

    // Initialize the list entry of blocked operations
    InitializeListHead(&RxContext->BlockedOperations);

    RxContext->MRxCancelRoutine = NULL;
    RxContext->ResumeRoutine    = NULL;

    SetFlag( RxContext->Flags, InitialContextFlags);

    //  Set the Irp fields....for cacheing and hiding
    RxContext->CurrentIrp   = Irp;
    RxContext->OriginalThread = RxContext->LastExecutionThread = PsGetCurrentThread();

    if (Irp != NULL) {
        PIO_STACK_LOCATION IrpSp;
        IrpSp = IoGetCurrentIrpStackLocation( Irp );  //ok4ioget

        // There are certain operations that are open ended in the redirector.
        // The change notification mechanism is one of them. On a synchronous
        // operation if the wait is in the redirector then we will not be able
        // to cancel because FsRtlEnterFileSystem disables APC's. Therefore
        // we convert the synchronous operation into an asynchronous one and
        // let the I/O system do the waiting.

        if (IrpSp->FileObject != NULL) {
            if (!IoIsOperationSynchronous(Irp)) {
                SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
            } else {
                PFCB Fcb;

                Fcb  = (PFCB)IrpSp->FileObject->FsContext;

                if ((Fcb != NULL) && NodeTypeIsFcb(Fcb)) {
                    if (((IrpSp->MajorFunction == IRP_MJ_READ)  ||
                         (IrpSp->MajorFunction == IRP_MJ_WRITE) ||
                         (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL)) &&
                        (Fcb->pNetRoot != NULL)                  &&
                        (Fcb->pNetRoot->Type == NET_ROOT_PIPE))  {
                        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
                    }
                }
            }
        }

        if ((IrpSp->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) &&
            (IrpSp->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY)) {
            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
        }

        //
        //  JOYC: make all device io control async
        //
        if (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
        }

        
        //  Set the recursive file system call parameter.  We set it true if
        //  the TopLevelIrp field in the thread local storage is not the current
        //  irp, otherwise we leave it as FALSE.
        if ( !RxIsThisTheTopLevelIrp(Irp) ) {
            SetFlag(RxContext->Flags, RX_CONTEXT_FLAG_RECURSIVE_CALL);
        }
        if ( RxGetTopDeviceObjectIfRdbssIrp() == RxDeviceObject ) {
            SetFlag(RxContext->Flags, RX_CONTEXT_FLAG_THIS_DEVICE_TOP_LEVEL);
        }

        //  Major/Minor Function codes
        RxContext->MajorFunction = IrpSp->MajorFunction;
        RxContext->MinorFunction = IrpSp->MinorFunction;
        ASSERT(RxContext->MajorFunction<=IRP_MJ_MAXIMUM_FUNCTION);

        RxContext->CurrentIrpSp = IrpSp;

        if (IrpSp->FileObject) {
            PFOBX Fobx;
            PFCB Fcb;

            Fcb  = (PFCB)IrpSp->FileObject->FsContext;
            Fobx = (PFOBX)IrpSp->FileObject->FsContext2;

            RxContext->pFcb  = (PMRX_FCB)Fcb;
            if (Fcb && NodeTypeIsFcb(Fcb)) {
                RxContext->NonPagedFcb = Fcb->NonPaged;
            }

            if (Fobx &&
                (Fobx != (PFOBX)UIntToPtr(DFS_OPEN_CONTEXT)) &&
                (Fobx != (PFOBX)UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT))) {

                RxContext->pFobx = (PMRX_FOBX)Fobx;
                RxContext->pRelevantSrvOpen = Fobx->pSrvOpen;
                if (NodeType(Fobx)==RDBSS_NTC_FOBX) {
                    RxContext->FobxSerialNumber = InterlockedIncrement(&Fobx->FobxSerialNumber);
                }
            } else {
                RxContext->pFobx = NULL;
            }

            // Copy IRP specific parameters.
            if ((RxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) &&
                (RxContext->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY)) {

                if (Fobx != NULL) {
                    if (NodeType(Fobx)==RDBSS_NTC_FOBX) {
                        RxContext->NotifyChangeDirectory.pVNetRoot = (PMRX_V_NET_ROOT)Fcb->VNetRoot;
                    } else if (NodeType(Fobx) == RDBSS_NTC_V_NETROOT) {
                        RxContext->NotifyChangeDirectory.pVNetRoot = (PMRX_V_NET_ROOT)Fobx;
                    }
                }
            }

            //  Copy RealDevice for workque algorithms,
            RxContext->RealDevice = IrpSp->FileObject->DeviceObject;
            if (FlagOn(IrpSp->FileObject->Flags,FO_WRITE_THROUGH)){
                SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH );
            }
        }
    } else {
        RxContext->CurrentIrpSp = NULL;
        //  Major/Minor Function codes
        RxContext->MajorFunction = IRP_MJ_MAXIMUM_FUNCTION + 1;
        RxContext->MinorFunction = 0;
    }

    if (RxContext->MajorFunction != IRP_MJ_DEVICE_CONTROL) {
        PETHREAD Thread = PsGetCurrentThread();
        UCHAR    Pad = 0;

        RxLog(
            (
                RxInitContext_SurrogateFormat,
                RxInitContext_ActualFormat,
                RXCONTX_OPERATION_NAME(
                    RxContext->MajorFunction,
                    BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)),
                RxContext->MinorFunction,
                RxContext,
                Irp,
                Thread,
                RxContext->pFcb,
                RxContext->pFobx,
                RxContext->SerialNumber
            ));
        
        RxWmiLog(LOG,
                 RxInitializeContext,
                 LOGPTR(RxContext)
                 LOGPTR(Irp)
                 LOGPTR(Thread)
                 LOGPTR(RxContext->pFcb)
                 LOGPTR(RxContext->pFobx)
                 LOGULONG(RxContext->SerialNumber)
                 LOGUCHAR(RxContext->MinorFunction)
                 LOGARSTR(RXCONTX_OPERATION_NAME(
                    RxContext->MajorFunction,
                    BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT))));
    }

    RxDbgTrace(-1, Dbg, ("RxInitializeContext -> %08lx %08lx %08lx\n",
                        RxContext,RxContext->pFcb,RxContext->pFobx));
}

PRX_CONTEXT
RxCreateRxContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags
    )
/*++

Routine Description:

    This routine creates a new RX_CONTEXT record

Arguments:

    Irp                 - Supplies the originating Irp.

    RxDeviceObject      - the deviceobject that applies

    InitialContextFlags - Supplies the wait value to store in the context;
                          also, the must_succeed value

Return Value:

    PRX_CONTEXT - returns a pointer to the newly allocate RX_CONTEXT Record

--*/
{
    KIRQL              SavedIrql;
    PRX_CONTEXT        RxContext = NULL;
    ULONG              RxContextFlags = 0;
    UCHAR              MustSucceedDescriptorNumber = 0;

    DebugDoit( InterlockedIncrement(&RxFsdEntryCount); )

    ASSERT(RxDeviceObject!=NULL);

    InterlockedIncrement(&RxDeviceObject->NumberOfActiveContexts);

    if (RxContext == NULL) {
        RxContext = ExAllocateFromNPagedLookasideList(
                        &RxContextLookasideList);

        if (RxContext != NULL) {
            SetFlag( RxContextFlags, RX_CONTEXT_FLAG_FROM_POOL );
        }
    }

    if(RxContext == NULL){
        return(NULL);
    }

    RtlZeroMemory( RxContext, sizeof(RX_CONTEXT) );

    RxContext->Flags = RxContextFlags;
    RxContext->MustSucceedDescriptorNumber = MustSucceedDescriptorNumber;

    RxInitializeContext(Irp,RxDeviceObject,InitialContextFlags,RxContext);

    ASSERT(
        (RxContext->MajorFunction!=IRP_MJ_CREATE) ||
        !FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED) );

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    InsertTailList(&RxActiveContexts,&RxContext->ContextListEntry);

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    return RxContext;
}

VOID
RxReinitializeContext(
   IN OUT PRX_CONTEXT RxContext
   )
{
   PIRP                 Irp  = RxContext->CurrentIrp;
   PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

   ULONG PreservedContextFlags = RxContext->Flags & RX_CONTEXT_PRESERVED_FLAGS;
   ULONG InitialContextFlags   = RxContext->Flags & RX_CONTEXT_INITIALIZATION_FLAGS;

   PAGED_CODE();

   RxPrepareContextForReuse(RxContext);

   RtlZeroMemory(
         (PCHAR)(&RxContext->ContextListEntry + 1),
         sizeof(RX_CONTEXT) - FIELD_OFFSET(RX_CONTEXT,MajorFunction));

   RxContext->Flags = PreservedContextFlags;

   RxInitializeContext(Irp,RxDeviceObject,InitialContextFlags,RxContext);
}

VOID
RxPrepareContextForReuse(
   IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine prepares a context for reuse by resetting all operation specific
    allocations/acquistions that have been made. The parameters that have been
    obtained from the IRP are not modified.

Arguments:

    RxContext - Supplies the RX_CONTEXT to remove

Return Value:

    None

--*/
{
    PAGED_CODE();

    //  Clean up the operation specific stuff
    switch (RxContext->MajorFunction) {

    case IRP_MJ_CREATE:
        ASSERT ( RxContext->Create.CanonicalNameBuffer == NULL );
        break;

    case IRP_MJ_READ :
    case IRP_MJ_WRITE :
        {
            ASSERT(RxContext->RxContextSerializationQLinks.Flink == NULL);
            ASSERT(RxContext->RxContextSerializationQLinks.Blink == NULL);
        }
        break;

    default:
        NOTHING;
    }

    RxContext->ReferenceCount = 0;
}


VOID
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine dereferences an RxContexts and if the refcount goes to zero
    then it deallocates and removes the specified RX_CONTEXT record from the
    Rx in-memory data structures. IT is called by routines other than
    RxCompleteRequest async requests touch the RxContext "last" in either the
    initiating thread or in some other thread. Thus, we refcount the structure
    and finalize on the last dereference.

Arguments:

    RxContext - Supplies the RX_CONTEXT to remove

Return Value:

    None

--*/
{
    KIRQL                SavedIrql;
    BOOLEAN              RxContextIsFromPool;
    BOOLEAN              RxContextIsMustSucceedAllocated;
    BOOLEAN              RxContextIsFromZone;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PRX_CONTEXT          pStopContext = NULL;
    LONG                 FinalRefCount;

    RxDbgTraceLV(+1, Dbg, 1500, ("RxDereferenceAndDeleteRxContext, RxContext = %08lx (%lu)\n",
                                RxContext,RxContext->SerialNumber));

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    ASSERT( RxContext->NodeTypeCode == RDBSS_NTC_RX_CONTEXT );

    FinalRefCount = InterlockedDecrement(&RxContext->ReferenceCount);

    if (FinalRefCount == 0) {
        RxDeviceObject = RxContext->RxDeviceObject;
        RxContextIsFromPool = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_FROM_POOL);
        RxContextIsMustSucceedAllocated = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED);

        if (RxContext == RxDeviceObject->StartStopContext.pStopContext) {
            RxDeviceObject->StartStopContext.pStopContext = NULL;
        } else {
            ASSERT((RxContext->ContextListEntry.Flink->Blink == &RxContext->ContextListEntry) &&
                   (RxContext->ContextListEntry.Blink->Flink == &RxContext->ContextListEntry));

            RemoveEntryList(&RxContext->ContextListEntry);

            if ((InterlockedDecrement(&RxDeviceObject->NumberOfActiveContexts)==0) &&
                (RxDeviceObject->StartStopContext.pStopContext != NULL)) {
                pStopContext = RxDeviceObject->StartStopContext.pStopContext;
            }
        }
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    if (FinalRefCount > 0) {
        RxDbgTraceLV(-1, Dbg, 1500, ("RxDereferenceAndDeleteRxContext, RxContext not final!!! = %08lx (%lu)\n",
                                RxContext,RxContext->SerialNumber));
        return;
    }

    ASSERT(RxContext->ReferenceCount == 0);

    //  Clean up the operation specific stuff
    RxPrepareContextForReuse(RxContext);

    ASSERT(RxContext->AcquireReleaseFcbTrackerX == 0);

    if (pStopContext != NULL) {
        // Signal the event.
        RxSignalSynchronousWaiter(pStopContext);
    }

    if (RxContext->dwShadowCritOwner)
    {
        DbgPrint("RxDereferenceAndDeleteRxContext:shdowcrit still owned by %x\n", RxContext->dwShadowCritOwner);
        ASSERT(FALSE);
    }
    if (RxContextIsFromPool) {
        ExFreeToNPagedLookasideList(
            &RxContextLookasideList,
            RxContext );
    }

    RxDbgTraceLV(-1, Dbg, 1500, ("RxDereferenceAndDeleteRxContext -> VOID\n", 0));

    return;
}

ULONG RxStopOnLoudCompletion = TRUE;
NTSTATUS
RxCompleteRequest(
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS    Status)
{
    PIRP Irp;

    PAGED_CODE();

    ASSERT(RxContext);
    ASSERT(RxContext->CurrentIrp);

    Irp = RxContext->CurrentIrp;
    if ((RxContext->LoudCompletionString)) {
        DbgPrint("LoudCompletion %08lx/%08lx on %wZ\n",Status,Irp->IoStatus.Information,RxContext->LoudCompletionString);
        if ((Status!=STATUS_SUCCESS) && RxStopOnLoudCompletion) {
            DbgPrint("FAILURE!!!!! %08lx/%08lx on %wZ\n",Status,Irp->IoStatus.Information,RxContext->LoudCompletionString);
            //DbgBreakPoint();
        }
    }

#if 0
    if ((Status!=STATUS_SUCCESS) && (RxContext->LoudCompletionString)) {
        DbgPrint("LoudFailure %08lx/%08lx on %wZ\n",Status,Irp->IoStatus.Information,RxContext->LoudCompletionString);
        if (RxStopOnLoudCompletion) {
            //DbgBreakPoint();
        }
    }
#endif

   RxContext->CurrentIrp = NULL;
   RxCompleteRequest_Real(RxContext,Irp,Status);

   return Status;
}

#ifdef RDBSSLOG
//this stuff must be in nonpaged memory
                                  ////      1 2 3 4 5 6 7 8 9
char RxCompleteContext_SurrogateFormat[] = "%S%S%S%N%N%N%N%N%N";
                                  ////            2 3  4   5       6        7   8    9
char RxCompleteContext_ActualFormat[]    = "Irp-- %s%s/%lx %lx irp %lx iosb %lx,%lx #%lx";

#endif //ifdef RDBSSLOG


VOID
RxCompleteRequest_Real (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine completes a Irp

Arguments:

    Irp - Supplies the Irp being processed

    Status - Supplies the status to complete the Irp with

--*/
{
    //
    //  If we have an Irp then complete the irp.
    //

    if (Irp != NULL) {

        CCHAR PriorityBoost;
        PIO_STACK_LOCATION IrpSp;

        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        RxSetCancelRoutine(Irp,NULL);

        //
        //  For an error, zero out the information field before
        //  completing the request if this was an input operation.
        //  Otherwise IopCompleteRequest will try to copy to the user's buffer.
        //  Also, no boost for an error.
        //

        if ( NT_ERROR(Status) &&
             FlagOn(Irp->Flags, IRP_INPUT_OPERATION) ) {

            Irp->IoStatus.Information = 0;
            PriorityBoost = IO_NO_INCREMENT;
        } else {
            PriorityBoost = IO_DISK_INCREMENT;
        }

        if (Irp->MdlAddress) {
            RxUnprotectMdlFromFree(Irp->MdlAddress);
        }

        Irp->IoStatus.Status = Status;

        RxDbgTrace(0, (DEBUG_TRACE_DISPATCH),
                       ("RxCompleteRequest_real ----------   Irp(code) = %08lx(%02lx) %08lx %08lx\n",
                                      Irp, IoGetCurrentIrpStackLocation( Irp )->MajorFunction,
                                      Status, Irp->IoStatus.Information));

        if (RxContext != NULL) {
            ASSERT(RxContext->MajorFunction<=IRP_MJ_MAXIMUM_FUNCTION);

            if (RxContext->MajorFunction != IRP_MJ_DEVICE_CONTROL) {
                RxLog(
                    (
                        RxCompleteContext_SurrogateFormat,
                        RxCompleteContext_ActualFormat,
                        (RxContext->OriginalThread == PsGetCurrentThread())?"":"*",
                        RXCONTX_OPERATION_NAME(RxContext->MajorFunction,TRUE),
                        RxContext->MinorFunction,
                        RxContext,
                        Irp,
                        Status,
                        Irp->IoStatus.Information,
                        RxContext->SerialNumber
                    ));

                RxWmiLog(LOG,
                         RxCompleteRequest,
                         LOGPTR(RxContext)
                         LOGPTR(Irp)
                         LOGULONG(Status)
                         LOGPTR(Irp->IoStatus.Information)
                         LOGULONG(RxContext->SerialNumber)
                         LOGUCHAR(RxContext->MinorFunction)
                         LOGARSTR(RXCONTX_OPERATION_NAME(RxContext->MajorFunction,TRUE)));
            }
        }

        if ((IrpSp->MajorFunction == IRP_MJ_CREATE) &&
            (Status != STATUS_PENDING)) {
            if (RxContext != NULL) {
                if (FlagOn(
                        RxContext->Create.Flags,
                        RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH)) {
                    IrpSp->FileObject->FileName.Length += sizeof(WCHAR);
                }

                RxpPrepareCreateContextForReuse(RxContext);

                ASSERT ( RxContext->Create.CanonicalNameBuffer == NULL );
            }
        }

        if (IrpSp->MajorFunction == IRP_MJ_WRITE) {
            if (Irp->IoStatus.Status == STATUS_SUCCESS) {
                ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.Write.Length);
            }
        }

        if (RxContext != NULL) {
            if (RxContext->PendingReturned) {
                ASSERT(IrpSp->Control & SL_PENDING_RETURNED);
            }
        }

        IoCompleteRequest( Irp, PriorityBoost );
    } else {
        // a call with a null irp..........
        RxLog(("Irp00 %lx\n", RxContext ));
        RxWmiLog(LOG,
                 RxCompleteRequest_NI,
                 LOGPTR(RxContext));
    }

    //  Delete the Irp context.
    if (RxContext != NULL) {
        RxDereferenceAndDeleteRxContext( RxContext );
    }

    return;
}

NTSTATUS
__RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ,
    IN     BOOLEAN     DropFcbLock
    )
/*++

Routine Description:

    This routine is used to synchronize among blocking IOs to the same Q.
    Currently, the routine is only used to synchronize block pipe operations and
    the Q is the one in the file object extension (Fobx). What happens is that
    the operation joins the queue. If it is now the front of the queue, the
    operation continues; otherwise it waits on the sync event in the RxContext
    or just returns pending (if async).

    We may have been cancelled while we slept, check for that and
    return an error if it happens.

    The event must have been reset before the call. The fcb lock must be held;
    it is dropped after we get on the Q.

Arguments:

    RxContext    The context of the operation being synchronized

    BlockingIoQ  The queue to get on.

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureRequestPacket;

    BOOLEAN FcbLockDropped = FALSE;
    BOOLEAN SerializationMutexReleased = FALSE;

    PRX_CONTEXT FrontRxContext;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock, rxc=%08lx, fobx=%08lx\n", RxContext, RxContext->pFobx ));

    RxContext->StoredStatus = STATUS_SUCCESS;  //do this early....a cleanup could come thru and change it

    ExAcquireFastMutex(&RxContextPerFileSerializationMutex);

    if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_CANCELLED)) {

        SetFlag(
            RxContext->FlagsForLowIo,
            RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION);

//        ValidateBlockingIoQ(BlockingIoQ);

        InsertTailList(BlockingIoQ,&RxContext->RxContextSerializationQLinks);
        FrontRxContext = CONTAINING_RECORD( BlockingIoQ->Flink,RX_CONTEXT,RxContextSerializationQLinks);

        if (RxContext != FrontRxContext) {
            if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                if (!SerializationMutexReleased) {
                    Serial