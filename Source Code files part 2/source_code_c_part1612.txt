und - but the
    //    port is being closed by another process on its behalf
    //
    // NOTE: The following code assumes that if the same process opened
    //       the port for listening AND as a client, then it will always
    //       close the client instance before it closes the listening
    //       instance.
    //

    if (    ppcb->PCB_OpenInstances == 2
        &&  pid == ppcb->PCB_OwnerPID)
    {

        //
        // A. Typical case: client opened and client is closing the port
        // fall through for processing the close
        //
       ;

    }
    else if (   ppcb->PCB_OpenInstances == 1
            &&  curpid == ppcb->PCB_BiplexOwnerPID
            &&  !fServerClose)
    {
        //
        // this can happen in the case of auto port close.
        // (remote disconnect/link failures)
        // rasman may try to close the server port.
        //
        RasmanTrace(
            "PortClose: pid(%d) tried to close server port."
            " Returning ERROR_ACCESS_DENIED", pid);

        ppcb->PCB_RasmanReceiveFlags &= ~(RECEIVE_PPPLISTEN | RECEIVE_PPPSTARTED);

        return ERROR_ACCESS_DENIED;

    }
    else
    {

        //
        // C. Case where the client opened the port while
        //    the server was listening - made a connection
        //    and process exited, on disconnection rasapi
        //    is closing the port on the client's behalf.
        //    This is the same as case A above - so we
        //    fall throught for processing the close
        //
        ;
    }

    fOwnerClose = (pid == ppcb->PCB_OwnerPID);

    if (    ppcb->PCB_OpenInstances == 2
       &&   ppcb->PCB_BiplexOwnerPID == pid
       &&   ppcb->PCB_DisconnectReason == USER_REQUESTED)
    {
        RasmanTrace(
               "Server Closing the port %s on "
               "clients behalf",
               ppcb->PCB_Name);
    }

    //
    // Handle the regular close.
    //

    //
    // If there is a request pending and the state is not
    // already disconnecting and this is a user requested
    // operation - then disconnect.
    //
    if(     REQTYPE_NONE !=
            ppcb->PCB_AsyncWorkerElement.WE_ReqType
        &&  ppcb->PCB_ConnState != DISCONNECTING)
    {
        //
        // Don't overwrite the real error if we
        // have it stored.
        //
        if(     (SUCCESS == ppcb->PCB_LastError)
            ||  (PENDING == ppcb->PCB_LastError))
        {
            ppcb->PCB_LastError = ERROR_PORT_DISCONNECTED;
        }

        CompleteAsyncRequest(ppcb);
    }

    //
    // Free rasapi32 I/O completion port handle.
    //
    if (ppcb->PCB_IoCompletionPort != INVALID_HANDLE_VALUE)
    {
        SetIoCompletionPortCommon(
          ppcb,
          INVALID_HANDLE_VALUE,
          NULL,
          NULL,
          NULL,
          NULL,
          TRUE);
    }
    //
    // Free up the list of notifiers:
    //
    RasmanTrace(
           "Freeing the notifier list for port %d",
           ppcb->PCB_PortHandle);

    FreeNotifierList(&ppcb->PCB_NotifierList);

    //
    // Reset the DisconnectAction struct.
    //
    memset(
      &ppcb->PCB_DisconnectAction,
      0,
      sizeof(SlipDisconnectAction));

    //
    // Free any user stored data
    //
    if (ppcb->PCB_UserStoredBlock != NULL)
    {
        LocalFree(ppcb->PCB_UserStoredBlock);
        ppcb->PCB_UserStoredBlock = NULL;
        ppcb->PCB_UserStoredBlockSize = 0;
    }

    //
    // Free new style user data.
    //
    FreeUserData(&ppcb->PCB_UserData);

    //
    // Once port is closed, the owner pid is 0.
    //
    ppcb->PCB_OwnerPID = 0;

    ppcb->PCB_OpenInstances--;

    RasmanTrace(
          "PortClose (%d). OpenInstances = %d",
          ppcb->PCB_PortHandle,
          ppcb->PCB_OpenInstances);

    //
    // Turn off the CALL_ROUTER bit in the
    // current usage mask.  The router will
    // set this bit via RasSetRouterUsage()
    // after a successful open/listen completes.
    //
    ppcb->PCB_CurrentUsage &= ~CALL_ROUTER;

    //
    // If this is a biplex port opened twice,
    // then repost the listen. Don't repost a
    // listen if the port is marked for removal
    // (PnP) or if BAP had posted a listen from
    // the client.
    //
    if (    0 != ppcb->PCB_OpenInstances
        &&  UNAVAILABLE != ppcb->PCB_PortStatus
        &&  (0 ==
            (ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPLISTEN)))
    {
        ppcb->PCB_UserStoredBlock =
                ppcb->PCB_BiplexUserStoredBlock;

        ppcb->PCB_UserStoredBlockSize =
            ppcb->PCB_BiplexUserStoredBlockSize;

        //
        // This is a reserved port being freed: we need
        // to open it again since the code is expecting
        // this handle to be open
        //
        if (!fClose)
        {
            PORTOPEN( ppcb->PCB_Media,
                      ppcb->PCB_Name,
                      &ppcb->PCB_PortIOHandle,
                      hIoCompletionPort,
                      HandleToUlong(ppcb->PCB_PortHandle));
        }

        RePostListenOnBiplexPort(ppcb);

    }
    else
    {
        //
        // Inform others the port has been disconnected.
        //
        if (ppcb->PCB_ConnState != DISCONNECTED)
        {
            RasmanTrace(
                   "8. Notifying of disconnect on port %d",
                   ppcb->PCB_PortHandle);

            SignalPortDisconnect(ppcb, 0);

            SignalNotifiers(pConnectionNotifierList,
                            NOTIF_DISCONNECT, 0);
        }

        //
        // If this is not the reserved port free case -
        // close the port else dont bother since it is
        // already closed. Also close the port if it was
        // removed (PnP)
        //
        if (    fClose
            ||  UNAVAILABLE == ppcb->PCB_PortStatus )
        {
            PORTCLOSE(ppcb->PCB_Media, ppcb->PCB_PortIOHandle);
        }
        if ( UNAVAILABLE == ppcb->PCB_PortStatus )
        {
            //
            // This port was marked for removal. Tear down
            // the structure associated with this port.
            //
            RasmanTrace(
                   "PortClose: Removing %s %d",
                   ppcb->PCB_Name, ppcb->PCB_PortHandle);

            RemovePort ( ppcb->PCB_PortHandle );

            RasmanTrace ( "PortClose: Removed Port ");
        }
        else
        {
            SetPortAsyncReqType(__FILE__, __LINE__,
                                ppcb, REQTYPE_NONE);

            SetPortConnState(__FILE__, __LINE__,
                            ppcb, DISCONNECTED);

            ppcb->PCB_ConnectDuration   = 0;

            ppcb->PCB_PortStatus        = CLOSED;

            ppcb->PCB_LinkSpeed         = 0;
        }

    }

    if ( pid == GetCurrentProcessId() )
    {
        ppcb->PCB_RasmanReceiveFlags &= ~RECEIVE_PPPLISTEN;
    }

    //
    // Save a copy of the connection block
    // pointer while we have the lock.
    //
    pConn                           = ppcb->PCB_Connection;
    ppcb->PCB_Connection            = NULL;
    ppcb->PCB_pszPhonebookPath      = NULL;
    ppcb->PCB_pszEntryName          = NULL;
    ppcb->PCB_pszPhoneNumber        = NULL;
    ppcb->PCB_pCustomAuthData       = NULL;
    ppcb->PCB_OpenedUsage           = 0;
    ppcb->PCB_pCustomAuthUserData   = NULL;
    ppcb->PCB_fLogon = FALSE;
    ppcb->PCB_fRedial = FALSE;
    ppcb->PCB_RasmanReceiveFlags    &= ~(RECEIVE_PPPSTOPPED | RECEIVE_PPPSTARTED);

    if(     (INVALID_HANDLE_VALUE != ppcb->PCB_hEventClientDisconnect)
        &&  (NULL != ppcb->PCB_hEventClientDisconnect))
    {
        RasmanTrace(
               "Signalling client's disconnect event(0x%x) for %s",
               ppcb->PCB_hEventClientDisconnect,
               ppcb->PCB_Name);

        SetEvent(ppcb->PCB_hEventClientDisconnect);

        CloseHandle(ppcb->PCB_hEventClientDisconnect);
    }

    ppcb->PCB_hEventClientDisconnect = INVALID_HANDLE_VALUE;

    //
    // If server is not the one closing the port
    // delete the filter if there was one and if
    // this is an l2tp port
    //
    if(     (!fServerClose)

        &&  (RDT_Tunnel_L2tp ==
            RAS_DEVICE_TYPE(
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType)))
    {
        DWORD retcode;

        retcode = DwDeleteIpSecFilter(ppcb, FALSE);

        RasmanTrace(
               "DwDeleteFilter for %s returned 0x%x",
               ppcb->PCB_Name,
               retcode);
    }

    ppcb->PCB_ulDestAddr = 0;

    //
    // Remove this port from its connection block,
    // if any.
    //
    RemoveConnectionPort(ppcb, pConn, fOwnerClose);

    //
    // Clear the AutoClose flag in case
    // we get closed some other path than
    // the worker thread.
    //
    RasmanTrace(
           "%s, %d: Clearing the autoclose "
           "flag for port %d",
           __FILE__, __LINE__,
           ppcb->PCB_PortHandle);

    ppcb->PCB_AutoClose = FALSE;

    if(ppcb->PCB_fAmb)
    {
        RasmanTrace(
               "PortClose: Bindings for %s=0x%x",
                ppcb->PCB_Name,
                ppcb->PCB_Bindings);

        ppcb->PCB_Bindings = NULL;
        ppcb->PCB_fAmb = FALSE;
    }

    //
    // if attached count is 0 and no ports
    // are open stop the service
    //
    if( 0 == g_dwAttachedCount)
    {
        for (i = 0; i < MaxPorts; i++)
        {
            if(     Pcb[i]
                &&  OPEN == Pcb[i]->PCB_PortStatus)
            {
                break;
            }
        }

        if(i == MaxPorts)
        {
            RasmanTrace(
                   "Posting close event from PortClose");

            if (!PostQueuedCompletionStatus(
                                hIoCompletionPort,
                                0,0,
                                (LPOVERLAPPED) &RO_CloseEvent))
            {
                RasmanTrace(
                    
                    "%s, %d: Failed to post close event. "
                    "GLE = %d", __FILE__, __LINE__,
                    GetLastError());
            }
        }
    }

    return SUCCESS;
}

/*++

Routine Description:

    Closes the requested port - if a listen was pending on the
    biplex port it is reposted.

Arguments:

Return Value:

    Nothing.

--*/
VOID
PortCloseRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD pid = ((REQTYPECAST *)buffer)->PortClose.pid;

    RPC_STATUS rpcstatus = RPC_S_OK;
    NTSTATUS ntstatus;
    ULONG SessionId;
    ULONG ReturnLength;
    HANDLE CurrentThreadToken;

    if (ppcb == NULL)
    {
        ((REQTYPECAST *)buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;
        return;
    }

#if 0
    //
    // get the sessionId and check to see if it matches the
    // sessionId that opens this port
    //
    if(pid != GetCurrentProcessId())
    {
        BOOL fAdmin = FALSE;
        rpcstatus = RpcImpersonateClient ( NULL );

        if ( RPC_S_OK != rpcstatus )
        {
            ((REQTYPECAST*)buffer)->Generic.retcode = ERROR_ACCESS_DENIED;
            return;
        }

        //
        // Use workstation service's security
        // context to open thread token
        //
        ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,
                   &CurrentThreadToken
                   );

        ntstatus = NtQueryInformationToken(
                  CurrentThreadToken,
                  TokenSessionId,
                  &SessionId,
                  sizeof(ULONG),
                  &ReturnLength
                  );

        if (! NT_SUCCESS(ntstatus))
        {
            ((REQTYPECAST*)buffer)->Generic.retcode = ERROR_ACCESS_DENIED;
            NtClose(CurrentThreadToken);
            RpcRevertToSelf();
            return ;
        }

        // fAdmin = FIsAdmin(CurrentThreadToken);

        NtClose(CurrentThreadToken);

        RpcRevertToSelf();

        if (SessionId != ppcb->PCB_LogonId)
        {
            RasmanTrace("PortCloseRequest: Access denied - "
                        "not the same login session");
            ((REQTYPECAST*)buffer)->Generic.retcode = ERROR_ACCESS_DENIED;
            return;
        }
    }

#endif    

    PortClose(ppcb,
              ((REQTYPECAST *)buffer)->PortClose.pid,
              (BOOLEAN)((REQTYPECAST *)buffer)->PortClose.close,
              FALSE);

    ((REQTYPECAST*) buffer)->Generic.retcode = SUCCESS ;
}



/*++

Routine Description:

    Used to make the device dll call.

Arguments:

Return Value:

    Nothing

--*/
VOID
CallDeviceEnum (pPCB ppcb, PBYTE buffer)
{
    DWORD           retcode ;
    pDeviceCB       device ;
    char            devicetype[MAX_DEVICETYPE_NAME] ;
    DWORD           dwSize;
    BYTE UNALIGNED *pBuffer;

    if(ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->Enum.entries = 0 ;
        ((REQTYPECAST*)buffer)->Enum.size = 0 ;

        if(0 != MaxPorts)
        {
            ((REQTYPECAST *)buffer)->Enum.retcode = ERROR_PORT_NOT_FOUND;
        }
        else
        {
            ((REQTYPECAST *)buffer)->Enum.retcode = SUCCESS;
        }

        return;
    }

    strcpy(devicetype,((REQTYPECAST*)buffer)->DeviceEnum.devicetype);

    //
    // NULL devices are specially treated
    //
    if(!_stricmp(devicetype, DEVICE_NULL))
    {
        ((REQTYPECAST*)buffer)->Enum.entries = 0 ;
        ((REQTYPECAST*)buffer)->Enum.size = 0 ;
        ((REQTYPECAST*)buffer)->Enum.retcode = SUCCESS ;
        return ;
    }

    dwSize = ((REQTYPECAST*)buffer)->DeviceEnum.dwsize;


    if(dwSize == 0)
    {
        pBuffer = LocalAlloc(LPTR, REQBUFFERSIZE_FIXED +
                            (REQBUFFERSIZE_PER_PORT * MaxPorts));

        if(NULL == pBuffer)
        {
            ((REQTYPECAST*)buffer)->Enum.entries    = 0 ;

            ((REQTYPECAST*)buffer)->Enum.size       = 0 ;

            ((REQTYPECAST*)buffer)->Enum.retcode    = GetLastError();

            return ;
        }

        ((REQTYPECAST*)buffer)->Enum.size = REQBUFFERSIZE_FIXED +
                                     ( REQBUFFERSIZE_PER_PORT * MaxPorts );
    }
    else
    {
        pBuffer = (BYTE UNALIGNED *) ((REQTYPECAST *)buffer)->Enum.buffer;
        ((REQTYPECAST*)buffer)->Enum.size = dwSize;
    }

    //
    // First check if device dll is loaded. If not loaded - load it.
    //
    device = LoadDeviceDLL (ppcb, devicetype) ;

    if (device != NULL)
    {
        retcode = DEVICEENUM(device,
                              devicetype,
                              &((REQTYPECAST*)buffer)->Enum.entries,
                              pBuffer ,
                              &((REQTYPECAST*)buffer)->Enum.size) ;

    }
    else
    {
        retcode = ERROR_DEVICE_DOES_NOT_EXIST;
    }

    if ( dwSize == 0 )
    {
        LocalFree ( pBuffer );
    }

    ((REQTYPECAST*)buffer)->Enum.retcode = retcode ;
}



/*++

Routine Description:

    Used to make the device dll call.

Arguments:

Return Value:

    Nothing

--*/
VOID
DeviceGetInfoRequest (pPCB ppcb, BYTE *buffer)
{
    DWORD       retcode ;

    pDeviceCB   device ;

    char        devicetype[MAX_DEVICETYPE_NAME] ;

    char        devicename[MAX_DEVICE_NAME+1] ;

    RASMAN_DEVICEINFO *info = (RASMAN_DEVICEINFO *)
                ((REQTYPECAST *)buffer)->GetInfo.buffer ;

    DWORD       dwSize = ((REQTYPECAST*)buffer)->DeviceGetInfo.dwSize;

    PBYTE       pBuffer;

    strcpy(
        devicetype,
        ((REQTYPECAST*)buffer)->DeviceGetInfo.devicetype);

    strcpy(
        devicename,
        ((REQTYPECAST*)buffer)->DeviceGetInfo.devicename);

    //
    // NULL devices are specially treated
    //
    if (!_stricmp(devicetype, DEVICE_NULL))
    {
        ((REQTYPECAST*)
        buffer)->GetInfo.size = sizeof (RASMAN_DEVICEINFO);

        info->DI_NumOfParams = 0 ;

        ((REQTYPECAST*)buffer)->GetInfo.retcode = SUCCESS ;

        return ;
    }

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                   "DeviceGetInfoRequest: Port %d is unavailable",
                   ppcb->PCB_PortHandle);
        }

        ((REQTYPECAST *)
        buffer)->GetInfo.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }

    if ( dwSize == 0 )
    {
        pBuffer = LocalAlloc(LPTR, REQBUFFERSIZE_FIXED +
                            (REQBUFFERSIZE_PER_PORT * MaxPorts));

        if ( NULL == pBuffer )
        {
            retcode = GetLastError();
            goto done;
        }

        ((REQTYPECAST*)
        buffer)->GetInfo.size = REQBUFFERSIZE_FIXED
                              + (REQBUFFERSIZE_PER_PORT * MaxPorts);

    }
    else
    {
        ((REQTYPECAST*)buffer)->GetInfo.size = dwSize;
        pBuffer = ((REQTYPECAST*)buffer)->GetInfo.buffer;

    }

    //
    // First check if device dll is loaded.
    // If not loaded - load it.
    //
    device = LoadDeviceDLL (ppcb, devicetype) ;

    if (device != NULL)
    {

        retcode = DEVICEGETINFO(
                        device,
                        ppcb->PCB_PortFileHandle,
                        devicetype,
                        devicename,
                        pBuffer,
                        &((REQTYPECAST*)buffer)->GetInfo.size) ;
    }
    else
    {
        retcode = ERROR_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Before passing the buffer back to the client
    // process convert pointers to offsets:
    //
    if (    dwSize
        &&  SUCCESS == retcode )
    {
        ConvParamPointerToOffset(
                    info->DI_Params,
                    info->DI_NumOfParams);
    }

done:

    if ( dwSize == 0 )
    {
        LocalFree ( pBuffer );
    }

    ((REQTYPECAST*)buffer)->GetInfo.retcode = retcode ;
}

VOID
GetDestIpAddress(pPCB  ppcb,
                 RASMAN_DEVICEINFO *pInfo)
{
    DWORD i;

    for(i = 0; i < pInfo->DI_NumOfParams; i++)
    {
        if(     (String != pInfo->DI_Params[i].P_Type)
            ||  (0 != _stricmp(pInfo->DI_Params[i].P_Key,
                               "PhoneNumber")))
        {
            continue;
        }

        ppcb->PCB_ulDestAddr =
            inet_addr(
                pInfo->DI_Params[i].P_Value.String.Data
                );

        break;
    }
}

/*++

Routine Description:

    Used to make the device dll call. Checks for the Device
    DLL's presence before though.

Arguments:

Return Value:

    Nothing

--*/
VOID
DeviceSetInfoRequest (pPCB ppcb, BYTE *buffer)
{
    DWORD       retcode ;
    pDeviceCB   device ;
    char        devicetype[MAX_DEVICETYPE_NAME] ;
    char        devicename[MAX_DEVICE_NAME+1] ;

    RASMAN_DEVICEINFO *info = &((REQTYPECAST *)
                        buffer)->DeviceSetInfo.info ;

    //
    // Convert the offsets to pointers:
    //
    ConvParamOffsetToPointer(info->DI_Params,
                             info->DI_NumOfParams) ;

    strcpy(
        devicetype,
        ((REQTYPECAST*)buffer)->DeviceSetInfo.devicetype);

    strcpy(
        devicename,
        ((REQTYPECAST*)buffer)->DeviceSetInfo.devicename);

    //
    // NULL devices are specially treated
    //
    if (!_stricmp(devicetype, DEVICE_NULL))
    {
        ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;
        return ;
    }

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                
                "DeviceSetInfoRequest: port %d is unavailable",
                ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)
        buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }

    //
    // First check if device dll is loaded.
    // If not loaded - load it.
    //
    device = LoadDeviceDLL (ppcb, devicetype) ;

    if (device != NULL)
    {
        retcode = DEVICESETINFO(
                            device,
                            ppcb->PCB_PortFileHandle,
                            devicetype,
                            devicename,
                            &((REQTYPECAST*)
                            buffer)->DeviceSetInfo.info) ;
    }
    else
    {
        retcode = ERROR_DEVICE_DOES_NOT_EXIST;
    }

    if(     (retcode == ERROR_SUCCESS)
        &&  (RDT_Tunnel == RAS_DEVICE_CLASS(
            ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType)))
    {
        GetDestIpAddress(ppcb,
                         (RASMAN_DEVICEINFO *) &((REQTYPECAST*)
                         buffer)->DeviceSetInfo.info);
    }

    ((REQTYPECAST*)buffer)->Generic.retcode = retcode ;
}


/*++

Routine Description:

    The ListenConnectRequest() function is called.
    No checks are done on the usage of the port etc.
    its assumed that the caller is trusted.

Arguments:

Return Value:

    Nothing.

--*/
VOID
DeviceConnectRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD retcode ;
    HANDLE handle;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus)
    {
        if (ppcb)
        {
            RasmanTrace(
                   "DeviceConnectRequest: port %d is unavailable",
                   ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }


    handle = ValidateHandleForRasman(
            ((REQTYPECAST*)buffer)->DeviceConnect.handle,
            ((REQTYPECAST*)buffer)->DeviceConnect.pid);

    retcode = ListenConnectRequest(
                         REQTYPE_DEVICECONNECT,
                         ppcb,
                         ((REQTYPECAST*)buffer)->DeviceConnect.devicetype,
                         ((REQTYPECAST*)buffer)->DeviceConnect.devicename,
                         ((REQTYPECAST*)buffer)->DeviceConnect.timeout,
                         handle) ;

    if (retcode != PENDING)
    {
        //
        // Complete the async request if anything other than PENDING
        // This allows the caller to dela with errors only in one place
        //
        CompleteAsyncRequest(ppcb);

        FreeNotifierHandle (
                ppcb->PCB_AsyncWorkerElement.WE_Notifier
                ) ;

        ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                                INVALID_HANDLE_VALUE ;
    }

    else if(    (NULL != ppcb->PCB_Connection)
            &&  (1 == ppcb->PCB_Connection->CB_Ports))
    {
        DWORD dwErr;
        g_RasEvent.Type = ENTRY_CONNECTING;

        dwErr = DwSendNotificationInternal(
                ppcb->PCB_Connection, &g_RasEvent);

        RasmanTrace(
               "DwSendNotificationInternal(ENTRY_CONNECTING) rc=0x%08x",
               dwErr);

        if(RDT_Tunnel_Pptp == RAS_DEVICE_TYPE(
                    ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType))
        {                    
            //
            // If its pptp, cache the interface guid of the interface
            // over which the pptp connection is being made.
            //
            (VOID) DwCacheRefInterface(ppcb);
        }

    }

    RasmanTrace(
           "Connect request on port: %s, error code %d",
           ppcb->PCB_Name, retcode);

    ((REQTYPECAST*)buffer)->Generic.retcode = retcode ;
}



/*++

Routine Description:

    The ListenConnectRequest() function is called. If the async
    operation completed successfully synchronously then the
    port is put in connected state. No checks are done on the
    usage of the port etc. its assumed that the caller is trusted.

Arguments:

Return Value:

    Nothing.

--*/
VOID
DeviceListenRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD retcode ;
    HANDLE handle;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus)
    {
        if ( ppcb )
        {
            RasmanTrace( 
                    "DeviceListenRequest: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Generic.retcode =
                                            ERROR_PORT_NOT_FOUND;

        return;
    }

    handle = ValidateHandleForRasman(
                        ((REQTYPECAST*)buffer)->PortListen.handle,
                        ((REQTYPECAST*)buffer)->PortListen.pid);

    //
    // Clear autoclose flag.
    //
    RasmanTrace(
           "DeviceListenRequest: Clearing Autoclose flag on port %s",
           ppcb->PCB_Name);

    ppcb->PCB_AutoClose = 0;
    ppcb->PCB_RasmanReceiveFlags &= ~(RECEIVE_PPPSTOPPED);

#if UNMAP
    ppcb->PCB_LinkHandle = INVALID_HANDLE_VALUE;
#endif


    // This could be the server trying to post a listen
    //
    if (    (ppcb->PCB_OpenInstances == 2)
        &&  (ppcb->PCB_OwnerPID !=
            ((REQTYPECAST*)buffer)->PortListen.pid))
    {
        //
        // This must be the server trying to post a listen.
        // Fill in the biplex fields in PCB and return PENDING
        // - the actual listen will be posted when the client
        // disconnects:
        //
        ppcb->PCB_BiplexAsyncOpNotifier  = handle ;
        ppcb->PCB_BiplexOwnerPID     =
                    ((REQTYPECAST*)buffer)->PortListen.pid ;

        ppcb->PCB_BiplexUserStoredBlock  = NULL ;

        ppcb->PCB_BiplexUserStoredBlockSize = 0 ;

        ((REQTYPECAST*)buffer)->Generic.retcode = PENDING ;

        ppcb->PCB_PendingReceive = NULL;

        RasmanTrace(
            "DeviceListenRequest: Listen pending on disconnection"
            " of %s", ppcb->PCB_Name);

        return ;
    }

    if(ppcb->PCB_fAmb)
    {

        RasmanTrace(
              "DeviceListen: Bindings of %s=0x%x",
              ppcb->PCB_Name,
              ppcb->PCB_Bindings);

        ppcb->PCB_Bindings = NULL;
        ppcb->PCB_fAmb = FALSE;

    }

    //
    // TODO: Change this to use a different api!!!
    //
    if (    ((REQTYPECAST *)buffer)->PortListen.pid ==
                                    GetCurrentProcessId()
        &&  ((REQTYPECAST *)buffer)->PortListen.handle ==
                                    INVALID_HANDLE_VALUE)
    {
        ppcb->PCB_RasmanReceiveFlags |= RECEIVE_PPPLISTEN;
    }

    ppcb->PCB_PendingReceive = NULL;

    retcode = ListenConnectRequest(
                             REQTYPE_DEVICELISTEN,
                             ppcb,
                             ppcb->PCB_DeviceType,
                             ppcb->PCB_DeviceName,
                             ((REQTYPECAST*)buffer)->PortListen.timeout,
                             handle) ;

    if (retcode != PENDING)
    {
        //
        // Complete the async request if anything other
        // than PENDING This allows the caller to dela
        // with errors only in one place
        //
        CompleteListenRequest (ppcb, retcode) ;
    }


    RasmanTrace(
           "Listen posted on port: %s, error code %d",
           ppcb->PCB_Name, retcode);

    ((REQTYPECAST*)buffer)->Generic.retcode = PENDING ;
}

VOID PortDisconnectRequest(pPCB ppcb, PBYTE buffer)
{
    PortDisconnectRequestInternal(ppcb, buffer, FALSE);
}

/*++

Routine Description:

    Handles the disconnect request. Ends up calling a function
    that is shared for all such requests and does all the work.

Arguments:

Return Value:

    Nothing
--*/
VOID
PortDisconnectRequestInternal(pPCB ppcb, PBYTE buffer, BOOL fDeferred)
{
    HANDLE handle;
    DWORD  curpid = GetCurrentProcessId();
    DWORD dwErr = SUCCESS;

    DWORD pid = ((REQTYPECAST *)buffer)->PortDisconnect.pid;
    RPC_STATUS rpcstatus = RPC_S_OK;
    NTSTATUS ntstatus;
    ULONG SessionId;
    ULONG ReturnLength;
    HANDLE CurrentThreadToken;
    BOOL fAdmin = FALSE;
    BOOL fQueued = FALSE;

    if (NULL == ppcb)
    {
        RasmanTrace(
               "PortDisconnectRequest: PORT_NOT_FOUND");

        ((REQTYPECAST *) buffer)->Generic.retcode =
                    ERROR_PORT_NOT_FOUND;
        return;
    }

    if(!fDeferred)
    {
        handle = ValidateHandleForRasman(
            ((REQTYPECAST*)buffer)->PortDisconnect.handle,
            ((REQTYPECAST*)buffer)->PortDisconnect.pid);
            

        if(     (INVALID_HANDLE_VALUE == handle)
            ||  (NULL == handle))
        {
            ((REQTYPECAST *) buffer)->Generic.retcode =
                E_FAIL;

            return;
        }
    }
    else
    {
        handle = ((REQTYPECAST *)buffer)->PortDisconnect.handle;
    }
        
    //
    // If the owner is the RAS server, then only the RAS
    // server can close it, unless the connection was dialed
    // with the RDEOPT_NoUser flag, which maps to the CALL_LOGON flag.
    //
    if (!fDeferred &&
        ppcb->PCB_OwnerPID == curpid &&
        pid != curpid &&
        !(ppcb->PCB_OpenedUsage & CALL_LOGON) )
    {
        //
        // If this is a dialout connection, check to see if its
        // demand dial. Proceed if it isn't
        //
        if(     (NULL != ppcb->PCB_Connection)
            && (IsRouterPhonebook(ppcb->PCB_Connection->
                        CB_ConnectionParams.CP_Phonebook)))
        {
            ((REQTYPECAST*)buffer)->Generic.retcode =
                                                ERROR_ACCESS_DENIED;

            RasmanTrace(
               "Disconnect request on port %s Failed with error = %d",
               ppcb->PCB_Name, ERROR_ACCESS_DENIED);

            CloseHandle(handle);

            return;
        }
    }

    if(     (DISCONNECTING == ppcb->PCB_ConnState)
        ||  (   !fDeferred
            &&  (INVALID_HANDLE_VALUE != ppcb->PCB_hEventClientDisconnect)
            &&  (NULL != ppcb->PCB_hEventClientDisconnect)))
    {
        ((REQTYPECAST *)buffer)->Generic.retcode = ERROR_ALREADY_DISCONNECTING;

        RasmanTrace(
                "Port %s is already disconnecting",
                ppcb->PCB_Name);

        if(fDeferred)
        {
            SetEvent(handle);
        }
        CloseHandle(handle);
        // ppcb->PCB_hEventClientDisconnect = INVALID_HANDLE_VALUE;
        return;
    }

    if(     !fDeferred
        &&  (NULL != ppcb->PCB_Connection)
        &&  (1 == ppcb->PCB_Connection->CB_Ports))
    {
        DWORD retcode;
        BOOL fQueued = FALSE;

        //
        // The last link in the connection is about to go down.
        // Tell connections folder this connection object is
        // DISCONNECTING. We will give the DISCONNECTED
        // notification when the connection is freed.
        //
        g_RasEvent.Type = ENTRY_DISCONNECTING;
        retcode = DwSendNotificationInternal(ppcb->PCB_Connection, &g_RasEvent);

        RasmanTrace(
               "DwSendNotificationInternal(DISCONNECTING) returned 0x%x",
               retcode);

        QueueCloseConnections(ppcb->PCB_Connection, handle, &fQueued);

        if(fQueued)
        {
            ppcb->PCB_hEventClientDisconnect = handle;
            
            RasmanTrace(
                "Queued close connections from portdisconnectrequest");
            ((REQTYPECAST *)buffer)->Generic.retcode = PENDING;                
            return;
        }
    }


    RasmanTrace(
           "PortDisconnectRequest on %s "
           "Connection=0x%x ,"
           "RasmanReceiveFlags=0x%x",
            ppcb->PCB_Name,
            ppcb->PCB_Connection,
            ppcb->PCB_RasmanReceiveFlags);

    //
    // Do graceful termination under the following conditions
    // 1. Its an outgoing call
    // 2. PPP has started on this call
    // 3. PPP hasn't already stopped.
    //
    if(     (NULL != ppcb->PCB_Connection)
        &&  (ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPSTARTED)
        &&  !(ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPSTOPPED))
    {

        //
        // Call ppp so that it terminates the connection gracefully.
        // Do this only if ppp has started on this port and if this
        // is a client port.
        //
        RasmanTrace(
               "PortDisconnectRequest: hEventClientDisconnect=0x%x",
               handle);

        ppcb->PCB_hEventClientDisconnect = handle;
        dwErr = (DWORD) RasPppHalt(ppcb->PCB_PortHandle);

        RasmanTrace(
               "PortDisconnectRequest: PppStop on %s returned 0x%x",
                ppcb->PCB_Name,
                dwErr);

        //
        // return PENDING if we successfully queued up a StopPpp
        // request with ppp. The actual disconnect will happen
        // when ppp gracefully terminates the connection.
        //

        ((REQTYPECAST *)
        buffer)->Generic.retcode = ((SUCCESS == dwErr) ?
                                     PENDING
                                   : dwErr);
    }
    else
    {
        RasmanTrace(
         
         "PortDisconnectRequest: Disconnecting %s",
        ppcb->PCB_Name);

        ((REQTYPECAST*)
        buffer)->Generic.retcode = DisconnectPort(ppcb,
                                                  handle,
                                                  USER_REQUESTED);
    }

    RasmanTrace(
           "Disconnect request on port: %s",
           ppcb->PCB_Name);
}



/*++

Routine Description:

    Completes an async Disconnect request. It is assumed that the
    disconnect completed successfully.

Arguments:

Return Value:

    Nothing.

--*/
VOID
CompleteDisconnectRequest (pPCB ppcb)
{
    if(NULL == ppcb)
    {
        return;
    }

    SetPortConnState(__FILE__, __LINE__,
                    ppcb, DISCONNECTED);

    ppcb->PCB_ConnectDuration   = 0 ;


    if(PENDING == ppcb->PCB_LastError)
    {
        ppcb->PCB_LastError         = SUCCESS ;
    }

    SetPortAsyncReqType(__FILE__, __LINE__,
                        ppcb, REQTYPE_NONE);

    FlushPcbReceivePackets(ppcb);

    RasmanTrace(
           "CompleteDisconnectRequest: signalling 0x%x for %s",
           ppcb->PCB_AsyncWorkerElement.WE_Notifier,
           ppcb->PCB_Name);

    CompleteAsyncRequest(ppcb);

    FreeNotifierHandle (ppcb->PCB_AsyncWorkerElement.WE_Notifier) ;

    ppcb->PCB_AsyncWorkerElement.WE_Notifier = INVALID_HANDLE_VALUE ;

    //
    // Inform others the port has been disconnected.
    //
    SignalPortDisconnect(ppcb, 0);
    SignalNotifiers(pConnectionNotifierList,
                    NOTIF_DISCONNECT, 0);

    // SignalPortDisconnect notifies ppp
    // SendDisconnectNotificationToPPP( ppcb );

    RasmanTrace(
           "Disconnect completed on port: %s",
           ppcb->PCB_Name);
}

/*++

Routine Description

Arguments:

Return Value:

--*/
VOID
CallPortGetStatistics (pPCB ppcb, BYTE *buffer)
{
    WORD    i ;
    DWORD   retcode = SUCCESS ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus)
    {

        if (ppcb)
        {
            RasmanTrace(
                   "CallPortGetStatistics: port %d is unavailable",
                   ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Generic.retcode =
                                                ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_PortStatus != OPEN)
    {
        ((REQTYPECAST*)buffer)->PortGetStatistics.retcode =
                                                ERROR_PORT_NOT_OPEN ;

        return ;
    }

    if (ppcb->PCB_ConnState == CONNECTED)
    {
        GetStatisticsFromNdisWan (
             ppcb,
             ((REQTYPECAST *)buffer)->PortGetStatistics.
             statbuffer.S_Statistics);

        //
        // Adjust the stat value for the zeroed stats
        //
        for (i = 0; i < MAX_STATISTICS; i++)
        {
            ((REQTYPECAST *)buffer)->PortGetStatistics.statbuffer.
                S_Statistics[i] -=
                ppcb->PCB_BundleAdjustFactor[i] ;
        }
    }
    else
    {
        memcpy (
            ((REQTYPECAST *)buffer)->PortGetStatistics.statbuffer.
            S_Statistics,
            ppcb->PCB_Stats,
            sizeof(DWORD) * MAX_STATISTICS) ;

        //
        // Adjust the stat value for the zeroed stats
        //
        for (i=0; i< MAX_STATISTICS; i++)
        {
            ((REQTYPECAST *)buffer)->PortGetStatistics.statbuffer.
                  S_Statistics[i] -=
                  ppcb->PCB_BundleAdjustFactor[i] ;
        }
    }

    ((REQTYPECAST *)buffer)->PortGetStatistics.statbuffer.
                                S_NumOfStatistics =  MAX_STATISTICS;

    ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;
}

VOID
ComputeStatistics(DWORD *stats, DWORD *statbuffer)
{

    ULONG   ulBXmit;                    // bytes transmitted (computed)
    ULONG   ulBRcved;                   // bytes received (computed)
    ULONG   ulBc;                       // bytes compressed (xmited/rcved)
    ULONG   ulBu;                       // bytes uncompressed (xmited/rcved)
    ULONG   ulBCompressed      = 0;     // compressed bytes
    ULONG   ulBx;                       // bytes transmitted (from ndiswan)
    ULONG   ulBr;                       // bytes received (from ndiswan)
    ULONG   ulCompressionRatio = 0;     // compression ratio (xmit/recv)


    memcpy (statbuffer,
            stats,
            sizeof(DWORD) * MAX_STATISTICS_EXT);

    //
    // compute the bytes xmited values
    //
    ulBXmit = stats[ BYTES_XMITED ] +
              stats[ BYTES_XMITED_UNCOMPRESSED ] -
              stats[ BYTES_XMITED_COMPRESSED ];

    ulBx =  stats[ BYTES_XMITED ];
    ulBu =  stats[ BYTES_XMITED_UNCOMPRESSED ];
    ulBc =  stats[ BYTES_XMITED_COMPRESSED ];

    if (ulBc < ulBu)
    {
        ulBCompressed = ulBu - ulBc;
    }

    if (ulBx + ulBCompressed > 100)
    {
        ULONG ulDen = (ulBx + ulBCompressed) / 100;
        ULONG ulNum = ulBCompressed + (ulDen / 2);
        ulCompressionRatio = ulNum / ulDen;
    }

    statbuffer[ BYTES_XMITED ] = ulBXmit;
    statbuffer[ COMPRESSION_RATIO_OUT ] = ulCompressionRatio;

    //
    // compute the bytes received values
    //
    ulBCompressed       = 0;
    ulCompressionRatio = 0;

    ulBRcved = stats[ BYTES_RCVED ] +
               stats[ BYTES_RCVED_UNCOMPRESSED ] -
               stats[ BYTES_RCVED_COMPRESSED ];

    ulBr    = stats[ BYTES_RCVED ];
    ulBu    = stats[ BYTES_RCVED_UNCOMPRESSED ];
    ulBc    = stats[ BYTES_RCVED_COMPRESSED ];

    if (ulBc < ulBu)
        ulBCompressed = ulBu - ulBc;

    if (ulBr + ulBCompressed > 100)
    {
         ULONG ulDen = (ulBr + ulBCompressed) / 100;
         ULONG ulNum = ulBCompressed + (ulDen / 2);
         ulCompressionRatio = ulNum / ulDen;
    }

    statbuffer[ BYTES_RCVED ] = ulBRcved;
    statbuffer[ COMPRESSION_RATIO_IN ] = ulCompressionRatio;

    return;
}

VOID
GetLinkStatisticsEx(pPCB ppcb,
                    PBYTE pbStats)
{
    DWORD stats[MAX_STATISTICS];
    DWORD i;

    if (CONNECTED == ppcb->PCB_ConnState)
    {
        DWORD AllStats[MAX_STATISTICS_EX];

        GetStatisticsFromNdisWan (ppcb, AllStats);

        memcpy (stats,
                &AllStats[MAX_STATISTICS],
                MAX_STATISTICS * sizeof(DWORD));

        //
        // adjust the statistics before doing the computation
        //
        for (i = 0; i < MAX_STATISTICS; i++)
        {
            stats[i] -= ppcb->PCB_AdjustFactor[i] ;
        }
    }
    else
    {
        memcpy (stats,
                ppcb->PCB_Stats,
                sizeof(DWORD) * MAX_STATISTICS);
    }

    //
    // calculate the values rasman needs to calculate for
    // the client
    //
    ComputeStatistics(stats, (DWORD *) pbStats);

    return;
}

VOID
GetBundleStatisticsEx(pPCB ppcb,
                      PBYTE pbStats)
{
    DWORD i;
    DWORD stats[MAX_STATISTICS];

    if(NULL == ppcb)
    {
        return;
    }

    if (ppcb->PCB_ConnState == CONNECTED)
    {
        GetBundleStatisticsFromNdisWan (ppcb, stats);

        //
        // Adjust the stat value for the zeroed stats
        //
        for (i = 0; i < MAX_STATISTICS; i++)
        {
            stats[i] -= ppcb->PCB_BundleAdjustFactor[i] ;
        }
    }
    else
    {
        memcpy (stats,
                ppcb->PCB_Stats,
                sizeof(DWORD) * MAX_STATISTICS) ;
    }

    //
    // compute the compression ratios
    // calculate the values rasman needs
    // to calculate for the client
    //
    ComputeStatistics(stats, (DWORD *) pbStats);

    return;
}

VOID
CallPortGetStatisticsEx (pPCB ppcb, BYTE *buffer)
{
    WORD    i;
    DWORD   retcode;

    if (    NULL == ppcb
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                   "CallPortGetStatisticsEx: port %d is "
                   "unavailable", ppcb->PCB_PortHandle);
        }

        ((REQTYPECAST *) buffer)->Generic.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }

    if (OPEN != ppcb->PCB_PortStatus)
    {
        ((REQTYPECAST *)buffer)->PortGetStatistics.retcode =
                                        ERROR_PORT_NOT_OPEN;
        return;
    }

    GetLinkStatisticsEx(ppcb,
                        (PBYTE) ((REQTYPECAST *)
                        buffer)->PortGetStatistics.
                        statbuffer.S_Statistics);

    ((REQTYPECAST *)buffer)->PortGetStatistics.statbuffer.
                    S_NumOfStatistics = MAX_STATISTICS_EXT;

    ((REQTYPECAST *)buffer)->Generic.retcode = SUCCESS;

    return;

}

VOID
CallBundleGetStatisticsEx (pPCB ppcb, BYTE *buffer)
{
    WORD    i ;
    DWORD   retcode = SUCCESS ;

    if (ppcb == NULL)
    {
        ((REQTYPECAST *)buffer)->PortGetStatistics.retcode =
                                ERROR_PORT_NOT_FOUND;
        return;
    }


    if (ppcb->PCB_PortStatus != OPEN)
    {
        ((REQTYPECAST*)buffer)->PortGetStatistics.retcode =
                                        ERROR_PORT_NOT_OPEN ;

        return ;
    }

    GetBundleStatisticsEx(ppcb,
                         (PBYTE) ((REQTYPECAST *)
                         buffer)->PortGetStatistics.
                         statbuffer.S_Statistics);

    ((REQTYPECAST *)buffer)->PortGetStatistics.statbuffer.
                            S_NumOfStatistics = MAX_STATISTICS_EXT;

    ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;

    return;

}


/*++

Routine Description:

    Calls the media dll to clear stats on the port.

Arguments:

Return Value:

    Nothing

--*/
VOID
PortClearStatisticsRequest (pPCB ppcb, PBYTE buffer)
{
    WORD    i ;
    DWORD   stats[MAX_STATISTICS_EX] ;
    DWORD   retcode = SUCCESS ;

    if (ppcb == NULL)
    {
        ((REQTYPECAST *)buffer)->Generic.retcode =
                                    ERROR_PORT_NOT_FOUND;
        return;
    }

    BundleClearStatisticsRequest(ppcb, buffer);
}

/*++

Routine Description:

Arguments:

Return Value:

--*/
VOID
CallBundleGetStatistics (pPCB ppcb, BYTE *buffer)
{
    WORD    i ;
    DWORD   retcode = SUCCESS ;

    if (ppcb == NULL)
    {
        ((REQTYPECAST *)buffer)->PortGetStatistics.retcode =
                                ERROR_PORT_NOT_FOUND;
        return;
    }


    if (ppcb->PCB_PortStatus != OPEN)
    {
        ((REQTYPECAST*)
        buffer)->PortGetStatistics.retcode = ERROR_PORT_NOT_OPEN;

        return ;
    }

    if (ppcb->PCB_ConnState == CONNECTED)
    {
        GetStatisticsFromNdisWan (
                    ppcb,
                    ((REQTYPECAST *)buffer)->PortGetStatistics.
                    statbuffer.S_Statistics
                    );

        //
        // Adjust the stat value for the zeroed stats
        //
        for (i = 0; i < MAX_STATISTICS; i++)
        {
            ((REQTYPECAST *)
            buffer)->PortGetStatistics.statbuffer.S_Statistics[i]
            -= ppcb->PCB_BundleAdjustFactor[i] ;
        }

        for (i = 0; i < MAX_STATISTICS; i++)
        {
            ((REQTYPECAST *)
            buffer)->PortGetStatistics.
            statbuffer.S_Statistics[i + MAX_STATISTICS]
            -= ppcb->PCB_AdjustFactor[i] ;
        }
    }
    else
    {
        memcpy (((REQTYPECAST *)
                buffer)->PortGetStatistics.statbuffer.S_Statistics,
                ppcb->PCB_Stats,
                sizeof(DWORD) * MAX_STATISTICS) ;

        memcpy (&((REQTYPECAST *)
                buffer)->PortGetStatistics.statbuffer.
                S_Statistics[MAX_STATISTICS],
                ppcb->PCB_Stats,
                sizeof(DWORD) * MAX_STATISTICS) ;

        //
        // Adjust the stat value for the zeroed stats
        //
        for (i = 0; i < MAX_STATISTICS_EX; i++)
        {
            ((REQTYPECAST *)
            buffer)->PortGetStatistics.statbuffer.S_Statistics[i] -=
            ppcb->PCB_BundleAdjustFactor[i % MAX_STATISTICS] ;
        }
    }

    ((REQTYPECAST *)
    buffer)->PortGetStatistics.statbuffer.S_NumOfStatistics =
                                    MAX_STATISTICS_EX ;

    ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;

}

/*++

Routine Description:

    Clear the statistics for a bundle.

Arguments:

Return Value:

--*/
VOID
BundleClearStatisticsRequest (pPCB ppcb, PBYTE buffer)
{
    WORD    i ;
    DWORD   stats[MAX_STATISTICS_EX] ;
    DWORD   retcode = SUCCESS ;
    ULONG   j;
    pPCB    ppcbT;

    if (ppcb == NULL)
    {
        ((REQTYPECAST *)buffer)->Generic.retcode =
                                ERROR_PORT_NOT_FOUND;

        return;
    }

    if (ppcb->PCB_PortStatus != OPEN)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                ERROR_PORT_NOT_OPEN;

        return ;
    }

    if (ppcb->PCB_ConnState == CONNECTED)
    {
        GetStatisticsFromNdisWan (ppcb, stats) ;

        //
        // Adjust the stat value for the zeroed stats
        //
        for (j = 0; j < MaxPorts; j++)
        {
            //
            // Adjust the bundle stat value for all
            // connected ports in the bundle
            //
            ppcbT = GetPortByHandle((HPORT) UlongToPtr(j));
            if (NULL == ppcbT)
            {
                continue;
            }

            if (    (ppcbT->PCB_ConnState == CONNECTED)
                &&  (ppcbT->PCB_Bundle->B_Handle ==
                                ppcb->PCB_Bundle->B_Handle))
            {
                memcpy(ppcbT->PCB_BundleAdjustFactor,
                       stats,
                       MAX_STATISTICS * sizeof (DWORD));
            }
        }

        for(i = 0; i < MAX_STATISTICS; i++)
        {
            ppcb->PCB_AdjustFactor[i] = stats[i + MAX_STATISTICS] ;
        }
    }
    else
    {
        memset(ppcb->PCB_Stats,
               0,
               sizeof(DWORD) * MAX_STATISTICS) ;

        memset (ppcb->PCB_BundleAdjustFactor,
                0,
                sizeof(DWORD) * MAX_STATISTICS) ;

        memset (ppcb->PCB_AdjustFactor,
                0,
                sizeof(DWORD) * MAX_STATISTICS) ;

        ppcb->PCB_LinkSpeed = 0;
    }

    ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;
}

/*++

Routine Description:

    Allocate the requested route if it exists - also make it
    into a wrknet if so desired.

Arguments:

Return Value:

    Nothing

--*/
VOID
AllocateRouteRequest (pPCB ppcb, BYTE *buffer)
{
    WORD        i ;
    DWORD       retcode ;
    pProtInfo   pprotinfo = NULL;
    pList       newlist ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus)
    {
        if ( ppcb )
        {
            RasmanTrace(
                   "AllocateRouteRequest: port %d is unavailable",
                   ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Route.retcode =
                                            ERROR_PORT_NOT_FOUND;
        return;
    }

    //
    // Look for a matching protocol:
    //
    for (i = 0,
        pprotinfo = &ProtocolInfo[0];
        i < MaxProtocols; i++, pprotinfo++)
    {
        //
        // For ASYBEUI routes look for a unallocated block
        //
        if (((REQTYPECAST*)buffer)->AllocateRoute.type == ASYBEUI)
        {
            if(     (pprotinfo->PI_Allocated == FALSE)
                &&  (pprotinfo->PI_Type ==
                        ((REQTYPECAST*)buffer)->AllocateRoute.type)

                &&  (((REQTYPECAST*)buffer)->AllocateRoute.wrknet ==
                                        pprotinfo->PI_WorkstationNet))
            {
                break ;
            }
        }

    }

    if (    ((REQTYPECAST*)buffer)->AllocateRoute.type == ASYBEUI
        &&  i == MaxProtocols )
    {
        retcode = ERROR_ROUTE_NOT_AVAILABLE ;
    }

    //
    // Before we use this "route" let us allocate the necessary
    // storage: This is the "list" element used to keep a
    // port->protocol used linkage
    //
    else if ((newlist = (pList) LocalAlloc(LPTR,
                            sizeof(List))) == NULL)
    {
        retcode = GetLastError () ;
    }
    else
    {

        if ( ((REQTYPECAST*)buffer)->AllocateRoute.type == ASYBEUI )
        {
            //
            // Mark the route allocated and copy the route info:
            //
            pprotinfo->PI_Allocated++ ;

            g_cNbfAllocated += 1;

            RasmanTrace(
                   "AllocateRouteRequest: cNbfAllocated = %d",
                   g_cNbfAllocated);

            //
            // Also mark the route as dial-out or dial-in so that
            // deallocate route can do the right thing
            //
            if(NULL != ppcb->PCB_Connection)
            {
                RasmanTrace(
                       "AllocateRouteRequest: marking asybeui dialout");
                pprotinfo->PI_DialOut = TRUE;
            }
            else
            {
                RasmanTrace(
                       "AllocateRouteRequest: marking asybeui for dialin");
                pprotinfo->PI_DialOut = FALSE;
            }

            pprotinfo->PI_WorkstationNet =
                    ((REQTYPECAST *)buffer)->AllocateRoute.wrknet ;

            //
            // This will be valid only for netbios nets.
            //
            ((REQTYPECAST*)buffer)->Route.info.RI_LanaNum =
                                        pprotinfo->PI_LanaNumber;

            ((REQTYPECAST*)buffer)->Route.info.RI_Type =
                                                pprotinfo->PI_Type;

            mbstowcs (
                ((REQTYPECAST *)buffer)->Route.info.RI_XportName,
                  pprotinfo->PI_XportName,
                  strlen (pprotinfo->PI_XportName)) ;

            mbstowcs (
                ((REQTYPECAST *)buffer)->Route.info.RI_AdapterName,
                  pprotinfo->PI_AdapterName,
                  strlen (pprotinfo->PI_AdapterName)) ;

            ((REQTYPECAST*)buffer)->Route.info.
                RI_AdapterName[strlen(pprotinfo->PI_AdapterName)] =
                    UNICODE_NULL ;

            ((REQTYPECAST*)buffer)->Route.info.
                RI_XportName[strlen(pprotinfo->PI_XportName)] =
                    UNICODE_NULL ;
        }
        else
        {
            pprotinfo = (pProtInfo) LocalAlloc(LPTR,
                                    sizeof (ProtInfo));

            if ( NULL == pprotinfo )
            {
                retcode = GetLastError();
                LocalFree(newlist);
                goto done;
            }

            pprotinfo->PI_Type =
                (((REQTYPECAST*)buffer)->AllocateRoute.type);

            pprotinfo->PI_AdapterName[0] = '\0';
        }

        //
        // Attach the allocated protocol binding to the list of
        // bindings for the port. This is necessary for
        // deallocation on a per-port basis.
        //
        newlist->L_Element = pprotinfo ;

        //
        // If this port has been bundled - attach the allocated
        // list to the bundle else attach it to the port's binding
        // list.
        //
        if (ppcb->PCB_Bundle == (Bundle *) NULL)
        {
            newlist->L_Next    = ppcb->PCB_Bindings ;
            ppcb->PCB_Bindings = newlist ;
        }
        else
        {
            newlist->L_Next    = ppcb->PCB_Bundle->B_Bindings;
            ppcb->PCB_Bundle->B_Bindings = newlist ;
        }

        if(((REQTYPECAST*)buffer)->AllocateRoute.type == ASYBEUI)
        {
            if(NULL != ppcb->PCB_Connection)
            {
                //
                // Increase the InUse count for NbfOut
                //
                if(g_pEpInfo[NbfOut].EP_Available > 0)
                {
                    InterlockedIncrement(
                        &g_plCurrentEpInUse[NbfOut]
                        );

                    RasmanTrace(
                           " New InUse for NbfOut=0%d\n",
                           g_plCurrentEpInUse[NbfOut]);
                }
            }
            else
            {
                //
                // Increase the InUse count for NbfIn
                //
                if(g_pEpInfo[NbfIn].EP_Available > 0)
                {
                    InterlockedIncrement(
                        &g_plCurrentEpInUse[NbfIn]
                        );

                    RasmanTrace(
                           " New InUse for NbfIn=0%d\n",
                           g_plCurrentEpInUse[NbfIn]);
                }
            }

            //
            // Add endpoints if required
            //
            retcode = DwAddEndPointsIfRequired();

            RasmanTrace(
                   "DwAddEndPointsIfRequired returned rc=%d",
                   retcode);
        }

        retcode = SUCCESS ;
    }

done:
    ((REQTYPECAST *)buffer)->Route.retcode = retcode ;
}

VOID
SendPppMessageToRasmanRequest(pPCB ppcb, LPBYTE buffer)
{
    ((REQTYPECAST *)buffer)->Generic.retcode =
        SendPPPMessageToRasman(&(((REQTYPECAST *) buffer)->PppMsg));
}


/*++

Routine Description:

    Deallocates a previously allocate route - if this route
    had been Activated it will be de-activated at this point.
    Similarly, if this was made into a wrknet, it will be
    "unwrknetted"!

Arguments:

Return Value:

    Nothing
--*/
VOID
DeAllocateRouteRequest (pPCB ppcb, PBYTE buffer)
{
    ((REQTYPECAST *)buffer)->Generic.retcode =
                DeAllocateRouteRequestCommon(
                    ((REQTYPECAST *)buffer)->DeAllocateRoute.hbundle,
                    ((REQTYPECAST *)buffer)->DeAllocateRoute.type);

    //
    // We need to do this here for the asybeui/amb/callback
    // case.
    //
    // ppcb->PCB_Bindings = NULL;
}

/*++

Routine Description:

    Deallocates a previously allocate route - if this
    route had been Activated it will be de-activated at this
    point. Similarly, if this was made into a wrknet, it will
    be "unwrknetted"!

Arguments:

Return Value:

--*/
DWORD
DeAllocateRouteRequestCommon (HBUNDLE hbundle, RAS_PROTOCOLTYPE prottype)
{
    DWORD   dwErr = SUCCESS;
    Bundle *pBundle;
    pList   list ;
    pList   prev ;
    pList   *pbindinglist ;
    DWORD   retcode;

    pBundle = FindBundle(hbundle);
    if (pBundle == NULL)
    {
        dwErr = ERROR_PORT_NOT_FOUND ;
        goto done;
    }

    RasmanTrace(
           "DeallocateRouteRequestCommon: pBundle=0x%x, type=%d\n",
           pBundle, prottype);

    pbindinglist = &pBundle->B_Bindings ;

    //
    // Find the route structure for the specified protocol.
    //
    if (*pbindinglist == NULL)
    {
        dwErr = ERROR_ROUTE_NOT_ALLOCATED ;
        goto done;
    }

    else if (((pProtInfo)
              ((pList)*pbindinglist)->L_Element)->PI_Type ==
                                                    prottype)
    {
        list = *pbindinglist ;
        *pbindinglist = list->L_Next ;

    }
    else
    {
        for (prev = *pbindinglist, list = prev->L_Next;
            list != NULL;
            prev = list, list = list->L_Next)
        {

            if (((pProtInfo)list->L_Element)->PI_Type == prottype)
            {
                prev->L_Next = list->L_Next ;
                break ;
            }

        }
    }

    //
    // list should only be NULL if the route was not found:
    //
    if (list == NULL)
    {
        dwErr = ERROR_ROUTE_NOT_ALLOCATED ;
        goto done ;
    }

    // Deallocate the route
    //
    DeAllocateRoute (pBundle, list) ;

    if (ASYBEUI != ((pProtInfo) list->L_Element)->PI_Type)
    {
        if(IP == ((pProtInfo) list->L_Element)->PI_Type)
        {
            if(((pProtInfo) list->L_Element)->PI_DialOut)
            {
                RasmanTrace(
                       "DeAlloc..: increasing the avail. count for IP");

                ASSERT(g_plCurrentEpInUse[IpOut] > 0);

                if(g_plCurrentEpInUse[IpOut] > 0)
                {
                    //
                    // Decrease the InUse count for IpOut
                    //
                    InterlockedDecrement(&g_plCurrentEpInUse[IpOut]);

                    RasmanTrace(
                           "  NewInUse for IpOut = %d",
                           g_plCurrentEpInUse[IpOut]);
                }
            }
        }


        //
        // We allocated this in AllocateRouteRequest
        //
        LocalFree ( list->L_Element );
    }
    else
    {
        if(((pProtInfo) list->L_Element)->PI_DialOut)
        {
            if(g_plCurrentEpInUse[NbfOut] > 0)
            {
            //
            // Decrease the InUse count for NbfOut
            //
            InterlockedDecrement(&g_plCurrentEpInUse[NbfOut]);

            RasmanTrace(
                   "  NewInUse for NbfOut = %d",
                   g_plCurrentEpInUse[NbfOut]);

            }
        }
        else
        {
            if(g_plCurrentEpInUse[NbfIn] > 0)
            {
            //
            // Decrease the InUse count for NbfIn
            //
            InterlockedDecrement(&g_plCurrentEpInUse[NbfIn]);

            RasmanTrace(
                   "  NewInUse for NbfIn = %d",
                   g_plCurrentEpInUse[NbfIn]);

            }
        }
    }

    LocalFree (list) ;  // free the list element

    //
    // If there are no bindings left,
    // then unlink and free the bundle.
    // Free the bundle only if number of
    // ports in this bundle is NULL.
    //
    if (    *pbindinglist == NULL
        &&  pBundle->B_Count == 0)
    {
        FreeBundle(pBundle);
    }

    if(ASYBEUI != prottype)
    {
        //
        // Remove endpoints if required.
        //
        retcode = DwRemoveEndPointsIfRequired();

        if(ERROR_SUCCESS != retcode)
        {
            RasmanTrace(
                   "DeAllocateRoute: failed to remove endpoints. 0x%x",
                    retcode);
        }
    }
    else
    {
        RasmanTrace(
               "DeAllocateRoute: Not removing endpoints for asybeui.");
    }


done:
    return dwErr;
}


/*++

Routine Description:

    Copy the PCB fields necessary to fill a
    RASMAN_PORT structure.  The PCB lock is
    assumed to be acquired.

Arguments:

Return Value:

    Nothing.

--*/
VOID
CopyPort(
    PCB *ppcb,
    RASMAN_PORT UNALIGNED *pPort,
    BOOL f32
    )
{
    
    if(f32)
    {
        RASMAN_PORT_32 UNALIGNED *pPort32 = (RASMAN_PORT_32 *) pPort;
        
        pPort32->P_Port = HandleToUlong(ppcb->PCB_PortHandle);
        memcpy ((CHAR UNALIGNED *) pPort32->P_PortName,
                ppcb->PCB_Name,
                MAX_PORT_NAME) ;

        pPort32->P_Status = ppcb->PCB_PortStatus ;

        pPort32->P_CurrentUsage = ppcb->PCB_CurrentUsage ;

        pPort32->P_ConfiguredUsage = ppcb->PCB_ConfiguredUsage ;

        pPort32->P_rdtDeviceType =
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType;

        memcpy ((CHAR UNALIGNED *) pPort32->P_MediaName,
                ppcb->PCB_Media->MCB_Name,
                MAX_MEDIA_NAME);

        memcpy ((CHAR UNALIGNED *) pPort32->P_DeviceType,
                ppcb->PCB_DeviceType,
                MAX_DEVICETYPE_NAME);

        memcpy((CHAR UNALIGNED *) pPort32->P_DeviceName,
               ppcb->PCB_DeviceName,
               MAX_DEVICE_NAME+1) ;

        pPort32->P_LineDeviceId = ppcb->PCB_LineDeviceId ;

        pPort32->P_AddressId    = ppcb->PCB_AddressId ;
    }
    else
    {
        pPort->P_Handle = ppcb->PCB_PortHandle;
        memcpy ((CHAR UNALIGNED *) pPort->P_PortName,
                ppcb->PCB_Name,
                MAX_PORT_NAME) ;

        pPort->P_Status = ppcb->PCB_PortStatus ;

        pPort->P_CurrentUsage = ppcb->PCB_CurrentUsage ;

        pPort->P_ConfiguredUsage = ppcb->PCB_ConfiguredUsage ;

        pPort->P_rdtDeviceType =
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType;

        memcpy ((CHAR UNALIGNED *) pPort->P_MediaName,
                ppcb->PCB_Media->MCB_Name,
                MAX_MEDIA_NAME);

        memcpy ((CHAR UNALIGNED *) pPort->P_DeviceType,
                ppcb->PCB_DeviceType,
                MAX_DEVICETYPE_NAME);

        memcpy((CHAR UNALIGNED *) pPort->P_DeviceName,
               ppcb->PCB_DeviceName,
               MAX_DEVICE_NAME+1) ;

        pPort->P_LineDeviceId = ppcb->PCB_LineDeviceId ;

        pPort->P_AddressId    = ppcb->PCB_AddressId ;
    }
    
}


/*++

Routine Description:

    The actual work for this request is done here.
    The information will always fit into the buffers
    passed in. The actual checking of the user buffer
    sizes is done in the context of the user
    process.

Arguments:

Return Value:

    Nothing.

--*/
VOID
EnumPortsRequest (pPCB ppcb, PBYTE reqbuffer)
{
    ULONG           i;
    DWORD           dwcPorts = 0 ;
    RASMAN_PORT_32 UNALIGNED *pbuf ;
    BYTE UNALIGNED *buffer = ((REQTYPECAST*)reqbuffer)->Enum.buffer ;
    DWORD           dwSize = ((REQTYPECAST*)reqbuffer)->Enum.size;

    //
    // We copy all the information into the buffers which are
    // guaranteed to be big enough:
    //
    for (i = 0, pbuf = (RASMAN_PORT_32 *) buffer; i < MaxPorts; i++)
    {
        ppcb = GetPortByHandle((HPORT) UlongToPtr(i));

        if (ppcb != NULL)
        {

            if (ppcb->PCB_PortStatus != REMOVED)
            {
                if ( dwSize >= sizeof(RASMAN_PORT_32) )
                {
                    CopyPort(ppcb, (RASMAN_PORT UNALIGNED *) pbuf, TRUE);

                    pbuf++;

                    dwSize -= sizeof(RASMAN_PORT_32);
                }

                dwcPorts++;
            }
        }
    }

    ((REQTYPECAST*)reqbuffer)->Enum.entries = dwcPorts ;

    ((REQTYPECAST*)reqbuffer)->Enum.size    =
                        dwcPorts * sizeof(RASMAN_PORT_32) ;

    ((REQTYPECAST*)reqbuffer)->Enum.retcode = SUCCESS ;
}

/*++

Routine Description:

    Does the real work of enumerating the protocols; this
    info will be copied into the user buffer when the
    request completes.

Arguments:

Return Value:

    Nothing

--*/
VOID
EnumProtocols (pPCB ppcb, PBYTE reqbuffer)
{
    DWORD     i ;

    RASMAN_PROTOCOLINFO UNALIGNED *puserbuffer ;

    DWORD    dwSize = ( (REQTYPECAST *) reqbuffer )->Enum.size;

    //
    // pointer to next protocol info struct to fill
    //
    puserbuffer = (RASMAN_PROTOCOLINFO UNALIGNED *)
            ((REQTYPECAST *) reqbuffer)->Enum.buffer;

    for(i = 0; i < MaxProtocols; i++)
    {
        if ( dwSize >= sizeof(RASMAN_PROTOCOLINFO) )
        {
            strcpy ( puserbuffer->PI_XportName,
                     ProtocolInfo[i].PI_XportName ) ;

            puserbuffer->PI_Type = ProtocolInfo[i].PI_Type ;

            puserbuffer++ ;

            dwSize -= sizeof(RASMAN_PROTOCOLINFO);
        }
    }

    ((REQTYPECAST*)reqbuffer)->Enum.entries = i ;

    ((REQTYPECAST*)
    reqbuffer)->Enum.size    = i * sizeof (RASMAN_PROTOCOLINFO) ;

    ((REQTYPECAST*)reqbuffer)->Enum.retcode = SUCCESS ;
}


VOID
CopyInfo(
    pPCB ppcb,
    RASMAN_INFO UNALIGNED *pInfo
    )
{
    pInfo->RI_PortStatus = ppcb->PCB_PortStatus ;

    pInfo->RI_ConnState  = ppcb->PCB_ConnState ;

    pInfo->RI_LastError  = ppcb->PCB_LastError ;

    pInfo->RI_CurrentUsage = ppcb->PCB_CurrentUsage ;

    pInfo->RI_OwnershipFlag = ppcb->PCB_OwnerPID ;

    pInfo->RI_LinkSpeed  = ppcb->PCB_LinkSpeed ;

    pInfo->RI_BytesReceived= ppcb->PCB_BytesReceived ;

    strcpy (pInfo->RI_DeviceConnecting,
            ppcb->PCB_DeviceConnecting) ;

    strcpy (pInfo->RI_DeviceTypeConnecting,
            ppcb->PCB_DeviceTypeConnecting) ;

    strcpy (pInfo->RI_szDeviceName,
            ppcb->PCB_DeviceName);

    strcpy (pInfo->RI_szPortName,
            ppcb->PCB_Name);

    strcpy (pInfo->RI_szDeviceType,
            ppcb->PCB_DeviceType);

    pInfo->RI_rdtDeviceType =
        ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType;

    pInfo->RI_DisconnectReason = ppcb->PCB_DisconnectReason ;

    if (ppcb->PCB_ConnState == CONNECTED)
    {
        pInfo->RI_ConnectDuration =
                GetTickCount() - ppcb->PCB_ConnectDuration ;
    }

    //
    // Copy the phonebook and entry strings from
    // the port if they are different from the
    // connection's.
    //
    if (ppcb->PCB_Connection != NULL)
    {
        strcpy(
          pInfo->RI_Phonebook,
          ppcb->PCB_Connection->CB_ConnectionParams.CP_Phonebook);

        strcpy(
          pInfo->RI_PhoneEntry,
          ppcb->PCB_Connection->CB_ConnectionParams.CP_PhoneEntry);

        pInfo->RI_ConnectionHandle =
                    ppcb->PCB_Connection->CB_Handle;

        pInfo->RI_SubEntry = ppcb->PCB_SubEntry;

        memcpy(&pInfo->RI_GuidEntry,
               &ppcb->PCB_Connection->CB_GuidEntry,
               sizeof(GUID));
    }
    else
    {
        *pInfo->RI_Phonebook = '\0';

        *pInfo->RI_PhoneEntry = '\0';

        pInfo->RI_ConnectionHandle = 0;

        pInfo->RI_SubEntry = 0;

        ZeroMemory(&pInfo->RI_GuidEntry, sizeof(GUID));
    }

    pInfo->RI_dwSessionId = ppcb->PCB_LogonId;

    pInfo->RI_dwFlags = 0;
    
    if(     (NULL != ppcb->PCB_Connection)
        &&  (CONNECTION_DEFAULT_CREDS & ppcb->PCB_Connection->CB_Flags))
    {
        pInfo->RI_dwFlags = RASMAN_DEFAULT_CREDS;
    }

    if(ppcb->PCB_OpenedUsage & CALL_OUT)
    {
        pInfo->RI_dwFlags |= RASMAN_OPEN_CALLOUT;
    }
}


/*++

Routine Description:

    Gets the "general" info for the port; this info will
    be copied into the user buffer when the request
    completes.

Arguments:

Return Value:

    Nothing

--*/
VOID
GetInfoRequest (pPCB ppcb, PBYTE buffer)
{
    RASMAN_INFO UNALIGNED *info = &((REQTYPECAST*)buffer)->Info.info ;
    DWORD retcode = SUCCESS;

    if (ppcb == NULL)
    {
        ((REQTYPECAST *)buffer)->Info.retcode = ERROR_PORT_NOT_FOUND;
        return;
    }

    if (ppcb->PCB_PortStatus != OPEN)
    {
        retcode = ERROR_PORT_NOT_OPEN ;
    }

    //
    // Copy infomation from the PCB into the buffer supplied ;
    //
    CopyInfo(ppcb, info);

    ((REQTYPECAST*)buffer)->Info.retcode = retcode ;
}

/*++

Routine Description:

    Gets the "general" info for all the ports; this info will
    be copied into the user buffer when the request completes.

Arguments:

Return Value:

    Nothing

--*/
VOID
GetInfoExRequest (pPCB ppcb, PBYTE buffer)
{
    RASMAN_INFO UNALIGNED *info = (RASMAN_INFO UNALIGNED *) 
                        &((REQTYPECAST*)buffer)->InfoEx.info ;

    DWORD pid = ((REQTYPECAST*)buffer)->InfoEx.pid;

    ULONG   i;
    DWORD   dwcPorts = 0 ;

    for (i = 0, info = &((REQTYPECAST*)buffer)->InfoEx.info;
         i < MaxPorts;
         i++, info++)
    {
        ppcb = GetPortByHandle((HPORT) UlongToPtr(i));
        if (ppcb != NULL)
        {
            CopyInfo(ppcb, info);

            //
            // Set the OwnershipFlag in the GetInfo structure
            // to tell us whether the caller owns the port or not.
            //
            info->RI_OwnershipFlag = (info->RI_OwnershipFlag == pid);
            dwcPorts++;
        }
    }

    ((REQTYPECAST*)buffer)->InfoEx.count = dwcPorts ;
    ((REQTYPECAST*)buffer)->InfoEx.retcode = SUCCESS ;
}


VOID
GetUserCredentials (pPCB ppcb, PBYTE buffer)
{
    PBYTE  pChallenge =
                    ((REQTYPECAST*)buffer)->GetCredentials.Challenge ;

    PLUID LogonId = &((REQTYPECAST*)buffer)->GetCredentials.LogonId ;

    PCHAR UserName = (PCHAR)
                    ((REQTYPECAST*)buffer)->GetCredentials.UserName ;

    PBYTE  CaseSensitiveChallengeResponse =
        ((REQTYPECAST*)buffer)->GetCredentials.CSCResponse ;

    PBYTE  CaseInsensitiveChallengeResponse =
        ((REQTYPECAST*)buffer)->GetCredentials.CICResponse ;

    DWORD dwChallengeResponseRequestLength;

    DWORD dwChallengeResponseLength;

    MSV1_0_GETCHALLENRESP_REQUEST ChallengeResponseRequest;

    PMSV1_0_GETCHALLENRESP_RESPONSE pChallengeResponse;

    NTSTATUS status;

    NTSTATUS substatus;

    dwChallengeResponseRequestLength =
                            sizeof(MSV1_0_GETCHALLENRESP_REQUEST);

    ChallengeResponseRequest.MessageType =
                            MsV1_0Lm20GetChallengeResponse;

    ChallengeResponseRequest.ParameterControl =
         RETURN_PRIMARY_LOGON_DOMAINNAME | RETURN_PRIMARY_USERNAME | USE_PRIMARY_PASSWORD;

    ChallengeResponseRequest.LogonId = *LogonId;

    ChallengeResponseRequest.Password.Length = 0;

    ChallengeResponseRequest.Password.MaximumLength = 0;

    ChallengeResponseRequest.Password.Buffer = NULL;

    RtlMoveMemory(ChallengeResponseRequest.ChallengeToClient,
                  pChallenge, (DWORD) MSV1_0_CHALLENGE_LENGTH);

    status = LsaCallAuthenticationPackage(HLsa,
                                        AuthPkgId,
                                        &ChallengeResponseRequest,
                                        dwChallengeResponseRequestLength,
                                        (PVOID *) &pChallengeResponse,
                                        &dwChallengeResponseLength,
                                        &substatus);

    if (    (status != STATUS_SUCCESS)
        ||  (substatus != STATUS_SUCCESS))
    {
         ((REQTYPECAST*)buffer)->GetCredentials.retcode = 1 ;
    }
    else
    {
    	DWORD dwuNameOffset = 0;
    	if ( pChallengeResponse->LogonDomainName.Length > 0 )
    	{
    		WCHAR		* pwszSeparator = L"\\";
    		
    		RtlMoveMemory( 	UserName, 
    						pChallengeResponse->LogonDomainName.Buffer,
    						pChallengeResponse->LogonDomainName.Length
    					 );
    					 
    		lstrcpyW ( 	(WCHAR *)(&UserName[pChallengeResponse->LogonDomainName.Length]),
		    			pwszSeparator
		    		 );
    				
    		dwuNameOffset = pChallengeResponse->LogonDomainName.Length + 
    							lstrlenW(pwszSeparator) * sizeof(WCHAR);
    				      				  
    	}
        RtlMoveMemory(	UserName + dwuNameOffset, 
        				pChallengeResponse->UserName.Buffer,
                 		pChallengeResponse->UserName.Length
                 	 );
        UserName[pChallengeResponse->UserName.Length + dwuNameOffset] = '\0';
        UserName[pChallengeResponse->UserName.Length+ dwuNameOffset + 1] = '\0';

        if(NULL !=
           pChallengeResponse->CaseInsensitiveChallengeResponse.Buffer)
        {

            RtlMoveMemory(CaseInsensitiveChallengeResponse,
                 pChallengeResponse->CaseInsensitiveChallengeResponse.Buffer,
                 SESSION_PWLEN);
        }
        else
        {
            ZeroMemory(CaseInsensitiveChallengeResponse,
                       SESSION_PWLEN);

        }

        if(NULL !=
           pChallengeResponse->CaseSensitiveChallengeResponse.Buffer)
        {

            RtlMoveMemory(CaseSensitiveChallengeResponse,
                 pChallengeResponse->CaseSensitiveChallengeResponse.Buffer,
                 SESSION_PWLEN);
        }
        else
        {
            ZeroMemory(CaseSensitiveChallengeResponse,
                       SESSION_PWLEN);
        }

        RtlMoveMemory(((REQTYPECAST*)buffer)->GetCredentials.LMSessionKey,
             pChallengeResponse->LanmanSessionKey,
             MAX_SESSIONKEY_SIZE);

        RtlMoveMemory(((REQTYPECAST*)buffer)->GetCredentials.UserSessionKey,
             pChallengeResponse->UserSessionKey,
             MAX_USERSESSIONKEY_SIZE);

        LsaFreeReturnBuffer(pChallengeResponse);

        ((REQTYPECAST*)buffer)->GetCredentials.retcode = 0 ;
    }

    if (pChallengeResponse)
    {
        LsaFreeReturnBuffer( pChallengeResponse );
    }

    return ;
}


/*++

Routine Description:

    Changes cached password for currently logged on user.
    This is done after the password has been changed so
    user doesn't have to log off and log on again with
    his new password to get the desired "authenticate
    using current username/password" behavior.

Arguments:

Return Value:

    Nothing.

--*/
VOID
SetCachedCredentials(
    pPCB  ppcb,
    PBYTE buffer)
{
    DWORD       dwErr;
    NTSTATUS    status;
    NTSTATUS    substatus;
    ANSI_STRING ansi;

    CHAR* pszAccount =
            ((REQTYPECAST* )buffer)->SetCachedCredentials.Account;

    CHAR* pszDomain =
            ((REQTYPECAST* )buffer)->SetCachedCredentials.Domain;

    CHAR* pszNewPassword =
            ((REQTYPECAST* )buffer)->SetCachedCredentials.NewPassword;

    struct
    {
        MSV1_0_CHANGEPASSWORD_REQUEST request;
        WCHAR  wszAccount[ MAX_USERNAME_SIZE + 1 ];
        WCHAR  wszDomain[ MAX_DOMAIN_SIZE + 1 ];
        WCHAR  wszNewPassword[ MAX_PASSWORD_SIZE + 1 ];
    }
    rbuf;

    PMSV1_0_CHANGEPASSWORD_RESPONSE pResponse;
    DWORD cbResponse = sizeof(*pResponse);

    //
    // Fill in our LSA request.
    //
    rbuf.request.MessageType = MsV1_0ChangeCachedPassword;

    RtlInitAnsiString( &ansi, pszAccount );

    rbuf.request.AccountName.Length = 0;

    rbuf.request.AccountName.MaximumLength =
                    (ansi.Length + 1) * sizeof(WCHAR);

    rbuf.request.AccountName.Buffer = rbuf.wszAccount;

    RtlAnsiStringToUnicodeString(&rbuf.request.AccountName,
                                    &ansi, FALSE );

    RtlInitAnsiString( &ansi, pszDomain );

    rbuf.request.DomainName.Length = 0;

    rbuf.request.DomainName.MaximumLength =
                            (ansi.Length + 1) * sizeof(WCHAR);

    rbuf.request.DomainName.Buffer = rbuf.wszDomain;

    RtlAnsiStringToUnicodeString(&rbuf.request.DomainName,
                                            &ansi, FALSE );

    rbuf.request.OldPassword.Length = 0;

    rbuf.request.OldPassword.MaximumLength = 0;

    rbuf.request.OldPassword.Buffer = NULL;

    RtlInitAnsiString( &ansi, pszNewPassword );

    rbuf.request.NewPassword.Length = 0;

    rbuf.request.NewPassword.MaximumLength =
                    (ansi.Length + 1) * sizeof(WCHAR);

    rbuf.request.NewPassword.Buffer = rbuf.wszNewPassword;

    RtlAnsiStringToUnicodeString(&rbuf.request.NewPassword,
                                            &ansi, FALSE );

    rbuf.request.Impersonating = FALSE;

    //
    // Tell LSA to execute our request.
    //
    status = LsaCallAuthenticationPackage(  HLsa,
                                            AuthPkgId,
                                            &rbuf,
                                            sizeof(rbuf),
                                            (PVOID *)&pResponse,
                                            &cbResponse,
                                            &substatus );
    //
    // Fill in result to be reported to API caller.
    //
    if (status == STATUS_SUCCESS && substatus == STATUS_SUCCESS)
    {
        dwErr = 0;
    }
    else
    {
        if (status != STATUS_SUCCESS)
        {
            dwErr = (DWORD )status;
        }
        else
        {
            dwErr = (DWORD )substatus;
        }
    }

    ((REQTYPECAST* )buffer)->SetCachedCredentials.retcode = dwErr;

    //
    // Free the LSA result.
    //
    if (pResponse)
    {
        LsaFreeReturnBuffer( pResponse );
    }
}


/*++

Routine Description:

    Writes information to the media (if state is not connected) and
    to the HUB if the state is connected. Since the write may take
    some time the async worker element is filled up.

Arguments:

Return Value:

    Nothing.

--*/
VOID
PortSendRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD       bytesrecvd ;
    SendRcvBuffer   *psendrcvbuf;
    DWORD       retcode = SUCCESS ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace (
                    "PortSendRequest: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_PortStatus != OPEN)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode = ERROR_PORT_NOT_OPEN ;
        return ;
    }

   psendrcvbuf = &((REQTYPECAST *) buffer)->PortSend.buffer;

    if (ppcb->PCB_ConnState == CONNECTED)
    {
#if DBG
        ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif
        //
        // get pointer to the send receive buffer - then we can access
        // the fields in the structure directly. This is done to avoid
        // the random access problem due to DWORD alignment:
        //
        psendrcvbuf->SRB_Packet.hHandle         = ppcb->PCB_LinkHandle;
        psendrcvbuf->SRB_Packet.usHandleType    = LINKHANDLE;
        psendrcvbuf->SRB_Packet.usPacketFlags   = PACKET_IS_DIRECT ;
        psendrcvbuf->SRB_Packet.usPacketSize    =
                    ( USHORT ) ((REQTYPECAST*)buffer)->PortSend.size ;

        psendrcvbuf->SRB_Packet.usHeaderSize    = 0 ;

        memset ((BYTE *) &ppcb->PCB_SendOverlapped,
                                0, sizeof(OVERLAPPED));

        //
        // ndiswan never pends send operations.
        //
        ppcb->PCB_SendOverlapped.hEvent = hDummyOverlappedEvent;

        /*
        if(0 == memcmp(bCmp1,
                      psendrcvbuf->SRB_Packet.PacketData,
                       10))
        {
            //DebugBreak();
            //DbgPrint("Same packet on send path------------------\n");
        }
        else
        {
            memcpy(bCmp1,
                   psendrcvbuf->SRB_Packet.PacketData,
                   10);
        } */

        if (!DeviceIoControl ( RasHubHandle,
                               IOCTL_NDISWAN_SEND_PACKET,
                               &psendrcvbuf->SRB_Packet,
                               sizeof(NDISWAN_IO_PACKET) + PACKET_SIZE,
                               &psendrcvbuf->SRB_Packet,
                               sizeof(NDISWAN_IO_PACKET) + PACKET_SIZE,
                               &bytesrecvd,
                               &ppcb->PCB_SendOverlapped))
        {

            retcode = GetLastError () ;
        }

    }
    else
    {
        PORTSEND( ppcb->PCB_Media,
                  ppcb->PCB_PortIOHandle,
                  psendrcvbuf->SRB_Packet.PacketData,
                  ((REQTYPECAST *)buffer)->PortSend.size) ;
    }


    ((REQTYPECAST*)buffer)->Generic.retcode = retcode ;
}


VOID
PortReceiveRequestEx ( pPCB ppcb, PBYTE buffer )
{
    DWORD retcode = SUCCESS;
    SendRcvBuffer *pSendRcvBuffer =
            &((REQTYPECAST *)buffer )->PortReceiveEx.buffer;


    if(NULL == ppcb)
    {
        retcode = ERROR_PORT_NOT_FOUND;
        goto done;
    }

    //
    // Return if rasman timed out waiting for the client
    // to pick up its buffer of received data
    //
    if (0 == (ppcb->PCB_RasmanReceiveFlags & RECEIVE_OUTOF_PROCESS))
    {
        ((REQTYPECAST *) buffer)->PortReceiveEx.size = 0;
        goto done;
    }

    //
    // Return if we are not connected
    //
    if (DISCONNECTING == ppcb->PCB_ConnState)
    {
        ((REQTYPECAST *) buffer)->PortReceiveEx.size = 0;
        retcode = ERROR_PORT_NOT_CONNECTED;
        goto done;
    }


    //
    // remove the timeout element if there was one
    //
    //
    if (ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement != NULL)
    {
        RemoveTimeoutElement(ppcb);
    }

    //
    // copy the contents of the buffer in the ppcb to the
    // clients buffer
    //

    if (ppcb->PCB_PendingReceive)
    {
        memcpy (pSendRcvBuffer,
                ppcb->PCB_PendingReceive,
                sizeof (SendRcvBuffer));
    }

    //
    // fill in the bytes received
    //
    ((REQTYPECAST *) buffer)->PortReceiveEx.size =
                                ppcb->PCB_BytesReceived;

    LocalFree ( ppcb->PCB_PendingReceive);

    ppcb->PCB_PendingReceive = NULL;

    //
    // Clear the waiting flag - the client has picked up
    // this buffer.
    //
    ppcb->PCB_RasmanReceiveFlags = 0;

    //
    // Free the notifier handle
    //
    if (ppcb->PCB_AsyncWorkerElement.WE_Notifier)
    {
        FreeNotifierHandle(ppcb->PCB_AsyncWorkerElement.WE_Notifier);
    }

    ppcb->PCB_AsyncWorkerElement.WE_Notifier = INVALID_HANDLE_VALUE ;

done:

    RasmanTrace(
          "PortReceiveRequestEx: rc=0x%x",
          retcode);

    ((REQTYPECAST *)buffer)->PortReceiveEx.retcode = retcode;

    return;
}

VOID PortReceiveRequest ( pPCB ppcb, PBYTE buffer )
{
    PortReceive( ppcb, buffer, FALSE );
}


VOID RasmanPortReceive ( pPCB ppcb )
{
    //
    // Keep posting receives till we get a PENDING
    // or an error returned
    //
    do
    {

        PortReceive( ppcb, ( PBYTE ) g_pReqPostReceive, TRUE );

    } while ( SUCCESS ==
            ((REQTYPECAST * )g_pReqPostReceive )->Generic.retcode);
}

/*++

Routine Description:

    Reads incoming bytes from the media (if state is not
    connected) & from the HUB if the state is connected.
    Since the read request accepts timeouts and the HUB
    does not support timeouts, we must submit a timeout
    request to our timer.

Arguments:

Return Value:

    Nothing.

--*/
VOID
PortReceive (pPCB ppcb, PBYTE buffer, BOOL fRasmanPostingReceive)
{
    WORD        reqtype ;
    DWORD       retcode = SUCCESS;
    SendRcvBuffer   *psendrcvbuf;
    HANDLE      handle ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace (  "PortReceive: port %d is unavailable",
                                    ppcb->PCB_PortHandle );
        }

        retcode = ERROR_PORT_NOT_OPEN;

        goto done;
    }


    if (ppcb->PCB_PortStatus != OPEN)
    {
        retcode = ERROR_PORT_NOT_OPEN ;
        goto done;
    }

    //
    // Something else is pending: cannot handle two async requests on the
    // same port at the same time:
    //
    // Note: If connected - the reqtype should always be
    //       REQTYPE_RECEIVEHUB - hence the if condition
    //
    // We return ERROR_ASYNC_REQUEST_PENDING in the following cases
    //  1. if there is a async request pending
    //  2. if we are waiting for an out of process receive request to
    //      be cleared
    //  3. If a RasPortReceive is being done by a client other than
    //      rasman after PPP has started.
    //
    if (    (   (ppcb->PCB_AsyncWorkerElement.WE_ReqType
                                            != REQTYPE_NONE)
            &&  (ppcb->PCB_ConnState != CONNECTED))

        ||  (ppcb->PCB_RasmanReceiveFlags & RECEIVE_WAITING)

        ||  (   !fRasmanPostingReceive
            &&  (ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPSTARTED)))
    {
        RasmanTrace(
               "PortReceive: async request pending on port %s",
               ppcb->PCB_Name);

        retcode = ERROR_ASYNC_REQUEST_PENDING;
        goto done ;

    }

    if (    ((REQTYPECAST*)buffer)->PortReceive.pid
                                != GetCurrentProcessId()
        &&  !fRasmanPostingReceive)
    {
        ppcb->PCB_PendingReceive =
                    LocalAlloc (LPTR, sizeof (SendRcvBuffer));

        if (NULL == ppcb->PCB_PendingReceive)
        {
            retcode = GetLastError() ;
            goto done ;
        }

        psendrcvbuf = ppcb->PCB_PendingReceive;

        //
        // Mark this buffer
        //
        ppcb->PCB_RasmanReceiveFlags = RECEIVE_OUTOF_PROCESS;

    }
    else
    {
        psendrcvbuf = ((REQTYPECAST *) buffer)->PortReceive.buffer;

        if (!fRasmanPostingReceive)
        {
            ppcb->PCB_RasmanReceiveFlags = 0;
        }
    }

    if (ppcb->PCB_ConnState == CONNECTED)
    {
        reqtype = REQTYPE_PORTRECEIVEHUB ;
        retcode = CompleteReceiveIfPending (ppcb, psendrcvbuf) ;
    }
    else
    {
        //
        // If this is a pre-connect terminal conversation case -
        // set state to connecting.
        //
        if (ppcb->PCB_ConnState == DISCONNECTED)
        {
            SetPortConnState(__FILE__, __LINE__, ppcb, CONNECTING);

            //
            // need to call the media dll to do any initializations:
            //
            retcode = PORTINIT(ppcb->PCB_Media, ppcb->PCB_PortIOHandle) ;
            if (retcode)
            {
                goto done ;
            }
        }

        reqtype = REQTYPE_PORTRECEIVE ;

        //
        // adjust the timeout from seconds to milliseconds
        //
        if (((REQTYPECAST *)buffer)->PortReceive.timeout != INFINITE)
        {
            ((REQTYPECAST *)buffer)->PortReceive.timeout =
                ((REQTYPECAST *)buffer)->PortReceive.timeout * 1000;
        }

        ppcb->PCB_BytesReceived = 0 ;

        retcode = PORTRECEIVE( ppcb->PCB_Media,
                       ppcb->PCB_PortIOHandle,
                       psendrcvbuf->SRB_Packet.PacketData,
                       ((REQTYPECAST *)buffer)->PortReceive.size,
                       ((REQTYPECAST *)buffer)->PortReceive.timeout);

    }

    if (retcode == ERROR_IO_PENDING)
    {
        retcode = PENDING ;
    }

    ppcb->PCB_LastError = retcode ;

    switch (retcode)
    {
        case PENDING:
            //
            // The connection attempt was successfully initiated:
            // make sure that the async operation struct in the
            // PCB is initialised.
            //
            ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                ValidateHandleForRasman(
                        ((REQTYPECAST*)buffer)->PortReceive.handle,
                        ((REQTYPECAST*)buffer)->PortReceive.pid) ;

            SetPortAsyncReqType(__FILE__, __LINE__, ppcb, reqtype);

            if (    !fRasmanPostingReceive
                &&  (( REQTYPECAST *)buffer)->PortReceive.pid ==
                                                GetCurrentProcessId())
                ppcb->PCB_PendingReceive = psendrcvbuf ;


            if (    reqtype == REQTYPE_PORTRECEIVEHUB
                &&  (((REQTYPECAST *)buffer)->PortReceive.timeout
                                                            != INFINITE)
                &&  (((REQTYPECAST *)buffer)->PortReceive.timeout
                                                            != 0))
            {
                    ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement =
                      AddTimeoutElement ((TIMERFUNC)HubReceiveTimeout,
                             ppcb, NULL,
                             ((REQTYPECAST*)buffer)->PortReceive.timeout);
            }
            break ;

        case SUCCESS:

            //
            // This means that the write completed synchronously:
            // We must signal the event passed in: so that the
            // calling program can treat this like a real async
            // completion.
            //

            if (reqtype == REQTYPE_PORTRECEIVE)
            {
                ppcb->PCB_BytesReceived = 0 ;
            }

            handle = ValidateHandleForRasman(
                         ((REQTYPECAST*)buffer)->PortReceive.handle,
                         ((REQTYPECAST*)buffer)->PortReceive.pid);


            if (ppcb->PCB_RasmanReceiveFlags & RECEIVE_OUTOF_PROCESS)
            {

                ppcb->PCB_RasmanReceiveFlags |= RECEIVE_WAITING;

                //
                // Add a timeout element so that we don't wait forever
                // for the client to pick up the received buffer.
                //
                ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement =
                    AddTimeoutElement (
                                (TIMERFUNC) OutOfProcessReceiveTimeout,
                                ppcb, NULL,
                                MSECS_OutOfProcessReceiveTimeOut );

                AdjustTimer();

            }

            RasmanTrace(
                   "PortReceive: Receive completed ssync on port %s",
                    ppcb->PCB_Name);

            if(ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPSTARTED)
            {
                //
                // Flush all the queued packets to ppp
                //
                do
                {
                    //
                    // We have receives buffered before ppp started.
                    // complete the receive synchronously.
                    //
                    RasmanTrace(
                           "PortReceive: %s ppp has "
                           "started. completing sync",
                           ppcb->PCB_Name);

                    SendReceivedPacketToPPP(
                                    ppcb,
                                    &psendrcvbuf->SRB_Packet);

                } while(SUCCESS == (retcode =
                                    CompleteReceiveIfPending(
                                    ppcb,
                                    psendrcvbuf)));
            }

            // retcode = PostReceivePacket();

            if(     (NULL != handle)
               &&   (INVALID_HANDLE_VALUE != handle))
            {
                SetEvent(handle) ;
            }

            //
            // Don't free the notifier handle immediately if
            // this is an out of process request. We wait till
            // the client has picked its buffer
            // TODO: This can be optimized by passing the buffer
            // back to the user in this case.
            //
            if (!fRasmanPostingReceive)
            {
                if (0 == (ppcb->PCB_RasmanReceiveFlags &
                                    RECEIVE_OUTOF_PROCESS))
                {
                    FreeNotifierHandle (handle) ;
                }
                else
                {

                    SetPortAsyncReqType (__FILE__, __LINE__,
                                         ppcb, reqtype);

                    ppcb->PCB_AsyncWorkerElement.WE_Notifier = handle;

                }
            }

        default:

        //
        // Some error occured - simply pass the error back to the app.
        //
        break ;
    }

done:
    ((REQTYPECAST*) buffer)->Generic.retcode = retcode ;
}

DWORD
CompleteReceiveIfPending (pPCB ppcb, SendRcvBuffer *psendrcvbuf)
{
    RasmanPacket    *Packet;

    //
    // Take the first packet off of the list
    //
    GetRecvPacketFromPcb(ppcb, &Packet);

    //
    // See if this port has any receives queued up
    //
    if (Packet != NULL)
    {
        memcpy (&psendrcvbuf->SRB_Packet,
                &Packet->RP_Packet,
                sizeof (NDISWAN_IO_PACKET) + PACKET_SIZE) ;

        ppcb->PCB_BytesReceived =
                    psendrcvbuf->SRB_Packet.usPacketSize ;

        //
        // This is a local alloc'd buffer, free it
        //
        LocalFree(Packet);

        return SUCCESS ;
    }

    return PENDING;
}



/*++

Routine Description:

    Activates a previously allocated route.
    The route information and a SUCCESS retcode
    is passed back if the action was successful.

Arguments:

Return Value:

    Nothing.

--*/
VOID
ActivateRouteRequest (pPCB ppcb, PBYTE buffer)
{
    pList           list ;
    pList           bindinglist ;
    DWORD           bytesrecvd ;
    NDISWAN_ROUTE   *rinfo ;
    BYTE            buff[MAX_BUFFER_SIZE] ;
    DWORD           retcode = ERROR_ROUTE_NOT_ALLOCATED ;
    DWORD           dwErr;

    rinfo = (NDISWAN_ROUTE *)buff ;

    ZeroMemory(rinfo, MAX_BUFFER_SIZE);

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace( 
                    "ActivateRouteRequest: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Route.retcode =
                                ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*) buffer)->Route.retcode =
                                ERROR_PORT_NOT_CONNECTED ;

        return ;
    }

    //
    // If this port is bundled use the bundle's binding
    // list else use the port from the port's binding list
    //
    if (ppcb->PCB_Bundle == (Bundle *) NULL)
    {
        bindinglist = ppcb->PCB_Bindings;
    }
    else
    {
        bindinglist = ppcb->PCB_Bundle->B_Bindings ;
    }

    //
    // Locate the route which should have been activated before:
    //
    for (list = bindinglist; list; list = list->L_Next)
    {
        if (((pProtInfo)list->L_Element)->PI_Type ==
                     ((REQTYPECAST *)buffer)->ActivateRoute.type)
        {

            if(((pProtInfo) list->L_Element)->PI_Type == ASYBEUI)
            {
                if(     ((ppcb->PCB_Connection == NULL)
                        &&  (((pProtInfo) list->L_Element)->PI_DialOut))
                    ||  ((ppcb->PCB_Connection != NULL)
                        &&  !(((pProtInfo) list->L_Element)->PI_DialOut)))
                {
                    RasmanTrace(
                           "ActivateRouteRequest: Skipping"
                           " since not marked correctly");

                    continue;
                }
            }

            //
            // Fill in the information supplied by the Control protocols
            //
            rinfo->hBundleHandle    = ppcb->PCB_BundleHandle;
            rinfo->usProtocolType   =
                (USHORT) ((REQTYPECAST *)buffer)->ActivateRoute.type;
            rinfo->ulBufferLength   =
                ((REQTYPECAST *)buffer)->ActivateRoute.config.P_Length;

            memcpy (&rinfo->Buffer,
                ((REQTYPECAST *)buffer)->ActivateRoute.config.P_Info,
                rinfo->ulBufferLength);

            if(NULL != ppcb->PCB_Connection)
            {
                ((pProtInfo) list->L_Element)->PI_DialOut = TRUE;
            }
            else
            {
                ((pProtInfo) list->L_Element)->PI_DialOut = FALSE;
            }

            //
            // Copy the device name if its nbf
            //
            if(((pProtInfo) list->L_Element)->PI_Type == ASYBEUI)
            {
                USHORT uscch;
                 uscch = (USHORT) mbstowcs(rinfo->BindingName,
                 ((pProtInfo)list->L_Element)->PI_AdapterName,
                 strlen (((pProtInfo)list->L_Element)->PI_AdapterName));

                rinfo->usDeviceNameLength = uscch * sizeof(WCHAR);
                rinfo->usBindingNameLength = rinfo->usDeviceNameLength;

            }

            //
            // If its IP and if this is a dialout connection, copy the
            // guid associated with the phonebook entry in the device
            // name.
            //
            if((IP == ((pProtInfo) list->L_Element)->PI_Type))
            {
                RasmanTrace(
                       "Usage for the call on %s is %d",
                        ppcb->PCB_Name,
                        ((IP_WAN_LINKUP_INFO *) rinfo->Buffer)->duUsage);

                if(     (NULL != ppcb->PCB_Connection)
                    ||  (DU_ROUTER == ((IP_WAN_LINKUP_INFO *)
                                         rinfo->Buffer)->duUsage))
                {
                    //
                    // If this is IP and we are accepting a call check
                    // to see if this is a router call. If it is then
                    // since router accepts a call on a ipout interface
                    // we need to do create bindings dynamically if
                    // required.
                    //
                    rinfo->usDeviceNameLength = sizeof(GUID);

                    if(NULL != ppcb->PCB_Connection)
                    {
                        memcpy((PBYTE) rinfo->DeviceName,
                               (PBYTE) &ppcb->PCB_Connection->CB_GuidEntry,
                               sizeof(GUID));
                    }

                    if(g_pEpInfo[IpOut].EP_Available > 0)
                    {
                        //
                        // Increase the InUse for IpOut
                        //
                        InterlockedIncrement(
                                &g_plCurrentEpInUse[IpOut]);

                        RasmanTrace(
                                " New InUse for IpOut=0%d\n",
                                g_plCurrentEpInUse[IpOut]);

                    }

                    //
                    // Hackorama babe! Treat the dial as out even
                    // though this could be a router dialing in.
                    //
                    ((pProtInfo) list->L_Element)->PI_DialOut = TRUE;

                }
            }

#if DBG
            ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

            //
            // Route this by calling to the RASHUB.
            //
            if (!DeviceIoControl ( RasHubHandle,
                                   IOCTL_NDISWAN_ROUTE,
                                   (PBYTE) rinfo,
                                   MAX_BUFFER_SIZE,
                                   (PBYTE) rinfo,
                                   MAX_BUFFER_SIZE,
                                   (LPDWORD) &bytesrecvd,
                                   NULL))
            {

                retcode = GetLastError() ;
            }
            else
            {
                retcode = SUCCESS ;
            }

            if (SUCCESS == retcode)
            {
                RasmanTrace(
                    "%s, %d: Activated Route , port = %s(0x%x), "
                    "bundlehandle 0x%x, prottype = %d, dwErr = %d",
                    __FILE__, __LINE__, ppcb->PCB_Name, ppcb,
                    (rinfo ? rinfo->hBundleHandle:0),
                    (rinfo ? rinfo->usProtocolType:0),
                    retcode);
            }
            else
            {
                RasmanTrace( "%s, %d: Activate Route "
                "failed for %s. dwErr = %d",
                __FILE__, __LINE__, ppcb->PCB_Name,
                retcode);
            }

            break ;
        }
    }

    //
    // If a route was found mark the route as activated
    // and fill in the route info struct to be passed back
    // to the caller.
    //
    if (retcode == SUCCESS)
    {
        //
        // For IP we get back the actual adapter name
        // after the route succeeds.
        //
        if (((pProtInfo)list->L_Element)->PI_Type == IP)
        {
            ZeroMemory(((pProtInfo)list->L_Element)->PI_AdapterName,
                       MAX_ADAPTER_NAME);

            //
            // Make sure that the device name is NULL terminated
            //
            *((WCHAR *) (((PBYTE) rinfo->DeviceName) +
                        rinfo->usDeviceNameLength)) = UNICODE_NULL;

            wcstombs(((pProtInfo)list->L_Element)->PI_AdapterName,
                     rinfo->DeviceName,
                     wcslen (rinfo->DeviceName)) ;




        }

        list->L_Activated = TRUE ;

        //
        // Will be valid for netbios nets only
        //
        if ( ((pProtInfo) list->L_Element)->PI_Type == ASYBEUI )
        {
            ((REQTYPECAST*)buffer)->Route.info.RI_LanaNum =
                          ((pProtInfo)list->L_Element)->PI_LanaNumber ;

            ((REQTYPECAST*)buffer)->Route.info.RI_Type =
                                ((pProtInfo)list->L_Element)->PI_Type;

            mbstowcs (((REQTYPECAST *)buffer)->Route.info.RI_XportName,
                  ((pProtInfo)list->L_Element)->PI_XportName,
                  strlen (((pProtInfo)list->L_Element)->PI_XportName)) ;

            ((REQTYPECAST *)buffer)->Route.info.RI_XportName[
                strlen(((pProtInfo)list->L_Element)->PI_XportName)] =
                                                        UNICODE_NULL;
        }

        mbstowcs (((REQTYPECAST *)buffer)->Route.info.RI_AdapterName,
              ((pProtInfo)list->L_Element)->PI_AdapterName,
              strlen (((pProtInfo)list->L_Element)->PI_AdapterName)) ;


        ((REQTYPECAST*)buffer)->Route.info.RI_AdapterName[
                strlen(((pProtInfo)list->L_Element)->PI_AdapterName)] =
                UNICODE_NULL ;

        if(NULL != ppcb->PCB_Connection)
        {
            BOOL fBind =
            !!(CONNECTION_SHAREFILEANDPRINT
            & ppcb->PCB_Connection->CB_ConnectionParams.CP_ConnectionFlags);

            WCHAR * pszAdapterName =
                ((REQTYPECAST*)buffer)->Route.info.RI_AdapterName;

            if(IP == ((pProtInfo) list->L_Element)->PI_Type)
            {
                //
                // Bind/unbind the server to the adapter
                //
                dwErr = DwBindServerToAdapter(
                        pszAdapterName + 8,
                        fBind,
                        ((pProtInfo) list->L_Element)->PI_Type);

            }
            else if (ASYBEUI == ((pProtInfo) list->L_Element)->PI_Type)
            {
                //
                // Bind/unbind the server to the adapter
                //
                dwErr = DwBindServerToAdapter(
                        pszAdapterName,
                        fBind,
                        ((pProtInfo) list->L_Element)->PI_Type);

            }

            RasmanTrace(
                
                "ActivateRouteRequest: DwBindServerToAdapter. 0x%x",
                dwErr);

            //
            // Ignore the above error. Its not fatal.
            //
            dwErr = DwSetTcpWindowSize(
                        pszAdapterName,
                        ppcb->PCB_Connection,
                        TRUE);

            RasmanTrace(
                "ActivateRouteRequest: DwSetTcpWindowSize. 0x%x",
                dwErr);
                
        }
    }

    //
    // Add endpoints if required
    //
    dwErr = DwAddEndPointsIfRequired();

    if(SUCCESS != dwErr)
    {
        RasmanTrace(
               "ActivateRoute: failed to add endpoints. 0x%x",
               retcode);

        //
        // This is not fatal - at least we should be able to
        // connect on available endpoints. Ignore the error
        // and hope that the next time this will succeed.
        //
    }


    ((REQTYPECAST*)buffer)->Route.retcode = retcode ;
}


/*++

Routine Description:

    Activates a previously allocated route. The route
    information and a SUCCESS retcode is passed back
    if the action was successful.

Arguments:

Return Value:

    Nothing.

--*/
VOID
ActivateRouteExRequest (pPCB ppcb, PBYTE buffer)
{
    pList           list ;
    pList           bindinglist ;
    DWORD           bytesrecvd ;
    NDISWAN_ROUTE   *rinfo ;
    BYTE            buff[MAX_BUFFER_SIZE] ;
    DWORD           retcode = ERROR_ROUTE_NOT_ALLOCATED ;

    rinfo = (NDISWAN_ROUTE *)buff ;
    ZeroMemory(rinfo, MAX_BUFFER_SIZE);

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                   "ActivateRouteExRequest: port %d is unavailable",
                   ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Route.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*) buffer)->Route.retcode =
                                ERROR_PORT_NOT_CONNECTED ;

        return ;
    }

    //
    // If this port is bundled use the bundle's binding list else
    // use the port from the port's binding list
    //
    if (ppcb->PCB_Bundle == (Bundle *) NULL)
    {
        bindinglist = ppcb->PCB_Bindings;
    }
    else
    {
        bindinglist = ppcb->PCB_Bundle->B_Bindings ;
    }

    //
    // Locate the route which should have been activated before:
    //
    for (list = bindinglist; list; list=list->L_Next)
    {
        if (((pProtInfo)list->L_Element)->PI_Type ==
                    ((REQTYPECAST *)buffer)->ActivateRouteEx.type)
        {

            rinfo->hBundleHandle    = ppcb->PCB_BundleHandle;
            rinfo->usProtocolType   =
                    (USHORT) ((REQTYPECAST *)buffer)->ActivateRouteEx.type;

            rinfo->ulBufferLength   =
                    ((REQTYPECAST *)buffer)->ActivateRouteEx.config.P_Length ;

            memcpy (&rinfo->Buffer,
                   ((REQTYPECAST *)buffer)->ActivateRouteEx.config.P_Info,
                   rinfo->ulBufferLength) ;


            if ( ( ( pProtInfo )list->L_Element)->PI_Type == ASYBEUI )
            {

                rinfo->usDeviceNameLength = (USHORT) mbstowcs(rinfo->BindingName,
                     ((pProtInfo)list->L_Element)->PI_AdapterName,
                     strlen (((pProtInfo)list->L_Element)->PI_AdapterName));

            }

#if DBG
            ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

            //
            // Route this by calling to the RASHUB.
            //
            if (!DeviceIoControl ( RasHubHandle,
                                   IOCTL_NDISWAN_ROUTE,
                                   (PBYTE) rinfo,
                                   MAX_BUFFER_SIZE,
                                   (PBYTE)rinfo,
                                   MAX_BUFFER_SIZE,
                                   (LPDWORD) &bytesrecvd,
                                   NULL))
            {

                retcode = GetLastError() ;
            }
            else
            {
                retcode = SUCCESS ;
            }

            break ;
        }
    }

    //
    // If a route was found mark the route as activated and
    // fill in the route info struct to be passed back to
    // the caller.
    //
    if (retcode == SUCCESS)
    {
        //
        // For IP we get back the actual adapter name after
        // the route succeeds.
        //
        if (((pProtInfo)list->L_Element)->PI_Type == IP)
        {
            wcstombs (((pProtInfo)list->L_Element)->PI_AdapterName,
                        rinfo->DeviceName,
                        wcslen (rinfo->DeviceName)) ;
        }

        list->L_Activated = TRUE ;

        //
        // Will be valid for netbios nets only
        //
        if (((pProtInfo) list->L_Element)->PI_Type == ASYBEUI)
        {

            ((REQTYPECAST*)buffer)->Route.info.RI_LanaNum =
                          ((pProtInfo)list->L_Element)->PI_LanaNumber;

            ((REQTYPECAST*)buffer)->Route.info.RI_Type =
                                ((pProtInfo)list->L_Element)->PI_Type;

            mbstowcs (((REQTYPECAST *)buffer)->Route.info.RI_XportName,
                      ((pProtInfo)list->L_Element)->PI_XportName,
                        strlen (((pProtInfo)list->L_Element)->PI_XportName)) ;

            ((REQTYPECAST *)buffer)->Route.info.RI_XportName[
                    strlen(((pProtInfo)list->L_Element)->PI_XportName)] =
                    UNICODE_NULL ;
        }

        mbstowcs (((REQTYPECAST *)buffer)->Route.info.RI_AdapterName,
                  ((pProtInfo)list->L_Element)->PI_AdapterName,
                  strlen (((pProtInfo)list->L_Element)->PI_AdapterName)) ;

        ((REQTYPECAST*)buffer)->Route.info.RI_AdapterName[
                strlen(((pProtInfo)list->L_Element)->PI_AdapterName)] =
                    UNICODE_NULL ;

    }

    ((REQTYPECAST*)buffer)->Route.retcode = retcode ;
}


/*++

Routine Description:

    Marks the state of the port as connected and calls the Media DLL
    to do whatever is necessary (tell the MAC to start frame-talk).

Arguments:

Return Value:

    Nothing.

--*/
VOID
ConnectCompleteRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD   retcode ;
    HANDLE  cookie ;
    WORD    i ;
    // DWORD   dwRate;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace (
                    "ConnectCompleteRequest: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }

    RasmanTrace(
           "ConnectCompleteRequest: entered for port %d",
           ppcb->PCB_PortHandle) ;

    //
    // For NULL devices simply set state and return - everything else is
    // already done.
    //
    if (!_stricmp(ppcb->PCB_DeviceType, DEVICE_NULL))
    {
        SetPortConnState(__FILE__, __LINE__, ppcb, CONNECTED);

        ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;

        return ;
    }


    //
    // For other devices....
    //
    FreeDeviceList (ppcb) ;

    retcode = PORTCONNECT (ppcb->PCB_Media,
                           ppcb->PCB_PortIOHandle,
                           FALSE,
                           &cookie );

    if (retcode == SUCCESS)
    {
        ppcb->PCB_ConnectDuration = GetTickCount() ;
        SetPortConnState(__FILE__, __LINE__, ppcb, CONNECTED);

        //
        // Allocate a bundle block if it
        // doesn't already have one.
        //
        retcode = AllocBundle(ppcb);

        if ( retcode )
        {
            goto done;
        }

        MapCookieToEndpoint (ppcb, cookie) ;

        //
        // Set Adjust factor to 0
        //
        for (i=0; i< MAX_STATISTICS; i++)
        {
            ppcb->PCB_AdjustFactor[i] = 0 ;
            ppcb->PCB_BundleAdjustFactor[i] = 0 ;
        }

        //
        // Queue a request to rasmans thread to post a receive buffer
        //
        // PostReceivePacket();
        if(!ReceiveBuffers->PacketPosted)
        {
            if (!PostQueuedCompletionStatus(
                                hIoCompletionPort,
                                0,0,
                                (LPOVERLAPPED) &RO_PostRecvPkt))
            {
                retcode = GetLastError();

                if(retcode != ERROR_IO_PENDING)
                {
                    RasmanTrace(
                        
                        "ConnectCompleteRequest failed to post "
                        "rcv pkt. 0x%x",
                        retcode);
                }

                retcode = SUCCESS;
            }
        }


        //
        // Save ipsec related information
        //
        if(RDT_Tunnel_L2tp == RAS_DEVICE_TYPE(
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType))
        {

            retcode = DwSaveIpSecInfo(ppcb);

            RasmanTrace(
                
                "ConnectCompleteRequest: DwSaveIpsecInfo returned 0x%x",
                 retcode);

            //
            // Failure to save the information is not fatal. ppp will drop
            // the connection if the policy requirements are not met.
            //
            retcode = SUCCESS;
        }

    }

done:
    ((REQTYPECAST*)buffer)->Generic.retcode = retcode ;

    RasmanTrace(
           "Connection Completed on port: %s, error code: %d",
           ppcb->PCB_Name, retcode);
}


/*++

Routine Description:

    Completes the listen request that was pending so far:

Arguments:

Return Value:

    Nothing.

--*/
VOID
CompleteListenRequest (pPCB ppcb, DWORD retcode)
{

    if (ppcb == NULL)
    {
        return;
    }

    if (retcode == SUCCESS)
    {

        SetPortConnState(__FILE__,
                         __LINE__,
                         ppcb,
                         LISTENCOMPLETED);

        //
        // Start monitoring DCD if this is serial media ONLY
        //
        if (!_stricmp (ppcb->PCB_Media->MCB_Name, "RASSER"))
        {
            PORTCONNECT (ppcb->PCB_Media,
                         ppcb->PCB_PortIOHandle,
                         TRUE,
                         NULL);
        }
    }

    //
    // Set last error:
    //
    ppcb->PCB_LastError = retcode ;

    //
    // Complete the async request:
    //
    CompleteAsyncRequest (ppcb);

    RasmanTrace(
           "RasmanReceiveFlags = 0x%x",
           ppcb->PCB_RasmanReceiveFlags );

    if ( ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPLISTEN )
    {
        SendListenCompletedNotificationToPPP ( ppcb );
    }
}

VOID
SendReceivedPacketToPPP( pPCB ppcb, NDISWAN_IO_PACKET *Packet )
{
    DWORD   retcode;
    DWORD   i;

    if ( NULL == Packet )
    {
        goto done;
    }

    g_PppeMessage->dwMsgId = PPPEMSG_Receive;

    g_PppeMessage->hPort = ppcb->PCB_PortHandle;

    ppcb->PCB_BytesReceived =
            Packet->usPacketSize;

    g_PppeMessage->ExtraInfo.Receive.pbBuffer =
                    Packet->PacketData + 12;

    g_PppeMessage->ExtraInfo.Receive.dwNumBytes =
                    ppcb->PCB_BytesReceived - 12;

    /*
    RasmanTrace(
           "SendReceived Packet to PPP. hPort=%d",
           ppcb->PCB_PortHandle);

    //DbgPrint("SendReceivedPacket to PPP, hPort=%d\n",
             ppcb->PCB_PortHandle);

    if(0 == memcmp(bCmp,
                  g_PppeMessage->ExtraInfo.Receive.pbBuffer,
                   10))
    {
        //DebugBreak();
        // DbgPrint("Same packet on Receive path------------------\n");

    }
    else
    {
        memcpy(bCmp,
               g_PppeMessage->ExtraInfo.Receive.pbBuffer,
               10);
    } */

    /*
    for(i = 0; i < 8; i++)
    {
        DbgPrint("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x"
                " %02x %02x %02x %02x %02x %02x\n",
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 0],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 1],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 2],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 3],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 4],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 5],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 6],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 7],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 8],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 9],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 10],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 11],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 12],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 13],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 14],
                g_PppeMessage->ExtraInfo.Receive.pbBuffer[i*8 + 15]);
    } */

    //
    // Send the packet on its way to PPP
    //
    RasSendPPPMessageToEngine ( g_PppeMessage );

done:
    return;
}

VOID
SendDisconnectNotificationToPPP( pPCB ppcb )
{

    //
    // If BAP is listening, send listen completed
    // to BAP.
    //
    if ( ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPLISTEN )
    {
        SendListenCompletedNotificationToPPP( ppcb );
    }

    if(     (0 == (RECEIVE_PPPSTART & ppcb->PCB_RasmanReceiveFlags))
        &&  (0 == (RECEIVE_PPPSTARTED & ppcb->PCB_RasmanReceiveFlags)))
    {
        goto done;
    }

    g_PppeMessage->dwMsgId = PPPEMSG_LineDown;

    g_PppeMessage->hPort = ppcb->PCB_PortHandle;

    //
    // Clear the flag in the pcb. We are no longer
    // in direct PPP mode
    //
    ppcb->PCB_RasmanReceiveFlags = 0;

    RasSendPPPMessageToEngine ( g_PppeMessage );

    //
    // Clear the pointers - PPP would have freed the
    // memory.
    //
    ppcb->PCB_pszPhonebookPath      = NULL;
    ppcb->PCB_pszEntryName          = NULL;
    ppcb->PCB_pszPhoneNumber        = NULL;
    ppcb->PCB_pCustomAuthData       = NULL;

    ppcb->PCB_pCustomAuthUserData   = NULL;
    ppcb->PCB_fLogon = FALSE;

done:
    return;

}

VOID
SendListenCompletedNotificationToPPP ( pPCB ppcb )
{
    g_PppeMessage->dwMsgId = PPPEMSG_ListenResult;

    g_PppeMessage->hPort = ppcb->PCB_PortHandle;

    ppcb->PCB_RasmanReceiveFlags &= ~RECEIVE_PPPLISTEN;

    RasSendPPPMessageToEngine ( g_PppeMessage );

}

VOID
QueueReceivedPacketOnPcb( pPCB ppcb, RasmanPacket *Packet )
{
    RasmanPacket *pRasmanPacket;

    //
    // LocalAlloc a RasmanPacket and put it on
    // the pcb. We cannot put the irp'd packet
    // on pcb directly as this would mean we stop
    // receiving packets
    //
    pRasmanPacket = LocalAlloc ( LPTR, sizeof ( RasmanPacket ) );

    if ( NULL == pRasmanPacket )
    {

        RasmanTrace( 
                "Failed to allocate Packet to put in PCB. %d",
                GetLastError() );
        RasmanTrace( 
                "Cannot pass on this packet above. Dropping it.");

        goto done;
    }

    memcpy ( pRasmanPacket, Packet, sizeof ( RasmanPacket ) );

    PutRecvPacketOnPcb( ppcb, pRasmanPacket );

done:
    return;
}

DWORD
CopyReceivedPacketToBuffer(
                    pPCB ppcb,
                    SendRcvBuffer *psendrcvbuf,
                    RasmanPacket *Packet)
{

    if (Packet != NULL)
    {

        memcpy (&psendrcvbuf->SRB_Packet,
                &Packet->RP_Packet,
                sizeof (NDISWAN_IO_PACKET) + PACKET_SIZE) ;

        ppcb->PCB_BytesReceived =
            psendrcvbuf->SRB_Packet.usPacketSize ;

        return SUCCESS ;
    }

    return PENDING;
}

DWORD
PostReceivePacket (
    VOID
    )
{
    DWORD               retcode = SUCCESS;
    DWORD               bytesrecvd ;
    RasmanPacket        *Packet;
    NDISWAN_IO_PACKET   *IoPacket;
    pPCB                ppcb;

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    //g_fPostReceive = TRUE;

    /*
    if(g_fProcessReceive)
    {
        DbgPrint("g_fProcessReceive==TRUE!!!\n");
        DebugBreak();
    }
    */

    if (!ReceiveBuffers->PacketPosted) {

        Packet = ReceiveBuffers->Packet;

        memset (Packet, 0, sizeof(RasmanPacket)) ;

        Packet->RP_OverLapped.RO_EventType = OVEVT_RASMAN_RECV_PACKET;

        IoPacket = (&Packet->RP_Packet);

        memset (IoPacket, 0xFF, sizeof(NDISWAN_IO_PACKET));

        IoPacket->usPacketFlags  = PACKET_IS_DIRECT;
        IoPacket->usPacketSize   = MAX_RECVBUFFER_SIZE ;
        IoPacket->usHeaderSize   = 0;
        IoPacket->PacketNumber   = ReceiveBuffers->PacketNumber;

        ReceiveBuffers->PacketPosted = TRUE;

        if (!DeviceIoControl (RasHubHandle,
                              IOCTL_NDISWAN_RECEIVE_PACKET,
                              IoPacket,
                              sizeof(NDISWAN_IO_PACKET) + MAX_RECVBUFFER_SIZE,
                              IoPacket,
                              sizeof(NDISWAN_IO_PACKET) + MAX_RECVBUFFER_SIZE,
                              (LPDWORD) &bytesrecvd,
                              (LPOVERLAPPED)&Packet->RP_OverLapped)) {

            retcode = GetLastError () ;

            if (retcode != ERROR_IO_PENDING) {

                RasmanTrace(
                       "PostReceivePacket: IOCTL_NDISWAN_RECEIVE_PACKET "
                       "returned error %d on 0x%x",
                       retcode, IoPacket->hHandle);

                ReceiveBuffers->PacketPosted = FALSE;
            }
        }
        ASSERT(retcode == ERROR_IO_PENDING);
    }

    //g_fPostReceive = FALSE;

    return (retcode);
}

/*++

Routine Description:

    Sets the retcode to TRUE if any ports are open,
    FALSE otherwise. If there are ports open but in
    disconnected state - it reports they are not
    open - this feature assumes that the only time
    this request is made rasman has no process
    attached to it.

Arguments:

Return Value:

    Nothing.

--*/
VOID
AnyPortsOpen (pPCB padding, PBYTE buffer)
{
    BOOL fAny = FALSE;
    ULONG    i;
    pPCB    ppcb ;

    fAny = FALSE ;     // No ports open
    for (i = 0; i < MaxPorts; i++)
    {
        ppcb = GetPortByHandle((HPORT) UlongToPtr(i));
        if (ppcb != NULL &&
            ppcb->PCB_PortStatus == OPEN &&
            ppcb->PCB_ConnState != DISCONNECTED)
        {
            fAny = TRUE;
            break;
        }
    }

    ((REQTYPECAST*)buffer)->Generic.retcode = fAny ;
}

/*++

Routine Description:

    Gets the lan nets information from the
    XPortsInfo struct parsed at init time.

Arguments:

Return Value:

--*/
VOID
EnumLanNetsRequest (pPCB ppcb, PBYTE buffer)
{
    GetLanNetsInfo (&((REQTYPECAST*)buffer)->EnumLanNets.count,
            ((REQTYPECAST*)buffer)->EnumLanNets.lanas) ;
}


/*++

Routine Description:

    Cancel pending receive request.

Arguments:

Return Value:

--*/
VOID
CancelReceiveRequest (pPCB ppcb, PBYTE buffer)
{

    if (ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                ERROR_PORT_NOT_FOUND;
        return;
    }

    ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;


    if (CancelPendingReceive (ppcb))
    {
        ppcb->PCB_LastError = SUCCESS ;

        SetPortAsyncReqType(__FILE__, __LINE__,
                            ppcb, REQTYPE_NONE);

        FreeNotifierHandle(ppcb->PCB_AsyncWorkerElement.WE_Notifier) ;

        ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                                    INVALID_HANDLE_VALUE ;
    }
}


/*++

Routine Description:

    Return all protocols routed to for the port.

Arguments:

Return Value:

    Nothing.

--*/
VOID
PortEnumProtocols (pPCB ppcb, PBYTE buffer)
{
    pList   temp ;
    pList   bindinglist ;
    DWORD   i ;

    if (ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->EnumProtocols.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }

    if(CONNECTED != ppcb->PCB_ConnState)
    {

        RasmanTrace(
               "PortEnumProtocols: port %d not CONNECTED",
               ppcb->PCB_PortHandle);

        ((REQTYPECAST *)
        buffer)->Generic.retcode = ERROR_NOT_CONNECTED;

        return ;
    }


    if (ppcb->PCB_Bundle == (Bundle *) NULL)
    {
        bindinglist = ppcb->PCB_Bindings;
    }
    else
    {
        bindinglist = ppcb->PCB_Bundle->B_Bindings ;
    }

    for (temp = bindinglist, i=0; temp; temp=temp->L_Next, i++)
    {

        ((REQTYPECAST*)buffer)->EnumProtocols.protocols.
                                RP_ProtocolInfo[i].RI_Type =
                              ((pProtInfo) temp->L_Element)->PI_Type ;

        ((REQTYPECAST*)buffer)->EnumProtocols.protocols.
                               RP_ProtocolInfo[i].RI_LanaNum =
                            ((pProtInfo) temp->L_Element)->PI_LanaNumber ;

        mbstowcs (((REQTYPECAST *)buffer)->EnumProtocols.protocols.
                RP_ProtocolInfo[i].RI_AdapterName,
                ((pProtInfo) temp->L_Element)->PI_AdapterName,
                strlen (((pProtInfo) temp->L_Element)->PI_AdapterName)) ;

        mbstowcs (((REQTYPECAST *)buffer)->EnumProtocols.protocols.
                RP_ProtocolInfo[i].RI_XportName,
                ((pProtInfo) temp->L_Element)->PI_XportName,
                strlen (((pProtInfo) temp->L_Element)->PI_XportName));

        ((REQTYPECAST*)buffer)->EnumProtocols.protocols.RP_ProtocolInfo[i].
               RI_AdapterName[
               strlen(((pProtInfo) temp->L_Element)->PI_AdapterName)] =
                                                        UNICODE_NULL ;

        ((REQTYPECAST*)buffer)->EnumProtocols.protocols.RP_ProtocolInfo[i].
          RI_XportName[strlen(((pProtInfo) temp->L_Element)->PI_XportName)] =
                                                        UNICODE_NULL;
    }




    ((REQTYPECAST*)buffer)->EnumProtocols.count = i ;

    ((REQTYPECAST*)buffer)->EnumProtocols.retcode = SUCCESS ;
}

VOID
SetFraming (pPCB ppcb, PBYTE buffer)
{
    DWORD       retcode ;
    DWORD       bytesrecvd ;
    NDISWAN_GET_LINK_INFO info ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace (
                    "SetFraming: port %d is unavailable",
                    ppcb->PCB_PortHandle);
        }

        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_NOT_CONNECTED ;

        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    info.hLinkHandle = ppcb->PCB_LinkHandle;

    retcode = DeviceIoControl(RasHubHandle,
                              IOCTL_NDISWAN_GET_LINK_INFO,
                              &info,
                              sizeof(NDISWAN_GET_LINK_INFO),
                              &info,
                              sizeof(NDISWAN_GET_LINK_INFO),
                              &bytesrecvd,
                              NULL) ;

    info.LinkInfo.SendFramingBits =
            ((REQTYPECAST *)buffer)->SetFraming.Sendbits ;

    info.LinkInfo.RecvFramingBits =
            ((REQTYPECAST *)buffer)->SetFraming.Recvbits ;

    info.LinkInfo.SendACCM =
            ((REQTYPECAST *)buffer)->SetFraming.SendbitMask ;

    info.LinkInfo.RecvACCM =
            ((REQTYPECAST *)buffer)->SetFraming.RecvbitMask ;

    retcode = DeviceIoControl(RasHubHandle,
                              IOCTL_NDISWAN_SET_LINK_INFO,
                              &info,
                              sizeof(NDISWAN_SET_LINK_INFO),
                              NULL,
                              0,
                              &bytesrecvd,
                              NULL) ;

    if (retcode == FALSE)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode = GetLastError() ;
    }
    else
    {
        ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;
    }
}

/*++

Routine Description:

    Perfrom some SLIP related actions on behalf of the UI

Arguments:

Return Value:

--*/
VOID
RegisterSlip (pPCB ppcb, PBYTE buffer)
{
    WORD                    i ;
    WORD                    numiprasadapters    = 0 ;
    DWORD                   retcode             = SUCCESS ;
    REQTYPECAST             reqBuf;
    CHAR                    szBuf[
                                sizeof(PROTOCOL_CONFIG_INFO)
                                + sizeof(IP_WAN_LINKUP_INFO)];

    PROTOCOL_CONFIG_INFO*   pProtocol           =
                                (PROTOCOL_CONFIG_INFO* )szBuf;

    /*
    RasIPLinkUpInfo*        pLinkUp             =
                                (RasIPLinkUpInfo* )pProtocol->P_Info;

    */

    IP_WAN_LINKUP_INFO*     pLinkUp =
                                (IP_WAN_LINKUP_INFO*)pProtocol->P_Info;


    WCHAR                   *pwszRasAdapter;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                   "RegisterSlip: port %d is unavailable",
                   ppcb->PCB_PortHandle );
        }

        retcode = ERROR_PORT_NOT_FOUND;

        goto done;
    }


    if (ppcb->PCB_PortStatus != OPEN)
    {
        retcode = ERROR_PORT_NOT_OPEN ;
        goto done ;
    }

    //
    // Allocate a route
    //
    reqBuf.AllocateRoute.type   = IP;
    reqBuf.AllocateRoute.wrknet = TRUE;

    AllocateRouteRequest ( ppcb, ( PBYTE ) &reqBuf );

    retcode = reqBuf.Route.retcode;

    if ( 0 != retcode )
    {
        goto done;
    }

    ZeroMemory(szBuf, sizeof(szBuf));

    pProtocol->P_Length     = sizeof(IP_WAN_LINKUP_INFO);
    pLinkUp->duUsage        = DU_CALLOUT;
    pLinkUp->dwLocalAddr    =
                ((REQTYPECAST*)buffer)->RegisterSlip.ipaddr;

    pLinkUp->fFilterNetBios = 0;

    reqBuf.ActivateRouteEx.type         = IP ;
    reqBuf.ActivateRouteEx.framesize    =
            ((REQTYPECAST*) buffer)->RegisterSlip.dwFrameSize ;

    memcpy ( reqBuf.ActivateRouteEx.config.P_Info,
             pProtocol->P_Info,
             pProtocol->P_Length );

    reqBuf.ActivateRouteEx.config.P_Length =
                                pProtocol->P_Length ;

    ActivateRouteExRequest( ppcb, ( PBYTE ) &reqBuf );

    retcode = reqBuf.Route.retcode;

    if (retcode != 0)
    {
        goto done ;
    }

    if (!(pwszRasAdapter =
        wcschr( &reqBuf.Route.info.RI_AdapterName[ 1 ], L'\\' )))
    {
        retcode = ERROR_NO_IP_RAS_ADAPTER;
        goto done;
    }

    ++pwszRasAdapter;

    //
    // If not loaded, load RAS IP HELPER entry points
    //
    if ( RasHelperSetDefaultInterfaceNetEx == NULL )
    {

        hinstIphlp = LoadLibrary( "rasppp.dll" );

        if ( hinstIphlp == (HINSTANCE)NULL )
        {
            retcode = GetLastError();

            goto done ;
        }

        RasHelperResetDefaultInterfaceNetEx =
                GetProcAddress( hinstIphlp,
                "HelperResetDefaultInterfaceNetEx");

        RasHelperSetDefaultInterfaceNetEx =
                GetProcAddress( hinstIphlp,
                "HelperSetDefaultInterfaceNetEx");

        if (    ( RasHelperResetDefaultInterfaceNetEx == NULL )
            ||  ( RasHelperSetDefaultInterfaceNetEx == NULL ) )
        {
            retcode = GetLastError();

            goto done ;
        }
    }

    //
    // First set the Slip interface information
    //
    retcode = (ULONG) RasHelperSetDefaultInterfaceNetEx(
                    ((REQTYPECAST*)buffer)->RegisterSlip.ipaddr,
                    pwszRasAdapter,
                    ((REQTYPECAST*)buffer)->RegisterSlip.priority,
                    ((REQTYPECAST*)buffer)->RegisterSlip.szDNSAddress,
                    ((REQTYPECAST*)buffer)->RegisterSlip.szDNS2Address,
                    ((REQTYPECAST*)buffer)->RegisterSlip.szWINSAddress,
                    ((REQTYPECAST*)buffer)->RegisterSlip.szWINS2Address
                    ) ;

    //
    // Save info for disconnect
    // Skip the '\device\'
    //
    memcpy (ppcb->PCB_DisconnectAction.DA_Device,
            reqBuf.Route.info.RI_AdapterName + 8,
            MAX_ARG_STRING_SIZE * sizeof (WCHAR)) ;


    ppcb->PCB_DisconnectAction.DA_IPAddress =
            ((REQTYPECAST*)buffer)->RegisterSlip.ipaddr ;

    ppcb->PCB_DisconnectAction.DA_fPrioritize =
            ((REQTYPECAST*)buffer)->RegisterSlip.priority;


    memcpy(
      ppcb->PCB_DisconnectAction.DA_DNSAddress,
      ((REQTYPECAST*)buffer)->RegisterSlip.szDNSAddress,
      17 * sizeof (WCHAR));

    memcpy(
      ppcb->PCB_DisconnectAction.DA_DNS2Address,
      ((REQTYPECAST*)buffer)->RegisterSlip.szDNS2Address,
      17 * sizeof (WCHAR));

    memcpy(
      ppcb->PCB_DisconnectAction.DA_WINSAddress,
      ((REQTYPECAST*)buffer)->RegisterSlip.szWINSAddress,
      17 * sizeof (WCHAR));

    memcpy(
      ppcb->PCB_DisconnectAction.DA_WINS2Address,
      ((REQTYPECAST*)buffer)->RegisterSlip.szWINS2Address,
      17 * sizeof (WCHAR));

    RasmanTrace(
           "RegisterSlip: fPriority=%d, ipaddr=0x%x, adapter=%ws"
           "dns=0x%x, dns2=0x%x, wins=0x%x, wins2=0x%x",
           ppcb->PCB_DisconnectAction.DA_fPrioritize,
           ppcb->PCB_DisconnectAction.DA_IPAddress,
           ppcb->PCB_DisconnectAction.DA_Device,
           ppcb->PCB_DisconnectAction.DA_DNSAddress,
           ppcb->PCB_DisconnectAction.DA_DNS2Address,
           ppcb->PCB_DisconnectAction.DA_WINSAddress,
           ppcb->PCB_DisconnectAction.DA_WINS2Address);


done:
    ((REQTYPECAST*)buffer)->Generic.retcode = retcode ;

}

VOID
StoreUserDataRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD   retcode = SUCCESS ;
    DWORD   dwSize  = ((REQTYPECAST *)
                      buffer)->OldUserData.size;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                
                "StoreUserDataRequest: port %d is unavailable",
                ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)
        buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_PortStatus != OPEN)
    {
        ((REQTYPECAST*)
        buffer)->Generic.retcode = ERROR_PORT_NOT_OPEN ;

        return ;
    }

    if (ppcb->PCB_UserStoredBlock != NULL)
    {
        LocalFree (ppcb->PCB_UserStoredBlock) ;
    }

    ppcb->PCB_UserStoredBlockSize = ((REQTYPECAST *)
                           buffer)->OldUserData.size;

    if (NULL == (ppcb->PCB_UserStoredBlock =
        (PBYTE) LocalAlloc (LPTR, ppcb->PCB_UserStoredBlockSize)))
    {
        retcode = GetLastError () ;
    }
    else
    {
        if (dwSize )
        {
            memcpy (ppcb->PCB_UserStoredBlock,
                    ((REQTYPECAST *)buffer)->OldUserData.data,
                    ppcb->PCB_UserStoredBlockSize) ;
        }
    }


    ((REQTYPECAST*)buffer)->Generic.retcode = retcode ;
}

VOID
RetrieveUserDataRequest (pPCB ppcb, PBYTE buffer)
{

    DWORD dwSize = ((REQTYPECAST *) buffer )->OldUserData.size;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus)
    {
        if (ppcb)
        {
            RasmanTrace(
                
                "RetrieveUserDataRequest: port %d is unavailable",
                ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)
        buffer)->OldUserData.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_PortStatus != OPEN)
    {
        ((REQTYPECAST*)
        buffer)->OldUserData.retcode = ERROR_PORT_NOT_OPEN ;

        return ;
    }

    if ( dwSize >= ppcb->PCB_UserStoredBlockSize )
    {
        memcpy (((REQTYPECAST *)buffer)->OldUserData.data,
                ppcb->PCB_UserStoredBlock,
                ppcb->PCB_UserStoredBlockSize) ;
    }

    ((REQTYPECAST *)
    buffer)->OldUserData.size = ppcb->PCB_UserStoredBlockSize ;

    ((REQTYPECAST*)
    buffer)->OldUserData.retcode = SUCCESS ;

}

VOID
GetFramingEx (pPCB ppcb, PBYTE buffer)
{
    DWORD       retcode = SUCCESS ;
    DWORD       bytesrecvd ;
    RAS_FRAMING_INFO      *temp ;
    NDISWAN_GET_LINK_INFO info ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace (
                    "GetFramingEx: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)buffer)->FramingInfo.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*)buffer)->FramingInfo.retcode =
                                    ERROR_NOT_CONNECTED ;
        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    info.hLinkHandle = ppcb->PCB_LinkHandle;

    retcode = DeviceIoControl(RasHubHandle,
                              IOCTL_NDISWAN_GET_LINK_INFO,
                              &info,
                              sizeof(NDISWAN_GET_LINK_INFO),
                              &info,
                              sizeof(NDISWAN_GET_LINK_INFO),
                              &bytesrecvd,
                              NULL) ;

    if (retcode == FALSE)
        retcode = GetLastError() ;
    else
    {
        temp = &((REQTYPECAST*)buffer)->FramingInfo.info ;

        temp->RFI_MaxSendFrameSize  =
                        info.LinkInfo.MaxSendFrameSize;

        temp->RFI_MaxRecvFrameSize  =
                        info.LinkInfo.MaxRecvFrameSize;

        temp->RFI_HeaderPadding     =
                        info.LinkInfo.HeaderPadding;

        temp->RFI_TailPadding       =
                        info.LinkInfo.TailPadding;

        temp->RFI_SendFramingBits   =
                        info.LinkInfo.SendFramingBits;

        temp->RFI_RecvFramingBits   =
                        info.LinkInfo.RecvFramingBits;

        temp->RFI_SendCompressionBits =
                        info.LinkInfo.SendCompressionBits;

        temp->RFI_RecvCompressionBits =
                        info.LinkInfo.RecvCompressionBits;

        temp->RFI_SendACCM  =
                        info.LinkInfo.SendACCM;

        temp->RFI_RecvACCM  =
                        info.LinkInfo.RecvACCM;
    }


    ((REQTYPECAST*)buffer)->FramingInfo.retcode = SUCCESS ;

}

VOID
SetFramingEx (pPCB ppcb, PBYTE buffer)
{
    DWORD       retcode ;
    DWORD       bytesrecvd ;
    RAS_FRAMING_INFO      *temp ;
    NDISWAN_SET_LINK_INFO info ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                   "SetFramingEx: port %d is unavailable",
                   ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)buffer)->FramingInfo.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*)buffer)->FramingInfo.retcode =
                                    ERROR_NOT_CONNECTED ;

        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    temp = &((REQTYPECAST*)buffer)->FramingInfo.info ;

    info.LinkInfo.MaxSendFrameSize  =
                        temp->RFI_MaxSendFrameSize;

    info.LinkInfo.MaxRecvFrameSize  =
                        temp->RFI_MaxRecvFrameSize;

    info.LinkInfo.MaxRSendFrameSize =
                        temp->RFI_MaxRSendFrameSize;

    info.LinkInfo.MaxRRecvFrameSize =
                        temp->RFI_MaxRRecvFrameSize;

    info.LinkInfo.HeaderPadding     =
                        temp->RFI_HeaderPadding   ;

    info.LinkInfo.TailPadding       =
                        temp->RFI_TailPadding     ;

    info.LinkInfo.SendFramingBits   =
                        temp->RFI_SendFramingBits    ;

    info.LinkInfo.RecvFramingBits   =
                        temp->RFI_RecvFramingBits    ;

    info.LinkInfo.SendCompressionBits  =
                        temp->RFI_SendCompressionBits;

    info.LinkInfo.RecvCompressionBits  =
                        temp->RFI_RecvCompressionBits;

    info.LinkInfo.SendACCM =
                        temp->RFI_SendACCM       ;

    info.LinkInfo.RecvACCM =
                        temp->RFI_RecvACCM       ;

    info.hLinkHandle = ppcb->PCB_LinkHandle;

    retcode = DeviceIoControl(RasHubHandle,
                              IOCTL_NDISWAN_SET_LINK_INFO,
                              &info,
                              sizeof(NDISWAN_SET_LINK_INFO),
                              &info,
                              sizeof(NDISWAN_SET_LINK_INFO),
                              &bytesrecvd,
                              NULL) ;

    if (retcode == FALSE)
    {
        ((REQTYPECAST*)buffer)->FramingInfo.retcode =
                                        GetLastError() ;
    }
    else
    {
        ((REQTYPECAST*)buffer)->FramingInfo.retcode =
                                                SUCCESS ;
    }
}

VOID
GetProtocolCompression (pPCB ppcb, PBYTE buffer)
{
    DWORD       retcode = SUCCESS ;
    DWORD       bytesrecvd ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace (
                    "GetProtocolCompression: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)buffer)->ProtocolComp.retcode =
                                                ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*)buffer)->ProtocolComp.retcode =
                                                ERROR_NOT_CONNECTED;
        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    if (((REQTYPECAST*)buffer)->ProtocolComp.type == IP)
    {
        NDISWAN_GET_VJ_INFO info ;

        info.hLinkHandle = ppcb->PCB_LinkHandle;

        retcode = DeviceIoControl(RasHubHandle,
                                  IOCTL_NDISWAN_GET_VJ_INFO,
                                  &info,
                                  sizeof(NDISWAN_GET_VJ_INFO),
                                  &info,
                                  sizeof(NDISWAN_GET_VJ_INFO),
                                  &bytesrecvd,
                                  NULL) ;

        if (retcode == FALSE)
        {
            ((REQTYPECAST*)buffer)->ProtocolComp.retcode =
                                                    GetLastError() ;
        }
        else
        {
            ((REQTYPECAST*)buffer)->ProtocolComp.retcode = SUCCESS ;
        }

        ((REQTYPECAST*)buffer)->ProtocolComp.send.RP_ProtocolType.
                        RP_IP.RP_IPCompressionProtocol =
                        info.SendCapabilities.IPCompressionProtocol;

        ((REQTYPECAST*)buffer)->ProtocolComp.send.RP_ProtocolType.
                        RP_IP.RP_MaxSlotID =
                        info.SendCapabilities.MaxSlotID ;

        ((REQTYPECAST*)buffer)->ProtocolComp.send.RP_ProtocolType.
                        RP_IP.RP_CompSlotID =
                        info.SendCapabilities.CompSlotID ;


        ((REQTYPECAST*)buffer)->ProtocolComp.recv.RP_ProtocolType.
                        RP_IP.RP_IPCompressionProtocol =
                        info.RecvCapabilities.IPCompressionProtocol ;

        ((REQTYPECAST*)buffer)->ProtocolComp.recv.RP_ProtocolType.
                        RP_IP.RP_MaxSlotID =
                        info.RecvCapabilities.MaxSlotID ;

        ((REQTYPECAST*)buffer)->ProtocolComp.recv.RP_ProtocolType.
                        RP_IP.RP_CompSlotID =
                        info.RecvCapabilities.CompSlotID ;

        ((REQTYPECAST*)buffer)->ProtocolComp.type = IP ;

    }
    else
    {
        ((REQTYPECAST*)buffer)->ProtocolComp.retcode =
                                        ERROR_NOT_SUPPORTED;
    }
}

VOID
SetProtocolCompression (pPCB ppcb, PBYTE buffer)
{
    DWORD       retcode = SUCCESS ;
    DWORD       bytesrecvd ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace( 
                    "SetProtocolCompression: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_NOT_CONNECTED ;
        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    if (((REQTYPECAST*)buffer)->ProtocolComp.type == IP)
    {
        NDISWAN_SET_VJ_INFO info ;

        info.hLinkHandle = ppcb->PCB_LinkHandle;

        info.SendCapabilities.IPCompressionProtocol =
             ((REQTYPECAST*)buffer)->ProtocolComp.send.
                RP_ProtocolType.RP_IP.RP_IPCompressionProtocol;

        info.SendCapabilities.MaxSlotID =
             ((REQTYPECAST*)buffer)->ProtocolComp.send.
                RP_ProtocolType.RP_IP.RP_MaxSlotID ;

        info.SendCapabilities.CompSlotID =
             ((REQTYPECAST*)buffer)->ProtocolComp.send.
             RP_ProtocolType.RP_IP.RP_CompSlotID ;

        info.RecvCapabilities.IPCompressionProtocol=
             ((REQTYPECAST*)buffer)->ProtocolComp.recv.
             RP_ProtocolType.RP_IP.RP_IPCompressionProtocol ;

        info.RecvCapabilities.MaxSlotID =
             ((REQTYPECAST*)buffer)->ProtocolComp.recv.
             RP_ProtocolType.RP_IP.RP_MaxSlotID ;

        info.RecvCapabilities.CompSlotID =
             ((REQTYPECAST*)buffer)->ProtocolComp.recv.
             RP_ProtocolType.RP_IP.RP_CompSlotID ;


        retcode = DeviceIoControl(RasHubHandle,
                          IOCTL_NDISWAN_SET_VJ_INFO,
                          &info,
                          sizeof(NDISWAN_SET_VJ_INFO),
                          &info,
                          sizeof(NDISWAN_SET_VJ_INFO),
                          &bytesrecvd,
                          NULL) ;

        if (retcode == FALSE)
        {
            ((REQTYPECAST*)buffer)->Generic.retcode =
                                        GetLastError() ;
        }
        else
        {
            ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;
        }
    }
    else
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_NOT_SUPPORTED;
    }

}

VOID
MapCookieToEndpoint (pPCB ppcb, HANDLE cookie)
{
    WORD        i ;
    DWORD       length ;
    DWORD       bytesrecvd ;

    PNDISWAN_MAP_CONNECTION_ID  MapConnectionID = NULL;

    NDISWAN_GET_WAN_INFO GetWanInfo;
    WORD        currentmac = 0 ;

    if (ppcb == NULL)
    {
        return;
    }

    if(INVALID_HANDLE_VALUE == RasHubHandle)
    {
        DWORD retcode;

        RasmanTrace(
               "MapCookieToEndPoint: Attempting"
               " to start ndiswan.."
               );

        if(SUCCESS != (retcode = DwStartAndAssociateNdiswan()))
        {
            RasmanTrace(
                   "MapcookieToEndPoint: failed to start ndiswan. 0x%x",
                   retcode);

            return;
        }

        RasmanTrace(
               "MapCookieToEndPoint: successfully started"
               " ndiswan");
    }

    length = sizeof(NDISWAN_MAP_CONNECTION_ID) +
                    sizeof(ppcb->PCB_Name);

    if ((MapConnectionID =
        (PNDISWAN_MAP_CONNECTION_ID)
        LocalAlloc (LPTR, length)) == NULL)
    {
        GetLastError() ;
        return ;
    }

    MapConnectionID->hConnectionID = (NDIS_HANDLE)cookie;
    MapConnectionID->hLinkContext = (NDIS_HANDLE)ppcb;
    MapConnectionID->hBundleContext = (NDIS_HANDLE)ppcb->PCB_Bundle;
    MapConnectionID->ulNameLength = sizeof(ppcb->PCB_Name);

    memmove(MapConnectionID->szName,
           ppcb->PCB_Name,
           sizeof(ppcb->PCB_Name));

    // Make the actual call.
    //
    if (DeviceIoControl (RasHubHandle,
                         IOCTL_NDISWAN_MAP_CONNECTION_ID,
                         MapConnectionID,
                         length,
                         MapConnectionID,
                         length,
                         &bytesrecvd,
                         NULL) == FALSE)
    {
        DWORD retcode;
        ppcb->PCB_LinkHandle = INVALID_HANDLE_VALUE ;
        ppcb->PCB_BundleHandle = INVALID_HANDLE_VALUE ;
        LocalFree (MapConnectionID) ;
        retcode = GetLastError() ;

        RasmanTrace(
               "MapCookieToEndPoint: failed with error 0x%x for port %s",
               retcode,
               ppcb->PCB_Name);

        return ;
    }

    ppcb->PCB_LinkHandle = MapConnectionID->hLinkHandle;
    ppcb->PCB_BundleHandle = MapConnectionID->hBundleHandle;

    RasmanTrace(
           "%s %d: Mapping Cookie to handle. port = %s(0x%x), "
           "Bundlehandle = 0x%x, linkhandle = 0x%x",
            __FILE__, __LINE__, ppcb->PCB_Name,
            ppcb, ppcb->PCB_BundleHandle, ppcb->PCB_LinkHandle);

    if (ppcb->PCB_Bundle != NULL)
    {
        ppcb->PCB_Bundle->B_NdisHandle = ppcb->PCB_BundleHandle;
    }
    else
    {
        RasmanTrace(
                "%s,%d: MapCookieToEndPoint: ppcb->PCB_Bundle "
                "is NULL!!", __FILE__, __LINE__);
    }

    LocalFree (MapConnectionID) ;

    //
    // Get the link speed
    //
    GetWanInfo.hLinkHandle = ppcb->PCB_LinkHandle;

    // Make the actual call.
    //
    if (DeviceIoControl (RasHubHandle,
             IOCTL_NDISWAN_GET_WAN_INFO,
             &GetWanInfo,
             sizeof(NDISWAN_GET_WAN_INFO),
             &GetWanInfo,
             sizeof(NDISWAN_GET_WAN_INFO),
             &bytesrecvd,
             NULL) == FALSE)
        return;

    ppcb->PCB_LinkSpeed = GetWanInfo.WanInfo.LinkSpeed;

}

#if UNMAP

VOID
UnmapEndPoint(pPCB ppcb)
{
    NDISWAN_UNMAP_CONNECTION_ID UnmapConnectionID;
    DWORD bytesrcvd;

    if(     (NULL == ppcb)
        ||  (INVALID_HANDLE_VALUE == RasHubHandle))
    {
        RasmanTrace(
               "UnmapEndPoint: ppcb=NULL or RasHubHandle=NULL");
        goto done;               
    }

    if(INVALID_HANDLE_VALUE == ppcb->PCB_LinkHandle)
    {
        RasmanTrace(
               "link handle for %s = INVALID_HANDLE_VALUE",
               ppcb->PCB_Name);

        goto done;               
    }

    UnmapConnectionID.hLinkHandle = ppcb->PCB_LinkHandle;

    if(!DeviceIoControl(
            RasHubHandle,
            IOCTL_NDISWAN_UNMAP_CONNECTION_ID,
            &UnmapConnectionID,
            sizeof(UnmapConnectionID),
            NULL,
            0,
            &bytesrcvd,
            NULL))
    {
        DWORD dwErr = GetLastError();
        
        RasmanTrace(
              "UnmapEndPoint: couldn't unmap end point %s. error = 0x%x",
              ppcb->PCB_Name,
              dwErr);
    }

    ppcb->PCB_LinkHandle = INVALID_HANDLE_VALUE;

done:
    return;

}


#endif

VOID
GetStatisticsFromNdisWan(pPCB ppcb, DWORD *stats)
{
    DWORD          bytesrecvd ;
    NDISWAN_GET_STATS   getstats ;

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    getstats.hHandle = ppcb->PCB_LinkHandle;
    getstats.usHandleType = LINKHANDLE;

    if (DeviceIoControl (RasHubHandle,
                          IOCTL_NDISWAN_GET_STATS,
                          &getstats,
                          sizeof(NDISWAN_GET_STATS),
                          &getstats,
                          sizeof(NDISWAN_GET_STATS),
                          &bytesrecvd,
                          NULL) == FALSE)
    {
        DWORD dwErr;

        dwErr = GetLastError();

        RasmanTrace( 
               "GetLinkStatisticsFromNdiswan: rc=0x%x",
                dwErr);

        memset(stats, '\0', sizeof (getstats.Stats));
    }
    else
    {
        memcpy (stats,
                &getstats.Stats,
                sizeof (getstats.Stats)) ;
    }

    return;
}

VOID
GetBundleStatisticsFromNdisWan(pPCB ppcb, DWORD *stats)
{
    DWORD          bytesrecvd ;
    NDISWAN_GET_STATS   getstats ;

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    getstats.hHandle = ppcb->PCB_BundleHandle;
    getstats.usHandleType = BUNDLEHANDLE;

    if (DeviceIoControl (RasHubHandle,
                          IOCTL_NDISWAN_GET_STATS,
                          &getstats,
                          sizeof(NDISWAN_GET_STATS),
                          &getstats,
                          sizeof(NDISWAN_GET_STATS),
                          &bytesrecvd,
                          NULL) == FALSE)
    {
        DWORD dwErr;

        dwErr = GetLastError();

        RasmanTrace( 
               "GetBundleStatisticsFromNdiswan: rc=0x%x",
                dwErr);

        memset(stats, '\0', sizeof (WAN_STATS));
    }
    else
    {
        memcpy (stats,
                &getstats.Stats.BundleStats,
                sizeof(WAN_STATS)) ;
    }

    return;
}

VOID
GetFramingCapabilities(pPCB ppcb, PBYTE buffer)
{
    DWORD       retcode = SUCCESS ;
    DWORD       bytesrecvd ;
    RAS_FRAMING_CAPABILITIES    caps ;
    WORD        i ;
    NDISWAN_GET_WAN_INFO    GetWanInfo;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                
                "GetFramingCapabilities: port %d is unavailable",
                ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)
        buffer)->FramingCapabilities.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }


    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*)
        buffer)->FramingCapabilities.retcode = ERROR_NOT_CONNECTED;

        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    GetWanInfo.hLinkHandle = ppcb->PCB_LinkHandle;


    // Make the actual call.
    //
    if (DeviceIoControl (RasHubHandle,
             IOCTL_NDISWAN_GET_WAN_INFO,
             &GetWanInfo,
             sizeof(NDISWAN_GET_WAN_INFO),
             &GetWanInfo,
             sizeof(NDISWAN_GET_WAN_INFO),
             &bytesrecvd,
             NULL) == FALSE)
    {
        retcode = GetLastError() ;
    }

    if (retcode == SUCCESS)
    {

        // copy info into temp. storage
        //
        caps.RFC_MaxFrameSize = GetWanInfo.WanInfo.MaxFrameSize;
        caps.RFC_FramingBits = GetWanInfo.WanInfo.FramingBits;
        caps.RFC_DesiredACCM = GetWanInfo.WanInfo.DesiredACCM;

        caps.RFC_MaxReconstructedFrameSize =
                    GetWanInfo.WanInfo.MaxReconstructedFrameSize ;

        memcpy (&((REQTYPECAST*)buffer)->FramingCapabilities.caps,
                &caps,
                sizeof (RAS_FRAMING_CAPABILITIES)) ;

    }
    else
    {
        retcode = ERROR_NOT_CONNECTED;
    }

    ((REQTYPECAST*)buffer)->FramingCapabilities.retcode = retcode ;
}

DWORD
MergeConnectionBlocks ( pPCB pcbPort, pPCB pcbToMerge )
{
    DWORD           retcode         = SUCCESS;
    ConnectionBlock *pConn          = pcbPort->PCB_Connection,
                    *pConnToMerge   = pcbToMerge->PCB_Connection;
    UINT            cPorts;
    DWORD           dwSubEntry;

    RasmanTrace(
           "MergeConnectionBlocks: %s -> %s",
           pcbPort->PCB_Name,
           pcbToMerge->PCB_Name);

    RasmanTrace(
           "MergeConnectionBlocks: setting bap links pid to %d",
            pcbPort->PCB_Connection->CB_dwPid);
    //
    // BAP is bringing up a port on the clients behalf
    // So, make client the owner of this port
    //
    pcbToMerge->PCB_OwnerPID = pcbPort->PCB_Connection->CB_dwPid;

    if (pConn == pConnToMerge)
    {

        RasmanTrace(
               "MergeConnectionBlocks: Merge not required");

        goto done;

    }

    if (    NULL == pConn
        ||  NULL == pConnToMerge)
    {
        RasmanTrace(
               "MergeConnectionBlocks: pConn (0x%x) or "
               "pConnToMerge (0x%x) is 0",
               pConn,
               pConnToMerge);

        retcode = ERROR_NO_CONNECTION;

        goto done;
    }

    dwSubEntry = pcbToMerge->PCB_SubEntry;

    //
    // Merge the connection blocks
    //
    if (dwSubEntry > pConn->CB_MaxPorts)
    {
        struct  PortControlBlock    **pHandles;
        DWORD                       dwcPorts    = dwSubEntry + 5;

        pHandles = LocalAlloc(LPTR,
                   dwcPorts * sizeof (struct PortControlBlock *));

        if (pHandles == NULL)
        {
            retcode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        if (pConn->CB_PortHandles != NULL)
        {
            memcpy(
              pHandles,
              pConn->CB_PortHandles,
              pConn->CB_MaxPorts * sizeof (struct PortControlBlock *));

            LocalFree(pConn->CB_PortHandles);
        }

        pConn->CB_PortHandles   = pHandles;
        pConn->CB_MaxPorts      = dwcPorts;
    }

    pConn->CB_PortHandles[dwSubEntry - 1] = pcbToMerge;
    pConn->CB_Ports++;

    pcbToMerge->PCB_Connection    = pConn;
    pcbToMerge->PCB_SubEntry      = dwSubEntry;

    pConnToMerge->CB_Ports -= 1;

    //
    // Remove the port from the connection.
    //
    pConnToMerge->CB_PortHandles[dwSubEntry - 1] = NULL;

    //
    // Free the connection block of the merged ppcb
    //
    if ( 0 == pConnToMerge->CB_Ports )
    {
        FreeConnection ( pConnToMerge );
    }

done:
    RasmanTrace( 
            "MergeConnectionBlocks: done. %d",
            retcode);

    return retcode;

}

/*++

Routine Description:

    This routine is called to Bundle two ports
    together as per the the multilink RFC. The
    scheme used is as follows:For each "bundle"
    a Bundle block is created. All bundled ports
    point to this Bundle block (ppcb->PCB_Bundle).
    In addition, the routes allocated to the bundle
    are now stored in the Bundle.

Arguments:

Return Value:

    Nothing.

--*/
VOID
PortBundle (pPCB ppcb, PBYTE buffer)
{
    pPCB    bundlepcb ;
    HPORT   porttobundle ;
    DWORD   bytesrecvd ;
    pList   temp ;
    pList   plist ;
    Bundle  *freebundle = NULL ;
    DWORD   retcode = SUCCESS ;
    NDISWAN_ADD_LINK_TO_BUNDLE  AddLinkToBundle;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus)
    {
        if (ppcb)
        {
            RasmanTrace(
                   "PortBundle: port %d is unavailable",
                   ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)
        buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }


    //
    // Check to see if the port is connected
    //
    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*)
        buffer)->Generic.retcode = ERROR_NOT_CONNECTED ;
        return ;
    }

    //
    // get handle to the second port being bundled
    //
    porttobundle = ((REQTYPECAST *)
                   buffer)->PortBundle.porttobundle;

    bundlepcb = GetPortByHandle(porttobundle);

    if (bundlepcb == NULL)
    {
        ((REQTYPECAST*)
        buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;
        return;
    }

    //
    // Check to see if the port is connected
    //
    if (bundlepcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST*)
        buffer)->Generic.retcode = ERROR_NOT_CONNECTED ;

        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    //
    // Tell Ndiswan to bundle
    //
    AddLinkToBundle.hBundleHandle = ppcb->PCB_BundleHandle;

    AddLinkToBundle.hLinkHandle = bundlepcb->PCB_LinkHandle;

    RasmanTrace(
           "PortBundle: bundle port=%d, link port=%d",
           ppcb->PCB_PortHandle,
           bundlepcb->PCB_PortHandle);

    if (DeviceIoControl (RasHubHandle,
                         IOCTL_NDISWAN_ADD_LINK_TO_BUNDLE,
                         &AddLinkToBundle,
                         sizeof(NDISWAN_ADD_LINK_TO_BUNDLE),
                         NULL,
                         0,
                         &bytesrecvd,
                         NULL) == FALSE)
    {
        retcode = GetLastError () ;

        RasmanTrace( 
                "PortBundle: DeviceIoControl returned %d\n",
                retcode);

        goto PortBundleEnd ;
    }

    //
    // Free the port being bundled bundle block: this is done
    // because we always allocate a bundle block on
    // connection, since the two ports will have a single
    // bundle block one must go.
    //
    freebundle = bundlepcb->PCB_Bundle;

    //
    // Update this ports bundle handle to the handle
    //
    bundlepcb->PCB_BundleHandle = ppcb->PCB_BundleHandle;

    //
    // Attach bundlepcb to the same bundle
    //
    bundlepcb->PCB_Bundle = ppcb->PCB_Bundle ;

    bundlepcb->PCB_LastBundle = bundlepcb->PCB_Bundle;

    //
    // Increment Bundle count for new pcb
    //
    bundlepcb->PCB_Bundle->B_Count++ ;

    //
    // Attach bundlepcb's routes to the allocate route
    // list in the bundle
    //
    plist = bundlepcb->PCB_Bindings;

    while (plist)
    {
        temp = plist->L_Next ;

        plist->L_Next = bundlepcb->PCB_Bundle->B_Bindings ;

        bundlepcb->PCB_Bundle->B_Bindings = plist ;

        plist = temp ;
    }

    bundlepcb->PCB_Bindings = NULL ;

    //
    // Don't free the merged bundle if the entries being dialed
    // are different.
    //
    if(     (NULL != bundlepcb->PCB_Connection)
        &&  (NULL != ppcb->PCB_Connection)
        &&  ((0 !=
            _stricmp(
            ppcb->PCB_Connection->CB_ConnectionParams.CP_PhoneEntry,
            bundlepcb->PCB_Connection->CB_ConnectionParams.CP_PhoneEntry))
        ||  (0 !=
            _stricmp(
            ppcb->PCB_Connection->CB_ConnectionParams.CP_Phonebook,
            bundlepcb->PCB_Connection->CB_ConnectionParams.CP_Phonebook))))
    {
        RasmanTrace(
               "PortBundle: connections %s,%s bundled. Not merging",
              ppcb->PCB_Connection->CB_ConnectionParams.CP_PhoneEntry,
              bundlepcb->PCB_Connection->CB_ConnectionParams.CP_PhoneEntry);

        FreeBundle(freebundle);

        goto done;
    }

    //
    // Merge the hconns if different hconns are created
    // for the ports that got bundled.This may happen when
    // BAP brings up an additional link.
    //
    if (    ppcb->PCB_Connection
        &&  bundlepcb->PCB_Connection )
    {
        retcode = MergeConnectionBlocks( ppcb, bundlepcb );
    }

PortBundleEnd:


    //
    // Signal notifiers waiting for bandwidth changes.
    //
    if (!retcode)
    {
        RasmanTrace(
               "PortBundle: BANDWIDTHADDED for port %s, "
               "connection 0x%x, bundle 0x%x",
                bundlepcb->PCB_Name,
                bundlepcb->PCB_Connection,
                bundlepcb->PCB_Bundle );

        SignalNotifiers(pConnectionNotifierList,
                        NOTIF_BANDWIDTHADDED, 0);


        if (bundlepcb->PCB_Connection != NULL)
        {
            SignalNotifiers(
              bundlepcb->PCB_Connection->CB_NotifierList,
              NOTIF_BANDWIDTHADDED,
              0);

            g_RasEvent.Type    = ENTRY_BANDWIDTH_ADDED;
            retcode = DwSendNotificationInternal(
                        bundlepcb->PCB_Connection, &g_RasEvent);

            RasmanTrace(
                   "DwSendNotificationInternal(ENTRY_BANDWIDTH_ADDED)"
                   " rc=0x%08x",
                   retcode);

            retcode = SUCCESS;
        }
    }

    //
    // Do the freeing of freebundle block here
    //
    if (freebundle != NULL)
    {
        if (freebundle->B_Count > 1)
        {
            RTASSERT(freebundle->B_Count <= 1);
        }
        FreeBundle(freebundle);
    }

done:
    ((REQTYPECAST*)buffer)->Generic.retcode = retcode ;
}

/*++

Routine Description:

    Go thru all ports and find a port that is connected
    and has its bundle context the same as the last
    bundle context for the given port.

Arguments:

Return Value:

    Nothing.

--*/
VOID
GetBundledPort (pPCB ppcb, PBYTE buffer)
{
    ULONG i ;
    pPCB  temppcb ;

    if (ppcb == NULL)
    {
        ((REQTYPECAST*)
        buffer)->GetBundledPort.retcode = ERROR_PORT_NOT_FOUND;
        return;
    }


    for (i = 0; i < MaxPorts; i++)
    {

        temppcb = GetPortByHandle((HPORT) UlongToPtr(i));

        if (    temppcb == NULL
            ||  temppcb == ppcb)
        {
            continue ;
        }


        if (    (temppcb->PCB_ConnState == CONNECTED)
            &&  (temppcb->PCB_Bundle == (Bundle *)
                            ppcb->PCB_LastBundle))
        {
            break ;
        }
    }

    if (i < MaxPorts)
    {

        ((REQTYPECAST*)
        buffer)->GetBundledPort.retcode = SUCCESS;

        ((REQTYPECAST*)
        buffer)->GetBundledPort.port = temppcb->PCB_PortHandle;


    }
    else
    {
        ((REQTYPECAST*)
        buffer)->GetBundledPort.retcode = ERROR_PORT_NOT_FOUND;
    }

}


/*++

Routine Description:

    This routine is called to get the Bundle handle
    given a port handle

Arguments:

Return Value:

    Nothing.

--*/
VOID
PortGetBundle (pPCB ppcb, PBYTE buffer)
{
    if (ppcb == NULL)
    {
        ((REQTYPECAST*)
        buffer)->PortGetBundle.retcode = ERROR_PORT_NOT_FOUND;
        return;
    }

    if (ppcb->PCB_ConnState == CONNECTED)
    {
        ((REQTYPECAST*)
        buffer)->PortGetBundle.bundle = ppcb->PCB_Bundle->B_Handle;

        ((REQTYPECAST*)
        buffer)->PortGetBundle.retcode = SUCCESS;
    }
    else
    {
        ((REQTYPECAST*)
        buffer)->PortGetBundle.retcode = ERROR_PORT_NOT_CONNECTED;
    }
}


/*++

Routine Description:

    This routine is called to get port handle
    given the Bundle handle

Arguments:

Return Value:

    Nothing.

--*/
VOID
BundleGetPort (pPCB ppcb, PBYTE buffer)
{
    ULONG i ;
    HBUNDLE hbundle = ((REQTYPECAST*)
                       buffer)->BundleGetPort.bundle ;

    for (i = 0; i < MaxPorts; i++)
    {

        ppcb = GetPortByHandle((HPORT) UlongToPtr(i));
        if (ppcb == NULL)
        {
            continue;
        }

        if (    (ppcb->PCB_ConnState == CONNECTED)
            &&  (ppcb->PCB_Bundle->B_Handle == hbundle))
        {
            break ;
        }
    }

    if (i < MaxPorts)
    {

       ((REQTYPECAST*)
       buffer)->BundleGetPort.retcode = SUCCESS;

       ((REQTYPECAST*)
       buffer)->BundleGetPort.port = ppcb->PCB_PortHandle;

    }
    else
    {
       ((REQTYPECAST*)
       buffer)->BundleGetPort.retcode = ERROR_PORT_NOT_FOUND;
    }
}


/*++

Routine Description:

    This routine increments/decrements the reference count
    on the shared memory buffer.

Arguments:

Return Value:

    Nothing.

--*/
VOID
ReferenceRasman (pPCB ppcb, PBYTE buffer)
{
    DWORD dwPid = ((REQTYPECAST *)
                   buffer )->AttachInfo.dwPid;

    RasmanTrace(
           "ReferenceRasman: process %d",
           dwPid );

    if (((REQTYPECAST*)buffer)->AttachInfo.fAttach)
    {
        g_dwAttachedCount++;

        if (GetCurrentProcessId () != dwPid)
        {
            AddProcessInfo ( dwPid );
        }


    }
    else
    {
        //
        // Cleanup the resources held by this process
        //
        if (GetCurrentProcessId () != dwPid)
        {
            if (!CleanUpProcess (dwPid))
            {
                //
                // If the client process is not found
                // don't decrement the refcount. Just bail
                //
                goto done;
            }
        }

        //
        // If there are no more references, then
        // shut down the service.
        //
        if (!--g_dwAttachedCount)
        {
            REQTYPECAST reqtypecast;

            AnyPortsOpen( NULL, ( PBYTE ) &reqtypecast );

            if ( reqtypecast.Generic.retcode )
            {

                RasmanTrace( 
                        "Rasman not quitting because "
                        "ports are still open");

                goto done;
            }

            RasmanTrace( 
                    "Posting Close Event from ReferenceRasman");

            if (!PostQueuedCompletionStatus(hIoCompletionPort,
                                    0,0,
                                    (LPOVERLAPPED) &RO_CloseEvent))
            {
                RasmanTrace(
                       "%s, %d: Failed to post "
                       "close event. GLE = %d",
                      __FILE__, __LINE__,
                      GetLastError());
            }
        }
    }

done:
    RasmanTrace(
           "Rasman RefCount = %d",
           g_dwAttachedCount );

    ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS;
}


/*++

Routine Description:

    Get the stored dial parameters from Lsa.

Arguments:

Return Value:

    Nothing.

--*/
VOID
GetDialParams (pPCB ppcb, PBYTE buffer)
{
    DWORD dwUID, dwErr, dwMask;
    PRAS_DIALPARAMS pDialParams;
    PWCHAR pszSid;

    dwUID = ((REQTYPECAST*)buffer)->DialParams.dwUID;

    dwMask = ((REQTYPECAST*)buffer)->DialParams.dwMask;

    pDialParams =
        &(((REQTYPECAST*)buffer)->DialParams.params);

    pszSid = ((REQTYPECAST*)buffer)->DialParams.sid;

    // dwMask &= (~DLPARAMS_MASK_PASSWORD);

    dwErr = GetEntryDialParams(
                pszSid,
                dwUID,
                &dwMask,
                pDialParams,
                ((REQTYPECAST *)buffer)->DialParams.dwPid);

    //
    // Copy the mask of fields copied
    // back into the request block.
    //
    ((REQTYPECAST*)buffer)->DialParams.dwMask = dwMask;
    ((REQTYPECAST*)buffer)->DialParams.retcode = dwErr;
}


/*++

Routine Description:

    Store new dial parameters into Lsa.

Arguments:

Return Value:

    Nothing.

--*/
VOID
SetDialParams (pPCB ppcb, PBYTE buffer)
{
    DWORD dwUID, dwErr, dwMask, dwSetMask = 0, dwClearMask = 0;
    PRAS_DIALPARAMS pDialParams;
    BOOL fDelete;
    PWCHAR pszSid;

    dwUID = ((REQTYPECAST*)buffer)->DialParams.dwUID;

    dwMask = ((REQTYPECAST*)buffer)->DialParams.dwMask;

    pDialParams = &(((REQTYPECAST*)buffer)->DialParams.params);

    fDelete = ((REQTYPECAST*)buffer)->DialParams.fDelete;

    pszSid = ((REQTYPECAST*)buffer)->DialParams.sid;

    if (fDelete)
    {
        dwClearMask = dwMask;
    }
    else
    {
        dwSetMask = dwMask;
    }

    dwErr = SetEntryDialParams(
              pszSid,
              dwUID,
              dwSetMask,
              dwClearMask,
              pDialParams);

    ((REQTYPECAST*)buffer)->DialParams.retcode = dwErr;
}

ConnectionBlock *
FindConnectionFromEntry(
                CHAR *pszPhonebookPath,
                CHAR *pszEntryName,
                DWORD dwSubEntries,
                DWORD *pdwSubEntryInfo
                )
{
    ConnectionBlock *pConn = NULL;

    PLIST_ENTRY pEntry;

    pPCB ppcb;

    UINT i;

    //
    // Loop through the connection blocks and see if we have a
    // connection that dialed out on this entry
    //
    for (pEntry = ConnectionBlockList.Flink;
         pEntry != &ConnectionBlockList;
         pEntry = pEntry->Flink)
    {
        pConn = CONTAINING_RECORD(pEntry, ConnectionBlock, CB_ListEntry);

        if (    _stricmp(pszPhonebookPath,
                         pConn->CB_ConnectionParams.CP_Phonebook)
            ||  _stricmp(pszEntryName,
                         pConn->CB_ConnectionParams.CP_PhoneEntry))
        {
            pConn = NULL;
            continue;
        }

        for (i = 0; i < pConn->CB_MaxPorts; i++)
        {
            ppcb = pConn->CB_PortHandles[i];

            if (ppcb != NULL)
            {
                if (i < dwSubEntries)
                {
                    RasmanTrace(
                    
                    "FindConnectionFromEntry: dwSubEntry"
                    " %d is connected on %s",
                    i + 1,
                    ppcb->PCB_Name);

                    pdwSubEntryInfo[i] = 1;
                }

            }
            else if (   i < dwSubEntries
                    &&  pdwSubEntryInfo)
            {
                pdwSubEntryInfo[i] = 0;
            }
        }

        break;
    }

    return pConn;
}

/*++

Routine Description:

    Create a rasapi32 connection block
    and link it on the global chain of
    connection blocks

Arguments:

Return Value:

    Nothing.

--*/
VOID
CreateConnection (pPCB pPortControlBlock, PBYTE buffer)
{
    DWORD dwErr;

    ConnectionBlock *pConn;

    pPCB ppcb;

    HCONN   hConn = 0;

    CHAR    *pszPhonebookPath = ((REQTYPECAST *)
                                buffer)->Connection.szPhonebookPath;

    CHAR    *pszEntryName = ((REQTYPECAST *)
                            buffer)->Connection.szEntryName;

    CHAR    *pszRefPbkPath = ((REQTYPECAST *)
                             buffer)->Connection.szRefPbkPath;

    CHAR    *pszRefEntryName = ((REQTYPECAST *)
                                buffer)->Connection.szRefEntryName;

    DWORD   dwSubEntries = ((REQTYPECAST *)
                            buffer)->Connection.dwSubEntries;

    DWORD   dwDialMode = ((REQTYPECAST *)
                          buffer)->Connection.dwDialMode;

    DWORD   *pdwSubEntryInfo = (DWORD *) ((REQTYPECAST *)
                                buffer)->Connection.data;

    GUID    *pGuidEntry = &((REQTYPECAST *)
                            buffer)->Connection.guidEntry;

    PLIST_ENTRY pEntry;

    DWORD i;

    ULONG ulNextConnection;

    RasmanTrace (
            "CreateConnection: entry=%s, pbk=%s",
            pszEntryName,
            pszPhonebookPath );

    memset (pdwSubEntryInfo,
            0,
            dwSubEntries * sizeof (DWORD));

    if(2 != dwDialMode)
    {
        pConn = FindConnectionFromEntry(pszPhonebookPath,
                                        pszEntryName,
                                        dwSubEntries,
                                        pdwSubEntryInfo);

        if (pConn)
        {
            if(pConn->CB_Signaled)
            {
                hConn = pConn->CB_Handle;
                pConn->CB_RefCount += 1;

                RasmanTrace( 
                        "CreateConnection: "
                        "Entry Already connected. "
                        "hconn=0x%x, "
                        "ref=%d, "
                        "pConn=0x%x",
                        pConn->CB_Handle,
                        pConn->CB_RefCount,
                        pConn );

                ((REQTYPECAST *)
                buffer)->Connection.dwEntryAlreadyConnected =
                (DWORD) RCS_CONNECTED;

                goto done;
            }
            else
            {
                DWORD dw;
                
                //
                // Check to see if any of the ports in this
                // connection got to CONNECTING state. Only
                // free up the connection if all ports in the
                // connection are in DISCONNECTED state
                //
                for(dw = 0; dw < pConn->CB_MaxPorts; dw++)
                {
                    pPCB pcbT = pConn->CB_PortHandles[dw];

                    if(     (NULL != pcbT)
                        &&  (DISCONNECTED != pcbT->PCB_ConnState))
                    {
                        break;
                    }
                }
                
                //
                // Before deciding that we are in the process of
                // connecting, lets make sure that the porcess
                // that initiated this dial is still alive..
                //
                if(     (dw != pConn->CB_MaxPorts)
                    ||  ((NULL != pConn->CB_Process)
                    &&  fIsProcessAlive(pConn->CB_Process)))
                {
                    RasmanTrace( 
                            "CreateConnection: "
                            "dial in progress. "
                            "hconn=0x%x, "
                            "ref=%d, "
                            "pConn=0x%x",
                            pConn->CB_Handle,
                            pConn->CB_RefCount,
                            pConn );

                    ((REQTYPECAST *)
                    buffer)->Connection.dwEntryAlreadyConnected =
                    (DWORD) RCS_CONNECTING;

                    goto done;
                }
                else
                {
                    RasmanTrace( 
                            "CreateConnection: another dial is"
                            " in progress. The process initiating "
                            " this dial is not longer alive ."
                            " hconn=0x%x, "
                            "ref=%d, "
                            "pConn=0x%x",
                            pConn->CB_Handle,
                            pConn->CB_RefCount,
                            pConn );
                    //
                    // Free the connection
                    //
                    FreeConnection(pConn);
                    pConn = NULL;

                    ((REQTYPECAST *)
                    buffer)->Connection.dwEntryAlreadyConnected =
                    (DWORD) RCS_NOT_CONNECTED;
                }
            }
        }
        else
        {
            ((REQTYPECAST *)
            buffer)->Connection.dwEntryAlreadyConnected =
            (DWORD) RCS_NOT_CONNECTED;
        }
    }
    else
    {
        RasmanTrace(
               "CreateConnection:Dialasneeded is set");

        ((REQTYPECAST *)
        buffer)->Connection.dwEntryAlreadyConnected =
        (DWORD) RCS_NOT_CONNECTED;
    }

    pConn = LocalAlloc(LPTR, sizeof (ConnectionBlock));

    if (pConn == NULL)
    {
        ((REQTYPECAST*)
        buffer)->Connection.retcode = GetLastError();

        return;
    }

    ulNextConnection = HandleToUlong(NextConnectionHandle);

    //
    // Reset the next connection handle to 0
    // when it hits the upper limit.
    //
    if (ulNextConnection >= 0xffff)
    {
        NextConnectionHandle = NULL;
        ulNextConnection = 0;
    }

    ulNextConnection += 1;

    NextConnectionHandle = (HANDLE) UlongToPtr(ulNextConnection);

    //
    // Connection handles always have the
    // low order word as zeroes to distinguish
    // them from port handles.
    //
    pConn->CB_Handle = (HANDLE) UlongToPtr((ulNextConnection << 16));

    pConn->CB_Signaled = FALSE;

    pConn->CB_NotifierList = NULL;

    memset(&pConn->CB_ConnectionParams,
           '\0',
           sizeof (RAS_CONNECTIONPARAMS));

    //
    // Copy the pbk name and entry so that redialing
    // the same entry doesn't create another connection
    // block.
    //
    strcpy( pConn->CB_ConnectionParams.CP_Phonebook,
            pszPhonebookPath);

    strcpy( pConn->CB_ConnectionParams.CP_PhoneEntry,
            pszEntryName);

    pConn->CB_Flags &= ~(CONNECTION_VALID);

    InitializeListHead(&pConn->CB_UserData);
    pConn->CB_NotifierList = NULL;
    pConn->CB_PortHandles = NULL;
    pConn->CB_MaxPorts = 0;
    pConn->CB_Ports = 0;
    pConn->CB_RefCount = 1;
    pConn->CB_SubEntries = dwSubEntries;
    pConn->CB_fAlive = TRUE;
    pConn->CB_Process = OpenProcess(
                        PROCESS_ALL_ACCESS,
                        FALSE,
                        ((REQTYPECAST*)buffer)->Connection.pid);

    pConn->CB_dwPid = ((REQTYPECAST*)buffer)->Connection.pid;

    pConn->CB_CustomCount = 0;

    memcpy(&pConn->CB_GuidEntry,
           pGuidEntry,
           sizeof(GUID));

    InsertTailList(&ConnectionBlockList, &pConn->CB_ListEntry);

    //
    // If a referred connection is present, store its handle
    // in the connection block. We will use this handle to
    // disconnect the referred connection when the pptp
    // connection is brought down.
    //
    if(     '\0' != pszRefPbkPath[0]
        &&  '\0' != pszRefEntryName[0])
    {
        ConnectionBlock *pConnRef =
                    FindConnectionFromEntry(pszRefPbkPath,
                                            pszRefEntryName,
                                            0, NULL);
        if(pConnRef)
        {
            RasmanTrace(
                   "Found referred Entry. 0x%08x",
                   pConnRef->CB_Handle);

            pConn->CB_ReferredEntry = pConnRef->CB_Handle;
        }
        else
        {
            RasmanTrace(
                   "No referred entry found");
        }
    }

    RasmanTrace( 
            "CreateConnection: Created new connection. "
            "hconn=0x%x, ref=%d, pConn=0x%x",
            pConn->CB_Handle,
            pConn->CB_RefCount,
            pConn );
done:

    ((REQTYPECAST*)buffer)->Connection.conn = pConn->CB_Handle;

    ((REQTYPECAST*)buffer)->Connection.retcode = SUCCESS;
}


/*++

Routine Description:

    Delete a rasapi32 connection block
    and close all connected ports.

Arguments:

Return Value:

    Nothing.

--*/
VOID
DestroyConnection (pPCB ppcb, PBYTE buffer)
{
    DWORD dwErr = SUCCESS, i;
    ConnectionBlock *pConn;
    HCONN hConn = ((REQTYPECAST*)buffer)->Connection.conn;
    DWORD dwMaxPorts;
    BOOL fConnectionValid = TRUE;

    //
    // Find the connection block.
    //
    pConn = FindConnection(hConn);

    RasmanTrace(
           "DestroyConnection: hConn=0x%x, pConn=0x%x",
           hConn,
           pConn);

    if (pConn == NULL)
    {
        ((REQTYPECAST*)
        buffer)->Connection.retcode = ERROR_NO_CONNECTION;

        return;
    }
    //
    // Enumerate all ports in the connection and call
    // PortClose() for each.  Read CB_MaxPorts now,
    // because pConn could be freed inside the loop.
    //
    dwMaxPorts = pConn->CB_MaxPorts;
    for (i = 0; i < dwMaxPorts; i++)
    {
        ppcb = pConn->CB_PortHandles[i];

        if (ppcb != NULL)
        {
            dwErr = PortClose(
                      ppcb,
                      ((REQTYPECAST*)
                      buffer)->Connection.pid,
                      TRUE,
                      FALSE);

            //
            // Check for ERROR_ACCESS_DENIED
            // returned by PortClose.  If this
            // is returned, we might as well
            // break out of the loop.  Otherwise,
            // ignore the return code.
            //
            if (dwErr == ERROR_ACCESS_DENIED)
            {
                break;
            }

            dwErr = 0;

            //
            // NOTE! pConn could have been
            // freed if we closed the last port
            // associated with the connection.
            // So it's possible that pConn
            // is no longer valid at this point.
            //
            fConnectionValid = (FindConnection(hConn) != NULL);

            if (!fConnectionValid)
            {
                RasmanTrace(
                       "DestroyConnection: pConn=0x%x no "
                       "longer valid",
                       pConn);

                break;
            }
        }
    }

    ((REQTYPECAST*)buffer)->Connection.retcode = dwErr;
}


/*++

Routine Description:

    Enumerate active connections.

Arguments:

Return Value:

    Nothing.

--*/
VOID
EnumConnection (pPCB ppcb, PBYTE buffer)
{
    PLIST_ENTRY pEntry;

    ConnectionBlock *pConn;

    DWORD i, dwEntries  = 0;

    HCONN UNALIGNED *lphconn =
            (HCONN UNALIGNED *)&((REQTYPECAST*)buffer)->Enum.buffer;

    DWORD dwSize = ((REQTYPECAST *)buffer)->Enum.size;

    for (pEntry = ConnectionBlockList.Flink;
         pEntry != &ConnectionBlockList;
         pEntry = pEntry->Flink)
    {
        pConn = CONTAINING_RECORD(pEntry, ConnectionBlock, CB_ListEntry);

        for (i = 0; i < pConn->CB_MaxPorts; i++)
        {
            ppcb = pConn->CB_PortHandles[i];

            if (    ppcb != NULL
                &&  ppcb->PCB_ConnState == CONNECTED)
            {
                if (dwSize >= sizeof(HCONN))
                {
                    lphconn[dwEntries] = pConn->CB_Handle;

                    dwSize -= sizeof(HCONN);
                }

                dwEntries += 1;

                break;

            }
        }
    }

    ((REQTYPECAST*)buffer)->Enum.size       =
                        (WORD) (dwEntries * sizeof (HCONN));

    ((REQTYPECAST*)buffer)->Enum.entries    = (WORD) dwEntries;
    ((REQTYPECAST*)buffer)->Enum.retcode    = SUCCESS;
}


/*++

Routine Description:

    Associate a connection block with a port.

Arguments:

Return Value:

    Nothing.

--*/
VOID
AddConnectionPort (pPCB ppcb, PBYTE buffer)
{
    ConnectionBlock *pConn;
    DWORD dwSubEntry =
        ((REQTYPECAST*)buffer)->AddConnectionPort.dwSubEntry;

    //
    // Sub entry indexes are 1-based.
    //
    if (!dwSubEntry)
    {
        ((REQTYPECAST*)buffer)->AddConnectionPort.retcode =
                                    ERROR_WRONG_INFO_SPECIFIED;
        return;
    }

    //
    // Find the connection block.
    //
    pConn = FindConnection(
            ((REQTYPECAST*)buffer)->AddConnectionPort.conn);

    if (pConn == NULL)
    {
        ((REQTYPECAST*)buffer)->AddConnectionPort.retcode =
                                            ERROR_NO_CONNECTION;

        return;
    }

    //
    // Check to see if the subentry already has a port assigned and
    // return error if it does
    // 
    if(     (NULL != pConn->CB_PortHandles)
        &&  (dwSubEntry <= pConn->CB_MaxPorts)
        &&  (NULL != pConn->CB_PortHandles[dwSubEntry - 1]))
    {
        ((REQTYPECAST*)buffer)->AddConnectionPort.retcode =
                                            ERROR_PORT_ALREADY_OPEN;

        RasmanTrace("Subentry %d in Conn is already present",
                    dwSubEntry, pConn->CB_Handle);

        return;                                            
    }

    //
    // Check to see if we need to extend
    // the port array.
    //
    if (dwSubEntry > pConn->CB_MaxPorts)
    {
        struct PortControlBlock **pHandles;
        DWORD dwcPorts = dwSubEntry + 5;

        pHandles = LocalAlloc(
                     LPTR,
                     dwcPorts * sizeof (struct PortControlBlock *));
        if (pHandles == NULL)
        {
            ((REQTYPECAST*)buffer)->AddConnectionPort.retcode =
                                        ERROR_NOT_ENOUGH_MEMORY;

            return;
        }
        if (pConn->CB_PortHandles != NULL)
        {
            memcpy(
              pHandles,
              pConn->CB_PortHandles,
              pConn->CB_MaxPorts * sizeof (struct PortControlBlock *));

            LocalFree(pConn->CB_PortHandles);
        }

        pConn->CB_PortHandles = pHandles;
        pConn->CB_MaxPorts = dwcPorts;
    }

    //
    // Assign the port.  Sub entry indexes are
    // 1-based.
    //
    pConn->CB_PortHandles[dwSubEntry - 1] = ppcb;
    pConn->CB_Ports++;

    RasmanTrace(
      
      "AddConnectionPort: pConn=0x%x, pConn->CB_Ports=%d,"
      " port=%d, dwSubEntry=%d",
      pConn,
      pConn->CB_Ports,
      ppcb->PCB_PortHandle,
      dwSubEntry);

    ppcb->PCB_Connection = pConn;
    ppcb->PCB_SubEntry = dwSubEntry;

    ((REQTYPECAST*)buffer)->AddConnectionPort.retcode = SUCCESS;
}


/*++

Routine Description:

    Return all ports associated with a connection

Arguments:

Return Value:

    Nothing.

--*/
VOID
EnumConnectionPorts(pPCB ppcb, PBYTE buffer)
{
    DWORD i, j = 0;

    ConnectionBlock *pConn;

    RASMAN_PORT *lpPorts =
                (RASMAN_PORT *)((REQTYPECAST*)
                buffer)->EnumConnectionPorts.buffer;

    PLIST_ENTRY pEntry;

    DWORD dwSize =
        ((REQTYPECAST*)
        buffer)->EnumConnectionPorts.size;

    //
    // Find the connection block.
    //
    pConn = FindConnection(
        ((REQTYPECAST*)buffer)->EnumConnectionPorts.conn);

    if (pConn == NULL)
    {
        ((REQTYPECAST*)buffer)->EnumConnectionPorts.size = 0;

        ((REQTYPECAST*)buffer)->EnumConnectionPorts.entries = 0;

        ((REQTYPECAST*)buffer)->EnumConnectionPorts.retcode =
                                            ERROR_NO_CONNECTION;

        return;
    }

    //
    // Enumerate all ports in the bundle and call
    // CopyPort() for each.
    //
    for (i = 0; i < pConn->CB_MaxPorts; i++)
    {
        ppcb = pConn->CB_PortHandles[i];

        if (ppcb != NULL)
        {
            if ( dwSize >= sizeof(RASMAN_PORT))
            {
                CopyPort(ppcb, &lpPorts[j] , FALSE);

                dwSize -= sizeof(RASMAN_PORT);
            }

            j += 1;
        }
    }

    ((REQTYPECAST*)buffer)->EnumConnectionPorts.size =
                                    j * sizeof (RASMAN_PORT);

    ((REQTYPECAST*)buffer)->EnumConnectionPorts.entries = j;

    ((REQTYPECAST*)buffer)->EnumConnectionPorts.retcode = SUCCESS;
}


/*++

Routine Description:

    Retrieve rasapi32 bandwidth-on-demand, idle disconnect,
    and redial-on-link-failure parameters for a bundle

Arguments:

Return Value:

    Nothing.

--*/
VOID
GetConnectionParams (pPCB ppcb, PBYTE buffer)
{
    ConnectionBlock *pConn;
    PRAS_CONNECTIONPARAMS pParams;

    //
    // Find the connection block.
    //
    pConn = FindConnection(
        ((REQTYPECAST*)buffer)->ConnectionParams.conn);

    if (pConn == NULL)
    {
        ((REQTYPECAST*)buffer)->ConnectionParams.retcode =
                                            ERROR_NO_CONNECTION;

        return;
    }

    if ( pConn->CB_Flags & CONNECTION_VALID )
    {
        memcpy(
              &(((REQTYPECAST*)buffer)->ConnectionParams.params),
              &pConn->CB_ConnectionParams,
              sizeof (RAS_CONNECTIONPARAMS));
    }


    ((REQTYPECAST*)buffer)->ConnectionParams.retcode = SUCCESS;
}


/*++

Routine Description:

    Store rasapi32 bandwidth-on-demand, idle disconnect,
    and redial-on-link-failure parameters for a bundle

Arguments:

Return Value:

    Nothing.

--*/
VOID
SetConnectionParams (pPCB ppcb, PBYTE buffer)
{
    ConnectionBlock *pConn;

    //
    // Find the connection block.
    //
    pConn = FindConnection(
            ((REQTYPECAST*)buffer)->ConnectionParams.conn);

    if (pConn == NULL)
    {
        ((REQTYPECAST*)buffer)->ConnectionParams.retcode =
                                        ERROR_NO_CONNECTION;

        return;
    }

    pConn->CB_Flags |= CONNECTION_VALID;

    memcpy(
          &pConn->CB_ConnectionParams,
          &(((REQTYPECAST*)buffer)->ConnectionParams.params),
          sizeof (RAS_CONNECTIONPARAMS));


    ((REQTYPECAST*)buffer)->ConnectionParams.retcode = SUCCESS;
}


/*++

Routine Description:

    Retrieve per-connection user data

Arguments:

Return Value:

    Nothing.

--*/
VOID
GetConnectionUserData (pPCB ppcb, PBYTE buffer)
{
    DWORD           dwTag;
    ConnectionBlock *pConn;
    UserData        *pUserData;
    DWORD           dwSize      =
                ((REQTYPECAST *) buffer)->ConnectionUserData.dwcb;

    //
    // Find the connection block.
    //
    pConn = FindConnection(
            ((REQTYPECAST*)buffer)->ConnectionUserData.conn);

    if (pConn == NULL)
    {
        ((REQTYPECAST*)buffer)->ConnectionUserData.retcode =
                                            ERROR_NO_CONNECTION;

        return;
    }

    //
    // Look up the user data object.
    //
    dwTag = ((REQTYPECAST *)buffer)->ConnectionUserData.dwTag;

    pUserData = GetUserData(&pConn->CB_UserData, dwTag);

    if (pUserData != NULL)
    {
        if (dwSize >= pUserData->UD_Length)
        {
            memcpy (
              ((REQTYPECAST *)buffer)->ConnectionUserData.data,
              &pUserData->UD_Data,
              pUserData->UD_Length);
        }

        ((REQTYPECAST *)buffer)->ConnectionUserData.dwcb =
          pUserData->UD_Length;
    }
    else
    {
        ((REQTYPECAST *)buffer)->ConnectionUserData.dwcb = 0;
    }

    ((REQTYPECAST*)buffer)->ConnectionUserData.retcode = SUCCESS;
}


/*++

Routine Description:

    Store per-connection user data

Arguments:

Return Value:

    Nothing.

--*/
VOID
SetConnectionUserData (pPCB ppcb, PBYTE buffer)
{
    ConnectionBlock *pConn;

    //
    // Find the connection block.
    //
    pConn = FindConnection(
        ((REQTYPECAST*)buffer)->ConnectionUserData.conn);

    if (pConn == NULL)
    {
        ((REQTYPECAST*)buffer)->ConnectionUserData.retcode =
                                        ERROR_NO_CONNECTION;

        return;
    }

    //
    // Store the user data object.
    //
    SetUserData(
      &pConn->CB_UserData,
      ((REQTYPECAST *)buffer)->ConnectionUserData.dwTag,
      ((REQTYPECAST *)buffer)->ConnectionUserData.data,
      ((REQTYPECAST *)buffer)->ConnectionUserData.dwcb);

    ((REQTYPECAST*)buffer)->ConnectionUserData.retcode = SUCCESS;
}


/*++

Routine Description:

    Retrieve per-port user data

Arguments:

Return Value:

    Nothing.

--*/
VOID
GetPortUserData (pPCB ppcb, PBYTE buffer)
{
    UserData *pUserData = NULL;
    DWORD     dwSize = ((REQTYPECAST *)buffer)->PortUserData.dwcb;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace( 
                    "GetPortUserData: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)buffer)->PortUserData.retcode =
                                            ERROR_PORT_NOT_FOUND;

        return;
    }

    //
    // Look up the user data object.
    //
    if (ppcb->PCB_PortStatus == OPEN)
    {
        pUserData = GetUserData(
                      &ppcb->PCB_UserData,
                      ((REQTYPECAST *)buffer)->PortUserData.dwTag);
    }
    if (pUserData != NULL)
    {
        if ( dwSize >= pUserData->UD_Length )
        {
            memcpy (
              ((REQTYPECAST *)buffer)->PortUserData.data,
              &pUserData->UD_Data,
              pUserData->UD_Length);
        }

        ((REQTYPECAST *)buffer)->PortUserData.dwcb =
                                    pUserData->UD_Length;
    }
    else
    {
        ((REQTYPECAST *)buffer)->PortUserData.dwcb = 0;
    }

    ((REQTYPECAST*)buffer)->PortUserData.retcode = SUCCESS;
}


/*++

Routine Description:

    Store per-port user data

Arguments:

Return Value:

    Nothing.

--*/
VOID
SetPortUserData (pPCB ppcb, PBYTE buffer)
{
    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                   "SetPortUserData: port %d is unavailable",
                   ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)buffer)->PortUserData.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }

    //
    // Special case PORT_CREDENTIALS_INDEX. Redirect to
    // CONNECTION_CREDENTIALS_INDEX.
    //
    if(((REQTYPECAST *)buffer)->PortUserData.dwTag ==
                        PORT_CREDENTIALS_INDEX)
    {
        SaveEapCredentials(ppcb, buffer);
        return;
    }


    //
    // Store the user data object.
    //
    if (ppcb->PCB_PortStatus == OPEN)
    {
        SetUserData(
          &ppcb->PCB_UserData,
          ((REQTYPECAST *)buffer)->PortUserData.dwTag,
          (BYTE UNALIGNED *) ((REQTYPECAST *)buffer)->PortUserData.data,
          ((REQTYPECAST *)buffer)->PortUserData.dwcb);
    }


    ((REQTYPECAST*)buffer)->PortUserData.retcode = SUCCESS;
}


VOID
PppStop (pPCB ppcb, PBYTE buffer)
{
    if (ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }


    if ( ppcb->PCB_ConnState != CONNECTED )
    {
        //
        // If we are disconnected then PPP is already stopped
        //
        ((REQTYPECAST*)buffer)->Generic.retcode = NO_ERROR;
    }
    else
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                            (DWORD) RasSendPPPMessageToEngine(
                                &(((REQTYPECAST*)buffer)->PppEMsg));
    }


}

DWORD
DwGetPassword(pPCB ppcb, CHAR *pszPassword, DWORD dwPid)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwDialParamsUID;
    PWCHAR pszSid = NULL;
    UserData *pData = NULL;
    RAS_DIALPARAMS DialParams;
    DWORD dwMask =
        DLPARAMS_MASK_PASSWORD | DLPARAMS_MASK_OLDSTYLE;

    ASSERT(NULL != pszPassword);

    ZeroMemory((PBYTE) &DialParams, sizeof(RAS_DIALPARAMS));

    pData = GetUserData(
              &ppcb->PCB_UserData,
              PORT_USERSID_INDEX);

    if(NULL == pData)
    {
        RasmanTrace(
               "DwGetPassword: sid not found");

        dwErr = E_FAIL;
        goto done;
    }

    pszSid = (WCHAR *) pData->UD_Data;

    pData = GetUserData(
          &ppcb->PCB_UserData,
          PORT_DIALPARAMSUID_INDEX);

    if(NULL == pData)
    {
        RasmanTrace(
              "DwGetPassword: paramsuid not found");

        dwErr = E_FAIL;
        goto done;
    }

    dwDialParamsUID = (DWORD) *((DWORD *) pData->UD_Data);

    dwErr = GetEntryDialParams(
                pszSid,
                dwDialParamsUID,
                &dwMask,
                &DialParams,
                GetCurrentProcessId());

    if(     (ERROR_SUCCESS != dwErr)
        ||  (0 == (dwMask & DLPARAMS_MASK_PASSWORD)))
    {
        RasmanTrace(
               "DwGetPassword: failed to get dialparams. 0x%x",
               dwErr);

        dwErr = E_FAIL;

        goto done;
    }

    if('\0' == DialParams.DP_Password)
    {
        goto done;
    }

    //
    // Now convert the password to ansi from unicode
    //
    if(!WideCharToMultiByte(
            CP_ACP,
            0,
            DialParams.DP_Password,
            -1,
            pszPassword,
            PWLEN + 1 ,
            NULL, NULL))
    {
        dwErr = GetLastError();

        RasmanTrace(
            
            "DwGetPassword: failed to convert pwd to ansi. 0x%x",
            dwErr);
    }

    if(     (dwMask & DLPARAMS_MASK_DEFAULT_CREDS)
        &&  (NULL != ppcb->PCB_Connection))
    {
        ppcb->PCB_Connection->CB_Flags |= CONNECTION_DEFAULT_CREDS;
    }
    
done:
    return dwErr;
}

VOID
PppStart (pPCB ppcb, PBYTE buffer)
{
    RPC_STATUS rpcstatus = RPC_S_OK;
    HANDLE hToken = INVALID_HANDLE_VALUE;
    UserData *pUserData;
    BYTE* pEapUIData = NULL;
    DWORD dwSizeOfEapUIData = 0;
    
    if (ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_PORT_NOT_FOUND;
        return;
    }


    if ( ppcb->PCB_ConnState != CONNECTED )
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                ERROR_PORT_DISCONNECTED;

        goto done;
    }

    if(NULL == ppcb->PCB_Connection)
    {
        RasmanTrace(
            
            "PppStart: ERROR_NO_CONNECTION for port %s",
            ppcb->PCB_PortHandle);

        ((REQTYPECAST*)buffer)->Generic.retcode =
                                ERROR_NO_CONNECTION;

        goto done;
    }

    //
    // Get the EAP Interactive UI data
    //

    pUserData = GetUserData(&(ppcb->PCB_Connection->CB_UserData),
                           CONNECTION_CUSTOMAUTHINTERACTIVEDATA_INDEX);

    if (pUserData != NULL)
    {
        pEapUIData = LocalAlloc(LPTR, pUserData->UD_Length);

        if (NULL == pEapUIData)
        {
            rpcstatus = GetLastError();
            goto done;
        }

        memcpy (
          pEapUIData,
          &pUserData->UD_Data,
          pUserData->UD_Length);

        dwSizeOfEapUIData = pUserData->UD_Length;
    }

    ppcb->PCB_PppEvent =
        DuplicateHandleForRasman(
            ((REQTYPECAST*)buffer)->PppEMsg.ExtraInfo.Start.hEvent,
            ((REQTYPECAST*)buffer)->PppEMsg.ExtraInfo.Start.dwPid );

    if(GetCurrentProcessId() !=
        ((REQTYPECAST*)buffer)->PppEMsg.ExtraInfo.Start.dwPid )
    {

        rpcstatus = RpcImpersonateClient ( g_hRpcHandle );

        if ( RPC_S_OK != rpcstatus )
        {
            RasmanTrace( 
                    "PppStart: RpcImpersonateClient"
                    " for %s failed. %d",
                    ppcb->PCB_Name,
                    rpcstatus );

            goto done;
        }


        if ( !OpenThreadToken (GetCurrentThread(),
                                TOKEN_ALL_ACCESS,
                                FALSE,
                                &hToken) )
        {
            rpcstatus = GetLastError();

            RasmanTrace(
                   "PppStart: OpenThreadToken failed "
                   "for %s. %d",
                   ppcb->PCB_Name,
                   rpcstatus );

            if ( !RevertToSelf())
            {
                rpcstatus = GetLastError();

                RasmanTrace(
                       "PppStart: ReverToSelf() failed "
                       "for %s. %d",
                       ppcb->PCB_Name,
                       rpcstatus );
            }

            goto done;
        }

        if ( ! RevertToSelf())
        {
            rpcstatus = GetLastError();

            RasmanTrace( 
                    "PppStart:RevertToSelf failed for %s. %d",
                    ppcb->PCB_Name,
                    rpcstatus );

            goto done;
        }


        //
        // If the username is not NULL and password is NULL
        // try to get the users password from lsa.
        //
        if( ('\0' != ((REQTYPECAST*)
                    buffer)->PppEMsg.ExtraInfo.Start.szUserName[0])
        &&  IsDummyPassword(((REQTYPECAST*)
                    buffer)->PppEMsg.ExtraInfo.Start.szPassword))
        {
            DWORD dwErr;

            dwErr = DwGetPassword(
                    ppcb,
                    ((REQTYPECAST*)
                    buffer)->PppEMsg.ExtraInfo.Start.szPassword,
                    ((REQTYPECAST*)buffer)->PppEMsg.ExtraInfo.Start.dwPid);

            if(ERROR_SUCCESS != dwErr)
            {
                RasmanTrace(
                       "PppStart: Failed to retrieve password for port %d",
                       ppcb->PCB_PortHandle);
            }
            
        }
        else if('\0' != ((REQTYPECAST*)
                    buffer)->PppEMsg.ExtraInfo.Start.szUserName[0])
        {
            CHAR *pszPasswordTemp;
            DWORD dwErr;

            pszPasswordTemp = LocalAlloc(LPTR, PWLEN + 1);

            if(NULL != pszPasswordTemp)
            {
            
                //
                // Get the password so that we know if its a global password
                // or not
                //
                dwErr = DwGetPassword(
                            ppcb,
                            pszPasswordTemp,
                            ((REQTYPECAST *)
                            buffer)->PppEMsg.ExtraInfo.Start.dwPid);

                if(ERROR_SUCCESS == dwErr)
                {
                    if(strcmp(pszPasswordTemp,
                        ((REQTYPECAST*)
                        buffer)->PppEMsg.ExtraInfo.Start.szPassword))
                    {
                        //
                        // clear the default creds flag
                        //
                        ppcb->PCB_Connection->CB_Flags &= 
                                    ~(CONNECTION_DEFAULT_CREDS);                    
                    
                    }
                    
                }
                
                SecureZeroMemory(pszPasswordTemp, PWLEN + 1);
                LocalFree(pszPasswordTemp);
            }
        }
    }

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.pszPhonebookPath =
                                ppcb->PCB_pszPhonebookPath;

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.pszEntryName =
                                ppcb->PCB_pszEntryName;

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.pszPhoneNumber =
                                ppcb->PCB_pszPhoneNumber;

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.hToken = hToken;

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.pCustomAuthConnData =
                                ppcb->PCB_pCustomAuthData;

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.pCustomAuthUserData =
                                ppcb->PCB_pCustomAuthUserData;

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.EapUIData.dwContextId = 0;

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.EapUIData.dwSizeOfEapUIData =
                                dwSizeOfEapUIData;

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.EapUIData.pEapUIData =
                                pEapUIData;

    //
    // Make sure that this doesn't get freed here.
    //
    pEapUIData = NULL;

    ((REQTYPECAST*)
    buffer)->PppEMsg.ExtraInfo.Start.fLogon =
                                ppcb->PCB_fLogon;

    //
    // If we have a password, save it in the cred manager
    //
    if(     !IsDummyPassword(((REQTYPECAST*)
                    buffer)->PppEMsg.ExtraInfo.Start.szPassword)
        &&  (GetCurrentProcessId() !=
                    ((REQTYPECAST*)
                    buffer)->PppEMsg.ExtraInfo.Start.dwPid ))
    {

        DWORD dwErr;

        dwErr = DwCacheCredMgrCredentials(
                &(((REQTYPECAST*)buffer)->PppEMsg),
                ppcb);

        if(ERROR_SUCCESS != dwErr)
        {
            RasmanTrace(
                "PppStart: DwCacheCredentials failed. 0x%x",
                dwErr);
        }

#if 0        
        RASMAN_CREDENTIALS *pCreds = NULL;
        
        //
        // Store the credentials to be saved with credential manager.
        // Encode password before we copy it to local memory.
        //
        pCreds = LocalAlloc(LPTR, sizeof(RASMAN_CREDENTIALS));

        if(NULL == pCreds)
        {
            //
            // This is not fatal. If we fail to save with Credmanager,
            // the client might get a lot of challenges from credmgr
            // which is not a fatal sideeffect.
            //
            RasmanTrace(
                   "PppStart: Failed to allocate. %d",
                   GetLastError());

            goto done;               
        }

        strcpy(pCreds->szUserName,
                ((REQTYPECAST*)
                buffer)->PppEMsg.ExtraInfo.Start.szUserName);

        strcpy(pCreds->szDomain,            
                ((REQTYPECAST*)
                buffer)->PppEMsg.ExtraInfo.Start.szDomain);

        strcpy(pCreds->szPassword,
                ((REQTYPECAST*)
                buffer)->PppEMsg.ExtraInfo.Start.szPassword);

        EncodePw(pCreds->szPassword);
                
        SetUserData(&(ppcb->PCB_Connection->CB_UserData),
                   CONNECTION_CREDENTIALS_INDEX,
                   (PBYTE) pCreds,
                   sizeof(RASMAN_CREDENTIALS));

        LocalFree(pCreds);               
#endif

    }
    
                                

    ((REQTYPECAST*)
    buffer)->Generic.retcode =
                      (DWORD) RasSendPPPMessageToEngine(
                              &(((REQTYPECAST*)buffer)->PppEMsg) );

    ppcb->PCB_RasmanReceiveFlags |= RECEIVE_PPPSTART;


    
done:

    if(NULL != pEapUIData)
    {
        LocalFree(pEapUIData);
    }
    ((REQTYPECAST *)buffer)->Generic.retcode = rpcstatus;

}

VOID
PppRetry (pPCB ppcb, PBYTE buffer)
{
    DWORD retcode = ERROR_SUCCESS;
    
    if (ppcb == NULL)
    {
        retcode = ERROR_PORT_NOT_FOUND;
        goto done;
    }

    if ( ppcb->PCB_ConnState != CONNECTED )
    {
        retcode = ERROR_PORT_DISCONNECTED;
        goto done;
    }
    else
    {
        if(IsDummyPassword(
            (((REQTYPECAST*)buffer)->PppEMsg.ExtraInfo.Retry.szPassword)))
        {
            retcode = DwGetPassword(ppcb, 
                (((REQTYPECAST*)buffer)->PppEMsg.ExtraInfo.Retry.szPassword),
                GetCurrentProcessId());

            if(ERROR_SUCCESS != retcode)
            {
                RasmanTrace(
                       "PppRetry: failed to retrieve password");
            }
        }
        
        //
        // Cache the new password to be saved in credmgr.
        //
        retcode = DwCacheCredMgrCredentials(
                    &(((REQTYPECAST*)buffer)->PppEMsg),
                    ppcb);
                    
        retcode = (DWORD)RasSendPPPMessageToEngine(
                      &(((REQTYPECAST*)buffer)->PppEMsg) );

    }

done:
    ((REQTYPECAST*)buffer)->Generic.retcode = retcode;
}

VOID
PppGetEapInfo(pPCB ppcb, PBYTE buffer)
{
    DWORD dwError     = NO_ERROR;

    PPP_MESSAGE *pPppMsg = NULL;

    DWORD dwSubEntry;

    HCONN hConn = ((REQTYPECAST*)
                  buffer)->GetEapInfo.hConn;

    ConnectionBlock *pConn = FindConnection(hConn);

    DWORD dwSize = ((REQTYPECAST*)
                    buffer)->GetEapInfo.dwSizeofEapUIData;

    if (NULL == pConn)
    {
        RasmanTrace(
               "PppGetEapInfo: failed to find connection 0x%x",
               hConn);

        dwError = ERROR_NO_CONNECTION;

        goto done;
    }

    RasmanTrace(
           "PppGetEapInfo: %s",
           ppcb->PCB_Name);

    dwSubEntry = ((REQTYPECAST*)buffer)->GetEapInfo.dwSubEntry;

    if (    dwSubEntry > pConn->CB_MaxPorts
        ||  NULL == (ppcb = pConn->CB_PortHandles[dwSubEntry - 1]))
    {
        RasmanTrace(
               "PppGetEapInfo: failed to find port. hConn=0x%x, "
               "SubEntry=%d", hConn, dwSubEntry);

        dwError = ERROR_PORT_NOT_FOUND;
        goto done;
    }

    if (ppcb->PCB_ConnState != CONNECTED)
    {
        dwError = ERROR_PORT_DISCONNECTED;
    }
    else if (ppcb->PCB_PppQHead == NULL)
    {
        dwError = ERROR_NO_MORE_ITEMS;
    }
    else
    {
        pPppMsg = ppcb->PCB_PppQHead;

        if ( dwSize >=
             pPppMsg->ExtraInfo.InvokeEapUI.dwSizeOfUIContextData)
        {

            memcpy(
                ((REQTYPECAST*)buffer)->GetEapInfo.data,
                pPppMsg->ExtraInfo.InvokeEapUI.pUIContextData,
                pPppMsg->ExtraInfo.InvokeEapUI.dwSizeOfUIContextData
                );

            //
            // Remove the msg from the queue
            //
            ppcb->PCB_PppQHead = pPppMsg->pNext;

            if( ppcb->PCB_PppQHead == NULL )
            {
                ppcb->PCB_PppQTail = NULL;
            }
        }

        ((REQTYPECAST*)buffer)->GetEapInfo.dwSizeofEapUIData =
                 pPppMsg->ExtraInfo.InvokeEapUI.dwSizeOfUIContextData;

        ((REQTYPECAST*)buffer)->GetEapInfo.dwContextId =
                            pPppMsg->ExtraInfo.InvokeEapUI.dwContextId;

        ((REQTYPECAST*)buffer)->GetEapInfo.dwEapTypeId =
                            pPppMsg->ExtraInfo.InvokeEapUI.dwEapTypeId;

        if ( dwSize >=
             pPppMsg->ExtraInfo.InvokeEapUI.dwSizeOfUIContextData)
        {
            LocalFree(pPppMsg->ExtraInfo.InvokeEapUI.pUIContextData);
            LocalFree(pPppMsg);
        }

    }

done:

    RasmanTrace(
           "PppGetEapInfo done. %d",
           dwError);

    ((REQTYPECAST*)buffer)->GetEapInfo.retcode = dwError;
}

VOID
PppSetEapInfo(pPCB ppcb, PBYTE buffer)
{
    PPPE_MESSAGE        PppEMsg;

    DWORD       dwError = SUCCESS;

    if (ppcb == NULL)
    {
        dwError = ERROR_PORT_NOT_FOUND;
        goto done;
    }

    RasmanTrace(
           "PppSetEapInfo: %s",
           ppcb->PCB_Name);

    if (ppcb->PCB_ConnState != CONNECTED)
    {
        dwError = ERROR_PORT_DISCONNECTED;
        goto done;
    }

    //
    // This memory will be released by the ppp engine when its done
    // with this blob.
    //
    PppEMsg.ExtraInfo.EapUIData.pEapUIData = LocalAlloc(LPTR,
               ((REQTYPECAST*)buffer)->SetEapInfo.dwSizeofEapUIData);

    if (NULL == PppEMsg.ExtraInfo.EapUIData.pEapUIData)
    {
        dwError = GetLastError();

        RasmanTrace(
               "PppSetEapInfo: failed to allocate. %d",
               dwError);

        goto done;
    }

    memcpy( PppEMsg.ExtraInfo.EapUIData.pEapUIData,
            (BYTE UNALIGNED *) ((REQTYPECAST*)buffer)->SetEapInfo.data,
            ((REQTYPECAST*)buffer)->SetEapInfo.dwSizeofEapUIData);

    PppEMsg.ExtraInfo.EapUIData.dwSizeOfEapUIData =
            ((REQTYPECAST*)buffer)->SetEapInfo.dwSizeofEapUIData;

    PppEMsg.ExtraInfo.EapUIData.dwContextId =
                ((REQTYPECAST*)buffer)->SetEapInfo.dwContextId;

    SetUserData(
        &(ppcb->PCB_Connection->CB_UserData),
        PORT_CUSTOMAUTHINTERACTIVEDATA_INDEX,
        PppEMsg.ExtraInfo.EapUIData.pEapUIData,
        PppEMsg.ExtraInfo.EapUIData.dwSizeOfEapUIData);

    PppEMsg.dwMsgId     = PPPEMSG_EapUIData;
    PppEMsg.hPort       = ppcb->PCB_PortHandle;
    PppEMsg.hConnection = ppcb->PCB_Connection->CB_Handle;

    RasmanTrace(
           "PppSetEapInfo: Sending message with ID %d to PPP",
           PppEMsg.dwMsgId);

    dwError = (DWORD) RasSendPPPMessageToEngine(&PppEMsg);

done:

    RasmanTrace(
           "PppSetEapInfo done. %d",
           dwError);

    ((REQTYPECAST*)buffer)->SetEapInfo.retcode = dwError;

    return;
}

VOID
PppGetInfo (pPCB ppcb, PBYTE buffer)
{
    PPP_MESSAGE * pPppMsg;

    if (ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->PppMsg.dwError =
                                    ERROR_PORT_NOT_FOUND;
        return;
    }


    if ( ppcb->PCB_ConnState != CONNECTED )
    {
        ((REQTYPECAST*)buffer)->PppMsg.dwError =
                                ERROR_PORT_DISCONNECTED;
    }
    else if ( ppcb->PCB_PppQHead == NULL )
    {
        ((REQTYPECAST*)buffer)->PppMsg.dwError =
                                ERROR_NO_MORE_ITEMS;
    }
    else
    {
        pPppMsg = ppcb->PCB_PppQHead;

        ((REQTYPECAST*)buffer)->PppMsg = *pPppMsg;

        //
        // Don't dequeue the message if its PPPMSG_InvokeEapUI
        // This message will be dequeued in PppGetEapInfo
        //
        if(PPPMSG_InvokeEapUI != pPppMsg->dwMsgId)
        {

            ppcb->PCB_PppQHead = pPppMsg->pNext;

            LocalFree( pPppMsg );

            if ( ppcb->PCB_PppQHead == NULL )
            {
                ppcb->PCB_PppQTail = NULL;
            }
        }

        ((REQTYPECAST*)buffer)->PppMsg.dwError = NO_ERROR;
    }
}

VOID
PppChangePwd (pPCB ppcb, PBYTE buffer)
{
    DWORD retcode = ERROR_SUCCESS;
    
    if (ppcb == NULL)
    {
        retcode = ERROR_PORT_NOT_FOUND;
        goto done;
    }


    if ( ppcb->PCB_ConnState != CONNECTED )
    {
        retcode = ERROR_PORT_DISCONNECTED;
    }
    else
    {
        //
        // If the password change request is for saved
        // passwords, we need to retrieve the one we
        // saved and copy over the old password
        //
        UserData *pData;

        pData = GetUserData(
                    &ppcb->PCB_UserData,
                    PORT_OLDPASSWORD_INDEX);

        if(NULL != pData)
        {
            CHAR *pszPwd = (CHAR *) pData->UD_Data;

            if(IsDummyPassword(
                ((REQTYPECAST *)
                buffer)->PppEMsg.ExtraInfo.ChangePw.szOldPassword))
            {

                DecodePw(pszPwd);

                strcpy(
                    ((REQTYPECAST *)
                    buffer)->PppEMsg.ExtraInfo.ChangePw.szOldPassword,
                    pszPwd);
            }

            ZeroMemory((PBYTE) pszPwd, pData->UD_Length);
        }

        //
        // Cache the new password to be saved in credmgr.
        //
        retcode = DwCacheCredMgrCredentials(
                &(((REQTYPECAST*)buffer)->PppEMsg),
                ppcb);

        retcode = (DWORD) RasSendPPPMessageToEngine(
                     &(((REQTYPECAST*)buffer)->PppEMsg));

    }

done:
    ((REQTYPECAST*)buffer)->Generic.retcode = retcode;
}

VOID
PppCallback  (pPCB ppcb, PBYTE buffer)
{
    if (ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                ERROR_PORT_NOT_FOUND;

        return;
    }


    if ( ppcb->PCB_ConnState != CONNECTED )
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                ERROR_PORT_DISCONNECTED;

    }
    else
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                        (DWORD) RasSendPPPMessageToEngine(
                                &(((REQTYPECAST*)buffer)->PppEMsg));
    }

}


VOID
ProcessReceivePacket(
    VOID
    )
{
    RasmanPacket        *Packet;
    NDISWAN_IO_PACKET   *IoPacket;
    DWORD               retcode;
    pPCB                ppcb;
    DWORD               i = 0;

    //g_fProcessReceive = TRUE;

    /*
    if(g_fPostReceive)
    {
         DbgPrint("g_fPostReceive==TRUE!!!\n");
         DebugBreak();
    }
    */

        Packet = ReceiveBuffers->Packet;
        IoPacket = &Packet->RP_Packet;

        ASSERT(IoPacket->usHandleType != (USHORT) 0xFFFFFFFF);

        if (IoPacket->PacketNumber != ReceiveBuffers->PacketNumber) {
            DbgPrint("ProcessRecv PacketNumbers off %d %d\n",
            IoPacket->PacketNumber, ReceiveBuffers->PacketNumber);
            //if (g_fDebugReceive)
            ASSERT(0);
        }

        ReceiveBuffers->PacketNumber++;

        if (IoPacket->usHandleType == CANCELEDHANDLE) {

            RasmanTrace(
                   "Packet has been cancelled");

            //g_fProcessReceive = FALSE;

            return;
        }

        ppcb = (pPCB)IoPacket->hHandle;

        ASSERT(INVALID_HANDLE_VALUE != ppcb);

        if (    (INVALID_HANDLE_VALUE == ppcb)
            ||  (ppcb->PCB_ConnState != CONNECTED))
        {

            if(INVALID_HANDLE_VALUE == ppcb) {

                RasmanTrace(
                       "ProcessRecivePacket: NULL context!!! Bailing");
            }

            //g_fProcessReceive = FALSE;

            return;
        }

        if (    (ppcb->PCB_PendingReceive != NULL)

            &&  (ppcb->PCB_RasmanReceiveFlags &
                            RECEIVE_WAITING) == 0

            &&  (ppcb->PCB_RasmanReceiveFlags &
                            RECEIVE_PPPSTARTED ) == 0)
        {
            retcode = CopyReceivedPacketToBuffer(ppcb,
                        ppcb->PCB_PendingReceive, Packet);

            if (retcode == SUCCESS)
            {
                //
                // We have completed a receive so notify the client!
                //
                if((ppcb->PCB_RasmanReceiveFlags
                            & RECEIVE_OUTOF_PROCESS) == 0)
                {
                    ppcb->PCB_PendingReceive = NULL;
                }
                else
                {
                    //
                    // Mark this buffer to be waiting to be picked
                    // up by the client
                    //
                    ppcb->PCB_RasmanReceiveFlags |= RECEIVE_WAITING;

                    //
                    // Add a timeout element so that we don't wait
                    // forever for the client to pick up the received
                    // buffer.
                    //
                    ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement =
                        AddTimeoutElement (
                            (TIMERFUNC) OutOfProcessReceiveTimeout,
                            ppcb,
                            NULL,
                            MSECS_OutOfProcessReceiveTimeOut );

                    AdjustTimer();

                }

                ppcb->PCB_LastError = SUCCESS;

                CompleteAsyncRequest(ppcb);

                if((ppcb->PCB_RasmanReceiveFlags
                    & RECEIVE_OUTOF_PROCESS) == 0)
                {
                    RasmanTrace(
                            "Completed receive - First Frame on %s, "
                            "handle=0x%x",
                            ppcb->PCB_Name,
                            ppcb->PCB_AsyncWorkerElement.WE_Notifier);
                }

                FreeNotifierHandle(
                    ppcb->PCB_AsyncWorkerElement.WE_Notifier
                    );

                ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                                            INVALID_HANDLE_VALUE;

                if (ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement !=
                                                                NULL)
                {
                    RemoveTimeoutElement(ppcb);
                }

                ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = 0;
            }
        }
        else if (ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPSTARTED)
        {
            //
            // Send the packet directly to PPP if we are
            // in PPPSTARTED mode.
            //

            /*
            RasmanTrace(
                   "ProcessReceivePacket: SendingPackettoPPP, hport=%d",
                   ppcb->PCB_PortHandle);
            */

            SendReceivedPacketToPPP (ppcb, &Packet->RP_Packet);

        }
        else
        {
            //
            // This means that no one picked up the buffer we got
            // from ndiswan. Queue it up in the pcb
            //
            RasmanTrace(
                   "PostReceivePacket - Queueing packet on pcb. %s",
                   ppcb->PCB_Name);

            QueueReceivedPacketOnPcb(ppcb, Packet);
        }

    //g_fProcessReceive = FALSE;

    return;
}

VOID
AddNotification (pPCB ppcb, PBYTE buffer)
{
    DWORD           dwErr = 0;
    HANDLE          handle = NULL;
    DWORD           dwfFlags;
    ConnectionBlock *pConn;
    Bundle          *pBundle;
    UserData        *pUserData;

    DWORD           dwPid =
        ((REQTYPECAST*)buffer)->AddNotification.pid;

    /*
    if (ppcb == NULL)
    {

        ((REQTYPECAST*)buffer)->AddNotification.retcode =
                                        ERROR_PORT_NOT_FOUND;

        return;
    }

    */

    dwfFlags = ((REQTYPECAST*)buffer)->AddNotification.dwfFlags;
    handle = ValidateHandleForRasman(
               ((REQTYPECAST*)buffer)->AddNotification.hevent,
               ((REQTYPECAST*)buffer)->AddNotification.pid);

    if (((REQTYPECAST*)buffer)->AddNotification.fAny)
    {
        dwErr = AddNotifierToList(
                &pConnectionNotifierList,
                handle,
                dwfFlags,
                ((REQTYPECAST*)buffer)->AddNotification.pid);

        if(SUCCESS != dwErr)
        {
            goto done;
        }
    }
    else if (((REQTYPECAST*)buffer)->AddNotification.hconn
                                                    != 0)
    {
        pConn = FindConnection(
            ((REQTYPECAST*)buffer)->AddNotification.hconn);

        if (pConn != NULL)
        {
            dwErr = AddNotifierToList(
              &pConn->CB_NotifierList,
              handle,
              NOTIF_DISCONNECT,
              ((REQTYPECAST*)buffer)->AddNotification.pid);

            if(SUCCESS != dwErr)
            {
                goto done;
            }
        }
        else
        {
            dwErr = ERROR_NO_CONNECTION;
        }
    }
    else
    {
        if(NULL == ppcb)
        {
            dwErr = ERROR_PORT_NOT_FOUND;
            goto done;
        }
        
        dwErr = AddNotifierToList(
          &ppcb->PCB_NotifierList,
          handle,
          dwfFlags,
          ((REQTYPECAST*)buffer)->AddNotification.pid);
    }

done:

    if(     (SUCCESS != dwErr)
        &&  (NULL != handle))
    {
        FreeNotifierHandle(handle);
    }

    ((REQTYPECAST*)buffer)->AddNotification.retcode = dwErr;
}

/*++

Routine Description:

    Signal notifiers waiting for a new connection.

Arguments:

Return Value:

    Nothing.

--*/
VOID
SignalConnection (pPCB ppcb, PBYTE buffer)
{
    DWORD           dwErr  = ERROR_SUCCESS;
    ConnectionBlock *pConn;
    Bundle          *pBundle;
    UserData        *pUserData;

    //
    // Find the connection block.
    //
    pConn = FindConnection(
        ((REQTYPECAST*)buffer)->SignalConnection.hconn);

    if (pConn == NULL)
    {
        ((REQTYPECAST*)buffer)->SignalConnection.retcode =
                                        ERROR_NO_CONNECTION;
        return;
    }

    RasmanTrace(
           "SignalConnection");

    if (!pConn->CB_Signaled)
    {
        //
        // Save the credentials with credential
        // manager
        //
        if(     (0 != (pConn->CB_ConnectionParams.CP_ConnectionFlags
                & CONNECTION_USERASCREDENTIALS))
            &&  (GetCurrentProcessId() != pConn->CB_dwPid))                
        {   

            dwErr = DwSaveCredentials(pConn);
            if(ERROR_SUCCESS != dwErr)
            {
                RasmanTrace(
                    "SignalConnection: failed to savecreds. 0x%x",
                    dwErr);

                //
                // This is not a fatal error
                //
                dwErr = SUCCESS;                    
            }

        }
        
        SignalNotifiers(pConnectionNotifierList,
                        NOTIF_CONNECT,
                        0);

        pConn->CB_Signaled = TRUE;

#if SENS_ENABLED
        dwErr = SendSensNotification(
                    SENS_NOTIFY_RAS_CONNECT,
                    (HRASCONN) pConn->CB_Handle);
        RasmanTrace(
            
            "SendSensNotification(_RAS_CONNECT) for 0x%08x "
            "returns 0x%08x",
            pConn->CB_Handle, dwErr);

#endif

        g_RasEvent.Type = ENTRY_CONNECTED;
        dwErr = DwSendNotificationInternal(pConn, &g_RasEvent);

        RasmanTrace(
               "DwSendNotificationInternal(ENTRY_CONNECTED), rC=0x%08x",
               dwErr);
    }

    ((REQTYPECAST*)buffer)->SignalConnection.retcode = SUCCESS;
}


/*++

Routine Description:

    Set dev specific info with device dll

Arguments:

Return Value:

    Nothing.

--*/
VOID
SetDevConfig (pPCB ppcb, PBYTE buffer)
{
    DWORD retcode ;
    pDeviceCB   device ;
    char    devicetype[MAX_DEVICETYPE_NAME] ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace( 
                    "SetDevConfig: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }

    //
    // First check if device dll is loaded. If not loaded -
    // load it.
    //
    strcpy(devicetype,
           ((REQTYPECAST*)buffer)->SetDevConfig.devicetype);

    device = LoadDeviceDLL (ppcb, devicetype) ;

    //
    // Call the entry point only if this function is
    // supported by the device dll
    //
    if(     device != NULL
        &&  device->DCB_AddrLookUp[DEVICESETDEVCONFIG_ID] != NULL)
    {
        retcode = DEVICESETDEVCONFIG(\
                         device,    \
                         ppcb->PCB_PortFileHandle,\
                         ((REQTYPECAST*)buffer)->SetDevConfig.config,\
                         ((REQTYPECAST*)buffer)->SetDevConfig.size) ;
    }
    else
    {
        retcode = ERROR_DEVICE_DOES_NOT_EXIST ;
    }

    ((REQTYPECAST*)buffer)->Generic.retcode = retcode ;

}



/*++

Routine Description:

    Get dev specific info with device dll

Arguments:

Return Value:

    Nothing.

--*/
VOID
GetDevConfig (pPCB ppcb, PBYTE buffer)
{
    DWORD retcode ;
    pDeviceCB   device ;
    char    devicetype[MAX_DEVICETYPE_NAME] ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace( 
                    "GetDevConfig: port %d is unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST*)buffer)->GetDevConfig.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }

    //
    // First check if device dll is loaded. If not loaded -
    // load it.
    //
    strcpy(devicetype,
           ((REQTYPECAST*)buffer)->GetDevConfig.devicetype);

    device = LoadDeviceDLL (ppcb, devicetype) ;

    //
    // Call the entry point only if this function is
    // supported by the device dll
    //
    if (    device != NULL
        &&  device->DCB_AddrLookUp[DEVICEGETDEVCONFIG_ID] != NULL)
    {
        // ((REQTYPECAST*)buffer)->GetDevConfig.size = 2000 ;

        retcode = DEVICEGETDEVCONFIG(\
                        device,\
                        ppcb->PCB_Name,\
                        ((REQTYPECAST*)buffer)->GetDevConfig.config,\
                        &((REQTYPECAST*)buffer)->GetDevConfig.size);
    }
    else
    {
        retcode = ERROR_DEVICE_DOES_NOT_EXIST ;
    }

    ((REQTYPECAST*)buffer)->GetDevConfig.retcode = retcode ;

}

VOID
GetDevConfigEx(pPCB ppcb, PBYTE buffer)
{
    DWORD retcode = SUCCESS;
    pDeviceCB device;

    if(     (NULL == ppcb)
        || (UNAVAILABLE == ppcb->PCB_PortStatus))
    {
        ((REQTYPECAST*)buffer)->GetDevConfigEx.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;                                    
    }

    if(RAS_DEVICE_TYPE(ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType)
        != RDT_Modem)
    {
        ((REQTYPECAST *)buffer)->GetDevConfigEx.retcode =
                                    E_INVALIDARG;
        return;                                    
    }

    device = LoadDeviceDLL(ppcb, 
            ((REQTYPECAST *)buffer)->GetDevConfigEx.devicetype);

    if(NULL != device)
    {

        ASSERT(RastapiGetDevConfigEx != NULL);

        retcode = (DWORD) RastapiGetDevConfigEx(
                        ppcb->PCB_Name,
                        ((REQTYPECAST *)buffer)->GetDevConfigEx.config,
                        &((REQTYPECAST *)buffer)->GetDevConfigEx.size);
    }
    else
    {
        retcode = ERROR_DEVICE_DOES_NOT_EXIST;
    }

    ((REQTYPECAST*)buffer)->GetDevConfigEx.retcode = retcode;
        
    
}


/*++

Routine Description:

    Get the idle time, in seconds, for the connection

Arguments:

Return Value:

--*/
VOID
GetTimeSinceLastActivity( pPCB ppcb, PBYTE buffer)
{
    NDISWAN_GET_IDLE_TIME  IdleTime ;
    DWORD       retcode = SUCCESS ;
    DWORD       bytesrecvd ;

    if (ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->GetTimeSinceLastActivity.dwRetCode =
                                                    ERROR_PORT_NOT_FOUND;

        return;
    }

    if (ppcb->PCB_ConnState != CONNECTED)
    {

        ((REQTYPECAST*)buffer)->GetTimeSinceLastActivity.dwRetCode =
                                                    ERROR_NOT_CONNECTED;

        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    IdleTime.hBundleHandle = ppcb->PCB_BundleHandle;
    IdleTime.usProtocolType = BUNDLE_IDLE_TIME;
    IdleTime.ulSeconds = 0;

    if (!DeviceIoControl (RasHubHandle,
                   IOCTL_NDISWAN_GET_IDLE_TIME,
                   (PBYTE) &IdleTime,
                   sizeof(IdleTime),
                   (PBYTE) &IdleTime,
                   sizeof(IdleTime),
                   (LPDWORD) &bytesrecvd,
                   NULL))
    {
        retcode = GetLastError() ;
    }
    else
    {
        retcode = SUCCESS ;
    }

    ((REQTYPECAST*)buffer)->GetTimeSinceLastActivity.dwTimeSinceLastActivity
                                                        = IdleTime.ulSeconds;

    ((REQTYPECAST*)buffer)->GetTimeSinceLastActivity.dwRetCode = retcode ;
}


/*++

Routine Description:

    Close all ports opened by the current process
    that are currently in DISCONNECTED state.

Arguments:

Return Value:

--*/
VOID
CloseProcessPorts( pPCB ppcb, PBYTE buffer)
{
    ULONG i;
    DWORD pid = ((REQTYPECAST*)buffer)->CloseProcessPortsInfo.pid;

    //
    // We are guaranteed to be called only
    // when pid != rasman service's pid.
    //
    for (i = 0; i < MaxPorts; i++)
    {
        ppcb = GetPortByHandle((HPORT) UlongToPtr(i));

        if (ppcb != NULL)
        {
            if (    ppcb->PCB_OwnerPID == pid
                &&  ppcb->PCB_ConnState == DISCONNECTED
                &&  ppcb->PCB_Connection != NULL)
            {
                PortClose(ppcb, pid, TRUE, FALSE);
            }
        }
    }

    ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS;
}


/*++

Routine Description:

    Debug routine to test PnP operations

Arguments:

Return Value:

--*/
VOID
PnPControl( pPCB ppcb, PBYTE buffer)
{
    static  DWORD dwNewPorts = 0;
    DWORD i,
          dwSize,
          dwEntries;
    DWORD dwErr;
    DWORD dwOp = ((REQTYPECAST*)buffer)->PnPControlInfo.dwOp;

    PortMediaInfo *pPortMediaInfo;

    switch (dwOp)
    {
    case 0:
        //
        // Fake a new port.
        //
        dwSize = dwEntries = 0;
        PORTENUM((&Mcb[0]), NULL, &dwSize, &dwEntries);
        dwSize = dwEntries * sizeof (PortMediaInfo);

        //
        // Allocate memory for the portenum buffer
        //
        pPortMediaInfo = LocalAlloc(LPTR, dwSize);
        if (pPortMediaInfo == NULL) {
            dwErr = GetLastError();
            break;
        }

        dwErr = PORTENUM(\
                    (&Mcb[0]),\
                    (PBYTE)pPortMediaInfo,\
                    &dwSize, \
                    &dwEntries);

        if (dwErr)
        {
            LocalFree(pPortMediaInfo);
            break;
        }

        wsprintf(pPortMediaInfo->PMI_Name, "TEST%d", dwNewPorts++);

        dwErr = CreatePort(&Mcb[0], pPortMediaInfo);

        LocalFree(pPortMediaInfo);

        break;

    case 1:
        dwErr = EnablePort(ppcb->PCB_PortHandle);

        break;

    case 2:
        dwErr = DisablePort(ppcb->PCB_PortHandle);

        break;

    case 3:
        dwErr = RemovePort(ppcb->PCB_PortHandle);

        break;

    default:

        dwErr = ERROR_INVALID_FUNCTION;

        break;
    }
}

/*++

Routine Description:

    Set the rasapi32 I/O completion port for this port

Arguments:

Return Value:

    Nothing.

--*/
VOID
SetIoCompletionPort (pPCB ppcb, PBYTE buffer)
{
    HANDLE h =
        ((REQTYPECAST*)buffer)->SetIoCompletionPortInfo.hIoCompletionPort;

    HANDLE hNew = INVALID_HANDLE_VALUE;

    if (ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }


    if (h != INVALID_HANDLE_VALUE)
    {
        hNew =
          ValidateHandleForRasman(
            h,
            ((REQTYPECAST*)buffer)->SetIoCompletionPortInfo.pid);
    }

    SetIoCompletionPortCommon(
      ppcb,
      hNew,
      ((REQTYPECAST*)buffer)->SetIoCompletionPortInfo.lpOvDrop,
      ((REQTYPECAST*)buffer)->SetIoCompletionPortInfo.lpOvStateChange,
      ((REQTYPECAST*)buffer)->SetIoCompletionPortInfo.lpOvPpp,
      ((REQTYPECAST*)buffer)->SetIoCompletionPortInfo.lpOvLast,
      TRUE);

    ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;


}


/*++

Routine Description:

    Set the router bit for the current usage for this port

Arguments:

Return Value:

    Nothing.

--*/
VOID
SetRouterUsage (pPCB ppcb, PBYTE buffer)
{
    if (ppcb == NULL)
    {
        ((REQTYPECAST*)buffer)->Generic.retcode =
                                    ERROR_PORT_NOT_FOUND;
        return;
    }


    if (((REQTYPECAST*)buffer)->SetRouterUsageInfo.fRouter)
    {
        ppcb->PCB_CurrentUsage |= CALL_ROUTER;
    }
    else
    {
        ppcb->PCB_CurrentUsage &= ~CALL_ROUTER;

        ppcb->PCB_OpenedUsage &= ~CALL_ROUTER;
    }

    ((REQTYPECAST*)buffer)->Generic.retcode = SUCCESS ;

}


/*++

Routine Description:

    Close the server's side of a port

Arguments:

Return Value:

    Nothing.

--*/
VOID
ServerPortClose (pPCB ppcb, PBYTE buffer)
{
    DWORD dwErr = SUCCESS, pid;

    if (ppcb == NULL)
    {
        ((REQTYPECAST *)
        buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;
        return;
    }

    RasmanTrace(
           "ServerPortClose (%d). OpenInstances = %d",
           ppcb->PCB_PortHandle,
           ppcb->PCB_OpenInstances);

    //
    // If the pid passed in is not our pid, then
    // fail immediately.
    //
    pid = ((REQTYPECAST *)buffer)->PortClose.pid;

    if (pid != GetCurrentProcessId())
    {
        ((REQTYPECAST *)
        buffer)->Generic.retcode = ERROR_ACCESS_DENIED;
        return;
    }

    //
    // Mask out the opened usage on this
    // port
    //
    ppcb->PCB_OpenedUsage &= ~CALL_IN;

    if (    ppcb->PCB_OpenInstances == 1
        &&  pid == ppcb->PCB_OwnerPID)
    {
        //
        // If the port is opened once and we are the owner,
        // then perform the regular close processing.
        //
        dwErr = PortClose(
                  ppcb,
                  ((REQTYPECAST *)
                  buffer)->PortClose.pid,
                  (BOOLEAN)((REQTYPECAST *)
                  buffer)->PortClose.close,
                  TRUE);

        ppcb->PCB_BiplexOwnerPID = 0;
    }
    else if (   ppcb->PCB_OpenInstances == 2
            &&  pid == ppcb->PCB_BiplexOwnerPID)
    {
        //
        // If the port is opened twice, and we are the
        // biplex owner, then clean up the server side
        // of the biplex port.
        //
        FreeNotifierHandle(ppcb->PCB_BiplexAsyncOpNotifier);

        ppcb->PCB_BiplexAsyncOpNotifier = INVALID_HANDLE_VALUE;

        FreeNotifierList(&ppcb->PCB_BiplexNotifierList);

        if (ppcb->PCB_BiplexUserStoredBlock)
        {
            LocalFree (ppcb->PCB_BiplexUserStoredBlock);
        }

        ppcb->PCB_BiplexUserStoredBlockSize = 0;

        ppcb->PCB_BiplexOwnerPID = 0;

        ppcb->PCB_OpenInstances -= 1;

        RasmanTrace(
               "ServerPortClose (%d). OpenInstances = %d",
               ppcb->PCB_PortHandle,
               ppcb->PCB_OpenInstances);
    }

    //
    // In all cases delete the ipsec filter plumbed by
    // the server if its a l2tp port
    //
    if(RAS_DEVICE_TYPE(ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType)
        == RDT_Tunnel_L2tp)
    {
        dwErr = DwDeleteIpSecFilter(ppcb, TRUE);

        RasmanTrace(
               "ServerPortClose: Deleting filter on port %s.rc=0x%x",
               ppcb->PCB_Name, dwErr);

    }


    ((REQTYPECAST*) buffer)->Generic.retcode = dwErr;
}

VOID
SetRasdialInfo(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode               = SUCCESS;
    CHAR *pszPhonebookPath      = NULL;
    CHAR *pszEntryName          = NULL;
    CHAR *pszPhoneNumber        = NULL;
    PRAS_CUSTOM_AUTH_DATA pdata = &((REQTYPECAST *)
                                  pBuffer)->SetRasdialInfo.rcad;

    RasmanTrace(
           "SetRasdialInfo: port %s",
           ppcb->PCB_Name);

    if (ppcb == NULL)
    {
        retcode = ERROR_PORT_NOT_FOUND;
        goto done;
    }

    if (    ppcb->PCB_pszPhonebookPath
        &&  ppcb->PCB_pszEntryName)
    {
        RasmanTrace(
               "SetRasdialInfo: Values already set");

        goto done;
    }

    pszPhonebookPath =
            ((REQTYPECAST *)
            pBuffer)->SetRasdialInfo.szPhonebookPath;

    pszEntryName     =
            ((REQTYPECAST *)
            pBuffer)->SetRasdialInfo.szEntryName;

    pszPhoneNumber   =
            ((REQTYPECAST *)
            pBuffer)->SetRasdialInfo.szPhoneNumber;

    ppcb->PCB_pszPhonebookPath = LocalAlloc(LPTR,
      (strlen(pszPhonebookPath) + 1) * sizeof (CHAR));

    if (NULL == ppcb->PCB_pszPhonebookPath)
    {
        retcode = ERROR_OUTOFMEMORY;
        goto done;
    }

    ppcb->PCB_pszEntryName = LocalAlloc(LPTR,
        (strlen (pszEntryName) + 1) * sizeof (CHAR));

    if (NULL == ppcb->PCB_pszEntryName)
    {
        retcode = ERROR_OUTOFMEMORY;
        goto done;
    }

    ppcb->PCB_pszPhoneNumber = LocalAlloc(LPTR,
        (strlen(pszPhoneNumber) + 1) * sizeof (CHAR));

    if (NULL == ppcb->PCB_pszPhoneNumber)
    {
        retcode = ERROR_OUTOFMEMORY;
        goto done;
    }

    if(pdata->cbCustomAuthData > 0)
    {
        ppcb->PCB_pCustomAuthData = LocalAlloc(LPTR,
                        sizeof(RAS_CUSTOM_AUTH_DATA)
                      + pdata->cbCustomAuthData);

        if(NULL == ppcb->PCB_pCustomAuthData)
        {
            retcode = ERROR_OUTOFMEMORY;
            goto done;
        }

        ppcb->PCB_pCustomAuthData->cbCustomAuthData =
                                pdata->cbCustomAuthData;

        memcpy(ppcb->PCB_pCustomAuthData->abCustomAuthData,
               pdata->abCustomAuthData,
               pdata->cbCustomAuthData);
    }
    else
    {
        ppcb->PCB_pCustomAuthData = NULL;
    }

    strcpy(ppcb->PCB_pszPhonebookPath,
           pszPhonebookPath) ;

    strcpy(ppcb->PCB_pszEntryName,
           pszEntryName);

    strcpy(ppcb->PCB_pszPhoneNumber,
           pszPhoneNumber);

    RasmanTrace(
           "SetRasdialInfo: PbkPath: %s",
           ppcb->PCB_pszPhonebookPath);

    RasmanTrace(
           "SetRasdialInfo: EntryName: %s",
           ppcb->PCB_pszEntryName);

    RasmanTrace(
           "SetRasdialInfo: PhoneNum: %s",
           ppcb->PCB_pszPhoneNumber);

    if(pdata->cbCustomAuthData)
    {
        RasmanTrace(
            
           "SetRasdialInfo: cbCAD=%d. pData=0x%x",
           ppcb->PCB_pCustomAuthData->cbCustomAuthData,
           ppcb->PCB_pCustomAuthData);
    }

done:
    if ( SUCCESS != retcode)
    {
        if(NULL != ppcb->PCB_pszPhonebookPath)
        {
            LocalFree (ppcb->PCB_pszPhonebookPath);
            ppcb->PCB_pszPhonebookPath = NULL;
        }

        if(NULL != ppcb->PCB_pszEntryName)
        {
            LocalFree (ppcb->PCB_pszEntryName);
            ppcb->PCB_pszEntryName = NULL;
        }

        if(NULL != ppcb->PCB_pszPhoneNumber)
        {
            LocalFree (ppcb->PCB_pszPhoneNumber);
            ppcb->PCB_pszPhoneNumber = NULL;
        }

        if(NULL != ppcb->PCB_pCustomAuthData)
        {
            LocalFree(ppcb->PCB_pCustomAuthData);
            ppcb->PCB_pCustomAuthData = NULL;
        }
    }

    ((REQTYPECAST *) pBuffer)->Generic.retcode = retcode;

    RasmanTrace(
           "SetRasdialInfo: done %d",
           retcode);

    return;
}

/*++

Routine Description:

    Register for PnP notifications with rasman

Arguments:

Return Value:

    Nothing.

--*/
VOID
RegisterPnPNotifRequest( pPCB ppcb, PBYTE buffer )
{
    DWORD               dwErr   = SUCCESS;
    DWORD               pid;
    PVOID               pvNotifier;
    DWORD               dwFlags;
    HANDLE              hEventNotifier = INVALID_HANDLE_VALUE;
    pPnPNotifierList    pNotifier;
    BOOL                fRegister = ((REQTYPECAST *)
                                    buffer)->PnPNotif.fRegister;

    pvNotifier  =
        ((REQTYPECAST *) buffer)->PnPNotif.pvNotifier;

    if(fRegister)
    {
        //
        // ppcb = NULL is OK.
        //

        pid = ((REQTYPECAST *) buffer)->PnPNotif.pid;

        RasmanTrace(
               "RegisterPnPNotifRequest. Process %d",
               pid );

        dwFlags     =
            ((REQTYPECAST *) buffer)->PnPNotif.dwFlags;

        if (PNP_NOTIFEVENT & dwFlags)
        {
            hEventNotifier = ValidateHandleForRasman(
                                        (HANDLE) pvNotifier,
                                        pid
                                        ) ;
        }

        //
        // Allocate a block for this notifier
        //
        pNotifier = LocalAlloc (LPTR, sizeof (PnPNotifierList));

        if (NULL == pNotifier)
        {

            FreeNotifierHandle(hEventNotifier);

            RasmanTrace (
                    "RegisterPnPNotifRequest failed to allocate. %d",
                    GetLastError());

            dwErr = ERROR_OUTOFMEMORY;

            goto done;
        }

        pNotifier->PNPNotif_Next = NULL;

        if (dwFlags & PNP_NOTIFEVENT)
        {
            RasmanTrace(
                   "RegisterPnPNotifer: Adding event 0x%x to Notif list",
                   hEventNotifier);

            pNotifier->PNPNotif_uNotifier.hPnPNotifier = hEventNotifier;
        }
        else
        {
            RasmanTrace(
                   "RegisterPnPNotifier: Adding callback 0x%x to Notif list",
                   pvNotifier);

            pNotifier->PNPNotif_uNotifier.pfnPnPNotifHandler =
                                                (PAPCFUNC) pvNotifier;

            pNotifier->hThreadHandle =
                        ((REQTYPECAST *) buffer)->PnPNotif.hThreadHandle;
        }

        pNotifier->PNPNotif_dwFlags = dwFlags;

        //
        // Add this notifier to the global list
        //
        AddPnPNotifierToList (pNotifier);
    }
    else
    {
        RasmanTrace(
               "RegisterPnPNotifier: Removing 0x%x from list",
               pvNotifier);

        RemovePnPNotifierFromList((PAPCFUNC) pvNotifier);
    }

done:

    ((REQTYPECAST *) buffer)->Generic.retcode = dwErr;
}

VOID
GetAttachedCountRequest (pPCB ppcb, PBYTE buffer)
{

    //
    // ppcb = NULL is OK.
    //
    RasmanTrace ( "GetAttachedCount...");

    ((REQTYPECAST *)buffer)->GetAttachedCount.dwAttachedCount =
                                                g_dwAttachedCount;

    ((REQTYPECAST *)buffer)->GetAttachedCount.retcode = SUCCESS;

    RasmanTrace(
           "GetAttachedCount. AttachedCount = %d",
           g_dwAttachedCount );

    return;

}



VOID
SetBapPolicyRequest (pPCB ppcb, PBYTE buffer)
{
    HCONN hConn                 =
            ((REQTYPECAST *) buffer)->SetBapPolicy.hConn;

    DWORD dwLowThreshold        =
            ((REQTYPECAST *) buffer)->SetBapPolicy.dwLowThreshold;

    DWORD dwLowSamplePeriod     =
            ((REQTYPECAST *) buffer)->SetBapPolicy.dwLowSamplePeriod;

    DWORD dwHighThreshold       =
            ((REQTYPECAST *) buffer)->SetBapPolicy.dwHighThreshold;

    DWORD dwHighSamplePeriod    =
            ((REQTYPECAST *) buffer)->SetBapPolicy.dwHighSamplePeriod;

    DWORD retcode               = SUCCESS;
    DWORD dwBytes;
    DWORD iPort;
    Bundle *pBundle;
    HANDLE handle;

    ConnectionBlock *pConn;

    NDISWAN_SET_BANDWIDTH_ON_DEMAND NdiswanBandwidthOnDemand = {0};

    RasmanBapPacket *pBapPacket = NULL;

    //
    // NULL ppcb is OK
    //
    RasmanTrace ( "SetBapPolicy hConn=0x%x...", hConn);

    if(INVALID_HANDLE_VALUE == RasHubHandle)
    {
        if(SUCCESS != (retcode = DwStartAndAssociateNdiswan()))
        {
            RasmanTrace(
                   "SetBapPolicyRequest: failed to start "
                   "ndiswan. 0x%x",
                   retcode);

            goto done;
        }
        else
        {
            RasmanTrace(
                   "SetBapPolicyRequest: successfully started"
                   " ndiswan");
        }
    }

    //
    // Get a BapPacket to send down to ndiswan
    //
    retcode = GetBapPacket (&pBapPacket);

    if(     (ERROR_SUCCESS == retcode)
        &&  (NULL != pBapPacket))
    {
        retcode = DwSetThresholdEvent(pBapPacket);

        RasmanTrace(
              "SetBapPolicyRequest: DwSetThresholdEvent returned 0x%x",
              retcode);
    }

    pBundle = FindBundle ((HBUNDLE) hConn);

    if (NULL == pBundle)
    {
        retcode = ERROR_NO_CONNECTION;
        goto done;
    }

    if (    0 != pBundle->B_Handle
        &&  INVALID_HANDLE_VALUE != pBundle->B_NdisHandle)
    {
        handle = pBundle->B_NdisHandle;
    }
    else
    {
        ULONG   i;
        pPCB    ppcb;

        for (i = 0; i < MaxPorts; i++)
        {

            ppcb = GetPortByHandle((HPORT) UlongToPtr(i));
            if (ppcb == NULL)
            {
                continue;
            }

            if (    (ppcb->PCB_ConnState == CONNECTED)
                &&  (ppcb->PCB_Bundle->B_Handle == hConn))
            {
                break ;
            }
        }

        if (i < MaxPorts)
        {
            handle = ppcb->PCB_BundleHandle;
        }
        else
        {
            retcode = ERROR_PORT_NOT_FOUND;
            goto done;
        }
    }

    //
    // Set the bandwidth on demand policy
    //
    NdiswanBandwidthOnDemand.hBundleHandle = handle;

    NdiswanBandwidthOnDemand.usLowerXmitThreshold    =
                                (USHORT) dwLowThreshold;

    NdiswanBandwidthOnDemand.usUpperXmitThreshold    =
                                (USHORT) dwHighThreshold;

    NdiswanBandwidthOnDemand.ulLowerXmitSamplePeriod =
                                dwLowSamplePeriod * 1000;

    NdiswanBandwidthOnDemand.ulUpperXmitSamplePeriod =
                                dwHighSamplePeriod * 1000;

    NdiswanBandwidthOnDemand.usLowerRecvThreshold    =
                                (USHORT) dwLowThreshold;

    NdiswanBandwidthOnDemand.usUpperRecvThreshold    =
                                (USHORT) dwHighThreshold;

    NdiswanBandwidthOnDemand.ulLowerRecvSamplePeriod =
                                dwLowSamplePeriod * 1000;

    NdiswanBandwidthOnDemand.ulUpperRecvSamplePeriod =
                                dwHighSamplePeriod * 1000;

    if (!DeviceIoControl(RasHubHandle,
                         IOCTL_NDISWAN_SET_BANDWIDTH_ON_DEMAND,
                         (LPVOID) &NdiswanBandwidthOnDemand,
                         sizeof (NdiswanBandwidthOnDemand),
                         (LPVOID) &NdiswanBandwidthOnDemand,
                         sizeof (NdiswanBandwidthOnDemand),
                         &dwBytes,
                         NULL))
    {
        retcode = GetLastError();

        RasmanTrace(
               "SetBapPolicy: Failed to set Bandwidth on "
               "Demand policy. %d",
               retcode);

        goto done;
    }

done:
    ((REQTYPECAST *) buffer)->Generic.retcode = retcode;

}

VOID
PppStarted (pPCB ppcb, PBYTE buffer)
{
    DWORD       retcode = SUCCESS;
    REQTYPECAST reqbuf;


    if (NULL == ppcb)
    {
        RasmanTrace ( "PppStarted: Port Not found.");

        retcode = ERROR_PORT_NOT_FOUND;

        goto done;
    }

    RasmanTrace ( "PppStarted...%s", ppcb->PCB_Name);

    //
    // Set flag in ppcb so that we can directly pump
    // packets from ndiswan to ppp
    //
    ppcb->PCB_RasmanReceiveFlags |= RECEIVE_PPPSTARTED;

    RasmanPortReceive (ppcb);

    if (retcode)
    {
        goto done;
    }

done:
    ((REQTYPECAST *) buffer)->Generic.retcode = retcode;

}

DWORD
dwProcessThresholdEvent ()
{
    RasmanBapPacket   *pBapPacket = NULL;
    NDIS_HANDLE       hBundleHandle;
    DWORD             retcode;
    Bundle            *pBundle;


    if(NULL != BapBuffers)
    {
        pBapPacket = BapBuffers->pPacketList;
    }

    //
    // Loop through the outstanding requests
    // and send ppp notifications.
    //
    while ( pBapPacket )
    {
        if ((pBundle =
            pBapPacket->RBP_ThresholdEvent.hBundleContext ) == NULL )
        {
            pBapPacket = pBapPacket->Next;
            continue;
        }


        //
        // Fill in the pppe_message
        //
        g_PppeMessage->dwMsgId = PPPEMSG_BapEvent;

        g_PppeMessage->hConnection = ( HCONN ) pBundle->B_Handle;

        g_PppeMessage->ExtraInfo.BapEvent.fAdd =
                 ((pBapPacket->RBP_ThresholdEvent.ulThreshold ==
                   UPPER_THRESHOLD ) ? TRUE : FALSE );

        g_PppeMessage->ExtraInfo.BapEvent.fTransmit =
                 ((pBapPacket->RBP_ThresholdEvent.ulDataType ==
                   TRANSMIT_DATA ) ? TRUE : FALSE );
        //
        // Send the message to PPP
        //
        RasSendPPPMessageToEngine ( g_PppeMessage );

        pBapPacket->RBP_ThresholdEvent.hBundleContext = NULL;

        //
        // repend the irp with ndiswan
        //
        retcode = DwSetThresholdEvent(pBapPacket);

        RasmanTrace(
               "dwProcessThresholdEvent: SetThresholdEvent returned 0x%x",
               retcode);

        pBapPacket = pBapPacket->Next;

    }

    return SUCCESS;
}

DWORD
DwRefConnection(ConnectionBlock **ppConn,
                BOOL fAddref)
{
    DWORD retcode = SUCCESS;
    ConnectionBlock *pConn = *ppConn;

    if (NULL == pConn)
    {
        retcode = ERROR_NO_CONNECTION;
        goto done;
    }

    if (    pConn->CB_RefCount
        &&  !fAddref)
    {
        pConn->CB_RefCount -= 1;

        RasmanTrace(
               "refcount=%d, maxports=%d, ports=%d",
               pConn->CB_RefCount,
               pConn->CB_MaxPorts,
               pConn->CB_Ports);

        if(     0 == pConn->CB_RefCount
            &&  (   0 == pConn->CB_MaxPorts
                ||  0 == pConn->CB_Ports))
        {
            DWORD dwErr;

            //
            // This means that the rasdialmachine never got
            // to the point of adding a port to the connection
            // Blow away the connection in this case as there
            // are no ports to close and if RemoveConnectionPort is
            // not called this connection will be orphaned.
            //
            RasmanTrace(
                 "RefConnection: deref - freeing connection as "
                 "0 ports in this connection");

            //
            // Send Notification about this disconnect
            //
            g_RasEvent.Type = ENTRY_DISCONNECTED;
            dwErr = DwSendNotificationInternal(pConn, &g_RasEvent);

            RasmanTrace(
                   "DwSendNotificationInternal(ENTRY_DISCONNECTED) returnd 0x%x",
                   dwErr);

            FreeConnection(pConn);

            pConn = NULL;
        }
    }
    else if(fAddref)
    {
        pConn->CB_RefCount += 1;
    }

done:
    *ppConn = pConn;

    return retcode;
}

VOID
RefConnection(pPCB ppcb, PBYTE pBuffer )
{
    HCONN           hConn   =
            ((REQTYPECAST *) pBuffer )->RefConnection.hConn;

    BOOL            fAddref =
            ((REQTYPECAST *) pBuffer )->RefConnection.fAddref;

    ConnectionBlock *pConn  = FindConnection ( hConn );
    DWORD           retcode = SUCCESS;

    RasmanTrace( "RefConnection: 0x%x", hConn );

    if ( NULL == pConn )
    {
        retcode = ERROR_NO_CONNECTION;
        goto done;
    }

    retcode = DwRefConnection(&pConn,
                              fAddref);

    if (pConn)
    {
        ((REQTYPECAST *) pBuffer)->RefConnection.dwRef =
                                        pConn->CB_RefCount;
    }
    else
    {
        ((REQTYPECAST *) pBuffer)->RefConnection.dwRef = 0;
    }

done:

    ((REQTYPECAST *) pBuffer)->RefConnection.retcode = retcode;

    if ( pConn )
    {
        RasmanTrace(
               "RefConnection: ref on 0x%x = %d",
               hConn,
               pConn->CB_RefCount );
    }
    else
    {
        RasmanTrace(
               "RefConnection: pConn = NULL for 0x%x",
               hConn );
    }

    return;
}

DWORD
PostConfigChangeNotification(RAS_DEVICE_INFO *pInfo)
{
    DWORD retcode = SUCCESS;
    RAS_DEVICE_INFO *pRasDeviceInfo = NULL;
    PRAS_OVERLAPPED pRasOverlapped;

    //
    // Allocate a ras overlapped structure
    //
    if (NULL == (pRasOverlapped =
                LocalAlloc(LPTR, sizeof(RAS_OVERLAPPED))))
    {
        retcode = GetLastError();

        RasmanTrace(
               "PostConfigChangedNotification: failed to "
               "allocate. 0x%08x",
               retcode);

        goto done;
    }

    //
    // Allocate a deviceinfo structure which we can
    // queue on the completion port
    //
    if (NULL == (pRasDeviceInfo =
                LocalAlloc(LPTR, sizeof(RAS_DEVICE_INFO))))
    {
        retcode = GetLastError();

        LocalFree(pRasOverlapped);

        RasmanTrace(
               "PostConfigChangedNotification: Failed to "
               "allocate. 0x%08x",
               retcode);

        goto done;
    }

    *pRasDeviceInfo = *pInfo;

    pRasOverlapped->RO_EventType = OVEVT_DEV_RASCONFIGCHANGE;
    pRasOverlapped->RO_Info = (PVOID) pRasDeviceInfo;

    if (!PostQueuedCompletionStatus(
            hIoCompletionPort,
            0,0,
            ( LPOVERLAPPED ) pRasOverlapped)
            )
    {
        retcode = GetLastError();

        RasmanTrace(
               "Failed to post Config changed event for %s. "
               "GLE = %d",
               pInfo->szDeviceName,
               retcode);

        LocalFree(pRasOverlapped);

        LocalFree(pRasDeviceInfo);
    }

done:
    return retcode;
}

VOID
SetDeviceConfigInfo(pPCB ppcb, PBYTE pBuffer)
{
    RAS_DEVICE_INFO *pInfo = (RAS_DEVICE_INFO *) ((REQTYPECAST *)
                             pBuffer)->DeviceConfigInfo.abdata;

    DWORD cDevices = ((REQTYPECAST *)
                      pBuffer)->DeviceConfigInfo.cEntries;

    DWORD cbBuffer = ((REQTYPECAST *)
                      pBuffer)->DeviceConfigInfo.cbBuffer;

    DWORD retcode = SUCCESS;

    DWORD i;

    BOOL fComplete = TRUE;

    DeviceInfo *pDeviceInfo = NULL;

    GUID *pGuidDevice;

    RasmanTrace(
           "SetDeviceInfo... cDevices=%d",
           cDevices);

    //
    // Do some basic parameter validation
    //
    if(cbBuffer < cDevices * sizeof(RAS_DEVICE_INFO))
    {
        retcode = ERROR_INVALID_PARAMETER;

        goto done;
    }

    //
    // Iterate through all the devices and process
    // the information sent in.
    //
    for(i = 0; i < cDevices; i++)
    {
        pDeviceInfo = GetDeviceInfo(
                (RDT_Modem ==
                RAS_DEVICE_TYPE(pInfo[i].eDeviceType))
                ? (PBYTE) pInfo[i].szDeviceName
                : (PBYTE) &pInfo[i].guidDevice,
                RDT_Modem == RAS_DEVICE_TYPE(
                pInfo[i].eDeviceType));

#if DBG
        ASSERT(NULL != pDeviceInfo);
#endif
        if(NULL == pDeviceInfo)
        {
            RasmanTrace(
                   "DeviceInfo not found for device %s!",
                   pInfo[i].szDeviceName);

            fComplete = FALSE;

            pInfo[i].dwError = ERROR_DEVICE_DOES_NOT_EXIST;

            continue;
        }

        //
        // Check to see if this device is available to
        // be fiddled with. We may still be processing
        // a previous operation
        //
        if (DS_Unavailable == pDeviceInfo->eDeviceStatus)
        {
            RasmanTrace(
                   "Device %s is Unavailable",
                   pInfo[i].szDeviceName);

            fComplete = FALSE;

            pInfo[i].dwError = ERROR_CAN_NOT_COMPLETE;

            continue;
        }

        //
        // Check to see if the enpointinfo is a valid
        // value for the cases where the endpoint
        // change is allowed. The number of endpoints
        // should be in the range of
        // <dwMinWanEndPoints, dwMaxWanEndPoints>
        //
        if(     (pInfo[i].dwMinWanEndPoints
                != pInfo[i].dwMaxWanEndPoints)

            &&  (   (pInfo[i].dwNumEndPoints <
                    pInfo[i].dwMinWanEndPoints)

                ||  (pInfo[i].dwNumEndPoints >
                    pInfo[i].dwMaxWanEndPoints)))
        {
            RasmanTrace(
                   "NumEndPoints value is not valid"
                   "nep=%d, min=%d, max=%d",
                   pInfo[i].dwNumEndPoints,
                   pInfo[i].dwMinWanEndPoints,
                   pInfo[i].dwMaxWanEndPoints);

            RasmanTrace(
                   "Ignoring the notification for %s",
                   pInfo[i].szDeviceName);

            continue;


        }

        //
        // Check to see if the client wants to write the
        // information in the registry and do so before
        // posting a notification to rasman's completion
        // port.
        //
        if(pInfo[i].fWrite)
        {
            DeviceInfo di;

            di.rdiDeviceInfo = pInfo[i];


            if(RDT_Modem != RAS_DEVICE_TYPE(pInfo[i].eDeviceType))
            {
                retcode = DwSetEndPointInfo(&di,
                              (PBYTE) &pInfo[i].guidDevice);
            }
            else
            {
                retcode = DwSetModemInfo(&di);
            }

            if(retcode)
            {
                RasmanTrace(
                       "Failed to save information to "
                       "registry for %s. 0x%08x",
                       pInfo[i].szDeviceName,
                       retcode);

                fComplete = FALSE;

                pInfo[i].dwError = retcode;

                continue;
            }
        }

        //
        // Create a notification packet and queue it on
        // the completion port for processing
        //
        retcode = PostConfigChangeNotification(&pInfo[i]);

        if(retcode)
        {
            fComplete = FALSE;
        }
    }

done:

    if(!fComplete)
    {
        retcode = ERROR_CAN_NOT_COMPLETE;
    }

    ((REQTYPECAST *)
    pBuffer)->DeviceConfigInfo.retcode = retcode;

    RasmanTrace(
           "SetDeviceInfo done. %d",
           retcode);

    return;
}

VOID
GetDeviceConfigInfo(pPCB ppcb, PBYTE pBuffer)
{
    RAS_DEVICE_INFO *pInfo = (RAS_DEVICE_INFO *) ((REQTYPECAST *)
                             pBuffer)->DeviceConfigInfo.abdata;

    DWORD dwSize = ((REQTYPECAST *)
                    pBuffer)->DeviceConfigInfo.cbBuffer;

    DWORD dwVersion = ((REQTYPECAST *)
                      pBuffer)->DeviceConfigInfo.dwVersion;

    DWORD cEntries = 0;

    DeviceInfo *pDeviceInfo = g_pDeviceInfoList;

    DWORD retcode = SUCCESS;

    RasmanTrace(
           "GetDeviceConfigInfo...");

    if(dwVersion != RAS_VERSION)
    {
        retcode = ERROR_NOT_SUPPORTED;
        goto done;
    }

    //
    // Iterate through all the devices we have and
    // fill in the information.
    //
    while(pDeviceInfo)
    {
        if(     !pDeviceInfo->fValid
            ||  (CALL_OUT_ONLY == pDeviceInfo->dwUsage))
        {
            pDeviceInfo = pDeviceInfo->Next;
            continue;
        }

        if(dwSize >= sizeof(RAS_DEVICE_INFO))
        {
            memcpy(pInfo,
                   (PBYTE) &pDeviceInfo->rdiDeviceInfo,
                   sizeof(RAS_DEVICE_INFO));

            dwSize -= sizeof(RAS_DEVICE_INFO);

            pInfo++;
        }

        cEntries += 1;

        pDeviceInfo = pDeviceInfo->Next;
    }

    ((REQTYPECAST *)
    pBuffer)->DeviceConfigInfo.cEntries = cEntries;

    ((REQTYPECAST *)
    pBuffer)->DeviceConfigInfo.cbBuffer =
                cEntries * sizeof(RAS_DEVICE_INFO);

    ((REQTYPECAST *)
    pBuffer)->DeviceConfigInfo.dwVersion = RAS_VERSION;

done:
    ((REQTYPECAST *)
    pBuffer)->DeviceConfigInfo.retcode = retcode;

    RasmanTrace(
           "GetDeviceConfigDone. retcode=%d",
           retcode);

    return;
}

VOID
FindPrerequisiteEntry(pPCB ppcb, PBYTE pBuffer)
{
    HCONN hConn = ((REQTYPECAST *)
                   pBuffer)->FindRefConnection.hConn;

    ConnectionBlock *pConn;

    DWORD retcode = SUCCESS;

    //
    // Find the connection
    //
    pConn = FindConnection(hConn);

    if(NULL == pConn)
    {
        RasmanTrace(
               "Connection 0x%08x not found",
               hConn);

        retcode = ERROR_NO_CONNECTION;

        goto done;
    }

    ((REQTYPECAST *)
    pBuffer)->FindRefConnection.hRefConn =
                          pConn->CB_ReferredEntry;

    if(pConn->CB_ReferredEntry)
    {
        RasmanTrace(
               "Referred Entry for 0x%08x found=0x%08x",
               hConn,
               pConn->CB_ReferredEntry);
    }

done:
    ((REQTYPECAST *)
    pBuffer)->FindRefConnection.retcode = retcode;

}

VOID
GetConnectionStats(pPCB ppcb, PBYTE pBuffer)
{
    HCONN hConn = ((REQTYPECAST *)
                  pBuffer)->GetStats.hConn;

    ConnectionBlock *pConn = FindConnection(hConn);

    DWORD retcode = SUCCESS;

    DWORD i;

    pPCB ppcbT = NULL;

    BYTE UNALIGNED *pbStats = (BYTE UNALIGNED *) ((REQTYPECAST *)
                    pBuffer)->GetStats.abStats;

    DWORD dwConnectDuration = 0;

    DWORD dwConnectionSpeed = 0;

    DWORD dwT;

    PDWORD pdwStats = (DWORD *) pbStats;

    if(NULL == pConn)
    {

#if 0
        RasmanTrace(
               "GetConnectionStats: No Connection "
               "found for 0x%08x",
               hConn);
#endif               

        retcode = ERROR_NO_CONNECTION;

        goto done;
    }

    ppcb = NULL;

    //
    // Find a connected/open port
    //
    for(i = 0; i < pConn->CB_MaxPorts; i++)
    {
        ppcb = pConn->CB_PortHandles[i];
        if(     NULL == ppcb
            ||  OPEN != ppcb->PCB_PortStatus)
        {
            continue;
        }

        ppcbT = ppcb;

        if(CONNECTED == ppcbT->PCB_ConnState)
        {
            dwT = GetTickCount();

            //
            // This check is made to handle the case
            // where GetTickCount wraps around. This
            // will still not solve the problem where
            // the duration of connect becomes more than
            // 49.7 days. This is a current limitation
            // we can live with.
            //
            if(dwT < ppcb->PCB_ConnectDuration)
            {
                dwT += (0xFFFFFFFF - ppcb->PCB_ConnectDuration);
            }
            else
            {
                dwT -= ppcb->PCB_ConnectDuration;
            }

            if(dwT > dwConnectDuration)
            {
                dwConnectDuration = dwT;
            }

            dwConnectionSpeed += ppcb->PCB_LinkSpeed;
        }
    }

    if (NULL == ppcbT)
    {
        RasmanTrace(
               "GetConnectionStats: No Connected/Open Port "
               "found for 0x%08x",
               hConn);
        goto done;
    }

    //
    // Get the stats
    //
    GetBundleStatisticsEx(ppcbT, pbStats);

    //
    // Fill in the link speed and the duration for which the
    // connection was up
    //
    pdwStats[MAX_STATISTICS_EXT] = dwConnectionSpeed;

    pdwStats[MAX_STATISTICS_EXT + 1] = dwConnectDuration;

done:
    ((REQTYPECAST *)
    pBuffer)->GetStats.retcode = retcode;
}

VOID
GetLinkStats(pPCB ppcb, PBYTE pBuffer)
{
    HCONN hConn = ((REQTYPECAST *)
                   pBuffer)->GetStats.hConn;

    DWORD dwSubEntry = ((REQTYPECAST *)
                        pBuffer)->GetStats.dwSubEntry;

    ConnectionBlock *pConn = FindConnection(hConn);

    DWORD retcode = SUCCESS;

    BYTE UNALIGNED *pbStats = (BYTE UNALIGNED *) ((REQTYPECAST *)
                                pBuffer)->GetStats.abStats;

    DWORD *pdwStats = (DWORD *) pbStats;

    if(NULL == pConn)
    {
        RasmanTrace(
               "GetLinkStats: No Connection found for 0x%08x",
               hConn);

        retcode = ERROR_NO_CONNECTION;
        goto done;
    }

    if(     dwSubEntry > pConn->CB_MaxPorts
        ||  NULL == pConn->CB_PortHandles[dwSubEntry - 1]
        ||  OPEN !=
            pConn->CB_PortHandles[dwSubEntry - 1]->PCB_PortStatus)
    {
        RasmanTrace(
               "GetLinkStats: conn=0x%08x, SubEntry=%d "
               "is not connected/open",
               hConn,
               dwSubEntry);

        retcode = ERROR_PORT_NOT_CONNECTED;

        goto done;
    }

    ppcb = pConn->CB_PortHandles[dwSubEntry - 1];

    //
    // Get the stats
    //
    GetLinkStatisticsEx(ppcb, pbStats);

    //
    // Fill in the link speed
    //
    pdwStats[MAX_STATISTICS_EXT] = ppcb->PCB_LinkSpeed;

    //
    // Calculate the duration of connection
    //
    if(CONNECTED == ppcb->PCB_ConnState)
    {
        DWORD dwT = GetTickCount();

        //
        // This check is made to handle the case
        // where GetTickCount wraps around. This
        // will still not solve the problem where
        // the duration of connect becomes more than
        // 49.7 days. This is a current limitation
        // we can live with.
        //
        if(dwT < ppcb->PCB_ConnectDuration)
        {
            dwT += (0xFFFFFFFF - ppcb->PCB_ConnectDuration);
        }
        else
        {
            dwT -= ppcb->PCB_ConnectDuration;
        }

        pdwStats[MAX_STATISTICS_EXT + 1] = dwT;
    }

done:
    ((REQTYPECAST *)
    pBuffer)->GetStats.retcode = retcode;
}

VOID
GetHportFromConnection(pPCB ppcb, PBYTE pBuffer)
{
    HCONN hConn = ((REQTYPECAST *)
                    pBuffer)->GetHportFromConnection.hConn;

    ConnectionBlock *pConn = FindConnection(hConn);

    DWORD retcode;

    ULONG i;

    HPORT hPort = INVALID_HPORT;

    if(NULL == pConn)
    {
        RasmanTrace(
               "GetHportFromConnection: connection "
               "0x%08x not found.",
               hConn);

        retcode = ERROR_NO_CONNECTION;

        goto done;
    }

    for(i = 0; i < pConn->CB_MaxPorts; i++)
    {
        ppcb = pConn->CB_PortHandles[i];

        if(     NULL == ppcb
            ||  OPEN != ppcb->PCB_PortStatus)
        {
            continue;
        }

        hPort = ppcb->PCB_PortHandle;

        if(CONNECTED == ppcb->PCB_ConnState)
        {
            break;
        }
    }

done:
    ((REQTYPECAST *)
    pBuffer)->GetHportFromConnection.hPort = hPort;

    ((REQTYPECAST *)
    pBuffer)->GetHportFromConnection.retcode = ((hPort == INVALID_HPORT)
                                                ? ERROR_PORT_NOT_FOUND
                                                : SUCCESS);
}

VOID
ReferenceCustomCount(pPCB ppcb, PBYTE pBuffer)
{
    HCONN hConn = ((REQTYPECAST *)
                    pBuffer)->ReferenceCustomCount.hConn;

    ConnectionBlock *pConn;

    BOOL fAddref = ((REQTYPECAST *)
                    pBuffer)->ReferenceCustomCount.fAddRef;

    CHAR *pszPhonebook = ((REQTYPECAST *)
                          pBuffer)->ReferenceCustomCount.szPhonebookPath;

    CHAR *pszEntryName = ((REQTYPECAST *)
                          pBuffer)->ReferenceCustomCount.szEntryName;

    DWORD retcode = SUCCESS;

    DWORD dwCustomCount = 0;

    RasmanTrace(
           "ReferenceCustomCount");

     if(fAddref)
     {
        //
        // Get the connection
        //
        pConn = FindConnectionFromEntry(
                            pszPhonebook,
                            pszEntryName,
                            0, NULL);

        if(NULL == pConn)
        {
            retcode = ERROR_NO_CONNECTION;
            goto done;
        }

        dwCustomCount = pConn->CB_CustomCount;

        pConn->CB_CustomCount += 1;
     }
     else
     {
        pConn = FindConnection(hConn);

        if(NULL == pConn)
        {
            retcode = ERROR_NO_CONNECTION;
            goto done;
        }

        if(0 == pConn->CB_CustomCount)
        {
            goto done;
        }

        //
        // Copy the phonebook and entry name
        //
        strcpy(pszPhonebook,
               pConn->CB_ConnectionParams.CP_Phonebook);

        strcpy(pszEntryName,
               pConn->CB_ConnectionParams.CP_PhoneEntry);

        dwCustomCount = pConn->CB_CustomCount;

        if(dwCustomCount > 0)
        {
            pConn->CB_CustomCount -= 1;
        }
     }

done:

    ((REQTYPECAST *)
    pBuffer)->ReferenceCustomCount.dwCount = dwCustomCount;

    ((REQTYPECAST *)
     pBuffer)->ReferenceCustomCount.retcode = retcode;

    RasmanTrace(
           "ReferenceCustomCount done. %d",
           retcode);
}

VOID
GetHconnFromEntry(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;

    CHAR *pszPhonebook = ((REQTYPECAST *)
                          pBuffer)->HconnFromEntry.szPhonebookPath;

    CHAR *pszEntry = ((REQTYPECAST *)
                      pBuffer)->HconnFromEntry.szEntryName;

    ConnectionBlock *pConn;

    RasmanTrace(
           "GetHconnFromEntry. %s",
           pszEntry);

    pConn = FindConnectionFromEntry(pszPhonebook,
                                    pszEntry,
                                    0, NULL);

    if(NULL == pConn)
    {
        retcode = ERROR_NO_CONNECTION;
        goto done;
    }

    ((REQTYPECAST *)
     pBuffer)->HconnFromEntry.hConn = pConn->CB_Handle;

done:

    ((REQTYPECAST *)
     pBuffer)->HconnFromEntry.retcode = retcode;

    RasmanTrace(
           "GetHconnFromEntry done. %d",
           retcode);
}


VOID
GetConnectInfo(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;

    RASTAPI_CONNECT_INFO *pConnectInfo =
                        &((REQTYPECAST *)
                        pBuffer)->GetConnectInfo.rci;

    DWORD dwSize = ((REQTYPECAST *)
                 pBuffer)->GetConnectInfo.dwSize;

    RAS_DEVICE_INFO *prdi;

    RasmanTrace(
           "GetConnectInfo: port %s",
           ppcb->PCB_Name);

    if(     (REMOVED == ppcb->PCB_PortStatus)
        ||  (UNAVAILABLE == ppcb->PCB_PortStatus))
    {
        dwSize = 0;
        retcode = ERROR_PORT_NOT_AVAILABLE;
        goto done;
    }

    ZeroMemory(pConnectInfo,
               sizeof(RASTAPI_CONNECT_INFO));

    prdi = &ppcb->PCB_pDeviceInfo->rdiDeviceInfo;

    //
    // Get the information from TAPI
    //
    retcode = (DWORD)RastapiGetConnectInfo(
                        ppcb->PCB_PortIOHandle,
                        (RDT_Modem == RAS_DEVICE_TYPE(
                        prdi->eDeviceType))
                        ? (PBYTE) prdi->szDeviceName
                        : (PBYTE) &prdi->guidDevice,
                        (RDT_Modem == RAS_DEVICE_TYPE(
                        prdi->eDeviceType)),
                        pConnectInfo,
                        &dwSize
                        );

    RasmanTrace(
           "GetConnectInfo: size=%d, rc=0xx%x",
           dwSize,
           retcode);

done:

    ((REQTYPECAST *)
    pBuffer)->GetConnectInfo.dwSize = dwSize;

    ((REQTYPECAST *)
    pBuffer)->GetConnectInfo.retcode = retcode;

    return;

}

VOID
GetVpnDeviceNameW(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;

    WCHAR *pszDeviceName = ((REQTYPECAST *)
                          pBuffer)->GetDeviceNameW.szDeviceName;

    RASDEVICETYPE eDeviceType = ((REQTYPECAST *)
                                pBuffer)->GetDeviceNameW.eDeviceType;

    DeviceInfo *pDeviceInfo = g_pDeviceInfoList;

    //
    // Loop through the global device list and return
    // the devicename of the first device found with
    // the specified devicetype
    //
    while(NULL != pDeviceInfo)
    {
        if(RAS_DEVICE_TYPE(eDeviceType) ==
            RAS_DEVICE_TYPE(pDeviceInfo->rdiDeviceInfo.eDeviceType))
        {
            break;
        }

        pDeviceInfo = pDeviceInfo->Next;
    }

    if(NULL == pDeviceInfo)
    {
        retcode = ERROR_DEVICETYPE_DOES_NOT_EXIST;

        goto done;
    }

    wcscpy(pszDeviceName,
           pDeviceInfo->rdiDeviceInfo.wszDeviceName);

done:

    ((REQTYPECAST *)
    pBuffer)->GetDeviceNameW.retcode = retcode;

    return;

}


VOID
GetDeviceName(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;

    CHAR *pszDeviceName = ((REQTYPECAST *)
                          pBuffer)->GetDeviceName.szDeviceName;

    RASDEVICETYPE eDeviceType = ((REQTYPECAST *)
                                pBuffer)->GetDeviceName.eDeviceType;

    DeviceInfo *pDeviceInfo = g_pDeviceInfoList;

    //
    // Loop through the global device list and return
    // the devicename of the first device found with
    // the specified devicetype
    //
    while(NULL != pDeviceInfo)
    {
        if(RAS_DEVICE_TYPE(eDeviceType) ==
            RAS_DEVICE_TYPE(pDeviceInfo->rdiDeviceInfo.eDeviceType))
        {
            break;
        }

        pDeviceInfo = pDeviceInfo->Next;
    }

    if(NULL == pDeviceInfo)
    {
        retcode = ERROR_DEVICETYPE_DOES_NOT_EXIST;

        goto done;
    }

    strcpy(pszDeviceName,
           pDeviceInfo->rdiDeviceInfo.szDeviceName);

done:

    ((REQTYPECAST *)
    pBuffer)->GetDeviceName.retcode = retcode;

    return;

}

VOID
GetCalledIDInfo(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;

    PBYTE pbAdapter;

    RAS_DEVICE_INFO *prdi = &((REQTYPECAST *)
                            pBuffer)->GetSetCalledId.rdi;

    BOOL fModem = (RDT_Modem == RAS_DEVICE_TYPE(prdi->eDeviceType));

    //
    // Do access check
    //
    if(!FRasmanAccessCheck())
    {
        retcode = ERROR_ACCESS_DENIED;
        goto done;
    }

    ASSERT(NULL != RastapiGetCalledIdInfo);

    pbAdapter =   (fModem)
                ? (PBYTE) (prdi->szDeviceName)
                : (PBYTE) &(prdi->guidDevice);

    retcode = (DWORD) RastapiGetCalledIdInfo(
                        pbAdapter,
                        fModem,
                        &((REQTYPECAST *)
                        pBuffer)->GetSetCalledId.rciInfo,
                        &((REQTYPECAST *)
                        pBuffer)->GetSetCalledId.dwSize);

done:
    ((REQTYPECAST *)
    pBuffer)->GetSetCalledId.retcode = retcode;

    return;
}

VOID
SetCalledIDInfo(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;

    PBYTE pbAdapter;

    RAS_DEVICE_INFO *prdi = &((REQTYPECAST *)
                            pBuffer)->GetSetCalledId.rdi;


    BOOL fModem = (RDT_Modem == RAS_DEVICE_TYPE(prdi->eDeviceType));

    //
    // do access check
    //
    if(!FRasmanAccessCheck())
    {
        retcode = ERROR_ACCESS_DENIED;
        goto done;
    }

    ASSERT(NULL != RastapiSetCalledIdInfo);

    pbAdapter = (fModem)
              ? (PBYTE) (prdi->szDeviceName)
              : (PBYTE) &(prdi->guidDevice);

    retcode = (DWORD) RastapiSetCalledIdInfo(
                        pbAdapter,
                        fModem,
                        &((REQTYPECAST *)
                        pBuffer)->GetSetCalledId.rciInfo,
                        ((REQTYPECAST *)
                        pBuffer)->GetSetCalledId.fWrite);

done:
    ((REQTYPECAST *)
    pBuffer)->GetSetCalledId.retcode = retcode;

    return;
}

VOID
EnableIpSec(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;

    BOOL fEnable = ((REQTYPECAST *)
                    pBuffer)->EnableIpSec.fEnable;

    BOOL fServer = ((REQTYPECAST *)
                    pBuffer)->EnableIpSec.fServer;

    RAS_L2TP_ENCRYPTION eEncryption = ((REQTYPECAST *)
                           pBuffer)->EnableIpSec.eEncryption;

    if(0 != g_dwProhibitIpsec)
    {
        RasmanTrace(
               "EnableIpSec: ProhibitIpsec=1. Not Enabling ipsec");
        goto done;
    }

    if(fEnable)
    {
        RasmanTrace(
               "Adding filters for port=%d, "
               "destaddr=0x%x, eEncryption=%d",
               ppcb->PCB_PortHandle,
               ppcb->PCB_ulDestAddr,
               eEncryption);

        retcode = DwAddIpSecFilter(ppcb, fServer, eEncryption);
    }
    else
    {
        retcode = DwDeleteIpSecFilter(ppcb, fServer);
    }

    RasmanTrace(
           "EnableIpSec: port=%s, fServer=%d, fEnable = %d, rc=0x%x",
           ppcb->PCB_Name,
           fServer,
           fEnable,
           retcode);

done:

    ((REQTYPECAST *)
    pBuffer)->EnableIpSec.retcode = retcode;

    return;
}


VOID
IsIpSecEnabled(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;

    BOOL fEnabled = FALSE;

    if(0 != g_dwProhibitIpsec)
    {
        RasmanTrace(
               "IsIpsecEnabled: ProhibitIpsec=1");
        goto done;
    }

    retcode = DwIsIpSecEnabled(ppcb,
                               &fEnabled);

    ((REQTYPECAST *)
    pBuffer)->IsIpSecEnabled.fIsIpSecEnabled = fEnabled;

done:
    ((REQTYPECAST *)
    pBuffer)->IsIpSecEnabled.retcode = retcode;

    RasmanTrace(
           "IsIpSecEnabled. port=%s, fEnabled=%d, rc=0x%x",
           ppcb->PCB_Name,
           fEnabled,
           retcode);

    return;

}


VOID
SetEapLogonInfo(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;

    DWORD cbEapLogonInfo = ((REQTYPECAST *)
                            pBuffer)->SetEapLogonInfo.dwSizeofEapData;

    BYTE  *pbEapLogonInfo = (BYTE * ) ((REQTYPECAST *)
                            pBuffer)->SetEapLogonInfo.abEapData;

    BOOL  fLogon = ((REQTYPECAST *)
                   pBuffer)->SetEapLogonInfo.fLogon;

    if(NULL == ppcb)
    {
        retcode = ERROR_PORT_NOT_FOUND;
        goto done;
    }

    RasmanTrace(
           "SetEapLogonInfo. Port %s",
           ppcb->PCB_Name);

    RasmanTrace(
           "SetEapLogonInfo. cbInfo=%d, fLogon=%d",
           cbEapLogonInfo,
           fLogon);

    ppcb->PCB_pCustomAuthUserData = LocalAlloc(LPTR,
                                         sizeof(RAS_CUSTOM_AUTH_DATA)
                                         + cbEapLogonInfo);

    if(NULL == ppcb->PCB_pCustomAuthUserData)
    {
        retcode = GetLastError();
        goto done;
    }

    ppcb->PCB_pCustomAuthUserData->cbCustomAuthData = cbEapLogonInfo;

    memcpy(ppcb->PCB_pCustomAuthUserData->abCustomAuthData,
           pbEapLogonInfo,
           cbEapLogonInfo);

    RasmanTrace(
           "PCB_pEapLogonInfo=0x%x",
           ppcb->PCB_pCustomAuthUserData);

    ppcb->PCB_fLogon = fLogon;

done:
    ((REQTYPECAST *)
    pBuffer)->SetEapLogonInfo.retcode = retcode;

    RasmanTrace(
           "SetEapLogonInfo. retcode=0x%x",
           retcode);

    return;
}

VOID
SendNotificationRequest(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;

    RASEVENT *pRasEvent = &((REQTYPECAST *)
                            pBuffer)->SendNotification.RasEvent;

    RasmanTrace(
           "SendNotificationRequest");

    retcode = DwSendNotification(pRasEvent);

    RasmanTrace(
           "DwSendNotification returned 0x%x",
           retcode);

    ((REQTYPECAST *)
    pBuffer)->SendNotification.retcode = retcode;

    return;
}

VOID
GetNdiswanDriverCaps(pPCB ppcb, PBYTE pBuffer)
{
    RAS_NDISWAN_DRIVER_INFO *pInfo =
                &((REQTYPECAST *)
                pBuffer)->GetNdiswanDriverCaps.NdiswanDriverInfo;


    DWORD retcode = SUCCESS;

    RasmanTrace(
           "GetNdiswanDriverCaps..");

    if(!g_fNdiswanDriverInfo)
    {
        NDISWAN_DRIVER_INFO NdiswanDriverInfo;
        DWORD bytesrecvd;

        ZeroMemory((PBYTE) &NdiswanDriverInfo,
                   sizeof(NDISWAN_DRIVER_INFO));

        //
        // Query ndiswan
        //
        if (!DeviceIoControl (
                RasHubHandle,
                IOCTL_NDISWAN_GET_DRIVER_INFO,
                &NdiswanDriverInfo,
                sizeof(NDISWAN_DRIVER_INFO),
                &NdiswanDriverInfo,
                sizeof(NDISWAN_DRIVER_INFO),
                &bytesrecvd,
                NULL))
        {
            retcode = GetLastError () ;
            goto done;
        }

        CopyMemory((PBYTE) &g_NdiswanDriverInfo,
               (PBYTE) &NdiswanDriverInfo,
               sizeof(NDISWAN_DRIVER_INFO));

        g_fNdiswanDriverInfo = TRUE;
    }

    CopyMemory((PBYTE) pInfo,
           (PBYTE) &g_NdiswanDriverInfo,
           sizeof(RAS_NDISWAN_DRIVER_INFO));

done:
    ((REQTYPECAST *)
    pBuffer)->GetNdiswanDriverCaps.retcode = retcode;

    RasmanTrace(
           "GetNdiswanDriverCaps rc=0x%x",
           retcode);

    return;
}

VOID
GetBandwidthUtilization(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;

    RAS_GET_BANDWIDTH_UTILIZATION *pUtilization =
        &((REQTYPECAST *)
        pBuffer)->GetBandwidthUtilization.BandwidthUtilization;

    NDISWAN_GET_BANDWIDTH_UTILIZATION Utilization;

    DWORD bytesrecvd;

    RasmanTrace(
           "GetBandwidthUtilization..");

    if(NULL == ppcb)
    {
        retcode = ERROR_PORT_NOT_FOUND;
        goto done;
    }

    ZeroMemory((PBYTE) &Utilization,
               sizeof(NDISWAN_GET_BANDWIDTH_UTILIZATION));

    Utilization.hBundleHandle = ppcb->PCB_BundleHandle;

    bytesrecvd = 0;

    //
    // Query ndiswan
    //
    if (!DeviceIoControl (
            RasHubHandle,
            IOCTL_NDISWAN_GET_BANDWIDTH_UTILIZATION,
            &Utilization,
            sizeof(NDISWAN_GET_BANDWIDTH_UTILIZATION),
            &Utilization,
            sizeof(NDISWAN_GET_BANDWIDTH_UTILIZATION),
            &bytesrecvd,
            NULL))
    {
        retcode = GetLastError () ;
        goto done;
    }

    RasmanTrace( "bytesrecvd=%d, Utilization: %d %d %d %d",
                bytesrecvd,
                Utilization.ulUpperXmitUtil,
                Utilization.ulLowerXmitUtil,
                Utilization.ulUpperRecvUtil,
                Utilization.ulLowerRecvUtil);

    //
    // Copy back the information returned from ndiswan
    //
    pUtilization->ulUpperXmitUtil = Utilization.ulUpperXmitUtil;
    pUtilization->ulLowerXmitUtil = Utilization.ulLowerXmitUtil;
    pUtilization->ulUpperRecvUtil = Utilization.ulUpperRecvUtil;
    pUtilization->ulLowerRecvUtil = Utilization.ulLowerRecvUtil;

done:

    ((REQTYPECAST *)
    pBuffer)->GetBandwidthUtilization.retcode = retcode;

    RasmanTrace(
           "GetBandwidthUtilization rc=ox%x", retcode);

    return;

}

/*++

Routine Description:

    This function allows rasauto.dll to provide
    a callback procedure that gets invoked when
    a connection is terminated due to hardware
    failure on its remaining link.

Arguments:

    func

Return Value:

    void

--*/
VOID
RegisterRedialCallback(pPCB ppcb, PBYTE pBuffer)
{
    RedialCallbackFunc = ((REQTYPECAST *)
            pBuffer)->RegisterRedialCallback.pvCallback;

    ((REQTYPECAST *)
    pBuffer)->RegisterRedialCallback.retcode = SUCCESS;

    return;


}

VOID
GetProtocolInfo(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;
    DWORD bytesrecvd;

    NDISWAN_GET_PROTOCOL_INFO protinfo;

    ASSERT(sizeof(NDISWAN_GET_PROTOCOL_INFO) ==
          sizeof(RASMAN_GET_PROTOCOL_INFO));

    RasmanTrace(
           "GetProtocolInfo..");

    ZeroMemory((PBYTE) &protinfo,
               sizeof(NDISWAN_GET_PROTOCOL_INFO));

    if(INVALID_HANDLE_VALUE == RasHubHandle)
    {
        RasmanTrace(
            "Ndiswan hasn't been loaded yet");
        goto done;
    }

    if(!DeviceIoControl(
        RasHubHandle,
        IOCTL_NDISWAN_GET_PROTOCOL_INFO,
        NULL,
        0,
        &protinfo,
        sizeof(NDISWAN_GET_PROTOCOL_INFO),
        &bytesrecvd,
        NULL))
    {
        retcode = GetLastError();
        RasmanTrace(
               "GetProtocolInfo: failed 0x%x",
               retcode);

        goto done;
    }

    memcpy((PBYTE) &((REQTYPECAST *)
            pBuffer)->GetProtocolInfo.Info,
            (PBYTE) &protinfo,
            sizeof(RASMAN_GET_PROTOCOL_INFO));

#if DBG
    {
        DWORD i;

        RasmanTrace(
               "# of Available protocols=%d",
               protinfo.ulNumProtocols);

        for(i = 0; i < protinfo.ulNumProtocols; i++)
        {
            RasmanTrace(
                   "    0x%x",
                   protinfo.ProtocolInfo[i].ProtocolType);
        }
    }
#endif

done:
    RasmanTrace(
           "GetProtocolInfo: rc=0x%x",
           retcode);

    ((REQTYPECAST *)
    pBuffer)->GetProtocolInfo.retcode = retcode;

    return;
}

VOID
GetCustomScriptDll(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = SUCCESS;
    CHAR *pszCustomScriptDll =
            ((REQTYPECAST *) pBuffer)->
                GetCustomScriptDll.szCustomScript;

    CHAR *pszCustomDllPath = NULL;

    HKEY hkey = NULL;

    DWORD dwSize = 0, dwType = 0;

    RasmanTrace(
           "GetCustomScriptDll");

    //
    // Read from registry to see if theres
    // a customdll registered.
    //
    retcode = (DWORD) RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                "System\\CurrentControlSet\\Services\\Rasman\\Parameters",
                0,
                KEY_QUERY_VALUE,
                &hkey);

    if(ERROR_SUCCESS != retcode)
    {
        goto done;
    }

    //
    // Query the REG_EXPAND_SZ value
    //
    retcode = RegQueryValueEx(
                hkey,
                "CustomScriptDllPath",
                NULL,
                &dwType,
                NULL,
                &dwSize);

    if(     (ERROR_SUCCESS != retcode)
        ||  (REG_EXPAND_SZ != dwType)
        ||  (0 == dwSize)
        ||  (MAX_PATH < dwSize))
    {
        if(SUCCESS == retcode)
        {
            retcode = E_FAIL;
        }

        goto done;
    }

    if(NULL == (pszCustomDllPath = LocalAlloc(LPTR, dwSize)))
    {
        retcode = GetLastError();
        goto done;
    }

    retcode = (DWORD) RegQueryValueEx(
                hkey,
                "CustomScriptDllPath",
                NULL,
                &dwType,
                pszCustomDllPath,
                &dwSize);

    if(     (ERROR_SUCCESS != retcode)
        ||  (REG_EXPAND_SZ != dwType)
        ||  (0 == dwSize)
        ||  (MAX_PATH < dwSize))
    {
        RasmanTrace(
               "GetCustomScriptDll: RegQueryVaue failed. 0x%x",
                retcode);

        goto done;
    }

    //
    // find the size of the expanded string
    //
    if (0 == (dwSize =
              ExpandEnvironmentStrings(pszCustomDllPath,
                                       NULL,
                                       0)))
    {
        retcode = GetLastError();
        goto done;
    }

    //
    // Get the expanded string
    //
    if (0 == ExpandEnvironmentStrings(
                                pszCustomDllPath,
                                pszCustomScriptDll,
                                dwSize))
    {
        retcode = GetLastError();
    }
    else
    {
        RasmanTrace(
               "GetCustomScriptDll: dllpath=%s",
                pszCustomScriptDll);
    }


done:

    ((REQTYPECAST *) pBuffer)->GetCustomScriptDll.retcode = retcode;

    if(NULL != pszCustomDllPath)
    {
        LocalFree(pszCustomDllPath);
    }

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    return;
}

VOID
IsTrustedCustomDll(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;

    WCHAR *pwszCustomDll = ((REQTYPECAST *)pBuffer)->IsTrusted.wszCustomDll;

    BOOL fTrusted = FALSE;

    if(IsCustomDLLTrusted(pwszCustomDll))
    {
        fTrusted = TRUE;
    }

    RasmanTrace(
           "IsTrustedCustomDll: pwsz=%ws, fTrusted=%d, rc=%d",
           pwszCustomDll,
           fTrusted,
           retcode);

    ((REQTYPECAST *)pBuffer)->IsTrusted.fTrusted = fTrusted;
    ((REQTYPECAST *)pBuffer)->IsTrusted.retcode = SUCCESS;
}

VOID
DoIke(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;
    HANDLE hEvent = NULL;

    if(0 != g_dwProhibitIpsec)
    {
        RasmanTrace(
               "DoIke: ProhibitIpSec=1. Not Doing Ike");

        retcode = E_ABORT;

        goto done;
    }

    hEvent = ValidateHandleForRasman(
    			((REQTYPECAST *) pBuffer)->DoIke.hEvent,
                ((REQTYPECAST *) pBuffer)->DoIke.pid);

    if(NULL == hEvent)
    {
        RasmanTrace(
               "DoIke, failed to validatehandle");

        retcode = E_INVALIDARG;

        goto done;
    }

    retcode = DwDoIke(ppcb, hEvent );

    RasmanTrace(
           "DwDoIke for port %s returned 0x%x",
           ppcb->PCB_Name,
           retcode);

done:

    ((REQTYPECAST *)pBuffer)->DoIke.retcode = retcode;

    RasmanTrace(
         "DoIke done. 0x%x",
        retcode);

	if(NULL != hEvent)
	{
		CloseHandle(hEvent);
	}

}

VOID
QueryIkeStatus(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;
    DWORD dwStatus;

    retcode = DwQueryIkeStatus(ppcb, &dwStatus);

    if(ERROR_SUCCESS == retcode)
    {
        ((REQTYPECAST *) pBuffer)->QueryIkeStatus.dwStatus = dwStatus;
    }

    ((REQTYPECAST *)pBuffer)->QueryIkeStatus.retcode = retcode;
}

VOID
SetRasCommSettings(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;

    if(RDT_Modem != RAS_DEVICE_TYPE(
                        ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType))
    {
        RasmanTrace(
               "SetRasCommSettings: Invalid devicetype 0x%x",
               ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType);
               
        retcode = E_INVALIDARG;
        goto done;
    }

    retcode = (DWORD) RastapiSetCommSettings(
                ppcb->PCB_PortIOHandle,
                &((REQTYPECAST *)pBuffer)->SetRasCommSettings.Settings);

done:

    ((REQTYPECAST *)pBuffer)->SetRasCommSettings.retcode = retcode;                

    RasmanTrace(
           "SetRasCommSettings: port %s returned 0x%x",
           ppcb->PCB_Name,
           retcode);

    return;
                
}

VOID
EnableRasAudio(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;
    BOOL  fEnable = ((REQTYPECAST *) pBuffer)->EnableRasAudio.fEnable;

    if(!FRasmanAccessCheck())
    {
        retcode = ERROR_ACCESS_DENIED;
        goto done;
    }
    
    if(fEnable)
    {
        retcode = InitializeRasAudio();
    }
    else
    {   
        retcode = UninitializeRasAudio();
    }

done:
    ((REQTYPECAST *)pBuffer)->EnableRasAudio.retcode = retcode;

    RasmanTrace("EnableRasAudio: fEnable=%d, error=%d",
                fEnable, retcode);

    return;                
}

VOID
SetKeyRequest(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;
    GUID  *pGuid = &((REQTYPECAST *) pBuffer)->GetSetKey.guid;
    DWORD dwMask = ((REQTYPECAST *) pBuffer)->GetSetKey.dwMask;
    DWORD cbkey = ((REQTYPECAST *) pBuffer)->GetSetKey.cbkey;
    PBYTE pbkey = ((REQTYPECAST *) pBuffer)->GetSetKey.data;
    DWORD dwPid = ((REQTYPECAST *)pBuffer)->GetSetKey.dwPid;

    if(dwPid != GetCurrentProcessId())
    {
        //
        // Check to see if the user has permissions to
        // set this key.
        //
        if(dwMask & (DLPARAMS_MASK_SERVER_PRESHAREDKEY
                  | (DLPARAMS_MASK_DDM_PRESHAREDKEY)))
        {
            if(!FRasmanAccessCheck())
            {
                retcode = ERROR_ACCESS_DENIED;
                goto done;
            }
        }
    }

    //
    // caller has cleared access checks.
    //
    retcode = SetKey(NULL,
                   pGuid,
                   dwMask,
                   (0 == cbkey)
                   ? TRUE
                   : FALSE,
                   cbkey,
                   pbkey);

    if(     (ERROR_SUCCESS == retcode)                   
        &&  (dwMask & DLPARAMS_MASK_SERVER_PRESHAREDKEY))
    {
        if(     (cbkey > 0)
            &&  (0 == memcmp(pbkey, L"****************", 
                      min(cbkey, 
                      sizeof(WCHAR) * wcslen(L"****************")))))
        {
            goto done;
        }
        
        retcode = DwUpdatePreSharedKey(cbkey, pbkey);

        RasmanTrace("DwUpdatePreSharedKey returned %d",
                    retcode);
    }

done:
    ((REQTYPECAST *) pBuffer)->GetSetKey.retcode = retcode;
}

VOID
GetKeyRequest(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;
    GUID *pGuid = &((REQTYPECAST *) pBuffer)->GetSetKey.guid;
    DWORD dwMask = ((REQTYPECAST *) pBuffer)->GetSetKey.dwMask;
    DWORD cbkey = ((REQTYPECAST *) pBuffer)->GetSetKey.cbkey;
    PBYTE pbkey = ((REQTYPECAST *) pBuffer)->GetSetKey.data;
    DWORD dwPid = ((REQTYPECAST *)pBuffer)->GetSetKey.dwPid;

    if(dwPid != GetCurrentProcessId())
    {
        //
        // Check to see if the caller has permissions to
        // get the key.
        //
        if(dwMask & (DLPARAMS_MASK_SERVER_PRESHAREDKEY
                  | (DLPARAMS_MASK_DDM_PRESHAREDKEY)))
        {
            if(!FRasmanAccessCheck())
            {
                retcode = ERROR_ACCESS_DENIED;
                goto done;
            }
        }
    }

    //
    // caller has cleared access checks.
    //
    retcode = GetKey(NULL,
                   pGuid,
                   dwMask,
                   &cbkey,
                   pbkey,
                   TRUE);

done:
    ((REQTYPECAST *) pBuffer)->GetSetKey.retcode = retcode;
    ((REQTYPECAST *) pBuffer)->GetSetKey.cbkey = cbkey;
}

VOID
DisableAutoAddress(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;
    WCHAR *pszAddress = ((REQTYPECAST *) pBuffer)->AddressDisable.szAddress;
    BOOL fDisable = ((REQTYPECAST *) pBuffer)->AddressDisable.fDisable;

    if(NULL != GetModuleHandle("rasauto.dll"))
    {
        BOOLEAN (*AddressDisable) (WCHAR * pszAddress,
                                 BOOLEAN fDisable);
        HINSTANCE hInst = NULL;        

        hInst = LoadLibrary("rasauto.dll");

        AddressDisable = (PVOID)GetProcAddress(hInst, "SetAddressDisabledEx");


        if(NULL != AddressDisable)
        {
            if(!AddressDisable(pszAddress, (BOOLEAN) fDisable))
            {
                RasmanTrace("AddressDisable %wz failed", pszAddress);
            }

            FreeLibrary(hInst);
        }
        else
        {
            retcode = GetLastError();
        }
    }

    ((REQTYPECAST *) pBuffer)->AddressDisable.retcode = retcode;

    RasmanTrace("DisableAutoAddress done. %d", retcode);
}

VOID
SendCredsRequest(pPCB ppcb, PBYTE pBuffer)
{
    DWORD retcode = ERROR_SUCCESS;
    DWORD pid = ((REQTYPECAST *) pBuffer)->SendCreds.pid;
    CHAR  *pszPassword = NULL, *psz;
    CHAR  controlchar = ((REQTYPECAST *)pBuffer)->SendCreds.controlchar;

    if(     (NULL == ppcb)
        || (UNAVAILABLE == ppcb->PCB_PortStatus))
    {
        RasmanTrace("SendCredsRequest: port not found");
        retcode = ERROR_PORT_NOT_FOUND;
        goto done;
    }

    if(     (ppcb->PCB_ConnState != CONNECTING)
        || (RAS_DEVICE_TYPE(ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType)
                != RDT_Modem))
    {
        RasmanTrace("SendCredsRequest: port in %d state",
                    ppcb->PCB_ConnState);
                    
        retcode = E_ACCESSDENIED;
        goto done;
    }

    pszPassword = LocalAlloc(LPTR, PWLEN + 1 + 2);
    if(NULL == pszPassword)
    {
        RasmanTrace("SendCredsRequest: failed to allocate");
        retcode = E_OUTOFMEMORY;
        goto done;
    }

    retcode = DwGetPassword(ppcb, pszPassword, pid);
    if(ERROR_SUCCESS != retcode)
    {
        RasmanTrace("SendCredsRequest: failed to get pwd 0x%x",
                    retcode);
        goto done;
    }

    RasmanTrace("ControlChar=%d", controlchar);
    if('\0' != controlchar)
    {
        pszPassword[strlen(pszPassword)] = controlchar;
    }        

    //
    // We have retrieved the password. Send it over the wire
    // character by character including the '\0' char.
    //
    psz = pszPassword;
    while(*psz)
    {
        retcode = PORTSEND( ppcb->PCB_Media,
                    ppcb->PCB_PortIOHandle,
                    psz,
                    sizeof(CHAR));

        if(     (ERROR_SUCCESS != retcode)
            && (PENDING != retcode))
        {
            RasmanTrace("SendCreds: PortSend failed 0x%x",
                        retcode);
        }
                    
        psz++;                  
    }

    retcode = ERROR_SUCCESS;
    
    
done:

    if(NULL != pszPassword)
    {
        ZeroMemory(pszPassword, PWLEN+1);
        LocalFree(pszPassword);
    }
    
    ((REQTYPECAST *)pBuffer)->SendCreds.retcode = retcode;
    
}

VOID
GetUnicodeDeviceName(pPCB ppcb, PBYTE pbuffer)
{
    DWORD retcode = ERROR_SUCCESS;
    
    if(     (ppcb != NULL)
        &&  (ppcb->PCB_pDeviceInfo != NULL))
    {
        wcscpy(
        ((REQTYPECAST *)pbuffer)->GetUDeviceName.wszDeviceName,
        ppcb->PCB_pDeviceInfo->rdiDeviceInfo.wszDeviceName);
    }
    else
    {
        retcode = ERROR_PORT_NOT_FOUND;
    }

    ((REQTYPECAST *)pbuffer)->GetUDeviceName.retcode = retcode;

    return;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\rnetcfg.h ===
extern "C"
{

    HRESULT HrRasCreateAndInitializeINetCfg (BOOL fInitCom, INetCfg** ppnc);
    
    HRESULT HrRasUninitializeAndReleaseINetCfg (BOOL fUninitCom, INetCfg* pnc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\thunk.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    thunk.c

Abstract:

    Support for WOW64.

Author:

    Rao Salapala (raos) 08-May-2001

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <rasman.h>
#include <rasppp.h>
#include <lm.h>
#include <lmwksta.h>
#include <wanpub.h>
#include <raserror.h>
#include <media.h>
#include <mprlog.h>
#include <rtutils.h>
#include <device.h>
#include <stdlib.h>
#include <string.h>
#include <rtutils.h>
#include <userenv.h>
#include "logtrdef.h"
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "reghelp.h"
#include "ndispnp.h"
#include "lmserver.h"
#include "llinfo.h"
#include "ddwanarp.h"

typedef struct _PortOpen32
    {
        DWORD   retcode;
        DWORD   notifier;
        DWORD   porthandle ;
        DWORD   PID ;
        DWORD   open ;
        CHAR    portname [MAX_PORT_NAME] ;
        CHAR    userkey [MAX_USERKEY_SIZE] ;
        CHAR    identifier[MAX_IDENTIFIER_SIZE] ;

    } PortOpen32 ;

VOID 
ThunkPortOpenRequest(
                    pPCB ppcb, 
                    BYTE *pBuffer, 
                    DWORD dwBufSize)
{
    BYTE *      pThunkBuffer    = NULL;
    DWORD       retcode         = ERROR_SUCCESS;
    PortOpen32 *pPortOpen32     = (PortOpen32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 2 * sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    //
    // Set up the thunk buffer
    //
    ((REQTYPECAST *)pThunkBuffer)->PortOpen.PID = 
                                        pPortOpen32->PID;

    ((REQTYPECAST *)pThunkBuffer)->PortOpen.open =
                                        pPortOpen32->open;

    ((REQTYPECAST *)pThunkBuffer)->PortOpen.notifier =  
                        LongToHandle(pPortOpen32->notifier);

    memcpy(((REQTYPECAST *)pThunkBuffer)->PortOpen.portname,
            pPortOpen32->portname,
            MAX_PORT_NAME + MAX_USERKEY_SIZE + MAX_IDENTIFIER_SIZE);

    //
    // Make the actual call
    //
    PortOpenRequest(ppcb, pThunkBuffer);

    //
    // Thunk back the results
    //
    pPortOpen32->porthandle = HandleToUlong(
                    ((REQTYPECAST *) pThunkBuffer)->PortOpen.porthandle);

    retcode = ((REQTYPECAST *) pThunkBuffer)->PortOpen.retcode;                                        

done:    
    ((PortOpen32 *) pBuffer)->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }

    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _PortReceive32
    {
        DWORD           size ;
        DWORD           timeout ;
        DWORD           handle ;
        DWORD           pid ;
        DWORD           buffer ;

    } PortReceive32 ;

VOID 
ThunkPortReceiveRequest(
                                pPCB ppcb, 
                                BYTE *pBuffer, 
                                DWORD dwBufSize)
{
    PBYTE           pThunkBuffer = NULL;
    DWORD           retcode      = ERROR_SUCCESS;
    PortReceive32   *pReceive32  = (PortReceive32 *) pBuffer;

    //
    // Set up the thunk buffer
    //
    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 2 * sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->PortReceive.size = pReceive32->size;
    ((REQTYPECAST *)pThunkBuffer)->PortReceive.timeout = 
                                                    pReceive32->timeout;
    ((REQTYPECAST *)pThunkBuffer)->PortReceive.pid = pReceive32->pid;
    ((REQTYPECAST *)pThunkBuffer)->PortReceive.handle = 
                                        LongToHandle(pReceive32->handle);

    //
    // Make actual call
    // 
    PortReceiveRequest(ppcb, pThunkBuffer);

    //
    // Thunk back the results
    //
    
done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    
    // DbgPrint("retcode = %d\n", retcode);
    return;
}

typedef struct _PortDisconnect32
    {
        DWORD  handle ;
        DWORD  pid ;

    } PortDisconnect32 ;

VOID 
ThunkPortDisconnectRequest(
                                    pPCB ppcb, 
                                    BYTE *pBuffer, 
                                    DWORD dwBufSize)
{
    PBYTE             pThunkBuffer = NULL;
    DWORD             retcode      = ERROR_SUCCESS;
    PortDisconnect32 *pDisconnect  = (PortDisconnect32 *) pBuffer;

    //
    // Setup the thunk buffer
    //
    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->PortDisconnect.handle =
                                    LongToHandle(pDisconnect->handle);
    ((REQTYPECAST*)pThunkBuffer)->PortDisconnect.pid = pDisconnect->pid;                                    

    PortDisconnectRequest(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;
    
done:    
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;
    // DbgPrint("retcode = %d\n", retcode);
    return;
}

typedef struct _DeviceConnect32
    {
        CHAR    devicetype [MAX_DEVICETYPE_NAME] ;
        CHAR    devicename [MAX_DEVICE_NAME + 1] ;
        DWORD   timeout ;
        DWORD   handle ;
        DWORD   pid ;

    } DeviceConnect32 ;

VOID 
ThunkDeviceConnectRequest(
                            pPCB  ppcb, 
                            BYTE *pBuffer, 
                            DWORD dwBufSize)
{
    PBYTE           pThunkBuffer = NULL;
    DWORD           retcode      = ERROR_SUCCESS;
    DeviceConnect32 *pConnect32  = (DeviceConnect32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    memcpy(((REQTYPECAST *)pThunkBuffer)->DeviceConnect.devicetype,
            pConnect32->devicetype,
            MAX_DEVICETYPE_NAME + MAX_DEVICE_NAME + 1);

    ((REQTYPECAST *)pThunkBuffer)->DeviceConnect.timeout = 
                                        pConnect32->timeout;            
    ((REQTYPECAST *)pThunkBuffer)->DeviceConnect.handle =
                              LongToHandle(pConnect32->handle);
    ((REQTYPECAST *)pThunkBuffer)->DeviceConnect.pid =
                                        pConnect32->pid;

    DeviceConnectRequest(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;

    if(NULL == pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}


typedef struct  _RASMAN_INFO_32 {

    RASMAN_STATUS       RI_PortStatus ;

    RASMAN_STATE        RI_ConnState ;

    DWORD           RI_LinkSpeed ;

    DWORD           RI_LastError ;

    RASMAN_USAGE        RI_CurrentUsage ;

    CHAR            RI_DeviceTypeConnecting [MAX_DEVICETYPE_NAME] ;

    CHAR            RI_DeviceConnecting [MAX_DEVICE_NAME + 1] ;

    CHAR            RI_szDeviceType[MAX_DEVICETYPE_NAME];

    CHAR            RI_szDeviceName[MAX_DEVICE_NAME + 1];

    CHAR            RI_szPortName[MAX_PORT_NAME + 1];

    RASMAN_DISCONNECT_REASON    RI_DisconnectReason ;

    DWORD           RI_OwnershipFlag ;

    DWORD           RI_ConnectDuration ;

    DWORD           RI_BytesReceived ;

    //
    // If this port belongs to a connection, then
    // the following fields are filled in.
    //
    CHAR            RI_Phonebook[MAX_PATH+1];

    CHAR            RI_PhoneEntry[MAX_PHONEENTRY_SIZE+1];

    DWORD           RI_ConnectionHandle;

    DWORD           RI_SubEntry;

    RASDEVICETYPE   RI_rdtDeviceType;

    GUID            RI_GuidEntry;
    
    DWORD           RI_dwSessionId;

    DWORD           RI_dwFlags;

}RASMAN_INFO_32 ;

typedef struct _Info32
    {
        DWORD         retcode ;
        RASMAN_INFO_32   info ;

    } Info32 ;

VOID 
ThunkGetInfoRequest(
                            pPCB ppcb, 
                            BYTE *pBuffer, 
                            DWORD dwBufSize)
{
    PBYTE pThunkBuffer = NULL;
    DWORD retcode = ERROR_SUCCESS;
    Info32 *pInfo32 = (Info32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    GetInfoRequest(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Info.retcode;

    if(ERROR_SUCCESS != retcode)
    {
        goto done;
    }

    //
    // Copy over the buffer
    //
    CopyMemory(
        &pInfo32->info,
        &((REQTYPECAST *)pThunkBuffer)->Info.info,
        FIELD_OFFSET(RASMAN_INFO, RI_ConnectionHandle));

    pInfo32->info.RI_ConnectionHandle = 
            HandleToUlong(
            ((REQTYPECAST *)pThunkBuffer)->Info.info.RI_ConnectionHandle);
            
    CopyMemory(&pInfo32->info.RI_SubEntry,
               &((REQTYPECAST *)pThunkBuffer)->Info.info.RI_SubEntry,
               sizeof(RASMAN_INFO_32) - 
               FIELD_OFFSET(RASMAN_INFO_32, RI_SubEntry));

done:    

    pInfo32->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _ReqNotification32
    {
        DWORD        handle ;
        DWORD         pid ;

    } ReqNotification32 ;


VOID 
ThunkRequestNotificationRequest(
                                        pPCB ppcb, 
                                        BYTE *pBuffer, 
                                        DWORD dwBufSize)
{
    PBYTE               pThunkBuffer     = NULL;
    DWORD               retcode          = ERROR_SUCCESS;
    ReqNotification32  *pReqNotification = (ReqNotification32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->ReqNotification.pid = 
                                    pReqNotification->pid;
    ((REQTYPECAST *)pThunkBuffer)->ReqNotification.handle =
                            LongToHandle(pReqNotification->handle);

    RequestNotificationRequest(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *) pBuffer)->Generic.retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _PortBundle32
    {
        DWORD           porttobundle ;

    } PortBundle32 ;

VOID
ThunkPortBundle(
                pPCB ppcb, 
                BYTE *pBuffer, 
                DWORD dwBufSize)
{
    DWORD retcode      = ERROR_SUCCESS;
    PBYTE pThunkBuffer = NULL;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->PortBundle.porttobundle =
                    UlongToHandle(((PortBundle32 *) pBuffer)->porttobundle);

    PortBundle(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}


typedef struct _GetBundledPort32
    {
        DWORD       retcode ;
        DWORD       port ;

    } GetBundledPort32 ;
    
VOID 
ThunkGetBundledPort(
                    pPCB ppcb, 
                    BYTE *pBuffer, 
                    DWORD dwBufSize)
{
    DWORD   retcode      = ERROR_SUCCESS;
    PBYTE   pThunkBuffer = NULL;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    GetBundledPort(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *) pThunkBuffer)->GetBundledPort.retcode;

    ((GetBundledPort32 *)pBuffer)->port =
                HandleToUlong(
                    ((REQTYPECAST *) pThunkBuffer)->GetBundledPort.port);
done:
    ((GetBundledPort32 *)pBuffer)->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
                    
    return;
}

typedef struct _PortGetBundle32
    {
        DWORD       retcode ;
        DWORD       bundle ;

    } PortGetBundle32 ;

VOID
ThunkPortGetBundle(
                    pPCB ppcb, 
                    BYTE *pBuffer, 
                    DWORD dwBufSize)
{
    DWORD retcode      = ERROR_SUCCESS;
    PBYTE pThunkBuffer = NULL;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    PortGetBundle(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->PortGetBundle.retcode;

    ((PortGetBundle32 *)pBuffer)->bundle = 
        HandleToUlong(((REQTYPECAST *)pThunkBuffer)->PortGetBundle.bundle);

done:
    ((PortGetBundle32 *)pBuffer)->retcode = retcode;        

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _BundleGetPort32
    {
        DWORD   retcode;
        DWORD   bundle ;
        DWORD   port ;

    } BundleGetPort32 ;
VOID 
ThunkBundleGetPort(
                    pPCB ppcb, 
                    BYTE *pBuffer, 
                    DWORD dwBufSize)
{
    DWORD   retcode      = ERROR_SUCCESS;
    PBYTE   pThunkBuffer = NULL;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 2*sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->BundleGetPort.bundle =
                UlongToHandle(((BundleGetPort32 *)pBuffer)->bundle);

    BundleGetPort(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->BundleGetPort.retcode;
    ((BundleGetPort32 *)pBuffer)->port = HandleToUlong(
                ((REQTYPECAST *)pThunkBuffer)->BundleGetPort.port);

done:
    
    ((BundleGetPort32 *)pBuffer)->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _Connection32
    {
        DWORD   retcode;
        DWORD   pid;
        DWORD   conn;
        DWORD   dwEntryAlreadyConnected;
        DWORD   dwSubEntries;
        DWORD   dwDialMode;
        GUID    guidEntry;
        CHAR    szPhonebookPath[MAX_PATH];
        CHAR    szEntryName[MAX_ENTRYNAME_SIZE];
        CHAR    szRefPbkPath[MAX_PATH];
        CHAR    szRefEntryName[MAX_ENTRYNAME_SIZE];
        BYTE    data[1];

    } Connection32;

VOID 
ThunkCreateConnection(
                        pPCB ppcb, 
                        BYTE *pBuffer, 
                        DWORD dwBufSize)
{
    PBYTE           pThunkBuffer = NULL;
    DWORD           retcode      = ERROR_SUCCESS;
    Connection32    *pConnection = (Connection32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        pConnection->retcode = retcode;
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->Connection.pid = pConnection->pid;
    
    CopyMemory(
        &((REQTYPECAST *)pThunkBuffer)->Connection.dwEntryAlreadyConnected,
        &pConnection->dwEntryAlreadyConnected,
        sizeof(Connection32) - 
            FIELD_OFFSET(Connection32, dwEntryAlreadyConnected));

    CreateConnection(ppcb, pThunkBuffer);

    pConnection->conn = HandleToUlong(
                ((REQTYPECAST *)pThunkBuffer)->Connection.conn);
                
    pConnection->dwEntryAlreadyConnected = 
    ((REQTYPECAST *)pThunkBuffer)->Connection.dwEntryAlreadyConnected;

    CopyMemory(pConnection->data,
        ((REQTYPECAST *)pThunkBuffer)->Connection.data,
        pConnection->dwSubEntries * sizeof(DWORD));

    pConnection->retcode = ((REQTYPECAST *)pThunkBuffer)->Connection.retcode;

done:

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}



typedef struct _Enum32
    {
        DWORD   retcode ;
        DWORD   size ;
        DWORD   entries ;
        BYTE    buffer [1] ;

    } Enum32 ;

VOID 
ThunkEnumConnection(
                        pPCB ppcb,
                        BYTE *pBuffer,
                        DWORD dwBufSize)
{
    PBYTE   pThunkBuffer       = NULL;
    DWORD   retcode            = ERROR_SUCCESS;
    Enum32  *pEnum             = (Enum32 *) pBuffer;
    DWORD   i;
    DWORD   UNALIGNED *pConn32 = (DWORD *) pEnum->buffer;
    HCONN   UNALIGNED *pConn;
    DWORD   dwSizeNeeded;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + pEnum->size * 2);
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->Enum.size = pEnum->size * 2;
    ((REQTYPECAST *)pThunkBuffer)->Enum.entries = pEnum->entries;

    EnumConnection(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Enum.retcode;
    pEnum->entries = ((REQTYPECAST *)pThunkBuffer)->Enum.entries;
    dwSizeNeeded = pEnum->entries * sizeof(DWORD);
    
    if(      (ERROR_SUCCESS == retcode)
        &&   (pEnum->size >= dwSizeNeeded))
    {
        pConn = (HCONN *) ((REQTYPECAST *)pThunkBuffer)->Enum.buffer;
        for(i = 0; i < pEnum->entries; i++)
        {
            *pConn32 = HandleToUlong(*pConn);
            pConn32++;
            pConn++;
        }
    }

    pEnum->size = (WORD) dwSizeNeeded;


done:
    pEnum->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _AddConnectionPort32
    {
        DWORD   retcode;
        DWORD   conn;
        DWORD   dwSubEntry;

    } AddConnectionPort32;

VOID 
ThunkAddConnectionPort(
                            pPCB ppcb,
                            BYTE *pBuffer,
                            DWORD dwBufSize)
{
    DWORD                retcode      = ERROR_SUCCESS;
    PBYTE                pThunkBuffer = NULL;
    AddConnectionPort32 *pAdd32       = (AddConnectionPort32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->AddConnectionPort.conn = 
                                    UlongToHandle(pAdd32->conn);

    ((REQTYPECAST *)pThunkBuffer)->AddConnectionPort.dwSubEntry =
                                                pAdd32->dwSubEntry;

    AddConnectionPort(ppcb, pThunkBuffer);

    retcode = 
        ((REQTYPECAST *)pThunkBuffer)->AddConnectionPort.retcode;

done:

    pAdd32->retcode = retcode;
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _EnumConnectionPorts32
    {
        DWORD   retcode;
        DWORD   conn;
        DWORD   size;
        DWORD   entries;
        BYTE    buffer[1];

    } EnumConnectionPorts32;

VOID 
ThunkEnumConnectionPorts(
                            pPCB ppcb,
                            BYTE *pBuffer,
                            DWORD dwBufSize)
{
    DWORD                   retcode      = ERROR_SUCCESS;
    PBYTE                   pThunkBuffer = NULL;
    EnumConnectionPorts32   *pEnum32 = (EnumConnectionPorts32 *)pBuffer;
    
    DWORD dwextrabytes = 
        (sizeof(RASMAN_PORT) - sizeof(RASMAN_PORT_32)) 
        * (pEnum32->size/sizeof(RASMAN_PORT_32));
        
    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + dwextrabytes);
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->EnumConnectionPorts.conn =
                                UlongToHandle(pEnum32->conn);
    ((REQTYPECAST *)pThunkBuffer)->EnumConnectionPorts.size = 
                                (pEnum32->size + dwextrabytes);
                    
    ((REQTYPECAST *)pThunkBuffer)->EnumConnectionPorts.entries = 
                                                    pEnum32->entries;

    EnumConnectionPorts(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->EnumConnectionPorts.retcode;

    pEnum32->entries = 
        ((REQTYPECAST *)pThunkBuffer)->EnumConnectionPorts.entries;


    if(     (retcode == ERROR_SUCCESS)
        &&  (pEnum32->size >= pEnum32->entries * sizeof(RASMAN_PORT_32)))
    {
        DWORD           i;
        RASMAN_PORT_32  *pPort32;
        RASMAN_PORT     *pPort;

        pPort32 = (RASMAN_PORT_32 *) pEnum32->buffer;
        pPort = (RASMAN_PORT *) 
            ((REQTYPECAST *)pThunkBuffer)->EnumConnectionPorts.buffer;
            
        for(i = 0; i < pEnum32->entries; i++)
        {
            pPort32->P_Port = HandleToUlong(pPort->P_Handle);

            CopyMemory(
                pPort32->P_PortName,
                pPort->P_PortName,
                sizeof(RASMAN_PORT) - sizeof(HPORT));

            pPort32 ++;
            pPort ++;
        }
    }

    pEnum32->size = pEnum32->entries * sizeof(RASMAN_PORT_32);
    
done:
    pEnum32->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _ConnectionParams32
    {
        DWORD                retcode;
        DWORD                conn;
        RAS_CONNECTIONPARAMS params;
    } ConnectionParams32;
    
VOID
ThunkGetConnectionParams(
                                pPCB ppcb,
                                BYTE *pBuffer,
                                DWORD dwBufSize)
{
    DWORD retcode      = ERROR_SUCCESS;
    PBYTE pThunkBuffer = NULL;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->ConnectionParams.conn =
        UlongToHandle(((ConnectionParams32 *)pBuffer)->conn);

    GetConnectionParams(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->ConnectionParams.retcode;
    if(ERROR_SUCCESS == retcode)
    {
        CopyMemory(&((ConnectionParams32 *)pBuffer)->params,
            &((REQTYPECAST *)pThunkBuffer)->ConnectionParams.params,
            sizeof(RAS_CONNECTIONPARAMS));
    }

done:

    ((ConnectionParams32 *)pBuffer)->retcode = retcode;

    if(NULL != pThunkBuffer)
    {   
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

VOID
ThunkSetConnectionParams(
                                pPCB ppcb,
                                BYTE *pBuffer,
                                DWORD dwBufSize)
{
    DWORD retcode      = ERROR_SUCCESS;
    PBYTE pThunkBuffer = NULL;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->ConnectionParams.conn =
                UlongToHandle(((ConnectionParams32 *)pBuffer)->conn);
    CopyMemory(
        &((REQTYPECAST *)pThunkBuffer)->ConnectionParams.params,
        &((ConnectionParams32 *)pBuffer)->params,
        sizeof(RAS_CONNECTIONPARAMS));

    SetConnectionParams(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->ConnectionParams.retcode;

done:
    ((ConnectionParams32 *)pBuffer)->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _PPP_LCP_RESULT_32
{
    /* Valid handle indicates one of the possibly multiple connections to
    ** which this connection is bundled. INVALID_HANDLE_VALUE indicates the
    ** connection is not bundled.
    */
    DWORD hportBundleMember;

    DWORD dwLocalAuthProtocol;
    DWORD dwLocalAuthProtocolData;
    DWORD dwLocalEapTypeId;
    DWORD dwLocalFramingType;
    DWORD dwLocalOptions;               // Look at PPPLCPO_*
    DWORD dwRemoteAuthProtocol;
    DWORD dwRemoteAuthProtocolData;
    DWORD dwRemoteEapTypeId;
    DWORD dwRemoteFramingType;
    DWORD dwRemoteOptions;              // Look at PPPLCPO_*
    DWORD szReplyMessage;
}
PPP_LCP_RESULT_32;

typedef struct _PPP_PROJECTION_RESULT_32
{
    PPP_NBFCP_RESULT    nbf;
    PPP_IPCP_RESULT     ip;
    PPP_IPXCP_RESULT    ipx;
    PPP_ATCP_RESULT     at;
    PPP_CCP_RESULT      ccp;
    PPP_LCP_RESULT_32   lcp;
}
PPP_PROJECTION_RESULT_32;

typedef struct ConnectionUserData32
    {
        DWORD   retcode;
        DWORD   conn;
        DWORD   dwTag;
        DWORD   dwcb;
        BYTE    data[1];

    } ConnectionUserData32;

VOID 
ThunkGetConnectionUserData(
                                pPCB ppcb,
                                BYTE *pBuffer,
                                DWORD dwBufSize)
{
    DWORD                       retcode      = ERROR_SUCCESS;
    PBYTE                       pThunkBuffer = NULL;
    ConnectionUserData32        *pData       = (ConnectionUserData32 *)
                                               pBuffer;
    PPP_LCP_RESULT_32 UNALIGNED *plcp;
    
    DWORD dwExtraBytes = sizeof(PPP_PROJECTION_RESULT) 
                       - sizeof(PPP_PROJECTION_RESULT_32);

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + dwExtraBytes);
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.dwTag = pData->dwTag;
    ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.conn =
                                        UlongToHandle(pData->conn);
                                        
    ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.dwcb = pData->dwcb;

    if(     (pData->dwTag == CONNECTION_PPPRESULT_INDEX)
        &&  (0 != pData->dwcb))
    {
        //
        // Thunk the ppp_result_index which is the only
        // connection data that is required to be thunked.
        // LCP_RESULT on 64bits is 4bytes more than on 32bit
        //
        ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.dwcb = 
                                        pData->dwcb + dwExtraBytes;
    }

    GetConnectionUserData(ppcb, pThunkBuffer);

    pData->dwcb = ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.dwcb;

    retcode = ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.retcode;

    if(pData->dwTag == CONNECTION_PPPRESULT_INDEX)
    {
        if(0 != pData->dwcb)
        {
            PPP_LCP_RESULT *plcp64;
            
            pData->dwcb = ((REQTYPECAST *)pThunkBuffer
                            )->ConnectionUserData.dwcb - dwExtraBytes;

            CopyMemory(pData->data,
                ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.data,
                FIELD_OFFSET(PPP_PROJECTION_RESULT, lcp));

            plcp = (PPP_LCP_RESULT_32 *) (pData->data + 
                       FIELD_OFFSET(PPP_PROJECTION_RESULT_32, lcp));

            plcp64 = (PPP_LCP_RESULT *)((BYTE *)
                ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.data + 
                             FIELD_OFFSET(PPP_PROJECTION_RESULT, lcp));
                             
            plcp->hportBundleMember = HandleToUlong(
                                plcp64->hportBundleMember);

            //
            // Subtract the 4 bytes each for hPortbundlemember 
            // and szReplymessage fields.
            //
            CopyMemory(&plcp->dwLocalAuthProtocol,
                       &plcp64->dwLocalAuthProtocol,
                       sizeof(PPP_LCP_RESULT) - 2 * sizeof(ULONG_PTR));
        }                   
                    
    }
    else
    {
        if(ERROR_SUCCESS == retcode)
        {
            CopyMemory(pData->data,
                ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.data,
                pData->dwcb);
        }
    }

done:
    pData->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }

    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

VOID 
ThunkSetConnectionUserData(
                                pPCB ppcb,
                                BYTE *pBuffer,
                                DWORD dwBufSize)
{   
    DWORD                retcode = ERROR_SUCCESS;
    PBYTE                   pThunkBuffer = NULL;
    ConnectionUserData32 *pData = (ConnectionUserData32 *)pBuffer;
    DWORD dwExtraBytes = sizeof(PPP_PROJECTION_RESULT)
                       - sizeof(PPP_PROJECTION_RESULT_32);
                        

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + dwExtraBytes);
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.dwTag = pData->dwTag;
    ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.conn =
                                        UlongToHandle(pData->conn);
    ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.dwcb = pData->dwcb;

    if(pData->dwTag == CONNECTION_PPPRESULT_INDEX)
    {
        PPP_LCP_RESULT_32 UNALIGNED * plcp = 
                    &((PPP_PROJECTION_RESULT_32 *) pData->data)->lcp;
                    
        PBYTE pdata = ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.data;

        PPP_LCP_RESULT *plcp64 = &((PPP_PROJECTION_RESULT *) pdata)->lcp;
                    
        CopyMemory(((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.data,
                    pData->data,
                    FIELD_OFFSET(PPP_PROJECTION_RESULT, lcp));

        plcp64->hportBundleMember = UlongToHandle(plcp->hportBundleMember);

        CopyMemory(&plcp64->dwLocalAuthProtocol,
                   &plcp->dwLocalAuthProtocol,
                   sizeof(PPP_LCP_RESULT) - sizeof(ULONG_PTR));

        ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.dwcb += 
                                                        dwExtraBytes;
                                
    }
    else
    {
        CopyMemory(((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.data,
                    pData->data,
                    pData->dwcb);
    }                

    SetConnectionUserData(ppcb, pThunkBuffer);                

    retcode = ((REQTYPECAST *)pThunkBuffer)->ConnectionUserData.retcode;                

done:
    pData->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _PPP_INTERFACE_INFO_32
{
    ROUTER_INTERFACE_TYPE   IfType;
    DWORD                  hIPInterface;
    DWORD                  hIPXInterface;
    CHAR                   szzParameters[PARAMETERBUFLEN];
} PPP_INTERFACE_INFO_32;

typedef struct _PPP_EAP_UI_DATA_32
{
    DWORD               dwContextId;
    DWORD               pEapUIData;
    DWORD               dwSizeOfEapUIData;
}
PPP_EAP_UI_DATA_32;


typedef struct _PPP_START_32
{
    CHAR                    szPortName[ MAX_PORT_NAME +1 ];
    CHAR                    szUserName[ UNLEN + 1 ];
    CHAR                    szPassword[ PWLEN + 1 ];
    CHAR                    szDomain[ DNLEN + 1 ];
    LUID                    Luid;
    PPP_CONFIG_INFO         ConfigInfo;
    CHAR                    szzParameters[ PARAMETERBUFLEN ];
    BOOL                    fThisIsACallback;
    BOOL                    fRedialOnLinkFailure;
    DWORD                   hEvent;
    DWORD                   dwPid;
    PPP_INTERFACE_INFO_32   PppInterfaceInfo;
    DWORD                   dwAutoDisconnectTime;
    PPP_BAPPARAMS           BapParams;    
    DWORD                   pszPhonebookPath;
    DWORD                   pszEntryName;
    DWORD                   pszPhoneNumber;
    DWORD                   hToken;
    DWORD                   pCustomAuthConnData;
    DWORD                   dwEapTypeId;
    BOOL                    fLogon;
    BOOL                    fNonInteractive;
    DWORD                   dwFlags;
    DWORD                   pCustomAuthUserData;
    PPP_EAP_UI_DATA_32      EapUIData;
    CHAR                    chSeed;
}
PPP_START_32;

typedef struct _PPPE_MESSAGE_32
{
    DWORD   dwMsgId;
    DWORD   hPort;
    DWORD   hConnection;

    union
    {
        PPP_START_32        Start;              // PPPEMSG_Start
        PPP_STOP            Stop;               // PPPEMSG_Stop
        PPP_CALLBACK        Callback;           // PPPEMSG_Callback
        PPP_CHANGEPW        ChangePw;           // PPPEMSG_ChangePw
        PPP_RETRY           Retry;              // PPPEMSG_Retry
        PPP_RECEIVE         Receive;            // PPPEMSG_Receive
        PPP_BAP_EVENT       BapEvent;           // PPPEMSG_BapEvent
        PPPDDM_START        DdmStart;           // PPPEMSG_DdmStart
        PPP_CALLBACK_DONE   CallbackDone;       // PPPEMSG_DdmCallbackDone
        PPP_INTERFACE_INFO  InterfaceInfo;      // PPPEMSG_DdmInterfaceInfo
        PPP_BAP_CALLBACK_RESULT 
                            BapCallbackResult;  // PPPEMSG_DdmBapCallbackResult
        PPP_DHCP_INFORM     DhcpInform;         // PPPEMSG_DhcpInform
        PPP_EAP_UI_DATA     EapUIData;          // PPPEMSG_EapUIData
        PPP_PROTOCOL_EVENT  ProtocolEvent;      // PPPEMSG_ProtocolEvent
        PPP_IP_ADDRESS_LEASE_EXPIRED            // PPPEMSG_IpAddressLeaseExpired
                            IpAddressLeaseExpired;
		PPP_POST_LINE_DOWN		PostLineDown;		//PPPEMSG_PostLineDown
                            
    }
    ExtraInfo;
}
PPPE_MESSAGE_32;

VOID
ThunkPppStop(
            pPCB ppcb, 
            BYTE *pBuffer, 
            DWORD dwBufSize)
{
    DWORD               retcode = ERROR_SUCCESS;
    PBYTE               pThunkBuffer = NULL;
    PPPE_MESSAGE_32     *pMsg   = (PPPE_MESSAGE_32 *)pBuffer;
    PPP_STOP UNALIGNED  *pStop  = (PPP_STOP *) 
                            (pBuffer + 3 * sizeof(DWORD));

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(PPPE_MESSAGE));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.dwMsgId = pMsg->dwMsgId;
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hPort = 
                                        UlongToHandle(pMsg->hPort);
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hConnection =
                                        UlongToHandle(pMsg->hConnection);

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Stop.dwStopReason =
                                                    pStop->dwStopReason;
#if 0    
    CopyMemory(&((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Stop,
                &pMsg->ExtraInfo.Stop,
                sizeof(PPP_STOP));
#endif                

    PppStop(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

VOID
ThunkPppStart(
                pPCB  ppcb,
                BYTE  *pBuffer,
                DWORD dwBufSize)
{   
    DWORD                   retcode = ERROR_SUCCESS;
    PBYTE                   pThunkBuffer = NULL;
    PPPE_MESSAGE_32         *pMsg = (PPPE_MESSAGE_32 *) pBuffer;
    PPP_START_32 UNALIGNED  *pStart = (PPP_START_32 *) 
                            (pBuffer + 3 * sizeof(DWORD));

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 3 * sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.dwMsgId = pMsg->dwMsgId;
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hPort = 
                                        UlongToHandle(pMsg->hPort);
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hConnection =
                                        UlongToHandle(pMsg->hConnection);

    // DbgPrint("Copying to %p from %p\n",
    // ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.szPortName,
    // pStart);
    
    CopyMemory(
        ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.szPortName,
         pStart,
         FIELD_OFFSET(PPP_START, hEvent));
               
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.hEvent =
                                                LongToHandle(pStart->hEvent);

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.dwPid =
                                        pStart->dwPid;

    ((REQTYPECAST *)pThunkBuffer)->
    PppEMsg.ExtraInfo.Start.dwAutoDisconnectTime =
                        pStart->dwAutoDisconnectTime;

    CopyMemory(
    &((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.BapParams,
    &pStart->BapParams,
    sizeof(PPP_BAPPARAMS));

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.dwEapTypeId =
                                    pStart->dwEapTypeId;

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.fLogon =
                                    pStart->fLogon;

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.fNonInteractive =
                                        pStart->fNonInteractive;

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.dwFlags =
                                        pStart->dwFlags;
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Start.chSeed =
                                        pStart->chSeed;

    PppStart(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

VOID
ThunkPppRetry(
                pPCB ppcb, 
                BYTE *pBuffer, 
                DWORD dwBufSize)
{
    DWORD                   retcode      = ERROR_SUCCESS;
    PBYTE                   pThunkBuffer = NULL;
    PPPE_MESSAGE_32         *pMsg        = (PPPE_MESSAGE_32 *)pBuffer;
    PPP_RETRY UNALIGNED     *pRetry      = (PPP_RETRY *) 
                            (pBuffer + 3 * sizeof(DWORD));

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 3*sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.dwMsgId = pMsg->dwMsgId;
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hPort = 
                                        UlongToHandle(pMsg->hPort);
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hConnection =
                                        UlongToHandle(pMsg->hConnection);
    CopyMemory(
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Retry.szUserName,
    pRetry,
    sizeof(PPP_RETRY));

    PppRetry(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}


typedef struct _PPP_MESSAGE_32
{
    DWORD                   Next;
    DWORD                   dwError;
    PPP_MSG_ID              dwMsgId;
    DWORD                   hPort;

    union
    {
        /* dwMsgId is PPPMSG_ProjectionResult or PPPDDMMSG_Done.
        */
        PPP_PROJECTION_RESULT_32 ProjectionResult;

        /* dwMsgId is PPPMSG_Failure.
        */
        PPP_FAILURE Failure;

        /*
        */
        PPP_STOPPED Stopped;

        /* dwMsgId is PPPMSG_InvokeEapUI         
        */
        PPP_INVOKE_EAP_UI InvokeEapUI;

        /* dwMsgId is PPPMSG_SetCustomAuthData         
        */
        PPP_SET_CUSTOM_AUTH_DATA SetCustomAuthData;

        /* dwMsgId is PPPDDMMSG_Failure.
        */
        PPPDDM_FAILURE DdmFailure;

        /* dwMsgId is PPPDDMMSG_Authenticated.
        */
        PPPDDM_AUTH_RESULT AuthResult;

        /* dwMsgId is PPPDDMMSG_CallbackRequest.
        */
        PPPDDM_CALLBACK_REQUEST CallbackRequest;

        /* dwMsgId is PPPDDMMSG_BapCallbackRequest.
        */
        PPPDDM_BAP_CALLBACK_REQUEST BapCallbackRequest;

        /* dwMsgId is PPPDDMMSG_NewBapLinkUp         
        */
        PPPDDM_NEW_BAP_LINKUP BapNewLinkUp;

        /* dwMsgId is PPPDDMMSG_NewBundle   
        */
        PPPDDM_NEW_BUNDLE DdmNewBundle;

        /* dwMsgId is PPPDDMMSG_PnPNotification   
        */
        PPPDDM_PNP_NOTIFICATION DdmPnPNotification;

        /* dwMsgId is PPPDDMMSG_Stopped   
        */
        PPPDDM_STOPPED DdmStopped;
    }
    ExtraInfo;
}
PPP_MESSAGE_32;

VOID
ThunkPppGetInfo(
                pPCB ppcb,
                BYTE *pBuffer,
                DWORD dwBufSize)
{
    DWORD           retcode      = ERROR_SUCCESS;
    PBYTE           pThunkBuffer = NULL;
    PPP_MESSAGE_32 *pMsg         = (PPP_MESSAGE_32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    PppGetInfo(ppcb, pThunkBuffer);

    pMsg->dwMsgId = ((REQTYPECAST *)pThunkBuffer)->PppMsg.dwMsgId;
    pMsg->dwError = ((REQTYPECAST *)pThunkBuffer)->PppMsg.dwError;
    pMsg->hPort = HandleToUlong(((REQTYPECAST *)pThunkBuffer)->PppMsg.hPort);

    CopyMemory(&pMsg->ExtraInfo.ProjectionResult,
        &((REQTYPECAST *)pThunkBuffer)->PppMsg.ExtraInfo.ProjectionResult,
        FIELD_OFFSET(PPP_PROJECTION_RESULT, lcp));

    pMsg->ExtraInfo.ProjectionResult.lcp.hportBundleMember = 
    HandleToUlong(((REQTYPECAST *)
    pThunkBuffer)->PppMsg.ExtraInfo.ProjectionResult.lcp.hportBundleMember);

    CopyMemory(
    &pMsg->ExtraInfo.ProjectionResult.lcp.dwLocalAuthProtocol,
    &((REQTYPECAST *)
    pThunkBuffer)->PppMsg.ExtraInfo.ProjectionResult.lcp.dwLocalAuthProtocol,
    sizeof(PPP_LCP_RESULT) - 2 * sizeof(ULONG_PTR));

done:
    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

VOID 
ThunkPppChangePwd(
                    pPCB ppcb,
                    BYTE *pBuffer,
                    DWORD dwBufSize)
{
    DWORD               retcode      = ERROR_SUCCESS;
    PBYTE               pThunkBuffer = NULL;
    PPPE_MESSAGE_32     *pMsg        = (PPPE_MESSAGE_32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 3 * sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.dwMsgId = pMsg->dwMsgId;
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hPort = 
                                        UlongToHandle(pMsg->hPort);
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hConnection =
                                        UlongToHandle(pMsg->hConnection);
    CopyMemory(
    &((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.ChangePw,
    &pMsg->ExtraInfo.ChangePw,
    sizeof(PPP_CHANGEPW));

    PppChangePwd(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

VOID
ThunkPppCallback(
                    pPCB ppcb,
                    BYTE *pBuffer,
                    DWORD dwBufSize)
{
    DWORD           retcode      = ERROR_SUCCESS;
    PBYTE           pThunkBuffer = NULL;
    PPPE_MESSAGE_32 *pMsg        = (PPPE_MESSAGE_32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 3 * sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.dwMsgId = pMsg->dwMsgId;
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hPort = 
                                        UlongToHandle(pMsg->hPort);
    ((REQTYPECAST *)pThunkBuffer)->PppEMsg.hConnection =
                                        UlongToHandle(pMsg->hConnection);
    CopyMemory(
    &((REQTYPECAST *)pThunkBuffer)->PppEMsg.ExtraInfo.Callback,
    &pMsg->ExtraInfo.Callback,
    sizeof(PPP_CALLBACK));

    PppCallback(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef  struct _AddNotification32
    {
        DWORD   retcode;
        DWORD   pid;
        BOOL    fAny;
        DWORD   hconn;
        DWORD   hevent;
        DWORD   dwfFlags;

    } AddNotification32;

VOID
ThunkAddNotification(
                    pPCB ppcb,
                    BYTE *pBuffer,
                    DWORD dwBufSize)
{
    DWORD               retcode      = ERROR_SUCCESS;
    PBYTE               pThunkBuffer = NULL;
    AddNotification32   *pNotif      = (AddNotification32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 2 * sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->AddNotification.pid = pNotif->pid;
    ((REQTYPECAST *)pThunkBuffer)->AddNotification.fAny = pNotif->fAny;
    ((REQTYPECAST *)pThunkBuffer)->AddNotification.dwfFlags = 
                                                pNotif->dwfFlags;
    ((REQTYPECAST *)pThunkBuffer)->AddNotification.hconn =
                                    UlongToHandle(pNotif->hconn);
    ((REQTYPECAST *)pThunkBuffer)->AddNotification.hevent =
                                    LongToHandle(pNotif->hevent);

    AddNotification(ppcb, pThunkBuffer);                                    

    retcode = ((REQTYPECAST *)pThunkBuffer)->AddNotification.retcode;

done:
    pNotif->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _SignalConnection32
    {
        DWORD   retcode;
        DWORD   hconn;

    } SignalConnection32;

VOID
ThunkSignalConnection(
                        pPCB ppcb, 
                        BYTE *pBuffer, 
                        DWORD dwBufSize)
{   
    DWORD               retcode      = ERROR_SUCCESS;
    PBYTE               pThunkBuffer = NULL;
    SignalConnection32 *pSignal      = (SignalConnection32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->SignalConnection.hconn =
                                UlongToHandle(pSignal->hconn);

    SignalConnection(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->SignalConnection.retcode;

done:
    pSignal->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _SetIoCompletionPortInfo32
    {
        LONG          hIoCompletionPort;
        DWORD         pid;
        LONG          lpOvDrop;
        LONG          lpOvStateChange;
        LONG          lpOvPpp;
        LONG          lpOvLast;

    } SetIoCompletionPortInfo32;


VOID 
ThunkSetIoCompletionPort(
                            pPCB ppcb,
                            BYTE *pBuffer,
                            DWORD dwBufSize)
{
    DWORD                       retcode = ERROR_SUCCESS;
    PBYTE                       pThunkBuffer = NULL;
    SetIoCompletionPortInfo32   *pInfo = 
                (SetIoCompletionPortInfo32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 5 * sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->SetIoCompletionPortInfo.pid = pInfo->pid;
    ((REQTYPECAST *)pThunkBuffer)->SetIoCompletionPortInfo.lpOvDrop =
                                    LongToHandle(pInfo->lpOvDrop);
    ((REQTYPECAST *)pThunkBuffer)->SetIoCompletionPortInfo.lpOvStateChange =
                                    LongToHandle(pInfo->lpOvStateChange);
    ((REQTYPECAST *)pThunkBuffer)->SetIoCompletionPortInfo.lpOvPpp =
                                    LongToHandle(pInfo->lpOvPpp);
    ((REQTYPECAST *)pThunkBuffer)->SetIoCompletionPortInfo.lpOvLast =
                                    LongToHandle(pInfo->lpOvLast);

    ((REQTYPECAST *)pThunkBuffer)->SetIoCompletionPortInfo.hIoCompletionPort =
                                    LongToHandle(pInfo->hIoCompletionPort);

    SetIoCompletionPort(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;
    
    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _FindRefConnection32
    {
        DWORD           retcode;
        DWORD           hConn;
        DWORD           hRefConn;
    } FindRefConnection32;
    
VOID
ThunkFindPrerequisiteEntry(
                            pPCB ppcb, 
                            BYTE *pBuffer, 
                            DWORD dwBufSize)
{
    DWORD               retcode      = ERROR_SUCCESS;
    PBYTE               pThunkBuffer = NULL;
    FindRefConnection32 *pRef        = (FindRefConnection32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 2 * sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->FindRefConnection.hConn =
                                        UlongToHandle(pRef->hConn);

    FindPrerequisiteEntry(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->FindRefConnection.retcode;

    pRef->hRefConn = HandleToUlong(((REQTYPECAST *)
                pThunkBuffer)->FindRefConnection.hRefConn);

done:
    pRef->retcode = retcode;
    if(NULL != pThunkBuffer)
    {   
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _PortOpenEx32
    {
        DWORD           retcode;
        DWORD           pid;
        DWORD           dwFlags;
        DWORD           hport;
        DWORD           dwOpen;
        DWORD           hnotifier;
        DWORD           dwDeviceLineCounter;
        CHAR            szDeviceName[MAX_DEVICE_NAME + 1];
    } PortOpenEx32;

VOID
ThunkPortOpenEx(
                    pPCB ppcb,
                    BYTE *pBuffer,
                    DWORD dwBufSize)
{
    DWORD           retcode      = ERROR_SUCCESS;
    PBYTE           pThunkBuffer = NULL;
    PortOpenEx32    *pOpen       = (PortOpenEx32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 2*sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *) pThunkBuffer)->PortOpenEx.pid      = pOpen->pid;
    ((REQTYPECAST *) pThunkBuffer)->PortOpenEx.dwFlags  = pOpen->dwFlags;
    ((REQTYPECAST *) pThunkBuffer)->PortOpenEx.dwOpen   = pOpen->dwOpen;
    ((REQTYPECAST *) pThunkBuffer)->PortOpenEx.hnotifier =
                                LongToHandle(pOpen->hnotifier);
    ((REQTYPECAST *) pThunkBuffer)->PortOpenEx.dwDeviceLineCounter =
                                                pOpen->dwDeviceLineCounter;
    CopyMemory(((REQTYPECAST *) pThunkBuffer)->PortOpenEx.szDeviceName,
                pOpen->szDeviceName,
                MAX_DEVICE_NAME + 1);
                
    PortOpenEx(ppcb, pThunkBuffer);

    pOpen->hport = HandleToUlong(((REQTYPECAST *)
                    pThunkBuffer)->PortOpenEx.hport);
    retcode = ((REQTYPECAST *)pThunkBuffer)->PortOpenEx.retcode;

done:
    pOpen->retcode = retcode;
    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef    struct _GetStats32
    {
        DWORD           retcode;
        DWORD           hConn;
        DWORD           dwSubEntry;
        BYTE            abStats[1];
    } GetStats32;

VOID
ThunkGetLinkStats(
                pPCB ppcb,
                BYTE *pBuffer,
                DWORD dwBufSize)
{   
    DWORD       retcode      = ERROR_SUCCESS;
    PBYTE       pThunkBuffer = NULL;
    GetStats32 *pStats       = (GetStats32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->GetStats.hConn = 
                            UlongToHandle(pStats->hConn);

    ((REQTYPECAST *)pThunkBuffer)->GetStats.dwSubEntry = 
                                    pStats->dwSubEntry;

    GetLinkStats(ppcb, pThunkBuffer);

    pStats->retcode = retcode;
    CopyMemory(pStats->abStats,
               ((REQTYPECAST *)pThunkBuffer)->GetStats.abStats,
               MAX_STATISTICS_EX * sizeof(DWORD));

done:
    pStats->retcode = retcode;
    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

VOID
ThunkGetConnectionStats(
                            pPCB ppcb, 
                            BYTE *pBuffer, 
                            DWORD dwBufSize)
{
    DWORD       retcode      = ERROR_SUCCESS;
    PBYTE       pThunkBuffer = NULL;
    GetStats32 *pStats       = (GetStats32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->GetStats.hConn =
                        UlongToHandle(pStats->hConn);
    ((REQTYPECAST *)pThunkBuffer)->GetStats.dwSubEntry =
                            pStats->dwSubEntry;

    GetConnectionStats(ppcb, pThunkBuffer);
    
    pStats->retcode = ((REQTYPECAST *)pThunkBuffer)->GetStats.retcode;

    CopyMemory(pStats->abStats,
            ((REQTYPECAST *)pThunkBuffer)->GetStats.abStats,
            MAX_STATISTICS * sizeof(DWORD));

done:
    pStats->retcode = retcode;
    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);

    return;
}

typedef struct _GetHportFromConnection32
    {
        DWORD           retcode;
        DWORD           hConn;
        DWORD           hPort;
    } GetHportFromConnection32;
    
VOID
ThunkGetHportFromConnection(
                                    pPCB ppcb,
                                    BYTE *pBuffer,
                                    DWORD dwBufSize)
{
    DWORD                     retcode       = ERROR_SUCCESS;
    PBYTE                     pThunkBuffer  = NULL;
    GetHportFromConnection32 *pConnection   = 
                (GetHportFromConnection32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + 2 * sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->GetHportFromConnection.hConn =
                              UlongToHandle(pConnection->hConn);

    GetHportFromConnection(ppcb, pThunkBuffer);

    pConnection->hPort = HandleToUlong(
        ((REQTYPECAST *)pThunkBuffer)->GetHportFromConnection.hPort);

    retcode = ((REQTYPECAST *)pThunkBuffer)->GetHportFromConnection.retcode;

done:
    pConnection->retcode = retcode;
    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }    
    // DbgPrint("retcode = %d\n", retcode);
                        
    return;
}

typedef struct _ReferenceCustomCount32
    {
        DWORD           retcode;
        BOOL            fAddRef;
        DWORD           hConn;
        DWORD           dwCount;
        CHAR            szEntryName[MAX_ENTRYNAME_SIZE + 1];
        CHAR            szPhonebookPath[MAX_PATH + 1];
    } ReferenceCustomCount32;

VOID
ThunkReferenceCustomCount(
                                pPCB ppcb, 
                                BYTE *pBuffer, 
                                DWORD dwBufSize)
{
    DWORD                   retcode      = ERROR_SUCCESS;
    PBYTE                   pThunkBuffer = NULL;
    ReferenceCustomCount32 *pRef         = (ReferenceCustomCount32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->ReferenceCustomCount.hConn =
                        UlongToHandle(pRef->hConn);

    ((REQTYPECAST *)pThunkBuffer)->ReferenceCustomCount.fAddRef =
                                            pRef->fAddRef;
    ((REQTYPECAST *)pThunkBuffer)->ReferenceCustomCount.dwCount =
                                        pRef->dwCount;    

    if(pRef->fAddRef)
    {
        CopyMemory(
        &((REQTYPECAST *)pThunkBuffer)->ReferenceCustomCount.szEntryName,
        &pRef->szEntryName,
        MAX_ENTRYNAME_SIZE + MAX_PATH + 2);
    }    

    ReferenceCustomCount(ppcb, pThunkBuffer);

    if(!pRef->fAddRef)
    {
        strcpy(pRef->szEntryName,
        ((REQTYPECAST *)pThunkBuffer)->ReferenceCustomCount.szEntryName);

        strcpy(pRef->szPhonebookPath,
        ((REQTYPECAST *)pThunkBuffer)->ReferenceCustomCount.szPhonebookPath);

        pRef->dwCount = 
            ((REQTYPECAST *) pThunkBuffer)->ReferenceCustomCount.dwCount;
    }
    
    retcode = ((REQTYPECAST *)pThunkBuffer)->ReferenceCustomCount.retcode;

done:
    pRef->retcode = retcode;
    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _HconnFromEntry32
    {
        DWORD           retcode;
        DWORD           hConn;
        CHAR            szEntryName[MAX_ENTRYNAME_SIZE + 1];
        CHAR            szPhonebookPath[MAX_PATH + 1];
    } HconnFromEntry32;

VOID
ThunkGetHconnFromEntry(
                            pPCB ppcb, 
                            BYTE *pBuffer, 
                            DWORD dwBufSize)
{
    DWORD               retcode      = ERROR_SUCCESS;
    PBYTE               pThunkBuffer = NULL;
    HconnFromEntry32    *pConn       = (HconnFromEntry32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    CopyMemory(
    ((REQTYPECAST *)pThunkBuffer)->HconnFromEntry.szEntryName,
    pConn->szEntryName,
    MAX_ENTRYNAME_SIZE + MAX_PATH + 2);

    GetHconnFromEntry(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->HconnFromEntry.retcode;

    pConn->hConn = HandleToUlong(
                ((REQTYPECAST *)pThunkBuffer)->HconnFromEntry.hConn);

done:
    pConn->retcode = retcode;
    if(NULL == pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _RASEVENT32
{
    RASEVENTTYPE    Type;

    union
    {
    // ENTRY_ADDED,
    // ENTRY_MODIFIED,
    // ENTRY_CONNECTED
    // ENTRY_CONNECTING
    // ENTRY_DISCONNECTING
    // ENTRY_DISCONNECTED
        struct
        {
            RASENUMENTRYDETAILS     Details;
        };

    // ENTRY_DELETED,
    // INCOMING_CONNECTED,
    // INCOMING_DISCONNECTED,
    // ENTRY_BANDWIDTH_ADDED
    // ENTRY_BANDWIDTH_REMOVED
    //  guidId is valid

    // ENTRY_RENAMED
    // ENTRY_AUTODIAL,
        struct
        {
            DWORD  hConnection;
            RASDEVICETYPE rDeviceType;
            GUID    guidId;
            WCHAR   pszwNewName [RASAPIP_MAX_ENTRY_NAME + 1];
        };

    // SERVICE_EVENT,
        struct
        {
            SERVICEEVENTTYPE    Event;
            RASSERVICE          Service;
        };

        // DEVICE_ADDED
        // DEVICE_REMOVED
        RASDEVICETYPE DeviceType;
    };
} RASEVENT32;

typedef    struct _SendNotification32
    {
        DWORD           retcode;
        RASEVENT32      RasEvent;
    } SendNotification32;

VOID
ThunkSendNotificationRequest(
                                    pPCB ppcb,
                                    BYTE *pBuffer,
                                    DWORD dwBufSize)
{
    DWORD               retcode      = ERROR_SUCCESS;
    PBYTE               pThunkBuffer = NULL;
    SendNotification32 *pNotif       = (SendNotification32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    if(     (pNotif->RasEvent.Type != ENTRY_RENAMED)
        &&  (pNotif->RasEvent.Type != ENTRY_AUTODIAL)
        &&  (pNotif->RasEvent.Type != ENTRY_CONNECTED)
        &&  (pNotif->RasEvent.Type != ENTRY_DISCONNECTED)
        &&  (pNotif->RasEvent.Type != ENTRY_BANDWIDTH_ADDED)
        &&  (pNotif->RasEvent.Type != ENTRY_BANDWIDTH_REMOVED)
        &&  (pNotif->RasEvent.Type != ENTRY_DELETED))    
    {
        CopyMemory(
        &((REQTYPECAST *)pThunkBuffer)->SendNotification.RasEvent,
        &pNotif->RasEvent,
        sizeof(RASEVENT32));
    }
    else
    {

        ((REQTYPECAST *)pThunkBuffer)->SendNotification.RasEvent.Type =
                    pNotif->RasEvent.Type;
        ((REQTYPECAST *)pThunkBuffer)->SendNotification.RasEvent.hConnection =
                                UlongToHandle(pNotif->RasEvent.hConnection); 

        CopyMemory(
        &((REQTYPECAST *)
        pThunkBuffer)->SendNotification.RasEvent.rDeviceType,
        &pNotif->RasEvent.rDeviceType,
        sizeof(RASDEVICETYPE) + sizeof(GUID)
        + RASAPIP_MAX_ENTRY_NAME + 1);
    }

    SendNotificationRequest(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->SendNotification.retcode;

done:
    pNotif->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }

    
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef   struct _DoIke32
    {
        DWORD   retcode;
        DWORD   hEvent;
        DWORD   pid;
        CHAR    szEvent[20];
    } DoIke32;

VOID
ThunkDoIke(
            pPCB ppcb, 
            PBYTE pBuffer, 
            DWORD dwBufSize)
{
    DWORD       retcode      = ERROR_SUCCESS;
    PBYTE       pThunkBuffer = NULL;
    DoIke32     *pIke        = (DoIke32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->DoIke.hEvent =
                                LongToHandle(pIke->hEvent);
    ((REQTYPECAST *)pThunkBuffer)->DoIke.pid =
                                        pIke->pid;

    CopyMemory(
    ((REQTYPECAST *)pThunkBuffer)->DoIke.szEvent,
    pIke->szEvent,
    20);

    DoIke(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->DoIke.retcode;

done:
    pIke->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}

typedef struct _NDISWAN_IO_PACKET32 {
    IN OUT  ULONG       PacketNumber;
    IN OUT  DWORD       hHandle;
    IN OUT  USHORT      usHandleType;
    IN OUT  USHORT      usHeaderSize;
    IN OUT  USHORT      usPacketSize;
    IN OUT  USHORT      usPacketFlags;
    IN OUT  UCHAR       PacketData[1];
} NDISWAN_IO_PACKET32;

typedef struct _SendRcvBuffer32 {

    DWORD       SRB_NextElementIndex ;

    DWORD       SRB_Pid ;

    NDISWAN_IO_PACKET32   SRB_Packet ;

    BYTE        SRB_Buffer [PACKET_SIZE] ;
} SendRcvBuffer32 ;

typedef struct _PortSend32
    {
        SendRcvBuffer32 buffer;
        DWORD         size ;

    } PortSend32 ;

VOID
ThunkPortSendRequest(
                        pPCB ppcb,
                        BYTE *pBuffer,
                        DWORD dwBufSize)
{
    DWORD       retcode      = ERROR_SUCCESS;
    PBYTE       pThunkBuffer = NULL;
    PortSend32 *pSend32      = (PortSend32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->PortSend.buffer.SRB_NextElementIndex =
                                    pSend32->buffer.SRB_NextElementIndex;

    ((REQTYPECAST *)pThunkBuffer)->PortSend.buffer.SRB_Pid =
                                    pSend32->buffer.SRB_Pid;

    ((REQTYPECAST *)pThunkBuffer)->PortSend.buffer.SRB_Packet.PacketNumber =
                                pSend32->buffer.SRB_Packet.PacketNumber;
    ((REQTYPECAST *)pThunkBuffer)->PortSend.buffer.SRB_Packet.usHandleType =
                                pSend32->buffer.SRB_Packet.usHandleType;
    ((REQTYPECAST *)pThunkBuffer)->PortSend.buffer.SRB_Packet.usHeaderSize =
                                pSend32->buffer.SRB_Packet.usHeaderSize;
    ((REQTYPECAST *)pThunkBuffer)->PortSend.buffer.SRB_Packet.usPacketSize =
                                pSend32->buffer.SRB_Packet.usPacketSize;
    ((REQTYPECAST *)pThunkBuffer)->PortSend.buffer.SRB_Packet.usPacketFlags =
                                pSend32->buffer.SRB_Packet.usPacketFlags;

    CopyMemory(
    ((REQTYPECAST *)pThunkBuffer)->PortSend.buffer.SRB_Packet.PacketData,
    pSend32->buffer.SRB_Packet.PacketData,
    PACKET_SIZE);
    
    ((REQTYPECAST *)pThunkBuffer)->PortSend.size = pSend32->size;                                            

    PortSendRequest(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->Generic.retcode;

done:
    ((REQTYPECAST *)pBuffer)->Generic.retcode = retcode;
    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);

    return;
}

typedef struct _PortReceiveEx32
    {
        DWORD           retcode;
        SendRcvBuffer32 buffer;
        DWORD           size;

    } PortReceiveEx32;

VOID
ThunkPortReceiveRequestEx(
                                pPCB ppcb,
                                BYTE *pBuffer,
                                DWORD dwBufSize)
{
    DWORD retcode = ERROR_SUCCESS;
    PBYTE pThunkBuffer = NULL;
    PortReceiveEx32 *pReceiveEx = (PortReceiveEx32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    PortReceiveRequestEx(ppcb, pThunkBuffer);

    retcode = ((REQTYPECAST *)pThunkBuffer)->PortReceiveEx.retcode;

    pReceiveEx->size = ((REQTYPECAST *)pThunkBuffer)->PortReceiveEx.size;
    pReceiveEx->buffer.SRB_Packet.PacketNumber = 
    ((REQTYPECAST *)
    pThunkBuffer)->PortReceiveEx.buffer.SRB_Packet.PacketNumber;

    pReceiveEx->buffer.SRB_Packet.usHandleType =
    ((REQTYPECAST *)
    pThunkBuffer)->PortReceiveEx.buffer.SRB_Packet.usHandleType;

    pReceiveEx->buffer.SRB_Packet.usHeaderSize =
    ((REQTYPECAST *)
    pThunkBuffer)->PortReceiveEx.buffer.SRB_Packet.usHeaderSize;

    pReceiveEx->buffer.SRB_Packet.usPacketSize =
    ((REQTYPECAST *)
    pThunkBuffer)->PortReceiveEx.buffer.SRB_Packet.usPacketSize;

    pReceiveEx->buffer.SRB_Packet.usPacketFlags =
    ((REQTYPECAST *)
    pThunkBuffer)->PortReceiveEx.buffer.SRB_Packet.usPacketFlags;

    CopyMemory(
    pReceiveEx->buffer.SRB_Packet.PacketData,
    ((REQTYPECAST *)
    pThunkBuffer)->PortReceiveEx.buffer.SRB_Packet.PacketData,
    PACKET_SIZE);

done:
    pReceiveEx->retcode = retcode;
    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}


typedef struct _RefConnection32
    {
        DWORD   retcode;
        DWORD   hConn;
        BOOL    fAddref;
        DWORD   dwRef;

    } RefConnection32;


VOID
ThunkRefConnection(
                        pPCB ppcb,
                        BYTE *pBuffer,
                        DWORD dwBufSize)
{
    DWORD           retcode      = ERROR_SUCCESS;
    PBYTE           pThunkBuffer = NULL;
    RefConnection32 *pRef = (RefConnection32 *) pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->RefConnection.hConn =
                            UlongToHandle(pRef->hConn);
    ((REQTYPECAST *)pThunkBuffer)->RefConnection.fAddref = pRef->fAddref;
    ((REQTYPECAST *)pThunkBuffer)->RefConnection.dwRef = pRef->dwRef;

    RefConnection(ppcb, pThunkBuffer);

    pRef->dwRef = ((REQTYPECAST *)pThunkBuffer)->RefConnection.dwRef;

    retcode = ((REQTYPECAST *)pThunkBuffer)->RefConnection.retcode;

done:
    pRef->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
                                                
    return;
}

typedef struct _GetEapInfo32
    {
        DWORD   retcode;
        DWORD   hConn;
        DWORD   dwSubEntry;
        DWORD   dwContextId;
        DWORD   dwEapTypeId;
        DWORD   dwSizeofEapUIData;
        BYTE    data[1];
    } GetEapInfo32;

VOID
ThunkPppGetEapInfo(
                        pPCB ppcb,
                        BYTE *pBuffer, 
                        DWORD dwBufSize)
{
    DWORD           retcode      = ERROR_SUCCESS;
    PBYTE           pThunkBuffer = NULL;
    GetEapInfo32    *pEapInfo    = (GetEapInfo32 *)pBuffer;

    pThunkBuffer = LocalAlloc(LPTR, dwBufSize + sizeof(DWORD));
    if(NULL == pThunkBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    ((REQTYPECAST *)pThunkBuffer)->GetEapInfo.hConn =
                                UlongToHandle(pEapInfo->hConn);
    ((REQTYPECAST *)pThunkBuffer)->GetEapInfo.dwSubEntry =
                                                pEapInfo->dwSubEntry;

    ((REQTYPECAST *)pThunkBuffer)->GetEapInfo.dwContextId =
                                                pEapInfo->dwContextId;
    ((REQTYPECAST *)pThunkBuffer)->GetEapInfo.dwEapTypeId =                                                
                                                pEapInfo->dwEapTypeId;

    PppGetEapInfo(ppcb, pThunkBuffer);

    pEapInfo->dwSizeofEapUIData = ((REQTYPECAST *)
                        pThunkBuffer)->GetEapInfo.dwSizeofEapUIData;

    CopyMemory(
        pEapInfo->data,
        ((REQTYPECAST *)pThunkBuffer)->GetEapInfo.data,
        pEapInfo->dwSizeofEapUIData);

    retcode = ((REQTYPECAST *)pThunkBuffer)->GetEapInfo.retcode;        

done:
    pEapInfo->retcode = retcode;

    if(NULL != pThunkBuffer)
    {
        LocalFree(pThunkBuffer);
    }
    // DbgPrint("retcode = %d\n", retcode);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\service.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

Module Name

    service.c

Abstract

    This module includes APIs for the main service routine
    and the service event handler routine for rasman.dll.

Author

    Anthony Discolo (adiscolo) 27-Jun-1995

Revision History

    Original from Gurdeep

    Rao Salapaka 13-Jub-1998 Handle Power Management

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <llinfo.h>
#include <rasman.h>
#include <lm.h>
#include <lmwksta.h>
#include <wanpub.h>
#include <raserror.h>
#include <mprlog.h>
#include <rtutils.h>
#include <media.h>
#include <device.h>
#include <stdlib.h>
#include <string.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "nouiutil.h"
#include "loaddlls.h"

//
// Global variables
//
DWORD CheckPoint = 1;

SERVICE_STATUS_HANDLE hService;

DWORD dwCurrentState = SERVICE_STOPPED;

extern HANDLE hIoCompletionPort;

extern HANDLE hRequestThread;

extern DWORD g_dwAttachedCount;

extern BOOL g_fRasRpcInitialized;

extern BOOLEAN RasmanShuttingDown;

//
// Prototype for an api in gdi32.lib.
// Used just to pull in gdi32.lib.
//
int
WINAPI
DeviceCapabilitiesExA(
    LPCSTR,
    LPCSTR,
    LPCSTR,
    int,
    LPCSTR, LPVOID);


#if ENABLE_POWER

DWORD
WINAPI
ServiceHandlerEx(
    DWORD                 fdwControl,
    DWORD                 fdwEventType,
    LPVOID                lpEventData,
    LPVOID                lpContext)
    
#else

VOID
WINAPI
ServiceHandler(
    DWORD fdwControl
    )
    
#endif

/*++

Routine Description

    Handle all service control events for rasman.dll.  Since we
    are not interested in any service events, we just return
    the service status each time we are called.

Arguments

    fdwControl: the service event

Return Value

    None.

--*/

{
    SERVICE_STATUS status;

#if ENABLE_POWER
    DWORD dwRetCode = SUCCESS;
#endif

    ZeroMemory (&status, sizeof(status));
    status.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    

    switch (fdwControl)
    {
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
            status.dwCurrentState       = dwCurrentState;
            status.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_SHUTDOWN;
            status.dwCheckPoint         = CheckPoint++;
            SetServiceStatus(hService, &status);
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
        {

            BOOL fOpenPorts = g_pRasNumPortOpen();
            BOOL fRasmanStopped = FALSE;

            if ( g_dwAttachedCount )
            {
                BackGroundCleanUp();

                if ( !g_dwAttachedCount )
                {
                    fRasmanStopped = TRUE;
                }
            }

            //
            // Setting this event stops
            // the service.
            //
            if (    !g_dwAttachedCount    // no clients attached
                &&  !fOpenPorts           // no open ports
                &&  !fRasmanStopped       // rasman is stopping because
                                          // of background cleanup
                &&  !RasmanShuttingDown)  // rasman is not already stopping
            {
                status.dwCurrentState = dwCurrentState = SERVICE_STOP_PENDING;
                SetServiceStatus(hService, &status);

                //
                // Stop the service.
                //
                PostQueuedCompletionStatus(hIoCompletionPort, 0,0,
                                           (LPOVERLAPPED) &RO_CloseEvent);
            }
            else if (   g_dwAttachedCount
                    ||  fOpenPorts)
            {
                status.dwCurrentState       = dwCurrentState;
                status.dwControlsAccepted   = SERVICE_ACCEPT_STOP;
                status.dwWin32ExitCode      = ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
                status.dwCheckPoint         = CheckPoint++;

                SetServiceStatus(hService, &status);
            }
            break;
        }
        
#if ENABLE_POWER

        case SERVICE_CONTROL_POWEREVENT:
        {
            switch(fdwEventType)
            {
                case PBT_APMQUERYSTANDBY:
                case PBT_APMQUERYSUSPEND:
                {
/*
                    //
                    // Check to see if there are any active connections. 
                    // If so then deny the request to standy/suspend. 
                    // Since we have disabled idle requests, and we
                    // don't ge any queries on critical, this must 
                    // be a user initiated hibernation request.
                    //
                    if(fAnyConnectedPorts())
                    {
                        dwRetCode = ERROR_ACTIVE_CONNECTIONS;
                    }
*/

                    //
                    // PatrickF's document decries that we drop all
                    // connections and acceed to the almighty request
                    // to standby.
                    //
                    DropAllActiveConnections();

                    break;
                }

                case PBT_APMRESUMECRITICAL:
                {
                    //
                    // Drop all active connections
                    //
                    DropAllActiveConnections();
                    
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
        
#endif

    }

#if ENABLE_POWER

    return dwRetCode;

#endif
} // ServiceHandler


VOID
ServiceMain(
    DWORD   dwArgc,
    LPWSTR *lpszArgv
    )

/*++

Routine Description

    Perform initialization and start the main loop for rasman.dll.
    This routine is called by rasman.exe.

Arguments

    dwArgc: ignored

    lpszArgv: ignored

Return Value

    None.

--*/

{
    SERVICE_STATUS status;
    DWORD dwRetCode = NO_ERROR;
    DWORD NumPorts;

    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(lpszArgv);

    ZeroMemory (&status, sizeof(status));
    status.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;

#if ENABLE_POWER
    hService = RegisterServiceCtrlHandlerEx(TEXT("rasman"),
                                          ServiceHandlerEx,
                                          NULL);

#else

    // Register the control request handler.
    //
    hService = RegisterServiceCtrlHandler (TEXT("rasman"),
                    ServiceHandler);
#endif  

    if (hService)
    {
        status.dwCurrentState = dwCurrentState = SERVICE_START_PENDING;
        SetServiceStatus(hService, &status);

        if ((dwRetCode = _RasmanInit(&NumPorts)) == SUCCESS)
        {
            //
            // Initialize PPP.
            //
            dwRetCode = (DWORD)RasStartPPP(NumPorts);

            //
            // Link in gdi32: this is a workaround of a memory
            // allocation bug in gdi32.dll that cannot be fixed
            // before 3.51 release. Calling this entrypoint in
            // gdi32.dll (even though we dont need this dll) causes
            // it to allocate memory for rasman process only once.
            // If we dont do this - each time a client connects with
            // tcpip gdi32.dll gets loaded and unloaded into rasman
            // process leaving behind 4K of of unfreed memory.
            //
            DeviceCapabilitiesExA(NULL, NULL, NULL, 0, NULL, NULL);

            if (dwRetCode == NO_ERROR)
            {
                //
                // Init succeeded: indicate that service is running
                //
                status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
                
#if ENABLE_POWER
                status.dwControlsAccepted |= SERVICE_ACCEPT_POWEREVENT;
#endif

                status.dwCurrentState     = dwCurrentState = SERVICE_RUNNING;
                SetServiceStatus(hService, &status);

                //
                // This is the call into the RASMAN DLL to
                // do all the work. This only returns when
                // the service is to be stopped.
                //
                _RasmanEngine();

                //
                // Update return code status.
                //
                status.dwWin32ExitCode = NO_ERROR;
                status.dwServiceSpecificExitCode = 0;
            }
            else
            {
                RouterLogErrorString (hLogEvents,
                                  ROUTERLOG_CANNOT_INIT_PPP,
                                  0, NULL, dwRetCode, 0) ;
            }
        }

        if (NO_ERROR != dwRetCode)
        {
            if (dwRetCode >= RASBASE)
            {
                status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
                status.dwServiceSpecificExitCode = dwRetCode;
            }
            else
            {
                status.dwWin32ExitCode = dwRetCode;
                status.dwServiceSpecificExitCode = 0;
            }

            if(g_fRasRpcInitialized)
            {
                UninitializeRasRpc();
            }
        }

        if(NULL != hService)
        {
            status.dwControlsAccepted = 0;
            status.dwCurrentState     = dwCurrentState = SERVICE_STOPPED;
            SetServiceStatus(hService, &status);
        }
    }

} // ServiceMain


VOID
SetRasmanServiceStopped(VOID)
{
    SERVICE_STATUS status;

    ZeroMemory (&status, sizeof(status));
    status.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    status.dwCurrentState = dwCurrentState = SERVICE_STOPPED;

    SetServiceStatus(hService, &status);

    hService = NULL;
} // SetRasmanServiceStopping
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\rnetcfg.cpp ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  05/29/97 Rao Salapaka  Created
//
//
//  Description: All Initialization code for rasman component lives here.
//
//****************************************************************************

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

extern "C"
{
#include <nt.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <comdef.h>
#include <ncnetcfg.h>
#include <rtutils.h>
#include <rnetcfg.h>
//#include <initguid.h>
#include <devguid.h>
#include <netcfg_i.c>
#include <rasman.h>
#include <defs.h>

extern "C" DWORD g_dwRasDebug;

#ifdef DBG
#define rDebugTrace(a) \
    if ( g_dwRasDebug) DbgPrint(a)

#define rDebugTrace1(a1, a2) \
    if ( g_dwRasDebug) DbgPrint(a1, a2)

#define rDebugTrace2(a1, a2, a3) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3)

#define rDebugTrace3(a1, a2, a3, a4) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3, a4)

#define rDebugTrace4(a1, a2, a3, a4, a5) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3, a4, a5)

#define rDebugTrace5(a1, a2, a3, a4, a5, a6) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3, a4, a5, a6)

#define rDebugTrace6(a1, a2, a3, a4, a5, a6, a7) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3, a4, a5, a6, a7)

#else

#define rDebugTrace(a)
#define rDebugTrace1(a1, a2)
#define rDebugTrace2(a1, a2, a3)
#define rDebugTrace3(a1, a2, a3, a4)
#define rDebugTrace4(a1, a2, a3, a4, a5)
#define rDebugTrace5(a1, a2, a3, a4, a5, a6)
#define rDebugTrace6(a1, a2, a3, a4, a5, a6, a7)

#endif

INetCfg *g_pINetCfg = NULL;


const TCHAR c_szInfId_MS_NdisWanAppleTalk[]        = TEXT("MS_NdisWanAppleTalk");


//
// These strings are defined in netinfid.h
// IMPORTANT: Please also update the enum
// following this if this structure is updated
//
static const LPCTSTR g_c_szNdisWan [] =
{
    c_szInfId_MS_NdisWanBh,
    c_szInfId_MS_NdisWanIpx,
    c_szInfId_MS_NdisWanIpIn,
    c_szInfId_MS_NdisWanIpOut,
    c_szInfId_MS_NdisWanNbfIn,
    c_szInfId_MS_NdisWanNbfOut,
    c_szInfId_MS_NdisWanAppleTalk

};

const DWORD g_cNumProtocols = (sizeof(g_c_szNdisWan)/sizeof(g_c_szNdisWan[0]));

enum ENdisWan
{

    NdisWanBh   = 0,

    NdisWanIpx,

    NdisWanIpIn,

    NdisWanIpOut,

    NdisWanNbfIn,

    NdisWanNbfOut,

    NdisWanAppleTalk

}   ;

typedef enum ENdisWan   eNdisWan ;

static const LPCTSTR g_c_szLegacyDeviceTypes[] =
{
    c_szInfId_MS_PptpMiniport,                       // corresponding to LEGACY_PPTP in rasman.h
    c_szInfId_MS_L2tpMiniport
};

//
// TODO:
// Copied from rasman\dll\structs.h
// we need to consolidate the structures
// used by netcfg and rasman into a separate
// file.
//
struct RProtocolInfo {

    RAS_PROTOCOLTYPE   PI_Type ;            // ASYBEUI, IPX, IP etc.

    CHAR        PI_AdapterName [MAX_ADAPTER_NAME];  // "\devices\rashub01"

    CHAR        PI_XportName [MAX_XPORT_NAME];  // "\devices\nbf\nbf01"

    PVOID       PI_ProtocolHandle ;         // Used for routing

    DWORD       PI_Allocated ;          // Allocated yet?

    DWORD       PI_Activated ;          // Activated yet?

    UCHAR       PI_LanaNumber ;         // For Netbios transports.

    BOOL        PI_WorkstationNet ;         // TRUE for wrk nets.
} ;

typedef struct RProtocolInfo rProtInfo, *prProtInfo ;

//
// Functions EXTERN_C 'd to be used by rasman
//
extern "C"
{

    CRITICAL_SECTION g_csINetCfg;

    DWORD dwRasInitializeINetCfg();

    DWORD dwRasUninitializeINetCfg();

    DWORD dwGetINetCfg(PVOID *ppvINetCfg);

    DWORD dwGetRasmanRegistryParamKey( HKEY *phkey );

    DWORD dwGetMaxProtocols( WORD *pwMaxProtocols );

    DWORD dwGetProtocolInfo( PBYTE pbBuffer);
/*
    DWORD dwGetNdiswanParamKey(HKEY *phKey, CHAR *pszAdapterName);

    DWORD dwGetServerAdapter (BOOL *pfServerAdapter);

    DWORD dwGetEndPoints ( DWORD * pdwPptpEndPoints,
                           GUID * pGuidComp,
                           DWORD dwDeviceType );
*/
}



DWORD dwRasInitializeINetCfg ()
{
    HRESULT hr = S_OK;

    rDebugTrace("RASMAN: dwRasInitializeINetCfg...\n");

    EnterCriticalSection ( &g_csINetCfg );

    if (NULL == g_pINetCfg)
    {
        DWORD dwCountTries = 0;

        //
        // Try to get INetCfg pointer. Try a few times to get it
        // if someone else is using it.
        //

        do
        {
            hr = HrCreateAndInitializeINetCfg (TRUE, &g_pINetCfg);

            if ( S_OK == hr )
                break;

            if ( NETCFG_E_IN_USE != hr )
                break;

            rDebugTrace1("RASMAN: Waiting for INetCfg to get released. %d\n", dwCountTries);

            Sleep ( 5000 );

            dwCountTries++;

        } while (   NETCFG_E_IN_USE == hr
                &&  dwCountTries < 6);
    }

    if (hr)
        LeaveCriticalSection( &g_csINetCfg );

    rDebugTrace1("RASMAN: dwRasInitializeINetCfg done. 0x%x\n", hr);

    return HRESULT_CODE (hr);
}


DWORD dwRasUninitializeINetCfg ()
{
    HRESULT hr = S_OK;

    rDebugTrace("RASMAN: dwRasUninitializeINetCfg...\n");

    if (NULL != g_pINetCfg)
    {
        hr = HrUninitializeAndReleaseINetCfg (TRUE, g_pINetCfg);
        g_pINetCfg = NULL;
    }

    LeaveCriticalSection ( &g_csINetCfg );

    rDebugTrace1("RASMAN: dwRasUninitializeINetCfg done. 0x%x\n", hr);

    return HRESULT_CODE (hr);
}


DWORD
dwGetINetCfg(PVOID *ppvINetCfg)
{

    rDebugTrace("RASMAN: dwGetINetCfg...\n");

    *ppvINetCfg = (PVOID) g_pINetCfg;

    rDebugTrace("RASMAN: dwGetINetCfg done. 0\n");

    return HRESULT_CODE(S_OK);
}


/*
DWORD
dwGetRasmanRegistryParamKey(HKEY *phkey)
{
    return RegOpenKeyEx (HKEY_LOCAL_MACHINE, RASMAN_REGISTRY_PATH, 0,
            KEY_ALL_ACCESS, phkey);
}

//
//  dwGetMaxProtocols
//  function: Get the number of protocols bound
//           to ndiswan
//
//  Parameters:
//      OUT WORD *pwMaxProtocols
//
DWORD
dwGetMaxProtocols(WORD *pwMaxProtocols)
{
    HRESULT                 hr;
    DWORD                   dwMaxProtocols  = 0;
    DWORD                   dwCount;
    INetCfgComponent        *pNetCfgCompi   = NULL;
    INetCfgClass            *pNetCfgClass   = NULL;

    rDebugTrace("RASMAN: dwGetMaxProtocols...\n");

    do
    {

        if (NULL == g_pINetCfg)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (hr = g_pINetCfg->QueryNetCfgClass (&GUID_DEVCLASS_NET, &pNetCfgClass))
        {
            break;
        }

        CIterNetCfgComponent cIterAdapters(pNetCfgClass);

        //
        // for each adapter check to see if its a wan adapter
        //
        while ( S_OK == (hr = cIterAdapters.HrNext(&pNetCfgCompi)))
        {
            if (    FIsComponentId ( g_c_szNdisWan[NdisWanNbfIn], pNetCfgCompi )
                ||  FIsComponentId ( g_c_szNdisWan[NdisWanNbfOut], pNetCfgCompi ))
                dwMaxProtocols++;

            ReleaseObj (pNetCfgCompi);
        }

    } while (FALSE);

    if (SUCCEEDED (hr))
        hr = S_OK;

    ReleaseObj(pNetCfgClass);

    *pwMaxProtocols = (WORD) dwMaxProtocols;

    rDebugTrace1("RASMAN: dwGetMaxProtocols done. 0x%x\n", hr);

    return HRESULT_CODE (hr);
}

//  dwGetProtocolInfo
//
//  Function:   Fills up the protinfo buffer being passed in.
//              Assumes that the buffer is big enough for dwcProtocols
//              information.
//              Assumes (dwcProtocols * sizeof(ProtInfo) < sizeof(pProtInfoBuffer)
//  Parameters:
//              IN PBYTE pbBuffer
//
DWORD
dwGetProtocolInfo( PBYTE pbBuffer )
{
    HRESULT                 hr;
    INetCfgClass            *pNetCfgAdapterClass = NULL;
    INetCfgComponent        *pNetCfgCompi        = NULL;
    DWORD                   dwCur                = 0;
    BSTR                    bstrBindName         = NULL;
    prProtInfo              pProtInfoBuffer      = (prProtInfo) pbBuffer;

    do
    {

        rDebugTrace("RASMAN: dwGetProtocolInfo...\n");

        if (    NULL == g_pINetCfg
            ||  NULL == pbBuffer)
        {
            hr = E_INVALIDARG;
            break;
        }

        if ( hr = g_pINetCfg->QueryNetCfgClass (&GUID_DEVCLASS_NET, &pNetCfgAdapterClass))
        {
            break;
        }

        CIterNetCfgComponent cIterAdapters(pNetCfgAdapterClass);

        while (S_OK == (hr = cIterAdapters.HrNext( &pNetCfgCompi )))
        {
            if (   FIsComponentId( g_c_szNdisWan[NdisWanNbfIn], pNetCfgCompi )
               ||  FIsComponentId( g_c_szNdisWan[NdisWanNbfOut], pNetCfgCompi ))
            {
                pProtInfoBuffer[dwCur].PI_Type = ASYBEUI;
            }
            else
            {
                ReleaseObj ( pNetCfgCompi );
                pNetCfgCompi = NULL;

                continue;
            }   

            //
            // Get the bindname
            //
            if (hr = pNetCfgCompi->GetBindName(&bstrBindName))
            {
                break;
            }

            strcpy (pProtInfoBuffer[dwCur].PI_AdapterName, "\\DEVICE\\");

            //
            // Convert the bindname to sbcs string
            // Go past the \DEVICE in the mbcs string
            //
            if (!WideCharToMultiByte ( CP_ACP,                                      // code page
                                       0,                                           // performance and mapping flags
                                       bstrBindName,                                // address of wide char string
                                       -1,                                          // number of characters in string       
                                       &(pProtInfoBuffer[dwCur].PI_AdapterName[8]), // address of buffer for new string
                                       MAX_ADAPTER_NAME,                            // size of buffer
                                       NULL,                                        // address of default for unmappable chars
                                       NULL))                                       // address of flag set when default char. used
            {

                DWORD dwRetcode;
                
                dwRetcode = GetLastError();

                hr = HRESULT_FROM_WIN32(dwRetcode);
            
                break;
            }

            pProtInfoBuffer[dwCur].PI_Allocated      = FALSE ;
            pProtInfoBuffer[dwCur].PI_Activated      = FALSE ;
            pProtInfoBuffer[dwCur].PI_WorkstationNet = FALSE ;
            
            ReleaseObj(pNetCfgCompi);
            pNetCfgCompi = NULL;

            if (bstrBindName)
            {
                SysFreeString (bstrBindName);
                bstrBindName = NULL;
            }

            dwCur++;

        }

        ReleaseObj( pNetCfgCompi );
        pNetCfgCompi = NULL;

    } while (FALSE);

    if (SUCCEEDED(hr))
        hr = S_OK;

    ReleaseObj(pNetCfgAdapterClass);

    rDebugTrace1("RASMAN: dwGetProtocolInfo done. 0x%x\n", hr);

    return HRESULT_CODE (hr);
}


DWORD
dwGetNdiswanParamKey(HKEY *phKey, CHAR *pszAdapterName)
{

    HRESULT             hr                      = S_OK;
    WCHAR               *pwszBindName           = NULL;
    INetCfgClass        *pNetCfgAdapterClass    = NULL;
    INetCfgComponent    *pNetCfgCompi           = NULL;
    BSTR                bstrTempBindName        = NULL;

    rDebugTrace("RASMAN: dwGetNdiswanParamKey...\n");

    do
    {
        if (    NULL == g_pINetCfg
            ||  NULL == pszAdapterName
            ||  '\0' == pszAdapterName[0])
        {
            hr = E_INVALIDARG;
            break;
        }

        //
        // convert the string to a bstr
        //
        pwszBindName = (BSTR) LocalAlloc( LPTR, sizeof ( WCHAR ) * (strlen(pszAdapterName) + 1 ));

        if (!pwszBindName)
        {
            break;
        }

        if (!MultiByteToWideChar( CP_ACP,                           // code page
                                  0,                                // charater-type options
                                  pszAdapterName,                   // address of string to map
                                  -1,                               // number of charaters in string
                                  pwszBindName,                     // address of wide-character buffer
                                  strlen(pszAdapterName) + 1))      // size of buffer
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
        
        //
        // iterate through the adapters and find the adapter with this bindname
        //
        if ( hr = g_pINetCfg->QueryNetCfgClass (&GUID_DEVCLASS_NET, &pNetCfgAdapterClass))
        {
            break;
        }

        CIterNetCfgComponent   cIterAdapters (pNetCfgAdapterClass);

        while (S_OK == (hr = cIterAdapters.HrNext( &pNetCfgCompi)))
        {
            if (hr = pNetCfgCompi->GetBindName( &bstrTempBindName ))
            {
                break;
            }

            if (FEqualComponentId(bstrTempBindName, pwszBindName))
            {
                hr = pNetCfgCompi->OpenParamKey( phKey );
                break;
            }

            if ( bstrTempBindName )
            {
                SysFreeString( bstrTempBindName );
                bstrTempBindName = NULL;
            }

            ReleaseObj ( pNetCfgCompi );
            pNetCfgCompi = NULL;
        }

        ReleaseObj ( pNetCfgCompi );
        pNetCfgCompi = NULL;

    } while (FALSE);

    if (SUCCEEDED (hr))
        hr = S_OK;

    ReleaseObj(pNetCfgAdapterClass);

    rDebugTrace1("RASMAN: dwGetNdiswanParamKey done. 0x%x\n", hr);

    return HRESULT_CODE(hr);

}

DWORD
dwGetServerAdapter( BOOL * pfServerAdapter )
{
    INetCfgComponent    *pNetCfgComp = NULL;
    HRESULT             hr;

    rDebugTrace("RASMAN: dwGetServerAdapter...\n");

    //
    // Initialize INetCfg if not already initialized
    //
    if (NULL == g_pINetCfg)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    //
    // Get the NdisWanipin component
    //
    if (hr = HrFindComponent(g_pINetCfg,
                             GUID_DEVCLASS_NET,
                             c_szInfId_MS_NdisWanIpIn,
                             &pNetCfgComp))
    {
        *pfServerAdapter = FALSE;
        hr = S_OK;
        goto done;
    }

    *pfServerAdapter = TRUE;

done:
    ReleaseObj( pNetCfgComp );

    rDebugTrace1("RASMAN: dwGetServerAdapter done. 0x%x\n", hr);

    return HRESULT_CODE(hr);

}

DWORD
dwGetEndPoints ( DWORD * pdwEndPoints,
                 GUID  * pGuidComp,
                 DWORD   dwDeviceType )
{
    HRESULT              hr                  = S_OK;
    INetCfgComponent     *pINetCfgComp       = NULL;
    HKEY                 hkey                = NULL;
    DWORD                dwType;
    DWORD                cbData;

    rDebugTrace ("RASMAN: dwGetPptpEndPoints...\n");

    *pdwEndPoints = 0;

    //
    // Get protocol component
    //
    hr = HrFindComponent ( g_pINetCfg,
                           GUID_DEVCLASS_NET,
                           g_c_szLegacyDeviceTypes[ dwDeviceType ],
                           &pINetCfgComp );

    if ( hr )
    {
        rDebugTrace("RASMAN: protocol not installed\n");
        goto done;
    }

    //
    // Get the Parameters key
    //
    hr = pINetCfgComp->OpenParamKey( &hkey );

    if ( hr )
    {
        rDebugTrace1("RASMAN: Failed to open param key\n, 0x%x", hr);
        goto done;
    }

    //
    // Get the number of endpoints
    //

    cbData = sizeof ( DWORD );

    if ( RegQueryValueEx( hkey,
                          TEXT("WanEndPoints"),
                          NULL,
                          &dwType,
                          (LPBYTE) pdwEndPoints,
                          &cbData))
    {
        hr = HRESULT_FROM_WIN32 ( GetLastError() );
        goto done;
    }

    //
    // Get the guid of the component
    //
    hr = pINetCfgComp->GetInstanceGuid( pGuidComp );

    if ( hr )
    {
        rDebugTrace1 ("RASMAN: Failed to obtain guid for component %d", dwDeviceType );
        *pdwEndPoints = 0;
        goto done;
    }

done:

    ReleaseObj ( pINetCfgComp );

    if ( hkey )
        RegCloseKey ( hkey );

    rDebugTrace2("RASMAN: dwGetEndPoints done 0x%x. EndPoints = %d\n", hr, *pdwEndPoints );

    return HRESULT_CODE ( hr );

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\util.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    util.c

Abstract:

    Utility functions used in rasmans.dll

Author:

    Gurdeep Singh Pall (gurdeep) 06-Jun-1997

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#define RASMXS_DYNAMIC_LINK

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <llinfo.h>
#include <rasman.h>
#include <rasppp.h>
#include <lm.h>
#include <lmwksta.h>
#include <wanpub.h>
#include <raserror.h>
//
//Open this to plumb creds at winlogon time
//
#if 0
#include <wincrypt.h>   // Required by sclogon.h
#include <sclogon.h>    // For ScHelperGetCertFromLogonInfo
#endif 
//#include <rasarp.h>
#include <media.h>
#include <mprlog.h>
#include <rtutils.h>
#include <device.h>
#include <stdlib.h>
#include <string.h>
#include <rtutils.h>
#include "logtrdef.h"
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "wincred.h"
#include "stdio.h"
#include "ntddip.h"
#include "iphlpapi.h"
#include "iprtrmib.h"


#include "eaptypeid.h" // for PPP_EAP_TLS

#if SENS_ENABLED
#include "sensapip.h"
#endif

#include "winsock2.h"

#define PASSWORDMAGIC 0xA5

//
// Following is copied from ..\..\ppp\eaptls\eaptls.h. Keep this in
// sync with the structure in eaptls.h. This is not good for maintenance
// TODO: copy the structure to a common header and include it both in
// rastls and rasman.
//
#define MAX_HASH_SIZE       20      // Certificate hash size

typedef struct _EAPTLS_HASH
{
    DWORD   cbHash;                 // Number of bytes in the hash
    BYTE    pbHash[MAX_HASH_SIZE];  // The hash of a certificate

} EAPTLS_HASH;

DWORD g_IphlpInitialized = FALSE;

typedef struct _RASMAN_EAPTLS_USER_PROPERTIES
{
    DWORD       reserved;               // Must be 0 (compare with EAPLOGONINFO)
    DWORD       dwVersion;
    DWORD       dwSize;                 // Number of bytes in this structure
    DWORD       fFlags;                 // See EAPTLS_USER_FLAG_*
    EAPTLS_HASH Hash;                   // Hash for the user certificate
    WCHAR*      pwszDiffUser;           // The EAP Identity to send
    DWORD       dwPinOffset;            // Offset in abData
    WCHAR*      pwszPin;                // The smartcard PIN
    USHORT      usLength;               // Part of UnicodeString
    USHORT      usMaximumLength;        // Part of UnicodeString
    UCHAR       ucSeed;                 // To unlock the UnicodeString
    WCHAR       awszString[1];          // Storage for pwszDiffUser and pwszPin

} RASMAN_EAPTLS_USER_PROPERTIES;

/*++

Routine Description:

    Gets information about the protocol change from ndiswan

Arguments:

    pointer to a structure NDISWAN_GET_PROTOCOL_EVENT which
    returns an array of PROTOCOL_EVENT structures.

Return Value:

    return codes from IOCTL_NDISWAN_GET_PROTOCOL_EVENT.
    E_INVALIDARG if pProtEvents is NULL.

--*/

DWORD
DwGetProtocolEvent(NDISWAN_GET_PROTOCOL_EVENT *pProtEvents)
{
    DWORD retcode = SUCCESS;

    DWORD dwbytes;

    if(NULL == pProtEvents)
    {
        RasmanTrace(
               "DwGetProtocolEvent: pProtEvents=NULL!");

        retcode = E_INVALIDARG;
        goto done;
    }

    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);


    if(!DeviceIoControl(
                RasHubHandle,
                IOCTL_NDISWAN_GET_PROTOCOL_EVENT,
                NULL,
                0,
                pProtEvents,
                sizeof(NDISWAN_GET_PROTOCOL_EVENT),
                &dwbytes,
                NULL))
    {
        retcode = GetLastError();

        RasmanTrace(
               "DwGetProtocolEvent: Failed to get protocol"
               " event. rc=0x%x",
               retcode);

        goto done;
    }

done:
    return retcode;

}

DWORD
GetBapPacket ( RasmanBapPacket **ppBapPacket )
{
    DWORD retcode = SUCCESS;
    RasmanBapPacket *pBapPacket = NULL;

    if(NULL == BapBuffers)
    {
        HKEY  hkey = NULL;
        DWORD dwMaxBuffers = 10;
        
        
        BapBuffers = (BapBuffersList *) 
                    LocalAlloc(LPTR, sizeof(BapBuffersList));

        if(NULL == BapBuffers)
        {
            retcode = GetLastError();
            goto done;
        }

        //
        // Read from registry the max number of buffers we allow.
        // default to 10.
        //
        if(NO_ERROR == RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            "System\\CurrentControlSet\\Services\\Rasman\\Parameters",
            0,
            KEY_READ,
            &hkey))
        {
            DWORD cbData = sizeof(DWORD);
            DWORD dwType;
            
            if(     (NO_ERROR == RegQueryValueEx(
                            hkey,
                            "MaxBapBuffers",
                            NULL,
                            &dwType,
                            (PBYTE) &dwMaxBuffers,
                            &cbData))
                &&  (REG_DWORD == dwType))                            
            {
                RasmanTrace(
                       "GetBapPacket: MaxBuffers = %d",
                       dwMaxBuffers);

            }

            RegCloseKey(hkey);
        }
        
        BapBuffers->dwMaxBuffers = dwMaxBuffers;                       
    }

    if(BapBuffers->dwNumBuffers < BapBuffers->dwMaxBuffers)
    {
        pBapPacket = LocalAlloc(LPTR, sizeof(RasmanBapPacket));

        if(NULL == pBapPacket)
        {
            retcode = GetLastError();
            goto done;
        }

        //
        // Insert the new buffer in the buffers list
        //
        pBapPacket->RBP_Overlapped.RO_EventType = OVEVT_RASMAN_THRESHOLD;
        pBapPacket->Next = BapBuffers->pPacketList;
        BapBuffers->pPacketList = pBapPacket;
        BapBuffers->dwNumBuffers += 1;

        RasmanTrace(
            "GetBapPacket: Max=%d, Num=%d",
            BapBuffers->dwMaxBuffers,
            BapBuffers->dwNumBuffers);
    }
    else
    {
        RasmanTrace( 
              "GetBapPacket: Not Allocating we have max BapBuffers");
    }

done:

    *ppBapPacket = pBapPacket;

    return retcode;
}


DWORD
DwSetThresholdEvent(RasmanBapPacket *pBapPacket)
{
    DWORD dwBytes;
    DWORD retcode = SUCCESS;

    RasmanTrace(
           "DwSetThresholdEvent: pOverlapped=%p",
            &pBapPacket->RBP_Overlapped);
    
    //
    // Set the threshold event
    //
    if (!DeviceIoControl(RasHubHandle,
                         IOCTL_NDISWAN_SET_THRESHOLD_EVENT,
                         ( LPVOID ) &pBapPacket->RBP_ThresholdEvent,
                         sizeof ( NDISWAN_SET_THRESHOLD_EVENT ),
                         ( LPVOID ) &pBapPacket->RBP_ThresholdEvent,
                         sizeof ( NDISWAN_SET_THRESHOLD_EVENT),
                         &dwBytes,
                         ( LPOVERLAPPED ) &pBapPacket->RBP_Overlapped ))
    {
        retcode = GetLastError();

        if (ERROR_IO_PENDING == retcode)
        {
            retcode = SUCCESS;
        }
        else
        {
            RasmanTrace(
                   "DwSetThresholdEvent: Failed to Set Threshold Event. %d",
                   retcode );
        }
    }
    else
    {
        RasmanTrace(
               "DwSetThresholdEvent: completed sync!");
    }    

    return retcode;
}

/*++

Routine Description:

    Pends an irp with ndiswan to signal in the case of
    Protocols coming and going.

Arguments:

    None

Return Value:

    return codes from IOCTL_NDISWAN_SET_PROTOCOL_EVENT.

--*/

DWORD
DwSetProtocolEvent()
{
    DWORD retcode = SUCCESS;

    //
    // Check to see if ndiswan has started yet.
    //
    if(INVALID_HANDLE_VALUE == RasHubHandle)
    {
        if((DWORD) -1 != TraceHandle)
        {
            RasmanTrace(
                   "DwSetProtocolEvent: returning %d"
                   " since ndiswan isn't started yet",
                   ERROR_INVALID_HANDLE);
        }

        retcode = ERROR_INVALID_HANDLE;
        goto done;
    }

    if((DWORD) -1 != TraceHandle)
    {
        RasmanTrace(
               "DwSetProtocolEvent");
    }

    //
    // Plumb the irp with ndiswan to notify on protocol
    // events. Keep plumbing if the IOCTL is completed
    // synchronously.
    //
    if (!DeviceIoControl(RasHubHandle,
                         IOCTL_NDISWAN_SET_PROTOCOL_EVENT,
                         NULL,
                         0,
                         NULL,
                         0,
                         NULL,
                         (LPOVERLAPPED) &RO_ProtocolEvent))
    {
        retcode = GetLastError();

        if(ERROR_IO_PENDING == retcode)
        {
            retcode = SUCCESS;
        }
        else
        {
            if((DWORD) -1 != TraceHandle)
            {
                RasmanTrace(
                       "_SET_PROTCOL_EVENT returned 0x%x",
                       retcode);
            }
        }
    }

    if((DWORD) -1 != TraceHandle)
    {
        RasmanTrace(
               "DwSetProtocolEvent. rc=0x%x",
               retcode);
    }

    if(ERROR_IO_PENDING == retcode)
    {
        retcode = SUCCESS;
    }

done:
    return retcode;
}

/*++

Routine Description:

    Pends an irp with ndiswan to signal in the case of
    Hibernation.

Arguments:

    None

Return Value:

    return codes from IOCTL_NDISWAN_SET_HIBERNATE_EVENT.

--*/
DWORD
DwSetHibernateEvent()
{
    DWORD retcode = SUCCESS;

    //
    // Check to see if ndiswan has started yet.
    //
    if(INVALID_HANDLE_VALUE == RasHubHandle)
    {
        if((DWORD) -1 != TraceHandle)
        {
            RasmanTrace(
                   "DwSetProtocolEvent: returning %d"
                   " since ndiswan isn't started yet",
                   ERROR_INVALID_HANDLE);
        }

        retcode = ERROR_INVALID_HANDLE;
        goto done;
    }

    if((DWORD) -1 != TraceHandle)
    {
        RasmanTrace(
           "DwSetHibernateEvent");
    }

    //
    // Plumb the irp with ndiswan to notify on Hibernate
    // events.
    //
    if (!DeviceIoControl(RasHubHandle,
                         IOCTL_NDISWAN_SET_HIBERNATE_EVENT,
                         NULL,
                         0,
                         NULL,
                         0,
                         NULL,
                         (LPOVERLAPPED) &RO_HibernateEvent))
    {
        retcode = GetLastError();

        if (ERROR_IO_PENDING == retcode)
        {
            retcode = SUCCESS;
        }
        else
        {
            if((DWORD) -1 != TraceHandle)
            {
                RasmanTrace(
                   "DwSetHibernateEvent: Failed to Set "
                   "HibernateEvent Event. 0x%x",
                   retcode);

                goto done;
            }
        }
    }

    if((DWORD) -1 != TraceHandle)
    {
        RasmanTrace(
               "DwSetHibernateEvent. rc=0x%x",
               retcode);
    }

done:
    return retcode;
}

/*++

Routine Description:

    Makes the association between ndiswan and rasman's
    completion port. Starts ndsiwan if required.

Arguments:

    None

Return Value:

    return codes from DwStartNdiswan and CreateIoCompletion.

--*/
DWORD
DwStartAndAssociateNdiswan()
{
    DWORD retcode = SUCCESS;
    HANDLE hAssociatedPort;

    ASSERT(INVALID_HANDLE_VALUE != hIoCompletionPort);

    if(INVALID_HANDLE_VALUE == RasHubHandle)
    {
        retcode = DwStartNdiswan();

        if(SUCCESS != retcode)
        {
            RasmanTrace(
                   "Failed to start ndiswan. 0x%x",
                   retcode);

            goto done;
        }
    }

    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);

    hAssociatedPort = CreateIoCompletionPort(
                            RasHubHandle,
                            hIoCompletionPort,
                            0,
                            0);

    if(NULL == hAssociatedPort)
    {
        retcode = GetLastError();

        RasmanTrace(
               "Failed to make ndiswan association. 0x%x",
               retcode);

        goto done;
    }

    ASSERT(hAssociatedPort == hIoCompletionPort);

    if(hAssociatedPort != hIoCompletionPort)
    {
        RasmanTrace(
               "DwMakeNdiswanAssociation: hAssociatedport=0x%x"
               " != hIoCompletionPort",
               hAssociatedPort,
               hIoCompletionPort);
    }

    //
    // Set hibernate and protocol irps with ndiswan
    //
    retcode = DwSetEvents();

    if(SUCCESS != retcode)
    {
        RasmanTrace(
               "DwMakeNdiswanAssociation: failed to set ndis events. 0x%x",
               retcode);
    }

done:

    RasmanTrace(
           "DwStartAndAssociateNdiswan: 0x%x",
           retcode);

    return retcode;
}

/*++

Routine Description:

    If a listen is posted on a biplex port this function
    is called to open it again - basically cancel the listen
    and make the approp changes so that the listen can be
    reposted when this port is closed.

Arguments:

    ppcb

Return Value:

   SUCCESS.

--*/
DWORD
ReOpenBiplexPort (pPCB ppcb)
{
    //
    // The only information that is context dependent is the
    // Notifier list AND the async op notifier. Back up both
    // of these:
    //
    ppcb->PCB_BiplexNotifierList = ppcb->PCB_NotifierList ;

    ppcb->PCB_NotifierList = NULL ;

    ppcb->PCB_BiplexAsyncOpNotifier =
        ppcb->PCB_AsyncWorkerElement.WE_Notifier;

    ppcb->PCB_BiplexOwnerPID = ppcb->PCB_OwnerPID ;

    ppcb->PCB_BiplexUserStoredBlock =
                    ppcb->PCB_UserStoredBlock ;

    ppcb->PCB_BiplexUserStoredBlockSize =
                    ppcb->PCB_UserStoredBlockSize ;

    ppcb->PCB_UserStoredBlock = NULL ;

    ppcb->PCB_UserStoredBlockSize = 0 ;

    ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                                INVALID_HANDLE_VALUE ;

    //
    // Now Disconnect disconnect the port to cancel any
    // existing states
    //
    DisconnectPort (ppcb,
                    INVALID_HANDLE_VALUE,
                    USER_REQUESTED) ;

    return SUCCESS ;
}

/*++

Routine Description:

    When the biplex port is closed - the previous listen
    request is reposted.

Arguments:

    ppcb

Return Value:

   SUCCESS.

--*/
VOID
RePostListenOnBiplexPort (pPCB ppcb)
{

    DWORD   retcode ;
    DWORD   opentry ;

    //
    // Close the port
    //
    PORTCLOSE (ppcb->PCB_Media, ppcb->PCB_PortIOHandle) ;

#define MAX_OPEN_TRIES 10

    //
    // In order to reset everything we close and open the
    // port:
    //
    for (opentry=0; opentry < MAX_OPEN_TRIES; opentry++)
    {
	    //
    	// Open followed by Close returns PortAlreadyOpen -
    	// hence the sleep.
	    //
    	Sleep (100L) ;

	    retcode = PORTOPEN (ppcb->PCB_Media,
            		    	ppcb->PCB_Name,
			                &ppcb->PCB_PortIOHandle,
			                hIoCompletionPort,
			                HandleToUlong(ppcb->PCB_PortHandle));

	    if (retcode==SUCCESS)
	    {
    	    break ;
    	}
    }

    //
    // If the port does not open successfully again - we
    // are in trouble with the port.
    //
    if (retcode != SUCCESS)
    {
	    LPSTR temp = ppcb->PCB_Name ;
    	RouterLogErrorString (
	                    hLogEvents,
	                    ROUTERLOG_CANNOT_REOPEN_BIPLEX_PORT,
	                    1, (LPSTR*)&temp,retcode, 1
	                    ) ;
    }

    //
    // Open port first
    //
    ppcb->PCB_PortStatus = OPEN ;

    SetPortConnState(__FILE__, __LINE__,
                     ppcb, DISCONNECTED);

    ppcb->PCB_DisconnectReason = NOT_DISCONNECTED ;

    ppcb->PCB_CurrentUsage |= CALL_IN ;

    ppcb->PCB_CurrentUsage &= ~CALL_OUT;

    ppcb->PCB_OpenedUsage &= ~CALL_OUT;

    //
    // First put the backed up notifier lists in place.
    //
    ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                ppcb->PCB_BiplexAsyncOpNotifier ;

    ppcb->PCB_NotifierList = ppcb->PCB_BiplexNotifierList ;

    ppcb->PCB_OwnerPID = ppcb->PCB_BiplexOwnerPID ;

    //
    // there wasnt a listen pending - so just return.
    //
    if (ppcb->PCB_AsyncWorkerElement.WE_Notifier ==
                                INVALID_HANDLE_VALUE)
    {
	    SignalPortDisconnect(ppcb, ERROR_PORT_DISCONNECTED);
    	return ;
    }

    //
    // Now we re-post a listen with the same async
    // op notifier
    //
    retcode = ListenConnectRequest (
                        REQTYPE_DEVICELISTEN,
                        ppcb, ppcb->PCB_DeviceType,
                        ppcb->PCB_DeviceName, 0,
                        ppcb->PCB_BiplexAsyncOpNotifier
                        );

    if (retcode != PENDING)
    {
        //
	    // Complete the async request if anything other
	    // than PENDING This allows the caller to dela
	    // with errors only in one place
    	//
	    CompleteListenRequest (ppcb, retcode) ;
	}

    RasmanTrace(
           "Listen posted on port: %s, error code: %d",
           ppcb->PCB_Name,
           retcode);
}

/*++

Routine Description:

    Loads the named device dll if it is not already
    loaded and returns a pointer to the device control
    block.

Arguments:

    ppcb

    devicetype

Return Value:

    Pointer to Device control block or NULL (if DLL could not
    be loaded)

--*/
pDeviceCB
LoadDeviceDLL (pPCB ppcb, char *devicetype)
{
    WORD    i ;

    char dllname [MAX_DEVICETYPE_NAME] ;

    pDeviceCB pdcb = Dcb ;

    DeviceDLLEntryPoints DDEntryPoints[MAX_DEVICEDLLENTRYPOINTS] =
    {
        DEVICEENUM_STR,         DEVICEENUM_ID,

        DEVICECONNECT_STR,      DEVICECONNECT_ID,

        DEVICELISTEN_STR,       DEVICELISTEN_ID,

        DEVICEGETINFO_STR,      DEVICEGETINFO_ID,

        DEVICESETINFO_STR,      DEVICESETINFO_ID,

        DEVICEDONE_STR,         DEVICEDONE_ID,

        DEVICEWORK_STR,         DEVICEWORK_ID,

        DEVICESETDEVCONFIG_STR, DEVICESETDEVCONFIG_ID,

        DEVICEGETDEVCONFIG_STR, DEVICEGETDEVCONFIG_ID
    } ;

    //
    // For optimization we have one DLL representing 3
    // devices. In order to support this we map the 3
    // device names to this one DLL name:
    //
    MapDeviceDLLName (ppcb, devicetype, dllname) ;

    //
    // Try to find the device first:
    //
    while (pdcb->DCB_Name[0] != '\0')
    {
	    if (_stricmp (dllname, pdcb->DCB_Name) == 0)
	    {
    	    return pdcb ;
    	}
    	
	    pdcb++ ;
    }

    //
    // Device DLL Not loaded, so load it.
    //
    if ((pdcb->DCB_DLLHandle =
        LoadLibrary(dllname)) == NULL)
    {
    	return NULL ;
    }

    //
    // Get all the device DLL entry points:
    //
    for (i=0; i < MAX_DEVICEDLLENTRYPOINTS ; i++)
    {
	    pdcb->DCB_AddrLookUp[i] =  GetProcAddress(
	                                pdcb->DCB_DLLHandle,
                                    DDEntryPoints[i].name
                                    );
	}

    //
    // If all succeeded copy the device dll name and
    // return pointer to the control block:
    //
    strcpy (pdcb->DCB_Name, dllname) ;

    return pdcb ;
}


/*++

Routine Description:

    Unloads all dynamically loaded device DLLs

Arguments:

    void

Return Value:

    void

--*/
VOID
UnloadDeviceDLLs()
{
    pDeviceCB pdcb;

    for (pdcb = Dcb; *pdcb->DCB_Name != '\0'; pdcb++)
    {
        if (pdcb->DCB_DLLHandle != NULL)
        {
            FreeLibrary(pdcb->DCB_DLLHandle);
            pdcb->DCB_DLLHandle = NULL;
        }
        *pdcb->DCB_Name = '\0';
    }
}


/*++

Routine Description:

   Used to map the device name to the corresponding DLL
   name. If it is one of modem, pad or switch device we
   map to rasmxs, Else, we map the device name itself.

Arguments:

    ppcb

    devicetype

    dllname

Return Value:

    void

--*/
VOID
MapDeviceDLLName (pPCB ppcb, char *devicetype, char *dllname)
{
    if (	(0 ==
            _stricmp (devicetype, DEVICE_MODEM)
    	&&	(0 ==
    	    _stricmp (ppcb->PCB_Media->MCB_Name, "RASTAPI"))))
    {     	
        //
        // this is a unimodem modem
        //
	    strcpy (dllname, "RASTAPI") ;
	}
    else if (	(0 == _stricmp (devicetype, DEVICE_MODEM))
    		||	(0 == _stricmp (devicetype, DEVICE_PAD))
    		||  (0 == _stricmp (devicetype, DEVICE_SWITCH)))
    {    		
        //
        // rasmxs modem
        //
	    strcpy (dllname, DEVICE_MODEMPADSWITCH);
    }	
    else if (0 == _stricmp (devicetype, "RASETHER"))
    {
	    strcpy (dllname, "RASETHER") ;
	}
    else if (0 == _stricmp (devicetype, "RASSNA"))
    {
    	strcpy (dllname, "RASSNA") ;
    }
    else
    {
        //
        // else all devices are supported bu rastapi dll
        //
	    strcpy (dllname, "RASTAPI") ;
	}
}

/*++

Routine Description:

    Frees a allocated route. If it was also activated it is
    "deactivated at this point"

Arguments:

    pBundle

    plist

Return Value:

    void

--*/
VOID
DeAllocateRoute (Bundle *pBundle, pList plist)
{
    NDISWAN_UNROUTE rinfo ;

    DWORD bytesrecvd ;

    pProtInfo prot = (pProtInfo)plist->L_Element ;

    if (plist->L_Activated)
    {

#if DBG
        ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

        plist->L_Activated = FALSE ;

        rinfo.hBundleHandle = pBundle->B_NdisHandle ;

        rinfo.usProtocolType = (USHORT) prot->PI_Type;

        //
        // Un-route this by calling to the RASHUB.
        //
        DeviceIoControl (
                 RasHubHandle,
                 IOCTL_NDISWAN_UNROUTE,
                 (PBYTE) &rinfo,
                 sizeof(rinfo),
                 NULL,
                 0,
                 (LPDWORD) &bytesrecvd,
                 NULL
                 );

		RasmanTrace(
		    
		    "DeActivated Route , bundlehandle 0x%x,"
		    " prottype = %d",
		    rinfo.hBundleHandle,
		    rinfo.usProtocolType);

        //
        // Reset the window size we might have set. 
        // Don't care about the error.
        //
        (void)DwResetTcpWindowSize(prot->PI_AdapterName);

    }

    prot->PI_Allocated--;

    if(ASYBEUI == prot->PI_Type)
    {
        g_cNbfAllocated -= 1;

        RasmanTrace(
               "DeAllocateRoute: cNbfAllocated = %d",
               g_cNbfAllocated);
    }

	RasmanTrace(
	    
	    "DeAllocateRoute: PI_Type=0x%x, PI_AdapterName=%s,"
	    " PI_Allocated=%d",
    	prot->PI_Type,
    	prot->PI_AdapterName,
    	prot->PI_Allocated);
}

/*++

Routine Description:

    Adds a list element pointing to the deviceCB.
    This marks that the device has been used in
    the connection on the port. This will be used
    to clear up the data structures in the device dll.

Arguments:

    ppcb

    device

Return Value:

    LocalAlloc errors if memory allocation fails

--*/
DWORD
AddDeviceToDeviceList (pPCB ppcb, pDeviceCB device)
{
    pList   list ;

    if (NULL == (list =
        (pList) LocalAlloc(LPTR, sizeof (List))))
    {
	    return GetLastError () ;
	}

    list->L_Element = (PVOID) device ;

    list->L_Next    = ppcb->PCB_DeviceList ;

    ppcb->PCB_DeviceList = list ;

    return SUCCESS ;
}

/*++

Routine Description:

    Runs thru the list of deviceCBs pointed to and calls
    DeviceDone on all of them. The list elements are also
    freed then.

Arguments:

    ppcb

Return Value:

    void

--*/
VOID
FreeDeviceList (pPCB ppcb)
{
    pList   list ;
    pList   next ;

    for (list = ppcb->PCB_DeviceList; list; list = next)
    {
	    DEVICEDONE(((pDeviceCB)list->L_Element),
	                    ppcb->PCB_PortFileHandle);
	
    	next = list->L_Next ;
    	
	    LocalFree (list) ;
    }

    ppcb->PCB_DeviceList = NULL ;
}

/*++

Routine Description:

    Add a notification to the specified notifier list.

Arguments:

    pphlist

    hEvent

    dwfFlags

    dwPid

Return Value:

    void

--*/
DWORD
AddNotifierToList(
    pHandleList *pphlist,
    HANDLE      hEvent,
    DWORD       dwfFlags,
    DWORD       dwPid
    )
{
    pHandleList hList;

    //
    // Silently ignore NULL events.
    //
    if (hEvent == NULL)
    {
        return SUCCESS;
    }

    //
    // Silently ignore out-of-memory errors.
    //
    hList = (pHandleList)LocalAlloc(LPTR,
                                sizeof (HandleList));

    if (hList == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hList->H_Handle = hEvent;
    hList->H_Flags  = dwfFlags;
    hList->H_Pid    = dwPid;
    hList->H_Next   = *pphlist;
    *pphlist        = hList;

    return SUCCESS;
}


/*++

Routine Description:

    Add a process information block to the global
    list of client process information blocks.

Arguments:

    dwPid

Return Value:

    void

--*/
VOID
AddProcessInfo( DWORD dwPid )
{
    // HANDLE hProcess;
    ClientProcessBlock *pCPB;

    //
    // Before we attempt adding this processinfo block
    // make sure there isn't already a processblock
    // with the same pid in our list - this is possible
    // because some client process could have terminated
    // abruptly and left behind a turd for us to cleanup.
    //
    (void) CleanUpProcess(dwPid);

#if 0
    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION,
                            FALSE,
                            dwPid
                           );

    if (NULL == hProcess)
    {
        RasmanTrace(
               "AddProcessInfo: Failed to OpenProcess %d. rc=%d",
               dwPid,
               GetLastError());
        goto done;
    }
#endif    

    //
    // Create a process block
    //
    pCPB = (ClientProcessBlock *)
           LocalAlloc (LPTR, sizeof (ClientProcessBlock));

    if (NULL == pCPB)
    {

        RasmanTrace (
                "AddProcessInfo: Failed to allocate for process "
                "%d. rc=%d",
                 dwPid,
                 GetLastError());

        goto done;
    }

    //
    // Store the process handle and the pid in the
    // process block
    //
    // pCPB->CPB_hProcess  = hProcess;
    pCPB->CPB_Pid       = dwPid;

    //
    // Insert the entry in the global list
    //
    InsertTailList(&ClientProcessBlockList, &pCPB->CPB_ListEntry);

done:
    return;

}

/*++

Routine Description:

    Find the process information block give the
    pid of the prcess

Arguments:

    dwPid

Return Value:

    ClientProcessblock * if the process information
    block is found. NULL otherwise

--*/
ClientProcessBlock *
FindProcess( DWORD dwPid )
{
    PLIST_ENTRY         pEntry;
    ClientProcessBlock *pCPB;

    for (pEntry = ClientProcessBlockList.Flink;
         pEntry != &ClientProcessBlockList;
         pEntry = pEntry->Flink)
    {
        pCPB = CONTAINING_RECORD(pEntry,
                             ClientProcessBlock,
                             CPB_ListEntry);

        if (pCPB->CPB_Pid == dwPid)
        {
            return pCPB;
        }
    }

    return NULL;
}


/*++

Routine Description:

    Find out if the process represented by hProcess
    is alive

Arguments:

    hProcess

Return Value:

    TRUE if the process is alive, FALSE otherwise

--*/
BOOL
fIsProcessAlive ( HANDLE hProcess )
{
    DWORD   dwExitCode;
    BOOL    fAlive = TRUE;

    if(NULL == hProcess)
    {
        RasmanTrace(
               "fIsProcessAlive: hProcess==NULL");
               
        return FALSE;
    }

    if(GetExitCodeProcess(hProcess, &dwExitCode))
    {
        if (STILL_ACTIVE != dwExitCode)
        {
            fAlive = FALSE;
        }
    }
    else
    {
        RasmanTrace(
               "GetExitCodeProcess 0x%x failed. gle=0x%x",
               hProcess,
               GetLastError());
    }

    return fAlive;
}

/*++

Routine Description:

    Cleanup the resources held by the process with pid
    dwPid

Arguments:

    dwPid

Return Value:

    TRUE if the process was cleaned up. FALSE otherwise

--*/
BOOL
CleanUpProcess( DWORD dwPid )
{

    ClientProcessBlock * pCPB;
    BOOL                fResult = TRUE;
    pHandleList         pList = pConnectionNotifierList;

    RasmanTrace( "Cleaning up process %d", dwPid);

    pCPB = FindProcess (dwPid);

    if (NULL == pCPB)
    {
        RasmanTrace(
               "CleanUpProcess: Process %d not found!",
               dwPid);

        fResult = FALSE;

        goto done;
    }

    //
    // Free up the notifier List owned by this process
    // here
    //
    while (pList)
    {
        if (pList->H_Pid == dwPid)
        {

            RasmanTrace(
                   "Freeing handle for %d", dwPid);

            try
            {
                FreeNotifierHandle( pList->H_Handle );
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                RasmanTrace(
                       "Exception while freeing handle 0x%x"
                       " exception=0x%x",
                       pList->H_Handle,
                       GetExceptionCode());
            }

            pList->H_Handle = INVALID_HANDLE_VALUE;
        }

        pList = pList->H_Next;
    }

#if 0
    try
    {
        CloseHandle(pCPB->CPB_hProcess);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        RasmanTrace(
               "Exception while closing handle 0x%x"
               " exception=0x%x",
               pCPB->CPB_hProcess,
               GetExceptionCode());
    }
#endif    

    RemoveEntryList(&pCPB->CPB_ListEntry);

    LocalFree (pCPB);

done:
    return fResult;

}

/*++

Routine Description:

    Frees a list of notifiers.

Arguments:

    pHandleList

Return Value:

    void
--*/
VOID
FreeNotifierList (pHandleList *orglist)
{
    pHandleList     hlist ;
    pHandleList     next ;

    for (hlist = *orglist; hlist; hlist = next)
    {
        next = hlist->H_Next ;
        FreeNotifierHandle (hlist->H_Handle) ;
        LocalFree (hlist) ;
    }

    *orglist = NULL ;
}


/*++

Routine Description:

    Adds a notifier to the head of. global
    g_pPnPNotifierList

Arguments:

    pNotifier

Return Value:

    void

--*/
VOID
AddPnPNotifierToList (pPnPNotifierList pNotifier)
{

    pNotifier->PNPNotif_Next = g_pPnPNotifierList;

    g_pPnPNotifierList = pNotifier;

    return;
}

VOID
RemovePnPNotifierFromList(PAPCFUNC pfn)
{
    pPnPNotifierList *ppList = &g_pPnPNotifierList;

    while(NULL != *ppList)
    {
        if((*ppList)->PNPNotif_uNotifier.pfnPnPNotifHandler == pfn)
        {
            pPnPNotifierList pNotifier = *ppList;
            *ppList = (*ppList)->PNPNotif_Next;
            LocalFree(pNotifier);
            break;
        }

        ppList = &((*ppList)->PNPNotif_Next);
    }
}

/*++

Routine Description:

    Frees the global list of PnP notifiers

Arguments:

    void

Return Value:

    void

--*/
VOID
FreePnPNotifierList ()
{
    pPnPNotifierList    pList = g_pPnPNotifierList;
    pPnPNotifierList    pTemp;

    while ( pList )
    {
        pTemp = pList;
        pList = pList->PNPNotif_Next;

        LocalFree ( pTemp );
    }

    return;
}

/*++

Routine Description:

    Runs thorugh a list of notifiers and calls the signalling
    routine. Frees the global list of PnP notifiers

Arguments:

    hlist

    dwEvent

    retcode

Return Value:

    void

--*/
VOID
SignalNotifiers (pHandleList hlist, DWORD dwEvent, DWORD retcode)
{

    for (; hlist; hlist = hlist->H_Next)
    {
        if (hlist->H_Flags & dwEvent)
        {
            if(     (INVALID_HANDLE_VALUE != hlist->H_Handle)
                &&  (NULL != hlist->H_Handle))
            {
                SetEvent (hlist->H_Handle);
            }
        }
    }
}

/*++

Routine Description:

    Signals the port's notifier list and I/O completion
    port of a disconnect event routine.

Arguments:

    ppcb

    retcode

Return Value:

    void

--*/
VOID
SignalPortDisconnect(pPCB ppcb, DWORD retcode)
{
    SignalNotifiers(ppcb->PCB_NotifierList,
                    NOTIF_DISCONNECT,
                    retcode);

    if (ppcb->PCB_IoCompletionPort != INVALID_HANDLE_VALUE)
    {
        RasmanTrace(
	          "SignalPortDisconnect: pOverlapped=0x%x",
	          ppcb->PCB_OvDrop);
	
        PostQueuedCompletionStatus(
        ppcb->PCB_IoCompletionPort,
        0,
        0,
        ppcb->PCB_OvDrop);
    }

    SendDisconnectNotificationToPPP ( ppcb );
}

/*++

Routine Description:

    Disconnects the port in question. Since disconnection
    is an async operation - if it completes synchronously,
    then SUCCESS is returned and the app is signalled
    asynchronously also.

Arguments:

    ppcb

    handle

    reason

Return Value:

    Error codes returned by the Media DLL if failed.
    SUCCESS otherwise

--*/
DWORD
DisconnectPort (pPCB ppcb,
                HANDLE handle,
                RASMAN_DISCONNECT_REASON reason)
{
    pList list ;

    pList temp ;

    DWORD retcode ;

    NDISWAN_UNROUTE rinfo ;

    DWORD bytesrecvd ;

    DWORD dwBundleCount = 0;

    HBUNDLE hBundle = 0;

    RasmanTrace(
           "Disconnecting Port 0x%s, reason %d",
    	ppcb->PCB_Name,
    	reason);

    if(ppcb->PCB_ConnState == LISTENING)
    {
        RasmanTrace(
               "DisconnectPort: disconnecting port %d which is listening",
               ppcb->PCB_PortHandle);
               
    }

    //
    // Get the stats are store them - for displaying
    // when we are not connected
    //
    if (ppcb->PCB_ConnState == CONNECTED)
    {
        DWORD stats[MAX_STATISTICS];

        RasmanTrace(
               "DisconnectPort: Saving Bundle stats for port %s",
               ppcb->PCB_Name);

        GetBundleStatisticsFromNdisWan (ppcb, stats) ;

        //
        // We save the bundle stats for the port so
        // the server can report the correct bytes
        // sent/received for the connection in its
        // error log report.
        //
        memcpy(ppcb->PCB_Stats, stats, sizeof (WAN_STATS));

        //
        // If this is the last port and its going away
        // then delete the credentials from credential
        // manager
        //
        if(     (NULL != ppcb->PCB_Connection)
            &&  (ppcb->PCB_Connection->CB_Signaled)
            &&  (1 == ppcb->PCB_Connection->CB_Ports)
            &&  (ppcb->PCB_Connection->CB_dwPid != GetCurrentProcessId()))
        {
            DWORD dwErr;
            
            dwErr = DwDeleteCredentials(ppcb->PCB_Connection);

            RasmanTrace(
                    "DisconnectPort: DwDeleteCreds returned 0x%x",
                     dwErr);
        }   
    }

    if(NULL != ppcb->PCB_Connection)
    {
        BOOL fQueued = FALSE;
        
        if(ppcb->PCB_Connection->CB_Flags & CONNECTION_DEFERRED_CLOSE)
        {
            RasmanTrace("DisconnectPort: CONNECTION_DEFERRED_CLOSE");
        }
        else if(ppcb->PCB_Connection->CB_Flags & CONNECTION_DEFERRING_CLOSE)
        {
            //
            // This port is in already disconnecting state
            //
            RasmanTrace("DisconnectPort: CONNECTION_DEFERRING_CLOSE");
            FreeNotifierHandle(handle);
            return ERROR_ALREADY_DISCONNECTING;
        }
        else
        {
            QueueCloseConnections(ppcb->PCB_Connection, handle, &fQueued);
            if(fQueued)
            {
                RasmanTrace("DisconnectPort: Deferring Disconnect.");
                return PENDING;
            }
        }
    }

#if UNMAP
    UnmapEndPoint(ppcb);
#endif    

    //
    // Set the port file handle back to the io handle since
    // the io handle is the only valid handle after a
    // disconnect.
    //
    ppcb->PCB_PortFileHandle = ppcb->PCB_PortIOHandle ;

    //
    // If there is a request pending and the state is
    // not already disconnecting and this is a user
    // requested operation - then complete the
    // request.
    //
    if (	(reason == USER_REQUESTED)
    	&&  (ppcb->PCB_ConnState != DISCONNECTING))
    {

	    if (ppcb->PCB_ConnState == CONNECTED)
	    {
            //
	        // In connected state the only thing pending is
	        // a read posted by rasman: if there is a read
	        // request pending - clean that.
        	//
	        if (ppcb->PCB_PendingReceive != NULL)
	        {
                //
                // Don't overwrite the real error if we
                // have it stored.
                //
                if(     (SUCCESS == ppcb->PCB_LastError)
                    ||  (PENDING == ppcb->PCB_LastError))
                {
    		        ppcb->PCB_LastError = ERROR_PORT_DISCONNECTED ;
		        }
		
    		    CompleteAsyncRequest (ppcb);
    		
    		    RasmanTrace(
    		           "1. Notifying of disconnect on port %d",
    		           ppcb->PCB_PortHandle);
    		
        		FreeNotifierHandle(
        		    ppcb->PCB_AsyncWorkerElement.WE_Notifier
        		    );
        		
	        	ppcb->PCB_AsyncWorkerElement.WE_Notifier =
	        	                    INVALID_HANDLE_VALUE;
	        	
	        	if (ppcb->PCB_RasmanReceiveFlags
	        	    & RECEIVE_OUTOF_PROCESS)
	        	{
	        	    //
	        	    // This means rasman allocated the buffer
	        	    // and so client is not going to free this
	        	    // memory.
	        	    //
	        	    LocalFree ( ppcb->PCB_PendingReceive );

	        	    ppcb->PCB_PendingReceive = NULL;
	        	}
	        	else
	        	{
	        	    SendDisconnectNotificationToPPP ( ppcb );
	        	}
	        	
    	    	ppcb->PCB_PendingReceive = NULL;
        	}

	    }
	    else if (ppcb->PCB_AsyncWorkerElement.WE_ReqType
	            != REQTYPE_NONE)
	    {
            //
	        // Not connected - some other operation may be
	        // pending - complete it.
        	//
        	if(     (SUCCESS == ppcb->PCB_LastError)
                ||  (PENDING == ppcb->PCB_LastError))
        	{
    	        ppcb->PCB_LastError = ERROR_PORT_DISCONNECTED ;
	        }
	
    	    CompleteAsyncRequest (ppcb);
    	
   		    RasmanTrace(
  		           "2. Notifying event on port %d",
   		           ppcb->PCB_PortHandle);
   		
        	FreeNotifierHandle(
        	        ppcb->PCB_AsyncWorkerElement.WE_Notifier
        	        );

	        ppcb->PCB_AsyncWorkerElement.WE_Notifier =
	                                    INVALID_HANDLE_VALUE ;
	                                    
            RemoveTimeoutElement(ppcb);
            ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = NULL;
            

            //SendDisconnectNotificationToPPP( ppcb );
    	}
    }
    else if(USER_REQUESTED != reason)
    {
        //
        // if a receive is pending then free the notifier
        // but do not notify since the cancelreceive is
        // used by the client
        //
        RasmanTrace(
               "10. Throwing away handle 0x%x!",
                ppcb->PCB_AsyncWorkerElement.WE_Notifier);

        //
        // Put in because on the server side the receive
        // request handle is not
        // being freed
        //
        FreeNotifierHandle(
                ppcb->PCB_AsyncWorkerElement.WE_Notifier
                );

	    ppcb->PCB_AsyncWorkerElement.WE_Notifier =
	                                INVALID_HANDLE_VALUE ;
    }

    //
    // Complete pending out-of-process receives if
    // one is pending - there is no point in keeping
    // this buffer around.
    //
    if(RECEIVE_WAITING & ppcb->PCB_RasmanReceiveFlags)
    {
        RasmanTrace(
            
            "Completing pending OUT_OF_PROCESS receive on port %s",
            ppcb->PCB_Name);

        //
        // remove the timeout element if there was one
        //
        //
        if (ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement != NULL)
        {
            RemoveTimeoutElement(ppcb);
            ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = NULL;
        }
                    
        ppcb->PCB_RasmanReceiveFlags = 0;
    }

    //
	// If we are already disconnecting - then return
	// PENDING. ** NOTE ** Since we only store one
	// event - the event passed in this request is
    // ignored.
    //
	if (    (INVALID_HANDLE_VALUE !=
	        ppcb->PCB_AsyncWorkerElement.WE_Notifier)
	    &&  (ppcb->PCB_ConnState == DISCONNECTING))
	{
	    RasmanTrace(
	           "DisconnectPort: Throwing away notification "
	           "handle 0x%x on port %s",
	           handle, ppcb->PCB_Name);

        RasmanTrace(
               "DisconnectPort: Current handle=0x%x",
               ppcb->PCB_AsyncWorkerElement.WE_Notifier);

        //
        // since we are ignoring the notification handle
        //
  	    FreeNotifierHandle (handle);
   		return ERROR_ALREADY_DISCONNECTING ;
    }
    else if(    (INVALID_HANDLE_VALUE != handle)
            &&  (DISCONNECTING == ppcb->PCB_ConnState))
    {
        RasmanTrace(
               "Queueing event on a DISCONNECTING port %s",
               ppcb->PCB_Name);

	    ppcb->PCB_AsyncWorkerElement.WE_Notifier = handle;

	    return PENDING;
    }

    // If already disconnected - simply return success.
   	//
    if (ppcb->PCB_ConnState == DISCONNECTED)
    {
    	ppcb->PCB_AsyncWorkerElement.WE_Notifier = handle ;
    	
    	RasmanTrace(
    	       "4. Notifying of disconnect on port %d",
    	       ppcb->PCB_PortHandle);
    	
    	CompleteDisconnectRequest (ppcb) ;

        // SendDisconnectNotificationToPPP ( ppcb );
    	
    	return SUCCESS ;
   	}
   	
    //
    // If some other operation is pending we must remove
    // it from the timeout queue before starting on
    // disconnection:
    //
   	if (NULL !=
   	    ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement)
   	{
	    RemoveTimeoutElement (ppcb) ;
	
   		ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = NULL ;
    }

    //
    // Check to see if this port belongs to a
    // connection where the process that has
    // created it has terminated, or the port
    // has not been disconnected due to user
    // request.  In this case, we automatically
    // close the port so that if the RAS server
    // is running, the listen will get reposted
    // on the port.
    //
    if (	ppcb->PCB_Connection != NULL
    	&&	reason != USER_REQUESTED)
    {
    	RasmanTrace(
    	       "%s, %d:Setting port %d for autoclosure...",
        	  __FILE__, __LINE__,
        	  ppcb->PCB_PortHandle);
        	
        ppcb->PCB_AutoClose = TRUE;

    }

    retcode =
        PORTDISCONNECT(ppcb->PCB_Media, ppcb->PCB_PortIOHandle);

    RasmanTrace(
           "%s %d: Disconnected Port %d, reason %d. rc=0x%x",
    	   __FILE__, __LINE__,
    	   ppcb->PCB_PortHandle,
    	   reason,
    	   retcode);

    //
    // If this failed for any reason LOG IT.
    //
    if (	(retcode != SUCCESS)
    	&&	(retcode != PENDING))
    {
	    LPSTR temp = ppcb->PCB_Name ;

	    RasmanTrace(
	           "PortDisconnect failed on port %d. retcode = %d",
	           ppcb->PCB_PortHandle, retcode);
	
    	RouterLogErrorString (
    	                hLogEvents,
                        ROUTERLOG_DISCONNECT_ERROR,
                        1,
                        (LPSTR*)&temp,
                        retcode,
                        1) ;
    }

    //
    // Flush the queue of PPP events.
    //
    while (ppcb->PCB_PppQHead != NULL)
    {
        PPP_MESSAGE * pPppMsg = ppcb->PCB_PppQHead;

        ppcb->PCB_PppQHead = ppcb->PCB_PppQHead->pNext;

        LocalFree( pPppMsg );
    }

    ppcb->PCB_PppQTail = NULL;

    //
    // Close the PCB_PppEvent handle.  It will
    // get recreated the next time PppStart
    // is called.
    //
    if (ppcb->PCB_PppEvent != INVALID_HANDLE_VALUE)
    {
        CloseHandle(ppcb->PCB_PppEvent);
        ppcb->PCB_PppEvent = INVALID_HANDLE_VALUE;
    }

    //
    // Call the device dlls to clean up:
    //
    if (	(ppcb->PCB_ConnState==CONNECTING)
    	||	(ppcb->PCB_ConnState==LISTENING)
    	||	(ppcb->PCB_ConnState==LISTENCOMPLETED))
    {    	
        FreeDeviceList (ppcb) ;
    }

    //
    // Unrouting works differently for Bundled and
    // unbundled cases:
    //
    if (ppcb->PCB_Bundle == (Bundle *) NULL)
    {
        //
        // Mark the allocated routes as deactivated.
        //
        for (list = ppcb->PCB_Bindings;
             list;
             list=list->L_Next)
        {
            if (list->L_Activated)
            {
#if DBG
                ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif
                rinfo.hBundleHandle = ppcb->PCB_BundleHandle ;

                rinfo.usProtocolType =
                        (USHORT)((pProtInfo)(list->L_Element))->PI_Type;

                //
                // Un-route this by calling to the RASHUB.
                //
                DeviceIoControl (
                    RasHubHandle,
                    IOCTL_NDISWAN_UNROUTE,
                    (PBYTE) &rinfo,
                    sizeof(rinfo),
                    NULL,
                    0,
                    &bytesrecvd,
                    NULL
                    );

				RasmanTrace(
				       "%s, %d: DeActivated Route for %s(0x%x) , "
				       "bundlehandle 0x%x, prottype = %d",
					__FILE__, __LINE__,
					ppcb->PCB_Name,
					ppcb,
					rinfo.hBundleHandle,
					rinfo.usProtocolType);

                list->L_Activated = FALSE ;
            }
        }
    }
	else
	{
	    BOOL fAsybeui = FALSE;
	
        //
	   	// If this is the last multilinked link -
	   	// then revert back the binding list to
	   	// this port.
	   	//
    	dwBundleCount = --ppcb->PCB_Bundle->B_Count;
	   	if (ppcb->PCB_Bundle->B_Count == 0)
    	{
    	    //
		    // Mark the allocated routes as deactivated.
    	   	//
	        for (list = ppcb->PCB_Bundle->B_Bindings;
	             list;
	             list=list->L_Next)
   		    {
       			if (list->L_Activated)
        		{
#if DBG
                    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif
                    rinfo.hBundleHandle = ppcb->PCB_BundleHandle;

                    rinfo.usProtocolType =
                    (USHORT)((pProtInfo)(list->L_Element))->PI_Type;

                    if(ASYBEUI == rinfo.usProtocolType)
                    {
                        fAsybeui = TRUE;
                    }

                    //
                    // Un-route this by calling to the RASHUB.
                    //
                    DeviceIoControl (
                                   RasHubHandle,
                    	           IOCTL_NDISWAN_UNROUTE,
                        	       (PBYTE) &rinfo,
                    	    	   sizeof(rinfo),
                           	       NULL,
                                   0,
                        	       &bytesrecvd,
                            	   NULL) ;

                    RasmanTrace(
                       "%s, %d: DeActivated Route for %s(0x%x),"
                       " bundlehandle 0x%x, prottype = %d",
                    	   __FILE__, __LINE__,
                    	   ppcb->PCB_Name,
                    	   ppcb,
                    	   rinfo.hBundleHandle,
                    	   rinfo.usProtocolType);

                    list->L_Activated = FALSE ;
   			    }
	       	}

			if(     fAsybeui
			    &&  (NULL == ppcb->PCB_Connection)
			    &&  !(ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPSTARTED))
			{
                ppcb->PCB_fAmb = TRUE;

                //ppcb->PCB_Bundle->B_fAmb = TRUE;

			    //
			    // Don't NULL this out in the case where
			    // its netbeui. Otherwise this breaks
			    // callbacks on amb/netbeui. This will be
			    // NULL'd out in RasDeallocateRoute.
			    //
			    ppcb->PCB_Bindings =
			            ppcb->PCB_Bundle->B_Bindings;

                RasmanTrace(
                       "Keeping bindings 0x%x on the "
                       "port for %s, bundle=0x%x",
                       ppcb->PCB_Bindings,
                       ppcb->PCB_Name,
                       ppcb->PCB_Bundle);
			
			}
            else
            {
    			ppcb->PCB_Bindings = NULL;
			}
    	
	        if (ppcb->PCB_Bundle->B_Bindings != NULL)
   		    {
       			//
           		// If the bundle has bindings, it will
	            // be deallocated via RasDeallocateRoute().
   		        //
       		    hBundle = ppcb->PCB_Bundle->B_Handle;
	        }
   		    else
   		    {
   		
       	        FreeBundle(ppcb->PCB_Bundle);

       	        ppcb->PCB_Bundle = ( Bundle * ) NULL;
       	    }

		}

	    if (NULL == ppcb->PCB_Connection)	
	    {
   		    ppcb->PCB_Bundle = (Bundle *) NULL ;
   		}
    }

    ppcb->PCB_LinkHandle = INVALID_HANDLE_VALUE ;
    ppcb->PCB_BundleHandle = INVALID_HANDLE_VALUE ;

    //
    // If there is any disconnect action to be
    // performed - do it.
    //
    PerformDisconnectAction (ppcb, hBundle) ;

    //
    // If the disconnect occured due some failure
    // (not user requested) then set the error code
    // to say this
    //
    ppcb->PCB_DisconnectReason = reason ;

    if (	SUCCESS != retcode
    	&&	PENDING != retcode)
    {
    	RasmanTrace(
    	       "%s, %d: retcode = 0x%x, port = %d",
    	       __FILE__, __LINE__,
    		   retcode,
    		   ppcb->PCB_PortHandle);
    		
    	SetPortConnState(__FILE__, __LINE__,
    	                ppcb,
    	                DISCONNECTED);
    }
    else
    {
	    SetPortConnState(__FILE__, __LINE__,
	                    ppcb,
	                    DISCONNECTING);
	}

    //
    // Flush any pending receive buffers from this port
    //
    FlushPcbReceivePackets(ppcb);

    //
    // For all cases: whether rasman requested or user
    // requested.
    //
    if ( retcode == SUCCESS )
    {
        SetPortConnState(__FILE__, __LINE__,
                        ppcb,
                        DISCONNECTED);
        //
        // Inform others the port has been disconnected.
        //
        RasmanTrace(
               "5. Notifying of disconnect on port %d",
               ppcb->PCB_PortHandle);

        SignalPortDisconnect(ppcb, 0);

        SignalNotifiers(pConnectionNotifierList,
                        NOTIF_DISCONNECT,
                        0);

        //SendDisconnectNotificationToPPP ( ppcb );
    }

    //
    // Set last error to the true retcode ONLY if this is a
    // USER_REQUESTED operation. Else set it to
    // ERROR_PORT_DISCONNECTED.
    //
    if (reason == USER_REQUESTED)
    {
	    if (	(retcode == SUCCESS)
	    	||	(retcode == PENDING))
	    {

	        if(     (SUCCESS == ppcb->PCB_LastError)
	            ||  (PENDING == ppcb->PCB_LastError))
	        {
    	        //
    	        // Set only for normal disconnect
    	        //
        	    ppcb->PCB_LastError = retcode ;
    	    }
    	}
	    else
	    {
		    ppcb->PCB_LastError = ERROR_PORT_DISCONNECTED ;
		}
    }		

    //
    // If the handle passed in is INVALID_HANDLE then this
    // is not an operation requested asynchronously. So we
    // do not need to marshall the asyncworkerlement for
    // the port. We also do not need to keep the lasterror .
    //
    if (handle != INVALID_HANDLE_VALUE)
    {
	    ppcb->PCB_AsyncWorkerElement.WE_Notifier = handle ;
	
	    SetPortAsyncReqType(__FILE__, __LINE__,
	                        ppcb,
	                        REQTYPE_PORTDISCONNECT);

        if (retcode == PENDING)
	    {
	        //
	        // This is added so that if some medias do not
	        // drop their connection within X amount of time
	        // - we force a disconnect.
        	//

            //
	        // If some other operation is pending we must
	        // remove it from the timeout queue before
	        // starting on disconnection:
        	//
	        if (NULL !=
	            ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement)
	        {
    	    	RemoveTimeoutElement (ppcb) ;
    	    	
	        	ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement
	        	                                            = NULL;
    	    }

        	ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement =
	        AddTimeoutElement ((TIMERFUNC)DisconnectTimeout,
    			               ppcb,
                			   NULL,
			                   DISCONNECT_TIMEOUT);

            AdjustTimer();
        	
	        return retcode ;
    	}
        else
        {
            //
    	    // This means that the connection attempt completed
    	    // synchronously: We must signal the event passed in
    	    // : so that the calling program can treat this like
    	    // a real async completion.
	        //
	        RasmanTrace(
	                "6. Notifying of disconnect on port %d",
	                ppcb->PCB_PortHandle);
	
        	CompleteDisconnectRequest (ppcb) ;
        }
    }
    else
    {
        //
	    // Make sure that the async worker element is set to
	    // REQTYPE_NONE
    	//
    	SetPortAsyncReqType(__FILE__, __LINE__,
    	                    ppcb,
    	                    REQTYPE_NONE);
    	
	    ppcb->PCB_AsyncWorkerElement.WE_Notifier =
	                            INVALID_HANDLE_VALUE ;
	
        if(SUCCESS == retcode)
        {
            ConnectionBlock *pConn = ppcb->PCB_Connection;

            RasmanTrace(
                   "***** DisconnectReason=%d,"
                   "pConn=0x%x,cbports=%d,signaled=%d,hEvent=0x%x,"
                   "fRedial=%d",
                   ppcb->PCB_DisconnectReason,
                   pConn,
                   (pConn)?pConn->CB_Ports:0,
                   (pConn)?pConn->CB_Signaled:0,
                   ppcb->PCB_hEventClientDisconnect,
                   ppcb->PCB_fRedial);
                   

            if (    (   (ppcb->PCB_DisconnectReason != USER_REQUESTED)
                    || (ppcb->PCB_fRedial))
                &&  (pConn != NULL)
                &&  (pConn->CB_Ports == 1)
                &&  (pConn->CB_Signaled)
                &&  ((INVALID_HANDLE_VALUE 
                        == ppcb->PCB_hEventClientDisconnect)
                    ||  (NULL == ppcb->PCB_hEventClientDisconnect)))
            {
                DWORD dwErr;
                RasmanTrace(
                       "Calling DwQueueRedial");

                dwErr = DwQueueRedial(pConn);

                RasmanTrace(
                       "DwQueueRedial returned 0x%x",
                       dwErr);

            }
            else
            {
                if(     (INVALID_HANDLE_VALUE != ppcb->PCB_hEventClientDisconnect)
                    ||  (NULL != ppcb->PCB_hEventClientDisconnect))
                {
                    RasmanTrace(
                   "Not queueing redial because its client initiated"
                   " disconnect on port %s",
                   ppcb->PCB_Name);
                }
            }

            if (ppcb->PCB_AutoClose)
            {
            	RasmanTrace(
            	    
            	    "%s, %d: Autoclosing port %d", __FILE__,
            		__LINE__, ppcb->PCB_PortHandle);
            		
                (void)PortClose(ppcb, GetCurrentProcessId(),
                                TRUE, FALSE);

            }
        }
    }

    RasmanTrace( "DisconnectPort Complete");
    return retcode ;
}

/*++

Routine Description:

    This is the shared code between the Listen and Connect
    requests. The corresponding device dll functions are
    called. If these async operations complete synchronously
    then we return SUCCESS but also comply to the async
    protocol by clearing the events. Note that in case
    of an error the state of the port is left at CONNECTING
    or LISTENING, the calling app must call Disconnect()
    to reset this.

Arguments:

    reqtype

    ppcb

    devicetype

    devicename

    timeout

    handle

Return Value:

    Codes returned by the loader or the device dll.

--*/
DWORD
ListenConnectRequest (
              WORD  reqtype,
              pPCB  ppcb,
              PCHAR devicetype,
              PCHAR devicename,
              DWORD timeout,
              HANDLE    handle
              )
{
    pDeviceCB device ;
    DWORD retcode ;

    //
    // If some other operation is pending we must remove it
    // from the timeout queue before starting on
    // connect/listen:
    //
    if (ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement != NULL)
    {
	    RemoveTimeoutElement (ppcb) ;
    	ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = NULL ;
    }

    ppcb->PCB_AsyncWorkerElement.WE_Notifier = handle ;

    //
    // If this is the first device connecting or listening on
    // this port then we need to call the media dll to do any
    // initializations:
    //
    if (    (ppcb->PCB_ConnState!=CONNECTING)
        ||  (ppcb->PCB_ConnState!=LISTENING))
    {
	    retcode = PORTINIT(ppcb->PCB_Media, ppcb->PCB_PortIOHandle) ;
	
    	if (retcode)
    	{
        	return retcode ;
	    }
    }

    //
    // First check if device dll is loaded. If not loaded -
    // load it.
    //
    device = LoadDeviceDLL (ppcb, devicetype) ;

    if (device == NULL)
    {
	    return ERROR_DEVICE_DOES_NOT_EXIST ;
    }

    //
    // We attach the device to the list of devices in the PCB
    // that the app uses - this is used for cleanup of the
    // device dll data structures after the connection is done.
    //
    if (SUCCESS !=
       (retcode = AddDeviceToDeviceList (ppcb, device)))
    {
	    return retcode ;
    }

    //
    // If another async request is pending this will return
    // with an error.
    //
    if (ppcb->PCB_AsyncWorkerElement.WE_ReqType != REQTYPE_NONE)
    {
    	RasmanTrace(
    	       "Returning ERROR_ASYNC_REQUEST_PENDING for "
    	       "reqtype %d",
  			   ppcb->PCB_AsyncWorkerElement.WE_ReqType);

	    return ERROR_ASYNC_REQUEST_PENDING ;
    }

    //
    // The appropriate device dll call is made here:
    //
    if (reqtype == REQTYPE_DEVICECONNECT)
    {
	    retcode = DEVICECONNECT (device,
    				             ppcb->PCB_PortFileHandle,
				                 devicetype,
				                 devicename);
				
	    SetPortConnState(__FILE__, __LINE__,
	                    ppcb, CONNECTING);
	
	    ppcb->PCB_CurrentUsage  |= CALL_OUT ;
	
    	ppcb->PCB_CurrentUsage &= ~CALL_IN;
    }
    else
    {
	    retcode = DEVICELISTEN  (device,
    				             ppcb->PCB_PortFileHandle,
				                 devicetype,
				                 devicename);
				
	    SetPortConnState(__FILE__, __LINE__,
	                     ppcb, LISTENING);
	
	    ppcb->PCB_CurrentUsage |= CALL_IN ;
	
    	ppcb->PCB_CurrentUsage &= ~CALL_OUT;
    }

    //
    // Set some of this information unconditionally
    //
    ppcb->PCB_LastError = retcode ;

    //ppcb->PCB_AsyncWorkerElement.WE_Notifier = handle ;

    strcpy (ppcb->PCB_DeviceTypeConnecting,
            devicetype) ;

    strcpy (ppcb->PCB_DeviceConnecting,
            devicename) ;

    switch (retcode)
    {
    case PENDING:
        //
	    // The connection attempt was successfully initiated:
	    // make sure that the async operation struct in the
	    // PCB is initialised.
    	//
    	SetPortAsyncReqType(__FILE__, __LINE__,
    	                    ppcb,
    	                    reqtype);
    	
        //
	    // Add this async request to the timer queue if a
	    // timeout is specified:
    	//
	    if ((timeout != INFINITE) && (timeout != 0))
	    {
	       RasmanTrace(
	              "Adding timeout of %d for listen",
	              timeout );
	
    	   ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement =
        			       AddTimeoutElement (
        			            (TIMERFUNC)ListenConnectTimeout,
                    			ppcb,
						        NULL,
						        timeout
						        );

            AdjustTimer();
            						
        }						
	    break ;


    case SUCCESS:

        //
    	// This means that the connection attempt completed
    	// synchronously: We must signal the event passed in:
    	// so that the calling program can treat this like a
    	// real async completion. This is done when this
	    // function returns.
    	//
    	
    default:

        //
    	// Some error occured - simply pass the error back to
    	// the app. We do not set the state to DISCONNECT(ED/ING)
    	// because we want the app to recover any information
    	// about this before explicitly discnnecting.
	    //

    	break ;
    }

    return retcode ;
}

/*++

Routine Description:

    Cancels receives if they are pending

Arguments:

    ppcb

Return Value:

    TRUE if successful , FALSE otherwise

--*/
BOOL
CancelPendingReceive (pPCB ppcb)
{
    DWORD    bytesrecvd ;

    //
    // If any reads are pending with the Hub cancel them:
    //
    if (ppcb->PCB_AsyncWorkerElement.WE_ReqType
        == REQTYPE_PORTRECEIVEHUB)
    {
        //
	    // Nothing to be done. The actual receives to
	    // the hub are left intact
	    //
    }
    else if (ppcb->PCB_AsyncWorkerElement.WE_ReqType
             == REQTYPE_PORTRECEIVE)
    {
    	PORTCOMPLETERECEIVE(ppcb->PCB_Media,
    	                    ppcb->PCB_PortIOHandle,
    	                    &bytesrecvd) ;
    }
    else
    {
	    return FALSE ;
	}

    ppcb->PCB_BytesReceived = 0 ;
	ppcb->PCB_PendingReceive = NULL ;

    return TRUE ;
}

/*++

Routine Description:

    Cancels receives if they are pending

Arguments:

    ppcb

Return Value:

    TRUE if receive was pending and was cancelled
    FALSE if no receive was pending

--*/
BOOL
CancelPendingReceiveBuffers (pPCB ppcb)
{
    DWORD    bytesrecvd ;

    //
    // If any reads are pending with the Hub cancel them:
    //
    if (ppcb->PCB_AsyncWorkerElement.WE_ReqType
        == REQTYPE_PORTRECEIVEHUB)
    {

#if DBG
        ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif
        DeviceIoControl (
                    RasHubHandle,
                    IOCTL_NDISWAN_FLUSH_RECEIVE_PACKETS,
                    NULL,
                    0,
                    NULL,
                    0,
                    &bytesrecvd,
                    NULL
                    );
    }
    else if (ppcb->PCB_AsyncWorkerElement.WE_ReqType
             == REQTYPE_PORTRECEIVE)
    {
        PORTCOMPLETERECEIVE(ppcb->PCB_Media,
                            ppcb->PCB_PortIOHandle,
                            &bytesrecvd) ;
    }
    else
    {
        return FALSE ;
    }

    ppcb->PCB_BytesReceived = 0 ;
    ppcb->PCB_PendingReceive = NULL ;

    //
    // Flush any complete receives pending on this port
    //
    FlushPcbReceivePackets(ppcb);

    return TRUE ;
}

/*++

Routine Description:

    Performs the action requested at disconnect time.
    If any errors occur - then the action is simply
    not performed.

Arguments:

    ppcb

    hBundle

Return Value:

    void

--*/
VOID
PerformDisconnectAction (pPCB ppcb, HBUNDLE hBundle)
{
    //
    // Anything to be done?
    //
    if (0 ==
        ppcb->PCB_DisconnectAction.DA_IPAddress)
    {
        //
        // no, return
        //
    	return ;
    }

    RasHelperResetDefaultInterfaceNetEx(
            ppcb->PCB_DisconnectAction.DA_IPAddress,
            ppcb->PCB_DisconnectAction.DA_Device,
            ppcb->PCB_DisconnectAction.DA_fPrioritize,
            ppcb->PCB_DisconnectAction.DA_DNSAddress,
            ppcb->PCB_DisconnectAction.DA_DNS2Address,
            ppcb->PCB_DisconnectAction.DA_WINSAddress,
            ppcb->PCB_DisconnectAction.DA_WINS2Address
            ) ;

    RasmanTrace(
           "PerformDisconnectAction: fPrioritize=%d",
           ppcb->PCB_DisconnectAction.DA_fPrioritize);

    ppcb->PCB_DisconnectAction.DA_IPAddress = 0 ;
    ppcb->PCB_DisconnectAction.DA_fPrioritize = FALSE;

    //
    // Auto-unroute IP for SLIP connections.
    //
    if (hBundle)
    {
        DeAllocateRouteRequestCommon(hBundle, IP);
    }
}

/*++

Routine Description:

    Allocates a new bundle block for a port
    if it doesn't already have one.  It is
    assumed the port is locked on entry.

Arguments:

    ppcb

Return Value:

    mem alloc errors

--*/
DWORD
AllocBundle(
    pPCB ppcb
    )
{
    ULONG ulNextBundle;

    if (ppcb->PCB_Bundle != NULL)
    {
        return 0;
    }

    //
    // Allocate a bundle block and a bundle
    // block lock.
    //
    ppcb->PCB_Bundle = (Bundle *)
                       LocalAlloc (LPTR,
                                   sizeof(Bundle));

    if (ppcb->PCB_Bundle == NULL)
    {
        return GetLastError();
    }

    //
    // Save the bundle context for later use.
    //
    ppcb->PCB_LastBundle = ppcb->PCB_Bundle;

    //
    // Increment Bundle count
    //
    ppcb->PCB_Bundle->B_Count++;

    ulNextBundle = HandleToUlong(NextBundleHandle);

    //
    // Bundle IDs stay above 0xff000000 to keep this ID
    // range separate from HPORTs.
    //
    if (ulNextBundle < 0xff000000)
    {
        NextBundleHandle = (HBUNDLE) UlongToPtr(0xff000000);
        ulNextBundle = 0xff000000;
    }

    ulNextBundle += 1;

    NextBundleHandle = (HBUNDLE) UlongToPtr(ulNextBundle);

    ppcb->PCB_Bundle->B_NdisHandle	= INVALID_HANDLE_VALUE;
    ppcb->PCB_Bundle->B_Handle		= NextBundleHandle;
    ppcb->PCB_Bundle->B_Bindings	= ppcb->PCB_Bindings;
    ppcb->PCB_Bindings				= NULL;

    //
    // Add it to the list.
    //
    InsertTailList(&BundleList, &ppcb->PCB_Bundle->B_ListEntry);

	RasmanTrace(
	       "AllocBundle: pBundle=0x%x\n",
	       ppcb->PCB_Bundle);

    return 0;
}

/*++

Routine Description:

    Find a bundle in the BundleList given its handle.

Arguments:

   hBundle

Return Value:

    Bundle *

--*/
Bundle *
FindBundle(
    HBUNDLE hBundle
    )
{
    PLIST_ENTRY pEntry;
    Bundle *pBundle;

    if (!IsListEmpty(&BundleList))
    {
        for (pEntry = BundleList.Flink;
             pEntry != &BundleList;
             pEntry = pEntry->Flink)
        {
            pBundle = CONTAINING_RECORD(pEntry, Bundle, B_ListEntry);

            if (pBundle->B_Handle == hBundle)
            {
                return pBundle;
            }
        }
    }

    return NULL;
}

VOID
FreeBapPackets()
{
    RasmanBapPacket *pPacket;
    
    if(NULL == BapBuffers)
    {
        return;
    }

    while(NULL != BapBuffers->pPacketList)
    {
        pPacket = BapBuffers->pPacketList;
        BapBuffers->pPacketList = pPacket->Next;

        LocalFree(pPacket);
    }

    LocalFree(BapBuffers);

    BapBuffers = NULL;
}


/*++

Routine Description:

    Free the bundle block passed in

Arguments:

    pBundle

Return Value:

    void
--*/
VOID
FreeBundle(
    Bundle *pBundle
    )
{
	RasmanTrace(
	       "FreeBundle: freeing pBundle=0x%x",
	       pBundle);

    RemoveEntryList(&pBundle->B_ListEntry);

    LocalFree(pBundle);
}

/*++

Routine Description:

    Copy a string

Arguments:

    lpsz

Return Value:

    address of new string if allocation
    of the string succeeded, NULL otherwise

--*/
PCHAR
CopyString(
    PCHAR lpsz
    )
{
    DWORD dwcb;
    PCHAR lpszNew;

    if (lpsz == NULL)
    {
        return NULL;
    }

    dwcb = strlen(lpsz);

    lpszNew = LocalAlloc(LPTR, dwcb + 1);

    if (lpszNew == NULL)
    {
        // Do we need to do something else here?
        return NULL;
    }

    strcpy(lpszNew, lpsz);

    return lpszNew;
}

BOOL
fIsValidConnection(ConnectionBlock *pConn)
{
    PLIST_ENTRY pEntry;
    BOOL fReturn = FALSE;
    ConnectionBlock *pConnT;

    for(pEntry = ConnectionBlockList.Flink;
        pEntry != &ConnectionBlockList;
        pEntry = pEntry->Flink)
    {
        pConnT = 
            CONTAINING_RECORD(pEntry, ConnectionBlock, CB_ListEntry);

        if(pConnT == pConn)
        {
            fReturn = TRUE;
            break;
        }
    }

    return fReturn;    
}

/*++

Routine Description:

    Clean up and free a connection block.

Arguments:

    pConn

Return Value:

    void
--*/
VOID
FreeConnection(
    ConnectionBlock *pConn
    )
{
    PLIST_ENTRY pEntry;
    ConnectionBlock *pConnT;
    DWORD dwError;
    BOOL fAutoClose = pConn->CB_fAutoClose;

    RasmanTrace(
           "FreeConnection: pConn=0x%x, %d",
           pConn,
           fAutoClose);

#if 0
    //
    // Zip through all the connections and check to
    // see if any connection is referring to this
    // connection. Bring down that connection too
    // if it is so. TODO: This could be optimized
    // by keeping an array of hconns in the prereq
    // entry - doing this for now as do not expect a
    // lot of simultaneous outgoing connections to make
    // a big performance gain
    //
    for (pEntry = ConnectionBlockList.Flink;
         pEntry != &ConnectionBlockList;
         pEntry = pEntry->Flink)
    {
        pConnT =
            CONTAINING_RECORD(pEntry, ConnectionBlock, CB_ListEntry);

        if(pConnT->CB_ReferredEntry == pConn->CB_Handle)
        {

            RasmanTrace(
                   "FreeConnection: Closing 0x%08x as the "
                   "connection it was referring to(0x%08x) "
                   "went down",
                   pConnT->CB_Handle,
                   pConn->CB_Handle);

            //
            // In this case make sure that the connection
            // is blown away
            //
            pConnT->CB_RefCount = 1;

            if(!fAutoClose)
            {
                RasmanTrace("Removing redial flag on %x",
                      pConnT->CB_Handle);
                pConnT->CB_ConnectionParams.CP_ConnectionFlags &=
                            ~(CONNECTION_REDIALONLINKFAILURE);
            }

            dwError = DwCloseConnection(pConnT->CB_Handle);

            RasmanTrace(
                   "FreeConnection: DwCloseConnection returned %d",
                   dwError);

            //
            // Check to see if the connection is still valid
            //
            if(fIsValidConnection(pConnT))
            {
                RasmanTrace(
                       "pConn 0x%x still valid ",
                       pConnT);
                //
                // Null out the prereq connection. We don't want to
                // try freeing this connection when freeconnection
                // is called for pConnT
                //
                pConnT->CB_ReferredEntry = 0;
            }
            else
            {
                RasmanTrace(
                       "pConn 0x%x not valid anymore",
                       pConnT);
            
                pEntry = ConnectionBlockList.Flink;
            }
        }
    }

#endif    

    //
    // Allocate and q a request to de-reference a referredentry if
    // one is present. Do this only if the vpn-connection is being
    // remotely disconnected. Otherwise the client will disconnect
    // the port.
    //
    if(     (fAutoClose)
        &&  (NULL != pConn->CB_ReferredEntry))
    {
        RAS_OVERLAPPED *pOverlapped = NULL;
        ConnectionBlock *pConnReferred = 
                    FindConnection(pConn->CB_ReferredEntry);

        if(NULL != pConnReferred)
        {
            //
            // Don't do a redial if this is not a client 
            // disconnect. The Vpn connection will cause
            // the inner connection to redial so no need
            // to redial explicitly.
            //
            
            RasmanTrace(
                   "Removing redial flag on %x",
                  pConnReferred->CB_Handle);
                  
            pConnReferred->CB_ConnectionParams.CP_ConnectionFlags &=
                        ~(CONNECTION_REDIALONLINKFAILURE);
        }

        pOverlapped = LocalAlloc(
                            LPTR,
                            sizeof(RAS_OVERLAPPED));

        if(NULL != pOverlapped)
        {
            pOverlapped->RO_EventType = 
                    OVEVT_RASMAN_DEFERRED_CLOSE_CONNECTION;
                    
            pOverlapped->RO_hInfo = pConn->CB_ReferredEntry;

            if (!PostQueuedCompletionStatus(
                            hIoCompletionPort,
                            0,0,
                            (LPOVERLAPPED)
                            pOverlapped))
            {
                RasmanTrace(
                       "FreeConnection: failed to post completion"
                       " status. GLE=0%x", GetLastError());

                LocalFree(pOverlapped);                       
            }
        }
        else
        {
            RasmanTrace(
                   "FreeConnection: Failed to allocate overlapped"
                   " GLE=0x%x",
                   GetLastError());
        }
    }

    CloseHandle(pConn->CB_Process);

    FreeUserData(&pConn->CB_UserData);

    FreeNotifierList(&pConn->CB_NotifierList);

    if (pConn->CB_PortHandles != NULL)
    {
        LocalFree(pConn->CB_PortHandles);
    }

    RemoveEntryList(&pConn->CB_ListEntry);

    LocalFree(pConn);
}

/*++

Routine Description:

    Retrieve a tagged user data object from a list.

Arguments:

    pList

    dwTag

Return Value:

    UserData *

--*/
UserData *
GetUserData(
    PLIST_ENTRY pList,
    DWORD dwTag
    )
{
    PLIST_ENTRY pEntry;
    UserData *pUserData;

    //
    // Enumerate the list looking for a tag match.
    //
    for (pEntry = pList->Flink;
         pEntry != pList;
         pEntry = pEntry->Flink)
    {
        pUserData =
            CONTAINING_RECORD(pEntry, UserData, UD_ListEntry);

        if (pUserData->UD_Tag == dwTag)
        {
            return pUserData;
        }
    }
    return NULL;
}

/*++

Routine Description:

    Store a tagged user data object in a list.

Arguments:

    pList

    dwTag

    pBuf

    dwcbBuf

Return Value:

    void

--*/
VOID
SetUserData(
    PLIST_ENTRY pList,
    DWORD dwTag,
    PBYTE pBuf,
    DWORD dwcbBuf
    )
{
    UserData *pUserData;

    //
    // Check to see if the object already exists.
    //
    pUserData = GetUserData(pList, dwTag);
    //
    // If it does, delete it from the list.
    //
    if (pUserData != NULL)
    {
        RemoveEntryList(&pUserData->UD_ListEntry);
        LocalFree(pUserData);
    }

    //
    // Add the new value back to the list if
    // necessary.
    //
    if (pBuf != NULL)
    {
        pUserData = LocalAlloc(
                      LPTR,
                      sizeof (UserData) + dwcbBuf);
        if (pUserData == NULL)
        {
            RasmanTrace(
                   "SetUserData: LocalAlloc failed");

            return;
        }
        pUserData->UD_Tag = dwTag;

        pUserData->UD_Length = dwcbBuf;

        memcpy(&pUserData->UD_Data, pBuf, dwcbBuf);

        InsertTailList(pList, &pUserData->UD_ListEntry);
    }
}


/*++

Routine Description:

    Free the user data list

Arguments:

    pList

Return Value:

    void
--*/
VOID
FreeUserData(
    PLIST_ENTRY pList
    )
{
    PLIST_ENTRY pEntry;
    UserData *pUserData;

    //
    // Enumerate the list freeing each object.
    //
    while (!IsListEmpty(pList))
    {
        pEntry = RemoveHeadList(pList);

        pUserData =
            CONTAINING_RECORD(pEntry, UserData, UD_ListEntry);

        LocalFree(pUserData);
    }
}

/*++

Routine Description:

    Look up connection by id

Arguments:

    hconn

Return Value:

    A pointer to the connection if successful,
    NULL otherwise.

--*/
ConnectionBlock *
FindConnection(
    HCONN hconn
    )
{
    PLIST_ENTRY pEntry;
    ConnectionBlock *pConn;

    for (pEntry = ConnectionBlockList.Flink;
         pEntry != &ConnectionBlockList;
         pEntry = pEntry->Flink)
    {
        pConn =
            CONTAINING_RECORD(pEntry, ConnectionBlock, CB_ListEntry);

        if (pConn->CB_Handle == hconn)
        {
            return pConn;
        }
    }
    return NULL;
}

/*++

Routine Description:

    Free a connection block that has no connected ports.

Arguments:

    ppcb

    pConn

    fOwnerClose

Return Value:

    void
--*/
VOID
RemoveConnectionPort(
    pPCB ppcb,
    ConnectionBlock *pConn,
    BOOLEAN fOwnerClose
    )
{
    if (pConn == NULL)
    {
        RasmanTrace(
            "RemoveConnectionPort:pConn==NULL");
        return;
    }

    if(0 != pConn->CB_Ports)
    {
        pConn->CB_Ports--;
    }

    RasmanTrace(
      
      "RemoveConnectionPort: port %d, fOwnerClose=%d, "
      "pConn=0x%x, pConn->CB_Ports=%d\n",
      ppcb->PCB_PortHandle,
      fOwnerClose,
      pConn,
      pConn->CB_Ports);

    if(NULL != pConn->CB_PortHandles)
    {
        //
        // Remove the port from the connection.
        //
        pConn->CB_PortHandles[ppcb->PCB_SubEntry - 1] = NULL;
    }

    //
    // If there are not any other ports
    // in the connection, then signal that
    // it's closed and free the connection
    // only if one of the following conditions
    // is true:
    // 1. If the refcount on the connection is 0
    //    i.e every RasDial has been matched by
    //    a RasHangUp
    // 2. if the last port in the connection was
    //    remotely disconnected.
    //
    if (    (0 == pConn->CB_Ports)
        &&  (   0 == pConn->CB_RefCount
            ||  ppcb->PCB_AutoClose))
    {
        DWORD dwErr;

        SignalNotifiers(pConn->CB_NotifierList,
                        NOTIF_DISCONNECT,
                        0);

        SignalNotifiers(pConnectionNotifierList,
                        NOTIF_DISCONNECT,
                        0);

#if SENS_ENABLED
        dwErr = SendSensNotification(
                    SENS_NOTIFY_RAS_DISCONNECT,
                    (HRASCONN) pConn->CB_Handle);

        RasmanTrace(
            
            "SendSensNotification(_RAS_DISCONNECT) for "
            "0x%08x returns 0x%08x",
            pConn->CB_Handle,
            dwErr);

#endif

        g_RasEvent.Type = ENTRY_DISCONNECTED;

        dwErr = DwSendNotificationInternal(
                    pConn, &g_RasEvent);

        RasmanTrace(
               "DwSendNotificationInternal(ENTRY_DISCONNECTED) rc=0x%x",
               dwErr);
                   
        RasmanTrace(
               "RemoveConnectionPort: FreeConnection "
               "hconn=0x%x, pconn=0x%x, AutoClose=%d",
               pConn->CB_Handle,
               pConn,
               ppcb->PCB_AutoClose);

        pConn->CB_fAutoClose = ppcb->PCB_AutoClose;

        FreeConnection(pConn);

        ppcb->PCB_Connection = NULL;

        pConn = NULL;

    }
    else if (   0 != pConn->CB_Ports
            &&  NULL != ppcb->PCB_Bundle
    		&&	ppcb->PCB_Bundle->B_Count)
    {
        DWORD retcode;

        RasmanTrace(
               "RemoveConnectionPort: Notifying BANDWIDTHREMOVED"
               " for port %s. Bundle 0x%x",
               ppcb->PCB_Name,
               ppcb->PCB_Bundle);

        SignalNotifiers(
          pConn->CB_NotifierList,
          NOTIF_BANDWIDTHREMOVED,
          0);

        SignalNotifiers(
          pConnectionNotifierList,
          NOTIF_BANDWIDTHREMOVED,
          0);

        g_RasEvent.Type    = ENTRY_BANDWIDTH_REMOVED;

        retcode = DwSendNotificationInternal(pConn, &g_RasEvent);

        RasmanTrace(
               "DwSendNotificationInternal(ENTRY_BANDWIDTH_REMOVED)"
               " rc=0x%08x",
               retcode);

    }

    if(     pConn
        &&  0 == pConn->CB_Ports)
    {
        RasmanTrace(
               "Connection not freed for 0x%x! "
               "CB_Ports=%d, CB_Ref=%d",
               pConn->CB_Handle,
               pConn->CB_Ports,
               pConn->CB_RefCount);
    }

    ppcb->PCB_Bundle = ( Bundle * ) NULL;
}

DWORD
DwProcessPppFailureMessage(pPCB ppcb)
{
    DWORD dwErr = SUCCESS;

    if(0 == (ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPSTARTED))
    {
        RasmanTrace(
            "DwProcessPppFailureMessage: PPP called to "
            "disconnect even though it hadn't started!! port %d",
            ppcb->PCB_PortHandle);

        goto done;
    }

    RasmanTrace(
           "DwProcessPppFailureMessage: disconnecting %s,"
           "hEventClientDisconnect=0x%x",
           ppcb->PCB_Name,
           ppcb->PCB_hEventClientDisconnect);

    if(     (INVALID_HANDLE_VALUE !=
            ppcb->PCB_hEventClientDisconnect)
        &&  (NULL !=
            ppcb->PCB_hEventClientDisconnect))
    {
        RasmanTrace(
               "DwProcessPppFailureMessage: Not autoclosing %s",
                ppcb->PCB_Name);
    }
    else
    {
        ppcb->PCB_AutoClose = TRUE;
    }

    ppcb->PCB_RasmanReceiveFlags |= RECEIVE_PPPSTOPPED;

    dwErr = DisconnectPort(
                   ppcb,
                   ppcb->PCB_hEventClientDisconnect,
                   USER_REQUESTED);

    ppcb->PCB_hEventClientDisconnect = INVALID_HANDLE_VALUE;

done:
    return dwErr;
}


VOID
ReverseString(
    CHAR* psz )

    /* Reverses order of characters in 'psz'.
    */
{
    CHAR* pszBegin;
    CHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + strlen( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        CHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}

CHAR*
EncodePw(
    IN OUT CHAR* pszPassword )

    /* Obfuscate 'pszPassword' in place to foil memory scans for passwords.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    if (pszPassword)
    {
        CHAR* psz;

        ReverseString( pszPassword );

        for (psz = pszPassword; *psz != '\0'; ++psz)
        {
            if (*psz != PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
        }
    }

    return pszPassword;
}


CHAR*
DecodePw(
    IN OUT CHAR* pszPassword )

    /* Un-obfuscate 'pszPassword' in place.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    return EncodePw( pszPassword );
}

/*++

Routine Description:

    Will receive the PPP_MESSAGE from RASPPP and tag
    into the PCB structure for the appropriate port.

Arguments:

    pPppMsg

Return Value:

    void

--*/
DWORD
SendPPPMessageToRasman( PPP_MESSAGE * pPppMsg )
{
    PPP_MESSAGE * pPppMessage = NULL;
    DWORD dwErr = SUCCESS;

    PCB *ppcb = GetPortByHandle(pPppMsg->hPort);

    if (NULL == ppcb)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto done;
    }

    RasmanTrace("sendpppmessagetorasman: msgid=%d",
                pPppMsg->dwMsgId);
                
    if (ppcb->PCB_ConnState != CONNECTED)
    {
        if(     (ppcb->PCB_ConnState != LISTENING)
            ||  (PPPMSG_PppFailure == pPppMsg->dwMsgId))
        {
            RasmanTrace(
                   "SendPPPMessageToRasman: disconnecting port. state=%d",
                   ppcb->PCB_ConnState);

            ppcb->PCB_fRedial = FALSE;                   
            dwErr = DwProcessPppFailureMessage(ppcb);
        }
        else
        {
            RasmanTrace(
                
                "SendPPPMessageToRasman: ignoring %d on port %d since ports"
                " listening",
                pPppMsg->dwMsgId,
                ppcb->PCB_PortHandle);
        }

        goto done;
    }

    if (NULL ==
        (pPppMessage = LocalAlloc(LPTR,
                                  sizeof( PPP_MESSAGE))))
    {
        dwErr = GetLastError();
        goto done;
    }
    
    *pPppMessage = *pPppMsg;


    if(PPPMSG_InvokeEapUI == pPppMessage->dwMsgId)
    {
        RasmanTrace(
               "SendPPPMessageToRasman: Queueing pppmessage "
               "with ID=InvokeEapUI for port %s",
               ppcb->PCB_Name);
    }

    if(     (PPPMSG_PppFailure == pPppMessage->dwMsgId)
        &&  (ERROR_SUCCESS != pPppMessage->ExtraInfo.Failure.dwError))
    {   
        RasmanTrace(
               "Setting last error for port %s to ppp error 0x%x",
               ppcb->PCB_Name,
               pPppMessage->ExtraInfo.Failure.dwError);
               
        ppcb->PCB_LastError = pPppMessage->ExtraInfo.Failure.dwError;
    }
    

    if(PPPMSG_SetCustomAuthData == pPppMessage->dwMsgId)
    {
        PPP_SET_CUSTOM_AUTH_DATA * pData = 
            &pPppMessage->ExtraInfo.SetCustomAuthData;
        
        //
        // Save the auth data that ppp sent to rasman in ppcb.
        // Note that if this message is sent multiple times
        // then the last writer wins - there is only one field
        // in the phonebook to save this value. If memory alloc
        // fails this will fail to save the information - which
        // is not fatal - the worst case scenario is that rasdial
        // will popup the ui to get the information again.
        //
        if( (0 != pData->dwSizeOfConnectionData)
        &&  (NULL != pData->pConnectionData))
        {
            SetUserData(
                &ppcb->PCB_UserData,
                PORT_CUSTOMAUTHDATA_INDEX,
                (PBYTE) pData->pConnectionData,
                pData->dwSizeOfConnectionData);
        }
    }

    if(PPPMSG_ProjectionResult == pPppMessage->dwMsgId)
    {
        CHAR *pszReplyMessage = 
              pPppMessage->ExtraInfo.ProjectionResult.lcp.szReplyMessage;

        //
        // If we haven't saved already , save the reply
        // message in the connection block.
        //
        if(     (NULL != ppcb->PCB_Connection)
            &&  (NULL != pszReplyMessage))
        {

            if(NULL == GetUserData(
                        &ppcb->PCB_Connection->CB_UserData,
                        CONNECTION_PPPREPLYMESSAGE_INDEX))
            {                        
                //
                // Allocate and store the message in the 
                // connection block
                //
                SetUserData(
                  &ppcb->PCB_Connection->CB_UserData,
                  CONNECTION_PPPREPLYMESSAGE_INDEX,
                  (PBYTE) pszReplyMessage,
                  strlen(pszReplyMessage) + 1);
            }              
        }

    }

    if(PPPMSG_ChangePwRequest == pPppMessage->dwMsgId)
    {
        CHAR  szPwd[PWLEN+1];
        DWORD retcode;
        
        //
        // Retrieve the password from lsa, encode it
        // and save it in the pcb. This will be used
        // when PppChangePwd is called.
        //
        retcode = DwGetPassword(ppcb, szPwd, GetCurrentProcessId());

        if(ERROR_SUCCESS == dwErr)
        {
            EncodePw(szPwd);
            
            SetUserData(
                &ppcb->PCB_UserData,
                PORT_OLDPASSWORD_INDEX,
                (PBYTE) szPwd,
                sizeof(szPwd));

            ZeroMemory(szPwd, sizeof(szPwd));                
        }
    }
    
    if(PPPMSG_Stopped == pPppMessage->dwMsgId)
    {
        RasmanTrace(
               "PPPMSG_Stopped. dwError=0x%x",
               pPppMessage->dwError);

        if(ERROR_SUCCESS != pPppMessage->dwError)
        {
            RasmanTrace(
                   "setting error to %d",
                    pPppMessage->dwError);
            ppcb->PCB_LastError = pPppMessage->dwError;               
        }

        if(pPppMessage->ExtraInfo.Stopped.dwFlags & 
                    PPP_FAILURE_REMOTE_DISCONNECT)
        {
            ppcb->PCB_fRedial = TRUE;
        }
        else
        {
            ppcb->PCB_fRedial = FALSE;
        }
                
        dwErr = DwProcessPppFailureMessage(ppcb);

        LocalFree(pPppMessage);

    }
    else
    {
        if (ppcb->PCB_PppQTail == NULL)
        {
            ppcb->PCB_PppQHead = pPppMessage;
        }
        else
        {
            ppcb->PCB_PppQTail->pNext = pPppMessage;
        }
        
        ppcb->PCB_PppQTail        = pPppMessage;
        ppcb->PCB_PppQTail->pNext = NULL;

        SetPppEvent(ppcb);
    }

done:
    return dwErr;

}

/*++

Routine Description:

    This function sets the pcb's ppp event and
    posts a queued completion status packet,
    if necessary.

Arguments:

    ppcb

Return Value:

    void
--*/
VOID
SetPppEvent(
    pPCB ppcb
    )
{
    SetEvent(ppcb->PCB_PppEvent);

    if (ppcb->PCB_IoCompletionPort != INVALID_HANDLE_VALUE)
    {
        RasmanTrace(
          
          "SetPppEvent: pOverlapped=0x%x",
          ppcb->PCB_OvPpp);

        PostQueuedCompletionStatus(
          ppcb->PCB_IoCompletionPort,
          0,
          0,
          ppcb->PCB_OvPpp);
    }
}

/*++

Routine Description:

    This function flushes any receive packets that
    are queue on a pcb.

Arguments:

    ppcb

Return Value:

    void

--*/
VOID
FlushPcbReceivePackets(
    pPCB ppcb
    )
{
    RasmanPacket *Packet;

    while (ppcb->PCB_RecvPackets != NULL)
    {

        GetRecvPacketFromPcb(ppcb, &Packet);

        //PutRecvPacketOnFreeList(Packet);
        //
        // The packets on pcb are local alloc'd
        // Local Free them
        //
        LocalFree( Packet );
    }
}

/*++

Routine Description:

    This is a wrapper to trace the port state
    transitions.

Arguments:

    pszFile

    nLine

    ppcb

    state

Return Value:

    void

--*/
VOID
SetPortConnState(
    PCHAR pszFile,
    INT nLine,
    pPCB ppcb,
    RASMAN_STATE state
)
{
    RasmanTrace(
           "%s: %d: port %d state chg: prev=%d, new=%d",
           pszFile,
           nLine,
           ppcb->PCB_PortHandle,
           ppcb->PCB_ConnState,
           state);

    ppcb->PCB_ConnState = state;
}

/*++

Routine Description:

    This is a wrapper to trace the async worker
    element type state transitions.

Arguments:

    pszFile

    nLine

    ppcb

    reqtype

Return Value:

    void
--*/
VOID
SetPortAsyncReqType(
    PCHAR pszFile,
    INT nLine,
    pPCB ppcb,
    ReqTypes reqtype
    )
{
    RasmanTrace(
           "%s: %d: port %d async reqtype chg: prev=%d, new=%d",
           pszFile,
           nLine,
           ppcb->PCB_PortHandle,
           ppcb->PCB_AsyncWorkerElement.WE_ReqType,
           reqtype);

    ppcb->PCB_AsyncWorkerElement.WE_ReqType = reqtype;
}

/*++

Routine Description:

    Set the I/O completion port associated with a port.

Arguments:

    ppcb

    hIoCompletionPort

    lpDrop

    lpStateChange

    lpPpp

    lpLast

    fPost

Return Value:

    void

--*/
VOID
SetIoCompletionPortCommon(
    pPCB ppcb,
    HANDLE hIoCompletionPort,
    LPOVERLAPPED lpDrop,
    LPOVERLAPPED lpStateChange,
    LPOVERLAPPED lpPpp,
    LPOVERLAPPED lpLast,
    BOOL fPost
    )
{
    if (    INVALID_HANDLE_VALUE != ppcb->PCB_IoCompletionPort
        &&  INVALID_HANDLE_VALUE == hIoCompletionPort)
    {
        //
        // If we invalidate an I/O completion port, post one
        // last message to inform rasapi32 that there will
        // be no more events on this port.
        //
        if (fPost)
        {
            RasmanTrace(
              
              "SetIoCompletionPortCommon: posting last event for port %d",
              ppcb->PCB_PortHandle);

            PostQueuedCompletionStatus(
              ppcb->PCB_IoCompletionPort,
              0,
              0,
              ppcb->PCB_OvLast);
        }

        CloseHandle(ppcb->PCB_IoCompletionPort);
        ppcb->PCB_IoCompletionPort = INVALID_HANDLE_VALUE;
    }

    if (hIoCompletionPort != INVALID_HANDLE_VALUE)
    {
        ppcb->PCB_IoCompletionPort  = hIoCompletionPort;
        ppcb->PCB_OvDrop            = lpDrop;
        ppcb->PCB_OvStateChange     = lpStateChange;
        ppcb->PCB_OvPpp             = lpPpp;
        ppcb->PCB_OvLast            = lpLast;
    }
    else
    {
        ppcb->PCB_OvDrop        = NULL;
        ppcb->PCB_OvStateChange = NULL;
        ppcb->PCB_OvPpp         = NULL;
        ppcb->PCB_OvLast        = NULL;
    }
}

#if SENS_ENABLED

DWORD
SendSensNotification(DWORD dwFlags, HRASCONN hRasConn)
{
    SENS_NOTIFY_RAS sensNotification =
        {
            dwFlags,
            (SENS_HRASCONN) (HandleToUlong(hRasConn))
        };

    return SensNotifyRasEvent(&sensNotification);
}

VOID
AdjustTimer(void)
{

    if (!PostQueuedCompletionStatus(
                    hIoCompletionPort,
                    0,0,
                    (LPOVERLAPPED)
                    &RO_RasAdjustTimerEvent))
    {
        RasmanTrace(
            
            "%s, %d: Failed to post "
            "close event. GLE = %d",	
            __FILE__,
            __LINE__,
            GetLastError());
    }

    return;	
}

#endif

#if ENABLE_POWER

BOOL
fAnyConnectedPorts()
{
    ULONG i;
    pPCB  ppcb;
    BOOL  fRet = FALSE;

    for (i = 0; i < MaxPorts; i++)
    {
        ppcb = GetPortByHandle((HPORT) UlongToPtr(i));

        if (ppcb != NULL)
        {
            if(     (LISTENING   != ppcb->PCB_ConnState)
                &&  (CLOSED      != ppcb->PCB_PortStatus)
                &&  (REMOVED     != ppcb->PCB_PortStatus)
                &&  (UNAVAILABLE != ppcb->PCB_PortStatus))
            {
                fRet = TRUE;
            }
        }
    }

    RasmanTrace(
           "fAnyConnectedPorts: %d",
           fRet);

    return fRet;
}

VOID
DropAllActiveConnections()
{
    ULONG i;
    pPCB  ppcb;

    RasmanTrace(
           "Dropping All ActiveConnections as a result of"
           " Hibernate Event");

    for( i = 0; i < MaxPorts; i++)
    {
        ppcb = GetPortByHandle((HPORT) UlongToPtr(i));

        if(ppcb != NULL)
        {
            if(     (LISTENING   != ppcb->PCB_ConnState)
                &&  (CLOSED      != ppcb->PCB_PortStatus)
                &&  (REMOVED     != ppcb->PCB_PortStatus)
                &&  (UNAVAILABLE != ppcb->PCB_PortStatus))
            {
                RasmanTrace(
                       "DropAllActiveConnections: Dropping connection"
                       " on port %s as a result of Hibernate Event",
                       ppcb->PCB_Name);

                //
                // Disconnect the port and autoclose the port
                //
                ppcb->PCB_AutoClose = TRUE;

                DisconnectPort(ppcb,
                               INVALID_HANDLE_VALUE,
                               USER_REQUESTED);
            }
        }
    }
}

#endif

DWORD
DwSendNotificationInternal(ConnectionBlock *pConn, RASEVENT *pEvent)
{
    DWORD dwErr = ERROR_SUCCESS;

    switch (pEvent->Type)
    {

        case ENTRY_CONNECTING:
        case ENTRY_CONNECTED:
        case ENTRY_DISCONNECTING:
        case ENTRY_DISCONNECTED:
        {

            //
            // Fill in RASENUMENTRYDETAILS structure with whatever
            // information we have.
            //
            WCHAR *pwszPhonebook = NULL;
            WCHAR *pwszPhoneEntry = NULL;

            if(NULL == pConn)
            {
                RasmanTrace("DwSendNotificationInternal: NULL pConn");
                dwErr = E_INVALIDARG;
                goto done;
            }

            pEvent->Details.dwSize = sizeof(RASENUMENTRYDETAILS);

            pwszPhonebook = StrdupAtoW(pConn->CB_ConnectionParams.CP_Phonebook);
            pwszPhoneEntry = StrdupAtoW(pConn->CB_ConnectionParams.CP_PhoneEntry);

            if(NULL != pwszPhonebook)
            {
                wcsncpy(pEvent->Details.szPhonebookPath,
                        pwszPhonebook,
                        MAX_PATH);

                LocalFree(pwszPhonebook);
            }

            if(NULL != pwszPhoneEntry)
            {
                wcsncpy(pEvent->Details.szEntryName,
                        pwszPhoneEntry,
                        RASAPIP_MAX_ENTRY_NAME);

                LocalFree(pwszPhoneEntry);
            }

            pEvent->Details.guidId = pConn->CB_GuidEntry;

            break;
        }
        
        case ENTRY_BANDWIDTH_ADDED:
        case ENTRY_BANDWIDTH_REMOVED:
        {
            if(NULL == pConn)
            {
                RasmanTrace("DwSendNotificationInternal: NULL pConn");
                dwErr = E_INVALIDARG;
                goto done;
            }

            //
            // Fill in guidId field
            //
            pEvent->guidId = pConn->CB_GuidEntry;
            break;
        }

        case SERVICE_EVENT:
        case DEVICE_REMOVED:
        case DEVICE_ADDED:
        {
            break;
        }

        default:
        {
            ASSERT(FALSE);
            break;
        }
    }

    dwErr = DwSendNotification(pEvent);

done:
    return dwErr;
}

DWORD
DwSendNotification(RASEVENT *pEvent)
{
    DWORD dwErr = ERROR_SUCCESS;
    HINSTANCE hInst = NULL;

    if(NULL != GetModuleHandle("netman.dll"))
    {
        RASEVENTNOTIFYPROC pfnNotify;

        hInst = LoadLibrary("netman.dll");

        if(NULL == hInst)
        {
            dwErr = GetLastError();
            goto done;
        }

        pfnNotify = (RASEVENTNOTIFYPROC)
                    GetProcAddress(hInst, "RasEventNotify");

        if(NULL == pfnNotify)
        {
            dwErr = GetLastError();
            goto done;
        }

        pfnNotify(pEvent);
        
    }

done:
    if(NULL != hInst)
    {
        FreeLibrary(hInst);
    }

    return dwErr;
}

DWORD
DwSaveIpSecInfo(pPCB ppcb)
{
    DWORD retcode;
    RAS_DEVICE_INFO *prdi;
    RASTAPI_CONNECT_INFO *pConnectInfo = NULL;
    DWORD dwSize = 0;
    DWORD dwIpsecInformation = 0;

    if(NULL == ppcb->PCB_Connection)
    {

        prdi = &ppcb->PCB_pDeviceInfo->rdiDeviceInfo;

        //
        // Get size of the connect information from TAPI
        //
        retcode = (DWORD)RastapiGetConnectInfo(
                            ppcb->PCB_PortIOHandle,
                            (RDT_Modem == RAS_DEVICE_TYPE(
                            prdi->eDeviceType))
                            ? (PBYTE) prdi->szDeviceName
                            : (PBYTE) &prdi->guidDevice,
                            (RDT_Modem == RAS_DEVICE_TYPE(
                            prdi->eDeviceType)),
                            pConnectInfo,
                            &dwSize
                            );

        if(     (ERROR_BUFFER_TOO_SMALL != retcode)
            &&  (SUCCESS != retcode))
        {
            RasmanTrace(
                
                "Failed to get size of connectinfo. rc=0%0x",
                retcode);
                
            goto done;
        }

        pConnectInfo = LocalAlloc(LPTR, dwSize);

        if(NULL == pConnectInfo)
        {
            retcode = GetLastError();

            RasmanTrace(
                   "DwSaveIpSecInformation: failed to allocate. rc=0%0x",
                   retcode);
            
            goto done;
        }

        //
        // Get the connect information from TAPI
        //
        retcode = (DWORD)RastapiGetConnectInfo(
                            ppcb->PCB_PortIOHandle,
                            (RDT_Modem == RAS_DEVICE_TYPE(
                            prdi->eDeviceType))
                            ? (PBYTE) prdi->szDeviceName
                            : (PBYTE) &prdi->guidDevice,
                            (RDT_Modem == RAS_DEVICE_TYPE(
                            prdi->eDeviceType)),
                            pConnectInfo,
                            &dwSize
                            );
        
        if(SUCCESS != retcode)
        {

            RasmanTrace(
                
                "Failed to get connectinfo. rc=0%0x",
                 retcode);
            
            goto done;
        }


        if(0 != pConnectInfo->dwCallerIdSize)
        {
            CHAR *pszAddress;
     
            //
            // Extract the caller-id which should be the ip 
            // address of the the caller.
            //
            pszAddress = (CHAR *) (((PBYTE) pConnectInfo) 
                       + pConnectInfo->dwCallerIdOffset);

            RasmanTrace(
                
                "DwSaveIpSecInfo: pszAddress=%s",
                pszAddress);

            ppcb->PCB_ulDestAddr = inet_addr(pszAddress);

        }
    }
    
    //
    // Get ipsecinformation from ipsec
    //
    retcode = DwGetIpSecInformation(ppcb, &dwIpsecInformation);

    if(SUCCESS != retcode)
    {
        RasmanTrace(
               "SaveIpsecInformation: failed to get ipsec info. 0x%x",
                retcode);
                
    }

    
done:
    SetUserData(
        &ppcb->PCB_UserData,
        PORT_IPSEC_INFO_INDEX,
        (PBYTE) &dwIpsecInformation,
        sizeof(DWORD));

    //
    // Also stash the information away
    // in the connection block so that
    // client side apis work
    //
    if(NULL != ppcb->PCB_Connection)
    {
        SetUserData(
            &ppcb->PCB_Connection->CB_UserData,
            CONNECTION_IPSEC_INFO_INDEX,
            (PBYTE) &dwIpsecInformation,
            sizeof(DWORD));
    }

    if(NULL != pConnectInfo)
    {   
        LocalFree(pConnectInfo);
    }

    return retcode;
}

BOOL 
FRasmanAccessCheck()
{
    SID_IDENTIFIER_AUTHORITY    SidAuth = SECURITY_NT_AUTHORITY;
    PSID psid;
    BOOL fIsMember = FALSE;
    RPC_STATUS rpcstatus;
    HANDLE CurrentThreadToken = NULL;
    BOOL fImpersonate = FALSE;
    DWORD retcode = ERROR_SUCCESS;
    SID  sidLocalSystem = { 1, 1,
                        SECURITY_NT_AUTHORITY,
                        SECURITY_LOCAL_SYSTEM_RID };
    
    rpcstatus = RpcImpersonateClient ( NULL );

    if ( RPC_S_OK != rpcstatus )
    {
        goto done;
    }

    fImpersonate = TRUE;

    retcode = NtOpenThreadToken(
               NtCurrentThread(),
               TOKEN_QUERY,
               TRUE,
               &CurrentThreadToken
               );

    if(retcode != ERROR_SUCCESS)
    {
        RpcRevertToSelf();
        goto done;
    }

    if (!CheckTokenMembership( CurrentThreadToken,
                        &sidLocalSystem, &fIsMember ))
    {
        fIsMember = FALSE;
    }

    if(fIsMember)
    {
        goto done;
    }
    
    if (AllocateAndInitializeSid( &SidAuth, 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0, 0, 0, 0, 0, 0,
                 &psid ))
    {
        if (!CheckTokenMembership( CurrentThreadToken, psid, &fIsMember ))
        {
            RasmanTrace( "CheckTokenMemberShip for admins failed.");
            fIsMember = FALSE;
        }

        FreeSid( psid );
    }            

done:

    if(NULL != CurrentThreadToken)
    {
        NtClose(CurrentThreadToken);
    }

    if(fImpersonate)
    {
        RpcRevertToSelf();
    }
    
    return fIsMember;
}

VOID
RevealPassword(
    IN  UNICODE_STRING* pHiddenPassword
)
{
    SECURITY_SEED_AND_LENGTH*   SeedAndLength;
    UCHAR                       Seed;

    SeedAndLength = (SECURITY_SEED_AND_LENGTH*)&pHiddenPassword->Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    RtlRunDecodeUnicodeString(Seed, pHiddenPassword);
}

VOID
EncodePwd(RASMAN_CREDENTIALS *pCreds)
{
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString(&UnicodeString, pCreds->wszPassword);
    RtlRunEncodeUnicodeString(&pCreds->ucSeed, &UnicodeString);
    pCreds->usLength = UnicodeString.Length;
    pCreds->usMaximumLength = UnicodeString.MaximumLength;
}

VOID
DecodePwd(RASMAN_CREDENTIALS *pCreds)
{
    UNICODE_STRING UnicodeString;

    UnicodeString.Length = pCreds->usLength;
    UnicodeString.MaximumLength = pCreds->usMaximumLength;
    UnicodeString.Buffer = pCreds->wszPassword;
    RtlRunDecodeUnicodeString(pCreds->ucSeed, &UnicodeString);
}

VOID
EncodePin(
    IN  RASMAN_EAPTLS_USER_PROPERTIES* pUserProp
)
{
    UNICODE_STRING  UnicodeString;
    UCHAR           ucSeed          = 0;

    RtlInitUnicodeString(&UnicodeString, pUserProp->pwszPin);
    RtlRunEncodeUnicodeString(&ucSeed, &UnicodeString);
    pUserProp->usLength = UnicodeString.Length;
    pUserProp->usMaximumLength = UnicodeString.MaximumLength;
    pUserProp->ucSeed = ucSeed;
}


VOID
DecodePin(
    IN  RASMAN_EAPTLS_USER_PROPERTIES* pUserProp
)
{
    UNICODE_STRING  UnicodeString;

    UnicodeString.Length = pUserProp->usLength;
    UnicodeString.MaximumLength = pUserProp->usMaximumLength;
    UnicodeString.Buffer = pUserProp->pwszPin;
    RtlRunDecodeUnicodeString(pUserProp->ucSeed, &UnicodeString);

}


VOID 
GetMarshalledCredFromHash( 
                            PBYTE pbHash, 
                            DWORD cbHash,
                            LPTSTR lpszMarshalledCred )
{
	
    CERT_CREDENTIAL_INFO	CertCredInfo;
    LPTSTR					lpszMarshalledCredLocal = NULL;

    RasmanTrace("GetMarshalledCredFromHash");

    CertCredInfo.cbSize = sizeof(CertCredInfo);

    memcpy (CertCredInfo.rgbHashOfCert, 
                pbHash, 
                cbHash 
    	   );
	if (CredMarshalCredential(CertCredential, 
                              (PVOID) &CertCredInfo, 
                              &lpszMarshalledCredLocal
							  )
	   )
    {
        //
        // Got Marshalled Credential from the cert
        // Set it in the username field
        //
        ASSERT( NULL != lpszMarshalledCredLocal );
        lstrcpy ( lpszMarshalledCred, lpszMarshalledCredLocal );
        CredFree ( lpszMarshalledCredLocal );
        RasmanTrace("Got MarshalledCredFromHash");

    }
    else
    {
        RasmanTrace("CredMarshalCredential Failed with Error:0x%x",
                    GetLastError());

    }
}

VOID
SaveEapCredentials(pPCB ppcb, PBYTE buffer)
{
    RASMAN_CREDENTIALS *pCreds;

    if(NULL == ppcb->PCB_Connection)
    {
        RasmanTrace("Attempted to save creds for NULL connection!");
        ((REQTYPECAST *)buffer)->PortUserData.retcode = E_FAIL;
        return;
    }

    pCreds = (RASMAN_CREDENTIALS *)
            ((REQTYPECAST *)buffer)->PortUserData.data;

    //
    // Store the user data object - make sure that the data is
    // encrypted
    //
#if 0
    if(NO_ERROR == EncodeData(
            (BYTE *) pCreds->wszPassword,
            wcslen(pCreds->wszPassword) * sizeof(WCHAR),
            &pblob))
    {
        pCreds->pbPasswordData = pblob->pbData;
        pCreds->cbPasswordData = pblob->cbData;
        LocalFree(pblob);
    }

#endif

    EncodePwd(pCreds);

    SetUserData(
      &ppcb->PCB_Connection->CB_UserData,
      CONNECTION_CREDENTIALS_INDEX,
      (BYTE *)pCreds,
      sizeof(RASMAN_CREDENTIALS));
}


DWORD
DwCacheCredMgrCredentials(PPPE_MESSAGE *pMsg, pPCB ppcb)
{
    RASMAN_CREDENTIALS *pCreds = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    CHAR *pszUser = NULL;
    CHAR *pszDomain = NULL;
    CHAR *pszPasswd = NULL;
    UserData *pData = NULL;
    RASMAN_EAPTLS_USER_PROPERTIES *pUserProps = NULL;

    RasmanTrace("DwCacheCredentials");
        
    //
    // Store the credentials to be saved with credential manager.
    // Encode password before we copy it to local memory.
    //
    pCreds = LocalAlloc(LPTR, sizeof(RASMAN_CREDENTIALS));

    if(NULL == pCreds)
    {
        //
        // This is not fatal. If we fail to save with Credmanager,
        // the client might get a lot of challenges from credmgr
        // which is not a fatal sideeffect.
        //
        RasmanTrace(
               "PppStart: Failed to allocate. %d",
               GetLastError());

        goto done;               
    }

    //
    // Fetch the stored credentials and initialize the
    // credentials if the fetch succeeds
    // 
    pData = GetUserData(
            &(ppcb->PCB_Connection->CB_UserData),
                   CONNECTION_CREDENTIALS_INDEX);

    if(NULL != pData)
    {
        RASMAN_CREDENTIALS *pSavedCreds =
                (RASMAN_CREDENTIALS *) pData->UD_Data;

        DecodePwd(pSavedCreds);

        CopyMemory(pCreds, pSavedCreds, sizeof(RASMAN_CREDENTIALS));

        //
        // SavedCreds will be freed when SetUserData is called below
        //
        EncodePwd(pSavedCreds);
    }

    switch(pMsg->dwMsgId)
    {
        case PPPEMSG_Start:
        {
            pszUser = pMsg->ExtraInfo.Start.szUserName;
            pszDomain = pMsg->ExtraInfo.Start.szDomain;
            pszPasswd = pMsg->ExtraInfo.Start.szPassword;

            if(pMsg->ExtraInfo.Start.fLogon)
            {   
                pCreds->dwFlags |= RASCRED_LOGON;
            }

            if(NULL != pMsg->ExtraInfo.Start.pCustomAuthUserData)
            {
                pCreds->dwFlags |= RASCRED_EAP;
            }

            break;
        }

        case PPPEMSG_ChangePw:
        {
            pszUser = pMsg->ExtraInfo.ChangePw.szUserName;
            pszPasswd = pMsg->ExtraInfo.ChangePw.szNewPassword;
            break;
        }

        case PPPEMSG_Retry:
        {
            pszUser = pMsg->ExtraInfo.Retry.szUserName;
            pszDomain = pMsg->ExtraInfo.Retry.szDomain;
            pszPasswd = pMsg->ExtraInfo.Retry.szPassword;
            break;
        }

        default:
        {
            dwErr = E_INVALIDARG;
            goto done;
        }
    }

    strcpy(pCreds->szUserName,
            pszUser);

    if(NULL != pszDomain)
    {
        strcpy(pCreds->szDomain,            
                pszDomain);
    }            

    //
    // Now do the dirty part of extracting the PIN if its
    // EAP-TLS smartcard stuff. If its not tls, we don't
    // know how to save the information in cred mgr. and
    // we bail. This feature doesn't work for non-smart
    // card eap at this point.
    //
    if(pCreds->dwFlags & RASCRED_EAP)
    {
#if 0

        RasmanTrace("DwCacheCredMgrCredentials: eap creds");
        if(PPP_EAP_TLS != pMsg->ExtraInfo.Start.dwEapTypeId)
        {
            RasmanTrace("DwCacheCreMgrCredentials: Eap but not TLS");
            dwErr = E_FAIL;
            goto done;
        }

        //
        // It is tls. So Extract the PIN.
        //
        if(pCreds->dwFlags & RASCRED_LOGON)
        {
        }
        else
        {
            pUserProps = (RASMAN_EAPTLS_USER_PROPERTIES *)
            LocalAlloc(LPTR, 
	            (pMsg->ExtraInfo.Start.pCustomAuthUserData)->cbCustomAuthData );
            if ( !pUserProps )
            {
	            RasmanTrace(
		               "DwCacheCredMgrCredentials: Failed to allocate. %d",
                        GetLastError());

	            goto done;
            }

            CopyMemory 
                ( pUserProps,
                  (pMsg->ExtraInfo.Start.pCustomAuthUserData)->abCustomAuthData,
                  (pMsg->ExtraInfo.Start.pCustomAuthUserData)->cbCustomAuthData
                );


            if ((pMsg->ExtraInfo.Start.pCustomAuthUserData)->cbCustomAuthData
                < sizeof(RASMAN_EAPTLS_USER_PROPERTIES))
            {
                //
                // nothing to plumb
                //
                pUserProps->dwVersion = 0;
                pUserProps->dwSize = 
                (pMsg->ExtraInfo.Start.pCustomAuthUserData)->cbCustomAuthData;
                
                pUserProps->pwszDiffUser = pUserProps->awszString;
                pUserProps->dwPinOffset = 0;
                pUserProps->pwszPin = 
                pUserProps->awszString + pUserProps->dwPinOffset;
			}
            else
            {
                pUserProps->dwSize = 
                (pMsg->ExtraInfo.Start.pCustomAuthUserData)->cbCustomAuthData;
                pUserProps->pwszDiffUser = pUserProps->awszString;
                pUserProps->pwszPin = 
                pUserProps->awszString + pUserProps->dwPinOffset;

                //
                // Decode Pin
                //
                DecodePin(pUserProps);

            }

            if (pUserProps->dwPinOffset )
            {
                wcscpy(pCreds->wszPassword,
                	   pUserProps->awszString 
                	   + pUserProps->dwPinOffset);
	        }	
	        
            GetMarshalledCredFromHash(pUserProps->Hash.pbHash, 
                                      pUserProps->Hash.cbHash,
                                      pCreds->szUserName );

            //                                      
            // Encode Pin 
            //
            EncodePin(pUserProps);

        }
#endif
    }
    else
    {
        WCHAR *pwszPwd = StrdupAtoW(pszPasswd);

        if(NULL == pwszPwd)
        {
            RasmanTrace("DwCacheCredMgrCredentials: failed to alloc pwd");
            dwErr = E_OUTOFMEMORY;
            goto done;
        }
        
        wcscpy(pCreds->wszPassword,
               pwszPwd);

        ZeroMemory(pwszPwd, (sizeof(WCHAR) * wcslen(pwszPwd)) + 1);
        LocalFree(pwszPwd);
    }

    //
    // Obfuscate the pwd
    //
    EncodePwd(pCreds);
            
    SetUserData(&(ppcb->PCB_Connection->CB_UserData),
               CONNECTION_CREDENTIALS_INDEX,
               (PBYTE) pCreds,
               sizeof(RASMAN_CREDENTIALS));


done:

    if ( pUserProps )
    {
        LocalFree(pUserProps);
    }
    if(NULL != pCreds)
    {
        ZeroMemory(pCreds->wszPassword, sizeof(WCHAR) * (PWLEN + 1));
        LocalFree(pCreds);               
    }
    
    RasmanTrace("DwCacheCredMgrCredentials: 0x%x", dwErr);
    return dwErr;
    
}

BOOL
fDomainNotPresent(CHAR *pszName)
{
    while(*pszName != '\0')
    {
        if('\\' == *pszName)
        {
            break;
        }

        pszName++;
    }

    return ('\0' == *pszName) ? TRUE : FALSE;
}

DWORD
DwSaveCredentials(ConnectionBlock *pConn)
{
    RASMAN_CREDENTIALS *pCreds;
    DWORD dwErr = SUCCESS;
    CHAR  szNameBuf[CRED_MAX_STRING_LENGTH];
    CREDENTIAL stCredential;
    BOOL bResult;
    UserData *pData;
    WCHAR *pwszPassword;

    RasmanTrace("DwSaveCredentials");

    // return dwErr;

    if(NULL == pConn)
    {
        RasmanTrace("DwSaveCredentials: ERROR_NO_CONNECTION");
        dwErr = ERROR_NO_CONNECTION;
        goto done;
    }

    //
    // This check is made for robustness. The caller of this
    // function should actually be making the check.
    //
    if(0 == (pConn->CB_ConnectionParams.CP_ConnectionFlags
            & CONNECTION_USERASCREDENTIALS))
    {
        RasmanTrace("DwSaveCredentials: not saving credentials");
        goto done;
    }

    pData = GetUserData(
                &pConn->CB_UserData,
                CONNECTION_CREDENTIALS_INDEX);

    if(NULL == pData)
    {
        RasmanTrace("DwSaveCredentials: Creds not found");
        dwErr = ERROR_NOT_FOUND;
        goto done;
    }

    pCreds = (RASMAN_CREDENTIALS *) pData->UD_Data;

    //
    // Save the credentials with cred mgr.
    //
    ZeroMemory(&stCredential, sizeof(CREDENTIAL));

    stCredential.TargetName = CRED_SESSION_WILDCARD_NAME_A;

    if(RASCRED_EAP & pCreds->dwFlags)
    {
        
        stCredential.Type = (DWORD) CRED_TYPE_DOMAIN_CERTIFICATE;
        
    }
    else 
    {
        stCredential.Type = (DWORD) CRED_TYPE_DOMAIN_PASSWORD;
    }
    
    stCredential.Persist = CRED_PERSIST_SESSION;

    //
    // Check to see if domain name is passed in the username
    // field (i.e the username is already in the form 
    // "domain\\user")
    //
    if(     ('\0' != pCreds->szDomain[0])
        &&  (fDomainNotPresent(pCreds->szUserName)))
    {        
        sprintf(szNameBuf,
               "%s\\%s",
               pCreds->szDomain,
               pCreds->szUserName);
    }
    else
    {
        strcpy(szNameBuf, pCreds->szUserName);
    }

    stCredential.UserName = szNameBuf;
    
    DecodePwd(pCreds);

    stCredential.CredentialBlobSize = sizeof(WCHAR) * wcslen(pCreds->wszPassword);
    stCredential.CredentialBlob = (unsigned char *) pCreds->wszPassword;

    if(ERROR_SUCCESS == (dwErr = RasImpersonateUser(pConn->CB_Process)))
    {

        //
        // Before writing the credentials, make sure there are no other wild card
        // credentials present in the credential manager. There should be only one
        // CRED_SESSION_WILDCARD_NAME credential at any time. Currently we only
        // plumb _PASSWORD or _CERTIFICATE type of credentials. This will need to
        // change if we backport any _GENERIC type.
        //
        (VOID) CredDelete(CRED_SESSION_WILDCARD_NAME_A,
                          CRED_TYPE_DOMAIN_CERTIFICATE,
                          0);

        (VOID) CredDelete(CRED_SESSION_WILDCARD_NAME_A,
                          CRED_TYPE_DOMAIN_PASSWORD,
                          0);

        if(!CredWrite(&stCredential, 0))
        {
            dwErr = GetLastError();
            
            RasmanTrace(
                "DwSaveCredentials: CredWrite failed to "
                 "save credentials in credmgr.0x%x", dwErr);

        }

        RasRevertToSelf();
    }
    else
    {
        RasmanTrace(
            "DwSaveCredentials: failed to impersonate. 0x%x",
            dwErr);
    }

    ZeroMemory(pCreds->wszPassword, sizeof(WCHAR) * (PWLEN + 1));

done:

    RasmanTrace("DwSaveCredentials: 0x%x", dwErr);

    return dwErr;
}

DWORD
DwDeleteCredentials(ConnectionBlock *pConn)
{
    DWORD					dwErr = SUCCESS;
    RASMAN_CREDENTIALS *	pCreds = NULL;
	UserData *				pData = NULL;
    RasmanTrace("DwDeleteCredentials");

    // return dwErr;

    if(NULL == pConn)
    {
        RasmanTrace("DwDeleteCredentials: ERROR_NO_CONNECTION");
        dwErr = ERROR_NO_CONNECTION;
        goto done;
    }

    if(0 == (pConn->CB_ConnectionParams.CP_ConnectionFlags
            & CONNECTION_USERASCREDENTIALS))
    {
        RasmanTrace("DwDeleteCredentials: not deleting creds");
        goto done;
    }   

    pData = GetUserData(
                &pConn->CB_UserData,
                CONNECTION_CREDENTIALS_INDEX);

    if(NULL == pData)
    {
        RasmanTrace("DwDeleteCredentials: not deleting creds");
        dwErr = ERROR_NOT_FOUND;
        goto done;
    }

    pCreds = (RASMAN_CREDENTIALS *) pData->UD_Data;

    if(ERROR_SUCCESS == (dwErr = RasImpersonateUser(pConn->CB_Process)))
    {

        (VOID) CredDelete(CRED_SESSION_WILDCARD_NAME_A,
                          CRED_TYPE_DOMAIN_CERTIFICATE,
                          0);

        (VOID) CredDelete(CRED_SESSION_WILDCARD_NAME_A,
                          CRED_TYPE_DOMAIN_PASSWORD,
                          0);
		
        RasRevertToSelf();
    }
    else
    {
        RasmanTrace(
                "DwDeleteCredentials: failed to impersonate. 0x%x",
                dwErr);
    }

done:

    RasmanTrace("DwDeleteCredentials: 0x%x");
    return dwErr;
}

DWORD
InitializeRasAudio()
{
    DWORD retcode = SUCCESS;
    CHAR *psz[2];
    
    if(NULL != hinstRasAudio)
    {
        goto done;
    }

    psz[0] = "initialize";
    psz[1] = NULL;
        
    hinstRasAudio = LoadLibrary("rasaudio.dll");
    
    if(NULL == hinstRasAudio)
    {
        retcode = GetLastError();
        RasmanTrace("InitializeRasAudio: failed to load rasaudio.dll"
                    " Error=%d", retcode);
        goto done;
    }

    if(     (NULL == (RasStartRasAudio = 
                        GetProcAddress(hinstRasAudio, 
                                        "StartRasAudio")))
        ||  (NULL == (RasStopRasAudio =
                        GetProcAddress(hinstRasAudio, 
                                        "StopRasAudio"))))
    {
        retcode = GetLastError();
        FreeLibrary(hinstRasAudio);
        hinstRasAudio = NULL;
        RasStartRasAudio = NULL;

        RasmanTrace("EnableRasAudio: failed to "
                    "GetProcAddress. error=%d", retcode);

        goto done;                        
    }

    retcode = (DWORD) RasStartRasAudio();
    
    if(ERROR_SUCCESS != retcode)
    {
        psz[0] = "start";
    }
    
done:

    if(SUCCESS != retcode)
    {
        //
        // Eventlog the failure
        //
        RouterLogErrorString (
                    hLogEvents,
                    ROUTERLOG_RASAUDIO_FAILURE,
                    2, psz, retcode, 2) ;
                    
        UninitializeRasAudio();                        
    }

    return retcode;
}

DWORD
UninitializeRasAudio()
{
    DWORD retcode = SUCCESS;
    
    if(NULL == hinstRasAudio)
    {
        goto done;
    }

    retcode = (DWORD) RasStopRasAudio();

    if(SUCCESS == retcode)
    {
        //
        // Free the module
        //
        FreeLibrary(hinstRasAudio);
        hinstRasAudio = NULL;
        RasStartRasAudio = NULL;
        RasStopRasAudio = NULL;
    }

done:

    if(SUCCESS != retcode)
    {
        CHAR *psz[2];
        
        //
        // Eventlog the failure
        //
        psz[0] = "stop";
        psz[1] = NULL;
        
        RouterLogErrorString (
                    hLogEvents,
                    ROUTERLOG_RASAUDIO_FAILURE,
                    2, psz, retcode, 2) ;
    }
    
    return retcode;
}


VOID
UninitializeIphlp()
{
    if(g_IphlpInitialized)
    {
        ASSERT(NULL != hIphlp);
        FreeLibrary(hIphlp);
    }

    hIphlp = NULL;
    RasGetBestInterface = NULL;
    RasGetIpAddrTable = NULL;
    g_IphlpInitialized = FALSE;
}

DWORD
DwInitializeIphlp()
{
    DWORD retcode = ERROR_SUCCESS;

    if(g_IphlpInitialized)
    {
        goto done;
    }

    if(     (NULL == (hIphlp = LoadLibrary("iphlpapi.dll")))
        ||  (NULL == (RasGetBestInterface =
                               GetProcAddress(hIphlp,
                                            "GetBestInterfaceFromStack")))
        ||  (NULL == (RasGetIpAddrTable =
                                GetProcAddress(hIphlp,
                                            "GetIpAddrTable")))
        ||  (NULL == (RasAllocateAndGetInterfaceInfoFromStack =
                                GetProcAddress(hIphlp,
                                "NhpAllocateAndGetInterfaceInfoFromStack"))))
    {
        retcode = GetLastError();
        goto done;
    }

    g_IphlpInitialized = TRUE;

done:
    return retcode;
}

DWORD
DwCacheRefInterface(pPCB ppcb)
{
    DWORD retcode = ERROR_SUCCESS;
    DWORD dwIfIndex;
    HANDLE hHeap = NULL;
    IP_INTERFACE_NAME_INFO *pTable = NULL;
    DWORD dw;
    DWORD dwCount;

    if(     (NULL == ppcb->PCB_Connection)
        ||  (RDT_Tunnel_Pptp !=
            RAS_DEVICE_TYPE(
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType)))
    {
        RasmanTrace("DwCacheRefInterface: Invalid Parameter");
        retcode = E_INVALIDARG;
        goto done;
    }

    retcode = DwInitializeIphlp();
    if(ERROR_SUCCESS != retcode)
    {
        RasmanTrace("DwCacheRefInterface: failed to init iphlp. 0x%x",
                    retcode);
        goto done;                    
    }

    retcode = (DWORD)RasGetBestInterface(ppcb->PCB_ulDestAddr, &dwIfIndex);
    if(ERROR_SUCCESS != retcode)
    {
        RasmanTrace("DwCacheRefInterface: GetBestInterface failed. 0x%x",
                    retcode);
        goto done;                    
    }

    hHeap = GetProcessHeap();
    
    retcode = (DWORD) RasAllocateAndGetInterfaceInfoFromStack(
                    &pTable, &dwCount, FALSE /* bOrder */,
                    hHeap, LPTR);

    if(ERROR_SUCCESS != retcode)
    {
        RasmanTrace("DwCacheRefInterface: AllocAndGet.. failed. 0x%x",
                                retcode);
        goto done;                
    }

    //
    // Loop through and cache the interface guid
    //
    for(dw = 0; dw < dwCount; dw++)
    {
        if(dwIfIndex == pTable[dw].Index)
        {
            SetUserData(
                &ppcb->PCB_Connection->CB_UserData,
                CONNECTION_REFINTERFACEGUID_INDEX,
                (PBYTE) &pTable[dw].InterfaceGuid,
                sizeof(GUID));

            SetUserData(
                &ppcb->PCB_Connection->CB_UserData,
                CONNECTION_REFDEVICEGUID_INDEX,
                (PBYTE) &pTable[dw].DeviceGuid,
                sizeof(GUID));

            RasmanTrace(
                "DwCacheRefInterface: setuserdata. Addr=0x%x, rc=0x%x",
                ppcb->PCB_ulDestAddr, retcode);
            break;
        }
    }

    if(dw == dwCount)
    {
        RasmanTrace("DwCacheRefInterface: didn't find i/f index");
        goto done;
    }

done:
    if(NULL != pTable)
    {
        HeapFree(hHeap, 0, pTable);
    }

    return retcode;
    
}

DWORD DwGetBestInterface(
                DWORD DestAddress,
                DWORD *pdwAddress,
                DWORD *pdwMask)
{
    DWORD retcode = ERROR_SUCCESS;
    DWORD dwInterface;
    DWORD dwSize = 0;
    MIB_IPADDRTABLE *pAddressTable = NULL;
    DWORD i;

    ASSERT(NULL != pdwAddress);
    ASSERT(NULL != pdwMask);

    *pdwAddress = -1;

    *pdwMask = -1;

    retcode = DwInitializeIphlp();

    if(ERROR_SUCCESS != retcode)
    {
        RasmanTrace(
            "DwGetBestInteface: failed to init iphlp. 0x%x",
            retcode);

        goto done;
    }

    retcode = (DWORD) RasGetBestInterface(DestAddress, &dwInterface);

    if(ERROR_SUCCESS != retcode)
    {
        RasmanTrace(
            "DwGetBestInterface: GetBestInterface failed. 0x%x",
            retcode);

        goto done;
    }

    //
    // Get the interface to address mapping
    //
    retcode = (DWORD) RasGetIpAddrTable(
                    &pAddressTable,
                    &dwSize,
                    FALSE);

    if(ERROR_INSUFFICIENT_BUFFER != retcode)
    {
        RasmanTrace(
            "DwGetBestInterface: GetIpAddrTable returned 0x%x",
            retcode);

        goto done;
    }

    pAddressTable = (MIB_IPADDRTABLE *) LocalAlloc(LPTR, dwSize);

    if(NULL == pAddressTable)
    {
        retcode = GetLastError();
        RasmanTrace(
            "DwGetBestInterface: failed to allocate table. 0x%x",
            retcode);

        goto done;
    }

    retcode = (DWORD) RasGetIpAddrTable(
                pAddressTable,
                &dwSize,
                FALSE);

    if(ERROR_SUCCESS != retcode)
    {
        RasmanTrace(
            "DwGetBestInterface: failed to get ip addr table. 0x%x",
            retcode);

        goto done;
    }

    //
    // Loop through the address table and find the
    // address with the index we are intersted in.
    //
    for(i = 0; i < pAddressTable->dwNumEntries; i++)
    {
        if(dwInterface == pAddressTable->table[i].dwIndex)
        {
            *pdwAddress = pAddressTable->table[i].dwAddr;
            *pdwMask = pAddressTable->table[i].dwMask;
            break;
        }
    }

    if(i == pAddressTable->dwNumEntries)
    {
        retcode = ERROR_NOT_FOUND;
    }

done:

    if(NULL != pAddressTable)
    {
        LocalFree(pAddressTable);
    }

    RasmanTrace(
        "DwGetBestInterface: done. rc=0x%x, address=0x%x, mask=0x%x",
        retcode,
        *pdwAddress,
        *pdwMask);

    return retcode;

}


VOID
QueueCloseConnections(ConnectionBlock *pConn,
                      HANDLE hEvent,
                      BOOL   *pfQueued)
{
    DWORD retcode = ERROR_SUCCESS;
    ConnectionBlock *pConnT;
    PLIST_ENTRY pEntry;
    DWORD dwCount = 0;
    UserData *pData = NULL;
    ConnectionBlock **phConn = NULL;
    DWORD dwConn;
    RAS_OVERLAPPED *pOverlapped = NULL;

    ASSERT(pfQueued != NULL);
    ASSERT(pConn != NULL);

    *pfQueued = FALSE;

    //
    // Check to see if this is the last port
    //
    if(pConn->CB_Ports != 1)
    {
        RasmanTrace("QueueCloseConnections: cbports=%d",
                    pConn->CB_Ports);
        goto done;                    
    }
    
    phConn = LocalAlloc(LPTR, 10 * sizeof(HCONN));
    if(NULL == phConn)
    {
        RasmanTrace(
            "QueueCloseConnections: failed to allocated");
        goto done;            
    }

    dwConn = 10;

    for (pEntry = ConnectionBlockList.Flink;
         pEntry != &ConnectionBlockList;
         pEntry = pEntry->Flink)
    
    {
        pConnT =
            CONTAINING_RECORD(pEntry, ConnectionBlock, CB_ListEntry);

        //
        // Get the interface guid
        //
        pData = GetUserData(&pConnT->CB_UserData, 
                            CONNECTION_REFINTERFACEGUID_INDEX);

        if(pData == NULL)
        {
            continue;
        }

        if(0 == memcmp(&pConn->CB_GuidEntry, pData->UD_Data, sizeof(GUID)))
        {
            phConn[dwCount] = pConnT;
            dwCount += 1;
            if(dwCount == dwConn)
            {   
                ConnectionBlock **pTemp;
                pTemp = LocalAlloc(LPTR, (dwCount + 10) * sizeof(HCONN));
                if(NULL == pTemp)
                {
                    goto done;
                }
                CopyMemory(pTemp, phConn, dwCount * sizeof(HCONN));
                LocalFree(phConn);
                phConn = pTemp;
            }
        }
    }

    if(dwCount == 0)
    {
        RasmanTrace("QueueCloseConnections: no dependent connections");
        goto done;
    }

    //
    // Now we have a list of connections which
    // should be closed before pConn is closed.
    // Queue requests to close these connections.
    //
    for(dwConn = 0; dwConn < dwCount; dwConn++)
    {
        pConnT = phConn[dwConn];

        if(dwConn + 1 == dwCount)
        {
            pConnT->CB_ReferredEntry = pConn->CB_Handle;
        }

        pOverlapped = LocalAlloc(LPTR, sizeof(RAS_OVERLAPPED));
        if(NULL == pOverlapped)
        {
            goto done;
        }

        pOverlapped->RO_EventType = OVEVT_RASMAN_DEREFERENCE_CONNECTION;
        pOverlapped->RO_hInfo = pConnT->CB_Handle;
        RasmanTrace("Queueing DEREFERENCE for 0x%x",
                    pConnT->CB_Handle);
                    
        if (!PostQueuedCompletionStatus(
                        hIoCompletionPort,
                        0,0,
                        (LPOVERLAPPED)
                        pOverlapped))
        {
            RasmanTrace(
                   "QueueCloseConnections: failed to post completion"
                   " status. GLE=0%x", GetLastError());

            LocalFree(pOverlapped);                    
            goto done;
        }
    }

    pConn->CB_Flags |= CONNECTION_DEFERRING_CLOSE;
    *pfQueued = TRUE;

done:

    if(phConn != NULL)
    {
        LocalFree(phConn);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\worker.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    worker.c

Abstract:

    All notifications from rastapi/etc are handled here

Author:

    Gurdeep Singh Pall (gurdeep) 16-Jun-1992

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#define RASMXS_DYNAMIC_LINK

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <raserror.h>
#include <media.h>
#include <device.h>
#include <devioctl.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <rtutils.h>
#include "logtrdef.h"
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "reghelp.h"

DWORD StopPPP(HANDLE) ;

extern BOOL g_fIpInstalled;
extern BOOL g_fNbfInstalled;
extern BOOLEAN RasmanShuttingDown;
BOOL fIsValidConnection(ConnectionBlock *pConn);


DWORD
DwProcessDeferredCloseConnection(
                    RAS_OVERLAPPED *pOverlapped)
{
    DWORD retcode = ERROR_SUCCESS;
    ConnectionBlock *pConn = FindConnection((HCONN) pOverlapped->RO_hInfo);
    DWORD i;
    HANDLE hEvent = INVALID_HANDLE_VALUE;
    pPCB ppcb;

    if(NULL == pConn)
    {
        retcode = ERROR_NO_CONNECTION;
        goto done;
    }

    pConn->CB_Flags |= CONNECTION_DEFERRED_CLOSE;

    for(i = 0; i < pConn->CB_MaxPorts; i++)
    {
        ppcb = pConn->CB_PortHandles[i];

        if(NULL == ppcb)
        {
            continue;
        }

        if(     (INVALID_HANDLE_VALUE != ppcb->PCB_hEventClientDisconnect)
            &&  (NULL != ppcb->PCB_hEventClientDisconnect))
        {
            REQTYPECAST *pReqTypeCast = LocalAlloc(LPTR, sizeof(REQTYPECAST));

            if(NULL == pReqTypeCast)
            {
                break;
            }

            pReqTypeCast->PortDisconnect.handle =
                        ppcb->PCB_hEventClientDisconnect;
            //
            // Call the port disconnect request api so that graceful
            // termination can be done.
            //
            PortDisconnectRequestInternal(ppcb, (PBYTE) pReqTypeCast, TRUE);

            break;
        }

        //
        // Disconnect the port on clients behalf
        // The port must be autoclosed.
        //
        ppcb->PCB_AutoClose = TRUE;
        DisconnectPort(ppcb,
            INVALID_HANDLE_VALUE,
            REMOTE_DISCONNECTION);
        
        break;
           
    }
            
done:    
    RasmanTrace("DwProcessDeferredCloseConnection: conn=0x%x. rc=0x%x",
                pOverlapped->RO_hInfo, retcode);
    return retcode;
}


DWORD
DwCloseConnection(HCONN hConn)
{
    DWORD retcode = SUCCESS;

    ConnectionBlock *pConn = FindConnection(hConn);

    pPCB ppcb = NULL;

    RasmanTrace(
           "DwCloseConnection: hConn=0x%08x",
           hConn);

    if(NULL == pConn)
    {
        RasmanTrace(
               "DwCloseConnection: No connection found");

        retcode = ERROR_NO_CONNECTION;
        goto done;
    }

    retcode = DwRefConnection(&pConn,
                              FALSE);

    if(SUCCESS != retcode)
    {
        goto done;
    }

    //
    // If this was the last ref on the connection
    // Iterate through all the ports in this
    // connection, Disconnect and autoclose
    // the ports
    //
    if(     (NULL != pConn)
        &&  (0 == pConn->CB_RefCount))
    {
        DWORD i;

        for(i = 0; i < pConn->CB_MaxPorts; i++)
        {
            ppcb = pConn->CB_PortHandles[i];

            if(NULL == ppcb)
            {
                continue;
            }

            //
            // Disconnect the port on clients behalf
            // The port must be autoclosed.
            //
            DisconnectPort(ppcb, INVALID_HANDLE_VALUE,
                           REMOTE_DISCONNECTION);


            //
            // Make sure that the connection is still valid
            //
            if(!fIsValidConnection(pConn))
            {
                RasmanTrace(
                       "pConn 0x%x no longer valid",
                       pConn);
                       
                break;
            }
        }
    }

done:

    RasmanTrace(
           "DwCloseConnection: done. 0x%08x",
           retcode);

    return retcode;

}

DWORD DwSignalPnPNotifiers (PNP_EVENT_NOTIF *ppnpEvent)
{
    DWORD               dwErr           = SUCCESS;
    pPnPNotifierList    pPnPNotifier    = g_pPnPNotifierList;
    PNP_EVENT_NOTIF     *pNotif;

    //
    // Walk down the list and signal/callback
    //
    while (pPnPNotifier)
    {
        //
        // Allocate the notification event and send it to the
        // callbacks
        //
        if(NULL == (pNotif = LocalAlloc(LPTR, sizeof(PNP_EVENT_NOTIF))))
        {
            dwErr = GetLastError();
            RasmanTrace(
                   "Failed to allocate pnp_event_notif",
                   dwErr);
            break;
        }

        *pNotif = *ppnpEvent;
        
        if ( pPnPNotifier->PNPNotif_dwFlags & PNP_NOTIFCALLBACK )
        {
            if(!QueueUserAPC (
                    pPnPNotifier->PNPNotif_uNotifier.pfnPnPNotifHandler,
                    pPnPNotifier->hThreadHandle,
                    (ULONG_PTR)pNotif))
            {
                dwErr = GetLastError();

                RasmanTrace (
                    
                    "DwSignalPnPNotifiers: Failed to notify "
                    "callback 0x%x, rc=0x%x",
                    pPnPNotifier->PNPNotif_uNotifier.pfnPnPNotifHandler,
                    dwErr);

                LocalFree(pNotif);                    

                //
                // Ignore the error and attempt to notify the next
                // notifier.
                //
                dwErr = SUCCESS;
            }
            else
            {
                RasmanTrace (
                    
                    "Successfully queued APC 0x%x",
                    pPnPNotifier->PNPNotif_uNotifier.pfnPnPNotifHandler);
            }
        }
        else
        {
            SetEvent (
                pPnPNotifier->PNPNotif_uNotifier.hPnPNotifier);
        }

        pPnPNotifier = pPnPNotifier->PNPNotif_Next;
    }

    return dwErr;
}

ULONG
ulGetRasmanProtFlags(ULONG ulFlags)
{
    ULONG ulFlagsRet = 0;

    switch(ulFlags)
    {
        case PROTOCOL_ADDED:
        {
            ulFlagsRet = RASMAN_PROTOCOL_ADDED;

            break;
        }

        case PROTOCOL_REMOVED:
        {
            ulFlagsRet = RASMAN_PROTOCOL_REMOVED;
            break;
        }

        default:
        {
#if DBG
            ASSERT(FALSE);
            break;
#endif
        }
    }

    return ulFlagsRet;
}

DWORD
DwProcessNetbeuiNotification(ULONG ulFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    if(PROTOCOL_ADDED & ulFlags)
    {
        RasmanTrace(
               "DwProcessNetbeuiNotification: NETBEUI was ADDED");
    }
    else if(PROTOCOL_REMOVED & ulFlags)
    {
        RasmanTrace(
               "DwProcessNetbeuiNotification: NETBEUI was REMOVED");
    }

    //
    // Reread the netbios information from the registry
    //
    dwErr = InitializeProtocolInfoStructs();

    return dwErr;

}

VOID
NotifyPPPOfProtocolChange(PROTOCOL_EVENT *pProtEvent)
{

    g_PppeMessage->dwMsgId = PPPEMSG_ProtocolEvent;

    g_PppeMessage->ExtraInfo.ProtocolEvent.usProtocolType =
                        pProtEvent->usProtocolType;

    g_PppeMessage->ExtraInfo.ProtocolEvent.ulFlags =
            ulGetRasmanProtFlags(pProtEvent->ulFlags);

    RasmanTrace(
           "Notifying PPP of protocol change. 0x%x was %s",
           pProtEvent->usProtocolType,
           (RASMAN_PROTOCOL_ADDED
          & g_PppeMessage->ExtraInfo.ProtocolEvent.ulFlags)
           ? "ADDED"
           : "REMOVED");

    RasSendPPPMessageToEngine(g_PppeMessage);

    return;
}

DWORD
DwProcessProtocolEvent()
{
    DWORD dwErr = SUCCESS;

    PROTOCOL_EVENT *pProtEvent;

    DWORD i;

    NDISWAN_GET_PROTOCOL_EVENT protocolevents;

    BOOL fAdjustEp = FALSE;

    //
    // Get the event information from ndiswan
    //
    dwErr = DwGetProtocolEvent(&protocolevents);

    if(SUCCESS != dwErr)
    {
        RasmanTrace(
               "DwProcessProtocolEvent: failed to get"
               " protocol event information. 0x%x",
               dwErr);

        goto done;
    }

    for(i = 0; i < protocolevents.ulNumProtocols; i++)
    {
        pProtEvent = &protocolevents.ProtocolEvent[i];

        RasmanTrace(
               "DwProcessProtocolEvent: Protocol 0x%x was %s",
               pProtEvent->usProtocolType,
               (pProtEvent->ulFlags & PROTOCOL_ADDED)
               ? "ADDED"
               : "REMOVED");

        if (ASYBEUI == pProtEvent->usProtocolType)
        {
            dwErr = DwProcessNetbeuiNotification(
                        pProtEvent->ulFlags
                        );

            RasmanTrace(
                   "DwProcessNetbeuiNotification returned 0x%x",
                   dwErr);
        
            if(      (pProtEvent->ulFlags & PROTOCOL_ADDED)
                 &&  !g_fNbfInstalled)
            {
                //
                // Nbf was added
                //
                (void) DwInitializeWatermarksForProtocol(NbfOut);
                (void) DwInitializeWatermarksForProtocol(NbfIn);
                g_fNbfInstalled = TRUE;
                fAdjustEp = TRUE;
            }
            else if(    (pProtEvent->ulFlags & PROTOCOL_REMOVED)
                    &&  g_fNbfInstalled)
            {
                g_fNbfInstalled = FALSE;
            }

            //
            // At this point this is the only notification we
            // we are interested in. IP/IPX events are not
            // really processed by rasman - theres nothing
            // for rasman to do for these protocols since
            // ndiswan is PnP wrt to IP and IPX.
            //
        }

        if(     (IP == pProtEvent->usProtocolType)
            &&  (pProtEvent->ulFlags & PROTOCOL_ADDED)
            &&  !g_fIpInstalled)
        {
            (void) DwInitializeWatermarksForProtocol(IpOut);
            g_fIpInstalled = TRUE;
            fAdjustEp = TRUE;
        }
        else if(    (IP == pProtEvent->usProtocolType)
                &&  (pProtEvent->ulFlags & PROTOCOL_REMOVED))
        {
            g_fIpInstalled = FALSE;
        }
        
        //
        // Notify PPP engine about the protocol change
        //
        NotifyPPPOfProtocolChange(pProtEvent);
    }

    if(fAdjustEp)
    {
        (void) DwAddEndPointsIfRequired();
        (void) DwRemoveEndPointsIfRequired();
    }


done:

    //
    // Always pend an irp with ndiswan for further
    // protocol notifications.
    //
    dwErr = DwSetProtocolEvent();

    if(SUCCESS != dwErr)
    {
        RasmanTrace(
               "DwProcessProtocolEvent: failed to set "
               "protevent. 0x%x",
               dwErr);
    }

    return dwErr;
}


VOID
FillRasmanPortInfo (
    RASMAN_PORT *pRasPort,
    PortMediaInfo *pmiInfo
    )
{

    pRasPort->P_Handle          = (HPORT) UlongToPtr(MaxPorts - 1);
    pRasPort->P_Status          = CLOSED;
    pRasPort->P_ConfiguredUsage = pmiInfo->PMI_Usage;
    pRasPort->P_CurrentUsage    = pmiInfo->PMI_Usage;
    pRasPort->P_LineDeviceId    = pmiInfo->PMI_LineDeviceId;
    pRasPort->P_AddressId       = pmiInfo->PMI_AddressId;

    strcpy (pRasPort->P_PortName, pmiInfo->PMI_Name);

    strcpy (pRasPort->P_DeviceType, pmiInfo->PMI_DeviceType);

    strcpy (pRasPort->P_DeviceName, pmiInfo->PMI_DeviceName);

}

DWORD
DwPostUsageChangedNotification(pPCB ppcb)
{
    DWORD           dwRetCode = SUCCESS;
    RASMAN_PORT     *pRasmanPort;
    PNP_EVENT_NOTIF *pUsageChangedNotification = NULL;

    RasmanTrace(
           "Posting Usage changed notification for %s "
           "NewUsage=%d",
           ppcb->PCB_Name,
           ppcb->PCB_ConfiguredUsage);

    if(NULL == g_pPnPNotifierList)
    {
        RasmanTrace(
               "NotifierList is Empty");

        goto done;
    }

    pUsageChangedNotification = LocalAlloc(
                LPTR, sizeof(PNP_EVENT_NOTIF));
    if(NULL == pUsageChangedNotification)
    {
        dwRetCode = GetLastError();

        RasmanTrace(
               "DwPostUsageChangedNotification: "
               "Couldn't Allocate. 0x%08x",
               dwRetCode);

        goto done;
    }

    //
    // initialize the event
    //
    pUsageChangedNotification->dwEvent = PNPNOTIFEVENT_USAGE;

    //
    // Fill in the RASMAN_PORT information
    //
    pRasmanPort = &pUsageChangedNotification->RasPort;

    pRasmanPort->P_Handle = ppcb->PCB_PortHandle;

    strcpy(pRasmanPort->P_PortName,
           ppcb->PCB_Name);

    pRasmanPort->P_Status = ppcb->PCB_PortStatus;

    pRasmanPort->P_ConfiguredUsage = ppcb->PCB_ConfiguredUsage;

    pRasmanPort->P_CurrentUsage = ppcb->PCB_CurrentUsage;

    strcpy(pRasmanPort->P_MediaName,
           ppcb->PCB_Media->MCB_Name);

    strcpy(pRasmanPort->P_DeviceType,
           ppcb->PCB_DeviceType);

    strcpy(pRasmanPort->P_DeviceName,
           ppcb->PCB_DeviceName);

    pRasmanPort->P_LineDeviceId = ppcb->PCB_LineDeviceId;

    pRasmanPort->P_AddressId = ppcb->PCB_AddressId;

    //
    // send the notification to the clients
    //
    dwRetCode = DwSignalPnPNotifiers(pUsageChangedNotification);

    if(dwRetCode)
    {
        RasmanTrace(
            
           "Failed to signal notifiers of change in port"
           " usage. 0x%08x",
           dwRetCode);
    }

done:

    if(NULL != pUsageChangedNotification)
    {
        LocalFree(pUsageChangedNotification);
    }
    
    return dwRetCode;
}

DWORD
DwEnableDeviceForDialIn(DeviceInfo *pDeviceInfo,
                        BOOL fEnable,
                        BOOL fEnableRouter,
                        BOOL fEnableOutboundRouter)
{
    DWORD dwRetCode = SUCCESS;
    DWORD i;
    pPCB ppcb;

    RasmanTrace(
           "DwEnableDeviceForDialIn: fEnable=%d,"
           "fEnableRouter=%d, fEnableOutboundRouter=%d,"
           "Device %s",
           fEnable,
           fEnableRouter,
           fEnableOutboundRouter,
           pDeviceInfo->rdiDeviceInfo.szDeviceName);

    //
    // Change the port usage in rastapi's
    // port control blocks.
    //
    dwRetCode = (DWORD) RastapiEnableDeviceForDialIn(
                                    pDeviceInfo,
                                    fEnable,
                                    fEnableRouter,
                                    fEnableOutboundRouter);

    if(dwRetCode)
    {
        RasmanTrace(
            
            "RasTapiEnableDeviceForDialIn failed. 0x%08x",
            dwRetCode);

        goto done;
    }

    //
    // Set the rasenabled to the changed value now that
    // rastapi has also successfully changed its state
    //
    pDeviceInfo->rdiDeviceInfo.fRasEnabled = fEnable;

    pDeviceInfo->rdiDeviceInfo.fRouterEnabled
                                    = fEnableRouter;

    pDeviceInfo->rdiDeviceInfo.fRouterOutboundEnabled
                                = fEnableOutboundRouter;

    //
    // Run down the list of ports in rasman and send
    // notifications. Note we ignore failures after
    // this point as we want the port usages to be
    // consistent between rastapi and rasman
    //
    for(i = 0; i < MaxPorts; i++)
    {
        ppcb = Pcb[i];

        if (    NULL == ppcb
            ||  UNAVAILABLE == ppcb->PCB_PortStatus
            ||  REMOVED == ppcb->PCB_PortStatus)

        {
            continue;
        }

        //
        // If the port is not the one we are interested
        // in, ignore it
        //
        if(RDT_Modem == RAS_DEVICE_TYPE(
        pDeviceInfo->rdiDeviceInfo.eDeviceType))
        {
            if(_stricmp(pDeviceInfo->rdiDeviceInfo.szDeviceName,
                        ppcb->PCB_DeviceName))
            {
                continue;
            }
        }
        else
        {
            if(memcmp(&pDeviceInfo->rdiDeviceInfo.guidDevice,
                  &ppcb->PCB_pDeviceInfo->rdiDeviceInfo.guidDevice,
                  sizeof(GUID)))
            {
                continue;
            }
        }

        //
        // Change the ports usage and send notifications
        // to clients regarding this change
        //
        if(fEnable)
        {
            ppcb->PCB_ConfiguredUsage |= CALL_IN;
        }
        else
        {
            ppcb->PCB_ConfiguredUsage &= ~CALL_IN;
        }

        if(fEnableRouter)
        {
            ppcb->PCB_ConfiguredUsage |= CALL_ROUTER;
        }
        else
        {
            ppcb->PCB_ConfiguredUsage &= ~CALL_ROUTER;
        }

        if(fEnableOutboundRouter)
        {
            ppcb->PCB_ConfiguredUsage |= CALL_OUTBOUND_ROUTER;
        }
        else
        {
            ppcb->PCB_ConfiguredUsage &= ~CALL_OUTBOUND_ROUTER;
        }

        dwRetCode = DwPostUsageChangedNotification(ppcb);

        if(dwRetCode)
        {
            RasmanTrace(
                
                "Failed to post the usage changed"
                "notification. 0x%08x",
                dwRetCode);
        }
    }

done:
    return dwRetCode;

}

DWORD
DwGetPortsToRemove (
        DWORD * pcPorts,
        pPCB **pppPCBPorts,
        PBYTE pbguidDevice
        )
{
    ULONG   ulPort;
    pPCB    *pppcbClosed    = NULL;
    pPCB    *pppcbOpen      = NULL;
    DWORD   dwPortsClosed   = 0,
            dwPortsOpen     = 0;
    DWORD   dwRetCode       = SUCCESS;
    pPCB    ppcb;
    CHAR    *pszDeviceType;

    pppcbClosed = LocalAlloc (LPTR, MaxPorts * sizeof (pPCB));

    if (NULL == pppcbClosed)
    {
        dwRetCode = GetLastError();

        RasmanTrace (
            
            "DwGetPortsToRemove: Failed to Allocate. 0x%x",
            dwRetCode );

        goto done;
    }

    pppcbOpen = LocalAlloc (LPTR, MaxPorts * sizeof (pPCB));

    if (NULL == pppcbOpen)
    {
        dwRetCode = GetLastError();

        RasmanTrace (
            
            "DwGetPortsToRemove: Failed to Allocate1. 0x%x",
            dwRetCode );

        LocalFree(pppcbClosed);            

        goto done;
    }

    for (ulPort = 0;  ulPort < MaxPorts ; ulPort++)
    {
        ppcb = GetPortByHandle ( (HPORT) UlongToPtr(ulPort));

        if (    NULL == ppcb
            ||  NULL == ppcb->PCB_pDeviceInfo)
        {
            continue;
        }

        if ( 0 == memcmp(pbguidDevice,
            &ppcb->PCB_pDeviceInfo->rdiDeviceInfo.guidDevice,
            sizeof ( GUID)))
        {
            //
            // If ports are getting removed, attempt to first
            // remove non-connected ports and only then remove
            // connected ports.
            //
            if (    (CLOSED == ppcb->PCB_PortStatus)
                ||  (   (OPEN == ppcb->PCB_PortStatus)
                    &&  (CONNECTED != ppcb->PCB_ConnState)))
            {
                pppcbClosed[dwPortsClosed] = ppcb;

                dwPortsClosed++;
            }
            else if (OPEN == ppcb->PCB_PortStatus)
            {
                pppcbOpen[dwPortsOpen] = ppcb;

                dwPortsOpen++;
            }
        }
    }

    if ( dwPortsOpen )
    {
        memcpy (
            &pppcbClosed[dwPortsClosed],
            pppcbOpen,
            dwPortsOpen * sizeof (pPCB));
    }

    *pcPorts = dwPortsClosed +  dwPortsOpen;
    *pppPCBPorts = pppcbClosed;

done:

    if (pppcbOpen)
    {
        LocalFree(pppcbOpen);
    }

    return dwRetCode ;
}

DWORD
DwRemoveRasTapiPort (pPCB ppcb, PBYTE pbguid)
{
    DWORD       dwRetCode = SUCCESS;

#if DBG
    ASSERT(RastapiRemovePort != NULL);
#endif

    dwRetCode = (DWORD) RastapiRemovePort (ppcb->PCB_Name,
                                       !!(ppcb->PCB_OpenInstances == 0),
                                       pbguid );

    if ( dwRetCode )
    {
        RasmanTrace(
            
            "DwRemoveRasTapiPort: Failed to remove port "
            "from rastapi. 0x%x",
            dwRetCode );
    }

    return dwRetCode;
}

DWORD
DwRemovePort ( pPCB ppcb, PBYTE pbguid )
{
    PPNP_EVENT_NOTIF ppnpEventNotif = NULL;
    RASMAN_PORT      *pRasPort      = NULL;
    DWORD            dwRetCode      = SUCCESS;
    DeviceInfo       *pDeviceInfo   = ppcb->PCB_pDeviceInfo;

    //
    // Disable the port
    //
    ppcb->PCB_PortStatus = UNAVAILABLE ;

    if ( NULL != pDeviceInfo )
    {
        //
        // This means that the user changed the configuration
        // from the ui So we got the notification from the ui
        // instead of from rastapi need to tell rastapi to
        // remove this port.
        //
        dwRetCode = DwRemoveRasTapiPort (ppcb,
                    (PBYTE)
                    &pDeviceInfo->rdiDeviceInfo.guidDevice);

        if ( dwRetCode )
        {
            RasmanTrace(
                
                "DwRemovePort: Failed to remove port %d from "
                "rastapi. 0x%x",
                ppcb->PCB_PortHandle,
                dwRetCode);

            goto done;
        }
    }

    //
    // Notify our clients ( currently ddm ) that the port
    // is removed. This memory will be freed in the clients
    // code.
    //
    ppnpEventNotif = LocalAlloc(LPTR, sizeof (PNP_EVENT_NOTIF));

    if(NULL == ppnpEventNotif)
    {
        dwRetCode = GetLastError();

        RasmanTrace(
            
            "DwRemovePort: Failed to Allocate. %d",
            dwRetCode );

        goto done;
    }

    dwRetCode = InitializeProtocolInfoStructs();

    if(SUCCESS != dwRetCode)
    {
        RasmanTrace(
               "DwRemovePort: InitializeProtocolInfoStructs",
               dwRetCode);
    }
    else
    {
        dwRetCode = SUCCESS;
    }

    ppnpEventNotif->dwEvent = PNPNOTIFEVENT_REMOVE;

    pRasPort = &ppnpEventNotif->RasPort;

    pRasPort->P_Handle          = ppcb->PCB_PortHandle;
    pRasPort->P_Status          = UNAVAILABLE;
    pRasPort->P_ConfiguredUsage = ppcb->PCB_ConfiguredUsage;
    pRasPort->P_CurrentUsage    = ppcb->PCB_CurrentUsage;
    pRasPort->P_LineDeviceId    = ppcb->PCB_LineDeviceId;
    pRasPort->P_AddressId       = ppcb->PCB_AddressId;

    strcpy (pRasPort->P_PortName,
            ppcb->PCB_Name);

    strcpy (pRasPort->P_DeviceType,
            ppcb->PCB_DeviceType);

    strcpy (pRasPort->P_DeviceName,
            ppcb->PCB_DeviceName);

    dwRetCode = DwSignalPnPNotifiers(ppnpEventNotif);

    if (dwRetCode)
    {
        RasmanTrace (
            
            "DwRemovePort: Failed to notify. 0x%x",
            dwRetCode );
    }

    {
        pPCB ppcb = GetPortByHandle(pRasPort->P_Handle);

        if(NULL != ppcb)
        {
        
            DWORD retcode;
            
            //
            // Signal connections folder about the device being
            // removed. Ignore the error - its not fatal.
            //
            g_RasEvent.Type = DEVICE_REMOVED;
            g_RasEvent.DeviceType = 
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType;

            retcode = DwSendNotificationInternal(NULL, &g_RasEvent);

            RasmanTrace(
                   "DwSendNotificationInternal(DEVICE_REMOVED)"
                   " rc=0x%08x, device=0x%x",
                   retcode,
                   g_RasEvent.DeviceType
                   );
        }               
    }
    
    //
    // remove the port from rasman
    // if the openinstances is 0
    //
    if (0 == ppcb->PCB_OpenInstances)
    {
        //
        // If open instances is 0 Remove the port in rasman
        //
        RasmanTrace( 
                "DwRemovePort: Removing port %s, %d",
                ppcb->PCB_Name,
                ppcb->PCB_PortHandle );

        dwRetCode = RemovePort( ppcb->PCB_PortHandle );

        if (dwRetCode)
        {
            RasmanTrace (
                
                "DwRemovePort: Failed to RemovePort %d. 0x%x",
                ppcb->PCB_PortHandle,
                dwRetCode );
        }
    }

done:

    if(NULL != ppnpEventNotif)
    {
        LocalFree(ppnpEventNotif);
    }

    return dwRetCode;
}

DWORD
DwRemovePorts(DWORD dwEndPoints, PBYTE pbguid)
{
    DWORD   dwPort;
    DWORD   cPortsToRemove;
    pPCB    ppcb;
    DWORD   dwRetCode   = SUCCESS;
    pPCB    *ppPCB      = NULL;
    DWORD   cPorts      = 0;
    DeviceInfo *pDeviceInfo = GetDeviceInfo(pbguid, FALSE);

#if DBG
    ASSERT(NULL != pbguid);
#endif

    if(NULL == pDeviceInfo)
    {
        RasmanTrace( "DwRemovePorts - device not found");
        dwRetCode = E_FAIL;
        goto done;
    }

    cPortsToRemove = dwEndPoints
                   - pDeviceInfo->rdiDeviceInfo.dwNumEndPoints;

    RasmanTrace(
        
        "DwGetPortsToRemove: cPortsToRemove=%d",
        cPortsToRemove);

    //
    // Get Ports to remove
    //
    dwRetCode = DwGetPortsToRemove ( &cPorts, &ppPCB, pbguid );

    if ( dwRetCode )
    {
        RasmanTrace (
            
            "DwGetPortsToRemove Failed, 0x%x",
            dwRetCode );

        goto done;

    }

    RasmanTrace(
        
        "DwGetPortsToRemove: Found %d ports to remove",
        cPorts);

    for (
        dwPort = 0;
        (dwPort < cPorts) && (dwPort < cPortsToRemove);
        dwPort++
        )
    {

        ppcb = ppPCB[ dwPort ];

        //
        // If the port is open, disconnect
        //
        if ( OPEN == ppcb->PCB_PortStatus )
        {

            //
            // Disconnect the port
            //
            dwRetCode = DisconnectPort (
                                ppcb,
                                INVALID_HANDLE_VALUE,
                                REMOTE_DISCONNECTION );

            if (    (ERROR_SUCCESS != dwRetCode)
                &&  (PENDING != dwRetCode))
            {
                RasmanTrace(
                    
                    "DwRemovePorts: DisconnectPort Failed. 0x%x",
                    dwRetCode );

                //
                // We need to continue removing the ports
                // even if the disconnect failed since
                // there is nothing else we can do if
                // the port is going away.
                //
            }
        }

        //
        // Remove the port
        //
        dwRetCode = DwRemovePort( ppcb, pbguid );

        if ( dwRetCode )
        {
            RasmanTrace (
                
                "DwRemovePorts: Failed to remove port %s %d. 0x%x",
                ppcb->PCB_Name,
                ppcb->PCB_PortHandle,
                dwRetCode );
        }
    }

done:

    if(NULL != ppPCB)
    {
        LocalFree(ppPCB);
    }

    return dwRetCode;
}

DWORD
DwAddPorts(PBYTE pbguid, PVOID pvReserved)
{
    DWORD       dwRetCode = SUCCESS;

#if DBG
    ASSERT(RastapiAddPorts != NULL);
#endif

    //
    // notify rastapi of the increase in endpoints
    //
    dwRetCode = (DWORD) RastapiAddPorts (pbguid, pvReserved);

    RasmanTrace(
        
        "AddPorts in rastapi returned 0x%x",
        dwRetCode);

    return dwRetCode;
}

DWORD
DwEnableDevice(DeviceInfo *pDeviceInfo)
{
    DWORD dwRetCode = SUCCESS;

    RasmanTrace(
           "Enabling Device %s",
           pDeviceInfo->rdiDeviceInfo.szDeviceName);

    //
    // Add the ports on this device
    //
    dwRetCode = DwAddPorts(
           (PBYTE) &pDeviceInfo->rdiDeviceInfo.guidDevice,
           NULL);

    RasmanTrace(
           "DwEnableDevice returning 0x%08x",
           dwRetCode);

    return dwRetCode;
}

DWORD
DwDisableDevice(DeviceInfo *pDeviceInfo)
{
    DWORD dwRetCode = SUCCESS;
    pPCB  ppcb;
    DWORD i;

    RasmanTrace(
           "Disabling Device %s",
           pDeviceInfo->rdiDeviceInfo.szDeviceName);

    //
    // Remove all ports on this device
    //
    for(i = 0; i < MaxPorts; i++)
    {
        ppcb = Pcb[i];

        if(     NULL == ppcb
            ||  REMOVED == ppcb->PCB_PortStatus
            ||  UNAVAILABLE == ppcb->PCB_PortStatus)
        {
            continue;
        }

        if (0 == memcmp(
                &ppcb->PCB_pDeviceInfo->rdiDeviceInfo.guidDevice,
                &pDeviceInfo->rdiDeviceInfo.guidDevice,
                sizeof(GUID)))
        {
            if(OPEN == ppcb->PCB_PortStatus)
            {
                //
                // Disconnect the port
                //
                dwRetCode = DisconnectPort (
                                    ppcb,
                                    INVALID_HANDLE_VALUE,
                                    REMOTE_DISCONNECTION );

                if ( dwRetCode )
                {
                    RasmanTrace(
                        
                        "DwDisableDevice: DisconnectPort Failed. 0x%x",
                        dwRetCode );
                }
            }

            //
            // Remove the port from rastapi. This will also
            // remove the port from rasman if the openinstances
            // on the ports 0
            //
            dwRetCode = DwRemovePort(ppcb,
                      (PBYTE) &pDeviceInfo->rdiDeviceInfo.guidDevice);

        }   // if
    }   // for

    return dwRetCode;
}


DWORD
DwProcessNewPortNotification ( PNEW_PORT_NOTIF pNewPortNotif )
{
    DWORD               dwMedia;
    DWORD               dwErr       = SUCCESS;
    RASMAN_PORT         *pRasPort   = NULL;
    PPNP_EVENT_NOTIF    ppnpEvent   = NULL;
    PortMediaInfo       *pmiInfo    = (PortMediaInfo *)
                                      pNewPortNotif->NPN_pmiNewPort;
    pDeviceInfo         pdi         = NULL;
    pDeviceInfo         pdiTemp     = pmiInfo->PMI_pDeviceInfo;

    RasmanTrace( "Processing new port notification...");

    for (dwMedia = 0; dwMedia < MaxMedias; dwMedia++)
    {
        if ( 0 == _stricmp (
                    Mcb[dwMedia].MCB_Name,
                    pNewPortNotif->NPN_MediaName ))
            break;
    }

    if (dwMedia == MaxMedias)
    {
        RasmanTrace(
            
            "ProcessNewPortNotification: Media %s not found",
            pNewPortNotif->NPN_MediaName);

        dwErr = ERROR_DEVICE_DOES_NOT_EXIST;

        goto done;
    }

    //
    // Before creating this port check to see if we already have
    // this device information with us. If not add this to our
    // global list
    //
    if (pdiTemp)
    {
        pdi = GetDeviceInfo(
                (RDT_Modem == RAS_DEVICE_TYPE(
                pdiTemp->rdiDeviceInfo.eDeviceType))
                ? (PBYTE) pdiTemp->rdiDeviceInfo.szDeviceName
                : (PBYTE) &pdiTemp->rdiDeviceInfo.guidDevice,
                RDT_Modem == RAS_DEVICE_TYPE(
                pdiTemp->rdiDeviceInfo.eDeviceType));

        if (NULL == pdi)
        {
            pdi = AddDeviceInfo(pdiTemp);

            if (NULL == pdi)
            {
                dwErr = GetLastError();

                RasmanTrace(
                    
                    "ProcessNewPortNotification: failed to allocate",
                    dwErr);

                goto done;
            }

            //
            // Initialize the device status to unavailable.
            // The device will be available when all the
            // ports on this device are added. Initialize the
            // current endpoints to 0. We will count this field
            // in CreatePort.
            //
            pdi->eDeviceStatus = DS_Unavailable;
            pdi->dwCurrentEndPoints = 0;
        }
    }

    pdi->rdiDeviceInfo.fRasEnabled = pdiTemp->rdiDeviceInfo.fRasEnabled;
    pdi->rdiDeviceInfo.fRouterEnabled = pdiTemp->rdiDeviceInfo.fRouterEnabled;

    pmiInfo->PMI_pDeviceInfo = pdi;

    dwErr = CreatePort (&Mcb[dwMedia], pmiInfo);

    pmiInfo->PMI_pDeviceInfo = pdiTemp;

    if (SUCCESS != dwErr)
    {
        RasmanTrace (
            
            "ProcessNewPortNotification: Failed to create port. %d",
            dwErr);
    }

    //
    // Allocate and Fill in the rasman port structure. This structure
    // will be freed in by the consumer of this notification.
    //
    ppnpEvent = LocalAlloc (LPTR, sizeof (PNP_EVENT_NOTIF));

    if (NULL == ppnpEvent)
    {
        dwErr = GetLastError();

        RasmanTrace(
            
            "ProcessNewPortNotification: Failed to allocate. %d",
            dwErr);

        goto done;
    }

    dwErr = InitializeProtocolInfoStructs();

#if DBG
    if(SUCCESS != dwErr)
    {
        DbgPrint("InitializeProtocolInfoStructs rc=0x%x\n",
                 dwErr);
    }
#endif

    dwErr = SUCCESS;

    pRasPort = &ppnpEvent->RasPort;

    strcpy (
        pRasPort->P_MediaName,
        pNewPortNotif->NPN_MediaName);

    FillRasmanPortInfo (pRasPort, pmiInfo);

    ppnpEvent->dwEvent = PNPNOTIFEVENT_CREATE;

    //
    // Notify clients through callbacks about a new port
    //
    dwErr = DwSignalPnPNotifiers(ppnpEvent);

    if (SUCCESS != dwErr)
    {
        RasmanTrace (
            
            "ProcessNewPortNotification: Failed to signal "
            "clients. %d", dwErr);
    }

    {
        pPCB ppcb = GetPortByHandle(pRasPort->P_Handle);

        if(NULL != ppcb)
        {
        
            DWORD retcode;
            
            //
            // Signal connections folder about the new device.
            // Ignore the error - its not fatal.
            //
            g_RasEvent.Type    = DEVICE_ADDED;
            g_RasEvent.DeviceType = 
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType;

            retcode = DwSendNotificationInternal( NULL, &g_RasEvent);

            RasmanTrace(
                   "DwSendNotificationInternal(DEVICE_ADDED)"
                   " rc=0x%08x, Device=0x%x",
                   retcode,
                   g_RasEvent.DeviceType);
        }               
    }
    

done:

    //
    // This memory is allocated in media dlls - rastapi,etc. and
    // is expected to be freed in rasman.
    //
    RasmanTrace(
        
        "Processed new port notification. %d",
        dwErr);

    if(NULL != ppnpEvent)
    {
        LocalFree(ppnpEvent);
    }
    
    LocalFree (pNewPortNotif->NPN_pmiNewPort);
    LocalFree (pNewPortNotif);

    return dwErr;
}

DWORD
DwProcessLineRemoveNotification(REMOVE_LINE_NOTIF *pNotif)
{
    DWORD dwErr = SUCCESS;
    pPCB  ppcb;
    DWORD i;

    //
    // Iterate through the ports and remove
    // all ports on this line
    //
    for (i = 0; i < MaxPorts; i++)
    {
        ppcb = Pcb[i];

        if(     (NULL == ppcb)
            ||  (UNAVAILABLE == ppcb->PCB_PortStatus)
            ||  (REMOVED == ppcb->PCB_PortStatus)
            ||  (pNotif->dwLineId != ppcb->PCB_LineDeviceId))
        {
            continue;
        }

        //
        // If the port is open, disconnect
        //
        if (OPEN == ppcb->PCB_PortStatus)
        {

            //
            // Disconnect the port
            //
            dwErr = DisconnectPort (
                                ppcb,
                                INVALID_HANDLE_VALUE,
                                REMOTE_DISCONNECTION );

            if (dwErr)
            {
                RasmanTrace(
                    
                    "DwProcessLineRemoveNotification: "
                    "DisconnectPort Failed. 0x%x",
                    dwErr );
            }
        }

        //
        // Remove the port
        //
        dwErr =
            DwRemovePort(
                     ppcb,
            (LPBYTE) &ppcb->PCB_pDeviceInfo->rdiDeviceInfo.guidDevice);

        if(SUCCESS != dwErr)
        {
            RasmanTrace(
                   "DwProcessLineRemoveNotification: "
                   "DwRemovePort returned %d",
                   dwErr);
        }

        //
        // Mark the device as invalid if the number
        // of endpoints on the device is 0.
        //
        if(	    (0 == ppcb->PCB_pDeviceInfo->dwCurrentEndPoints)
            &&  (ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwMinWanEndPoints ==
                 ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwMaxWanEndPoints))
        {
            ppcb->PCB_pDeviceInfo->eDeviceStatus = DS_Removed;
            ppcb->PCB_pDeviceInfo->fValid = FALSE;
        }
    }

    //
    // Free the notif structure. This is LocalAlloc'd in rastapi and
    // is expected to be freed here.
    //
    LocalFree(pNotif);

    return dwErr;
}

VOID
UpdateDeviceInfo(DeviceInfo      *pDeviceInfo,
                 RAS_DEVICE_INFO *prdi)
{
    //
    // Update deviceinfo kept in the global list
    //
    pDeviceInfo->rdiDeviceInfo.fRasEnabled =
                            prdi->fRasEnabled;

    pDeviceInfo->rdiDeviceInfo.fRouterEnabled =
                            prdi->fRouterEnabled;

    pDeviceInfo->rdiDeviceInfo.fRouterOutboundEnabled =
                            prdi->fRouterOutboundEnabled;

    pDeviceInfo->rdiDeviceInfo.dwNumEndPoints =
                            prdi->dwNumEndPoints;

    pDeviceInfo->rdiDeviceInfo.dwMaxOutCalls =
                            prdi->dwMaxOutCalls;

    pDeviceInfo->rdiDeviceInfo.dwMaxInCalls =
                            prdi->dwMaxInCalls;
}


DWORD
DwProcessRasConfigChangeNotification(RAS_DEVICE_INFO *prdi)
{
    DWORD dwRetCode = SUCCESS;
    DeviceInfo *pDeviceInfo;

    if(NULL == prdi)
    {
        RasmanTrace(
               "pRasDeviceInfo == NULL");

        dwRetCode = ERROR_INVALID_PARAMETER;

        goto done;
    }

    pDeviceInfo = GetDeviceInfo(
                    (RDT_Modem == RAS_DEVICE_TYPE(
                    prdi->eDeviceType))
                    ? (PBYTE) prdi->szDeviceName
                    : (PBYTE) &prdi->guidDevice,
                    (RDT_Modem == RAS_DEVICE_TYPE(
                    prdi->eDeviceType)));

    if(NULL == pDeviceInfo)
    {
        RasmanTrace(
               "DeviceInfo not found for %s",
               prdi->szDeviceName);

        dwRetCode = ERROR_DEVICE_DOES_NOT_EXIST;

        goto done;
    }

    //
    // Check to see if RasEnability of this
    // device changed
    //
    if(     pDeviceInfo->rdiDeviceInfo.fRasEnabled !=
                            prdi->fRasEnabled
        ||  pDeviceInfo->rdiDeviceInfo.fRouterEnabled !=
                            prdi->fRouterEnabled
        ||  pDeviceInfo->rdiDeviceInfo.fRouterOutboundEnabled !=
                            prdi->fRouterOutboundEnabled)
    {
        //
        // Mark the device as not available
        //
        pDeviceInfo->eDeviceStatus = DS_Unavailable;

#if DBG
        if(prdi->fRouterOutboundEnabled)
        {
            //
            // Assert that if fRouterOutbound is enabled neither
            // of fRouter and fRas are enabled
            //
            ASSERT((!prdi->fRasEnabled) && (!prdi->fRouterEnabled));
        }
#endif
        dwRetCode = DwEnableDeviceForDialIn(
                                pDeviceInfo,
                                prdi->fRasEnabled,
                                prdi->fRouterEnabled,
                                prdi->fRouterOutboundEnabled);

        pDeviceInfo->eDeviceStatus = ((     prdi->fRasEnabled
                                        ||  prdi->fRouterEnabled)
                                     ? DS_Enabled
                                     : DS_Disabled);
    }

    //
    // Check to see if the EndPoints changed on this device
    //
    if (pDeviceInfo->rdiDeviceInfo.dwNumEndPoints
                      != prdi->dwNumEndPoints)
    {
        DWORD dwNumEndPoints =
            pDeviceInfo->rdiDeviceInfo.dwNumEndPoints;

        RasmanTrace(
               "EndPoints Changed for device %s"
               "from %d -> %d",
               prdi->szDeviceName,
               dwNumEndPoints,
               prdi->dwNumEndPoints);

        //
        // Mark the device as not available. This device will
        // again become available when the  whole add or
        // remove operation is completed. Don't mark pptp as
        // as unavailable since otherwise we fail any further
        // configuration of pptp device
        //
        if(RDT_Tunnel_Pptp != RAS_DEVICE_TYPE(
                        pDeviceInfo->rdiDeviceInfo.eDeviceType))
        {
            pDeviceInfo->eDeviceStatus = DS_Unavailable;
        }
        else
        {
            RasmanTrace(
                   "Not marking pptp device as unavailable");
        }

        //
        // This better be a virtual device
        //
        if(RDT_Tunnel != RAS_DEVICE_CLASS(prdi->eDeviceType))
        {
            RasmanTrace(
                   "WanEndpoints changed for a non "
                   "virtualDevice - %d!!!",
                   prdi->eDeviceType);
        }

        //
        // Update deviceinfo kept in the global list
        //
        UpdateDeviceInfo(pDeviceInfo, prdi);

        if(dwNumEndPoints < prdi->dwNumEndPoints)
        {
            DWORD dwEP = prdi->dwNumEndPoints;

            dwRetCode = DwAddPorts((PBYTE) &prdi->guidDevice,
                                    (LPVOID) &dwEP);

            if(dwEP != pDeviceInfo->rdiDeviceInfo.dwNumEndPoints)
            {
                RasmanTrace(
                    
                    "Adjusting the enpoints. NEP=%d, dwEP=%d",
                    pDeviceInfo->rdiDeviceInfo.dwNumEndPoints,
                    dwEP);

                pDeviceInfo->rdiDeviceInfo.dwNumEndPoints = dwEP;

            }
        }
        else
        {
            //
            // Remove the ports only if the current endpoints is
            // greater than the number of ports entered by the user.
            //
            if(prdi->dwNumEndPoints < pDeviceInfo->dwCurrentEndPoints)
            {
                dwRetCode = DwRemovePorts(dwNumEndPoints,
                                    (PBYTE) &prdi->guidDevice);
            }
            else
            {
                RasmanTrace(
                       "Ignoring removal of ports since CEP=%d"
                       ",NEP=%d for device %s",
                        pDeviceInfo->dwCurrentEndPoints,
                        prdi->dwNumEndPoints,
                        prdi->szDeviceName);
            }
        }
    }
    else
    {
        RasmanTrace(
               "No change in EndPoints observed for %s",
               prdi->szDeviceName);
    }

done:
    return dwRetCode;
}

/*++

Routine Description

    The Worker thread is started in this routine:
    Once it has completed its initializations it
    signals the event passed in to the thread.

Arguments

Return Value

    Nothing

--*/
DWORD
RasmanWorker (ULONG_PTR ulpCompletionKey, PRAS_OVERLAPPED pOverlapped)
{
    DWORD   devstate ;
    pPCB    ppcb ;
    RASMAN_DISCONNECT_REASON reason ;
    HCONN   hConn;
    struct ConnectionBlock *pConn;

    ASSERT(NULL != pOverlapped);

    //
    // The main work loop for the worker thread:
    //
    do
    {
        //
        // Exit the main loop if we are trying to shut
        // down the service.
        //
        if (    (RasmanShuttingDown)
            ||  (NULL == pOverlapped))
        {
            break;
        }

        //
        // Get the port associated with this event.
        //
        ppcb = GetPortByHandle((HPORT)ulpCompletionKey);
        if (    ppcb == NULL
            &&  pOverlapped
            &&  OVEVT_DEV_REMOVE != pOverlapped->RO_EventType
            &&  OVEVT_DEV_CREATE != pOverlapped->RO_EventType
            &&  OVEVT_DEV_RASCONFIGCHANGE != pOverlapped->RO_EventType)
        {
            RasmanTrace(
                
                "WorkerThread: ignoring invalid port=%d\n",
                ulpCompletionKey);
            break;
        }

        //
        // This could be one of two things:
        // 1) The driver has signalled a signal transition, or
        // 2) The Device/Media DLLs are signalling in order to
        //    be called again.
        // Check the Media DLL to see if the driver signalled
        // a state change:
        //
        switch (pOverlapped->RO_EventType)
        {
        case OVEVT_DEV_IGNORED:

            RasmanTrace( "OVEVT_DEV_IGNORED. pOverlapped = 0x%x",
            	pOverlapped);
            	
            break;

        case OVEVT_DEV_STATECHANGE:

            reason   = NOT_DISCONNECTED ;
            devstate = INFINITE ;

            RasmanTrace(
                
                "WorkerThread: Disconnect event signaled on port: %s",
                ppcb->PCB_Name);

            RasmanTrace(
                
                "OVEVT_DEV_STATECHANGE. pOverlapped = 0x%x",
            	pOverlapped);



            PORTTESTSIGNALSTATE (ppcb->PCB_Media,
                                ppcb->PCB_PortIOHandle,
                                &devstate) ;

            //
            // Always detect the hardware failure: irrespective
            // of the state
            //
            if (devstate & SS_HARDWAREFAILURE)
            {
                reason = HARDWARE_FAILURE ;
            }

            //
            // Line disconnect noticed only in case the state is
            // CONNECTED or DISCONNECTING
            //
            else if (devstate & SS_LINKDROPPED)
            {
                if (	(ppcb->PCB_ConnState==CONNECTED)
                	||  (ppcb->PCB_ConnState==LISTENCOMPLETED)
                	||  (ppcb->PCB_ConnState==DISCONNECTING)
                	||  (ppcb->PCB_ConnState==CONNECTING)
                	||  (RECEIVE_OUTOF_PROCESS 
                	    & ppcb->PCB_RasmanReceiveFlags))
                {
                    if(RECEIVE_OUTOF_PROCESS & ppcb->PCB_RasmanReceiveFlags)
                    {
                        RasmanTrace(
                            "RasmanWorker: Disconnecting Script remotely"
                            " State=%d", ppcb->PCB_ConnState);
                    }

                    if(CONNECTING == ppcb->PCB_ConnState)
                    {
                        RasmanTrace(
                               "Rasmanworker: Disconnecting port %d in"
                               " CONNECTING state",
                               ppcb->PCB_PortHandle);
                               
                    }
                	
                    reason = REMOTE_DISCONNECTION ;
                }                    
            }

            else
                // why did this get signalled?
                ;

            if (	(reason==HARDWARE_FAILURE)
            	||	(reason == REMOTE_DISCONNECTION))
            {

                if (ppcb->PCB_ConnState == DISCONNECTING)
                {

                    CompleteDisconnectRequest (ppcb) ;

                    //
                    // Remove the timeout request from the timer queue:
                    //
                    if (ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement
                                != NULL)
                    {
                        RemoveTimeoutElement(ppcb);
                    }

                    // CompleteDisconnectRequest above notifies PPP
                    //SendDisconnectNotificationToPPP ( ppcb );

                    ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = NULL;

                }
                else
                {
                    {
                        //
                        // This code is only hit for a line drop or
                        // hardware failure: IF the port is already
                        // disconnected or disconnecting (handled
                        // above) - ignore the link dropped signal.
                        //
                        if (    (reason==HARDWARE_FAILURE)
                            ||  (   (ppcb->PCB_ConnState
                                            != DISCONNECTED)
                                &&  (ppcb->PCB_ConnState
                                            != DISCONNECTING)))
                        {
                            //
                            // Disconnected for some reason - signal
                            // all the notifier events. First, however,
                            // complete any async operations pending
                            // on this port.
                            //
                            if(ppcb->PCB_AsyncWorkerElement.WE_ReqType
                                            != REQTYPE_NONE)
                            {
                                if(     (ppcb->PCB_LastError == SUCCESS)
                                    ||  (ppcb->PCB_LastError == PENDING))
                                {
                                    ppcb->PCB_LastError =
                                       ERROR_PORT_DISCONNECTED;

                                    CompleteAsyncRequest (ppcb);
                                }
                            }

                            RasmanTrace(
                                
                                "%s, %d: Disconnecting port %d, connection"
                                " 0x%x, reason %d", __FILE__, __LINE__,
                                ppcb->PCB_PortHandle, ppcb->PCB_Connection,
                                reason);

                            DisconnectPort(ppcb,
                                           INVALID_HANDLE_VALUE,
                                           reason) ;

                            if (ppcb->PCB_ConnState != DISCONNECTED)
                            {
                                SignalPortDisconnect(ppcb, 0);
                                SignalNotifiers(pConnectionNotifierList,
                                                NOTIF_DISCONNECT, 0);
                            }

                            //
                            // Make sure that the state at this point
                            // is DISCONNECTED there is NO reason it
                            // should be otherwise except for the
                            // medias which bring their DCDs back up
                            // after disconnecting. This will not be the
                            // case if Disconnectport has posted a listen.
                            // DisconnectPort has posted a listen on
                            // this port as a part of disconneting a
                            // biplex port.
                            //
                            if(LISTENING != ppcb->PCB_ConnState)
                            {
                                if(     (ppcb->PCB_Connection)
                                    &&  (ppcb->PCB_Connection->CB_Flags 
                                        & CONNECTION_DEFERRING_CLOSE))
                                {
                                    RasmanTrace("RasmanWorker: not setting to:"
                                    "DISCONNECTED because close deferred");
                                }
                                else
                                {
                                    SetPortConnState(
                                                __FILE__, __LINE__,
                                                ppcb, DISCONNECTED);
                                                
                                    SetPortAsyncReqType(
                                                __FILE__, __LINE__,
                                                ppcb, REQTYPE_NONE);
                                }                                            

                            }
                            else
                            {
                                RasmanTrace(
                                       "Not setting port %s to DISCONNECTED since"
                                       "its listening",
                                       ppcb->PCB_Name);
                            }
                            
                            if(     (SUCCESS == ppcb->PCB_LastError)
                                ||  (PENDING == ppcb->PCB_LastError))
                            {
                                if(LISTENING != ppcb->PCB_ConnState)
                                {
                                    ppcb->PCB_LastError =
                                        ERROR_PORT_DISCONNECTED;
                                }
                                else
                                {
                                    RasmanTrace(
                                           "Worker: not setting error to "
                                           "disconnected for port %d\n",
                                           ppcb->PCB_PortHandle);
                                }
                            }

                            // SendDisconnectNotificationToPPP(ppcb);
                        }
                    }
                }
            }
            break;

        case OVEVT_DEV_ASYNCOP:

            //
            // The Device/Media DLLs are signalling in
            // order to be called again.
            //
            RasmanTrace(
                
                "WorkerThread: Async work event signaled on port: %s",
                ppcb->PCB_Name);

            RasmanTrace(
                
                "OVEVT_DEV_ASYNCOP. pOverlapped = 0x%x",
            	pOverlapped);


            if (ppcb->PCB_ConnState == DISCONNECTED)
            {
                ;
            }

            //
            // If the async "work" is underway on the Port
            // then perform the approp action. If the
            // serviceworkrequest API returns PENDING then
            // do not execute the code that resets the
            // event since the event has already been
            // assocaited with an async op.
            //
            else if (ServiceWorkRequest (ppcb) == PENDING)
            {
                continue ;
            }

            break;

        case OVEVT_DEV_SHUTDOWN:
            RasmanTrace( "WorkerThread: shutting down");

            goto done;

            break;

        case OVEVT_DEV_CREATE:
            RasmanTrace( "WorkerThread: OVEVT_DEV_CREATE. "
                   "pnpn = 0x%x", pOverlapped->RO_Info);

            DwProcessNewPortNotification((PNEW_PORT_NOTIF)
                                       pOverlapped->RO_Info );

            //
            // The overlapped structure is localalloced in rastapi.
            // It is expected to be freed here.
            //
            //LocalFree(pOverlapped);

            break;

        case OVEVT_DEV_REMOVE:
        {
            DWORD dwRetCode;

            RasmanTrace(
                   "RasmanWorker: OVEVT_DEV_REMOVE. pnpn=0x%08x",
                   pOverlapped->RO_Info);

            dwRetCode = DwProcessLineRemoveNotification(
                                        (PREMOVE_LINE_NOTIF)
                                        pOverlapped->RO_Info);

            RasmanTrace(
                   "RasmanWorker: DwProcessLineRemoveNotification"
                   "returned %d",
                   dwRetCode);

            //
            // The overlapped structure is localalloced in rastapi.
            // It is expected to be freed here.
            //
            //LocalFree(pOverlapped);

            break;
        }

        case OVEVT_DEV_RASCONFIGCHANGE:
        {
            DWORD dwRetCode = SUCCESS;

            RasmanTrace(
                   "WorkerThread: Process RASCONFIGCHANGE notification");

            dwRetCode = DwProcessRasConfigChangeNotification(
                            (RAS_DEVICE_INFO *)
                            pOverlapped->RO_Info);

            RasmanTrace(
                    "WorkerThread: Process RASCONFIGCHANGE returned "
                    "0x%08x", dwRetCode);

            LocalFree((LPBYTE) pOverlapped->RO_Info);
            //LocalFree((LPBYTE) pOverlapped);

            break;

        }

        default:
            RasmanTrace(
                
                "WorkerThread: invalid eventtype=%d\n",
                pOverlapped->RO_EventType);
            break;

        }

        //
        // Get the connection handle now to determine
        // whether we need to do redial on link failure
        // below.
        //
        hConn = ( ppcb && (ppcb->PCB_Connection != NULL)) ?
                  ppcb->PCB_Connection->CB_Handle :
                  0;

        //
        // Check to see if we need to invoke the redial
        // callback procedure so rasauto.dll can do
        // redial-on-link-failure.
        //
        if (    pOverlapped->RO_EventType == OVEVT_DEV_STATECHANGE
            &&  hConn != 0)
        {
            pConn = FindConnection(hConn);

            /*
            if (    ppcb->PCB_DisconnectReason != USER_REQUESTED
                &&  RedialCallbackFunc != NULL
                &&  pConn != NULL
                &&  pConn->CB_Ports == 1
                &&  pConn->CB_Signaled)
            {
                (*RedialCallbackFunc)(
                  pConn->CB_ConnectionParams.CP_Phonebook,
                  pConn->CB_ConnectionParams.CP_PhoneEntry);
            } */

            if (    (   (ppcb->PCB_DisconnectReason != USER_REQUESTED)
                    || (ppcb->PCB_fRedial))
                &&  (pConn != NULL)
                &&  (pConn->CB_Ports == 1)
                &&  (pConn->CB_Signaled)
                &&  ((INVALID_HANDLE_VALUE 
                        == ppcb->PCB_hEventClientDisconnect)
                    ||  (NULL == ppcb->PCB_hEventClientDisconnect)))
            {
                DWORD dwErr = DwQueueRedial(pConn);

                RasmanTrace("RasmanWorker queued redial");
                ppcb->PCB_fRedial = FALSE;
            }

            if(     ppcb->PCB_DisconnectReason != USER_REQUESTED
                &&  pConn != NULL
                &&  1 == pConn->CB_Ports)
            {
#if 0
                if(pConn->CB_Signaled)
                {
                   DWORD dwErr = DwQueueRedial(pConn);

                   RasmanTrace(
                          "DwQueueRedial returnd 0x%x", dwErr);
                }
#endif                

#if 0
                //
                // The last port in the connection is being remotely
                // disconnected. Bring down the referred entry at
                // this point if any.
                //
                if(pConn->CB_ReferredEntry)
                {
                    DWORD dwRetCode;

                    dwRetCode = DwCloseConnection(
                                    pConn->CB_ReferredEntry
                                    );

                    RasmanTrace(
                           "RasmanWorker: Failed to close the"
                           " the referred connection. 0x%08x,"
                           "rc=0x%08x",
                           pConn->CB_ReferredEntry,
                           dwRetCode);

                }

#endif
            }

            //
            // If PCB_AutoClose is set, then either the process
            // that has created it has terminated, or the port
            // is a biplex port open by the client and has been
            // disconnected by the remote side.  In this case,
            // we automatically close the port so that if the
            // RAS server is running, the listen will get reposted
            // on the port.
            //
            if (ppcb->PCB_AutoClose)
            {
            	RasmanTrace(
            	    
            	    "%s, %d: Autoclosing port %d", __FILE__,
            		__LINE__, ppcb->PCB_PortHandle);
            		
                (void)PortClose(ppcb, GetCurrentProcessId(),
                                TRUE, FALSE);

            }
            else
            {
            	RasmanTrace(
            	    
            	    "%s, %d: Port %d is not marked for autoclose",
            		__FILE__, __LINE__, ppcb->PCB_PortHandle);
            }
        }
    } while (FALSE);

done:

    if((NULL != pOverlapped)
       && ((pOverlapped->RO_EventType == OVEVT_DEV_CREATE) ||
       (pOverlapped->RO_EventType == OVEVT_DEV_REMOVE) ||
       (pOverlapped->RO_EventType == OVEVT_DEV_RASCONFIGCHANGE)))
    {
        LocalFree((LPBYTE) pOverlapped);
    }

    return SUCCESS ;
}


/*++

Routine Description

    Checks to see what async operation is underway
    on the port and performs the next step in that
    operation.

Arguments

Return Value

    Nothing.

--*/

DWORD
ServiceWorkRequest (pPCB    ppcb)
{
    DWORD       retcode ;
    DWORD       reqtype = ppcb->PCB_AsyncWorkerElement.WE_ReqType;
    pDeviceCB   device ;


    switch (ppcb->PCB_AsyncWorkerElement.WE_ReqType)
    {

    case REQTYPE_DEVICELISTEN:
    case REQTYPE_DEVICECONNECT:


        device = LoadDeviceDLL(ppcb,
                               ppcb->PCB_DeviceTypeConnecting);

        if(NULL == device)
        {
            retcode = ERROR_DEVICE_DOES_NOT_EXIST;
            break;
        }

        //
        // At this point we assume that device will never be NULL:
        //
        retcode = DEVICEWORK(device, ppcb->PCB_PortFileHandle);

        if (retcode == PENDING)
        {
            break ;
        }

        //
        // Either way the request completed.
        //
        if ((ppcb->PCB_AsyncWorkerElement.WE_ReqType) ==
                    REQTYPE_DEVICELISTEN)
        {
            CompleteListenRequest (ppcb, retcode) ;
        }
        else
        {
            // DbgPrint("ServiceWorkRequest: setting lasterror to %d\n", retcode);
            ppcb->PCB_LastError = retcode ;
            CompleteAsyncRequest (ppcb);
        }

        //
        // If listen or connect succeeded then for some medias
        // (specifically unimodem in rastapi) we need to get
        // the file handle for the port as well for use in
        // scripting etc.
        //
        if (    (retcode == SUCCESS)
            &&  (_stricmp (ppcb->PCB_DeviceTypeConnecting,
                           DEVICE_MODEM) == 0)
            &&  (_stricmp (ppcb->PCB_Media->MCB_Name,
                           "RASTAPI") == 0))
        {
            PORTGETIOHANDLE(
                ppcb->PCB_Media,
                ppcb->PCB_PortIOHandle,
                &ppcb->PCB_PortFileHandle) ;
        }

        //
        // The notifier should be freed: otherwise we'll lose it.
        //
        FreeNotifierHandle(
                    ppcb->PCB_AsyncWorkerElement.WE_Notifier);

        SetPortAsyncReqType(__FILE__, __LINE__,
                            ppcb, REQTYPE_NONE);

        ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                            INVALID_HANDLE_VALUE ;

        //
        // Remove the timeout request from the timer queue:
        //
        if (ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement
            != NULL)
        {
            RemoveTimeoutElement(ppcb);
        }

        ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = 0 ;

        break ;

    case REQTYPE_PORTRECEIVEHUB:

        //
        // I guess I need to do something here?????????
        //
        retcode = SUCCESS ;

        break ;

    case REQTYPE_PORTRECEIVE:
    {
       	DWORD bytesread = 0;
       	
        PORTCOMPLETERECEIVE(
            ppcb->PCB_Media,
            ppcb->PCB_PortIOHandle,
            &bytesread) ;

        ppcb->PCB_BytesReceived = bytesread ;

        if ((ppcb->PCB_RasmanReceiveFlags & RECEIVE_OUTOF_PROCESS)
                == 0)
        {
            ppcb->PCB_PendingReceive = NULL ;

            retcode = ppcb->PCB_LastError = SUCCESS ;

            CompleteAsyncRequest ( ppcb );

            SetPortAsyncReqType(
                    __FILE__, __LINE__,
                    ppcb, REQTYPE_NONE);

            FreeNotifierHandle(ppcb->PCB_AsyncWorkerElement.WE_Notifier) ;

            ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                                    INVALID_HANDLE_VALUE ;
        }
        else
        {

            retcode = ppcb->PCB_LastError = SUCCESS;

            CompleteAsyncRequest ( ppcb );

            SetPortAsyncReqType(__FILE__, __LINE__,
                                ppcb, REQTYPE_NONE);

            ppcb->PCB_RasmanReceiveFlags |= RECEIVE_WAITING;

            //
            // Add a timeout element so that we don't wait
            // forever for the client to pick up the received
            // buffer.
            //
            ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement =
                AddTimeoutElement (
                        (TIMERFUNC) OutOfProcessReceiveTimeout,
                        ppcb,
                        NULL,
                        MSECS_OutOfProcessReceiveTimeOut * 1000 );

            AdjustTimer();
        }

        break ;
   }

    default:
        retcode = SUCCESS ;
        break ;
    }

    RasmanTrace
        (
        "ServiceWorkRequest: Async op event %d for port "
        "%s returned %d",
        reqtype,
        ppcb->PCB_Name,
        retcode);

    return retcode ;
}


#if DBG

VOID
MyPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    DWORD length;

    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    length = strlen( OutputBuffer );

    WriteFile(
        GetStdHandle(STD_OUTPUT_HANDLE),
                (LPVOID )OutputBuffer,
                length, &length, NULL );

}


VOID
DumpLine (
    CHAR* p,
    DWORD cb,
    BOOL  fAddress,
    DWORD dwGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR  szHex[ 51 ];
    CHAR* pszHex = szHex;
    CHAR  szAscii[ 17 ];
    CHAR* pszAscii = szAscii;
    DWORD dwGrouped = 0;

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++dwGrouped >= dwGroup)
        {
            *pszHex++ = ' ';
            dwGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    MyPrintf ("%-*s|%-*s|\n", 32 + (16 / dwGroup),
              szHex, 16, szAscii );

}


VOID
Dump(
    CHAR* p,
    DWORD cb,
    BOOL  fAddress,
    DWORD dwGroup )

/*++

Routine description

    Hex dump 'cb' bytes starting at 'p' grouping 'dwGroup' bytes together.
    For example, with 'dwGroup' of 1, 2, and 4:

    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    0000 0000 0000 0000 0000 0000 0000 0000 |................|
    00000000 00000000 00000000 00000000 |................|

    If 'fAddress' is true, the memory address dumped is prepended to each
    line.

Arguments

Return Value

--*/
{
    while (cb)
    {
        INT cbLine = min( cb, 16 );
        DumpLine( p, cbLine, fAddress, dwGroup );
        cb -= cbLine;
        p += cbLine;
    }
}


VOID
FormatAndDisplay (BOOL recv, PBYTE data)
{
    if (recv == 0)
    {
        MyPrintf ("Recvd from hub T>%d >>>>>>>>\r\n", GetCurrentTime());
    }
    else if (recv == 1)
    {
        MyPrintf ("Completed asyn T>%d >>>>>>>>\r\n", GetCurrentTime());
    }
    else
    {
        MyPrintf ("Completed sync T>%d >>>>>>>>\r\n", GetCurrentTime());
    }

    Dump (data, 32, FALSE, 1) ;

    MyPrintf ("\r\n\r\n");
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\timer.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    timer.c

Abstract:

    All timer queue related functions
    
Author:

    Gurdeep Singh Pall (gurdeep) 23-Jun-1997

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <raserror.h>
#include <media.h>
#include <devioctl.h>
#include <stdlib.h>
#include <string.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "rtutils.h"
#include "logtrdef.h"

VOID	DequeueTimeoutElement (DeltaQueueElement *) ;

/*++

Routine Description

    Initializes the delata queue

Arguments

Return Value

    SUCCESS
    
--*/
DWORD
InitDeltaQueue ()
{
    return SUCCESS ;
}


/*++

Routine Description

    Called each second if there are elements in the
    timeout queue.

Arguments

Return Value

    Nothing
    
--*/
VOID
TimerTick ()
{
    DeltaQueueElement *qelt ;
    DeltaQueueElement *temp ;
    DeltaQueueElement *tempqueue = NULL ;

    if ((qelt = TimerQueue.DQ_FirstElement) == NULL) 
    {
	    return ;
    }

    //
    // Decrement time on the first element
    //
    (qelt->DQE_Delta)-- ;

    //
    // Now run through and remove all completed 
    // (delta 0) elements.
    //
    while (     (qelt != NULL) 
            &&  (qelt->DQE_Delta == 0)) 
    {
    	temp = qelt->DQE_Next  ;
    	
    	DequeueTimeoutElement (qelt) ;
    	
    	{
        	DeltaQueueElement *foo = tempqueue ;
        	tempqueue = qelt ;
        	tempqueue->DQE_Next = foo ;
    	}
    	
    	qelt = temp ;
    }

    //
    // Now call the functions associated with each
    // removed element. This is outside of the timer
    // critical section:
    //
    qelt = tempqueue ;
    
    while (qelt != NULL) 
    {

    	temp = qelt->DQE_Next  ;

    	((TIMERFUNC)(qelt->DQE_Function)) (
    	        (pPCB)qelt->DQE_pPcb, qelt->DQE_Arg1
    	        ) ;

    	LocalFree ((PBYTE)qelt) ;

    	qelt = temp ;
    }
}


/*++

Routine Description

    Adds a timeout element into the delta queue. If the Timer is not
    started it is started. Since there is a LocalAlloc() call here -
    this may fail in which case it will simply not insert it in the
    queue and the request will never timeout. NOTE: All timer 
    functions must be called outside of critical sections or
    mutual exclusions on the PCB AsyncOp structures,

Arguments

Return Value

    Pointer to the timeout element inserted.
    
--*/
DeltaQueueElement *
AddTimeoutElement (
        TIMERFUNC func,
        pPCB ppcb,
        PVOID arg1, 
        DWORD timeout
        )
{
    DeltaQueueElement *qelt ;
    
    DeltaQueueElement *last ;
    
    DeltaQueueElement *newelt ;

    //
    // Allocate a new timer element :
    //
    newelt = (DeltaQueueElement *) LocalAlloc (
                                    LPTR,
                                    sizeof(DeltaQueueElement));
    if (newelt == NULL)
    {
        //
     	// This has same effect as element was never inserted
     	//
    	return NULL ;
	}


    newelt->DQE_pPcb	 = (PVOID) ppcb ;
    
    newelt->DQE_Function = (PVOID) func ;
    
    newelt->DQE_Arg1	 = arg1 ;

    for (last = qelt = TimerQueue.DQ_FirstElement;
            (qelt != NULL) 
        &&  (qelt->DQE_Delta < timeout);
        last = qelt, qelt = qelt->DQE_Next)
    {    	 
	    timeout -= qelt->DQE_Delta;
	}

    //
    // insert before qelt: if qelt is NULL then we do no need
    // to worry about the Deltas in the following elements:
    //
    newelt->DQE_Next	= qelt ;
    newelt->DQE_Delta	= timeout ;

    //
    // Empty list
    //
    if (    (last == NULL) 
        &&  (qelt == NULL)) 
    {
    	TimerQueue.DQ_FirstElement = newelt ;
    	newelt->DQE_Last = NULL ;
    }

    //
    // First Element in the list
    //
    else if (TimerQueue.DQ_FirstElement == qelt) 
    {
    	qelt->DQE_Last	   = newelt ;
    	
    	(qelt->DQE_Delta) -= timeout ;
    	
    	TimerQueue.DQ_FirstElement = newelt ;
    }

    //
    // In the middle somewhere
    //
    else if (qelt != NULL) 
    {
    	newelt->DQE_Last	 = qelt->DQE_Last ;
    	
    	qelt->DQE_Last->DQE_Next = newelt ;
    	
    	qelt->DQE_Last		 = newelt ;
    	
    	(qelt->DQE_Delta)	 -= timeout ;
    }

    //
    // Last element
    //
    else if (qelt == NULL) 
    {
    	newelt->DQE_Last	 = last ;
    	
    	last->DQE_Next		 = newelt ;
    }

    return newelt ;
}

/*++

Routine Description

    Removes the timeout element from the queue and frees it.
    NOTE: All timer functions must be called outside of
    critical sections or mutual exclusions on the PCB
    AsyncOp structures,

Arguments

Return Value

    Nothing.
    
--*/
VOID
RemoveTimeoutElement (pPCB ppcb)
{
    DeltaQueueElement *qelt ;

    if (ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement == NULL) 
    {
    	return ;
    }

    qelt = TimerQueue.DQ_FirstElement ;

    //
    // Now run through and remove element if it is in the queue.
    //
    while (qelt != NULL)  
    {
    	if (qelt == ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement) 
    	{
    	    //
    	    // remove it from the delta queue
    	    //
    	    DequeueTimeoutElement (qelt) ;
    	    
    	    LocalFree ((PBYTE) qelt);
    	    
    	    break ;
	}
	
	qelt = qelt->DQE_Next	;
    }

}


VOID
DequeueTimeoutElement (DeltaQueueElement *qelt)
{
    //
    // If first element
    //
    if (qelt == TimerQueue.DQ_FirstElement) 
    {
    	TimerQueue.DQ_FirstElement = qelt->DQE_Next ;
    	
    	if (qelt->DQE_Next) 
    	{
    	    qelt->DQE_Next->DQE_Last = NULL ;
    	    
    	    (qelt->DQE_Next->DQE_Delta) += qelt->DQE_Delta ;
    	}
    }

    //
    // if middle element
    //
    else if ((qelt->DQE_Next) != NULL) 
    {
        //
        // Adjust timeouts
        //
    	(qelt->DQE_Next->DQE_Delta) += qelt->DQE_Delta ;

    	//
    	// Adjust timeouts
    	//
    	(qelt->DQE_Last->DQE_Next) = (qelt->DQE_Next) ;
    	
    	(qelt->DQE_Next->DQE_Last) = (qelt->DQE_Last) ;
    }

    //
    // Last element
    //
    else
    {
	    (qelt->DQE_Last->DQE_Next) = NULL ;
    }

    qelt->DQE_Last = NULL ;
    
    qelt->DQE_Next = NULL ;
}

/*++

Routine Description

    Called by Timer: timeout request.

Arguments

Return Value

    Nothing.
--*/
VOID
ListenConnectTimeout (pPCB ppcb, PVOID arg)
{
    RasmanTrace("ListenConnectTimeout: Timed out on port"
                " %s waiting for listen to complete",
                ppcb->PCB_Name);
    //
    // Timed out when there is nothing to 
    // timeout .... why?
    //
    if ((ppcb->PCB_AsyncWorkerElement.WE_ReqType) == REQTYPE_NONE) 
    {
        //
        // mark ptr null.
        //
    	ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = 0 ;
    	
    	return ;
    }

    if ((ppcb->PCB_AsyncWorkerElement.WE_ReqType) == 
                                    REQTYPE_DEVICELISTEN)
    {
    	CompleteListenRequest (ppcb, ERROR_REQUEST_TIMEOUT) ;
    }
    	
    else 
    {
    	ppcb->PCB_LastError = ERROR_REQUEST_TIMEOUT ;
    	
    	CompleteAsyncRequest (ppcb);
    }

    //
    // This element is free..
    //
    SetPortAsyncReqType(__FILE__, 
                        __LINE__,
                        ppcb,
                        REQTYPE_NONE);
                        
    ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = 0 ;
    
    FreeNotifierHandle (ppcb->PCB_AsyncWorkerElement.WE_Notifier) ;
    
    ppcb->PCB_AsyncWorkerElement.WE_Notifier = INVALID_HANDLE_VALUE ;

}

/*++

Routine Description

    Called by Timer: timeout request.

Arguments

Return Value

    Nothing.
    
--*/
VOID
HubReceiveTimeout (pPCB ppcb, PVOID arg)
{

    RasmanTrace("HubReceiveTimeout: on port %s",
                ppcb->PCB_Name);
    //
    // Timed out when there is nothing to
    // timeout .... why?
    //
    if (ppcb->PCB_PendingReceive == NULL) 
    {
    	ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = 0 ;
    	return ;
    }

    ppcb->PCB_LastError	= ERROR_REQUEST_TIMEOUT ;
    
    CompleteAsyncRequest (ppcb);
    
    ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = 0 ;
    
    ppcb->PCB_PendingReceive = NULL ;
    
    FreeNotifierHandle (ppcb->PCB_AsyncWorkerElement.WE_Notifier) ;
    
    ppcb->PCB_AsyncWorkerElement.WE_Notifier = INVALID_HANDLE_VALUE ;

}

/*++

Routine Description

    Called by Timer: timeout request.

Arguments

Return Value

    Nothing.
    
--*/
VOID
DisconnectTimeout (pPCB ppcb, PVOID arg)
{

	RasmanTrace(
	       "Disconnect on port %d timed out...",
	       ppcb->PCB_PortHandle);

    //
    // Only if we are still not disconnected do
    // we disconnect.
    //
    if (ppcb->PCB_ConnState == DISCONNECTING) 
    {
        CompleteDisconnectRequest (ppcb) ;
        
        //
        // Inform others the port has been disconnected.
        //
        SignalPortDisconnect(ppcb, 0);
        
        SignalNotifiers(pConnectionNotifierList,
                        NOTIF_DISCONNECT,
                        0);
    }

    //
    // no timeout associated
    //
    ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = NULL ;

    SendDisconnectNotificationToPPP ( ppcb );

    RasmanTrace( "Faking a disconnect");
}


/*++

Routine Description

    Called by Timer: timeout request. Gets called when
    rasman times out waiting for an out of process client
    (eg. scripting ) to pick up its received buffer of data.

Arguments

Return Value

    Returns:  Nothing.
    
--*/
VOID
OutOfProcessReceiveTimeout (pPCB ppcb, PVOID arg)
{
    RasmanTrace(
           "Timed out waiting for client to pick up "
           "its data buffer. %d", 
           ppcb->PCB_PortHandle );

    ppcb->PCB_AsyncWorkerElement.WE_TimeoutElement = 0 ;

    if (ppcb->PCB_PendingReceive)
    {
        LocalFree ( ppcb->PCB_PendingReceive );
    }
    
    ppcb->PCB_PendingReceive = NULL ;

    ppcb->PCB_RasmanReceiveFlags = 0;
    
    FreeNotifierHandle (ppcb->PCB_AsyncWorkerElement.WE_Notifier) ;
    
    ppcb->PCB_AsyncWorkerElement.WE_Notifier = INVALID_HANDLE_VALUE ;

}

VOID
BackGroundCleanUp()
{
    PLIST_ENTRY         pEntry;
    ClientProcessBlock  *pCPB;
    DWORD               *pdwPid;
    REQTYPECAST         reqtypecast;
    DWORD               dwAvail = 5, dwCur = 0;
    DWORD               adwPid [5] = {0};
    DWORD               i;
    HANDLE              hProcess = NULL;
    BOOL                fAlive;

    RasmanTrace ( "BackGoundCleanUp");

    pdwPid = adwPid;

    for (pEntry = ClientProcessBlockList.Flink;
         pEntry != &ClientProcessBlockList;
         pEntry = pEntry->Flink)
    {
        pCPB = CONTAINING_RECORD(pEntry, ClientProcessBlock, CPB_ListEntry);

        hProcess = OpenProcess( PROCESS_QUERY_INFORMATION,
                                FALSE,
                                pCPB->CPB_Pid
                               );

        fAlive = fIsProcessAlive(hProcess);                               

        if(NULL != hProcess)
        {
            CloseHandle(hProcess);
        }

        if (!fAlive)
        {
            RasmanTrace(
                   "BackGroundCleanUp: Process %d is not alive. ",
                    pCPB->CPB_Pid);
                                                
            pdwPid[dwCur] = pCPB->CPB_Pid;
            dwCur ++;

            if (dwCur >= dwAvail)
            {
                DWORD *pdwTemp = pdwPid;
                
                dwAvail += 5;
                
                //
                // TODO OPT: Use alloca instead
                //
                pdwPid = (DWORD *) LocalAlloc (LPTR,
                                               dwAvail
                                               * sizeof(DWORD));

                if (NULL == pdwPid) 
                {
                    RasmanTrace(
                           "BackGroundCleanUp: Failed to allocate. %d",
                           GetLastError() );

                    goto done;                                    
                }

                memcpy (pdwPid,
                        pdwTemp,
                        dwCur * sizeof(DWORD));

                if (adwPid != pdwTemp)
                {
                    LocalFree(pdwTemp);
                }
            }
        }
    }
    
    for (i = 0; i < dwCur; i++)
    {
        RasmanTrace(
               "BackGroundCleanUp: Cleaningup process %d",
               pdwPid[i]);
        
        reqtypecast.AttachInfo.dwPid = pdwPid [i];
        
        reqtypecast.AttachInfo.fAttach = FALSE;
        
        ReferenceRasman(NULL, (PBYTE) &reqtypecast);

    }

    if (pdwPid != adwPid)
    {
        LocalFree(pdwPid);
    }

done:    
    return ;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\serial32\serial.c ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: serial.c
//
//  Revision History
//
//  Sep  3, 1992   J. Perry Hannah      Created
//
//
//  Description: This file contains all entry points for SERIAL.DLL
//               which is the media DLL for serial ports.
//
//****************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <rasman.h>
#include <raserror.h>
#include <rasfile.h>
#include <mprlog.h>
#include <rtutils.h>
#include <rasmxs.h>

#include <wanpub.h>
#include <asyncpub.h>

#include <media.h>
#include <serial.h>
#include <serialpr.h>

#include <stdlib.h>
#include <malloc.h>
#include <string.h>



//*  Global Variables  *******************************************************
//

SERIALPCB  *gpSerialPCB;    // Points to Serial PCB linked list
HANDLE     ghRasfileMutex;  // Mutex used to protect access to Rasfile

HRASFILE   ghIniFile;       // Handle to Serial.ini memory image
HANDLE     ghAsyMac;        // Handle to AsyncMac driver
DWORD      gLastError;


//*  Prototypes For APIs That Are Called Internally  *************************
//

DWORD  PortClearStatistics(HANDLE hIOPort);

OVERLAPPED overlapped ;


//*  Initialization Routine  *************************************************
//

//*  SerialDllEntryPoint
//
// Function: Initializes Serial DLL when the DLL is loaded into memory,
//           and cleans up when the last process detaches from the DLL.
//
// Returns: TRUE if successful, else FALSE.
//
//*

BOOL APIENTRY
SerialDllEntryPoint(HANDLE hDll, DWORD dwReason, LPVOID pReserved)
{
  static BOOL  bFirstCall = TRUE;

  char   szIniFilePath[MAX_PATH];
  WCHAR  szDriverName[] = ASYNCMAC_FILENAME;


  DebugPrintf(("SerialDllEntryPoint\n"));
  //DbgPrint("SerialDllEntryPoint\n");

  switch(dwReason)
  {
    case DLL_PROCESS_ATTACH:

      if (bFirstCall)
      {
        DebugPrintf(("\tProcess Attach.\n"));


        // Open Serial.ini file
        *szIniFilePath = '\0';
        GetIniFileName(szIniFilePath, sizeof(szIniFilePath));
        ghIniFile = RasfileLoad(szIniFilePath, RFM_READONLY, NULL, NULL);

        DebugPrintf(("INI: %s, ghIniFile: 0x%08x\n", szIniFilePath, ghIniFile));

        /*
        if (ghIniFile == INVALID_HRASFILE)
        {
          LogError(ROUTERLOG_CANNOT_OPEN_SERIAL_INI, 0, NULL, 0xffffffff);
          return(FALSE);
        } */

        if ((ghRasfileMutex = CreateMutex (NULL,FALSE,NULL)) == NULL)
          return FALSE ;



        // Get handle to Asyncmac driver
        /*
        ghAsyMac = CreateFileW(szDriverName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,                      //No security attribs
                               OPEN_EXISTING,
			       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                               NULL);                     //No template file

        DebugPrintf(("ghAsyMac: 0x%08x\n", ghAsyMac));

        if (ghAsyMac == INVALID_HANDLE_VALUE)
        {
          DebugPrintf(("CreateFileError: %d\n", GetLastError()));

          LogError(ROUTERLOG_CANNOT_GET_ASYNCMAC_HANDLE, 0, NULL, 0xffffffff);
          return(FALSE);
        } */

        bFirstCall = FALSE;
      }
      break;


    case DLL_PROCESS_DETACH:
      DebugPrintf(("\tProcess Detach.\n"));
      if(INVALID_HANDLE_VALUE != ghRasfileMutex
        &&  NULL != ghRasfileMutex)
      {
        CloseHandle(ghRasfileMutex);
        ghRasfileMutex = INVALID_HANDLE_VALUE;
      }
      break;

    case DLL_THREAD_ATTACH:
      DebugPrintf(("\tThread Attach.\n"));
      break;

    case DLL_THREAD_DETACH:
      DebugPrintf(("\tThread Detach.\n"));
      break;
  }

  return(TRUE);

  UNREFERENCED_PARAMETER(hDll);
  UNREFERENCED_PARAMETER(pReserved);
}






//*  Serial APIs  ************************************************************
//


//*  PortEnum  ---------------------------------------------------------------
//
// Function: This API returns a buffer containing a PortMediaInfo struct.
//
// Returns: SUCCESS
//          ERROR_BUFFER_TOO_SMALL
//          ERROR_READING_SECTIONNAME
//          ERROR_READING_DEVICETYPE
//          ERROR_READING_DEVICENAME
//          ERROR_READING_USAGE
//          ERROR_BAD_USAGE_IN_INI_FILE
//
//*

DWORD  APIENTRY
PortEnum(BYTE *pBuffer, DWORD *pdwSize, DWORD *pdwNumPorts)
{
  DWORD          dwAvailable;
  TCHAR          szUsage[RAS_MAXLINEBUFLEN];
  CHAR           szMacName[MAC_NAME_SIZE] ;
  PortMediaInfo  *pPMI;
  BYTE           buffer [1000] ;
  DWORD 	 dwBytesReturned;

  memset (&overlapped, 0, sizeof (OVERLAPPED)) ;

  DebugPrintf(("PortEnum\n"));


  // Count number of sections in serial.ini

  *pdwNumPorts = 0;

    // Begin Exclusion

  WaitForSingleObject(ghRasfileMutex, INFINITE);

  if (  INVALID_HRASFILE != ghIniFile
     && RasfileFindFirstLine(ghIniFile, RFL_SECTION, RFS_FILE))
    (*pdwNumPorts)++;
  else
  {
    *pdwSize = 0;

      // End Exclusion

    ReleaseMutex(ghRasfileMutex);
    return(SUCCESS);
  }

  while(RasfileFindNextLine(ghIniFile, RFL_SECTION, RFS_FILE))
    (*pdwNumPorts)++;

    // End Exclusion

  ReleaseMutex(ghRasfileMutex);


  // Calculate size of buffer needed

  dwAvailable = *pdwSize;
  *pdwSize = sizeof(PortMediaInfo) * (*pdwNumPorts);
  if (*pdwSize > dwAvailable)
    return(ERROR_BUFFER_TOO_SMALL);


  // Translate serial.ini file section by section into pBuffer

  pPMI = (PortMediaInfo *) pBuffer;

    // Begin Exclusion

  WaitForSingleObject(ghRasfileMutex, INFINITE);

  RasfileFindFirstLine(ghIniFile, RFL_SECTION, RFS_FILE);

#if 0
  // Need to get the MAC name

  if (!DeviceIoControl(ghAsyMac,
                       IOCTL_ASYMAC_ENUM,
                       buffer,
                       sizeof(buffer),
                       buffer,
                       sizeof(buffer),
                       &dwBytesReturned,
        		       &overlapped))
  {
      // End Exclusion

    ReleaseMutex(ghRasfileMutex);
    return(GetLastError());
  }

  wcstombs(szMacName, ((PASYMAC_ENUM)buffer)->AdapterInfo[0].MacName,
           wcslen(((PASYMAC_ENUM)buffer)->AdapterInfo[0].MacName)+1) ;

#else
  szMacName[0] = '\0' ;
#endif

  do
  {
    // Get Section Name (same as Port Name)

    if (!RasfileGetSectionName(ghIniFile, pPMI->PMI_Name))
    {
        // End Exclusion

      ReleaseMutex(ghRasfileMutex);
      return(ERROR_READING_SECTIONNAME);
    }


    // Set Binding Name

    strcpy (pPMI->PMI_MacBindingName, szMacName) ;


    // Get Device Type

    if(!(RasfileFindNextKeyLine(ghIniFile, SER_DEVICETYPE_KEY, RFS_SECTION) &&
         RasfileGetKeyValueFields(ghIniFile, NULL, pPMI->PMI_DeviceType)))
    {
        // End Exclusion

      ReleaseMutex(ghRasfileMutex);
      return(ERROR_READING_DEVICETYPE);
    }


    // Get Device Name

    if (!(RasfileFindFirstLine(ghIniFile, RFL_SECTION, RFS_SECTION) &&
          RasfileFindNextKeyLine(ghIniFile, SER_DEVICENAME_KEY, RFS_SECTION) &&
          RasfileGetKeyValueFields(ghIniFile, NULL, pPMI->PMI_DeviceName)))
    {
        // End Exclusion

      ReleaseMutex(ghRasfileMutex);
      return(ERROR_READING_DEVICENAME);
    }


    // Get Usage

    if (!(RasfileFindFirstLine(ghIniFile, RFL_SECTION, RFS_SECTION) &&
          RasfileFindNextKeyLine(ghIniFile, SER_USAGE_KEY, RFS_SECTION) &&
          RasfileGetKeyValueFields(ghIniFile, NULL, szUsage)))
    {
        // End Exclusion

      ReleaseMutex(ghRasfileMutex);
      return(ERROR_READING_USAGE);
    }

    if (!StrToUsage(szUsage, &(pPMI->PMI_Usage)))
    {
        // End Exclusion

      ReleaseMutex(ghRasfileMutex);
      return(ERROR_BAD_USAGE_IN_INI_FILE);
    }

    pPMI->PMI_LineDeviceId = INVALID_TAPI_ID;
    pPMI->PMI_AddressId = INVALID_TAPI_ID;

    pPMI++;

  }while(RasfileFindNextLine(ghIniFile, RFL_SECTION, RFS_FILE));


    // End Exclusion

  ReleaseMutex(ghRasfileMutex);
  return(SUCCESS);
}






//*  PortOpen  ---------------------------------------------------------------
//
// Function: This API opens a COM port.  It takes the port name in ASCIIZ
//           form and supplies a handle to the open port.  hNotify is use
//           to notify the caller if the device on the port shuts down.
//
//           PortOpen allocates a SerialPCB and places it at the head of
//           the linked list of Serial Port Control Blocks.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_CONFIGURED
//          ERROR_DEVICE_NOT_READY
//
//*

DWORD  APIENTRY
PortOpen(
    char *pszPortName, 
    HANDLE *phIOPort, 
    HANDLE hIoCompletionPort, 
    DWORD dwCompletionKey)
{
  SERIALPCB *pSPCB ;
  DWORD     dwRC, dwStatus = 0;
  TCHAR     szPort[MAX_PATH];
  WCHAR  szDriverName[] = ASYNCMAC_FILENAME;
  

  try
  {
    DebugPrintf(("PortOpen: %s\n", pszPortName));


    // Check serial.ini to see that pszPortName is configured for RAS

      // Begin Exclusion

    if(INVALID_HRASFILE == ghIniFile)
    {
        return ERROR_PORT_NOT_CONFIGURED;
    }

    WaitForSingleObject(ghRasfileMutex, INFINITE);

#if DBG
    ASSERT(INVALID_HRASFILE != ghIniFile );
#endif    

    if (!RasfileFindSectionLine(ghIniFile, pszPortName, FROM_TOP_OF_FILE))
    {
        // End Exclusion

      ReleaseMutex(ghRasfileMutex);
      return(ERROR_PORT_NOT_CONFIGURED);
    }
      // End Exclusion

    ReleaseMutex(ghRasfileMutex);



    // Prepend \\.\ to COMx

    strcpy(szPort, "\\\\.\\");
    strcat(szPort, pszPortName);


    // Open Port

    *phIOPort = CreateFile(szPort,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_EXCLUSIVE_MODE,
                           NULL,                       //No Security Attributes
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                           NULL);                            //No Template File


    DebugPrintf(("hioport: 0x%08x\n", *phIOPort));
    //DbgPrint("hioport: 0x%08x\n", *phIOPort);

    if (*phIOPort == INVALID_HANDLE_VALUE)
    {
      dwRC = GetLastError();
      if (dwRC == ERROR_ACCESS_DENIED)
	return (ERROR_PORT_ALREADY_OPEN);
      else if (dwRC == ERROR_FILE_NOT_FOUND)
	return (ERROR_PORT_NOT_FOUND) ;
      else
        return(dwRC);
    }

    //
    // Associate an I/O completion port with 
    // the file handle.
    //
    if (CreateIoCompletionPort(
          *phIOPort, 
          hIoCompletionPort, 
          dwCompletionKey, 
          0) == NULL)
    {
        return GetLastError();
    }

        

#ifdef notdef
    {
    DWORD      dwBytesReturned ;

#define FILE_DEVICE_SERIAL_PORT	  0x0000001b
#define _SERIAL_CONTROL_CODE(request,method) \
		((FILE_DEVICE_SERIAL_PORT)<<16 | (request<<2) | method)
#define IOCTL_SERIAL_PRIVATE_RAS  _SERIAL_CONTROL_CODE(4000, METHOD_BUFFERED)

    DeviceIoControl(*phIOPort,
                    IOCTL_SERIAL_PRIVATE_RAS,
                    NULL,
                    0,
                    NULL,
                    0,
                    &dwBytesReturned,
                    NULL) ;
    }
#endif

    // Set Queue sizes and default values for Comm Port

    if (!SetupComm(*phIOPort, INPUT_QUEUE_SIZE, OUTPUT_QUEUE_SIZE))
    {
      LogError(ROUTERLOG_SERIAL_QUEUE_SIZE_SMALL, 0, NULL, 0xffffffff);
    }

    SetCommDefaults(*phIOPort, pszPortName);


    // Add a Serial PCB to head of list and set eDeviceType

    AddPortToList(*phIOPort, pszPortName);

    pSPCB = FindPortInList(*phIOPort, NULL) ;           //Find port just added

    if(NULL == pSPCB)
    {
        return ERROR_PORT_NOT_FOUND;
    }

    // Get handle to Asyncmac driver

    pSPCB->hAsyMac = CreateFileW(szDriverName,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,                      //No security attribs
                           OPEN_EXISTING,
	        		       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                           NULL);                     //No template file

    DebugPrintf(("pSPCB->hAsyMac: 0x%08x\n", pSPCB->hAsyMac));
    
    //DbgPrint("pSPCB->hAsyMac: 0x%08x\n", pSPCB->hAsyMac);
    
    if (pSPCB->hAsyMac == INVALID_HANDLE_VALUE)
    {
        DWORD dwErr;
        dwErr = GetLastError();
        DebugPrintf(("CreateFileError: %d\n", dwErr));
        //DbgPrint("CreateFileError: %d\n", dwErr);

        LogError(ROUTERLOG_CANNOT_GET_ASYNCMAC_HANDLE, 0, NULL, 0xffffffff);
        return(dwErr);
    }
   

    //
    // Associate the I/O completion port with
    // the asyncmac file handle
    //
    if (CreateIoCompletionPort(pSPCB->hAsyMac,
                               hIoCompletionPort,
                               dwCompletionKey,
                               0) == NULL)
    {
        DWORD dwErr;
        dwErr = GetLastError();
        //DbgPrint("PortOpen: Failed to create IoCompletionPort %d\n", dwErr);
        return dwErr;
    }
    
    dwRC = InitCarrierBps(pszPortName, pSPCB->szCarrierBPS);
    if (dwRC != SUCCESS)
    {
      gLastError = dwRC;
      RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }


    // Check that device is powered on and ready (DSR is up) If it is then
    // we monitor DSR - else - we do not monitor DSR until we are connected.
    //
    GetCommModemStatus(*phIOPort, &dwStatus);

    pSPCB->dwPreviousModemStatus = 0;
    
    if ( ! (dwStatus & MS_DSR_ON))
    // DSR is not raised by the device = assume that it will not raise
    // it until its connected.
    //
    pSPCB->dwActiveDSRMask = pSPCB->dwMonitorDSRMask = 0 ;
    else {
    // Tell system to signal rasman if DSR drops

    pSPCB->dwActiveDSRMask = pSPCB->dwMonitorDSRMask = EV_DSR ;
    //DbgPrint("PortOpen: Setting mask 0x%x\n", EV_DSR);
    SetCommMask(*phIOPort, EV_DSR);


    if (!WaitCommEvent(*phIOPort,
                  &(pSPCB->dwEventMask),
                  (LPOVERLAPPED)&(pSPCB->MonitorDevice)))
    {                  

        //DbgPrint("PortOpen: WaitCommEvent. %d\n", GetLastError());
    }

    }

    // Set values in Serial Port Control Block

    GetDefaultOffStr(*phIOPort, pszPortName);

  }
  except(exception_code()==EXCEPT_RAS_MEDIA ? HANDLE_EXCEPTION:CONTINUE_SEARCH)
  {
    return(gLastError);
  }

  return(SUCCESS);
}





//*  PortClose  --------------------------------------------------------------
//
// Function: This API closes the COM port for the input handle.  It also
//           finds the SerialPCB for the input handle, removes it from
//           the linked list, and frees the memory for it
//
// Returns: SUCCESS
//          Values returned by GetLastError()
//
//*

DWORD  APIENTRY
PortClose (HANDLE hIOPort)
{
  SERIALPCB  *pPrev, *pSPCB = gpSerialPCB;


  DebugPrintf(("PortClose\n"));


  // Find the SerialPCB which contains hIOPOrt

  pSPCB = FindPortInList(hIOPort, &pPrev);

  if (pSPCB == NULL)
    return(ERROR_PORT_NOT_OPEN);


  // Remove the found SerialPCB

  if (pSPCB == gpSerialPCB)
    gpSerialPCB = pSPCB->pNextSPCB;
  else
    pPrev->pNextSPCB = pSPCB->pNextSPCB;

  // Cancel wait on this port  (WaitCommEvent)
  //
  //DbgPrint("PortClose: Setting mask to 0\n");
  SetCommMask(hIOPort, 0);

  // Drop DTR
  //
  EscapeCommFunction(hIOPort, CLRDTR);

  // Close COM Port
  //
  if (!CloseHandle(hIOPort))
    return(GetLastError());

  // close the asymac file we associated with this com port
  if (!CloseHandle(pSPCB->hAsyMac))
    return GetLastError();

  // Free portcontrolblock: note this must be done after CloseHandle since the struct
  // contains an overlapped struct used for i/o on the port. this overlapped struct
  // is freed when the handle to the port is closed.
  //
  free(pSPCB);

  return(SUCCESS);
}





//*  PortGetInfo  ------------------------------------------------------------
//
// Function: This API returns a block of information to the caller about
//           the port state.  This API may be called before the port is
//           open in which case it will return inital default values
//           instead of actual port values.
//
//           If the API is to be called before the port is open, set hIOPort
//           to INVALID_HANDLE_VALUE and pszPortName to the port name.  If
//           hIOPort is valid (the port is open), pszPortName may be set
//           to NULL.
//
//           hIOPort  pSPCB := FindPortNameInList()  Port
//           -------  -----------------------------  ------
//           valid    x                              open
//           invalid  non_null                       open
//           invalid  null                           closed
//
// Returns: SUCCESS
//          ERROR_BUFFER_TOO_SMALL
//*

DWORD  APIENTRY
PortGetInfo(HANDLE hIOPort, TCHAR *pszPortName, BYTE *pBuffer, DWORD *pdwSize)
{
  SERIALPCB   *pSPCB;
  DCB         DCB;
  RAS_PARAMS  *pParam;
  TCHAR       *pValue;
  TCHAR       szDefaultOff[RAS_MAXLINEBUFLEN];
  TCHAR       szClientDefaultOff[RAS_MAXLINEBUFLEN];
  TCHAR       szDeviceType[MAX_DEVICETYPE_NAME + 1];
  TCHAR       szDeviceName[MAX_DEVICE_NAME + 1];
  TCHAR       szPortName[MAX_PORT_NAME + 1];
  TCHAR       szConnectBPS[MAX_BPS_STR_LEN], szCarrierBPS[MAX_BPS_STR_LEN];
  DWORD       dwConnectBPSLen, dwCarrierBPSLen, dwDefaultOffLen;
  DWORD       dwDeviceTypeLen, dwDeviceNameLen, dwPortNameLen;
  DWORD       dwClientDefaultOffLen;
  DWORD       dwStructSize;
  DWORD       dwAvailable, dwNumOfParams = 12;

  try
  {

    DebugPrintf(("PortGetInfo\n"));

    if (hIOPort == INVALID_HANDLE_VALUE &&
        (pSPCB = FindPortNameInList(pszPortName)) == NULL)
    {
      // Port is not yet open

      // Read from Serial.ini

      GetValueFromFile(pszPortName, SER_DEFAULTOFF_KEY,    szDefaultOff);
      GetValueFromFile(pszPortName, SER_MAXCONNECTBPS_KEY, szConnectBPS);
      GetValueFromFile(pszPortName, SER_MAXCARRIERBPS_KEY, szCarrierBPS);
      GetValueFromFile(pszPortName, SER_DEVICETYPE_KEY,    szDeviceType);
      GetValueFromFile(pszPortName, SER_DEVICENAME_KEY,    szDeviceName);
      strcpy(szPortName, pszPortName);


      // Set RAS default values in the DCB

      SetDcbDefaults(&DCB);
    }
    else
    {
       // Port is open; Get a Device Control Block with current port values

      if (hIOPort != INVALID_HANDLE_VALUE)
      {
        pSPCB = FindPortInList(hIOPort, NULL);
        if (pSPCB == NULL)
        {
          gLastError = ERROR_PORT_NOT_OPEN;
          RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
      }

      if (!GetCommState(pSPCB->hIOPort, &DCB))
      {
        gLastError = GetLastError();
        RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
      }

      _itoa(DCB.BaudRate, szConnectBPS, 10);
      strcpy(szCarrierBPS, pSPCB->szCarrierBPS);
      strcpy(szDefaultOff, pSPCB->szDefaultOff);
      strcpy(szDeviceType, pSPCB->szDeviceType);
      strcpy(szDeviceName, pSPCB->szDeviceName);
      strcpy(szPortName,   pSPCB->szPortName);
    }



    // Read from Serial.ini even if port is open

    GetValueFromFile(szPortName, SER_C_DEFAULTOFFSTR_KEY, szClientDefaultOff);


    // Calculate Buffer size needed

    dwStructSize = sizeof(RASMAN_PORTINFO)
                   + sizeof(RAS_PARAMS) * (dwNumOfParams - 1);

    dwConnectBPSLen = strlen(szConnectBPS);
    dwCarrierBPSLen = strlen(szCarrierBPS);
    dwDeviceTypeLen = strlen(szDeviceType);
    dwDeviceNameLen = strlen(szDeviceName);
    dwDefaultOffLen = strlen(szDefaultOff);
    dwPortNameLen   = strlen(szPortName);
    dwClientDefaultOffLen = strlen(szClientDefaultOff);

    dwAvailable = *pdwSize;
    *pdwSize =   (dwStructSize + dwConnectBPSLen + dwCarrierBPSLen
                                   + dwDeviceTypeLen + dwDeviceNameLen
                                   + dwDefaultOffLen + dwPortNameLen
                                   + dwClientDefaultOffLen +
                                   + 7L);  //Zero bytes
    if (*pdwSize > dwAvailable)
      return(ERROR_BUFFER_TOO_SMALL);



    // Fill in Buffer

    ((RASMAN_PORTINFO *)pBuffer)->PI_NumOfParams = ( WORD ) dwNumOfParams;

    pParam = ((RASMAN_PORTINFO *)pBuffer)->PI_Params;
    pValue = pBuffer + dwStructSize;

    strcpy(pParam->P_Key, SER_CONNECTBPS_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = dwConnectBPSLen;
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, szConnectBPS);
    pValue += dwConnectBPSLen + 1;

    pParam++;
    strcpy(pParam->P_Key, SER_DATABITS_KEY);
    pParam->P_Type = Number;
    pParam->P_Attributes = 0;
    pParam->P_Value.Number = DCB.ByteSize;

    pParam++;
    strcpy(pParam->P_Key, SER_PARITY_KEY);
    pParam->P_Type = Number;
    pParam->P_Attributes = 0;
    pParam->P_Value.Number = DCB.Parity;

    pParam++;
    strcpy(pParam->P_Key, SER_STOPBITS_KEY);
    pParam->P_Type = Number;
    pParam->P_Attributes = 0;
    pParam->P_Value.Number = DCB.StopBits;

    pParam++;
    strcpy(pParam->P_Key, SER_HDWFLOWCTRLON_KEY);
    pParam->P_Type = Number;
    pParam->P_Attributes = 0;
    pParam->P_Value.Number = DCB.fOutxCtsFlow;

    pParam++;
    strcpy(pParam->P_Key, SER_CARRIERBPS_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = dwCarrierBPSLen;
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, szCarrierBPS);
    pValue += dwCarrierBPSLen + 1;

    pParam++;
    strcpy(pParam->P_Key, SER_ERRORCONTROLON_KEY);
    pParam->P_Type = Number;
    pParam->P_Attributes = 0;
    if (pSPCB == NULL)
      pParam->P_Value.Number = FALSE;
    else
      pParam->P_Value.Number = pSPCB->bErrorControlOn;

    pParam++;
    strcpy(pParam->P_Key, SER_DEFAULTOFFSTR_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = dwDefaultOffLen;
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, szDefaultOff);
    pValue += dwDefaultOffLen + 1;

    pParam++;
    strcpy(pParam->P_Key, SER_DEVICETYPE_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = dwDeviceTypeLen;
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, szDeviceType);
    pValue += dwDeviceTypeLen + 1;

    pParam++;
    strcpy(pParam->P_Key, SER_DEVICENAME_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = dwDeviceNameLen;
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, szDeviceName);
    pValue += dwDeviceNameLen + 1;

    pParam++;
    strcpy(pParam->P_Key, SER_PORTNAME_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = dwPortNameLen;
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, szPortName);
    pValue += dwPortNameLen + 1;

    pParam++;
    strcpy(pParam->P_Key, SER_C_DEFAULTOFFSTR_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = dwClientDefaultOffLen;
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, szClientDefaultOff);
    //pValue += dwClientDefaultOffLen + 1;


    return(SUCCESS);

  }
  except(exception_code()==EXCEPT_RAS_MEDIA ? HANDLE_EXCEPTION:CONTINUE_SEARCH)
  {
    return(gLastError);
  }
}






//*  PortSetInfo  ------------------------------------------------------------
//
// Function: The values for most input keys are used to set the port
//           parameters directly.  However, the carrier BPS and the
//           error conrol on flag set fields in the Serial Port Control
//           Block only, and not the port.
//
// Returns: SUCCESS
//          ERROR_WRONG_INFO_SPECIFIED
//          Values returned by GetLastError()
//*

DWORD  APIENTRY
PortSetInfo(HANDLE hIOPort, RASMAN_PORTINFO *pInfo)
{
  RAS_PARAMS *p;
  SERIALPCB  *pSPCB;
  DCB        DCB;
  WORD       i;
  BOOL       bTypeError = FALSE;


  try
  {

    DebugPrintf(("PortSetInfo\n\thPort = %d\n", hIOPort));


    // Find the SerialPCB which contains hIOPOrt

    pSPCB = FindPortInList(hIOPort, NULL);

    if (pSPCB == NULL)
    {
      gLastError = ERROR_PORT_NOT_OPEN;
      RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }


    // Get a Device Control Block with current port values

    if (!GetCommState(hIOPort, &DCB))
      return(GetLastError());


    // Set DCB and PCB values

    for (i=0, p=pInfo->PI_Params; i<pInfo->PI_NumOfParams; i++, p++)
    {
      // Set DCB values

      if (_stricmp(p->P_Key, SER_CONNECTBPS_KEY) == 0)

        DCB.BaudRate = ValueToNum(p);

      else if (_stricmp(p->P_Key, SER_DATABITS_KEY) == 0)

        DCB.ByteSize = (BYTE) ValueToNum(p);

      else if (_stricmp(p->P_Key, SER_PARITY_KEY) == 0)

        DCB.Parity = (BYTE) ValueToNum(p);

      else if (_stricmp(p->P_Key, SER_STOPBITS_KEY) == 0)

        DCB.StopBits = (BYTE) ValueToNum(p);

      else if (_stricmp(p->P_Key, SER_HDWFLOWCTRLON_KEY) == 0)

        DCB.fOutxCtsFlow = ValueToBool(p);


      // Set PCB values

      else if (_stricmp(p->P_Key, SER_CARRIERBPS_KEY) == 0)

        if (p->P_Type == String)
        {
          strncpy(pSPCB->szCarrierBPS,
                  p->P_Value.String.Data,
                  p->P_Value.String.Length);

          pSPCB->szCarrierBPS[p->P_Value.String.Length] = '\0';
        }
        else
          _itoa(p->P_Value.Number, pSPCB->szCarrierBPS, 10);

      else if (_stricmp(p->P_Key, SER_ERRORCONTROLON_KEY) == 0)

        pSPCB->bErrorControlOn = ValueToBool(p);

      else if (_stricmp(p->P_Key, SER_DEFAULTOFF_KEY) == 0)

        if (p->P_Type == String)
        {
          strncpy(pSPCB->szDefaultOff,
                  p->P_Value.String.Data,
                  p->P_Value.String.Length);

          pSPCB->szDefaultOff[p->P_Value.String.Length] = '\0';
        }
        else
          pSPCB->szDefaultOff[0] = USE_DEVICE_INI_DEFAULT;


      else
        return(ERROR_WRONG_INFO_SPECIFIED);

    } // for


    // Send DCB to Port

    if (!SetCommState(hIOPort, &DCB))
      return(GetLastError());


    return(SUCCESS);

  }
  except(exception_code()==EXCEPT_RAS_MEDIA ? HANDLE_EXCEPTION:CONTINUE_SEARCH)
  {
    return(gLastError);
  }
}





//*  PortTestSignalState  ----------------------------------------------------
//
// Function: This API indicates the state of the DSR and DTR lines.
//            DSR - Data Set Ready
//            DCD - Data Carrier Detect (RLSD - Received Line Signal Detect)
//
// Returns: SUCCESS
//          Values returned by GetLastError()
//
//*

DWORD  APIENTRY
PortTestSignalState(HANDLE hIOPort, DWORD *pdwDeviceState)
{
  DWORD 	dwModemStatus;
  SERIALPCB     *pSPCB;
  DWORD 	dwSetMask = 0 ;

  DebugPrintf(("PortTestSignalState\n"));

  *pdwDeviceState = 0;
  

  if ((pSPCB = FindPortInList (hIOPort, NULL)) == NULL)
    return ERROR_PORT_NOT_OPEN ;

  if (!GetCommModemStatus(hIOPort, &dwModemStatus))
  {
    *pdwDeviceState = 0xffffffff;
    return(GetLastError());
  }

  // If DSR is down AND it was up before then mark it as a hw failure.
  //
  if ((!(dwModemStatus & MS_DSR_ON)) && (pSPCB->dwMonitorDSRMask))
    *pdwDeviceState |= SS_HARDWAREFAILURE;

  // Similarly, if DCD is down and it was up before then link has dropped.
  //
  if (!(dwModemStatus & MS_RLSD_ON))
    *pdwDeviceState |= SS_LINKDROPPED;
  else
      dwSetMask = EV_RLSD ;

  if (pSPCB->uRasEndpoint != INVALID_HANDLE_VALUE) {
    ASYMAC_DCDCHANGE	  A ;
    DWORD		  dwBytesReturned;

    A.MacAdapter = NULL ;
    A.hNdisEndpoint = (HANDLE) pSPCB->uRasEndpoint ;
    DeviceIoControl(pSPCB->hAsyMac,
                    IOCTL_ASYMAC_DCDCHANGE,
                    &A,
                    sizeof(A),
                    &A,sizeof(A),
                    &dwBytesReturned,
                    (LPOVERLAPPED)&(pSPCB->MonitorDevice)) ;

  } else {

    dwSetMask |= (pSPCB->dwMonitorDSRMask) ; // Only monitor DSR if it is used.

    if (dwSetMask == 0)
	return (SUCCESS) ;  // do not set wait mask.

    if (dwModemStatus == pSPCB->dwPreviousModemStatus)
    {
        //DbgPrint("PortTestSignalState: Modemstatus hasn't changed\n");
        return SUCCESS;
    }
    else
        pSPCB->dwPreviousModemStatus = dwModemStatus;

    //DbgPrint("PortTestSignalState: Setting mask ox%x\n", dwSetMask);
    SetCommMask(hIOPort, dwSetMask);

    // Start a new wait on signal lines (DSR and/or DCD)

    if (!WaitCommEvent(hIOPort,
                   &(pSPCB->dwEventMask),
                    (LPOVERLAPPED)&(pSPCB->MonitorDevice)))
    {
        //DbgPrint("PortTestSignalState: WaitCommEvent. %d\n", GetLastError());
    }
  }

  return(SUCCESS);
}





//*  PortConnect  ------------------------------------------------------------
//
// Function: This API is called when a connection has been completed and some
//	     steps need to be taken, If bWaitForDevice is set then we monitor DCD only
//	     else,
//           It in turn calls the asyncmac device driver in order to
//           indicate to asyncmac that the port and the connection
//           over it are ready for commumication.
//
//           pdwCompressionInfo is an output only parameter which
//           indicates the type(s) of compression supported by the MAC.
//
//	     bWaitForDevice is set to TRUE when we just want to start monitoring DCD
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_OPEN
//          ERROR_NO_CONNECTION
//          Values returned by GetLastError()
//
//*

DWORD  APIENTRY
PortConnect(HANDLE             hIOPort,
            BOOL               bWaitForDevice,
	        HANDLE	           *pRasEndpoint)
{
  ASYMAC_OPEN	AsyMacOpen;
  ASYMAC_DCDCHANGE    A ;
  SERIALPCB     *pSPCB;
  BOOL          bPadDevice;
  DWORD         dwModemStatus, dwBytesReturned;
  TCHAR         szDeviceType[RAS_MAXLINEBUFLEN];


  // This is a special mode of PortConnect where all we do is start monitoring DCD
  // Hand off to asyncmac does not happen till the next call to port connect where the
  // bWaitForDevice flag is false
  //

  if (bWaitForDevice) {

    pSPCB = FindPortInList(hIOPort, NULL);

    if (pSPCB == NULL)
    {
      gLastError = ERROR_PORT_NOT_OPEN;
      return ERROR_NO_CONNECTION ;
    }

    if (!GetCommModemStatus(hIOPort, &dwModemStatus))
	return(GetLastError());


    // UPDATE the DSR monitoring
    //
    if (!(dwModemStatus & MS_DSR_ON))
	 pSPCB->dwMonitorDSRMask = 0 ;
    else
	 pSPCB->dwMonitorDSRMask = EV_DSR ;

    // Tell serial driver to signal rasman if DCD, (and DSR, if it was used) drop
    //
    //DbgPrint("PortConnect: Setting mask to 0x%x\n",EV_RLSD | (pSPCB->dwMonitorDSRMask));
    if (!SetCommMask(hIOPort, EV_RLSD | (pSPCB->dwMonitorDSRMask)))
    	return(GetLastError());

    WaitCommEvent(hIOPort,
		   &(pSPCB->dwEventMask),
		   (LPOVERLAPPED) &(pSPCB->MonitorDevice)) ;

    return SUCCESS ;
  }


  // Else we do both - change DCD monitoring and handing off context to asyncmac
  //
  memset (&overlapped, 0, sizeof (OVERLAPPED)) ;

  try
  {

    DebugPrintf(("PortConnect\n"));


    // Find port in list

    pSPCB = FindPortInList(hIOPort, NULL);

    if (pSPCB == NULL)
    {
      gLastError = ERROR_PORT_NOT_OPEN;
      RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }


    //Make sure connection is still up

    if (!GetCommModemStatus(hIOPort, &dwModemStatus))
      return(GetLastError());


    // Make sure that DSR is still up (if it ever was up!)

    if ((!(dwModemStatus & MS_DSR_ON)) && (pSPCB->dwMonitorDSRMask)) {
	OutputDebugString ("DSR down!!!\r\n") ;
	return(ERROR_NO_CONNECTION);			     //Device is down
    }

    if (!(dwModemStatus & MS_RLSD_ON) ) {
	OutputDebugString ("DCD down!!!\r\n") ;
	return(ERROR_NO_CONNECTION);			     //DCD is down
    }

//    // UPDATE the DSR monitoring
//    //
//    if ( ! (dwModemStatus & MS_DSR_ON)) {
//	 pSPCB->dwMonitorDSRMask = 0 ;
//    } else {
//	 pSPCB->dwMonitorDSRMask = EV_DSR ;
//    }
//
//    // Tell system to signal rasman if DCD, (and DSR, if it was used) drop
//
//    if (!SetCommMask(hIOPort, EV_RLSD | (pSPCB->dwMonitorDSRMask)))
//	return(GetLastError());
//
//    WaitCommEvent(hIOPort,
//		   &(pSPCB->dwEventMask),
//		   &(pSPCB->MonitorDevice)) ;

    //Put endpoint in Serial PCB for later use by PortDisconnect


    //Find if device type is Pad

    GetValueFromFile(pSPCB->szPortName, SER_DEVICETYPE_KEY, szDeviceType);

    bPadDevice = (_stricmp(szDeviceType, MXS_PAD_TXT) == 0);


    // Let the ASYMAC notify us of DCD and DSR change
    //
    //DbgPrint("PortConnect: Setting mask to 0\n");
    if (!SetCommMask(hIOPort, 0))   // Set mask to stop monitoring DCD
	return(GetLastError());


    //Open AsyncMac (Hand off port to AsyncMac)

    AsyMacOpen.hNdisEndpoint = INVALID_HANDLE_VALUE ;
    AsyMacOpen.LinkSpeed = (atoi(pSPCB->szCarrierBPS) == 0) ?
                           14400 :
                           atoi(pSPCB->szCarrierBPS) ;
    AsyMacOpen.FileHandle = hIOPort;

    if (bPadDevice || pSPCB->bErrorControlOn)
      AsyMacOpen.QualOfConnect = (UINT)NdisWanErrorControl;
    else
      AsyMacOpen.QualOfConnect = (UINT)NdisWanRaw;

    if (!DeviceIoControl(pSPCB->hAsyMac,
                         IOCTL_ASYMAC_OPEN,
                         &AsyMacOpen,
                         sizeof(AsyMacOpen),
                         &AsyMacOpen,
                         sizeof(AsyMacOpen),
                         &dwBytesReturned,
			             &overlapped))
    {
      // Clear the stored end point, so that if it failed to open
      //  no attempt will be made to close it.

      pSPCB->uRasEndpoint = INVALID_HANDLE_VALUE;
      return(GetLastError());
    } else
	pSPCB->uRasEndpoint = AsyMacOpen.hNdisEndpoint;

    *pRasEndpoint = AsyMacOpen.hNdisEndpoint ;

    //DbgPrint("PortConnect: RasEndpoint = 0x%x\n", *pRasEndpoint);

    A.hNdisEndpoint = (HANDLE) *pRasEndpoint ;
    A.MacAdapter = NULL ;
    if (!DeviceIoControl(pSPCB->hAsyMac,
                    IOCTL_ASYMAC_DCDCHANGE,
                    &A,
                    sizeof(A),
                    &A,
                    sizeof(A),
                    &dwBytesReturned,
                    (LPOVERLAPPED)&(pSPCB->MonitorDevice)))
    {
        ;//DbgPrint("PortConnect: DeviceIoControl (IOCTL_ASYMAC_DCDCHANGE) failed. %d\n",
        //    GetLastError());
    }

    PortClearStatistics(hIOPort);


//    if (!(dwModemStatus & MS_RLSD_ON))
//	return(PENDING);				     //DCD is down
//    else

    return(SUCCESS);

  }
  except(exception_code()==EXCEPT_RAS_MEDIA ? HANDLE_EXCEPTION:CONTINUE_SEARCH)
  {
    return(gLastError);
  }
}





//*  PortDisconnect  ---------------------------------------------------------
//
// Function: This API is called to drop a connection and close AsyncMac.
//
// Returns: SUCCESS
//          PENDING
//          ERROR_PORT_NOT_OPEN
//
//*

DWORD  APIENTRY
PortDisconnect(HANDLE hIOPort)
{
  ASYMAC_CLOSE  AsyMacClose;
  SERIALPCB     *pSPCB;
  DWORD dwModemStatus, dwBytesReturned;
  DWORD retcode ;
  DWORD dwSetMask = 0;
  DWORD  fdwAction = PURGE_TXABORT|PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR;

  memset (&overlapped, 0, sizeof (OVERLAPPED)) ;

  try
  {

    DebugPrintf(("PortDisconnect\n"));


    //Signal other end of link that connection is being dropped

    if (!EscapeCommFunction(hIOPort, CLRDTR))
    {
        ;//DbgPrint("PortDisconnect: EscapeCommFunction Failed. %d\n", GetLastError());
    }
    
    //
    // Apparently, DTR isn't really down
    // yet, even though this call is supposed
    // to be synchronous to the serial driver.
    // We sleep here for a while to make sure
    // DTR drops.
    //
    Sleep(100);

    //Find port in list

    if ((pSPCB = FindPortInList(hIOPort, NULL)) == NULL)
    {
      gLastError = ERROR_PORT_NOT_OPEN;
      RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }


    if (pSPCB->uRasEndpoint != INVALID_HANDLE_VALUE)
    {
      // Update statistics before closing Asyncmac

      if ((retcode = UpdateStatistics(pSPCB)) != SUCCESS)
      {
        gLastError = retcode;
        RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
      }

      //Close AsynacMac

      AsyMacClose.MacAdapter = NULL;
      AsyMacClose.hNdisEndpoint = (HANDLE) pSPCB->uRasEndpoint;

      DeviceIoControl(pSPCB->hAsyMac,
                      IOCTL_ASYMAC_CLOSE,
                      &AsyMacClose,
                      sizeof(AsyMacClose),
                      &AsyMacClose,
                      sizeof(AsyMacClose),
                      &dwBytesReturned,
		              &overlapped);

      pSPCB->uRasEndpoint = INVALID_HANDLE_VALUE;
    }

    PurgeComm(hIOPort, fdwAction) ; // flush the ports

    //Check whether DCD has dropped yet

    GetCommModemStatus(hIOPort, &dwModemStatus);

    if (dwModemStatus & MS_RLSD_ON) {

      //DbgPrint("PortDisconnect: DCD hasn't dropped yet!\n");
      dwSetMask = EV_RLSD ;
      retcode = PENDING ;                                  // not yet dropped.
    } else
      retcode = SUCCESS ;


    // UPDATE the DSR monitoring: this restores the DCR to what it was when
    // the port was opened.
    //
    pSPCB->dwMonitorDSRMask = pSPCB->dwActiveDSRMask	;

    dwSetMask |= (pSPCB->dwMonitorDSRMask) ;

    if (dwSetMask != 0) {	// set only if mask is not 0
    //DbgPrint("PortDisconnect: Setting mask to 0x%x\n", dwSetMask);
	SetCommMask (hIOPort, dwSetMask);
	if (!WaitCommEvent(hIOPort,
                     &(pSPCB->dwEventMask),
                      (LPOVERLAPPED)&(pSPCB->MonitorDevice)))
    {
        //DbgPrint("PortDisconnect: WaitCommEvent. %d\n", GetLastError());
    }
    }

    //Since DCD may have dropped after GetCommModemStatus and
    // before WaitCommEvent, check it again.

    if (retcode != SUCCESS)
    {
      GetCommModemStatus(hIOPort, &dwModemStatus);

      if (dwModemStatus & MS_RLSD_ON)
      {
        //DbgPrint("PortDisconnect: DCD hasn't dropped yet. 2\n");
        retcode = PENDING ;                                  // not yet dropped.
      }
      else
        retcode = SUCCESS ;
    }


    // Set the default connect baud
    //
    SetCommDefaults(pSPCB->hIOPort, pSPCB->szPortName);

  }
  except(exception_code()==EXCEPT_RAS_MEDIA ? HANDLE_EXCEPTION:CONTINUE_SEARCH)
  {
    return(gLastError);
  }

  return retcode ;
}






//*  PortInit  ---------------------------------------------------------------
//
// Function: This API re-initializes the com port after use.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_CONFIGURED
//          ERROR_DEVICE_NOT_READY
//
//*

DWORD  APIENTRY
PortInit(HANDLE hIOPort)
{
  DWORD  fdwAction = PURGE_TXABORT|PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR;
  DWORD      dwErrors;
  SERIALPCB  *pSPCB;


  DebugPrintf(("PortInit\n"));


  pSPCB = FindPortInList(hIOPort, NULL) ;

  // Raise DTR

  if (!EscapeCommFunction(hIOPort, SETDTR))
    return(GetLastError());

  if (!PurgeComm(hIOPort, fdwAction))
    return(GetLastError());

  if (!ClearCommError(hIOPort, &dwErrors, NULL))
    return(GetLastError());

  // Reset szCarrierBPS to MAXCARRIERBPS from ini file
  //
  InitCarrierBps(pSPCB->szPortName, pSPCB->szCarrierBPS);

  return(SUCCESS);
}





//*  PortSend  ---------------------------------------------------------------
//
// Function: This API sends a buffer to the port.  This API is
//           asynchronous and normally returns PENDING; however, if
//           WriteFile returns synchronously, the API will return
//           SUCCESS.
//
// Returns: SUCCESS
//          PENDING
//          Return code from GetLastError
//
//*

DWORD
PortSend(HANDLE hIOPort, BYTE *pBuffer, DWORD dwSize)
{
  SERIALPCB  *pSPCB;
  DWORD      dwRC, pdwBytesWritten;
  BOOL       bIODone;


  DebugPrintf(("PortSend\n"));


  // Find the SerialPCB which contains hIOPOrt

  pSPCB = FindPortInList(hIOPort, NULL);

  if (pSPCB == NULL)
    return(ERROR_PORT_NOT_OPEN);

  // Send Buffer to Port

  bIODone = WriteFile(hIOPort,
                      pBuffer,
                      dwSize,
                      &pdwBytesWritten,         //pdwBytesWritten is not used
                      (LPOVERLAPPED)&(pSPCB->SendReceive));

  if (bIODone)
    return(PENDING);

  else if ((dwRC = GetLastError()) == ERROR_IO_PENDING)
    return(PENDING);

  else
    return(dwRC);
}





//*  PortReceive  ------------------------------------------------------------
//
// Function: This API reads from the port.  This API is
//           asynchronous and normally returns PENDING; however, if
//           ReadFile returns synchronously, the API will return
//           SUCCESS.
//
// Returns: SUCCESS
//          PENDING
//          Return code from GetLastError
//
//*

DWORD
PortReceive(HANDLE hIOPort,
            BYTE   *pBuffer,
            DWORD  dwSize,
            DWORD  dwTimeOut)
{
  COMMTIMEOUTS  CT;
  SERIALPCB     *pSPCB;
  DWORD         dwRC, pdwBytesRead;
  BOOL          bIODone;


  DebugPrintf(("PortReceive\n"));


  // Find the SerialPCB which contains hIOPOrt

  pSPCB = FindPortInList(hIOPort, NULL);

  if (pSPCB == NULL)
    return(ERROR_PORT_NOT_OPEN);


  // Set Read Timeouts

  CT.ReadIntervalTimeout = 0;
  CT.ReadTotalTimeoutMultiplier = 0;
  CT.ReadTotalTimeoutConstant = dwTimeOut;

  if ( ! SetCommTimeouts(hIOPort, &CT))
    return(GetLastError());

  // Read from Port

  bIODone = ReadFile(hIOPort,
                     pBuffer,
                     dwSize,
                     &pdwBytesRead,               //pdwBytesRead is not used
                     (LPOVERLAPPED)&(pSPCB->SendReceive));

  if (bIODone) {
    return(PENDING);
  }

  else if ((dwRC = GetLastError()) == ERROR_IO_PENDING)
    return(PENDING);

  else
    return(dwRC);
}


//*  PortReceiveComplete ------------------------------------------------------
//
// Function: Completes a read  - if still PENDING it cancels it - else it returns the bytes read.
//           PortClearStatistics.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_OPEN
//*

DWORD
PortReceiveComplete (HANDLE hIOPort, PDWORD bytesread)
{
    SERIALPCB	 *pSPCB;

    // Find the SerialPCB which contains hIOPOrt

    pSPCB = FindPortInList(hIOPort, NULL);

    if (pSPCB == NULL)
	return(ERROR_PORT_NOT_OPEN);

    if (!GetOverlappedResult(hIOPort,
			     (LPOVERLAPPED)&(pSPCB->SendReceive),
			     bytesread,
			     FALSE)) 
    {
#if DBG    
        DbgPrint("PortReceiveComplete: GetOverlappedResult failed. %d", GetLastError());			     
#endif        
    	PurgeComm (hIOPort, PURGE_RXABORT) ;
    	*bytesread = 0 ;
    }

    return SUCCESS ;
}



//*  PortCompressionSetInfo  -------------------------------------------------
//
// Function: This API selects Asyncmac compression mode by setting
//           Asyncmac's compression bits.
//
// Returns: SUCCESS
//          Return code from GetLastError
//
//*

DWORD
PortCompressionSetInfo(HANDLE hIOPort)
{

  // Not supported anymore -

  return(SUCCESS);
}





//*  PortClearStatistics  ----------------------------------------------------
//
// Function: This API is used to mark the beginning of the period for which
//           statistics will be reported.  The current numbers are copied
//           from the MAC and stored in the Serial Port Control Block.  At
//           the end of the period PortGetStatistics will be called to
//           compute the difference.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_OPEN
//*

DWORD
PortClearStatistics(HANDLE hIOPort)
{
#if 0
  ASYMAC_GETSTATS  A;
  int              i;
  DWORD            dwBytesReturned;
  SERIALPCB        *pSPCB;

  memset (&overlapped, 0, sizeof (OVERLAPPED)) ;

  DebugPrintf(("PortClearStatistics\n"));


  // Find port in list

  if ((pSPCB = FindPortInList(hIOPort, NULL)) == NULL)
    return(ERROR_PORT_NOT_OPEN);


  // Check whether Asyncmac is open

  if (pSPCB->uRasEndpoint == INVALID_RASENDPOINT)

    for (i=0; i<NUM_RAS_SERIAL_STATS; i++)                  // Asymac is closed
      pSPCB->Stats[i] = 0;

  else                                                      // Asyncmac is open
  {
    // Fill in GetStats struct

    A.MacAdapter = NULL;
    A.hNdisEndpoint = pSPCB->uRasEndpoint;


    // Call Asymac

    if (!DeviceIoControl(pSPCB->hAsyMac,
                         IOCTL_ASYMAC_GETSTATS,
                         &A,
                         sizeof(A),
                         &A,
                         sizeof(A),
                         &dwBytesReturned,
		            	 &overlapped))
      return(GetLastError());


    // Update Stats in Serial Port Control Block

    pSPCB->Stats[BYTES_XMITED]  = A.AsyMacStats.GenericStats.BytesTransmitted;
    pSPCB->Stats[BYTES_RCVED]   = A.AsyMacStats.GenericStats.BytesReceived;
    pSPCB->Stats[FRAMES_XMITED] = A.AsyMacStats.GenericStats.FramesTransmitted;
    pSPCB->Stats[FRAMES_RCVED]  = A.AsyMacStats.GenericStats.FramesReceived;

    pSPCB->Stats[CRC_ERR]       = A.AsyMacStats.SerialStats.CRCErrors;
    pSPCB->Stats[TIMEOUT_ERR]   = A.AsyMacStats.SerialStats.TimeoutErrors;
    pSPCB->Stats[ALIGNMENT_ERR] = A.AsyMacStats.SerialStats.AlignmentErrors;
    pSPCB->Stats[SERIAL_OVERRUN_ERR]
                                = A.AsyMacStats.SerialStats.SerialOverrunErrors;
    pSPCB->Stats[FRAMING_ERR]   = A.AsyMacStats.SerialStats.FramingErrors;
    pSPCB->Stats[BUFFER_OVERRUN_ERR]
                                = A.AsyMacStats.SerialStats.BufferOverrunErrors;

    pSPCB->Stats[BYTES_XMITED_UNCOMP]
                 = A.AsyMacStats.CompressionStats.BytesTransmittedUncompressed;

    pSPCB->Stats[BYTES_RCVED_UNCOMP]
                 = A.AsyMacStats.CompressionStats.BytesReceivedUncompressed;

    pSPCB->Stats[BYTES_XMITED_COMP]
                 = A.AsyMacStats.CompressionStats.BytesTransmittedCompressed;

    pSPCB->Stats[BYTES_RCVED_COMP]
                 = A.AsyMacStats.CompressionStats.BytesReceivedCompressed;
  }
#endif
  return(SUCCESS);
}





//*  PortGetStatistics  ------------------------------------------------------
//
// Function: This API reports MAC statistics since the last call to
//           PortClearStatistics.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_OPEN
//*

DWORD
PortGetStatistics(HANDLE hIOPort, RAS_STATISTICS *pStat)
{
#if 0
  ASYMAC_GETSTATS  A;
  DWORD            dwBytesReturned;
  SERIALPCB        *pSPCB;

  memset (&overlapped, 0, sizeof (OVERLAPPED)) ;

  DebugPrintf(("PortGetStatistics\n"));


  // Find port in list

  if ((pSPCB = FindPortInList(hIOPort, NULL)) == NULL)
    return(ERROR_PORT_NOT_OPEN);


  // Check whether Asyncmac is open

  if (pSPCB->uRasEndpoint == INVALID_RASENDPOINT)
  {
    // Asyncmac is closed
    // Report current counts

    pStat->S_NumOfStatistics = NUM_RAS_SERIAL_STATS;

    pStat->S_Statistics[BYTES_XMITED]  = pSPCB->Stats[BYTES_XMITED];
    pStat->S_Statistics[BYTES_RCVED]   = pSPCB->Stats[BYTES_RCVED];
    pStat->S_Statistics[FRAMES_XMITED] = pSPCB->Stats[FRAMES_XMITED];
    pStat->S_Statistics[FRAMES_RCVED]  = pSPCB->Stats[FRAMES_RCVED];

    pStat->S_Statistics[CRC_ERR]            = pSPCB->Stats[CRC_ERR];
    pStat->S_Statistics[TIMEOUT_ERR]        = pSPCB->Stats[TIMEOUT_ERR];
    pStat->S_Statistics[ALIGNMENT_ERR]      = pSPCB->Stats[ALIGNMENT_ERR];
    pStat->S_Statistics[SERIAL_OVERRUN_ERR] = pSPCB->Stats[SERIAL_OVERRUN_ERR];
    pStat->S_Statistics[FRAMING_ERR]        = pSPCB->Stats[FRAMING_ERR];
    pStat->S_Statistics[BUFFER_OVERRUN_ERR] = pSPCB->Stats[BUFFER_OVERRUN_ERR];

    pStat->S_Statistics[BYTES_XMITED_UNCOMP]= pSPCB->Stats[BYTES_XMITED_UNCOMP];
    pStat->S_Statistics[BYTES_RCVED_UNCOMP] = pSPCB->Stats[BYTES_RCVED_UNCOMP];
    pStat->S_Statistics[BYTES_XMITED_COMP]  = pSPCB->Stats[BYTES_XMITED_COMP];
    pStat->S_Statistics[BYTES_RCVED_COMP]   = pSPCB->Stats[BYTES_RCVED_COMP];
  }
  else
  {
    // Asyncmac is open
    // Fill in GetStats struct

    A.MacAdapter = NULL;
    A.hNdisEndpoint = pSPCB->uRasEndpoint;


    // Call Asymac to get current MAC statistics counts

    if (!DeviceIoControl(pSPCB->hAsyMac,
                         IOCTL_ASYMAC_GETSTATS,
                         &A,
                         sizeof(A),
                         &A,
                         sizeof(A),
                         &dwBytesReturned,
		            	 &overlapped))
      return(GetLastError());


    // Find difference between last PortClearStatistics and current counts

    pStat->S_NumOfStatistics = NUM_RAS_SERIAL_STATS;

    pStat->S_Statistics[BYTES_XMITED]
      = A.AsyMacStats.GenericStats.BytesTransmitted
          - pSPCB->Stats[BYTES_XMITED];

    pStat->S_Statistics[BYTES_RCVED]
      = A.AsyMacStats.GenericStats.BytesReceived
          - pSPCB->Stats[BYTES_RCVED];

    pStat->S_Statistics[FRAMES_XMITED]
      = A.AsyMacStats.GenericStats.FramesTransmitted
          - pSPCB->Stats[FRAMES_XMITED];

    pStat->S_Statistics[FRAMES_RCVED]
      = A.AsyMacStats.GenericStats.FramesReceived
         - pSPCB->Stats[FRAMES_RCVED];

    pStat->S_Statistics[CRC_ERR]
      = A.AsyMacStats.SerialStats.CRCErrors
         - pSPCB->Stats[CRC_ERR];

    pStat->S_Statistics[TIMEOUT_ERR]
      = A.AsyMacStats.SerialStats.TimeoutErrors
         - pSPCB->Stats[TIMEOUT_ERR];

    pStat->S_Statistics[ALIGNMENT_ERR]
      = A.AsyMacStats.SerialStats.AlignmentErrors
         - pSPCB->Stats[ALIGNMENT_ERR];

    pStat->S_Statistics[SERIAL_OVERRUN_ERR]
      = A.AsyMacStats.SerialStats.SerialOverrunErrors
         - pSPCB->Stats[SERIAL_OVERRUN_ERR];

    pStat->S_Statistics[FRAMING_ERR]
      = A.AsyMacStats.SerialStats.FramingErrors
         - pSPCB->Stats[FRAMING_ERR];

    pStat->S_Statistics[BUFFER_OVERRUN_ERR]
      = A.AsyMacStats.SerialStats.BufferOverrunErrors
         - pSPCB->Stats[BUFFER_OVERRUN_ERR];

    pStat->S_Statistics[BYTES_XMITED_UNCOMP]
      = A.AsyMacStats.CompressionStats.BytesTransmittedUncompressed
         - pSPCB->Stats[BYTES_XMITED_UNCOMP];

    pStat->S_Statistics[BYTES_RCVED_UNCOMP]
      = A.AsyMacStats.CompressionStats.BytesReceivedUncompressed
         - pSPCB->Stats[BYTES_RCVED_UNCOMP];

    pStat->S_Statistics[BYTES_XMITED_COMP]
      = A.AsyMacStats.CompressionStats.BytesTransmittedCompressed
         - pSPCB->Stats[BYTES_XMITED_COMP];

    pStat->S_Statistics[BYTES_RCVED_COMP]
      = A.AsyMacStats.CompressionStats.BytesReceivedCompressed
         - pSPCB->Stats[BYTES_RCVED_COMP];
  }
#endif
  return(SUCCESS);
}


//*  PortSetFraming	-------------------------------------------------------
//
// Function: Sets the framing type with the mac
//
// Returns: SUCCESS
//
//*
DWORD  APIENTRY
PortSetFraming(HANDLE hIOPort, DWORD SendFeatureBits, DWORD RecvFeatureBits,
	      DWORD SendBitMask, DWORD RecvBitMask)
{
#if 0
    ASYMAC_STARTFRAMING  A;
    DWORD		 dwBytesReturned;
    SERIALPCB		 *pSPCB;

    memset (&overlapped, 0, sizeof (OVERLAPPED)) ;

    // Find port in list

    if ((pSPCB = FindPortInList(hIOPort, NULL)) == NULL)
	return(ERROR_PORT_NOT_OPEN);

    A.MacAdapter      = NULL ;
    A.hNdisEndpoint    = pSPCB->uRasEndpoint;
    A.SendFeatureBits = SendFeatureBits;
    A.RecvFeatureBits =	RecvFeatureBits;
    A.SendBitMask =	SendBitMask;
    A.RecvBitMask =	RecvBitMask;

    if (!DeviceIoControl(pSPCB->hAsyMac,
			 IOCTL_ASYMAC_STARTFRAMING,
                         &A,
                         sizeof(A),
                         &A,
                         sizeof(A),
                         &dwBytesReturned,
		            	 &overlapped))
	return(GetLastError());
#endif

    return(SUCCESS);
}



//*  PortGetPortState  -------------------------------------------------------
//
// Function: This API is used in MS-DOS only.
//
// Returns: SUCCESS
//
//*

DWORD  APIENTRY
PortGetPortState(char *pszPortName, DWORD *pdwUsage)
{
  DebugPrintf(("PortGetPortState\n"));

  return(SUCCESS);
}





//*  PortChangeCallback  -----------------------------------------------------
//
// Function: This API is used in MS-DOS only.
//
// Returns: SUCCESS
//
//*

DWORD  APIENTRY
PortChangeCallback(HANDLE hIOPort)
{
  DebugPrintf(("PortChangeCallback\n"));

  return(SUCCESS);
}

DWORD APIENTRY
PortSetINetCfg(PVOID pvINetCfg)
{
    ((void) pvINetCfg);

    return SUCCESS;
}

DWORD APIENTRY
PortSetIoCompletionPort ( HANDLE hIoCompletionPort)
{
    ((void) hIoCompletionPort);

    return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\tapi32\diag.c ===
/*++

Copyright (C) 1994-98 Microsft Corporation. All rights reserved.

Module Name:

    diag.c

Abstract:

    This file contains helper routines to get the callerid/calledid
    and connect response.

Author:

    Rao salapaka (raos) 23-Feb-1998

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tapi.h>
#include <rasman.h>
#include <raserror.h>
#include <mprlog.h>
#include <rtutils.h>

#include <media.h>
#include <device.h>
#include <rasmxs.h>
#include <isdn.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include "rastapi.h"
#include "reghelp.h"

#include <unimodem.h>

/*++

Routine Description:

    Extract CallerID and CalledID information if
    available.

Arguments:

    port - The tapi port on which the call was made
           / on which the call came in

    pLineCallInfo - the LINECALLINFO associated with
                    this call

    pdwRequiredSize - pointer to buffer to receive the
                      size of buffer required to hold
                      the callerid and called id info.

    pConnectInfo - pointer to the RASTAPI_CONNECT_INFO struct
                   where the information about the
                   callerid and called id will be filledin.
                   If this is not NULL then it is assumed
                   that the buffer is big enough to store
                   the callerid and called id iformation.

Return Value:

    ERROR_SUCCESS if successful

--*/

DWORD
DwGetIDInformation(
    TapiPortControlBlock *port,
    LINECALLINFO         *pLineCallInfo,
    DWORD                *pdwRequiredSize,
    RASTAPI_CONNECT_INFO *pConnectInfo
    )
{

    DWORD dwRequiredSize = 0;
    DWORD dwErr          = ERROR_SUCCESS;

    RasTapiTrace("DwGetIDInformation");

#if DBG

    RasTapiTrace ("RasTapiCallback: connected on %s",
                  port->TPCB_Name );

    RasTapiTrace("RasTapiCallback: CallerIDFlags=0x%x",
                 pLineCallInfo->dwCallerIDFlags);


    RasTapiTrace("RasTapiCallback: CalledIDFlags=0x%x",
                 pLineCallInfo->dwCalledIDFlags);

    RasTapiTrace("RasTapiCallback: dwNeededSize=%d",
                 pLineCallInfo->dwNeededSize);

    RasTapiTrace("RasTapiCallback: dwUsedSize=%d",
                 pLineCallInfo->dwUsedSize);

    RasTapiTrace("RasTapiCallback: dwCallerIDOffset=%d",
                 pLineCallInfo->dwCallerIDOffset);

    RasTapiTrace("RasTapiCallback: dwCalledIdOffset=%d",
                 pLineCallInfo->dwCalledIDOffset);

    RasTapiTrace("RasTapiCallback: dwCallerIdSize=%d",
                 pLineCallInfo->dwCallerIDSize);

    RasTapiTrace("RasTapiCallback: dwCalledIdSize=%d",
                 pLineCallInfo->dwCalledIDSize);

    RasTapiTrace("RasTapiCallback: dwCallerIdNameSize=%d",
                 pLineCallInfo->dwCallerIDNameSize);

    RasTapiTrace("RasTapiCallback: dwCallerIdNameOffset=%d",
                 pLineCallInfo->dwCallerIDNameOffset);
#endif

    //
    // Find the size of the buffer to allocate
    //
    if(pLineCallInfo->dwCallerIDFlags & LINECALLPARTYID_ADDRESS)
    {
        //
        // Add one byte to allocate for NULL char
        //
        dwRequiredSize += RASMAN_ALIGN8(pLineCallInfo->dwCallerIDSize + 1);
    }

    if(pLineCallInfo->dwCalledIDFlags & LINECALLPARTYID_ADDRESS)
    {
        //
        // Add one byte to allocate for NULL char
        //
        dwRequiredSize += RASMAN_ALIGN8(pLineCallInfo->dwCalledIDSize + 1);
    }

    if(     (NULL == pConnectInfo)
        ||  (0 == dwRequiredSize))
    {
        goto done;
    }

    //
    // If pConnectInfo is != NULL it is assumed
    // that the buffer is large enough to put
    // the CALLER/CALLED ID information in it.
    //
    if(     (   pLineCallInfo->dwCallerIDFlags
            &   LINECALLPARTYID_ADDRESS )
        &&  pLineCallInfo->dwCallerIDSize)
    {

        //
        // Copy the caller id information. Note that abdata
        // is already aligned at 8byte boundary
        //
        pConnectInfo->dwCallerIdSize =
            pLineCallInfo->dwCallerIDSize;

        pConnectInfo->dwCallerIdOffset =
                    FIELD_OFFSET(RASTAPI_CONNECT_INFO, abdata);

        ZeroMemory(
            pConnectInfo->abdata, 
            pLineCallInfo->dwCallerIDSize + 1);

        memcpy(  pConnectInfo->abdata,

                 (PBYTE) ((PBYTE) pLineCallInfo
               + pLineCallInfo->dwCallerIDOffset),

               pLineCallInfo->dwCallerIDSize);

        RasTapiTrace("GetIDInformation: CallerID=%s",
                      (CHAR *) pConnectInfo->abdata);

        //
        // for the NULL char
        //
        pConnectInfo->dwCallerIdSize += 1;
    }
    else
    {
        RasTapiTrace("RasTapiCallback: caller id "
                     "info. not avail");

    }

    if(     (   pLineCallInfo->dwCalledIDFlags
            &   LINECALLPARTYID_ADDRESS)
        &&  pLineCallInfo->dwCalledIDSize)
    {
        //
        // Copy the called id information
        //
        pConnectInfo->dwCalledIdSize =
                pLineCallInfo->dwCalledIDSize;

        pConnectInfo->dwCalledIdOffset =
                FIELD_OFFSET(RASTAPI_CONNECT_INFO, abdata)
              + RASMAN_ALIGN8(pConnectInfo->dwCallerIdSize);

        ZeroMemory((PBYTE)
                   ((PBYTE) pConnectInfo
                 + pConnectInfo->dwCalledIdOffset),
                   pLineCallInfo->dwCalledIDSize + 1);


        memcpy(  (PBYTE)
                 ((PBYTE) pConnectInfo
               + pConnectInfo->dwCalledIdOffset),

                 (PBYTE) ((PBYTE) pLineCallInfo
               + pLineCallInfo->dwCalledIDOffset),

               pLineCallInfo->dwCalledIDSize);

        //
        // For the calledID
        //
        pConnectInfo->dwCalledIdSize += 1;
    }
    else
    {
        RasTapiTrace("RasTapiCallback: called id "
                     "info. not avail");
    }

done:

    if(pdwRequiredSize)
    {
        *pdwRequiredSize = dwRequiredSize;
    }

    RasTapiTrace("DwGetIDInformation. %d", dwErr);

    return dwErr;
}



/*++

Routine Description:

    Extract the connect responses from lpLineDiagnostics(see
    MODEM_KEYTYPE_AT_COMMAND_RESPONSE,MODEMDIAGKEY_ATRESP_CONNECT)
    and copy them in lpBuffer

Arguments:

    lpLineDiagnostics - diagnostic structure

    lpBuffer - destination buffer (can be NULL), upon
               return contains null terminated ASCII
               strings

    dwBufferSize - size in bytes of the buffer pointed
                   by lpBuffer

    lpdwNeededSize - pointer (can be NULL) to a dword to
                     receive the needed size

Return Value:

    Returns the number of bytes copied into lpBuffer

--*/
DWORD
DwGetConnectResponses(
    LINEDIAGNOSTICS *lpLineDiagnostics,
    LPBYTE          lpBuffer,
    DWORD           dwBufferSize,
    LPDWORD         lpdwNeededSize
    )
{
    DWORD dwBytesCopied;

    DWORD dwNeededSize;

    LINEDIAGNOSTICS *lpstructDiagnostics;

    RasTapiTrace("DwGetConnectresponses");

    dwBytesCopied   = 0;
    dwNeededSize    = 0;

    lpstructDiagnostics = lpLineDiagnostics;

    while (NULL != lpstructDiagnostics)
    {
        LINEDIAGNOSTICS_PARSEREC    *lpParsedDiagnostics;

        LINEDIAGNOSTICSOBJECTHEADER *lpParsedHeader;

        DWORD                       dwNumItems;

        DWORD                       dwIndex;

        //
        // check the signature for modem diagnostics
        //
        lpParsedHeader = PARSEDDIAGNOSTICS_HDR(lpstructDiagnostics);

        if (    (lpstructDiagnostics->hdr.dwSig
                    != LDSIG_LINEDIAGNOSTICS)

            ||  (lpstructDiagnostics->dwDomainID
                    != DOMAINID_MODEM)

            ||  !IS_VALID_PARSEDDIAGNOSTICS_HDR(lpParsedHeader))
        {
            goto NextStructure;
        }

        //
        // get parsed structure info
        //
        dwNumItems  = PARSEDDIAGNOSTICS_NUM_ITEMS(lpParsedHeader);

        lpParsedDiagnostics = PARSEDDIAGNOSTICS_DATA(lpstructDiagnostics);

        //
        // iterate the array of LINEDIAGNOSTICS_PARSERECs
        //
        for (dwIndex = 0; dwIndex < dwNumItems; dwIndex++)
        {
            DWORD dwThisLength;

            LPSTR lpszThisString;

            //
            //  check is a connect response
            //
            if (    (lpParsedDiagnostics[dwIndex].dwKeyType !=
                        MODEM_KEYTYPE_AT_COMMAND_RESPONSE)

                ||  (lpParsedDiagnostics[dwIndex].dwKey !=
                        MODEMDIAGKEY_ATRESP_CONNECT)

                ||  !(lpParsedDiagnostics[dwIndex].dwFlags &
                    fPARSEKEYVALUE_ASCIIZ_STRING))
            {
                continue;
            }

            //
            // get the string, dwValue offset from the beginning
            // of lpParsedDiagnostics
            //
            lpszThisString  = (LPSTR) ( (LPBYTE) lpParsedHeader +
                                lpParsedDiagnostics[dwIndex].dwValue);

            dwThisLength = strlen(lpszThisString) + 1;

            if (dwThisLength == 1)
            {
                continue;
            }

            //
            //  update needed size
            //
            dwNeededSize += dwThisLength;

            //
            //  copy to buffer, if large enough
            //
            if (    NULL != lpBuffer
                &&  dwBytesCopied < dwBufferSize - 1)
            {
                DWORD dwBytesToCopy;

                //
                //  dwThisLength includes null char, so
                //  does dwBytesToCopy
                //
                dwBytesToCopy = min(dwThisLength,
                                      dwBufferSize
                                    - 1
                                    - dwBytesCopied);

                if (dwBytesToCopy > 1)
                {
                    memcpy(lpBuffer + dwBytesCopied,
                            lpszThisString,
                            dwBytesToCopy - 1);

                    lpBuffer[dwBytesCopied + dwBytesToCopy - 1] = 0;

                    dwBytesCopied += dwBytesToCopy;
                }
            }
        }

NextStructure:

        if (lpstructDiagnostics->hdr.dwNextObjectOffset != 0)
        {
            lpstructDiagnostics = (LINEDIAGNOSTICS *)
                    (((LPBYTE) lpstructDiagnostics) +
                        lpstructDiagnostics->hdr.dwNextObjectOffset);
        }
        else
        {
            lpstructDiagnostics = NULL;
        }
    }

    //
    //  the final null only if data is not empty
    //
    if (dwNeededSize > 0)
    {
        dwNeededSize++;

        if (    lpBuffer != NULL
            &&  dwBytesCopied < dwBufferSize)
        {
            lpBuffer[dwBytesCopied] = 0;

            dwBytesCopied++;
        }
    }

    if (lpdwNeededSize != NULL)
    {
        *lpdwNeededSize = dwNeededSize;
    }

    RasTapiTrace("DwGetConnectResponses done");

    return dwBytesCopied;
}

/*++

Routine Description:

    Extract the connect response information

Arguments:

    pLineCallInfo - the LINECALLINFO associated with
                    this call

    hCall - handle to call

    pdwRequiredSize - This is in/out parameter. As IN it
                      specifies the size of pBuffer. As
                      OUT it contains the size required
                      to store the connect response.

    pBuffer - buffer to receive the connect response. This
              can be NULL.

Return Value:

    ERROR_SUCCESS if successful

--*/
DWORD
DwGetConnectResponseInformation(
                LINECALLINFO *pLineCallInfo,
                HCALL        hCall,
                DWORD        *pdwRequiredSize,
                BYTE         *pBuffer
                )
{
    LONG lr = ERROR_SUCCESS;

    BYTE bvar[100];

    LPVARSTRING pvar = (LPVARSTRING) bvar;

    LINEDIAGNOSTICS *pLineDiagnostics;

    DWORD dwConnectResponseSize = 0;

    RasTapiTrace("DwGetConnectResponseInformation");

    //
    // Get the diagnostics information
    //
    ZeroMemory (pvar, sizeof(*pvar));
    pvar->dwTotalSize = sizeof(bvar);

    lr = lineGetID(
            pLineCallInfo->hLine,
            pLineCallInfo->dwAddressID,
            hCall,
            LINECALLSELECT_CALL,
            pvar,
            szUMDEVCLASS_TAPI_LINE_DIAGNOSTICS);

    if(     (LINEERR_STRUCTURETOOSMALL == lr)
        ||  pvar->dwNeededSize > sizeof(bvar))
    {
        DWORD dwNeededSize = pvar->dwNeededSize;

        //
        // Allocate the required size
        //
        pvar = LocalAlloc(
                    LPTR,
                    dwNeededSize);

        if(NULL == pvar)
        {
            lr = (LONG) GetLastError();
            goto done;
        }

        ZeroMemory (pvar, sizeof(*pvar));
        pvar->dwTotalSize = dwNeededSize;

        lr = lineGetID(
                pLineCallInfo->hLine,
                pLineCallInfo->dwAddressID,
                hCall,
                LINECALLSELECT_CALL,
                pvar,
                szUMDEVCLASS_TAPI_LINE_DIAGNOSTICS);

        if(ERROR_SUCCESS != lr)
        {
            goto done;
        }
    }
    else if(ERROR_SUCCESS != lr)
    {
        goto done;
    }

    pLineDiagnostics = (LINEDIAGNOSTICS *) ((LPBYTE) pvar
                     + pvar->dwStringOffset);


    (void) DwGetConnectResponses(
                        pLineDiagnostics,
                        pBuffer,
                        *pdwRequiredSize,
                        &dwConnectResponseSize);

done:

    if(bvar != (LPBYTE) pvar)
    {
        LocalFree(pvar);
    }

    *pdwRequiredSize = dwConnectResponseSize;

    RasTapiTrace("DwGetConnectResponseInformation. 0x%x",
                 lr);

    return (DWORD) lr;
}

/*++

Routine Description:

    Extract the connection information. This includes
    extracing the caller id / called id information
    and the connect response information for modems.

Arguments:

    port - pointer to the rastapi port on which the
           call came in / was made

    hCall - handle to call

    pLineCallInfo - pointer to the LINECALLINFO structure
                    associated with this call.

Return Value:

    ERROR_SUCCESS if succcessful

--*/
DWORD
DwGetConnectInfo(
    TapiPortControlBlock *port,
    HCALL                hCall,
    LINECALLINFO         *pLineCallInfo
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwRequiredSize = 0;

    DWORD dwConnectResponseSize = 0;

    RASTAPI_CONNECT_INFO *pConnectInfo = NULL;

    RasTapiTrace("DwGetConnectInfo");

    //
    // Get the size required to store the
    // caller/called id information
    //
    dwErr = DwGetIDInformation(port,
                               pLineCallInfo,
                               &dwRequiredSize,
                               NULL);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    RasTapiTrace("SizeRequired for CallID=%d",
                 dwRequiredSize);

    if(0 == _stricmp(port->TPCB_DeviceType, "modem"))
    {
        //
        // Get the size required to store connect
        // response if this is a modem
        //
        dwErr = DwGetConnectResponseInformation(
                    pLineCallInfo,
                    hCall,
                    &dwConnectResponseSize,
                    NULL);

        if(NO_ERROR != dwErr)
        {
            goto done;
        }

        RasTapiTrace("SizeRequired for ConnectResponse=%d",
                     dwConnectResponseSize);
    }

    if(0 == (dwRequiredSize + dwConnectResponseSize))
    {
        //
        // None of the information is available.
        // bail.
        //
        RasTapiTrace("CallIDSize=ConnectResponseSize=0");
        goto done;
    }

    dwRequiredSize += (  RASMAN_ALIGN8(dwConnectResponseSize)
                       + sizeof(RASTAPI_CONNECT_INFO));


    //
    // Allocate the buffer
    //
    pConnectInfo = (RASTAPI_CONNECT_INFO *) LocalAlloc(
                                    LPTR,
                                    dwRequiredSize);

    if(NULL == pConnectInfo)
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Get the actual information
    //
    dwErr = DwGetIDInformation(
                    port,
                    pLineCallInfo,
                    NULL,
                    pConnectInfo);

    if(NO_ERROR != dwErr)
    {
        goto done;
    }

    //
    // Get Connect response if its a modem
    //
    if(0 == _stricmp(port->TPCB_DeviceType, "modem"))
    {

        pConnectInfo->dwConnectResponseOffset =
                        FIELD_OFFSET(RASTAPI_CONNECT_INFO, abdata)
                      + RASMAN_ALIGN8(pConnectInfo->dwCallerIdSize)
                      + RASMAN_ALIGN8(pConnectInfo->dwCalledIdSize);

        pConnectInfo->dwConnectResponseSize =
                            dwConnectResponseSize;

        dwErr = DwGetConnectResponseInformation(
                    pLineCallInfo,
                    hCall,
                    &dwConnectResponseSize,
                    (PBYTE) ((PBYTE) pConnectInfo
                    + pConnectInfo->dwConnectResponseOffset));

        if(ERROR_SUCCESS != dwErr)
        {
            goto done;
        }
    }

    port->TPCB_pConnectInfo = pConnectInfo;

done:

    if(     NO_ERROR != dwErr
        &&  NULL != pConnectInfo)
    {
        LocalFree(pConnectInfo);
    }

    RasTapiTrace("DwGetConnectInfo. 0x%x",
                 dwErr);

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\serial32\serialpr.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: serialpr.h
//
//  Revision History
//
//  Sep  3, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains structure and constant definitions
//               SERIAL.DLL.  This file is used used only by SERIAL.DLL
//               source files, and is not public in any way.
//
//****************************************************************************


#ifndef _SERIAL_DLL_PRIVATE_
#define _SERIAL_DLL_PRIVATE_




//*  Defines  ****************************************************************
//

#define  RAS_PATH               "\\ras\\"                               //*
#define  SERIAL_INI_FILENAME    "serial.ini"
#define  ASYNCMAC_FILENAME      L"\\\\.\\ASYNCMAC"
#define  ASYNCMAC_BINDING_NAME  "\\DEVICE\\ASYNCMAC01"

#define  FILE_EXCLUSIVE_MODE    0
#define  HANDLE_EXCEPTION       1L
#define  CONTINUE_SEARCH        0
#define  EXCEPT_RAS_MEDIA       0x00A00002                              //*

#define  INPUT_QUEUE_SIZE       1514    // ???
#define  OUTPUT_QUEUE_SIZE      1514    // ???
#define  FROM_TOP_OF_FILE       TRUE

#define  USE_DEVICE_INI_DEFAULT '\x01'
#define  INVALID_RASENDPOINT    0xffff




//*  Enumeration Types  ******************************************************
//

// typedef enum DEVICETYPE DEVICETYPE;                                     //*

enum DEVICETYPE
{
  MODEM     = 0,
  PAD       = 1,
  SWITCH    = 2
};




//*  Macros  *****************************************************************
//

#ifdef DEBUG

#define DebugPrintf(_args_) DbgPrntf _args_                              //*

#else

#define DebugPrintf(_args_)

#endif




//*  Data Structures  ********************************************************
//

typedef struct SERIALPCB SERIALPCB;

struct SERIALPCB
{
  SERIALPCB   *pNextSPCB;
  HANDLE      hIOPort;
  TCHAR       szPortName[MAX_PORT_NAME];

  HANDLE      hAsyMac;

  BOOL        bErrorControlOn;
  HANDLE      uRasEndpoint;

  DWORD       dwActiveDSRMask ; // Stores whether DSR was active when the port
                                // was opened. (this is fixed)
  DWORD       dwMonitorDSRMask; // Used to store whether DSR should be
                                // monitored.(this may change during connection)
  DWORD       dwEventMask;      //Used by WaitCommEvent
  DWORD       dwPreviousModemStatus;  // used to detect changes in state
  RAS_OVERLAPPED  MonitorDevice;    //Used by WaitCommEvent
  RAS_OVERLAPPED  SendReceive;      //Used by WriteFile and ReadFile

  DWORD       Stats[NUM_RAS_SERIAL_STATS];

  TCHAR       szDeviceType[MAX_DEVICETYPE_NAME + 1];
  TCHAR       szDeviceName[MAX_DEVICE_NAME + 1];
  TCHAR       szCarrierBPS[MAX_BPS_STR_LEN];
  TCHAR       szDefaultOff[RAS_MAXLINEBUFLEN];
};



//*  Error Return Codes for Internal Errors  *********************************
//
//   Internal errors are not expected after shipping.  These errors are not
//  normally reported to the user except as an internal error number.
//

#ifndef _INTERROR_
#include "interror.h"
#endif


#define  ISER_BASE  RAS_INTERNAL_ERROR_BASE + RIEB_ASYNCMEDIADLL

#define  ERROR_SPCB_NOT_ON_LIST                 ISER_BASE + 1







//*  Local Prototypes  *******************************************************
//

//*  From serutil.c  ---------------------------------------------------------
//

void  AddPortToList(HANDLE hIOPort, char *pszPortName);

SERIALPCB* FindPortInList(HANDLE hIOPort, SERIALPCB **ppPrevSPCB);

SERIALPCB* FindPortNameInList(TCHAR *pszPortName);

void  GetDefaultOffStr(HANDLE hIOPort, TCHAR *pszPortName);

void  GetIniFileName(char *pszFileName, DWORD dwNameLen);

void  GetMem(DWORD dSize, BYTE **ppMem);                                 //*

void  GetValueFromFile(TCHAR *pzPortName, TCHAR szKey[], TCHAR *pszValue);

DWORD InitCarrierBps(char *pszPortName, char *pszMaxCarrierBps);

void  SetCommDefaults(HANDLE hIOPort, char *pszPortName);

void  SetDcbDefaults(DCB *pDCB);

BOOL  StrToUsage(char *pszStr, RASMAN_USAGE *peUsage);

DWORD UpdateStatistics(SERIALPCB *pSPCB);

DWORD ValueToNum(RAS_PARAMS *p);

BOOL  ValueToBool(RAS_PARAMS *p);



#ifdef DEBUG

void DbgPrntf(const char * format, ...);                                 //*

#endif



#endif // _SERIAL_DLL_PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\tapi32\rtnetcfg.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\tapi32\common.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//	Copyright (C) 1994-95 Microsft Corporation. All rights reserved.
//
//  Filename: rastapi.h
//
//  Revision History
//
//  Mar  28 1992   Gurdeep Singh Pall	Created
//
//
//  Description: This file contains all structs for TAPI.DLL
//
//****************************************************************************

typedef struct DeviceInfo 
{
    struct DeviceInfo *Next;
    BOOL        fValid;
    DWORD       dwNumEndPoints;
    DWORD       dwExclusiveDialIn;
    DWORD       dwExclusiveDialOut;
    DWORD       dwExclusiveRouter;
    DWORD       dwCurrentEndPoints;
    HKEY        hkeyDevice;
    GUID        guidDevice;
    CHAR        DeviceName[256];
    
} DeviceInfo, *pDeviceInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\tapi32\rastapi.c ===
/*++

Copyright (C) 1994-98 Microsft Corporation. All rights reserved.

Module Name:

    rastapi.c

Abstract:

    This file contains all entry points for TAPI.DLL

Author:

    Gurdeep Singh Pall (gurdeep) 06-Mar-1995

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tapi.h>
#include <rasman.h>
#include <raserror.h>
#include <mprlog.h>
#include <rtutils.h>

#include <wanpub.h>
#include <asyncpub.h>

#include <media.h>
#include <device.h>
#include <rasmxs.h>
#include <isdn.h>
#include <serial.h>
#include <stdlib.h>
#include <tchar.h>
#include <malloc.h>
#include <setupapi.h>
#include <string.h>
#include "rastapi.h"
#include <unimodem.h>
#include "reghelp.h"


extern DWORD                TotalPorts ;
extern HLINEAPP             RasLine ;
extern HINSTANCE            RasInstance ;
extern TapiLineInfo         *RasTapiLineInfoList ;
extern TapiPortControlBlock *RasPortsList ;
extern TapiPortControlBlock *RasPortsEnd ;
extern HANDLE               RasTapiMutex ;
extern BOOL                 Initialized ;
extern DWORD                TapiThreadId    ;
extern HANDLE               TapiThreadHandle;
// extern DWORD                LoaderThreadId;
extern DWORD                ValidPorts;
extern HANDLE               g_hAsyMac ;

extern HANDLE               g_hIoCompletionPort;

extern DWORD                *g_pdwNumEndPoints;

extern DeviceInfo           *g_pDeviceInfoList;

BOOL   g_fDllLoaded = FALSE;

DWORD GetInfo ( TapiPortControlBlock *,
                BYTE *,
                DWORD *) ;

DWORD SetInfo ( TapiPortControlBlock *,
                RASMAN_PORTINFO *) ;

DWORD GetGenericParams ( TapiPortControlBlock *,
                         RASMAN_PORTINFO *,
                         PDWORD) ;

DWORD GetIsdnParams ( TapiPortControlBlock *,
                      RASMAN_PORTINFO * ,
                      PDWORD) ;

DWORD GetX25Params ( TapiPortControlBlock *,
                     RASMAN_PORTINFO *,
                     PDWORD) ;

DWORD FillInX25Params ( TapiPortControlBlock *,
                        RASMAN_PORTINFO *) ;

DWORD FillInIsdnParams ( TapiPortControlBlock *,
                         RASMAN_PORTINFO *) ;

DWORD FillInGenericParams ( TapiPortControlBlock *,
                            RASMAN_PORTINFO *) ;

DWORD FillInUnimodemParams ( TapiPortControlBlock *,
                             RASMAN_PORTINFO *) ;

VOID  SetModemParams ( TapiPortControlBlock *hIOPort,
                       LINECALLPARAMS *linecallparams) ;

VOID  SetGenericParams (TapiPortControlBlock *,
                        LINECALLPARAMS *);

VOID
SetAtmParams (TapiPortControlBlock *,
              LINECALLPARAMS *);

VOID
SetX25Params(TapiPortControlBlock *hIOPort,
             LINECALLPARAMS *linecallparams);

DWORD InitiatePortDisconnection (TapiPortControlBlock *hIOPort) ;

TapiPortControlBlock *LookUpControlBlock (HANDLE hPort) ;

DWORD ValueToNum(RAS_PARAMS *p) ;

extern DWORD                   dwTraceId;

#define CCH_GUID_STRING_LEN   39    // 38 chars + terminator null

/*++

Routine Description:

    Searches for a specific device on a given interface.
    It does this by using setup api to return all of the
    devices in the class given by pguidInterfaceId.  It then
    gets device path for each of these device interfaces and
    looks for pguidDeviceId and pszwReferenceString as
    substrings.

Arguments:
    pguidDeviceId        [in]  The device id to find.
    pguidInterfaceId     [in]  The interface on which to look.
    pszwReferenceString  [in]  Optional.  Further match on this ref string.
    dwFlagsAndAttributes [in]  See CreateFile.  This is how the device is
                               opened if it is found.
    phFile               [out] The returned device handle.

Return Value:

    TRUE if found and opened, FALSE if not found, or an error.

--*/
BOOL
FindDeviceOnInterface (
    const GUID* pguidDeviceId,
    const GUID* pguidInterfaceId,
    LPCWSTR     pszwReferenceString,
    DWORD       dwFlagsAndAttributes,
    HANDLE*     phFile)
{
    WCHAR       szwDeviceId [CCH_GUID_STRING_LEN];
    INT         cch;
    HDEVINFO    hdi;
    BOOL fFound = FALSE;

    ASSERT (pguidDeviceId);
    ASSERT (pguidInterfaceId);
    ASSERT (phFile);

    //
    // Initialize the output parameter.
    //
    *phFile = INVALID_HANDLE_VALUE;

    cch = StringFromGUID2 (pguidDeviceId,
                           szwDeviceId,
                           CCH_GUID_STRING_LEN);

    ASSERT (CCH_GUID_STRING_LEN == cch);

    CharLowerW (szwDeviceId);

    //
    // Get the devices in this class.
    //
    hdi = SetupDiGetClassDevsW ((LPGUID)pguidInterfaceId,
                                NULL, NULL,
                                DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
    if (hdi)
    {
        //
        // pDetail is used to get device interface
        // detail for each device interface enumerated
        // below.
        //
        PSP_DEVICE_INTERFACE_DETAIL_DATA_W pDetail;

        const ULONG cbDetail = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W)
                                    +(MAX_PATH * sizeof(WCHAR));

        pDetail = malloc (cbDetail);

        if (pDetail)
        {
            //
            // Enumerate the device interfaces looking for
            // the one specified.
            //
            DWORD                       dwIndex;
            SP_DEVICE_INTERFACE_DATA    did;

            ZeroMemory (&did, sizeof(did));

            for (dwIndex = 0;
                 did.cbSize = sizeof(did),
                 SetupDiEnumDeviceInterfaces (hdi, NULL,
                                             (LPGUID)(pguidInterfaceId),
                                             dwIndex,
                                             &did);
                 dwIndex++)
            {
                //
                // Now get the details so we can compare the
                // device path.
                //
                pDetail->cbSize = sizeof(*pDetail);
                if (SetupDiGetDeviceInterfaceDetailW (hdi, &did,
                        pDetail, cbDetail, NULL, NULL))
                {
                    CharLowerW (pDetail->DevicePath);

                    //
                    // Look for a substring containing szwDeviceId.  Also
                    // look for a substring containing pszwReferenceString
                    // if it is specified.
                    //
                    if (    wcsstr (pDetail->DevicePath, szwDeviceId)
                        &&  (   !pszwReferenceString
                            ||  !*pszwReferenceString
                            ||   wcsstr (pDetail->DevicePath,
                                         pszwReferenceString)))
                    {
                        //
                        // We found it, so open the device and return it.
                        //
                        HANDLE hFile = CreateFileW (
                                            pDetail->DevicePath,
                                            GENERIC_READ | GENERIC_WRITE,
                                            0,
                                            NULL,
                                            OPEN_EXISTING,
                                            dwFlagsAndAttributes,
                                            NULL);

                        if (    hFile
                            &&  (INVALID_HANDLE_VALUE != hFile))
                        {
                            *phFile = hFile;
                            fFound = TRUE;
                        }
            else
            {
                DWORD dwErr = GetLastError();
                RasTapiTrace("Createfile %ws failed with %d",
                     pDetail->DevicePath, dwErr);
                
            }

                        //
                        // Now that we've found it, break out of the loop.
                        //
                        break;
                    }
                }
            }

            free (pDetail);
        }

        SetupDiDestroyDeviceInfoList (hdi);
    }

    return fFound;
}


DWORD
OpenAsyncMac (
    HANDLE *phAsyMac
    )
{
    static const GUID DEVICE_GUID_ASYNCMAC =
        {0xeeab7790,0xc514,0x11d1,{0xb4,0x2b,0x00,0x80,0x5f,0xc1,0x27,0x0e}};

    static const GUID GUID_NDIS_LAN_CLASS =
        {0xad498944,0x762f,0x11d0,{0x8d,0xcb,0x00,0xc0,0x4f,0xc3,0x35,0x8c}};

    HANDLE  hAsyMac = INVALID_HANDLE_VALUE;
    HANDLE  hSwenum;
    BOOL    fFound;
    DWORD   dwErr = SUCCESS;

    fFound = FindDeviceOnInterface (
                    &DEVICE_GUID_ASYNCMAC,
                    &GUID_NDIS_LAN_CLASS,
                    L"asyncmac",
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                    &hSwenum);
    if (fFound)
    {
         hAsyMac = CreateFileW (
                        L"\\\\.\\ASYNCMAC",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        NULL);

        if(INVALID_HANDLE_VALUE == hAsyMac)
        {
            dwErr = GetLastError();
            RasTapiTrace("Failed to createfile asyncmac. rc=0x%x",
                         dwErr);
        }

        CloseHandle (hSwenum);
    }
    else
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        RasTapiTrace("FindDeviceOnInterface returned FALSE");
    }

    *phAsyMac = hAsyMac;

    return dwErr;
}

DWORD APIENTRY
PortSetIoCompletionPort(HANDLE hIoCompletionPort)
{


    g_hIoCompletionPort = hIoCompletionPort;

    return SUCCESS;
}

/*++

Routine Description:

    This API returns a buffer containing
    a PortMediaInfo struct.

Arguments:

Return Value:

    SUCCESS
    ERROR_BUFFER_TOO_SMALL
    ERROR_READING_SECTIONNAME
    ERROR_READING_DEVICETYPE
    ERROR_READING_DEVICENAME
    ERROR_READING_USAGE
    ERROR_BAD_USAGE_IN_INI_FILE

--*/
DWORD  APIENTRY
PortEnum(
    BYTE *pBuffer,
    DWORD *pdwSize,
    DWORD *pdwNumPorts
    )
{
    PortMediaInfo *pinfo ;
    TapiPortControlBlock *pports ;
    DWORD numports = 0;
    DWORD i ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    RasTapiTrace ("PortEnum");

    if (!Initialized)
    {
        HANDLE  event;

        // LoaderThreadId = GetCurrentThreadId();

        event = CreateEvent (NULL, FALSE, FALSE, NULL) ;

        if(NULL == event)
        {
            DWORD dwError = GetLastError();

            RasTapiTrace("PortEnum: CreateEvent failed %d",
                         dwError);

            FreeMutex(RasTapiMutex);
            return dwError;
        }

        TapiThreadHandle = CreateThread (
                          NULL,
                          5000,
                          (LPTHREAD_START_ROUTINE)
                          EnumerateTapiPorts,
                          (LPVOID) event,
                          0,
                          &TapiThreadId);

        if(NULL == TapiThreadHandle)
        {
            DWORD dwError = GetLastError();
            CloseHandle(event);
            FreeMutex(RasTapiMutex);

            RasTapiTrace("PortEnum: CreateThread failed %d",
                         dwError);

            return dwError;                         
        }

        WaitForSingleObject (event, INFINITE) ;

        if (    RasLine == 0 )
        {

            //
            // Wait for the thread to go away!
            //
            WaitForSingleObject(TapiThreadHandle, INFINITE);

            CloseHandle (TapiThreadHandle) ;

            // *** Exclusion End ***
            FreeMutex (RasTapiMutex) ;

            CloseHandle(event);

            RasTapiTrace("PortEnum: RasLine == 0, returning "
                         "ERROR_TAPI_CONFIGURATION");

            RasTapiTrace(" ");

            return ERROR_TAPI_CONFIGURATION ;
        }

        CloseHandle (event) ;

        Initialized = TRUE ;
    }

    //
    // calculate the number of valid ports
    //
    pports = RasPortsList;

    while ( pports )
    {
        if (pports->TPCB_State != PS_UNINITIALIZED)
            numports++ ;

        pports = pports->TPCB_next;
    }

    RasTapiTrace("PortEnum: Number of Ports = %d", numports );

    if (*pdwSize < numports * sizeof(PortMediaInfo))
    {
        RasTapiTrace ("PortEnum: size required = %d,"
                      " size avail = %d, returning %d",
                      numports * sizeof(PortMediaInfo),
                      *pdwSize, ERROR_BUFFER_TOO_SMALL );

        *pdwNumPorts = numports ;

        *pdwSize = *pdwNumPorts * sizeof(PortMediaInfo) ;

        // *** Exclusion End ***
        FreeMutex (RasTapiMutex) ;


        return ERROR_BUFFER_TOO_SMALL ;

    }

    *pdwNumPorts = 0 ;

    pinfo = (PortMediaInfo *)pBuffer ;

    pports = RasPortsList;

    while ( pports )
    {

        if (pports->TPCB_State  == PS_UNINITIALIZED)
        {
            pports = pports->TPCB_next;
            continue ;
        }

        strcpy (pinfo->PMI_Name, pports->TPCB_Name) ;

        pinfo->PMI_Usage = pports->TPCB_Usage ;

        strcpy (pinfo->PMI_DeviceType, pports->TPCB_DeviceType) ;

        strcpy (pinfo->PMI_DeviceName, pports->TPCB_DeviceName) ;

        pinfo->PMI_LineDeviceId = pports->TPCB_Line->TLI_LineId;

        pinfo->PMI_AddressId = pports->TPCB_AddressId;

        pinfo->PMI_pDeviceInfo =
            pports->TPCB_Line->TLI_pDeviceInfo;

        pinfo++ ;

        (*pdwNumPorts)++    ;

        pports = pports->TPCB_next;
    }

    // *** Exclusion End ***
    FreeMutex (RasTapiMutex) ;

    return(SUCCESS);
}

DWORD
DwEnableModemDiagnostics(TapiPortControlBlock *pport)
{
    DWORD dwErr = SUCCESS;

    BYTE bvar[1000];

    LPVARSTRING pvar = (LPVARSTRING) bvar;

    LONG lr = ERROR_SUCCESS;

    RasTapiTrace("DwEnableModemDiagnostics");

    //
    // Get the device config information regarding
    // line diagnostics
    //
    pvar->dwTotalSize = 1000;

    pvar->dwStringSize = 0;

    lr = lineGetDevConfig(pport->TPCB_Line->TLI_LineId,
                          pvar,
                          "tapi/line/diagnostics");

    if(     LINEERR_STRUCTURETOOSMALL == lr
        ||  pvar->dwNeededSize > pvar->dwTotalSize)
    {
        DWORD dwNeededSize = pvar->dwNeededSize;

        //
        // Allocate the required size
        //
        if(NULL == (pvar = LocalAlloc(LPTR,
                                      dwNeededSize)))
        {
            lr = (LONG) GetLastError();

            goto done;
        }

        pvar->dwTotalSize = dwNeededSize;

        //
        // Call the api again
        //
        lr = lineGetDevConfig(pport->TPCB_Line->TLI_LineId,
                              pvar,
                              "tapi/line/diagnostics");
    }

    if(ERROR_SUCCESS != lr)
    {
        goto done;
    }

    if(     STRINGFORMAT_BINARY != pvar->dwStringFormat
        ||  pvar->dwStringSize < sizeof(LINEDIAGNOSTICSCONFIG))
    {
        RasTapiTrace("No diagnostics information available");

        goto done;
    }
    else
    {

        PLINEDIAGNOSTICSCONFIG lpConfig;

        lpConfig = (PLINEDIAGNOSTICSCONFIG)
                   ((LPBYTE) pvar + pvar->dwStringOffset);

        if(LDSIG_LINEDIAGNOSTICSCONFIG != lpConfig->hdr.dwSig)
        {
            RasTapiTrace("Invalid LineDiagnostics sig. 0x%x",
                        lpConfig->hdr.dwSig);
        }

        lpConfig->hdr.dwParam |= fSTANDARD_CALL_DIAGNOSTICS;

        lr = lineSetDevConfig(pport->TPCB_Line->TLI_LineId,
                              lpConfig,
                              pvar->dwStringSize,
                              "tapi/line/diagnostics");

    }

done:

    if(bvar != (PBYTE) pvar)
    {
        LocalFree(pvar);
    }

    RasTapiTrace("DwEnableModemDiagnostics. 0x%x",
                 lr);

    return (DWORD) lr;
}

/*++

Routine Description:

    This API opens a COM port.  It takes the port name in ASCIIZ
    form and supplies a handle to the open port.  hNotify is use
    to notify the caller if the device on the port shuts down.

Arguments:

Return Value:

    SUCCESS
    ERROR_PORT_NOT_CONFIGURED
    ERROR_DEVICE_NOT_READY

--*/
DWORD  APIENTRY
PortOpen(
    char *pszPortName,
    HANDLE *phIOPort,
    HANDLE hIoCompletionPort,
    DWORD dwCompletionKey
    )
{
    TapiPortControlBlock *pports ;
    DWORD   retcode ;
    DWORD   i ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    RasTapiTrace ("PortOpen: %s", pszPortName );

    pports = RasPortsList ;

    while ( pports )
    {
        if (    (_stricmp(pszPortName, pports->TPCB_Name) == 0)
            &&  (pports->TPCB_State != PS_UNAVAILABLE))
        {
            break ;
        }

        pports = pports->TPCB_next ;
    }

    if ( pports )
    {

        if (pports->TPCB_State == PS_UNINITIALIZED)
        {
            RasTapiTrace ("PortOpen: state = PS_UNINITIALIZED,"
                          " returning %d",
                          ERROR_TAPI_CONFIGURATION );

            // **** Exclusion END ****
            FreeMutex (RasTapiMutex) ;

            RasTapiTrace(" ");

            return ERROR_TAPI_CONFIGURATION ;

        }

        if (pports->TPCB_State != PS_CLOSED)
        {
            RasTapiTrace("PortOpen: Port is already open. "
                         "state = %d != PS_CLOSED",
                         pports->TPCB_State );

            // **** Exclusion END ****
            FreeMutex (RasTapiMutex) ;

            RasTapiTrace(" ");

            return ERROR_PORT_ALREADY_OPEN ;
        }

        if ((_stricmp (pports->TPCB_DeviceType,
                    DEVICETYPE_UNIMODEM) == 0)) {

            if (INVALID_HANDLE_VALUE == g_hAsyMac)
            {
                retcode = OpenAsyncMac (&g_hAsyMac);
            }

            if (INVALID_HANDLE_VALUE == g_hAsyMac)
            {
                RasTapiTrace ("PortOpen: Failed to CreateFile asyncmac."
                              " %d", retcode );

                if(SUCCESS == retcode)
                {
                    RasTapiTrace("Failed to open asyncmac but no error!!!");
                    retcode = ERROR_FILE_NOT_FOUND;
                }

                // *** Exclusion END ****
                FreeMutex (RasTapiMutex) ;

                RasTapiTrace(" ");
                return(retcode);
            }
        }

        if (pports->TPCB_Line->TLI_LineState == PS_CLOSED)
        {
            //
            // open line
            //
            LINEDEVCAPS     *linedevcaps ;
            BYTE            buffer[400] ;

            linedevcaps = (LINEDEVCAPS *)buffer ;
            linedevcaps->dwTotalSize = sizeof (buffer) ;

            lineGetDevCaps (RasLine,
                            pports->TPCB_Line->TLI_LineId,
                            pports->TPCB_Line->NegotiatedApiVersion,
                            pports->TPCB_Line->NegotiatedExtVersion,
                            linedevcaps) ;

            //
            // Remove LINEMEDIAMODE_INTERACTIVEVOICE from the
            // media mode since this mode cannot be used for
            // receiving calls.
            //
            pports->TPCB_Line->TLI_MediaMode =
                linedevcaps->dwMediaModes &
                            ~( LINEMEDIAMODE_INTERACTIVEVOICE |
                             LINEMEDIAMODE_AUTOMATEDVOICE) ;

            retcode =
             lineOpen (RasLine,
                   pports->TPCB_Line->TLI_LineId,
                   &pports->TPCB_Line->TLI_LineHandle,
                   pports->TPCB_Line->NegotiatedApiVersion,
                   pports->TPCB_Line->NegotiatedExtVersion,
                   (DWORD_PTR) pports->TPCB_Line,
                   LINECALLPRIVILEGE_OWNER,
                   pports->TPCB_Line->TLI_MediaMode,
                   NULL) ;

            if (retcode)
            {
                RasTapiTrace ("PortOpen: lineOpen Failed. 0x%x",
                              retcode );

                // **** Exclusion END ****
                FreeMutex (RasTapiMutex) ;

                RasTapiTrace(" ");

                return retcode ;
            }

            //
            // Set monitoring of rings
            //
            lineSetStatusMessages (pports->TPCB_Line->TLI_LineHandle,
                                LINEDEVSTATE_RINGING, 0) ;

            //
            //  Always turn off the modem lights incase this
            //  is a modem device
            //
            if ((_stricmp (pports->TPCB_DeviceType,
                        DEVICETYPE_UNIMODEM) == 0))
            {

                //
                // unimodem struct not defined in any header
                //
                typedef struct _DEVCFG
                {
                    DWORD   dwSize;
                    DWORD   dwVersion;
                    WORD    fwOptions;
                    WORD    wWaitBong;

                } DEVCFG;

#define LAUNCH_LIGHTS 8

                LPVARSTRING var ;
                BYTE    buffer[1000] ;
                DEVCFG  *devcfg ;

                var = (LPVARSTRING)buffer ;

                var->dwTotalSize  = 1000 ;

                var->dwStringSize = 0 ;

                lineGetDevConfig(pports->TPCB_Line->TLI_LineId,
                                 var, "comm/datamodem") ;

                devcfg = (DEVCFG*) (((LPBYTE) var)
                                + var->dwStringOffset) ;

                devcfg->fwOptions &= ~LAUNCH_LIGHTS ;

                lineSetDevConfig (pports->TPCB_Line->TLI_LineId,
                                  devcfg,
                                  var->dwStringSize,
                                  "comm/datamodem") ;

                //
                // Enable diagnostics on the modem
                //
                retcode = DwEnableModemDiagnostics(pports);

                RasTapiTrace("DwEnableModemDiagnostics returned 0x%x",
                             retcode);

                //
                // clear any error in this case. We don't want
                // to fail a connection just because we couldn't
                // obtain the connect response.
                //
                retcode = SUCCESS;

            }

            pports->TPCB_Line->TLI_LineState = PS_OPEN ;

        }

        //
        // Initialize the parameters
        //
        pports->TPCB_Info[0][0] = '\0' ;
        pports->TPCB_Info[1][0] = '\0' ;
        pports->TPCB_Info[2][0] = '\0' ;
        pports->TPCB_Info[3][0] = '\0' ;
        pports->TPCB_Info[4][0] = '\0' ;

        strcpy (pports->TPCB_Info[ISDN_CONNECTBPS_INDEX], "64000") ;

        pports->TPCB_Line->TLI_OpenCount++ ;

        pports->TPCB_State = PS_OPEN ;

        pports->TPCB_DisconnectReason = 0 ;

        pports->TPCB_CommHandle = INVALID_HANDLE_VALUE ;

        pports->TPCB_IoCompletionPort = hIoCompletionPort;

        pports->TPCB_CompletionKey = dwCompletionKey;

        if (pports->TPCB_Line->CharModeSupported)
        {

            pports->TPCB_SendRequestId =
            pports->TPCB_RecvRequestId = INFINITE;

            pports->TPCB_CharMode = FALSE;

            //
            // If this port does not have a receive fifo
            // allocated to it get one and init.
            //
            if (pports->TPCB_RecvFifo == NULL)
            {
                if ((pports->TPCB_RecvFifo =
                     LocalAlloc(LPTR, sizeof(RECV_FIFO) + 1500))
                            == NULL)
                {

                    RasTapiTrace("PortOpen: LocalAlloc Failed. "
                                 "%d, port %s, state = %d",
                                 GetLastError(),
                                 pports->TPCB_Name,
                                 pports->TPCB_State );

                    // **** Exclusion END ****
                    FreeMutex (RasTapiMutex) ;
                    return(GetLastError()) ;
                }

                pports->TPCB_RecvFifo->In =
                pports->TPCB_RecvFifo->Out =
                pports->TPCB_RecvFifo->Count = 0;
                pports->TPCB_RecvFifo->Size = 1500;
            }
        }

        *phIOPort = (HANDLE) pports ;

        // **** Exclusion END ****
        FreeMutex (RasTapiMutex) ;

        RasTapiTrace("PortOpen: successfully opened %s",
                     pszPortName );

        RasTapiTrace(" ");

        return(SUCCESS);

    }
    else
    {
        RasTapiTrace("PortOpen: Port %s not found",
                    pszPortName );
    }

   // **** Exclusion END ****
   FreeMutex (RasTapiMutex) ;

   RasTapiTrace(" ");

   return ERROR_PORT_NOT_CONFIGURED ;


}


/*++

Routine Description:

    This API closes the COM port for the input handle.
    It also finds the SerialPCB for the input handle,
    removes it from the linked list, and frees the
    memory for it

Arguments:

Return Value:

    SUCCESS
    Values returned by GetLastError()

--*/
DWORD  APIENTRY
PortClose (HANDLE hIOPort)
{
    TapiPortControlBlock *pports =
            (TapiPortControlBlock *) hIOPort ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    RasTapiTrace("PortClose: %s", pports->TPCB_Name );

    pports->TPCB_Line->TLI_OpenCount-- ;

    if (pports->TPCB_DevConfig)
    {
        LocalFree (pports->TPCB_DevConfig) ;
    }

    pports->TPCB_DevConfig = NULL ;

    if (pports->TPCB_Line->TLI_OpenCount == 0)
    {
        pports->TPCB_Line->TLI_LineState = PS_CLOSED ;

        lineClose (pports->TPCB_Line->TLI_LineHandle) ;
    }

    if (pports->TPCB_RecvFifo != NULL)
    {

        LocalFree(pports->TPCB_RecvFifo);

        pports->TPCB_RecvFifo = NULL;
    }

    if ( pports->TPCB_State == PS_UNAVAILABLE )
    {
        RasTapiTrace("PortClose: Removing port %s",
                     pports->TPCB_Name );

        //
        // This port has been marked for removal
        //
        dwRemovePort ( pports );

        RasTapiTrace("PortClose: Port removed");

    }
    else
    {
        RasTapiTrace ("PortClose: Changing state for"
                      "  %s from %d -> %d",
                      pports->TPCB_Name,
                      pports->TPCB_State,
                      PS_CLOSED );

        pports->TPCB_State = PS_CLOSED ;
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    RasTapiTrace(" ");

    return(SUCCESS);
}

/*++

Routine Description:

    This API returns a block of information to the caller about
    the port state.  This API may be called before the port is
    open in which case it will return inital default values
    instead of actual port values.
    hIOPort can be null in which case use portname to give
    information hIOPort may be the actual file handle or
    the hIOPort returned in port open.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD  APIENTRY
PortGetInfo(
        HANDLE hIOPort,
        TCHAR *pszPortName,
        BYTE *pBuffer,
        DWORD *pdwSize
        )
{
    DWORD i ;
    DWORD retcode = ERROR_FROM_DEVICE ;

    TapiPortControlBlock *port = RasPortsList;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    while ( port )
    {
        if (    !_stricmp(port->TPCB_Name, pszPortName)
            ||  (hIOPort == (HANDLE) port)
            ||  (hIOPort == port->TPCB_CommHandle))
        {
            hIOPort = (HANDLE) port ;

            retcode = GetInfo ((TapiPortControlBlock *) hIOPort,
                                pBuffer, pdwSize) ;

            break ;
        }

        port = port->TPCB_next;
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    return (retcode);
}

/*++

Routine Description:

    The values for most input keys are used to set the port
    parameters directly.  However, the carrier BPS and the
    error conrol on flag set fields in the Serial Port Control
    Block only, and not the port.
    hIOPort may the port handle returned in portopen or the
    actual file handle.

Arguments:

Return Value:

    SUCCESS
    ERROR_WRONG_INFO_SPECIFIED
    Values returned by GetLastError()

--*/
DWORD  APIENTRY
PortSetInfo(HANDLE hIOPort, RASMAN_PORTINFO *pInfo)
{
    DWORD retcode ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    hIOPort = LookUpControlBlock(hIOPort) ;

    if (NULL == hIOPort)
    {
        FreeMutex ( RasTapiMutex );

        RasTapiTrace ("PortSetInfo: Port Not found");

        RasTapiTrace(" ");

        return ERROR_PORT_NOT_FOUND;
    }

    retcode = SetInfo ((TapiPortControlBlock *) hIOPort, pInfo) ;

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    RasTapiTrace(" ");

    return (retcode);
}

/*++

Routine Description:

    Really only has meaning if the
    call was active. Will return

Arguments:

Return Value:

    SUCCESS
    Values returned by GetLastError()

--*/
DWORD  APIENTRY
PortTestSignalState(HANDLE hPort, DWORD *pdwDeviceState)
{
    BYTE                    buffer[200] ;
    LINECALLSTATUS          *pcallstatus ;
    DWORD                   retcode     = SUCCESS ;

    TapiPortControlBlock    *hIOPort
                = (TapiPortControlBlock *) hPort;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    *pdwDeviceState = 0 ;

    memset (buffer, 0, sizeof(buffer)) ;

    pcallstatus = (LINECALLSTATUS *) buffer ;

    pcallstatus->dwTotalSize = sizeof (buffer) ;

    //
    // First check if we have a disconnect reason stored away.
    // if so return that.
    //
    if (hIOPort->TPCB_DisconnectReason)
    {
        *pdwDeviceState = hIOPort->TPCB_DisconnectReason ;

        RasTapiTrace("PortTestSignalState: DisconnectReason = %d",
                     *pdwDeviceState );
    }

    else if (hIOPort->TPCB_State != PS_CLOSED)
    {
        //
        // Only in case of CONNECTING or CONNECTED do we care
        // how the link dropped
        //
        if (    hIOPort->TPCB_State == PS_CONNECTING
            ||  hIOPort->TPCB_State == PS_CONNECTED)
        {

            retcode = lineGetCallStatus(hIOPort->TPCB_CallHandle,
                                        pcallstatus) ;

            if (retcode)
            {
#if DBG
                DbgPrint("PortTestSignalState: "
                         "lineGetCallStatus Failed. retcode = %d\n",
                         retcode);
#endif
                *pdwDeviceState = SS_HARDWAREFAILURE;
            }

            else if (pcallstatus->dwCallState ==
                        LINECALLSTATE_DISCONNECTED)
            {
                *pdwDeviceState = SS_LINKDROPPED ;
            }
            else if (pcallstatus->dwCallState ==
                        LINECALLSTATE_IDLE)
            {
                 *pdwDeviceState = SS_HARDWAREFAILURE ;
            }
            else if (pcallstatus->dwCallState ==
                        LINECALLSTATE_SPECIALINFO)
            {
                 *pdwDeviceState = SS_HARDWAREFAILURE ;
            }
            RasTapiTrace("PortTestSignalState: CallState"
                         " = 0x%x, DeviceState = %d",
                         pcallstatus->dwCallState,
                         *pdwDeviceState );

        }
        else
        {
            RasTapiTrace("PortTestSignalState: DeviceState = %d",
                        *pdwDeviceState );

            *pdwDeviceState = SS_LINKDROPPED | SS_HARDWAREFAILURE ;
        }
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    return retcode ;
}

/*++

Routine Description:

    This API is called when a connection has been completed.
    It in turn calls the asyncmac device driver in order to
    indicate to asyncmac that the port and the connection
    over it are ready for commumication.

Arguments:

Return Value:

    SUCCESS
    ERROR_PORT_NOT_OPEN
    ERROR_NO_CONNECTION
    Values returned by GetLastError()

--*/
DWORD  APIENTRY
PortConnect(HANDLE          hPort,
            BOOL            bLegacyFlagNotUsed,
            ULONG_PTR       *endpoint )
{
    DCB                     DCB ;
    LINECALLINFO            linecall ;
    ASYMAC_OPEN             AsyMacOpen;
    ASYMAC_DCDCHANGE        A ;
    DWORD                   dwBytesReturned ;
    TapiPortControlBlock    *hIOPort = (TapiPortControlBlock *) hPort;
    VARSTRING               *varstring ;
    BYTE                    buffer [100] ;


    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    RasTapiTrace("PortConnect: %s", hIOPort->TPCB_Name );

    //
    // We must be connected to process this
    //
    if (hIOPort->TPCB_State != PS_CONNECTED)
    {

        RasTapiTrace (
            "PortConnect: Port %s not connected. state = %d",
            hIOPort->TPCB_Name,
            hIOPort->TPCB_State );

        // **** Exclusion END ****
        FreeMutex (RasTapiMutex) ;

        RasTapiTrace(" ");

        return ERROR_PORT_DISCONNECTED ;
    }

    //
    // get the cookie to realize tapi and ndis endpoints
    //
    memset (buffer, 0, sizeof(buffer));
    varstring = (VARSTRING *) buffer ;
    varstring->dwTotalSize = sizeof(buffer) ;

    //
    // get the actual line speed at which we connected
    //
    memset (&linecall, 0, sizeof (linecall)) ;

    linecall.dwTotalSize = sizeof (linecall) ;

    lineGetCallInfo (hIOPort->TPCB_CallHandle, &linecall) ;

    _ltoa(linecall.dwRate, hIOPort->TPCB_Info[CONNECTBPS_INDEX], 10);

    if (_stricmp (hIOPort->TPCB_DeviceType,
                  DEVICETYPE_UNIMODEM) == 0)
    {
        if(INVALID_HANDLE_VALUE == hIOPort->TPCB_CommHandle)
        {
            DWORD                   retcode;

            if ( retcode =
                    lineGetID (hIOPort->TPCB_Line->TLI_LineHandle,
                               hIOPort->TPCB_AddressId,
                               hIOPort->TPCB_CallHandle,
                               LINECALLSELECT_CALL,
                               varstring,
                               "comm/datamodem"))
            {
                RasTapiTrace("PortConnect: %s lineGetID Failed. 0x%x",
                        hIOPort->TPCB_Name, retcode );

                // **** Exclusion End ****
                FreeMutex (RasTapiMutex) ;
                RasTapiTrace(" ");

                return ERROR_FROM_DEVICE ;
            }

            hIOPort->TPCB_CommHandle = (HANDLE) 
                                       UlongToPtr((*((DWORD UNALIGNED *)
                         ((BYTE *)varstring+varstring->dwStringOffset))));

            RasTapiTrace("PortConnect: TPCB_CommHandle=%d",
                          hIOPort->TPCB_CommHandle );

            //
            // Create the I/O completion port for
            // asynchronous operation completion
            // notificiations.
            //
            if (CreateIoCompletionPort(
                  hIOPort->TPCB_CommHandle,
                  hIOPort->TPCB_IoCompletionPort,
                  hIOPort->TPCB_CompletionKey,
                  0) == NULL)
            {
                retcode = GetLastError();

                RasTapiTrace("PortConnect: %s. CreateIoCompletionPort "
                             "failed. %d",
                             hIOPort->TPCB_Name,
                             retcode );

                FreeMutex(RasTapiMutex);
                RasTapiTrace(" ");

                return retcode;
            }

            //
            // Initialize the port for approp. buffers
            //
            SetupComm (hIOPort->TPCB_CommHandle, 1514, 1514) ;
        }

        //
        // Before we send IOCTL to asyncmac - sanitize the DCB in
        // case some app left databits, stopbits, parity set to bad
        // values.
        //
        if (!GetCommState(hIOPort->TPCB_CommHandle, &DCB))
        {
            RasTapiTrace ("PortConnect: GetCommState failed for %s",
                          hIOPort->TPCB_Name);

            FreeMutex(RasTapiMutex);

            RasTapiTrace(" ");

            return(GetLastError());
        }

        DCB.ByteSize = 8 ;
        DCB.StopBits = ONESTOPBIT ;
        DCB.Parity   = NOPARITY ;

        if (!SetCommState(hIOPort->TPCB_CommHandle, &DCB))
        {

            DWORD retcode = GetLastError();

            RasTapiTrace ("PortConnect: SetCommState failed "
                          "for %s.handle=0x%x. %d",
                           hIOPort->TPCB_Name,
                           hIOPort->TPCB_CommHandle,
                           retcode);

            // FreeMutex(RasTapiMutex);

            RasTapiTrace(" ");

            // return(retcode);
            // This is not a fatal error. Ignore the error.
            retcode = ERROR_SUCCESS;
        }

        RasTapiTrace("PortConnect: dwRate=%d", linecall.dwRate );

        AsyMacOpen.hNdisEndpoint = INVALID_HANDLE_VALUE ;

        AsyMacOpen.LinkSpeed  = linecall.dwRate ;

        AsyMacOpen.FileHandle = hIOPort->TPCB_CommHandle ;

        AsyMacOpen.QualOfConnect = (UINT)NdisWanErrorControl;

        {
            OVERLAPPED overlapped ;
            memset (&overlapped, 0, sizeof(OVERLAPPED)) ;
            if (!DeviceIoControl(g_hAsyMac,
                                 IOCTL_ASYMAC_OPEN,
                                 &AsyMacOpen,
                                 sizeof(AsyMacOpen),
                                 &AsyMacOpen,
                                 sizeof(AsyMacOpen),
                                 &dwBytesReturned,
                 &overlapped))
            {
                DWORD dwError = GetLastError();

                RasTapiTrace("PortConnect: IOCTL_ASYMAC_OPEN "
                             "failed. %d", dwError );

                // *** Exclusion END ****
                FreeMutex (RasTapiMutex) ;

                RasTapiTrace(" ");
                return(dwError);
            }
        }

        hIOPort->TPCB_Endpoint = AsyMacOpen.hNdisEndpoint;

        *endpoint = (ULONG_PTR) AsyMacOpen.hNdisEndpoint;

    }
    else
    {
        DWORD                   retcode;

        if ( retcode = lineGetID (hIOPort->TPCB_Line->TLI_LineHandle,
                                   hIOPort->TPCB_AddressId,
                                   hIOPort->TPCB_CallHandle,
                                   LINECALLSELECT_CALL,
                                   varstring,
                                   "NDIS"))
        {
            RasTapiTrace ("PortConnect: %s. lineGetId Failed. 0x%x",
                          hIOPort->TPCB_Name,
                          retcode );

            // **** Exclusion End ****
            FreeMutex (RasTapiMutex) ;

            RasTapiTrace(" ");

            return ERROR_FROM_DEVICE ;
        }

        hIOPort->TPCB_Endpoint =
            *((HANDLE UNALIGNED *) ((BYTE *)varstring+varstring->dwStringOffset)) ;

        *endpoint = (ULONG_PTR) hIOPort->TPCB_Endpoint ;

        if (    hIOPort->TPCB_Line->CharModeSupported
            &&  hIOPort->TPCB_CharMode)
        {

            PRASTAPI_DEV_SPECIFIC SetPPP;

            hIOPort->TPCB_CharMode = FALSE;

            if ((SetPPP =
                    LocalAlloc(LPTR, sizeof(RASTAPI_DEV_SPECIFIC))) == NULL)
            {

                DWORD dwErr = GetLastError();

                RasTapiTrace("PortConnect: Failed to allocate. %d, "
                             "port %s, State=%d",
                             dwErr,
                             hIOPort->TPCB_Name,
                             hIOPort->TPCB_State );

                // **** Exclusion END ****
                FreeMutex (RasTapiMutex) ;

                return(dwErr);
            }

            SetPPP->Command = RASTAPI_DEV_PPP_MODE;

            hIOPort->TPCB_ModeRequestDesc = SetPPP;

            hIOPort->TPCB_ModeRequestId =
            lineDevSpecific(hIOPort->TPCB_Line->TLI_LineHandle,
                            hIOPort->TPCB_AddressId,
                            hIOPort->TPCB_CallHandle,
                            SetPPP,
                            sizeof(RASTAPI_DEV_SPECIFIC));

            if (    hIOPort->TPCB_ModeRequestId == 0
                ||  hIOPort->TPCB_ModeRequestId > 0x80000000)
            {

                LocalFree(SetPPP);
                hIOPort->TPCB_ModeRequestId = INFINITE;
                hIOPort->TPCB_ModeRequestDesc = NULL;
            }
        }
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    RasTapiTrace(" ");
    return(SUCCESS);
}

/*++

Routine Description:

    This API is called to drop a connection and close AsyncMac.

Arguments:

Return Value:

    SUCCESS
    PENDING
    ERROR_PORT_NOT_OPEN

--*/
DWORD  APIENTRY
PortDisconnect(HANDLE hPort)
{
    DWORD retcode = SUCCESS ;
    TapiPortControlBlock *hIOPort = (TapiPortControlBlock *) hPort;

    if(NULL == hIOPort)
    {
        RasTapiTrace("PortDisconnect: hioport==NULL");
        return E_INVALIDARG;
    }

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    RasTapiTrace("PortDisconnect: %s", hIOPort->TPCB_Name );

    if (    (hIOPort->TPCB_State == PS_CONNECTED)
        ||  (hIOPort->TPCB_State == PS_CONNECTING)
        ||  (   (hIOPort->TPCB_State == PS_LISTENING)
            &&  (hIOPort->TPCB_ListenState != LS_WAIT)))
    {

        retcode = InitiatePortDisconnection (hIOPort) ;

        //
        // If we had saved away the device config then we
        // restore it here.
        //
        if (hIOPort->TPCB_DefaultDevConfig)
        {
            lineSetDevConfig (hIOPort->TPCB_Line->TLI_LineId,
                              hIOPort->TPCB_DefaultDevConfig,
                              hIOPort->TPCB_DefaultDevConfigSize,
                              "comm/datamodem") ;

            LocalFree (hIOPort->TPCB_DefaultDevConfig) ;

            hIOPort->TPCB_DefaultDevConfig = NULL ;
        }
    }
    else if (hIOPort->TPCB_State == PS_LISTENING)
    {
        RasTapiTrace ("PortDisconnect: Changing State"
                      " of %s from %d -> %d",
                      hIOPort->TPCB_Name,
                      hIOPort->TPCB_State,
                      PS_OPEN );
        //
        // for LS_WAIT listen state case
        //
        hIOPort->TPCB_State = PS_OPEN ;

        retcode = SUCCESS ;

    }
    else if (hIOPort->TPCB_State == PS_DISCONNECTING)
    {

        retcode = PENDING ;
    }

    if (hIOPort->TPCB_Line->CharModeSupported)
    {

        hIOPort->TPCB_RecvFifo->In =
        hIOPort->TPCB_RecvFifo->Out =
        hIOPort->TPCB_RecvFifo->Count = 0;

    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    RasTapiTrace(" ");
    return retcode ;
}

/*++

Routine Description:

    This API re-initializes the com port after use.

Arguments:

Return Value:

    SUCCESS
    ERROR_PORT_NOT_CONFIGURED
    ERROR_DEVICE_NOT_READY

--*/

DWORD  APIENTRY
PortInit(HANDLE hIOPort)
{
  return(SUCCESS);
}

/*++

Routine Description:

    This API sends a buffer to the port.  This API is
    asynchronous and normally returns PENDING; however, if
    WriteFile returns synchronously, the API will return
    SUCCESS.

Arguments:

Return Value:

    SUCCESS
    PENDING
    Return code from GetLastError

--*/
DWORD
PortSend(
        HANDLE hPort, BYTE *pBuffer,
        DWORD dwSize
        )
{
    TapiPortControlBlock *hIOPort =
                            (TapiPortControlBlock *) hPort;
    DWORD retcode ;
    DWORD pdwBytesWritten;
    BOOL  bIODone;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (_stricmp (hIOPort->TPCB_DeviceType,
                  DEVICETYPE_UNIMODEM) == 0)
    {
        // DbgPrint("sending %c\n", (CHAR) *pBuffer);

        // Send Buffer to Port
        //
        bIODone = WriteFile(
                    hIOPort->TPCB_CommHandle,
                    pBuffer,
                    dwSize,
                    &pdwBytesWritten,
                    (LPOVERLAPPED)&(hIOPort->TPCB_WriteOverlapped));

        if (bIODone)
        {
            retcode = PENDING;
        }

        else if ((retcode = GetLastError()) == ERROR_IO_PENDING)
        {
            retcode = PENDING ;
        }

    }
    else if (hIOPort->TPCB_Line->CharModeSupported)
    {

        PRASTAPI_DEV_SPECIFIC TapiSend;
        DWORD   TapiSendSize;

        if (hIOPort->TPCB_State != PS_CONNECTED)
        {
            // **** Exclusion END ****
            FreeMutex (RasTapiMutex) ;
            return SUCCESS;
        }

        TapiSendSize = sizeof(RASTAPI_DEV_SPECIFIC) + dwSize;

        if ((TapiSend = LocalAlloc(LPTR, TapiSendSize)) == NULL)
        {

            // **** Exclusion END ****
            FreeMutex(RasTapiMutex);
            return(GetLastError());
        }

        TapiSend->Command = RASTAPI_DEV_SEND;
        TapiSend->DataSize = dwSize;
        memcpy(TapiSend->Data, pBuffer, dwSize);

        hIOPort->TPCB_SendDesc = TapiSend;
        hIOPort->TPCB_CharMode = TRUE;

        hIOPort->TPCB_SendRequestId =
        lineDevSpecific(hIOPort->TPCB_Line->TLI_LineHandle,
                        hIOPort->TPCB_AddressId,
                        hIOPort->TPCB_CallHandle,
                        TapiSend,
                        TapiSendSize);

        if (hIOPort->TPCB_SendRequestId == 0)
        {
            //
            // Do I need to set the event?
            //
            LocalFree(TapiSend);

            hIOPort->TPCB_SendDesc = NULL;

            hIOPort->TPCB_SendRequestId = INFINITE;

            retcode = SUCCESS;

        }
        else if (hIOPort->TPCB_SendRequestId > 0x80000000)
        {

            LocalFree(TapiSend);

            hIOPort->TPCB_SendDesc = NULL;

            hIOPort->TPCB_SendRequestId = INFINITE;

            retcode = ERROR_FROM_DEVICE;

        }
        else
        {
            //
            // The request has been pended.  We need to free the
            // buffer at completion time.
            //
            //
            retcode = PENDING;
        }
    }
    else
    {
        retcode = SUCCESS;
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    return retcode ;
}

/*++

Routine Description:

    This API reads from the port.  This API is
    asynchronous and normally returns PENDING; however, if
    ReadFile returns synchronously, the API will return
    SUCCESS.

Arguments:

Return Value:

    SUCCESS
    PENDING
    Return code from GetLastError

--*/
DWORD
PortReceive(HANDLE hPort,
            BYTE   *pBuffer,
            DWORD  dwSize,
            DWORD  dwTimeOut)
{
    TapiPortControlBlock *hIOPort
                               = (TapiPortControlBlock *) hPort;
    COMMTIMEOUTS  CT;
    DWORD         pdwBytesRead;
    BOOL          bIODone;
    DWORD         retcode ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (_stricmp (hIOPort->TPCB_DeviceType,
                  DEVICETYPE_UNIMODEM) == 0)
    {

        // Set Read Timeouts

        CT.ReadIntervalTimeout = 0;

        CT.ReadTotalTimeoutMultiplier = 0;

        CT.ReadTotalTimeoutConstant = dwTimeOut;

        if (!SetCommTimeouts(hIOPort->TPCB_CommHandle, &CT))
        {
            DWORD dwError = GetLastError();

            RasTapiTrace("PorTReceive: SetCommTimeouts failed "
                         "for %s. %d", hIOPort->TPCB_Name,
                         dwError);

            // **** Exclusion END ****
            FreeMutex (RasTapiMutex) ;

            RasTapiTrace(" ");
            return(dwError);
        }

        //
        // Read from Port
        //
        bIODone = ReadFile(hIOPort->TPCB_CommHandle,
                           pBuffer,
                           dwSize,
                           &pdwBytesRead,
                           (LPOVERLAPPED) &(hIOPort->TPCB_ReadOverlapped));

        if (bIODone)
        {
            retcode = PENDING;
        }

        else if ((retcode = GetLastError()) == ERROR_IO_PENDING)
        {
            retcode = PENDING;
        }

    }
    else if (hIOPort->TPCB_Line->CharModeSupported)
    {

        if (hIOPort->TPCB_State != PS_CONNECTED)
        {
            // **** Exclusion END ****
            FreeMutex (RasTapiMutex) ;
            return SUCCESS;
        }

        //
        // What to do about timeouts?
        //
        hIOPort->TPCB_RasmanRecvBuffer = pBuffer;
        hIOPort->TPCB_RasmanRecvBufferSize = dwSize;

        //
        // If we already have some data buffered
        // go ahead and notify
        //
        if (hIOPort->TPCB_RecvFifo->Count > 0)
        {
            //
            //SetEvent(hAsyncEvent);
            //
            PostNotificationCompletion( hIOPort );
        }
        else
        {
        }

        retcode = PENDING;
    }
    else
    {
        retcode = SUCCESS ;
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    return retcode ;
}

/*++

Routine Description:

    Completes a read  - if still PENDING it cancels it -
    else it returns the bytes read. PortClearStatistics.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD
PortReceiveComplete (HANDLE hPort, PDWORD bytesread)
{
    TapiPortControlBlock *hIOPort =
                (TapiPortControlBlock *) hPort;

    DWORD retcode = SUCCESS;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (!GetOverlappedResult(
                hIOPort->TPCB_CommHandle,
                (LPOVERLAPPED)&(hIOPort->TPCB_ReadOverlapped),
                bytesread,
                FALSE))
    {
        retcode = GetLastError() ;

        RasTapiTrace("PortReceiveComplete: GetOverlappedResult "
                     "Failed.%s, %d", hIOPort->TPCB_Name,
                     retcode );

        PurgeComm (hIOPort->TPCB_CommHandle, PURGE_RXABORT) ;
        *bytesread = 0 ;

    }
    else if (hIOPort->TPCB_Line->CharModeSupported)
    {

        *bytesread =
        CopyDataFromFifo(hIOPort->TPCB_RecvFifo,
                         hIOPort->TPCB_RasmanRecvBuffer,
                         hIOPort->TPCB_RasmanRecvBufferSize);

        hIOPort->TPCB_RasmanRecvBuffer = NULL;
        hIOPort->TPCB_RasmanRecvBufferSize = 0;
    }
    else
    {
        retcode = SUCCESS ;
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    return retcode ;
}

/*++

Routine Description:

    This API selects Asyncmac compression mode
    by setting Asyncmac's compression bits.

Arguments:

Return Value:

    SUCCESS
    Return code from GetLastError

--*/
DWORD
PortCompressionSetInfo(HANDLE hIOPort)
{
  return SUCCESS;
}

/*++

Routine Description:

    This API is used to mark the beginning of the
    period for which statistics will be reported.
    The current numbers are copied from the MAC and
    stored in the Serial Port Control Block.  At
    the end of the period PortGetStatistics will be
    called to compute the difference.

Arguments:

Return Value:

    SUCCESS
    ERROR_PORT_NOT_OPEN

--*/
DWORD
PortClearStatistics(HANDLE hIOPort)
{
  return SUCCESS;
}


/*++

Routine Description:

    This API reports MAC statistics since the last call to
    PortClearStatistics.

Arguments:

Return Value:

    SUCCESS
    ERROR_PORT_NOT_OPEN

--*/
DWORD
PortGetStatistics(
        HANDLE hIOPort,
        RAS_STATISTICS *pStat
        )
{
  return(SUCCESS);
}

/*++

Routine Description:

    Sets the framing type with the mac

Arguments:

Return Value:

    SUCCESS

--*/
DWORD  APIENTRY
PortSetFraming(
        HANDLE hIOPort,
        DWORD SendFeatureBits,
        DWORD RecvFeatureBits,
        DWORD SendBitMask,
        DWORD RecvBitMask
        )
{

    return(SUCCESS);
}


/*++

Routine Description:

    This API is used in MS-DOS only.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD  APIENTRY
PortGetPortState(char *pszPortName, DWORD *pdwUsage)
{
  return(SUCCESS);
}

/*++

Routine Description:

    This API is used in MS-DOS only.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD  APIENTRY
PortChangeCallback(HANDLE hIOPort)
{
  return(SUCCESS);
}

/*++

Routine Description:

    For the given hIOPort this returns the file
    handle for the connection

Arguments:

Return Value:

    SUCCESS

--*/
DWORD  APIENTRY
PortGetIOHandle(HANDLE hPort, HANDLE *FileHandle)
{
    DWORD retcode ;
    TapiPortControlBlock *hIOPort = (TapiPortControlBlock *) hPort;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (hIOPort->TPCB_State == PS_CONNECTED)
    {
        //
        // purge the comm since it may still have
        // characters from modem responses
        //
        RasTapiTrace("PortGetIOHandle: Purging Comm %s",
                     hIOPort->TPCB_Name );

        Sleep ( 10 );

        PurgeComm (hIOPort->TPCB_CommHandle,
                      PURGE_RXABORT
                    | PURGE_TXCLEAR
                    | PURGE_RXCLEAR );

        *FileHandle = hIOPort->TPCB_CommHandle ;
        retcode = SUCCESS ;
    }
    else
    {
        RasTapiTrace("PortGetIOHandle: %s. port not "
                     "open. State = %d",
                     hIOPort->TPCB_Name,
                     hIOPort->TPCB_Name);

        retcode = ERROR_PORT_NOT_OPEN ;
    }

    // **** Exclusion Begin ****
    FreeMutex (RasTapiMutex) ;

    return retcode ;
}

/*++

Routine Description:

    Enumerates all devices in the device INF file for the
    specified DevictType.

Arguments:

Return Value:

    Return codes from RasDevEnumDevices

--*/
DWORD APIENTRY
DeviceEnum (char  *pszDeviceType,
            DWORD *pcEntries,
            BYTE  *pBuffer,
            DWORD *pdwSize)
{
    *pdwSize    = 0 ;
    *pcEntries = 0 ;

    return(SUCCESS);
}

/*++

Routine Description:

    Returns a summary of current information from
    the InfoTable for the device on the port in Pcb.

Arguments:

Return Value:

    Return codes from GetDeviceCB, BuildOutputTable

--*/
DWORD APIENTRY
DeviceGetInfo(HANDLE hPort,
              char   *pszDeviceType,
              char   *pszDeviceName,
              BYTE   *pInfo,
              DWORD   *pdwSize)
{
    DWORD retcode ;
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
    {
        RasTapiTrace("DeviceGetInfo: Port Not "
                     "found. hPort = 0x%x ",
                     hPort );

        return ERROR_PORT_NOT_FOUND ;
    }

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    retcode = GetInfo (hIOPort, pInfo, pdwSize) ;


    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

    return(retcode);
}

/*++

Routine Description:

    Sets attributes in the InfoTable for the device on the
    port in Pcb.

Arguments:

Return Value:

    Return codes from GetDeviceCB, UpdateInfoTable

--*/
DWORD APIENTRY
DeviceSetInfo(HANDLE        hPort,
              char              *pszDeviceType,
              char              *pszDeviceName,
              RASMAN_DEVICEINFO *pInfo)
{
    DWORD retcode ;
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
    {
        RasTapiTrace ("DeviceSetInfo: Port not "
                      "found. hPort = 0x%x",
                      hPort );

        RasTapiTrace(" ");

        return ERROR_PORT_NOT_FOUND ;
    }


    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    retcode = SetInfo (hIOPort, (RASMAN_PORTINFO*) pInfo) ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

    return (retcode);
}

/*++

Routine Description:

    Initiates the process of connecting a device.

Arguments:

Return Value:

    Return codes from ConnectListen

--*/
DWORD APIENTRY
DeviceConnect(HANDLE hPort,
              char   *pszDeviceType,
              char   *pszDeviceName)
{
    LINECALLPARAMS *linecallparams ;
    LPVARSTRING var ;
    BYTE       buffer [2000] ;
    BYTE       *nextstring ;
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
    {
        RasTapiTrace ("DeviceConnect: %s not found",
                     (  pszDeviceName
                     ?  pszDeviceName
                     :  "NULL"));

        return ERROR_PORT_NOT_FOUND ;
    }


    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    //
    // Check to see if the port is in disconnecting state
    //
    if ( hIOPort->TPCB_State != PS_OPEN )
    {

#if DBG
        DbgPrint("RASTAPI: port is not "
                 "in PS_OPEN state. State = %d \n",
                 hIOPort->TPCB_State );
#endif

        RasTapiTrace ("DeviceConnect: Device %s is not"
                      " in PS_OPEN state state = %d",
                      (pszDeviceName)
                      ? pszDeviceName
                      : "NULL",
                      hIOPort->TPCB_State );

        FreeMutex ( RasTapiMutex );

        return ERROR_PORT_NOT_AVAILABLE;
    }

    //
    // if dev config has been set for this device we
    // should call down and set it.
    //
    if (    (hIOPort->TPCB_DevConfig)
        &&  (_stricmp (hIOPort->TPCB_DeviceType,
                       DEVICETYPE_UNIMODEM) == 0))
    {
        RAS_DEVCONFIG *pDevConfig;

        //
        // Before the write this - save away the current
        // setting for the device.
        //
        var = (LPVARSTRING)buffer ;

        var->dwTotalSize  = 2000 ;

        var->dwStringSize = 0 ;

        lineGetDevConfig (hIOPort->TPCB_Line->TLI_LineId,
                          var,
                          "comm/datamodem") ;

        if(NULL != hIOPort->TPCB_DefaultDevConfig)
        {
            LocalFree(hIOPort->TPCB_DefaultDevConfig);
            hIOPort->TPCB_DefaultDevConfig = NULL;
        }
        
        //
        // Alloc mem for the returned info. If memory allocation
        // fails, its not really fatal - we will just fail to
        // save the dev config - we will try allocating again
        // when this api is called next.
        //

        hIOPort->TPCB_DefaultDevConfigSize = 0;
        
        hIOPort->TPCB_DefaultDevConfig =
                    LocalAlloc (LPTR, var->dwStringSize) ;

        if(NULL != hIOPort->TPCB_DefaultDevConfig)
        {

            hIOPort->TPCB_DefaultDevConfigSize = var->dwStringSize ;

            memcpy (hIOPort->TPCB_DefaultDevConfig,
                   (CHAR*)var+var->dwStringOffset,
                   var->dwStringSize) ;
        }

        pDevConfig = (RAS_DEVCONFIG *) hIOPort->TPCB_DevConfig;

        lineSetDevConfig (hIOPort->TPCB_Line->TLI_LineId,
                          (PBYTE) ((PBYTE) pDevConfig +
                          pDevConfig->dwOffsetofModemSettings),
                          pDevConfig->dwSizeofModemSettings,
                          "comm/datamodem") ;

    }

    memset (buffer, 0, sizeof(buffer)) ;

    linecallparams = (LINECALLPARAMS *) buffer ;

    nextstring = (buffer + sizeof (LINECALLPARAMS)) ;

    linecallparams->dwTotalSize = sizeof(buffer) ;

    strcpy (nextstring, hIOPort->TPCB_Address) ;

    linecallparams->dwOrigAddressSize = strlen (nextstring) ;

    linecallparams->dwOrigAddressOffset = (DWORD)(nextstring - buffer) ;

    linecallparams->dwAddressMode = LINEADDRESSMODE_DIALABLEADDR ;

    nextstring += linecallparams->dwOrigAddressSize ;

    if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_ISDN) == 0)
    {
        SetIsdnParams (hIOPort, linecallparams) ;
    }
    else if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_X25) == 0)
    {

        if (*hIOPort->TPCB_Info[X25_USERDATA_INDEX] != '\0')
        {

            strcpy (nextstring,
                    hIOPort->TPCB_Info[X25_USERDATA_INDEX]) ;

            linecallparams->dwUserUserInfoSize =
                                strlen (nextstring) ;

            linecallparams->dwUserUserInfoOffset =
                                (DWORD)(nextstring - buffer) ;

            nextstring += linecallparams->dwUserUserInfoSize ;

        }

        if (*hIOPort->TPCB_Info[X25_FACILITIES_INDEX] != '\0')
        {

            strcpy (nextstring, hIOPort->TPCB_Info[X25_FACILITIES_INDEX]) ;

            linecallparams->dwDevSpecificSize =
                            strlen (nextstring) ;

            linecallparams->dwDevSpecificOffset =
                            (DWORD)(nextstring - buffer) ;

            nextstring += linecallparams->dwDevSpecificSize ;
        }

        //
        // Diagnostic key is ignored.
        //
        SetX25Params(hIOPort, linecallparams);

    }
    else if (_stricmp (hIOPort->TPCB_DeviceType,
                       DEVICETYPE_UNIMODEM) == 0)
    {
        SetModemParams (hIOPort, linecallparams) ;

    } else if (_stricmp(hIOPort->TPCB_DeviceType,
                        DEVICETYPE_ATM) == 0) 
    {
        SetAtmParams (hIOPort, linecallparams) ;
    } else
    {
        SetGenericParams(hIOPort, linecallparams);
    }

    //
    // mark request id as unused
    //
    hIOPort->TPCB_RequestId = INFINITE ;

    //
    // set call handle to bogus value
    //
    hIOPort->TPCB_CallHandle = (HCALL) INFINITE ;

    hIOPort->TPCB_AsyncErrorCode = SUCCESS ;

    RasTapiTrace ("DeviceConnect: calling lineMakeCall"
                  " for %s, address=%s",
                  hIOPort->TPCB_Name,
                  hIOPort->TPCB_Info[ADDRESS_INDEX] );

    if ((hIOPort->TPCB_RequestId =
        lineMakeCall (hIOPort->TPCB_Line->TLI_LineHandle,
                      &hIOPort->TPCB_CallHandle,
                      hIOPort->TPCB_Info[ADDRESS_INDEX],
                      0,
                      linecallparams)) > 0x80000000 )
    {

        RasTapiTrace ("DeviceConnect: lineMakeCall"
                      " Failed for %s. 0x%x",
                      hIOPort->TPCB_Name,
                      hIOPort->TPCB_RequestId );

        // **** Exclusion End ****
        FreeMutex (RasTapiMutex) ;

        if (hIOPort->TPCB_RequestId == LINEERR_INUSE)
        {
            RasTapiTrace("DeviceConnect: ERROR_PORT_NOT_AVAILABLE");

            RasTapiTrace(" ");

            return ERROR_PORT_NOT_AVAILABLE ;
        }

        RasTapiTrace("DeviceConnect: ERROR_FROM_DEVICE");

        RasTapiTrace(" ");

        return ERROR_FROM_DEVICE ;

    }

    RasTapiTrace ("DeviceConnect: Changing state for %s"
                  " from %d -> %d",
                  hIOPort->TPCB_Name,
                  hIOPort->TPCB_State,
                  PS_CONNECTING );

    hIOPort->TPCB_State = PS_CONNECTING ;

    hIOPort->TPCB_DisconnectReason = 0 ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

    return (PENDING);
}



VOID
SetIsdnParams (
        TapiPortControlBlock *hIOPort,
        LINECALLPARAMS *linecallparams
        )
{
    WORD    numchannels ;
    WORD    fallback ;

    //
    // Line type
    //
    if (_stricmp (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX],
        ISDN_LINETYPE_STRING_64DATA) == 0)
    {
        linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;

        linecallparams->dwMinRate = 64000 ;

        linecallparams->dwMaxRate = 64000 ;

        linecallparams->dwMediaMode = LINEMEDIAMODE_DIGITALDATA ;

    }
    else if (_stricmp (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX],
             ISDN_LINETYPE_STRING_56DATA) == 0)
    {
        linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;

        linecallparams->dwMinRate = 56000 ;

        linecallparams->dwMaxRate = 56000 ;

        linecallparams->dwMediaMode = LINEMEDIAMODE_DIGITALDATA ;

    }
    else if (_stricmp (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX],
                       ISDN_LINETYPE_STRING_56VOICE) == 0)
    {
        linecallparams->dwBearerMode = LINEBEARERMODE_VOICE ;

        linecallparams->dwMinRate = 56000 ;

        linecallparams->dwMaxRate = 56000 ;

        linecallparams->dwMediaMode = LINEMEDIAMODE_UNKNOWN ;
    }
    else
    {  // default
        linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;

        linecallparams->dwMinRate = 64000 ;

        linecallparams->dwMaxRate = 64000 ;

        linecallparams->dwMediaMode = LINEMEDIAMODE_DIGITALDATA ;
    }

    if (hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX][0] != '\0')
    {
        numchannels = (USHORT)atoi(hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX]) ;
    }
    else
    {
        numchannels = 1 ; // default
    }

    if (hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX] != '\0')
    {
        fallback = (USHORT)atoi(hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX]) ;
    }
    else
    {
        fallback = 1 ;    // default
    }

    if (fallback)
    {
        //
        // always allow the min
        //
        linecallparams->dwMinRate = 56000 ;
    }
    else
    {
        linecallparams->dwMinRate =
                numchannels * linecallparams->dwMaxRate ;
    }

    linecallparams->dwMaxRate =
            numchannels * linecallparams->dwMaxRate ;

}

VOID
SetModemParams(
        TapiPortControlBlock *hIOPort,
        LINECALLPARAMS *linecallparams
        )
{
    WORD    numchannels ;
    WORD    fallback ;
    BYTE    buffer[800] ;
    LINEDEVCAPS     *linedevcaps ;

    memset (buffer, 0, sizeof(buffer)) ;

    linedevcaps = (LINEDEVCAPS *)buffer ;
    linedevcaps->dwTotalSize = sizeof(buffer) ;

    //
    // Get a count of all addresses across all lines
    //
    if (lineGetDevCaps (RasLine,
                        hIOPort->TPCB_Line->TLI_LineId,
                        hIOPort->TPCB_Line->NegotiatedApiVersion,
                        hIOPort->TPCB_Line->NegotiatedExtVersion,
                        linedevcaps))
    {
        linecallparams->dwBearerMode = LINEBEARERMODE_VOICE;
    }

    if (linedevcaps->dwBearerModes & LINEBEARERMODE_VOICE)
    {
        linecallparams->dwBearerMode = LINEBEARERMODE_VOICE ;
    }
    else
    {
        linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;
    }

    //
    // do not dial without dialtone
    //
    linecallparams->dwCallParamFlags |= LINECALLPARAMFLAGS_IDLE ;

    linecallparams->dwMinRate = 2400 ;

    linecallparams->dwMaxRate = 115200 ;

    linecallparams->dwMediaMode = LINEMEDIAMODE_DATAMODEM ;
}

VOID
SetAtmParams (
    TapiPortControlBlock *hIOPort,
    LINECALLPARAMS *linecallparams
    )
{
    linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;

    //
    // Tell ATM to use the default rates of the underlying
    // miniport adapter.
    //
    linecallparams->dwMinRate = 0;
    linecallparams->dwMaxRate = 0;

    linecallparams->dwMediaMode = LINEMEDIAMODE_DIGITALDATA ;
}

VOID
SetGenericParams (
                TapiPortControlBlock *hIOPort,
                LINECALLPARAMS *linecallparams
                )
{
    linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;

    linecallparams->dwMinRate = 64000;

    linecallparams->dwMaxRate = 10000000;

    linecallparams->dwMediaMode = LINEMEDIAMODE_DIGITALDATA ;
}

VOID
SetX25Params(TapiPortControlBlock *hIOPort,
             LINECALLPARAMS *linecallparams)
{
    BYTE    buffer[800] ;
    LINEDEVCAPS     *linedevcaps ;

    memset (buffer, 0, sizeof(buffer)) ;

    linedevcaps = (LINEDEVCAPS *)buffer ;
    linedevcaps->dwTotalSize = sizeof(buffer) ;

    //
    // Get a count of all addresses across all lines
    //
    if (lineGetDevCaps (RasLine,
                        hIOPort->TPCB_Line->TLI_LineId,
                        hIOPort->TPCB_Line->NegotiatedApiVersion,
                        hIOPort->TPCB_Line->NegotiatedExtVersion,
                        linedevcaps))
    {

        //
        // go for the gold!!!
        //
        linecallparams->dwMaxRate = 0xFFFFFFFF;

        linecallparams->dwMediaMode = LINEMEDIAMODE_UNKNOWN;

    } else
    {
        linecallparams->dwMaxRate = linedevcaps->dwMaxRate;

        if (linedevcaps->dwMediaModes & LINEMEDIAMODE_DIGITALDATA)
        {
            linecallparams->dwMediaMode = LINEMEDIAMODE_DIGITALDATA;

        }
        else if (linedevcaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM)
        {
            linecallparams->dwMediaMode = LINEMEDIAMODE_DATAMODEM;
        }
        else
        {
            linecallparams->dwMediaMode = LINEMEDIAMODE_UNKNOWN;
        }
    }
}

/*++

Routine Description:

    Initiates the process of listening for a remote device
    to connect to a local device.

Arguments:

Return Value:

    Return codes from ConnectListen

--*/
DWORD APIENTRY
DeviceListen(HANDLE hPort,
             char   *pszDeviceType,
             char   *pszDeviceName)
{
    DWORD retcode ;
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
    {
        RasTapiTrace ("DeviceListen: hPort "
                      "= 0x%x not found",
                      hPort );

        return ERROR_PORT_NOT_FOUND ;
    }

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    RasTapiTrace("DeviceListen: %s. State = %d",
                 hIOPort->TPCB_Name,
                 hIOPort->TPCB_State );

    //
    // If the state is DISCONNECTING (this could happen
    // since rasman waits only 10 seconds for the lower
    // layers to complete a disconnect request), then
    // we have no option but to close and open the line.
    //
    if (hIOPort->TPCB_State == PS_DISCONNECTING &&
        !hIOPort->TPCB_Line->TLI_MultiEndpoint)
    {

        RasTapiTrace ("DeviceListen: Hammering LineClosed!");

        lineClose (hIOPort->TPCB_Line->TLI_LineHandle) ;

        Sleep (30L) ;

        retcode = lineOpen (RasLine,
                      hIOPort->TPCB_Line->TLI_LineId,
                      &hIOPort->TPCB_Line->TLI_LineHandle,
                      hIOPort->TPCB_Line->NegotiatedApiVersion,
                      hIOPort->TPCB_Line->NegotiatedExtVersion,
                      (DWORD_PTR) hIOPort->TPCB_Line,
                      LINECALLPRIVILEGE_OWNER,
                      hIOPort->TPCB_Line->TLI_MediaMode,
                      NULL) ;

        if (retcode)
        {

            RasTapiTrace ("DeviceListen: %s. lineOpen"
                          " failed. 0x%x",
                          hIOPort->TPCB_Name,
                          retcode );

            // **** Exclusion End ****
            FreeMutex (RasTapiMutex) ;

            RasTapiTrace(" ");

            return ERROR_FROM_DEVICE ;
        }

        //
        // Set monitoring of rings
        //
        retcode = lineSetStatusMessages(
                            hIOPort->TPCB_Line->TLI_LineHandle,
                            LINEDEVSTATE_RINGING, 0) ;

        if (retcode)
        {
            RasTapiTrace("DeviceListen: %s. Failed"
                         " to post listen. %d",
                         hIOPort->TPCB_Name,
                         retcode );
        }
    }

    if (hIOPort->TPCB_Line->TLI_LineState != PS_LISTENING)
    {
        hIOPort->TPCB_Line->TLI_LineState = PS_LISTENING ;
    }

    RasTapiTrace ("DeviceListen: Changing State"
                  " for %s from %d -> %d",
                  hIOPort->TPCB_Name,
                  hIOPort->TPCB_State,
                  PS_LISTENING );

    hIOPort->TPCB_State = PS_LISTENING ;

    RasTapiTrace ("DeviceListen: Changing Listen"
                  " State for %s from %d -> %d",
                  hIOPort->TPCB_Name,
                  hIOPort->TPCB_ListenState,
                  PS_LISTENING );

    hIOPort->TPCB_ListenState = LS_WAIT ;

    hIOPort->TPCB_DisconnectReason = 0 ;

    hIOPort->TPCB_CallHandle = -1 ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

    RasTapiTrace(" ");
    return (PENDING);
}

/*++

Routine Description:

    Informs the device dll that the attempt to connect or listen
    has completed.

Arguments:

Return Value:

    nothing

--*/
VOID APIENTRY
DeviceDone(HANDLE hPort)
{
#ifdef notdef
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
        return ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;
#endif
}

/*++

Routine Description:

    This function is called following DeviceConnect or
    DeviceListen to further the asynchronous process of
    connecting or listening.

Arguments:

Return Value:

    ERROR_DCB_NOT_FOUND
    ERROR_STATE_MACHINES_NOT_STARTED
    Return codes from DeviceStateMachine

--*/
DWORD APIENTRY
DeviceWork(HANDLE hPort)
{
    LINECALLSTATUS *callstatus ;
    BYTE       buffer [1000] ;
    DWORD      retcode = ERROR_FROM_DEVICE ;
    TapiPortControlBlock *hIOPort =
                            LookUpControlBlock(hPort);

    if (!hIOPort)
    {
        RasTapiTrace("DeviceWork: port 0x%x not found",
                     hPort );

        return ERROR_PORT_NOT_FOUND ;
    }

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    memset (buffer, 0, sizeof(buffer)) ;

    callstatus = (LINECALLSTATUS *)buffer ;
    callstatus->dwTotalSize = sizeof(buffer) ;

    RasTapiTrace ("DeviceWork: %s. State = %d",
                  hIOPort->TPCB_Name,
                  hIOPort->TPCB_State );

    if (hIOPort->TPCB_State == PS_CONNECTING)
    {
        if (hIOPort->TPCB_AsyncErrorCode != SUCCESS)
        {

            retcode = hIOPort->TPCB_AsyncErrorCode ;
            hIOPort->TPCB_AsyncErrorCode = SUCCESS ;

        }
        else if (lineGetCallStatus (hIOPort->TPCB_CallHandle,
                                    callstatus))
        {
            RasTapiTrace( "DeviceWork: lineGetCallStatus failed");

            retcode =  ERROR_FROM_DEVICE ;
        }
        else if (callstatus->dwCallState ==
                    LINECALLSTATE_CONNECTED)
        {
            RasTapiTrace("DeviceWork: Changing state"
                         " for %s from %d -> %d",
                         hIOPort->TPCB_Name,
                         hIOPort->TPCB_State,
                         PS_CONNECTED );

            hIOPort->TPCB_State = PS_CONNECTED ;

            retcode =  SUCCESS ;

        }
        else if (callstatus->dwCallState ==
                        LINECALLSTATE_DISCONNECTED)
        {
            retcode = ERROR_FROM_DEVICE ;

            /*
            if (callstatus->dwCallStateMode ==
                        LINEDISCONNECTMODE_BUSY)
            {
                retcode = ERROR_LINE_BUSY ;
            }
            else if (   (callstatus->dwCallStateMode ==
                        LINEDISCONNECTMODE_NOANSWER)
                    ||  (callstatus->dwCallStateMode ==
                        LINEDISCONNECTMODE_OUTOFORDER))
            {
                retcode = ERROR_NO_ANSWER ;
            }
            else if (callstatus->dwCallStateMode ==
                        LINEDISCONNECTMODE_CANCELLED)
            {
                retcode = ERROR_USER_DISCONNECTION;
            }

            */

            retcode = DwRasErrorFromDisconnectMode(
                            callstatus->dwCallStateMode);

            RasTapiTrace("DeviceWork: callstate = 0x%x. "
                         "callmode = 0x%x, retcode %d",
                         callstatus->dwCallState,
                         callstatus->dwCallStateMode,
                         retcode );

        }
        else if (   (callstatus->dwCallState ==
                            LINECALLSTATE_SPECIALINFO)
                &&  (callstatus->dwCallStateMode ==
                            LINESPECIALINFO_NOCIRCUIT))
        {
            RasTapiTrace ("DeviceWork: ERROR_NO_ACTIVE_ISDN_LINES" );

            retcode = ERROR_NO_ACTIVE_ISDN_LINES ;
        }
    }

    if (hIOPort->TPCB_State == PS_LISTENING)
    {

        if (hIOPort->TPCB_ListenState == LS_ERROR)
        {
            RasTapiTrace ("DeviceWork: %s. ListenState = LS_ERROR",
                          hIOPort->TPCB_Name );

            retcode = ERROR_FROM_DEVICE ;
        }
        else if (hIOPort->TPCB_ListenState == LS_ACCEPT)
        {

            hIOPort->TPCB_RequestId =
                    lineAccept (hIOPort->TPCB_CallHandle, NULL, 0) ;

            RasTapiTrace( "DeviceWork: %s. lineAccept returned 0x%x",
                    hIOPort->TPCB_Name, hIOPort->TPCB_RequestId );

            if (hIOPort->TPCB_RequestId > 0x80000000)
            {
                RasTapiTrace("DeviceWork: changing Listen"
                             " state for %s from %d -> %d",
                             hIOPort->TPCB_Name,
                             hIOPort->TPCB_ListenState,
                             LS_ANSWER );

                hIOPort->TPCB_ListenState = LS_ANSWER ;
            }

            else if (hIOPort->TPCB_RequestId == 0)
            {

                RasTapiTrace("DeviceWork: changing Listen "
                             "state for %s from %d -> %d",
                             hIOPort->TPCB_Name,
                             hIOPort->TPCB_ListenState,
                             LS_ANSWER);

                hIOPort->TPCB_ListenState = LS_ANSWER ;
            }

            retcode = PENDING ;
        }

        if (hIOPort->TPCB_ListenState == LS_ANSWER)
        {

            hIOPort->TPCB_RequestId =
                    lineAnswer (hIOPort->TPCB_CallHandle, NULL, 0) ;

            RasTapiTrace("DeviceWork: %s. lineAnswer returned 0x%x",
                         hIOPort->TPCB_Name,
                         hIOPort->TPCB_RequestId );

            if (hIOPort->TPCB_RequestId > 0x80000000 )
            {
                RasTapiTrace("DeviceWork: lineAnswer returned "
                             "an error");

                retcode = ERROR_FROM_DEVICE ;
            }

            else if (hIOPort->TPCB_RequestId)
            {
                retcode = PENDING ;
            }
            else
            {
                RasTapiTrace("DeviceWork: Changing Listen "
                             "state for %s from %d -> %d",
                             hIOPort->TPCB_Name,
                             hIOPort->TPCB_ListenState,
                             LS_COMPLETE );

                hIOPort->TPCB_ListenState = LS_COMPLETE ;
            }
        }

        if (hIOPort->TPCB_ListenState == LS_COMPLETE)
        {

            if (hIOPort->TPCB_CallHandle == (-1))
            {
                retcode = ERROR_FROM_DEVICE ;
            }
            else
            {

                RasTapiTrace("DeviceWork: Changing State"
                             " for %s from %d -> %d",
                             hIOPort->TPCB_Name,
                             hIOPort->TPCB_State,
                             PS_CONNECTED );

                hIOPort->TPCB_State = PS_CONNECTED ;

                retcode = SUCCESS ;
            }
        }

    }

    //
    // If we have connected, then get the com port handle for
    // use in terminal modem i/o
    //
    if (hIOPort->TPCB_State == PS_CONNECTED)
    {

        VARSTRING   *varstring ;
        BYTE        buffer [100] ;

        //
        // get the cookie to realize tapi and ndis endpoints
        //
        varstring = (VARSTRING *) buffer ;
        varstring->dwTotalSize = sizeof(buffer) ;

        //
        // Unimodem/asyncmac linegetid returns a comm port handle.
        // Other medias give the endpoint itself back in linegetid
        // This has to do with the fact that modems/asyncmac are
        // not a miniport.
        //
        if (_stricmp (hIOPort->TPCB_DeviceType,
                DEVICETYPE_UNIMODEM) == 0)
        {

            if ( retcode =
                    lineGetID (hIOPort->TPCB_Line->TLI_LineHandle,
                               hIOPort->TPCB_AddressId,
                               hIOPort->TPCB_CallHandle,
                               LINECALLSELECT_CALL,
                               varstring,
                               "comm/datamodem"))
            {
                RasTapiTrace("DeviceWork: %s lineGetID Failed. 0x%x",
                        hIOPort->TPCB_Name, retcode );

                // **** Exclusion End ****
                FreeMutex (RasTapiMutex) ;
                RasTapiTrace(" ");

                return ERROR_FROM_DEVICE ;
            }

            hIOPort->TPCB_CommHandle =
                (HANDLE) UlongToPtr((*((DWORD UNALIGNED *)
                ((BYTE *)varstring+varstring->dwStringOffset)))) ;

            RasTapiTrace("DeviceWork: TPCB_CommHandle=%d",
                          hIOPort->TPCB_CommHandle );
                          
            //
            // Create the I/O completion port for
            // asynchronous operation completion
            // notificiations.
            //
            if (CreateIoCompletionPort(
                  hIOPort->TPCB_CommHandle,
                  hIOPort->TPCB_IoCompletionPort,
                  hIOPort->TPCB_CompletionKey,
                  0) == NULL)
            {
                retcode = GetLastError();

                RasTapiTrace("DeviceWork: %s. CreateIoCompletionPort "
                             "failed. %d",
                             hIOPort->TPCB_Name,
                             retcode );

                FreeMutex(RasTapiMutex);
                RasTapiTrace(" ");

                return retcode;
            }
            
            //
            // Initialize the port for approp. buffers
            //
            SetupComm (hIOPort->TPCB_CommHandle, 1514, 1514) ;

        }
#if 0

        else
        {

            if ( retcode = lineGetID (hIOPort->TPCB_Line->TLI_LineHandle,
                                       hIOPort->TPCB_AddressId,
                                       hIOPort->TPCB_CallHandle,
                                       LINECALLSELECT_CALL,
                                       varstring,
                                       "NDIS"))
            {
                RasTapiTrace ("DeviceWork: %s. lineGetId Failed. 0x%x",
                              hIOPort->TPCB_Name,
                              retcode );

                // **** Exclusion End ****
                FreeMutex (RasTapiMutex) ;

                RasTapiTrace(" ");

                return ERROR_FROM_DEVICE ;
            }

            hIOPort->TPCB_Endpoint =
                *((HANDLE UNALIGNED *) ((BYTE *)varstring+varstring->dwStringOffset)) ;
        }
#endif        
    }

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;
    return(retcode);
}

/*++

Routine Description:

    Called to set an opaque blob of
    data to configure a device.

Arguments:

Return Value:

    LocalAlloc returned values.

--*/
DWORD
DeviceSetDevConfig (
            HANDLE hPort,
            PBYTE devconfig,
            DWORD sizeofdevconfig
            )
{
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
    {
        RasTapiTrace("DeviceSetDevConfig: port"
                     " 0x%x not found",
                     hPort );

        return ERROR_PORT_NOT_FOUND ;
    }

    if (_stricmp (hIOPort->TPCB_DeviceType,
                  DEVICETYPE_UNIMODEM))
    {
        return SUCCESS ;
    }

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (hIOPort->TPCB_DevConfig != NULL)
    {
        LocalFree (hIOPort->TPCB_DevConfig) ;
    }

    if ((hIOPort->TPCB_DevConfig =
            LocalAlloc(LPTR, sizeofdevconfig)) == NULL)
    {

        // **** Exclusion End ****
        FreeMutex (RasTapiMutex) ;
        return(GetLastError());
    }

    memcpy (hIOPort->TPCB_DevConfig,
            devconfig,
            sizeofdevconfig) ;

    hIOPort->TPCB_SizeOfDevConfig = sizeofdevconfig ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;
    return (SUCCESS);
}

DWORD
DwGetConfigInfoForDeviceClass(
            DWORD LineId,
            CHAR  *pszDeviceClass,
            LPVARSTRING *ppVar)
{
    LPVARSTRING var = NULL;
    LONG lr;
    DWORD dwNeededSize;

    //
    // Make var string
    //
    var = (LPVARSTRING)LocalAlloc(LPTR, 2000) ;

    if(NULL == var)
    {
        lr = (LONG) GetLastError();
        goto done;
    }

    var->dwTotalSize  = 2000 ;

    if(     (ERROR_SUCCESS != (lr = lineGetDevConfig (
                                            LineId,
                                            var,
                                            pszDeviceClass)))
        &&  (LINEERR_STRUCTURETOOSMALL != lr))
    {
        goto done;
    }

    if(var->dwNeededSize > 2000)
    {
        dwNeededSize = var->dwNeededSize;

        LocalFree(var);

        var = (LPVARSTRING) LocalAlloc(LPTR, dwNeededSize);

        if(NULL == var)
        {
            lr = (LONG) GetLastError();
            goto done;
        }

        var->dwTotalSize = dwNeededSize;

        lr = lineGetDevConfig(
                            LineId,
                            var,
                            pszDeviceClass);
    }

done:

    if(ERROR_SUCCESS != lr)
    {
        LocalFree(var);
        var = NULL;
    }

    *ppVar = var;

    return ((DWORD) lr);
}


DWORD
DwGetDevConfig(
        DWORD LineId,
        PBYTE pBuffer,
        DWORD *pcbSize,
        BOOL   fDialIn)
{
    DWORD           dwSize;
    DWORD           dwErr           = ERROR_SUCCESS;
    BYTE            buffer[2000];
    LPVARSTRING     varModem        = NULL,
                    varExtendedCaps = NULL;

    if(NULL == pcbSize)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    dwSize = *pcbSize;

    *pcbSize = 0;

    if(fDialIn)
    {
        dwErr = DwGetConfigInfoForDeviceClass(
                           LineId,
                           "comm/datamodem/dialin",
                           &varModem);
    
    }
    else 
    {
        dwErr = DwGetConfigInfoForDeviceClass(
                           LineId,
                           "comm/datamodem",
                           &varModem);
    }                           

    if(ERROR_SUCCESS != dwErr)
    {
        RasTapiTrace("DwGetDevConfig returned error=0x%x",
                      dwErr);

        goto done;
    }

    dwErr = DwGetConfigInfoForDeviceClass(
                           LineId,
                           "comm/extendedcaps",
                           &varExtendedCaps);

    if(ERROR_SUCCESS != dwErr)
    {
        /*
        RasTapiTrace("DwGetDevConfig returned error=0x%x",
                     dwErr);
        */                     

        //
        // Ignore the error
        //
        dwErr = ERROR_SUCCESS;
    }

    *pcbSize = sizeof(RAS_DEVCONFIG)
             + varModem->dwStringSize
             + ((NULL != varExtendedCaps)
             ? varExtendedCaps->dwStringSize
             : 0);
             
    if(dwSize >= *pcbSize)
    {
        RAS_DEVCONFIG *pConfig = (RAS_DEVCONFIG *) pBuffer;

        pConfig->dwOffsetofModemSettings =
                    FIELD_OFFSET(RAS_DEVCONFIG, abInfo);

        pConfig->dwSizeofModemSettings = varModem->dwStringSize;

        memcpy(pConfig->abInfo,
               (PBYTE) ((BYTE *) varModem) + varModem->dwStringOffset,
               pConfig->dwSizeofModemSettings);

        if(NULL != varExtendedCaps)
        {
            pConfig->dwOffsetofExtendedCaps =
                    pConfig->dwOffsetofModemSettings
                  + pConfig->dwSizeofModemSettings;

            pConfig->dwSizeofExtendedCaps =
                    varExtendedCaps->dwStringSize;

            memcpy(pConfig->abInfo + pConfig->dwSizeofModemSettings,
                   (PBYTE) ((PBYTE) varExtendedCaps)
                            + varExtendedCaps->dwStringOffset,
                   pConfig->dwSizeofExtendedCaps);
        }
        else
        {
            pConfig->dwOffsetofExtendedCaps = 0;
            pConfig->dwSizeofExtendedCaps = 0;
        }
    }
    else
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

done:
    if(NULL != varModem)
    {
        LocalFree(varModem);
    }

    if(NULL != varExtendedCaps)
    {
        LocalFree(varExtendedCaps);
    }

    return dwErr;
}
/*++

Routine Description:

    Called to set an opaque blob of
    data to configure a device.

Arguments:

Return Value:

    LocalAlloc returned values.

--*/
DWORD
DwDeviceGetDevConfig (
            char *name,
            PBYTE devconfig,
            DWORD *sizeofdevconfig,
            BOOL fDialIn
            )
{
    TapiPortControlBlock *hIOPort = RasPortsList;
    DWORD i ;
    BYTE buffer[2000] ;
    LPVARSTRING var ;
    PBYTE configptr ;
    DWORD configsize ;
    DWORD retcode = SUCCESS;

    while ( hIOPort )
    {
        if (!_stricmp(hIOPort->TPCB_Name, name))
        {
            break ;
        }

        hIOPort = hIOPort->TPCB_next;
    }

    if (!hIOPort)
    {

        RasTapiTrace("DeviceGetDevConfig: port"
                     " %s not found",
                     name );

        RasTapiTrace(" ");

        return ERROR_PORT_NOT_FOUND ;
    }

    if (_stricmp (hIOPort->TPCB_DeviceType,
                  DEVICETYPE_UNIMODEM))
    {
        *sizeofdevconfig = 0 ;

        return SUCCESS ;
    }

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (hIOPort->TPCB_DevConfig != NULL)
    {

        configptr  = hIOPort->TPCB_DevConfig ;
        configsize = hIOPort->TPCB_SizeOfDevConfig ;

    }
    else
    {
        retcode = DwGetDevConfig(
                            hIOPort->TPCB_Line->TLI_LineId,
                            devconfig,
                            sizeofdevconfig,
                            fDialIn);

        goto done;
    }

    if (*sizeofdevconfig >= configsize)
    {
        memcpy (devconfig, configptr, configsize) ;

        retcode = SUCCESS ;
    }
    else
    {
        retcode = ERROR_BUFFER_TOO_SMALL ;
    }

    *sizeofdevconfig = configsize ;

done:

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

    return (retcode);
}

DWORD
DeviceGetDevConfig(
            char *name,
            PBYTE devconfig,
            DWORD *sizeofdevconfig)
{
    return DwDeviceGetDevConfig (
                name, devconfig,
                sizeofdevconfig, FALSE);

}

DWORD
DeviceGetDevConfigEx(
            char *name,
            PBYTE devconfig,
            DWORD *sizeofdevconfig)
{
    return DwDeviceGetDevConfig (
                name, devconfig,
                sizeofdevconfig, TRUE);
}


DWORD
RastapiGetCalledID(PBYTE                pbAdapter,
                   BOOL                 fModem,
                   RAS_CALLEDID_INFO    *pCalledID,
                   DWORD                *pdwSize)
{
    DWORD       retcode = ERROR_SUCCESS;
    DeviceInfo  *pInfo = NULL;
    DWORD       dwSize;

    RasTapiTrace("RastapiGetCalledID..");

    if(NULL == pdwSize)
    {
        retcode = E_INVALIDARG;
        goto done;
    }

    dwSize = *pdwSize;

    GetMutex(RasTapiMutex, INFINITE);

    pInfo = GetDeviceInfo(pbAdapter,
                          fModem);

    if(NULL == pInfo)
    {
        retcode = E_FAIL;
        goto done;
    }

    /*
    if(NULL != pInfo->pCalledID)
    {
        LocalFree(pInfo->pCalledID);
        pInfo->pCalledID = NULL;
    }

    retcode = DwGetCalledIdInfo(NULL,
                                pInfo);

    if(ERROR_SUCCESS != retcode)
    {
        goto done;
    }
    */

    if(NULL == pInfo->pCalledID)
    {
        retcode = E_FAIL;
        goto done;
    }

    *pdwSize = sizeof(RAS_CALLEDID_INFO) +
               pInfo->pCalledID->dwSize;

    if(     (NULL != pCalledID)
        &&  (*pdwSize <= dwSize))
    {
        memcpy(pCalledID,
               pInfo->pCalledID,
               *pdwSize);
    }

done:

    FreeMutex(RasTapiMutex);

    RasTapiTrace("RastapiGetCalledID. 0x%x",
                retcode);

    return retcode;
}

DWORD
RastapiSetCalledID(PBYTE              pbAdapter,
                   BOOL               fModem,
                   RAS_CALLEDID_INFO *pCalledID,
                   BOOL               fWrite)
{
    DWORD retcode = ERROR_SUCCESS;
    DeviceInfo *pInfo = NULL;

    RasTapiTrace("RastapiSetCalledID..");

    if(NULL == pCalledID)
    {
        retcode = E_INVALIDARG;
        goto done;
    }

    GetMutex(RasTapiMutex, INFINITE);

    pInfo = GetDeviceInfo(pbAdapter,
                          fModem);

    if(NULL == pInfo)
    {
        retcode = E_FAIL;
        goto done;
    }

    if(NULL != pInfo->pCalledID)
    {
        LocalFree(pInfo->pCalledID);
        pInfo->pCalledID = NULL;
    }

    pInfo->pCalledID = LocalAlloc(LPTR,
                        sizeof(RAS_CALLEDID_INFO)
                       + pCalledID->dwSize);

    if(NULL == pInfo->pCalledID)
    {
        retcode = GetLastError();
        goto done;
    }

    memcpy(pInfo->pCalledID->bCalledId,
           pCalledID->bCalledId,
           pCalledID->dwSize);

    pInfo->pCalledID->dwSize = pCalledID->dwSize;

    if(fWrite)
    {

        retcode = DwSetCalledIdInfo(NULL,
                                    pInfo);

        if(ERROR_SUCCESS != retcode)
        {
            goto done;
        }
    }

done:

    FreeMutex(RasTapiMutex);

    RasTapiTrace("RastapiSetCalledID. 0x%x",
                retcode);

    return retcode;
}


/*++

Routine Description:

    Notification that the number of
    pptp endpoints changed

Arguments:

Return Value:

--*/
DWORD
AddPorts( PBYTE pbGuidAdapter, PVOID pvReserved )
{
    DWORD       retcode;
    BOOL        fINetCfgInited  = FALSE;
    DeviceInfo *pDeviceInfo     = NULL;
    DeviceInfo *pNewDeviceInfo  = NULL;

    GetMutex( RasTapiMutex, INFINITE );

    RasTapiTrace("AddPorts");

    //
    // Get Current DeviceInfo
    //
    pDeviceInfo = GetDeviceInfo(pbGuidAdapter, FALSE);

    RasTapiTrace("OldInfo");

    TraceEndPointInfo(pDeviceInfo);

#if DBG
    ASSERT( NULL != pDeviceInfo );
#endif

    RasTapiTrace("AddPorts: Old: NumEndPoints=%d",
                pDeviceInfo->rdiDeviceInfo.dwNumEndPoints );

    retcode = GetEndPointInfo(&pNewDeviceInfo,
                              pbGuidAdapter,
                              TRUE,
                              0);

    if ( retcode )
    {

        RasTapiTrace("AddPorts: Failed to get enpoint "
                    "info from retistry");

        goto error;
    }

    pNewDeviceInfo->rdiDeviceInfo.eDeviceType = 
        pDeviceInfo->rdiDeviceInfo.eDeviceType;

    RasTapiTrace("NewInfo");

    TraceEndPointInfo(pNewDeviceInfo);

    //
    // Assign the new Number of endpoints to
    // the deviceinfo in the global list
    //
    pDeviceInfo->rdiDeviceInfo.dwNumEndPoints =
            pNewDeviceInfo->rdiDeviceInfo.dwNumEndPoints;

    //
    // Reset the current endpoints to 0 for
    // this adapter since we are again going
    // to enumerate all the lines.
    //
    pDeviceInfo->dwCurrentEndPoints = 0;

    LocalFree (pNewDeviceInfo);

    RasTapiTrace("AddPorts: New: NumEndPoints=%d",
              pDeviceInfo->rdiDeviceInfo.dwNumEndPoints );

    retcode = dwAddPorts( pbGuidAdapter, pvReserved );

    //
    // At this point the currentendpoints should also
    // be the Numendpoints. Make it so if its not the
    // case - since otherwise we will get out of ssync.
    //
    if(pDeviceInfo->rdiDeviceInfo.dwNumEndPoints !=
        pDeviceInfo->dwCurrentEndPoints)
    {
        RasTapiTrace(
            "AddPorts: NEP==%d != CEP==%d",
            pDeviceInfo->rdiDeviceInfo.dwNumEndPoints,
            pDeviceInfo->dwCurrentEndPoints);

        pDeviceInfo->rdiDeviceInfo.dwNumEndPoints =
            pDeviceInfo->dwCurrentEndPoints;
    }

    if(pvReserved != NULL)
    {
        *((ULONG *) pvReserved) =
            pDeviceInfo->rdiDeviceInfo.dwNumEndPoints;
    }

error:
    FreeMutex ( RasTapiMutex );

    RasTapiTrace(" ");

    return retcode;

}

DWORD
RemovePort (
        CHAR *pszPortName,
        BOOL fRemovePort,
        PBYTE pbGuidAdapter
        )
{
    TapiPortControlBlock *pport         = RasPortsList;
    DWORD                dwRetCode      = SUCCESS;
    DeviceInfo           *pDeviceInfo   = NULL;
    TapiPortControlBlock *pportT        = NULL;

    GetMutex ( RasTapiMutex, INFINITE );

    RasTapiTrace("RemovePort: %s", pszPortName );

    /*
    pDeviceInfo = GetDeviceInfo(pbGuidAdapter, FALSE);

    if ( 0 == pDeviceInfo->rdiDeviceInfo.dwNumEndPoints )
    {
        RasTapiTrace("RemovePort: No ports to remove. %s",
                     pszPortName );

        goto done;
    } */

    while ( pport )
    {
        if ( 0 == _stricmp (pszPortName, pport->TPCB_Name))
        {
            DeviceInfo *pDeviceInfo = pport->TPCB_Line->TLI_pDeviceInfo;

            pportT = pport;

            if(RDT_Modem !=
                RAS_DEVICE_TYPE(pDeviceInfo->rdiDeviceInfo.eDeviceType))
            {                
                break;
            }

            //
            // For modems continue to try to find a port which is marked
            // for removal - this is required since we can end up with 2
            // modems on the same com port and one of them is marked for
            // removal.
            //
            if(PS_UNAVAILABLE == pport->TPCB_State)
            {
                break;
            }            
        }

        pport = pport->TPCB_next;
    }

    pport = pportT;

    if ( NULL == pport )
    {

        RasTapiTrace ("RemovePort: port %s not found",
                      pszPortName );

        goto done;
    }

    pDeviceInfo = pport->TPCB_Line->TLI_pDeviceInfo;

    if ( fRemovePort )
    {
        RasTapiTrace("RemovePort: removing %s",
                     pport->TPCB_Name );

        dwRetCode = dwRemovePort ( pport );
    }
    else
    {
        RasTapiTrace ("RemovePort: Marking %s for removal",
                      pport->TPCB_Name );

        RasTapiTrace ("RemovePorT: Changing state"
                      " of %s from %d -> %d",
                      pport->TPCB_Name,
                      pport->TPCB_State,
                      PS_UNAVAILABLE );

        pport->TPCB_State = PS_UNAVAILABLE;

        pport->TPCB_dwFlags |= RASTAPI_FLAG_UNAVAILABLE;
    }

#if DBG

    ASSERT(pDeviceInfo->rdiDeviceInfo.dwNumEndPoints);
    ASSERT(pDeviceInfo->dwCurrentEndPoints);

    if(pDeviceInfo->rdiDeviceInfo.dwNumEndPoints == 0)
    {
        DbgPrint("RemovePort: pDeviceInfo->dwNumEndPoints==0!!!\n");
    }

    if(pDeviceInfo->dwCurrentEndPoints == 0)
    {
        DbgPrint("RemovePort: pDeviceInfo->dwCurrentEndPoints==0!!!\n");
    }

#endif

    if(pDeviceInfo->rdiDeviceInfo.dwNumEndPoints > 0)
    {
        pDeviceInfo->rdiDeviceInfo.dwNumEndPoints -= 1;
    }

    if(pDeviceInfo->dwCurrentEndPoints > 0)
    {
        pDeviceInfo->dwCurrentEndPoints -= 1;
    }

    RasTapiTrace("RemovePort. dwnumEndPoints for port = %d",
        pDeviceInfo->rdiDeviceInfo.dwNumEndPoints);

done:

    FreeMutex ( RasTapiMutex );

    RasTapiTrace(" ");
    return dwRetCode;
}

DWORD
EnableDeviceForDialIn(DeviceInfo *pDeviceInfo,
                      BOOL fEnable,
                      BOOL fEnableRouter,
                      BOOL fEnableOutboundRouter)
{
    DWORD                   dwRetCode   = SUCCESS;
    TapiPortControlBlock    *pport      = RasPortsList;
    DeviceInfo              *pInfo;
    BOOL                    fModem =
                        ((RDT_Modem ==
                        RAS_DEVICE_TYPE(
                        pDeviceInfo->rdiDeviceInfo.eDeviceType))
                        ? TRUE
                        : FALSE);

    GetMutex(RasTapiMutex, INFINITE);

#if DBG
    ASSERT(pDeviceInfo);
#endif

    if(NULL == pDeviceInfo)
    {
        goto done;
    }


    RasTapiTrace("EnableDeviceForDialIn: fEnable=%d, "
                 "fEnableRouter=%d, fEnableOutboundRouter=%d, "
                 "device=%s",
                 (UINT) fEnable,
                 (UINT) fEnableRouter,
                 (UINT) fEnableOutboundRouter,
                 pDeviceInfo->rdiDeviceInfo.szDeviceName);
    //
    // Run through the list of ports and change the usage of ports
    // on this device.
    //
    while (pport)
    {
        if(fModem)
        {
            if(_stricmp(pport->TPCB_DeviceName,
                     pDeviceInfo->rdiDeviceInfo.szDeviceName))
            {
                pport = pport->TPCB_next;
                continue;
            }
        }
        else
        {
            pInfo = pport->TPCB_Line->TLI_pDeviceInfo;

            if(memcmp(&pInfo->rdiDeviceInfo.guidDevice,
                      &pDeviceInfo->rdiDeviceInfo.guidDevice,
                      sizeof(GUID)))
            {
                pport = pport->TPCB_next;
                continue;
            }
        }

        pInfo = pport->TPCB_Line->TLI_pDeviceInfo;

        pInfo->rdiDeviceInfo.fRasEnabled = fEnable;

        pInfo->rdiDeviceInfo.fRouterEnabled = fEnableRouter;

        pInfo->rdiDeviceInfo.fRouterOutboundEnabled = fEnableOutboundRouter;

        if(fEnable)
        {
            RasTapiTrace("Enabling %s for dialin",
                         pport->TPCB_Name);

            pport->TPCB_Usage |= CALL_IN;
        }
        else
        {
            RasTapiTrace("Disabling %s for dialin",
                         pport->TPCB_Name);

            pport->TPCB_Usage &= ~CALL_IN;
        }

        if(fEnableRouter)
        {
            RasTapiTrace("Enabling %s for routing",
                         pport->TPCB_Name);
            pport->TPCB_Usage |= CALL_ROUTER;
        }
        else
        {
            RasTapiTrace("Disabling %s for routing",
                         pport->TPCB_Name);
            pport->TPCB_Usage &= ~CALL_ROUTER;
        }

        if(fEnableOutboundRouter)
        {
            RasTapiTrace("Enabling %s for outboundrouting",
                            pport->TPCB_Name);

            pport->TPCB_Usage &= ~(CALL_IN | CALL_ROUTER);
            pport->TPCB_Usage |= CALL_OUTBOUND_ROUTER;
        }

        pport = pport->TPCB_next;
    }

done:
    FreeMutex(RasTapiMutex);

    return dwRetCode;
}

DWORD
DwGetSizeofMbcs(
    WCHAR *pwszCalledId,
    DWORD *pdwSize)
{
    DWORD dwSize = 0;
    DWORD retcode = SUCCESS;

    *pdwSize = 0;

    while(*pwszCalledId != L'\0')
    {
        dwSize = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pwszCalledId,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);

        if(0 == dwSize)
        {
            retcode = GetLastError();
            goto done;
        }

        pwszCalledId += wcslen(pwszCalledId) + 1;

        *pdwSize += dwSize;
    }

    //
    // Include one char for trailing '\0'
    //

    *pdwSize += 1;

done:
    return retcode;
}

DWORD
DwFillCalledIDInfo(
    RAS_CALLEDID_INFO    *pCalledId,
    RASTAPI_CONNECT_INFO *pConnectInfo,
    DWORD                *pdwSize,
    DWORD                dwSizeAvailable)
{
    DWORD dwSize = 0;

    DWORD retcode = SUCCESS;

    WCHAR *pwszCalledId = NULL;

    CHAR  *pszCalledId = NULL;

    DWORD cchLen;

    ASSERT(NULL != pCalledId);

    pwszCalledId = (WCHAR *) pCalledId->bCalledId;

    //
    // Get size of mbcs string equivalent of
    // the unicode string
    //
    retcode = DwGetSizeofMbcs(
                    pwszCalledId,
                    &dwSize);

    if(SUCCESS != retcode)
    {
        goto done;
    }

    *pdwSize += dwSize;

    if(dwSizeAvailable < dwSize)
    {
        goto done;
    }

    pConnectInfo->dwAltCalledIdOffset =
                  FIELD_OFFSET(RASTAPI_CONNECT_INFO, abdata)
                + RASMAN_ALIGN8(pConnectInfo->dwCallerIdSize)
                + RASMAN_ALIGN8(pConnectInfo->dwCalledIdSize)
                + RASMAN_ALIGN8(pConnectInfo->dwConnectResponseSize);

    pConnectInfo->dwAltCalledIdSize = dwSize;


    pszCalledId = (CHAR *)
                  ((LPBYTE)
                   pConnectInfo
                 + pConnectInfo->dwAltCalledIdOffset);

    //
    // Make the conversion from wchar to char
    //
    while(*pwszCalledId != L'\0')
    {
        if (0 == (dwSize = WideCharToMultiByte (
                       CP_ACP,
                       0,
                       pwszCalledId,
                       -1,
                       pszCalledId,
                       dwSizeAvailable,
                       NULL,
                       NULL)))
        {
            retcode = GetLastError();
            goto done;
        }

        dwSizeAvailable -= dwSize;

        pwszCalledId += wcslen(pwszCalledId) + 1;

        pszCalledId = ((PBYTE) pszCalledId) + dwSize;

    }

    //
    // Append a NULL to make the string a multisz
    //
    *pszCalledId = '\0';

done:

    return retcode;
}

DWORD
GetConnectInfo(
    TapiPortControlBlock *hIOPort,
    PBYTE                pbDevice,
    BOOL                 fModem,
    RASTAPI_CONNECT_INFO *pInfo,
    DWORD                *pdwSize)
{
    DWORD retcode = SUCCESS;

    RASTAPI_CONNECT_INFO *pConnectInfo =
                            (NULL != hIOPort)
                            ? hIOPort->TPCB_pConnectInfo
                            : NULL;

    RAS_CALLEDID_INFO *pCalledId =
                  (NULL != hIOPort)
                ? hIOPort->TPCB_Line->TLI_pDeviceInfo->pCalledID
                : NULL;

    DWORD dwSize = 0;

    GetMutex ( RasTapiMutex, INFINITE );

    if(     (NULL != hIOPort)
      &&    (NULL == hIOPort->TPCB_pConnectInfo))
    {
        do
        {
            BYTE buffer[1000];
            LINECALLINFO *linecallinfo;

            RasTapiTrace(
                "GetConnectInfo: Getting connectinfo because"
                " info not available");
            
            
            memset (buffer, 0, sizeof(buffer)) ;

            linecallinfo = (LINECALLINFO *) buffer ;

            linecallinfo->dwTotalSize = sizeof(buffer) ;

            if ((retcode = lineGetCallInfo (
                                    hIOPort->TPCB_CallHandle,
                                    linecallinfo))
                                    > 0x80000000)
            {
                if(     (LINEERR_STRUCTURETOOSMALL == retcode)
                    ||  (linecallinfo->dwNeededSize > sizeof(buffer)))
                {
                    DWORD dwSizeNeeded =
                        linecallinfo->dwNeededSize;

                    //
                    // Allocate the correct size and call
                    // the api again
                    //
                    linecallinfo = LocalAlloc(LPTR,
                                              dwSizeNeeded);

                    if(NULL == linecallinfo)
                    {
                        retcode = GetLastError();
                        break;
                    }

                    linecallinfo->dwTotalSize = dwSizeNeeded;

                    retcode = lineGetCallInfo(
                                hIOPort->TPCB_CallHandle,
                                linecallinfo);

                }
            }

            if(retcode > 0x80000000)
            {

                RasTapiTrace("GetConnectInfo: LINE_CALLSTATE - "
                             "lineGetCallInfo Failed. %d",
                             retcode );

                if(buffer != (PBYTE) linecallinfo)
                {
                    LocalFree(linecallinfo);
                }

                break ;
            }

            //
            // Do the work to get CONNECTINFO, CALLER/CALLEDID
            //
            retcode = DwGetConnectInfo(hIOPort,
                                       hIOPort->TPCB_CallHandle,
                                       linecallinfo);

            RasTapiTrace("GetConnectInfo: DwGetConnectInfo"
                        "returned 0x%x",
                        retcode);


            //
            // don't want to stop the dial from happening
            // because we couldn't the connect info
            //
            retcode = SUCCESS;

            //
            // Free the linecallinfo struct. if we allocated
            // it above
            //
            if(buffer != (PBYTE) linecallinfo)
            {
                LocalFree(linecallinfo);
            }
        }
        while(FALSE);
    }
    
    pConnectInfo = (NULL != hIOPort)
                    ? hIOPort->TPCB_pConnectInfo
                    : NULL;

    if(     (NULL == pCalledId)
        &&  (NULL != pbDevice))
    {
        DeviceInfo * pDeviceInfo = NULL;

        pDeviceInfo = GetDeviceInfo(pbDevice, fModem);

        if(NULL != pDeviceInfo)
        {
            pCalledId = pDeviceInfo->pCalledID;
        }
    }

    if(NULL != pConnectInfo)
    {
        dwSize = sizeof(RASTAPI_CONNECT_INFO)
               + RASMAN_ALIGN8(pConnectInfo->dwCallerIdSize)
               + RASMAN_ALIGN8(pConnectInfo->dwCalledIdSize)
               + RASMAN_ALIGN8(pConnectInfo->dwConnectResponseSize);

        if(     (NULL != pInfo)
            &&  (*pdwSize >= dwSize))
        {

            memcpy((PBYTE) pInfo,
                   (PBYTE) pConnectInfo,
                   dwSize);
        }
    }

    //
    // Calculate the space required for the alternate
    // calledids - read from registry and adjust the
    // structure to return this information.
    //
    if(NULL != pCalledId)
    {
        DWORD dwSizeRemaining;

        if(0 == dwSize)
        {
            dwSize = sizeof(RASTAPI_CONNECT_INFO);
        }

        dwSizeRemaining =   (*pdwSize > dwSize)
                          ? (*pdwSize - dwSize)
                          : 0;

        retcode = DwFillCalledIDInfo(
                    pCalledId,
                    pInfo,
                    &dwSize,
                    dwSizeRemaining);
    }

    if(     (NULL == pConnectInfo)
        &&  (NULL == pCalledId))
    {
        retcode = E_FAIL;
    }

    *pdwSize = dwSize;

    FreeMutex(RasTapiMutex);

    return retcode;
}

DWORD
GetZeroDeviceInfo(DWORD *pcDevices,
                  DeviceInfo ***pppDeviceInfo)
{
    DeviceInfo *pDeviceInfo = g_pDeviceInfoList;
    DeviceInfo **ppDeviceInfo = NULL;
    DWORD       cDevices = 0;
    DWORD       retcode = SUCCESS;

    ASSERT(NULL != pcDevices);
    ASSERT(NULL != pppDeviceInfo);

    *pcDevices = 0;
    *pppDeviceInfo = NULL;

    while(NULL != pDeviceInfo)
    {
        if(     (pDeviceInfo->fValid)

            &&  (pDeviceInfo->rdiDeviceInfo.dwMinWanEndPoints
                != pDeviceInfo->rdiDeviceInfo.dwMaxWanEndPoints)

            &&  (0 == pDeviceInfo->rdiDeviceInfo.dwNumEndPoints))
        {
            cDevices += 1;
        }

        pDeviceInfo = pDeviceInfo->Next;
    }

    if(0 == cDevices)
    {
        goto done;
    }

    ppDeviceInfo = (DeviceInfo **) LocalAlloc(
                                LPTR,
                                cDevices
                                * sizeof(DeviceInfo *));

    cDevices = 0;

    if(NULL == ppDeviceInfo)
    {
        retcode = GetLastError();
        goto done;
    }

    pDeviceInfo = g_pDeviceInfoList;

    while(NULL != pDeviceInfo)
    {
        if(     (pDeviceInfo->fValid)

            &&  (pDeviceInfo->rdiDeviceInfo.dwMinWanEndPoints
                 != pDeviceInfo->rdiDeviceInfo.dwMaxWanEndPoints)

            &&  (0 == pDeviceInfo->rdiDeviceInfo.dwNumEndPoints))
        {
            ppDeviceInfo[cDevices] = pDeviceInfo;
            cDevices += 1;
        }

        pDeviceInfo = pDeviceInfo->Next;
    }

    *pppDeviceInfo = ppDeviceInfo;
    *pcDevices = cDevices;

done:

    RasTapiTrace("GetZeroDeviceInfo. rc=%d, cDevices=%d",
                 retcode,
                 cDevices);

    return retcode;
}

DWORD
GetInfo (
    TapiPortControlBlock *hIOPort,
    BYTE *pBuffer,
    DWORD *pdwSize
    )
{
    if (_stricmp (hIOPort->TPCB_DeviceType,
                  DEVICETYPE_ISDN) == 0)
    {
        GetIsdnParams (hIOPort, (RASMAN_PORTINFO *) pBuffer,
                       pdwSize) ;
    }
    else if (_stricmp (hIOPort->TPCB_DeviceType,
                       DEVICETYPE_X25) == 0)
    {
        GetX25Params (hIOPort, (RASMAN_PORTINFO *) pBuffer,
                      pdwSize) ;
    }
    else
    {
        GetGenericParams (hIOPort, (RASMAN_PORTINFO *) pBuffer,
                          pdwSize) ;
    }
    return SUCCESS ;
}

DWORD
SetInfo (
    TapiPortControlBlock *hIOPort,
    RASMAN_PORTINFO *pBuffer
    )
{

    if (_stricmp (hIOPort->TPCB_DeviceType,
                  DEVICETYPE_UNIMODEM) == 0)
    {
        FillInUnimodemParams (hIOPort, pBuffer) ;
    }
    else if (_stricmp (hIOPort->TPCB_DeviceType,
                       DEVICETYPE_ISDN) == 0)
    {
        FillInIsdnParams (hIOPort, pBuffer) ;
    }
    else if (_stricmp (hIOPort->TPCB_DeviceType,
                       DEVICETYPE_X25) == 0)
    {
        FillInX25Params (hIOPort, pBuffer) ;
    }
    else
    {
        FillInGenericParams (hIOPort, pBuffer) ;
    }

    return SUCCESS ;
}

/*++

Routine Description:

    We do more than fill in the params if the params are
    ones that are required to be set right then.

Arguments:

Return Value:

    ERROR_WRONG_INFO_SPECIFIED.
    Comm related Win32 errors
    SUCCESS.

--*/
DWORD
FillInUnimodemParams (
        TapiPortControlBlock *hIOPort,
        RASMAN_PORTINFO *pInfo
        )
{
    RAS_PARAMS *p;
    WORD    i;
    DWORD   index = 0xfefefefe ;
    DCB     DCB ;
#define INITIALIZED_VALUE  0xde
    BYTE    DCBByteSize = INITIALIZED_VALUE ;
    BYTE    DCBParity   = INITIALIZED_VALUE ;
    BYTE    DCBStopBits = INITIALIZED_VALUE ;
    BOOL    DCBProcessingRequired = FALSE ;

    for (i = 0, p = pInfo->PI_Params;
         i < pInfo->PI_NumOfParams;
         i++, p++)
    {

        if (_stricmp(p->P_Key, SER_DATABITS_KEY) == 0)
        {
            DCBByteSize = (BYTE) ValueToNum(p);
            DCBProcessingRequired = TRUE ;
        }
        else if (_stricmp(p->P_Key, SER_PARITY_KEY) == 0)
        {
            DCBParity = (BYTE) ValueToNum(p);
            DCBProcessingRequired = TRUE ;
        }
        else if (_stricmp(p->P_Key, SER_STOPBITS_KEY) == 0)
        {
            DCBStopBits = (BYTE) ValueToNum(p);
            DCBProcessingRequired = TRUE ;
        }

        //
        // The fact we use ISDN_PHONENUMBER_KEY is not a bug.
        // This is just a define.
        //
        else if (_stricmp(p->P_Key, ISDN_PHONENUMBER_KEY) == 0)
        {
            index = ADDRESS_INDEX ;
        }
        else if (_stricmp(p->P_Key, CONNECTBPS_KEY) == 0)
        {
            index = CONNECTBPS_INDEX ;
        }
        else
        {
            return(ERROR_WRONG_INFO_SPECIFIED);
        }

        if (index != 0xfefefefe)
        {
            strncpy (hIOPort->TPCB_Info[index],
                     p->P_Value.String.Data,
                     p->P_Value.String.Length);

            hIOPort->TPCB_Info[index][p->P_Value.String.Length] = '\0' ;
        }
    }


    //
    // For parameters that should be set right away - check that
    // the port handle is still valid
    // if so set the parameters.
    //
    if (    DCBProcessingRequired
        &&  hIOPort->TPCB_CommHandle != INVALID_HANDLE_VALUE)
    {

        //
        // Get a Device Control Block with current port values
        //
        if (!GetCommState(hIOPort->TPCB_CommHandle, &DCB))
        {
            return(GetLastError());
        }

        if (DCBByteSize != INITIALIZED_VALUE)
        {
            DCB.ByteSize = DCBByteSize ;
        }
        if (DCBParity   != INITIALIZED_VALUE)
        {
            DCB.Parity   = DCBParity ;
        }
        if (DCBStopBits != INITIALIZED_VALUE)
        {
            DCB.StopBits = DCBStopBits ;
        }

        //
        // Send DCB to Port
        //
        if (!SetCommState(hIOPort->TPCB_CommHandle, &DCB))
        {
            return(GetLastError());
        }
    }

    return SUCCESS ;
}

DWORD
FillInIsdnParams (
        TapiPortControlBlock *hIOPort,
        RASMAN_PORTINFO *pInfo
        )
{
    RAS_PARAMS *p;
    WORD    i;
    DWORD   index ;

    for (i = 0, p = pInfo->PI_Params;
         i < pInfo->PI_NumOfParams;
         i++, p++)
    {

        if (_stricmp(p->P_Key, ISDN_LINETYPE_KEY) == 0)
        {
            index = ISDN_LINETYPE_INDEX ;
        }
        else if (_stricmp(p->P_Key, ISDN_FALLBACK_KEY) == 0)
        {
            index = ISDN_FALLBACK_INDEX ;
        }
        else if (_stricmp(p->P_Key, ISDN_COMPRESSION_KEY) == 0)
        {
            index = ISDN_COMPRESSION_INDEX ;
        }
        else if (_stricmp(p->P_Key, ISDN_CHANNEL_AGG_KEY) == 0)
        {
            index = ISDN_CHANNEL_AGG_INDEX ;
        }
        else if (_stricmp(p->P_Key, ISDN_PHONENUMBER_KEY) == 0)
        {
            index = ADDRESS_INDEX ;
        }
        else if (_stricmp(p->P_Key, CONNECTBPS_KEY) == 0)
        {
            index = ISDN_CONNECTBPS_INDEX ;
        }
        else
        {
            return(ERROR_WRONG_INFO_SPECIFIED);
        }

        strncpy (hIOPort->TPCB_Info[index],
                 p->P_Value.String.Data,
                 p->P_Value.String.Length);

        hIOPort->TPCB_Info[index][p->P_Value.String.Length] = '\0' ;
    }

    //
    // initialize connectbps to a reasonable default
    //
    strcpy (hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX], "64000") ;

    return SUCCESS ;
}

DWORD
FillInX25Params (
            TapiPortControlBlock *hIOPort,
            RASMAN_PORTINFO *pInfo
            )
{
    RAS_PARAMS *p;
    WORD    i;
    DWORD   index ;

    for (i = 0, p = pInfo->PI_Params;
         i < pInfo->PI_NumOfParams;
         i++, p++)
    {

        if (_stricmp(p->P_Key, MXS_DIAGNOSTICS_KEY) == 0)
        {
            index = X25_DIAGNOSTICS_INDEX ;
        }

        else if (_stricmp(p->P_Key, MXS_USERDATA_KEY) == 0)
        {
            index = X25_USERDATA_INDEX ;
        }

        else if (_stricmp(p->P_Key, MXS_FACILITIES_KEY) == 0)
        {
            index = X25_FACILITIES_INDEX;
        }

        else if (_stricmp(p->P_Key, MXS_X25ADDRESS_KEY) == 0)
        {
            index = ADDRESS_INDEX ;
        }

        else if (_stricmp(p->P_Key, CONNECTBPS_KEY) == 0)
        {
            index = X25_CONNECTBPS_INDEX ;
        }
        else
        {
            return(ERROR_WRONG_INFO_SPECIFIED);
        }

        strncpy (hIOPort->TPCB_Info[index],
                 p->P_Value.String.Data,
                 p->P_Value.String.Length);

        hIOPort->TPCB_Info[index][p->P_Value.String.Length] = '\0';
    }

    //
    // initialize connectbps to a reasonable default
    //
    strcpy (hIOPort->TPCB_Info[X25_CONNECTBPS_INDEX], "9600") ;

    return SUCCESS ;
}

DWORD
FillInGenericParams (
    TapiPortControlBlock *hIOPort,
    RASMAN_PORTINFO *pInfo
    )
{
    RAS_PARAMS *p;
    WORD    i;
    DWORD   index ;

    for (i=0, p=pInfo->PI_Params; i<pInfo->PI_NumOfParams; i++, p++)
    {

        if (_stricmp(p->P_Key, ISDN_PHONENUMBER_KEY) == 0)
        {
            index = ADDRESS_INDEX ;
        }
        else if (_stricmp(p->P_Key, CONNECTBPS_KEY) == 0)
        {
            index = CONNECTBPS_INDEX ;
        }
        else
        {
            return(ERROR_WRONG_INFO_SPECIFIED);
        }

        strncpy (hIOPort->TPCB_Info[index],
                 p->P_Value.String.Data,
                 p->P_Value.String.Length);

        hIOPort->TPCB_Info[index][p->P_Value.String.Length] = '\0' ;
    }

    return SUCCESS ;
}

DWORD
GetGenericParams (
        TapiPortControlBlock *hIOPort,
        RASMAN_PORTINFO *pBuffer ,
        PDWORD pdwSize
        )
{
    RAS_PARAMS  *pParam;
    CHAR        *pValue;
    DWORD       dwAvailable ;
    DWORD       dwStructSize = sizeof(RASMAN_PORTINFO)
                               + sizeof(RAS_PARAMS) * 2;

    dwAvailable = *pdwSize;
    *pdwSize =    (dwStructSize
                   + strlen (hIOPort->TPCB_Info[ADDRESS_INDEX])
                   + strlen (hIOPort->TPCB_Info[CONNECTBPS_INDEX])
                   + 1L) ;

    if (*pdwSize > dwAvailable)
    {
        return(ERROR_BUFFER_TOO_SMALL);
    }

    ((RASMAN_PORTINFO *)pBuffer)->PI_NumOfParams = 2;

    pParam = ((RASMAN_PORTINFO *)pBuffer)->PI_Params;

    pValue = (CHAR*)pBuffer + dwStructSize;

    strcpy(pParam->P_Key, MXS_PHONENUMBER_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
            strlen (hIOPort->TPCB_Info[ADDRESS_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
           hIOPort->TPCB_Info[ADDRESS_INDEX]);

    pParam++;

    strcpy(pParam->P_Key, CONNECTBPS_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
            strlen (hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
           hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX]);

    return(SUCCESS);
}

DWORD
GetIsdnParams (
    TapiPortControlBlock *hIOPort,
    RASMAN_PORTINFO *pBuffer ,
    PDWORD pdwSize
    )
{
    RAS_PARAMS  *pParam;
    CHAR        *pValue;
    DWORD       dwAvailable ;
    DWORD       dwStructSize = sizeof(RASMAN_PORTINFO)
                               + sizeof(RAS_PARAMS) * 5;

    dwAvailable = *pdwSize;
    *pdwSize =    (dwStructSize
                   + strlen (hIOPort->TPCB_Info[ADDRESS_INDEX])
                   + strlen (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX])
                   + strlen (hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX])
                   + strlen (hIOPort->TPCB_Info[ISDN_COMPRESSION_INDEX])
                   + strlen (hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX])
                   + strlen (hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX])
                   + 1L) ;

    if (*pdwSize > dwAvailable)
    {
        return(ERROR_BUFFER_TOO_SMALL);
    }

    // Fill in Buffer

    ((RASMAN_PORTINFO *)pBuffer)->PI_NumOfParams = 6;

    pParam = ((RASMAN_PORTINFO *)pBuffer)->PI_Params;
    pValue = (CHAR*)pBuffer + dwStructSize;


    strcpy(pParam->P_Key, ISDN_PHONENUMBER_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
        strlen (hIOPort->TPCB_Info[ADDRESS_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
           hIOPort->TPCB_Info[ADDRESS_INDEX]);

    pValue += pParam->P_Value.String.Length + 1;

    pParam++;


    strcpy(pParam->P_Key, ISDN_LINETYPE_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
            strlen (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
           hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX]);

    pValue += pParam->P_Value.String.Length + 1;

    pParam++;

    strcpy(pParam->P_Key, ISDN_FALLBACK_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
            strlen (hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
           hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX]);

    pValue += pParam->P_Value.String.Length + 1;

    pParam++;

    strcpy(pParam->P_Key, ISDN_COMPRESSION_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
        strlen (hIOPort->TPCB_Info[ISDN_COMPRESSION_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
           hIOPort->TPCB_Info[ISDN_COMPRESSION_INDEX]);

    pValue += pParam->P_Value.String.Length + 1;

    pParam++;

    strcpy(pParam->P_Key, ISDN_CHANNEL_AGG_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
            strlen (hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
           hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX]);

    pValue += pParam->P_Value.String.Length + 1;

    pParam++;

    strcpy(pParam->P_Key, CONNECTBPS_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
        strlen (hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
           hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX]);


    return(SUCCESS);
}

DWORD
GetX25Params (
        TapiPortControlBlock *hIOPort,
        RASMAN_PORTINFO *pBuffer ,
        PDWORD pdwSize
        )
{
    RAS_PARAMS  *pParam;
    CHAR    *pValue;
    DWORD   dwAvailable ;

    DWORD dwStructSize = sizeof(RASMAN_PORTINFO)
                         + sizeof(RAS_PARAMS) * 4 ;

    dwAvailable = *pdwSize;

    *pdwSize =    (dwStructSize
                   + strlen (hIOPort->TPCB_Info[ADDRESS_INDEX])
                   + strlen (hIOPort->TPCB_Info[X25_DIAGNOSTICS_INDEX])
                   + strlen (hIOPort->TPCB_Info[X25_USERDATA_INDEX])
                   + strlen (hIOPort->TPCB_Info[X25_FACILITIES_INDEX])
                   + strlen (hIOPort->TPCB_Info[X25_CONNECTBPS_INDEX])
                   + 1L) ;

    if (*pdwSize > dwAvailable)
    {
        return(ERROR_BUFFER_TOO_SMALL);
    }

    // Fill in Buffer

    ((RASMAN_PORTINFO *)pBuffer)->PI_NumOfParams = 5 ;

    pParam = ((RASMAN_PORTINFO *)pBuffer)->PI_Params;

    pValue = (CHAR*)pBuffer + dwStructSize;

    strcpy(pParam->P_Key, MXS_X25ADDRESS_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
        strlen (hIOPort->TPCB_Info[ADDRESS_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
            hIOPort->TPCB_Info[ADDRESS_INDEX]);

    pValue += pParam->P_Value.String.Length + 1;

    pParam++;

    strcpy(pParam->P_Key, MXS_DIAGNOSTICS_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
            strlen (hIOPort->TPCB_Info[X25_DIAGNOSTICS_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
            hIOPort->TPCB_Info[X25_DIAGNOSTICS_INDEX]);

    pValue += pParam->P_Value.String.Length + 1;

    pParam++;

    strcpy(pParam->P_Key, MXS_USERDATA_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
            strlen (hIOPort->TPCB_Info[X25_USERDATA_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
            hIOPort->TPCB_Info[X25_USERDATA_INDEX]);

    pValue += pParam->P_Value.String.Length + 1;

    pParam++;

    strcpy(pParam->P_Key, MXS_FACILITIES_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
        strlen (hIOPort->TPCB_Info[X25_FACILITIES_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(pParam->P_Value.String.Data,
           hIOPort->TPCB_Info[X25_FACILITIES_INDEX]);

    pValue += pParam->P_Value.String.Length + 1;

    pParam++;

    strcpy(pParam->P_Key, CONNECTBPS_KEY);

    pParam->P_Type = String;

    pParam->P_Attributes = 0;

    pParam->P_Value.String.Length =
        strlen (hIOPort->TPCB_Info[X25_CONNECTBPS_INDEX]);

    pParam->P_Value.String.Data = pValue;

    strcpy(
        pParam->P_Value.String.Data,
        hIOPort->TPCB_Info[X25_CONNECTBPS_INDEX]);


    return(SUCCESS);
}

VOID
GetMutex (HANDLE mutex, DWORD to)
{
    if (WaitForSingleObject (mutex, to) == WAIT_FAILED)
    {
        GetLastError() ;
        DbgBreakPoint() ;
    }
}

VOID
FreeMutex (HANDLE mutex)
{
    if (!ReleaseMutex(mutex))
    {
        GetLastError () ;
        DbgBreakPoint() ;
    }
}

/*++

Routine Description:

    Starts the disconnect process. Note even though
    this covers SYNC completion of lineDrop this
    is not per TAPI spec.

Arguments:

Return Value:

--*/
DWORD
InitiatePortDisconnection (TapiPortControlBlock *hIOPort)
{
    DWORD retcode = SUCCESS;

    hIOPort->TPCB_RequestId = INFINITE ;

    RasTapiTrace("InitiatePortDisconnection: %s",
                 hIOPort->TPCB_Name );

    if ( hIOPort->TPCB_dwFlags & RASTAPI_FLAG_DIALEDIN )
    {
        hIOPort->TPCB_dwFlags &= ~(RASTAPI_FLAG_DIALEDIN);

        if (hIOPort->TPCB_Line->TLI_pDeviceInfo)
        {
            DeviceInfo * pDeviceInfo =
                    hIOPort->TPCB_Line->TLI_pDeviceInfo;

#if DBG
            ASSERT(pDeviceInfo->dwCurrentDialedInClients > 0);
#endif

            pDeviceInfo->dwCurrentDialedInClients -= 1;

            RasTapiTrace(
                "IntiatePortDisconnection: %s, "
                "CurrenDialedInClients=0x%x",
                hIOPort->TPCB_DeviceName,
                pDeviceInfo->dwCurrentDialedInClients );
        }
                
    }

    //
    // For asyncmac/unimodem give a close indication to asyncmac if
    // the endpoint is still valid
    //
    if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_UNIMODEM) == 0)
    {

        // tell asyncmac to close the link
        //
        if (hIOPort->TPCB_Endpoint != INVALID_HANDLE_VALUE)
        {

            ASYMAC_CLOSE  AsyMacClose;
            OVERLAPPED overlapped ;
            DWORD       dwBytesReturned ;

            memset (&overlapped, 0, sizeof(OVERLAPPED)) ;

            AsyMacClose.MacAdapter = NULL;

            AsyMacClose.hNdisEndpoint = (HANDLE) hIOPort->TPCB_Endpoint ;

            DeviceIoControl(g_hAsyMac,
                      IOCTL_ASYMAC_CLOSE,
                      &AsyMacClose,
                      sizeof(AsyMacClose),
                      &AsyMacClose,
                      sizeof(AsyMacClose),
                      &dwBytesReturned,
                      &overlapped);

            hIOPort->TPCB_Endpoint = INVALID_HANDLE_VALUE ;

        }

        //
        // Close the handle given by lineGetId on unimodem ports
        //
        if (hIOPort->TPCB_CommHandle != INVALID_HANDLE_VALUE)
        {
            CloseHandle (hIOPort->TPCB_CommHandle) ;
            hIOPort->TPCB_CommHandle = INVALID_HANDLE_VALUE ;
        }
    }

    //
    // Handle the case where lineMakeCall is not yet
    // complete and the callhandle is invalid
    //
    if (hIOPort->TPCB_CallHandle == (HCALL) INFINITE)
    {

        RasTapiTrace("InitiatePortDisconnect: Invalid CallHandle - hIOPort %p, State 0x%x", 
                     hIOPort, hIOPort->TPCB_State);

        if (!hIOPort->TPCB_Line->TLI_MultiEndpoint) {

            RasTapiTrace ("InitiatePortDisconnect: Hammering LineClosed!");

            lineClose (hIOPort->TPCB_Line->TLI_LineHandle) ;

            Sleep (30L) ;

            retcode = lineOpen (
                          RasLine,
                          hIOPort->TPCB_Line->TLI_LineId,
                          &hIOPort->TPCB_Line->TLI_LineHandle,
                          hIOPort->TPCB_Line->NegotiatedApiVersion,
                          hIOPort->TPCB_Line->NegotiatedExtVersion,
                          (DWORD_PTR) hIOPort->TPCB_Line,
                          LINECALLPRIVILEGE_OWNER,
                          hIOPort->TPCB_Line->TLI_MediaMode,
                          NULL) ;

            if (retcode)
            {
                RasTapiTrace("InitiatePortDisconnection: %s."
                             " lineOpen Failed. 0x%x",
                             hIOPort->TPCB_Name,
                             retcode );
            }

            //
            // Set monitoring of rings
            //
            lineSetStatusMessages (hIOPort->TPCB_Line->TLI_LineHandle,
                                  LINEDEVSTATE_RINGING, 0) ;

            RasTapiTrace(" ");

            retcode = SUCCESS;

            goto done;

        } else {

            //
            // We need to do something here!
            // Change the state?
            // What about the callback case?
            // Fix this post Win2K!
            //

            RasTapiTrace("InitiatePortDisconnect: Possible lost port: %p", hIOPort);

            goto done;
        }
    }

    //
    // Initiate disconnection.
    //
    if ((hIOPort->TPCB_RequestId =
            lineDrop (hIOPort->TPCB_CallHandle, NULL, 0))
                > 0x80000000 )
    {

        RasTapiTrace("InitiatePortDisconnection: Error"
                     " issuing lineDrop for %s. 0x%x",
                     hIOPort->TPCB_Name,
                     hIOPort->TPCB_RequestId );
        //
        // Error issuing the linedrop.  Should we try
        // to deallocate anyway?
        //
        RasTapiTrace("InitiatePortDisconnection: Changing "
                     "state for %s from %d -> %d",
                     hIOPort->TPCB_Name,
                     hIOPort->TPCB_State,
                     PS_OPEN );

        hIOPort->TPCB_State = PS_OPEN ;

        hIOPort->TPCB_RequestId = INFINITE ;

        lineDeallocateCall (hIOPort->TPCB_CallHandle) ;

        RasTapiTrace(" ");

        retcode = ERROR_DISCONNECTION;

        goto done;

    }
    else if (hIOPort->TPCB_RequestId)
    {

        //
        // The linedrop is completeing async
        //
        RasTapiTrace(
            "InitiatePortDisconnection: Changing"
            " state for %s from %d -> %d",
            hIOPort->TPCB_Name,
            hIOPort->TPCB_State,
            PS_DISCONNECTING );

        hIOPort->TPCB_State = PS_DISCONNECTING ;

        RasTapiTrace(" ");

        retcode = PENDING;

        goto done;

    }
    else
    {

        //
        // The linedrop completed sync
        //
        RasTapiTrace("InitiatePortDisconnection: %s. "
                     "linedrop completed sync.",
                     hIOPort->TPCB_Name );

        hIOPort->TPCB_RequestId = INFINITE ;

        if (hIOPort->IdleReceived)
        {


            RasTapiTrace(
                "InitiatePortDisconnection: Changing"
                " state for %s from %d -> %d",
                hIOPort->TPCB_Name,
                hIOPort->TPCB_State,
                PS_OPEN );

            hIOPort->IdleReceived = FALSE;

            hIOPort->TPCB_State = PS_OPEN ;

            lineDeallocateCall (hIOPort->TPCB_CallHandle) ;

            hIOPort->TPCB_CallHandle = (HCALL) -1 ;

            RasTapiTrace(" ");

            retcode = SUCCESS;

            goto done;

        }
        else
        {
            //
            // Wait for IdleReceived
            //
            hIOPort->TPCB_State = PS_DISCONNECTING ;

            retcode = PENDING;

            goto done;
        }
    }

done:

    if(hIOPort->TPCB_pConnectInfo)
    {
        LocalFree(hIOPort->TPCB_pConnectInfo);

        hIOPort->TPCB_pConnectInfo = NULL;
    }

    return retcode;
}

VOID
UnloadRastapiDll()
{
    //
    // If DLL did not successfully initialize for
    // this process
    // dont try to clean up
    //
    if (!g_fDllLoaded)
    {
        return;
    }

    if (RasLine)
    {
        lineShutdown (RasLine) ;
        RasLine = 0;
    }

    TraceDeregister( dwTraceId );

    g_fDllLoaded = FALSE;

    PostThreadMessage (TapiThreadId, WM_QUIT, 0, 0) ;
}

DWORD
SetCommSettings(TapiPortControlBlock *hIOPort,
                RASMANCOMMSETTINGS *pSettings)
{
    DCB dcb;
    DWORD retcode = SUCCESS;

    if(NULL == hIOPort)
    {
        RasTapiTrace("SetCommSettings: NULL hIOPort!");
        retcode = E_INVALIDARG;
        return retcode;
    }

    GetMutex(RasTapiMutex, INFINITE);

    if (!GetCommState(hIOPort->TPCB_CommHandle, &dcb))
    {
        retcode = GetLastError();
        
        RasTapiTrace(
            "SetCommSettings: GetCommState failed for %s",
            hIOPort->TPCB_Name);

        RasTapiTrace(" ");
        goto done;
    }

    dcb.ByteSize = pSettings->bByteSize;
    dcb.StopBits = pSettings->bStop;
    dcb.Parity   = pSettings->bParity;

    RasTapiTrace("SetCommSettings: setting parity=%d, stop=%d, data=%d",
                 pSettings->bParity,
                 pSettings->bStop,
                 pSettings->bByteSize);

    if (!SetCommState(hIOPort->TPCB_CommHandle, &dcb))
    {
        retcode = GetLastError();

        RasTapiTrace(
            "SetCommSettings: SetCommState failed "
              "for %s.handle=0x%x. %d",
               hIOPort->TPCB_Name,
               hIOPort->TPCB_CommHandle,
               retcode);

        RasTapiTrace(" ");
        goto done;
    }

done:    

    FreeMutex(RasTapiMutex);

    RasTapiTrace("SetCommSettings: done. rc=0x%x",
                  retcode);
                  
    return retcode;
}

/*++

Routine Description:

    This function uses the given handle to find
    which TPCB is it refering to. This handle can be
    either a pointer to TPCB itself (in case of non
    unimodem devices) or it is the CommHandle for the
    unimodem port. Consider: Adding a cache for
    lookup speeding.

Arguments:

Return Value:

    Nothing.

--*/
TapiPortControlBlock *
LookUpControlBlock (HANDLE hPort)
{
    DWORD i ;
    TapiPortControlBlock *pports = RasPortsList;

    while ( pports )
    {
        if (    pports == ( TapiPortControlBlock * ) hPort
            &&  ((TapiPortControlBlock *)hPort)->TPCB_Signature
                        == CONTROLBLOCKSIGNATURE)
        {
            return (TapiPortControlBlock *) hPort;
        }

        pports = pports->TPCB_next;
    }

    //
    // hPort is the TPCB pointer
    //
    pports = RasPortsList;

    //
    // hPort is not the TPCB pointer - see if this
    // matches any of the CommHandles
    //
    while ( pports )
    {
        if (pports->TPCB_CommHandle == hPort)
        {
            return pports ;
        }

        pports = pports->TPCB_next;
    }

    return NULL ;
}

/*++

Routine Description:

    Converts a RAS_PARAMS P_Value, which may
    be either a DWORD or a string, to a DWORD.

Arguments:

Return Value:

    The numeric value of the input as a DWORD.

--*/

DWORD
ValueToNum(RAS_PARAMS *p)
{
    CHAR szStr[RAS_MAXLINEBUFLEN];


    if (p->P_Type == String)
    {

        strncpy(szStr,
                p->P_Value.String.Data,
                p->P_Value.String.Length);

        szStr[p->P_Value.String.Length] = '\0';

        return(atol(szStr));

    }
    else
    {
        return(p->P_Value.Number);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\serial32\serutil.c ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: serutil.c
//
//  Revision History
//
//  Sep  3, 1992   J. Perry Hannah      Created
//
//
//  Description: This file contains utility functions which are used by
//               the serial DLL APIs.
//
//****************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <rasman.h>
#include <raserror.h>
#include <rasfile.h>

#include <rasmxs.h>

#include <serial.h>
#include <serialpr.h>

#include <stdlib.h>
#include <malloc.h>
#include <string.h>




//*  Global Variables  *******************************************************
//

extern SERIALPCB  *gpSerialPCB;     // Points to Serial PCB linked list
extern HANDLE     *ghRasfileMutex;  // Mutex used to protect access to Rasfile

extern HRASFILE    ghIniFile;       // Handle to Serial.ini memory image
extern HANDLE      ghAsyMac;        // Handle to AsyncMac driver
extern DWORD       gLastError;




//*  Utility Funcitons  ******************************************************
//


//*  GetIniFileName  --------------------------------------------------------
//
// Funciton: Puts the full path file name of the serial.ini file in the
//           first parameter.  dwBufferLen is the size of the array
//           referenced by the first parameter.
//
// Returns: nothing
//
//*

void
GetIniFileName(char *pszFileName, DWORD dwBufferLen)
{
  UINT  uLen;


  uLen = GetSystemDirectory(pszFileName, dwBufferLen);

  strcat(pszFileName, RAS_PATH);
  strcat(pszFileName, SERIAL_INI_FILENAME);
}






//*  AddPortToList  ----------------------------------------------------------
//
// Function: Adds a Serial Port Control Block to the head of the linked
//           list in the DLL's global memory.
//
// Returns: Nothing
//
// Exceptions: ERROR_ALLOCATING_MEMORY
//
//*

void
AddPortToList(HANDLE hIOPort, char *pszPortName)
{
  SERIALPCB  *pSPCB;



  // Add new Serial Port Control Block to head of list

  pSPCB = gpSerialPCB;
  GetMem(sizeof(SERIALPCB), (BYTE **)&gpSerialPCB);
  gpSerialPCB->pNextSPCB = pSPCB;



  // Set ID values in Serial Port Control Block

  gpSerialPCB->hIOPort = hIOPort;
  gpSerialPCB->uRasEndpoint = INVALID_HANDLE_VALUE;
  strcpy(gpSerialPCB->szPortName, pszPortName);

  //
  // Initialize overlapped structures.
  //
  gpSerialPCB->MonitorDevice.RO_EventType = OVEVT_DEV_STATECHANGE;
  gpSerialPCB->SendReceive.RO_EventType = OVEVT_DEV_ASYNCOP;

  // From Serial.ini file get info on the device attached to this port

  GetValueFromFile(gpSerialPCB->szPortName,
                   SER_DEVICETYPE_KEY,
                   gpSerialPCB->szDeviceType);

  GetValueFromFile(gpSerialPCB->szPortName,
                   SER_DEVICENAME_KEY,
                   gpSerialPCB->szDeviceName);

}






//*  FindPortInList  ---------------------------------------------------------
//
// Function: Finds the Serial Port Control Block in the linked list in
//           the DLL's global memory which contains the first parameter.
//           If the second parameter is not NULL on input, a pointer to
//           the previous PCB is returned in the second parameter.
//
//           NOTE: If the found PCB is at the head of the list, ppPrevSPCB
//           will be the same as the return value.
//
// Returns: Pointer to found PCB, or NULL if PCB is not found.
//
// Exceptions: ERROR_PORT_NOT_OPEN
//
//*

SERIALPCB *
FindPortInList(HANDLE hIOPort, SERIALPCB **ppPrevSPCB)
{
  SERIALPCB  *pSPCB, *pPrev;


  pSPCB = pPrev = gpSerialPCB;

  while(pSPCB != NULL && pSPCB->hIOPort != hIOPort)
  {
    pPrev = pSPCB;
    pSPCB = pSPCB->pNextSPCB;
  }

  if (pSPCB == NULL)
    gLastError = ERROR_PORT_NOT_OPEN;

  else if (ppPrevSPCB != NULL)
    *ppPrevSPCB = pPrev;

  return(pSPCB);
}






//*  FindPortNameInList  -----------------------------------------------------
//
// Function: Finds the Serial Port Control Block in the linked list in
//           the DLL's global memory which contains the Port name.
//
// Returns: Pointer to found PCB, or NULL if not found.
//
//*

SERIALPCB *
FindPortNameInList(TCHAR *pszPortName)
{
  SERIALPCB  *pSPCB;


  pSPCB = gpSerialPCB;

  while(pSPCB != NULL && _stricmp(pSPCB->szPortName, pszPortName) != 0)

    pSPCB = pSPCB->pNextSPCB;

  return(pSPCB);
}






//*  InitCarrierBps  ---------------------------------------------------------
//
// Function: Sets szCarrierBps in Serial Port Control Block to the
//           MAXCARRIERBPS value in serial.ini.
//
// Returns: Nothing
//
//*
DWORD
InitCarrierBps(char *pszPortName, char *pszMaxCarrierBps)
{
  // Find section for pszPortName

    // Begin Exclusion

  if(INVALID_HRASFILE == ghIniFile)
  {
    return SUCCESS;
  }

  WaitForSingleObject(ghRasfileMutex, INFINITE);

#if DBG
    ASSERT( INVALID_HRASFILE != ghIniFile );
#endif    

  if (!RasfileFindSectionLine(ghIniFile, pszPortName, FROM_TOP_OF_FILE))
  {
      // End Exclusion

    ReleaseMutex(ghRasfileMutex);
    return(ERROR_READING_SECTIONNAME);
  }


  // Get Device Type

  if(!(RasfileFindNextKeyLine(ghIniFile, SER_MAXCARRIERBPS_KEY, RFS_SECTION) &&
       RasfileGetKeyValueFields(ghIniFile, NULL, pszMaxCarrierBps)))
  {
      // End Exclusion

    ReleaseMutex(ghRasfileMutex);
    return(ERROR_READING_INI_FILE);
  }

    // End Exclusion

  ReleaseMutex(ghRasfileMutex);
  return(SUCCESS);
}






//*  SetCommDefaults  --------------------------------------------------------
//
// Function: Adds a Serial Port Control Block to the head of the linked
//           list in the DLL's global memory.  Two fields are initialized:
//           hIOPort, from the first parameter, and eCmdType, from the
//           serial.ini file.
//
// Returns: Nothing
//
// Exceptions: ERROR_READING_INI_FILE
//             ERROR_UNKNOWN_DEVICE_TYPE
//
//*

void
SetCommDefaults(HANDLE hIOPort, char *pszPortName)
{
  DCB   DCB;
  char  szInitialBPS[MAX_BPS_STR_LEN];


  // Get a Device Control Block with current port values

  if (!GetCommState(hIOPort, &DCB))
  {
    gLastError = GetLastError();
    RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
  }

  strcpy(szInitialBPS, "28800");

  // Read Max Connect BPS from Serial.ini

  GetValueFromFile(pszPortName, SER_INITBPS_KEY, szInitialBPS);


  // Set RAS default values in the DCB

  SetDcbDefaults(&DCB);
  DCB.BaudRate = atoi(szInitialBPS);


  // Send DCB to Port

  if (!SetCommState(hIOPort, &DCB))
  {
    gLastError = GetLastError();
    RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
  }
}






//*  SetDcbDefaults ----------------------------------------------------------
//
// Function: Sets DCB values (except BaudRate) to RAS default values.
//
// Returns: Nothing.
//
//*

void
SetDcbDefaults(DCB *pDCB)
{
  pDCB->fBinary         = TRUE;
  pDCB->fParity         = FALSE;

  pDCB->fOutxCtsFlow    = TRUE;
  pDCB->fOutxDsrFlow    = FALSE;
  pDCB->fDtrControl     = DTR_CONTROL_ENABLE;

  pDCB->fDsrSensitivity = FALSE;
  pDCB->fOutX           = FALSE;
  pDCB->fInX            = FALSE;

  pDCB->fNull           = FALSE;
  pDCB->fRtsControl     = RTS_CONTROL_HANDSHAKE;
  pDCB->fAbortOnError   = FALSE;

  pDCB->ByteSize        = 8;
  pDCB->Parity          = NOPARITY;
  pDCB->StopBits        = ONESTOPBIT;
}






//*  StrToUsage  -------------------------------------------------------------
//
// Function: Converts string in first parameter to enum RASMAN_USAGE.
//           If string does not map to one of the enum values, the
//           function returns FALSE.
//
// Returns: TRUE if successful.
//
//*

BOOL
StrToUsage(char *pszStr, RASMAN_USAGE *peUsage)
{

  if (_stricmp(pszStr, SER_USAGE_VALUE_NONE) == 0)
    *peUsage = CALL_NONE;

  else {
      if (strstr(pszStr, SER_USAGE_VALUE_CLIENT))
        *peUsage |= CALL_OUT;
    
      if (strstr(pszStr, SER_USAGE_VALUE_SERVER))
        *peUsage |= CALL_IN;
    
      if (strstr(pszStr, SER_USAGE_VALUE_ROUTER))
        *peUsage |= CALL_ROUTER;
  }

  return(TRUE);
}







//*  GetMem  -----------------------------------------------------------------
//
// Function: Allocates memory.
//
// Returns: Nothing.  Raises exception on error.
//
//*

void
GetMem(DWORD dSize, BYTE **ppMem)
{

  if ((*ppMem = (BYTE *) calloc(dSize, 1)) == NULL )
  {
    gLastError = ERROR_ALLOCATING_MEMORY;
    RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
  }
}







//*  GetValueFromFile  -------------------------------------------------------
//
// Function: Finds the szKey for the pszPortName and copies its value
//           string to pszValue.
//
// Assumptions: ghIniFile has been initalized.
//
// Returns: Nothing.  Raises exception on error.
//
//*

void
GetValueFromFile(TCHAR *pszPortName, TCHAR szKey[], TCHAR *pszValue)
{
    // Begin Exclusion

    if(INVALID_HRASFILE == ghIniFile)
    {
        return;
    }

#if DBG
    ASSERT( INVALID_HRASFILE != ghIniFile );
#endif

  WaitForSingleObject(ghRasfileMutex, INFINITE);

  if (!(RasfileFindSectionLine(ghIniFile, pszPortName, FROM_TOP_OF_FILE) &&
        RasfileFindNextKeyLine(ghIniFile, szKey, RFS_SECTION) &&
        RasfileGetKeyValueFields(ghIniFile, NULL, pszValue)))
  {
      // End Exclusion

    ReleaseMutex(ghRasfileMutex);
    gLastError = ERROR_READING_INI_FILE;
    RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
  }

    // End Exclusion

  ReleaseMutex(ghRasfileMutex);
}







//*  GetDefaultOffStr  -------------------------------------------------------
//
// Function: Copies the DefaultOff value string from serial.ini to the
//           first Serial Port Control Block.  If there is no DefaultOff=
//           in serial.ini a string containing a not printable character
//           used as a flag is copied to the SPCB.
//
// Assumptions: The first SPCB on the list is the current one.  This
//              function *must* be called only from PortOpen.
//
// Returns: Nothing.  Raises exception on error.
//
//*

void
GetDefaultOffStr(HANDLE hIOPort, TCHAR *pszPortName)
{

    if(INVALID_HRASFILE == ghIniFile)
    {
        return;
    }

#if DBG
  ASSERT(INVALID_HRASFILE != ghIniFile );
#endif  

    // Begin Exclusion

  WaitForSingleObject(ghRasfileMutex, INFINITE);

  if (!(RasfileFindSectionLine(ghIniFile, pszPortName, FROM_TOP_OF_FILE)))
  {
      // End Exclusion

    ReleaseMutex(ghRasfileMutex);
    gLastError = ERROR_READING_INI_FILE;
    RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
  }

  if (!(RasfileFindNextKeyLine(ghIniFile, SER_DEFAULTOFFSTR_KEY, RFS_SECTION)))
  {
      // End Exclusion

    ReleaseMutex(ghRasfileMutex);
    *(gpSerialPCB->szDefaultOff) = USE_DEVICE_INI_DEFAULT;
    return;
  }

  if (!(RasfileGetKeyValueFields(ghIniFile, NULL, gpSerialPCB->szDefaultOff)))
  {
      // End Exclusion

    ReleaseMutex(ghRasfileMutex);
    gLastError = ERROR_READING_INI_FILE;
    RaiseException(EXCEPT_RAS_MEDIA, EXCEPTION_NONCONTINUABLE, 0, NULL);
  }

    // End Exclusion

  ReleaseMutex(ghRasfileMutex);
}







//*  ValueToNum  -------------------------------------------------------------
//
// Function: Converts a RAS_PARAMS P_Value, which may be either a DWORD or
//           a string, to a DWORD.
//
// Returns: The numeric value of the input as a DWORD.
//
//*

DWORD ValueToNum(RAS_PARAMS *p)
{
  TCHAR szStr[RAS_MAXLINEBUFLEN];


  if (p->P_Type == String)
  {
    strncpy(szStr, p->P_Value.String.Data, p->P_Value.String.Length);
    szStr[p->P_Value.String.Length] = '\0';

    return(atol(szStr));
  }
  else
    return(p->P_Value.Number);
}







//*  ValueToBool -------------------------------------------------------------
//
// Function: Converts a RAS_PARAMS P_Value, which may be either a DWORD or
//           a string, to a BOOL.
//
// Returns: The boolean value of the input.
//
//*

BOOL ValueToBool(RAS_PARAMS *p)
{
  TCHAR szStr[RAS_MAXLINEBUFLEN];


  if (p->P_Type == String)
  {
    strncpy(szStr, p->P_Value.String.Data, p->P_Value.String.Length);
    szStr[p->P_Value.String.Length] = '\0';

    return(atol(szStr) ? TRUE : FALSE);
  }
  else
    return(p->P_Value.Number ? TRUE : FALSE);
}







//*  UpdateStatistics  -------------------------------------------------------
//
// Function: Updates the statistics when PortDisconnect is called so that
//           if PortGetStatistics is called while asyncmac is closed the
//           last good statistics will be reported.
//
// Returns: SUCCESS
//          Values from GetLastError()
//
//*

DWORD
UpdateStatistics(SERIALPCB *pSPCB)
{
#if 0
  ASYMAC_GETSTATS  A;
  DWORD            dwBytesReturned;


  // Fill in GetStats struct

  A.MacAdapter = NULL;
  A.hRasEndpoint = pSPCB->uRasEndpoint;


  // Call Asymac to get current MAC statistics counts

  if (!DeviceIoControl(ghAsyMac,
                       IOCTL_ASYMAC_GETSTATS,
                       &A,
                       sizeof(A),
                       &A,
                       sizeof(A),
                       &dwBytesReturned,
                       NULL))
    return(GetLastError());


  // Find difference between last PortClearStatistics and current counts

  pSPCB->Stats[BYTES_XMITED]
    = A.AsyMacStats.GenericStats.BytesTransmitted
        - pSPCB->Stats[BYTES_XMITED];

  pSPCB->Stats[BYTES_RCVED]
    = A.AsyMacStats.GenericStats.BytesReceived
        - pSPCB->Stats[BYTES_RCVED];

  pSPCB->Stats[FRAMES_XMITED]
    = A.AsyMacStats.GenericStats.FramesTransmitted
        - pSPCB->Stats[FRAMES_XMITED];

  pSPCB->Stats[FRAMES_RCVED]
    = A.AsyMacStats.GenericStats.FramesReceived
       - pSPCB->Stats[FRAMES_RCVED];

  pSPCB->Stats[CRC_ERR]
    = A.AsyMacStats.SerialStats.CRCErrors
       - pSPCB->Stats[CRC_ERR];

  pSPCB->Stats[TIMEOUT_ERR]
    = A.AsyMacStats.SerialStats.TimeoutErrors
       - pSPCB->Stats[TIMEOUT_ERR];

  pSPCB->Stats[ALIGNMENT_ERR]
    = A.AsyMacStats.SerialStats.AlignmentErrors
       - pSPCB->Stats[ALIGNMENT_ERR];

  pSPCB->Stats[SERIAL_OVERRUN_ERR]
    = A.AsyMacStats.SerialStats.SerialOverrunErrors
       - pSPCB->Stats[SERIAL_OVERRUN_ERR];

  pSPCB->Stats[FRAMING_ERR]
    = A.AsyMacStats.SerialStats.FramingErrors
       - pSPCB->Stats[FRAMING_ERR];

  pSPCB->Stats[BUFFER_OVERRUN_ERR]
    = A.AsyMacStats.SerialStats.BufferOverrunErrors
       - pSPCB->Stats[BUFFER_OVERRUN_ERR];

  pSPCB->Stats[BYTES_XMITED_UNCOMP]
    = A.AsyMacStats.CompressionStats.BytesTransmittedUncompressed
       - pSPCB->Stats[BYTES_XMITED_UNCOMP];

  pSPCB->Stats[BYTES_RCVED_UNCOMP]
    = A.AsyMacStats.CompressionStats.BytesReceivedUncompressed
       - pSPCB->Stats[BYTES_RCVED_UNCOMP];

  pSPCB->Stats[BYTES_XMITED_COMP]
    = A.AsyMacStats.CompressionStats.BytesTransmittedCompressed
       - pSPCB->Stats[BYTES_XMITED_COMP];

  pSPCB->Stats[BYTES_RCVED_COMP]
    = A.AsyMacStats.CompressionStats.BytesReceivedCompressed
       - pSPCB->Stats[BYTES_RCVED_COMP];

#endif
  return(SUCCESS);
}






//*  DbgPrntf  --------------------------------------------------------------
//
// Funciton: DbgPrntf -- printf to the debugger console
//           Takes printf style arguments.
//           Expects newline characters at the end of the string.
//           Written by BruceK.
//
// Returns: nothing
//
//*

#ifdef DEBUG

#include <stdarg.h>
#include <stdio.h>


void DbgPrntf(const char * format, ...) {
    va_list marker;
    char String[512];
    
    va_start(marker, format);
    vsprintf(String, format, marker);
    OutputDebugString(String);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\tapi32\rtnetcfg.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    rtnetcfg.c

Abstract:

    Helper routines to read PortUsage and other information
    from registry.

Author:

    Rao Salapaka (raos) 29-Mar-97

Revision History:

--*/

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tchar.h>
#include <rtutils.h>
#include <rasman.h>
#include <reghelp.h>

#define REGISTRY_NUMBEROFRINGS      TEXT("NumberOfRings")

#define RNETCFG_RASCLI              1

#define RNETCFG_RASSRV              2

#define RNETCFG_ROUTER              4

DWORD   g_dwRasComponent = 0;

#define TRACESETTINGS               (0x00010000 \
                                    | TRACE_USE_MASK \
                                    | TRACE_USE_MSEC)


DWORD dwTraceId;

DWORD dwGetNumberOfRings ( PDWORD pdwRings );

DWORD dwGetPortUsage(DWORD *pdwPortUsage);

LONG  lrIsModemRasEnabled(HKEY hkey, 
                          BOOL *pfRasEnabled,
                          BOOL *pfRouterEnabled);

DeviceInfo * GetDeviceInfo (PBYTE pbGuid );

/*++

Routine Description:

    Reads the value specified by lpcszValue parameter in the
    hkeyRas location of registry and returns the data assoc.
    with it. It is assumed that the data is a REG_DWORD. Side
    effect is that this key is created if not already present
    and defaults the value to the fEnable passed in.

Arguments:

    hkeyRas - handle of the registry key where this  value is
              to be checked.

    lpcszValue - Const. string representing the value to be
                 read.

    pfEnabled - pointer to a BOOL where the value read from
                the registry is to be returned.

    fEnable - the default value to set if the value is not
              present and this routine creates it.

Return Value:

    Values from the registry apis.

--*/
LONG
lrCheckValue(
        HKEY    hkeyRas,
        LPCTSTR lpcszValue,
        BOOL    *pfEnabled,
        BOOL    fEnable)
{
    DWORD dwdata = 0;
    DWORD dwtype;
    DWORD dwsize = sizeof(DWORD);
    LONG  lr;

    *pfEnabled = FALSE;

    if(ERROR_FILE_NOT_FOUND == (lr = RegQueryValueEx(
                                        hkeyRas,
                                        lpcszValue,
                                        0, 
                                        &dwtype,
                                        (PBYTE) &dwdata,
                                        &dwsize)))
    {
        TracePrintfExA(dwTraceId,
                       TRACESETTINGS,
                       "lrCheckValue: value %ws not found",
                       lpcszValue);

        if(lr = lrRasEnableDevice(hkeyRas,
                                  (LPTSTR) lpcszValue,
                                  fEnable))
        {
            TracePrintfExA(
                    dwTraceId,
                    TRACESETTINGS,
                   "lrCheckValue: Couldn't set value %ws. 0x%x",
                   lpcszValue, 
                   lr);
                   
            goto done;
        }

        *pfEnabled = fEnable;

        goto done;
    }

    *pfEnabled = dwdata;

done:
    return lr;
}

/*++

Routine Description:

    This routine is called only for modems. It checks the
    registry and determines if the modem is registered
    for RasDialIn and Routing. These values in registry
    are created if they are not already present and
    are defaulted appropriately.
    
Arguments:

    hkey - handle to the modems instance key in registry.

    pfRasEnabled - address where the data indicating if
                   the modem is enabled for ras dialin is
                   stored. If the key for this value doesn't
                   exist this value determines the default
                   value as an in parameter.

    pfRouterEnabled - address where the data indicating if
                      the modem is enabled for routing is
                      enabled.
                      
Return Value:

    Return values from the registry apis.


--*/
LONG
lrIsModemRasEnabled(HKEY    hkey,
                    BOOL    *pfRasEnabled,
                    BOOL    *pfRouterEnabled)
{
    DWORD dwdata;
    DWORD dwsize = sizeof ( DWORD );
    DWORD dwtype;
    LONG  lr;
    HKEY  hkeyRas = NULL;
    DWORD dwDisposition;
    BOOL  fDefaultForRasEnabled = *pfRasEnabled;

    *pfRasEnabled = 
    *pfRouterEnabled = FALSE;

    //
    // Open the RAS key and if the key is not present
    // create the key.
    //
    if (lr = RegCreateKeyEx(
               hkey,
               TEXT("Clients\\Ras"),
               0, NULL, 0,
               KEY_ALL_ACCESS,
               NULL,
               &hkeyRas,
               &dwDisposition))
    {
        TracePrintfExA(
            dwTraceId,
            TRACESETTINGS,
            "dwFindModemPortUsage: Failed to create/open"
            " RAS key under modem class. 0x%x",
            lr);

        goto done;
    }

    //
    // Check to see if the modem is enabled for ras dialin
    // Enable the modem for dialin by default to whatever
    // value is passed in
    //
    if(lr = lrCheckValue(
                hkeyRas,
                TEXT("EnableForRas"),
                pfRasEnabled,
                fDefaultForRasEnabled))
    {
        TracePrintfExA(
            dwTraceId,
            TRACESETTINGS,
            "dwFindModemPortUsage: lrCheckValue failed for "
            "RasEnabled. %d",
            lr );

        lr = ERROR_SUCCESS;

    }

    if (!*pfRasEnabled)
    {
        TracePrintfExA(
            dwTraceId,
            TRACESETTINGS,
            "dwFindModemPortUsage: Modem is not "
            "enabled for RAS");
    }

    //
    // Check to see if the modem is enabled for routing
    // disable the modem for routing by default
    //
    if(lr = lrCheckValue(
                hkeyRas,
                TEXT("EnableForRouting"),
                pfRouterEnabled,
                FALSE))
    {
        TracePrintfExA(
            dwTraceId,
            TRACESETTINGS,
            "dwFindModemPortUsage: lrCheckValue failed for "
            "RouterEnabled. %d",
            lr );

        lr = ERROR_SUCCESS;

    }

    if (!*pfRouterEnabled)
    {
        TracePrintfExA(
            dwTraceId,
            TRACESETTINGS,
            "dwFindModemPortUsage: Modem is not "
            "enabled for Routing");
    }
    

done:
    if(hkeyRas)
    {
        RegCloseKey(hkeyRas);
    }

    return (DWORD) lr;
}

/*++

Routine Description:

    Gets the default port usage for the device. The default
    is if ras server is installed, the port is enabled for
    ras dialin and routing. The device is always enabled for
    dialout.

Arguments:

    pdwUsage - buffer to receive the port usage.

Return Value:

    ERROR_SUCCESS.

--*/
DWORD
dwGetPortUsage(DWORD *pdwUsage)
{
    HKEY    hkey         = NULL;
    DWORD   dwRetCode    = ERROR_SUCCESS;

    static const TCHAR c_szRemoteAccess[] =
    TEXT("System\\CurrentControlSet\\Services\\RemoteAccess");

    TracePrintfExA(dwTraceId,
                   TRACESETTINGS,
                   "dwGetPorTUsage:...");

    if(0 == g_dwRasComponent)
    {
        //
        // Check to see if Ras Server is installed
        //
        g_dwRasComponent = RNETCFG_RASCLI;

        if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    c_szRemoteAccess,
                    0, KEY_QUERY_VALUE,
                    &hkey))
        {
            TracePrintfExA(
                dwTraceId,
                TRACESETTINGS,
                "dwAssignDefaultPortUsage: RemoteAccess"
                " not installed");
        }
        else
        {
            g_dwRasComponent = RNETCFG_RASSRV;
        }
    }

    *pdwUsage = CALL_OUT;

    *pdwUsage |= ((g_dwRasComponent & RNETCFG_RASSRV) ?
                    (CALL_IN | CALL_ROUTER) : 0);

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }   

    return dwRetCode;
}


/*++

Routine Description:

    Gets the information from registry about how many
    rings to wait for before picking up an incoming 
    call.

Arguments:

    pdwRings - buffer to receive the number of rings
               read from registry.

Return Value:

    Return Values from registry apis.

--*/
DWORD
dwGetNumberOfRings (PDWORD pdwRings)
{
    LONG    lr      = ERROR_SUCCESS;
    HKEY    hkey    = NULL;
    DWORD   dwsize  = sizeof(DWORD);
    DWORD   dwtype;

    TCHAR c_szRasmanParam[] =
    TEXT("SYSTEM\\CurrentControlSet\\Services\\Rasman\\Parameters");

    if(lr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                c_szRasmanParam,
                0, KEY_READ,
                &hkey))
    {
        TracePrintfExA(
                dwTraceId,
                TRACESETTINGS,
                "dwGetNumberOfRings: failed to open rasman key"
                " in registry. 0x%x",
                lr);

        goto done;
    }

    if(lr = RegQueryValueEx(
                hkey,
                TEXT("NumberOfRings"),
                0, &dwtype,
                (PBYTE) pdwRings,
                &dwsize))
    {
        *pdwRings = 2;
    }

    if (*pdwRings > 20)
    {
        *pdwRings = 2;
    }

done:
    if(hkey)
    {
        RegCloseKey(hkey);
    }

    TracePrintfExA(
        dwTraceId,
        TRACESETTINGS,
        "dwGetNumberOfRings: dwRings=%d. lr=0x%x",
        *pdwRings,
        lr);


    return (DWORD) lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\tapi32\init.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    init.c

Abstract:

    This file contains init code for TAPI.DLL

Author:

    Gurdeep Singh Pall (gurdeep) 06-Jun-1997

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <tapi.h>
#include <rasman.h>
#include <raserror.h>
#include <mprlog.h>
#include <rtutils.h>

#include <media.h>
#include <device.h>
#include <rasmxs.h>
#include <isdn.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include "rastapi.h"
#include "reghelp.h"
#include <ntddndis.h> //for NDIS_WAN_MEDIUM_SUBTYPE

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#define                 NUMBUFFERS              10

VOID
MapNdiswanDTtoRasDT(DeviceInfo              *pDeviceInfo,
                    NDIS_WAN_MEDIUM_SUBTYPE eMediaType);
                    
HLINEAPP                RasLine                 = 0 ;
HINSTANCE               RasInstance             = 0 ;
TapiLineInfo            *RasTapiLineInfoList    = NULL;
DWORD                   TotalLines              = 0 ;
DWORD                   TotalPorts ;
TapiPortControlBlock    *RasPortsList           = NULL;
TapiPortControlBlock    *RasPortsEnd ;
HANDLE                  RasTapiMutex ;
BOOL                    Initialized             = FALSE ;
DWORD                   TapiThreadId    ;
HANDLE                  TapiThreadHandle;
// DWORD                   LoaderThreadId;
DWORD                   ValidPorts              = 0;
DWORD                   NumberOfRings           = 2 ;

HANDLE                  g_hAsyMac               = INVALID_HANDLE_VALUE;

HANDLE                  g_hIoCompletionPort     = INVALID_HANDLE_VALUE;

pDeviceInfo             g_pDeviceInfoList       = NULL;

LIST_ENTRY              ZombieCallList;

DWORD                   dwTraceId;

extern BOOL             g_fDllLoaded;


TapiLineInfo *FindLineByHandle (HLINE) ;

TapiPortControlBlock *FindPortByRequestId (DWORD) ;

TapiPortControlBlock *FindPortByAddressId (TapiLineInfo *, DWORD) ;

TapiPortControlBlock *FindPortByAddress   (CHAR *) ;

TapiPortControlBlock *FindPortByCallHandle(
                            TapiLineInfo *line,
                            HCALL callhandle);

TapiPortControlBlock *FindListeningPort(TapiLineInfo *line,
                                        DWORD AddressID);

DWORD InitiatePortDisconnection (TapiPortControlBlock *hIOPort) ;

TapiPortControlBlock *FindPortByAddressAndName (CHAR *address,
                                                    CHAR *name) ;

/*++

Routine Description:

        Trace

Arguments:

        Formatting string,...

Return Value:

        void.
--*/

VOID
RasTapiTrace(
    CHAR * Format,
    ...
)
{
    va_list arglist;

    va_start(arglist, Format);

    TraceVprintfEx(dwTraceId,
                   0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC, 
                   Format,
                   arglist);

    va_end(arglist);
}

/*++

Routine Description:

        Initialize the RasPorts List

Arguments:

        void

Return Value:

        SUCCESS.
--*/

DWORD
InitializeRasPorts()
{

    RasPortsList = NULL;

    InitializeListHead(&ZombieCallList);

    return 0;

}

/*++

Routine Description:

        Gets Next available port from the list of
        port control blocks. Allocates a block if
        no block is available.

Arguments:

        pfNewBlock -address of bool which received
            if a new block was created

Return Value:

        Pointer to the newly created block. NULL is
        returned in case of failures.

--*/

TapiPortControlBlock *
GetNextAvailablePort( BOOL *pfNewBlock )
{

    //
    // Run down the global list looking for an
    // unused block. If no such block is found
    // allocate a new block.
    //
    TapiPortControlBlock *ptpcb = RasPortsList;

    while ( NULL != ptpcb )
    {
        if ( PS_UNINITIALIZED == ptpcb->TPCB_State )
            break;

        ptpcb = ptpcb->TPCB_next;
    }

    if ( NULL != ptpcb )
    {
        *pfNewBlock = FALSE;
        goto done;
    }

    ptpcb = LocalAlloc ( LPTR, sizeof ( TapiPortControlBlock ) );

    if ( NULL == ptpcb )
        goto done;

    *pfNewBlock = TRUE;

    ptpcb->TPCB_State = PS_UNINITIALIZED;

    //
    // insert the new block in the global list
    //
    ptpcb->TPCB_next    = RasPortsList;
    RasPortsList        = ptpcb;

    TotalPorts++;

done:
    return ptpcb;

}

#if 0
DWORD
dwGetNextInstanceNumber(CHAR    *pszMediaName,
                        DWORD   *pdwExclusiveDialIn,
                        DWORD   *pdwExclusiveDialOut,
                        DWORD   *pdwExclusiveRouter,
                        BOOL    *pfIn)
{
    DWORD                   dwCount;
    DWORD                   dwInstanceNum   = 0;
    DWORD                   dwTemp;
    TapiPortControlBlock    *ptpcb          = RasPortsList;

    *pdwExclusiveDialIn     = 0;
    *pdwExclusiveDialOut    = 0;
    *pdwExclusiveRouter     = 0;
    *pfIn                   = FALSE;

    while ( ptpcb )
    {
        if (    PS_UNINITIALIZED != ptpcb->TPCB_State
            &&  ptpcb->TPCB_Name[0] != '\0'
            &&  strstr( ptpcb->TPCB_Name, pszMediaName ))
         {
            dwTemp = atoi(ptpcb->TPCB_Name + strlen(pszMediaName) + 1);

            if (dwTemp > dwInstanceNum)
            {
                dwInstanceNum = dwTemp;
            }
            if (CALL_IN == ptpcb->TPCB_Usage)
            {
                *pdwExclusiveDialIn += 1;
            }
            else if (CALL_OUT == ptpcb->TPCB_Usage)
            {
                *pdwExclusiveDialOut += 1;
            }
            else if (CALL_ROUTER == ptpcb->TPCB_Usage)
            {
                *pdwExclusiveRouter += 1;
            }
        }

        if ( CALL_IN & ptpcb->TPCB_Usage)
        {
            *pfIn = TRUE;
        }

        ptpcb = ptpcb->TPCB_next;
    }

    return dwInstanceNum + 1;
}
#endif

/*++

Routine Description:

        Gets the Guid of the adapter identified by the
        dwID parameter. Also returns the media type of
        the device in szMediaType parameter.

Arguments:

        dwNegotiatedApiVersion

        dwNegotiatedExtVersion

        pbyte - buffer to receive the Guid

        dwID - line Id of the device

        dwAddressID - Address Id of the device

        szMediaType - buffer to receive the media type

Return Value:

        return codes from tapi calls. SUCCESS is
        returned if there are no failures.
--*/

DWORD
dwGetLineAddress( DWORD  dwNegotiatedApiVersion,
                  DWORD  dwNegotiatedExtVersion,
                  LPBYTE pbyte,
                  DWORD  dwID,
                  DWORD  dwAddressID,
                  CHAR*  szMediaType,
                  PNDIS_WAN_MEDIUM_SUBTYPE peMedia)
{
    DWORD           dwRetCode;
    HLINE           hLine       = 0;
    LINECALLPARAMS  lineparams;
    BYTE            *bvar[100];
    LPVARSTRING     pvar;

    RasTapiTrace("dwGetLineAddress:...");

    //
    // Open the line
    //
    if ( dwRetCode = lineOpen (  RasLine,
                                 dwID,
                                 &hLine,
                                 dwNegotiatedApiVersion,
                                 dwNegotiatedExtVersion,
                                 0,
                                 LINECALLPRIVILEGE_NONE,
                                 LINEMEDIAMODE_UNKNOWN,
                                 &lineparams))
    {
        RasTapiTrace("dwGetLineAddress: lineOpen failed. "
                     "0x%x", dwRetCode );
        goto done;
    }

    pvar = (VARSTRING *) bvar;
    pvar->dwTotalSize = sizeof (bvar);

    //
    // Get the Guid for this line from TAPI
    //
    if ( dwRetCode = lineGetID ( hLine,
                                 dwAddressID,
                                 0,
                                 LINECALLSELECT_LINE,
                                 pvar,
                                 "LineGuid"))
    {
        RasTapiTrace("dwGetLineAddress: lineGetID LineGuid "
                     "failed. 0x%x", dwRetCode );
        goto done;
    }


    lineClose (hLine);

    hLine = 0;

    if (    0 != pvar->dwStringSize
        &&  1 != pvar->dwStringSize)
    {
        DWORD   Index;
        PUCHAR  MediaTypes[] = {
            "GENERIC",
            "X25",
            "ISDN",
            "SERIAL",
            "FRAMERELAY",
            "ATM",
            "SONET",
            "SW56",
            "VPN",
            "VPN",
            "IRDA",
            "PARALLEL",
            "PPPoE"
        };

        //
        // Copy the GUID
        //
        memcpy ( pbyte,
                (PBYTE) (((PBYTE) pvar) +
                pvar->dwStringOffset),
                sizeof (GUID) );

        memcpy ((PBYTE)&Index, (PBYTE) (((PBYTE) pvar) +
                pvar->dwStringOffset + sizeof (GUID)),
                sizeof(DWORD));

        if (Index > 12) {
            Index = 0;
        }

        //
        // Copy the media name
        //
        strcpy (szMediaType, MediaTypes[Index]);

        if(peMedia)
        {
            *peMedia = (NDIS_WAN_MEDIUM_SUBTYPE) Index;
        }
    }
    else
    {   
        ASSERT(FALSE);

        dwRetCode = E_FAIL;
        
        RasTapiTrace(
            "dwGetLineAddress: pvar->dwStringSize != 0,1"
            " returning 0x%x",
            dwRetCode);
    }

done:

    if (hLine)
    {
        lineClose (hLine);
    }

    RasTapiTrace("dwGetLineAddress: done. 0x%x", dwRetCode );

    RasTapiTrace(" ");

    return dwRetCode;
}

/*++

Routine Description:

        DLL Main routine for rastapi dll.

Arguments:

        hInst - instance handle of the dll

        dwReason

        lpReserved

Return Value:

        returns 1 if successfule. 0 otherwise.

--*/

BOOL
InitRasTapi (
    HANDLE  hInst,
    DWORD   dwReason,
    LPVOID  lpReserved)
{
    static BOOLEAN DllInitialized = FALSE ;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        if (RasPortsList != NULL)
        {
            return 1 ;
        }

        RasInstance = hInst ;

        //
        // Register for tracing
        //
        dwTraceId = TraceRegister("RASTAPI");

#if DBG
        if(dwTraceId == (DWORD) -1)
        {
            DbgPrint("RASTAPI: TraceRegister Failed\n");
        }
        else
        {
            DbgPrint("RASTAPI: TraceId = %d\n",
                     dwTraceId);
        }
#endif

        //
        // initialize RasPorts
        //
        if (InitializeRasPorts())
        {
            return 0;
        }

        if ((RasTapiMutex = CreateMutex (NULL, FALSE, NULL))
                    == NULL)
        {
            return 0 ;
        }

        DllInitialized = TRUE ;
        break ;

    case DLL_PROCESS_DETACH:

        //
        // If DLL did not successfully initialize for
        // this process
        // dont try to clean up
        //
        if (    !DllInitialized
            ||  !g_fDllLoaded)
        {
            break ;
        }

        if (RasLine)
        {
            lineShutdown (RasLine) ;
            RasLine = 0;
        }

        TraceDeregister( dwTraceId );

        g_fDllLoaded = FALSE;

        PostThreadMessage (TapiThreadId, WM_QUIT, 0, 0) ;

        if(NULL != TapiThreadHandle)
        {
            CloseHandle(TapiThreadHandle);
            TapiThreadHandle = NULL;
        }
        
        break ;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return 1 ;
}


/*++

Routine Description:

            Gets the device information associated with
            the Guid passed in if the device is not a
            modem. Gets the information about modem if
            the the address passed in is the device name
            of a modem.

Arguments:

            pbAddress - Guid of the device if fModem is
                FALSE or Device Name of a modem if fModem
                is TRUE.

Return Value:

            Pointer to a DeviceInfo structure if the info
            was found. NULL otherwise.

--*/

DeviceInfo *
GetDeviceInfo(
    PBYTE pbAddress,
    BOOL fModem)
{
    DeviceInfo *pDeviceInfo = g_pDeviceInfoList;

    while ( pDeviceInfo )
    {
        if(     fModem
            &&  !_stricmp(
                    (CHAR *) pbAddress,
                    pDeviceInfo->rdiDeviceInfo.szDeviceName))
        {
            break;
        }
        else if(    !fModem
                &&  0 == memcmp(pbAddress,
                        &pDeviceInfo->rdiDeviceInfo.guidDevice,
                        sizeof (GUID)))
        {
            break;
        }

        pDeviceInfo = pDeviceInfo->Next;
    }

    return pDeviceInfo;
}

/*++

Routine Description:

        Trace the information in the Device Info block.

Arguments:

        DeviceInfo

Return Value:

        void
--*/

VOID
TraceEndPointInfo(DeviceInfo *pInfo)
{
    if('\0' != pInfo->rdiDeviceInfo.szDeviceName[0])
    {
        RasTapiTrace("------DeviceInfo for %s--------",
                    pInfo->rdiDeviceInfo.szDeviceName);
    }
    else
    {
        RasTapiTrace("------DeviceInfo for Unknown----");
    }

    RasTapiTrace(" ");

    RasTapiTrace("WanEndPoints      =%d",
                 pInfo->rdiDeviceInfo.dwNumEndPoints);

    RasTapiTrace("RasEnabled        =%d",
                (DWORD) pInfo->rdiDeviceInfo.fRasEnabled);

    RasTapiTrace("RasEnabledRouter  =%d",
                (DWORD) pInfo->rdiDeviceInfo.fRouterEnabled);

    RasTapiTrace("MinWanEndPoints   =0x%x",
                pInfo->rdiDeviceInfo.dwMinWanEndPoints);

    RasTapiTrace("MaxWanEndPoints   =0x%x",
                pInfo->rdiDeviceInfo.dwMaxWanEndPoints);

    RasTapiTrace(" ");
    RasTapiTrace("------------------------------------");

}

/*++

Routine Description:

        Gets the Device information of the device
        represented by the Guid. Depending on the flags
        passed reads the information from registry.
        Uses the functions in reghelp.lib

Arguments:

        ppDeviceInfo - Address to receive the DeviceInfo
            structure.

        pbAddress - Guid of the device.

        fForceRead - if TRUE the information is read from
            the registry. If FALSE only cached information
            is searched for the information on this device.

Return Value:

        void
--*/

DWORD
GetEndPointInfo(DeviceInfo **ppDeviceInfo,
                PBYTE pbAddress,
                BOOL fForceRead,
                NDIS_WAN_MEDIUM_SUBTYPE eMediaType)
{
    DeviceInfo *pDeviceInfo = g_pDeviceInfoList;
    DWORD       retcode     = SUCCESS;
    DeviceInfo *pdi;

    //
    // Run through the device info list to see if we already
    // have the device
    //
    if (    !fForceRead
        &&  ( pDeviceInfo = GetDeviceInfo(pbAddress, FALSE) ))
    {
        RasTapiTrace("GetEndPointInfo: Device already present");
        goto done;
    }

    pDeviceInfo = LocalAlloc ( LPTR, sizeof ( DeviceInfo ) );

    if ( NULL == pDeviceInfo )
    {
        retcode = GetLastError();

        RasTapiTrace("GetEndPointInfo: Failed to alloc. %d",
                     retcode );
        goto done;
    }

    MapNdiswanDTtoRasDT(pDeviceInfo, eMediaType);

    retcode = DwGetEndPointInfo( pDeviceInfo,
                                 pbAddress );
    if ( retcode )
    {
        RasTapiTrace("GetEndPpointInfo: DwGetEndPointInfo "
                     "failed. 0x%x", retcode );
        goto done;
    }

    pDeviceInfo->fValid = TRUE;

    //
    // Run through our device list and check to see if
    // we already have a device with the same name. If
    // we do then append the instance number of the
    // device with the device name
    //
    pdi = g_pDeviceInfoList;

    while(pdi)
    {
        if(!_stricmp(
            pdi->rdiDeviceInfo.szDeviceName,
            pDeviceInfo->rdiDeviceInfo.szDeviceName))
        {
            RasTapiTrace(
                "GetEndPointInfo: found another"
                " device with the same name %s",
                pDeviceInfo->rdiDeviceInfo.szDeviceName);

            break;
        }

        pdi = pdi->Next;
    }

    if(NULL != pdi)
    {
        CHAR szDeviceInstance[40];
        WCHAR wszDeviceInstance[40];
        
        sprintf(szDeviceInstance,
                 " (%d)",
                 pDeviceInfo->dwInstanceNumber);

        (VOID) StringCchPrintfA(
                    szDeviceInstance,
                    40, " (%d)",
                    pDeviceInfo->dwInstanceNumber);

        (VOID) StringCchPrintfW(
                    wszDeviceInstance,
                    40, L" (%d)",
                    pDeviceInfo->dwInstanceNumber);

        retcode = StringCchCatA(
                    pDeviceInfo->rdiDeviceInfo.szDeviceName,
                    MAX_DEVICE_NAME + 1,
                    szDeviceInstance);

        if(SUCCESS != retcode)
        {
            goto done;
        }

        retcode = StringCchCatW(
                    pDeviceInfo->rdiDeviceInfo.wszDeviceName,
                    MAX_DEVICE_NAME + 1,
                    wszDeviceInstance);

        if(SUCCESS != retcode)
        {
            goto done;
        }
        
        RasTapiTrace("New DeviceName=%s",
            pDeviceInfo->rdiDeviceInfo.szDeviceName);

        RasTapiTrace("New WDeviceName=%ws",
            pDeviceInfo->rdiDeviceInfo.wszDeviceName);
                
    }
    
    //
    // Insert the DeviceInfo at the head of the
    // global list
    //
    if ( !fForceRead )
    {
        pDeviceInfo->Next = g_pDeviceInfoList;
        g_pDeviceInfoList = pDeviceInfo;

        //
        // Trace all this information for this adapter
        //
        TraceEndPointInfo(pDeviceInfo);
    }

done:

    if(     (SUCCESS != retcode)
        &&  (NULL != pDeviceInfo))
    {
        LocalFree(pDeviceInfo);
        pDeviceInfo = NULL;
    }

    *ppDeviceInfo = pDeviceInfo;

    return retcode;

}

/*++

Routine Description:

    This routine maps the devicetypes declared in the
    NDIS_WAN_MEDIUM_SUBTYPE enum in ntddndis.h to the
    RASDEVICETYPE enum declared in rasman.h. This
    mapping is done to enable flexibility at the ras
    layer to further categorize the device type into
    paricular classes.

Arguments:

    pDeviceInfo - address of the DeviceInfo structure
                  containing the informatio pertaining
                  to the device.

    eMediaType - Device type as defined in ndis for this
                 device.


Return Value:

    Nothing;

--*/
VOID
MapNdiswanDTtoRasDT(DeviceInfo              *pDeviceInfo,
                    NDIS_WAN_MEDIUM_SUBTYPE eMediaType)
{
    RASDEVICETYPE rdt = 0;

    switch (eMediaType)
    {
        case NdisWanMediumHub:
        {
            rdt = RDT_Other;
            break;
        }

        case NdisWanMediumX_25:
        {
            rdt = RDT_X25;
            break;
        }

        case NdisWanMediumIsdn:
        {
            rdt = RDT_Isdn;
            break;
        }

        case NdisWanMediumSerial:
        {
            rdt = RDT_Serial;
            break;
        }

        case NdisWanMediumFrameRelay:
        {
            rdt = RDT_FrameRelay;
            break;
        }

        case NdisWanMediumAtm:
        {
            rdt = RDT_Atm;
            break;
        }

        case NdisWanMediumSonet:
        {
            rdt = RDT_Sonet;
            break;
        }

        case NdisWanMediumSW56K:
        {
            rdt = RDT_Sw56;
            break;
        }

        case NdisWanMediumPPTP:
        {
            rdt = RDT_Tunnel_Pptp | RDT_Tunnel;
            break;
        }

        case NdisWanMediumL2TP:
        {
            rdt = RDT_Tunnel_L2tp | RDT_Tunnel;
            break;
        }

        case NdisWanMediumIrda:
        {
            rdt = RDT_Irda | RDT_Direct;
            break;
        }

        case NdisWanMediumParallel:
        {
            rdt = RDT_Parallel | RDT_Direct;
            break;
        }

        case NdisWanMediumPppoe:
        {
            rdt = RDT_PPPoE | RDT_Broadband;
            break;
        }

        default:
        {
            rdt = RDT_Other;
            break;
        }
    } // switch

    pDeviceInfo->rdiDeviceInfo.eDeviceType = rdt;
}

/*++

Routine Description:

        Checks if a port identified by the line/Address/Call
        is already configured.

Arguments:

        dwLineId - lineID

        dwAddressID - AddressID

        dwCallID - CallID

        ppLine - address to receive the TapiLineInfo to which this
            address/call belongs.

Return Value:

        void
--*/
BOOL
fIsPortAlreadyPresent( DWORD          dwlineId,
                       DWORD          dwAddressId,
                       DWORD          dwCallId,
                       TapiLineInfo** ppLine)
{
    TapiPortControlBlock *ptpcb = RasPortsList;
    BOOL fPortPresent = FALSE;

    while(ptpcb)
    {
        if(dwlineId == ptpcb->TPCB_Line->TLI_LineId)
        {
            *ppLine = ptpcb->TPCB_Line;

            if(     PS_UNINITIALIZED != ptpcb->TPCB_State
                &&  dwCallId == ptpcb->TPCB_CallId
                &&  dwAddressId == ptpcb->TPCB_AddressId
                &&  PS_UNAVAILABLE != ptpcb->TPCB_State
                &&  (0 == 
                    (ptpcb->TPCB_dwFlags & RASTAPI_FLAG_UNAVAILABLE)))
            {
                fPortPresent = TRUE;
                break;
            }
        }

        ptpcb = ptpcb->TPCB_next;
    }

    return fPortPresent;
}

DWORD
DwLineGetDevCaps(DWORD lineId,
                 DWORD NegotiatedApiVersion,
                 DWORD NegotiatedExtVersion,
                 DWORD dwSize,
                 BYTE  *pBuffer,
                 BYTE  **ppBuffer,
                 BOOL  fUnicode)
{
    DWORD retcode = SUCCESS;

    LINEDEVCAPS *pLineDevCaps;

    ZeroMemory(pBuffer, dwSize);

    *ppBuffer = pBuffer;

    pLineDevCaps = (LINEDEVCAPS *) pBuffer;
    pLineDevCaps->dwTotalSize = dwSize;

    if(!fUnicode)
    {
        retcode = (DWORD)lineGetDevCaps (
                             RasLine,
                             lineId,
                             NegotiatedApiVersion,
                             NegotiatedExtVersion,
                             pLineDevCaps);
    }                         
    else
    {
        retcode = (DWORD)lineGetDevCapsW(
                             RasLine,
                             lineId,
                             NegotiatedApiVersion,
                             NegotiatedExtVersion,
                             pLineDevCaps);
    }

    if(     (LINEERR_STRUCTURETOOSMALL == retcode)
        ||  (pLineDevCaps->dwNeededSize > dwSize))
    {
        DWORD dwNeededSize = pLineDevCaps->dwNeededSize;

        if(0 == dwNeededSize)
        {
            RasTapiTrace("DwLineGetDevCaps: dwNeededSize == 0!!");
            goto done;
        }

        *ppBuffer = LocalAlloc(LPTR, pLineDevCaps->dwNeededSize);

        if(NULL == *ppBuffer)
        {
            retcode = GetLastError();
        }
        else
        {
            pLineDevCaps = (LINEDEVCAPS *) *ppBuffer;

            pLineDevCaps->dwTotalSize = dwNeededSize;

            if(!fUnicode)
            {
                retcode = (DWORD)lineGetDevCaps(
                                    RasLine,
                                    lineId,
                                    NegotiatedApiVersion,
                                    NegotiatedExtVersion,
                                    pLineDevCaps);
            }                                
            else
            {
                retcode = (DWORD)lineGetDevCapsW(
                                    RasLine,
                                    lineId,
                                    NegotiatedApiVersion,
                                    NegotiatedExtVersion,
                                    pLineDevCaps);
            }
        }
    }

done:
    return retcode;
}


DWORD
DwLineGetAddrCaps(DWORD lineId,
                  DWORD addressId,
                  DWORD NegotiatedApiVersion,
                  DWORD NegotiatedExtVersion,
                  DWORD dwSize,
                  BYTE  *pBuffer,
                  BYTE  **ppBuffer)
{

    DWORD retcode = SUCCESS;

    LINEADDRESSCAPS *pAddressCaps;

    ZeroMemory(pBuffer, dwSize);

    *ppBuffer = pBuffer;

    pAddressCaps = (LINEADDRESSCAPS *) pBuffer;
    pAddressCaps->dwTotalSize = dwSize;

    retcode = (DWORD) lineGetAddressCaps (
                                RasLine,
                                lineId,
                                addressId,
                                NegotiatedApiVersion,
                                NegotiatedExtVersion,
                                pAddressCaps);

    if(     (LINEERR_STRUCTURETOOSMALL == retcode)
        ||  (pAddressCaps->dwNeededSize > dwSize))
    {
        DWORD dwNeededSize = pAddressCaps->dwNeededSize;

        if(0 == dwNeededSize)
        {
            RasTapiTrace("DwLineGetAddrCaps: NeededSize==0!!");
            goto done;
        }

        *ppBuffer = LocalAlloc(LPTR, dwNeededSize);
        if(NULL == *ppBuffer)
        {
            retcode = GetLastError();
        }
        else
        {
            pAddressCaps = (LINEADDRESSCAPS *) *ppBuffer;

            pAddressCaps->dwTotalSize = dwNeededSize;

            retcode = (DWORD) lineGetAddressCaps(
                                RasLine,
                                lineId,
                                addressId,
                                NegotiatedApiVersion,
                                NegotiatedExtVersion,
                                pAddressCaps);
        }
    }

done:
    return retcode;
}

/*++

Routine Description:

        Creates RasTapiPorts given the lineID of the newline.
        Returns success without creating ports if ports already
        exist in rastapi corresponding to the line. Iterates
        over all Addresses on a line and all the calls on an
        address to create the ports.

Arguments:

        dwidDevice - ID of the device

        pcNewPorts [out] - address of the number of new ports
                           created. can be NULL.

        ppptpcbNewPorts [out] - addressreturns an array of
                                pointers to newly created
                                ports. Cannot be NULL if
                                pcNewPorts is not NULL.

Return Value:

        SUCCESS if operation was successful. error otherwise.
--*/

//
// Temp workaround
// Work around the alpha compiler bug.
//

#ifdef _ALPHA_
#pragma function(strcpy)
#endif

DWORD
dwCreateTapiPortsPerLine(DWORD                  dwidDevice,
                         DWORD                  *pcNewPorts,
                         TapiPortControlBlock   ***ppptpcbNewPorts)
{
    WORD                    i, k ;
    TapiLineInfo            *nextline                       = NULL;
    BYTE                    buffer[800] ;
    LINEADDRESSCAPS         *lineaddrcaps ;
    LINEDEVCAPS             *linedevcaps ;
    CHAR                    address[100] ;
    CHAR                    devicetype[MAX_DEVICETYPE_NAME] = {0};
    DWORD                   devicetypelength;
    CHAR                    devicename[MAX_DEVICE_NAME]     = {0};
    DWORD                   devicenamelength;
    LINEEXTENSIONID         extensionid ;
    DWORD                   totaladdresses ;
    DWORD                   totalports                      = 0;
    TapiPortControlBlock    *nextport ;
    MSG                     msg ;
    HINSTANCE               hInst;
    TapiPortControlBlock    *pports ;
    LINEINITIALIZEEXPARAMS  param ;
    DWORD                   version                         = HIGH_VERSION ;
    HLINE                   hLine;
    VARSTRING               *pvar;
    BYTE                    bvar[100];
    LINECALLPARAMS          lineparams;
    CHAR                    szMediaName [32]                = {0};
    DWORD                   dwPortUsage;
    DWORD                   dwEndPoints;
    DWORD                   dwRetcode;
    BOOL                    fModem                          = FALSE ;
    DWORD                   retcode                         = SUCCESS;
    DWORD                   dwPortIndex;
    DWORD                   fCreatedINetCfg                 = FALSE;
    CHAR                    *pszDeviceType;
    DeviceInfo              *pDeviceInfo                    = NULL;
    BOOL                    fRasEnabled;
    BOOL                    fRouterEnabled;
    BOOL                    fRouterOutboundEnabled = FALSE;
    DWORD                   NegotiatedApiVersion,
                            NegotiatedExtVersion;
    HKEY                    hkey                            = NULL;
    BOOL                    fCharModeSupported              = FALSE;
    BOOL                    fIsValid                        = FALSE;
    LPBYTE                  pBuffer                         = NULL;

    RasTapiTrace( "dwCreateTapiPortsPerLine: line %d...", dwidDevice );

    nextport = NULL;

    if ( pcNewPorts )
    {
        *pcNewPorts = 0;
    }

    i = ( WORD ) dwidDevice;

    //
    // for all lines get the addresses -> ports
    //
    if ( retcode = ( DWORD ) lineNegotiateAPIVersion (
                                   RasLine,
                                   i,
                                   LOW_VERSION,
                                   HIGH_VERSION,
                                   &NegotiatedApiVersion,
                                   &extensionid) )
    {

        RasTapiTrace (
                "dwCreateTapiPortsPerLine: "
                "lineNegotiateAPIVersion() failed. %d",
                retcode );

        goto error ;
    }

    if ( lineNegotiateExtVersion( RasLine,
                                  i,
                                  NegotiatedApiVersion,
                                  LOW_EXT_VERSION,
                                  HIGH_EXT_VERSION,
                                  &NegotiatedExtVersion))
    {
        NegotiatedExtVersion = 0;
    }

    if(     (NULL != pBuffer)
        &&  (buffer != pBuffer))
    {
        LocalFree(pBuffer);
        pBuffer = NULL;
    }

    retcode = DwLineGetDevCaps(
                    i,
                    NegotiatedApiVersion,
                    NegotiatedExtVersion,
                    sizeof(buffer),
                    buffer,
                    &pBuffer,
                    FALSE);


    if(SUCCESS != retcode)
    {

        RasTapiTrace("dwCreateTapiPortsPerLine: "
                     "lineGetDevCaps Failed. 0x%x",
                     retcode );

        goto error;
    }

    linedevcaps = (LINEDEVCAPS *) pBuffer;

    //
    // Figure out if this is a unimodem device or not
    //
    if (NegotiatedApiVersion == HIGH_VERSION)
    {
        //
        // first convert all nulls in the device class
        // string to non nulls.
        //
        DWORD  j ;
        char *temp ;

        for ( j = 0,
              temp = (CHAR *)
                     linedevcaps+linedevcaps->dwDeviceClassesOffset;
              j < linedevcaps->dwDeviceClassesSize;
              j++, temp++)

            if (*temp == '\0')
                *temp = ' ' ;

        //
        // flag those devices that have comm/datamodem as a
        // device class
        //
        if (strstr( (CHAR *)linedevcaps
                    + linedevcaps->dwDeviceClassesOffset,
                    "comm/datamodem") != NULL)
        {
            fModem = TRUE ;

            RasTapiTrace("dwCreateTapiPortsPerLine: fModem = TRUE");

        }
    }

    if (fModem)
    {
        CHAR *pszRegKeyPath;

        DWORD stringlen = (linedevcaps->dwLineNameSize
                           > MAX_DEVICE_NAME - 1
                           ? MAX_DEVICE_NAME - 1
                           : linedevcaps->dwLineNameSize);

        PRODUCT_TYPE pt = PT_SERVER;

        strcpy (devicetype, DEVICETYPE_UNIMODEM) ;

        strncpy ( devicename,
                    (CHAR *)linedevcaps
                  + linedevcaps->dwLineNameOffset,
                  stringlen) ;

        devicename[stringlen] = '\0' ;


        //
        // Get the AttachedToValue.
        //
        if ( retcode = ( DWORD ) lineOpen (
                            RasLine,
                            i,
                            &hLine,
                            NegotiatedApiVersion,
                            NegotiatedExtVersion,
                            0,
                            LINECALLPRIVILEGE_NONE,
                            LINEMEDIAMODE_DATAMODEM,
                            &lineparams))
        {
            RasTapiTrace ("dwCreateTapiPortsPerLine: "
                          "lineOpen(%d) Failed. %d",
                          i,
                          retcode );

            goto error;
        }

        pvar = (VARSTRING *) bvar;

        pvar->dwTotalSize = sizeof (bvar);

        //
        // Find Out the AttachedTo address
        //
        if ( retcode = ( DWORD ) lineGetID (
                                    hLine,
                                    i,
                                    0,
                                    LINECALLSELECT_LINE,
                                    pvar,
                                    "comm/datamodem/portname"))
        {
            lineClose (hLine);

            RasTapiTrace("dwCreateTapiPortsPerLine: "
                         "lineGetID(%d) failed. %d",
                         i,
                         retcode );
            goto error;
        }

        lineClose (hLine);

        if (    0 != pvar->dwStringSize
            &&  1 != pvar->dwStringSize)
        {
            strcpy ( address, (CHAR *) pvar + pvar->dwStringOffset );
        }
        else
        {
            RasTapiTrace(
                "dwCreateTapiPortsPerLine: lineGetID(portname) "
                "didn't return a portname for line %d",
                i);

            retcode = E_FAIL;

            goto error;
        }

        //
        // Create a device info structure for the modem and
        // insert it in the deviceinfo list
        //
        if(NULL == (pDeviceInfo = GetDeviceInfo((LPBYTE) devicename,
                                                    TRUE)))
        {
            PBYTE pTempBuffer = NULL;
            PBYTE pcaps = NULL;
            
            if(NULL == (pDeviceInfo = (DeviceInfo *) LocalAlloc(
                                      LPTR, sizeof(DeviceInfo))))
            {
                retcode = GetLastError();

                RasTapiTrace("dwCreateTapiPortsPerLine: Failed"
                             " to alloc. %d",
                             retcode);
                goto error;
            }

            //
            // Add the device info in the global list maintained
            // and fill in available information
            //
            pDeviceInfo->Next = g_pDeviceInfoList;
            g_pDeviceInfoList = pDeviceInfo;

            strcpy(
                pDeviceInfo->rdiDeviceInfo.szDeviceName,
                devicename);

            if(linedevcaps->dwBearerModes & LINEBEARERMODE_DATA)
            {
                pDeviceInfo->rdiDeviceInfo.eDeviceType = RDT_Modem
                                                       | RDT_Direct
                                                       | RDT_Null_Modem;
            }
            else
            {
                pDeviceInfo->rdiDeviceInfo.eDeviceType =
                RDT_Modem;
            }

            //
            // Get the unicode version of the devicename
            //
            pTempBuffer = LocalAlloc(LPTR, 800);
            if(NULL == pTempBuffer)
            {
                retcode = GetLastError();
                RasTapiTrace("Failed to allocate unicode name");
                goto error;
            }
            
            retcode = DwLineGetDevCaps(
                            i,
                            NegotiatedApiVersion,
                            NegotiatedExtVersion,
                            800,
                            pTempBuffer,
                            &pBuffer,
                            TRUE);

            if(ERROR_SUCCESS == retcode)
            {
                DWORD strLen = (((LINEDEVCAPS *) pBuffer)->dwLineNameSize
                                   > sizeof(WCHAR) * (MAX_DEVICE_NAME - 1)
                                   ? sizeof(WCHAR) * (MAX_DEVICE_NAME - 1)
                                   : ((LINEDEVCAPS *) pBuffer)->dwLineNameSize);

                PRODUCT_TYPE pt = PT_SERVER;

                CopyMemory((PBYTE) pDeviceInfo->rdiDeviceInfo.wszDeviceName,                
                            pBuffer +
                            ((LINEDEVCAPS *)pBuffer)->dwLineNameOffset,
                            strLen);
                            
                pDeviceInfo->rdiDeviceInfo.
                wszDeviceName[strLen/sizeof(WCHAR)] = 
                                                        L'\0';                            

                RasTapiTrace("ReadModemname=%ws, strlen=%d",
                    pDeviceInfo->rdiDeviceInfo.wszDeviceName, strlen);                                                        
            }

            if(NULL != pTempBuffer)
            {
                LocalFree(pTempBuffer);
            }

            if((pcaps != pTempBuffer) && (NULL != pcaps))
            {
                LocalFree(pcaps);
            }
        }

        pDeviceInfo->rdiDeviceInfo.dwNumEndPoints = 1;

        RasTapiTrace("**rdiDeviceInfo.dwNumEndPoints=1");

        pDeviceInfo->dwCurrentDialedInClients = 0;

        pDeviceInfo->rdiDeviceInfo.dwMinWanEndPoints
            = pDeviceInfo->rdiDeviceInfo.dwMaxWanEndPoints
            = 1;

        pDeviceInfo->rdiDeviceInfo.dwTapiLineId = dwidDevice;

        pDeviceInfo->fValid = TRUE;
        
        pszRegKeyPath = ( CHAR *) linedevcaps +
                        linedevcaps->dwDevSpecificOffset + 8;

        if ( retcode = ( DWORD ) RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                                                pszRegKeyPath,
                                                0,
                                                KEY_ALL_ACCESS,
                                                &hkey ) )
        {
            RasTapiTrace("dwCreateTapiPortsPerLine: "
                         "failed to open %s. 0x%x",
                         pszRegKeyPath,
                         retcode );

            goto error;
        }

        //
        // Per SteveFal, we should not be posting listens on
        // devices by default on workstation. The exception
        // is for NULL modems because WinCE depends on this.
        //
        if(ERROR_SUCCESS != lrGetProductType(&pt))
        {
            RasTapiTrace("Failed to get product type");
        }

        if(     (PT_WORKSTATION == pt)
            &&  (0 == (linedevcaps->dwBearerModes & LINEBEARERMODE_DATA)))
        {
            //
            // On a workstation don't listen on modems unless its a NULL
            // modem
            //
            fRasEnabled = FALSE;
        }
        else
        {
            //
            // We enable the devices for dial-in for all other cases
            // if its a server or if its a NULL modem.
            //
            fRasEnabled = TRUE;
        }

        //
        // Check to see if this device is ras enabled
        //
        retcode = (DWORD) lrIsModemRasEnabled(
                            hkey,
                            &fRasEnabled,
                            &fRouterEnabled);

        pDeviceInfo->rdiDeviceInfo.fRasEnabled = fRasEnabled;

        if(!fRasEnabled)
        {
            RasTapiTrace(
                "dwCreateTapiPortsPerLine: device %s is not"
                "enabled for DialIn",
                pDeviceInfo->rdiDeviceInfo.szDeviceName);
        }

        //
        // Get the calledid info for this modem
        //
        retcode = DwGetCalledIdInfo(NULL,
                                    pDeviceInfo);

        if(SUCCESS != retcode)
        {
            RasTapiTrace("DwGetCalledIdInfo for %s returned 0x%xd",
                         pDeviceInfo->rdiDeviceInfo.szDeviceName,
                         retcode);
        }

        pDeviceInfo->rdiDeviceInfo.fRouterEnabled = fRouterEnabled;

        if(!fRouterEnabled)
        {
            RasTapiTrace(
                "dwCreateTapiPortsPerLine: device %s is not"
                 "enabled for routing",
                 pDeviceInfo->rdiDeviceInfo.szDeviceName);
        }

        fRouterOutboundEnabled = 
        pDeviceInfo->rdiDeviceInfo.fRouterOutboundEnabled = FALSE;
        
    }
    else
    {

        //
        // The address that we are returning here is the same
        // for all addresses/calls on this line device.  We only
        // need to get it once.
        //
        NDIS_WAN_MEDIUM_SUBTYPE eMediaType;

        if (retcode = dwGetLineAddress (NegotiatedApiVersion,
                                        NegotiatedExtVersion,
                                        (LPBYTE) address,
                                        i,
                                        0,
                                        szMediaName,
                                        &eMediaType))
        {
            RasTapiTrace(
                "dwCreateTapiPortsPerLine: dwGetLineAddrss Failed. %d",
                retcode );

            goto error;
        }

        //
        // Copy the media name to devicetype
        //
        strcpy(devicetype, szMediaName);

        //
        // Get the device information from registry and insert the
        // device info structure in the global list
        //
        if (retcode = GetEndPointInfo(
                        &pDeviceInfo,
                        address,
                        FALSE,
                        eMediaType))
        {
            RasTapiTrace(
                "dwCreateTapiPortsPerLine: Failed to get "
                "deviceinformation for %s. %d",
                 szMediaName,
                 retcode );

            RasTapiTrace(
                "dwCreateTapiPortsPerLine: Enumerating all "
                "lines/addresses on this adapter");

            goto error;
        }

        //
        // Fill in the device type for this device
        //
        MapNdiswanDTtoRasDT(pDeviceInfo, eMediaType);

        //
        // Copy the device name
        //
        strcpy(devicename,
               pDeviceInfo->rdiDeviceInfo.szDeviceName);

        pDeviceInfo->rdiDeviceInfo.dwTapiLineId = dwidDevice;

        fRasEnabled = pDeviceInfo->rdiDeviceInfo.fRasEnabled;

        if (!fRasEnabled)
        {
            RasTapiTrace(
                "dwCreateTapiPortsPerLine: Device "
                "%s not enabled for DialIn",
                pDeviceInfo->rdiDeviceInfo.szDeviceName);
        }

        fRouterEnabled = pDeviceInfo->rdiDeviceInfo.fRouterEnabled;

        if (!fRouterEnabled)
        {
            RasTapiTrace(
                "dwCreateTapiPortsPerLine: Device %s not enabled "
                "for Routing",
                pDeviceInfo->rdiDeviceInfo.szDeviceName);
        }

        fRouterOutboundEnabled = 
            pDeviceInfo->rdiDeviceInfo.fRouterOutboundEnabled;
        if(!fRouterOutboundEnabled)
        {
            RasTapiTrace(
                "dwCreateTapiPortsPerLine: Device %s not enabled "
                "for outbound routing",
                pDeviceInfo->rdiDeviceInfo.szDeviceName);
        }

    }

    //
    // Get Device Specific information.  This is used by
    // the miniport to indicate if it can support character
    // mode
    //
    if (linedevcaps->dwDevSpecificSize
            >= sizeof(RASTAPI_DEV_DATA_MODES))
    {
        PRASTAPI_DEV_DATA_MODES devdatamodes =
                        (PRASTAPI_DEV_DATA_MODES)
                        ((CHAR*)linedevcaps +
                        linedevcaps->dwDevSpecificOffset);

        if (    devdatamodes->MagicCookie == MINIPORT_COOKIE
            &&  devdatamodes->DataModes & CHAR_MODE)
        {
            fCharModeSupported = TRUE;
        }
    }

    //
    // A legacy device might not be filling this field.  If so
    // give them a single address on their line.
    //
    totaladdresses = (linedevcaps->dwNumAddresses == 0)
                     ? 1
                     : linedevcaps->dwNumAddresses;

    for (k = 0; k < totaladdresses; k++)
    {
        if(     (NULL != pBuffer)
            &&  (buffer != pBuffer))
        {
            LocalFree(pBuffer);
            pBuffer = NULL;
        }

        retcode = DwLineGetAddrCaps(
                        i,
                        k,
                        NegotiatedApiVersion,
                        NegotiatedExtVersion,
                        sizeof(buffer),
                        buffer,
                        &pBuffer);

        if(SUCCESS != retcode)
        {
            RasTapiTrace(
                "dwCreateTapiPortsPerLine: lineGetAddresscaps"
                " Failed. 0x%x",
                 retcode );

            goto error ;
        }

        lineaddrcaps = (LINEADDRESSCAPS *)pBuffer;

        //
        // Some of the legacy wan miniports might not be filling
        // the NumActiveCalls correctly.  They will have at least
        // a single call on each address.
        //
        totalports += (lineaddrcaps->dwMaxNumActiveCalls == 0)
                      ? 1
                      : lineaddrcaps->dwMaxNumActiveCalls;

    }

    if ( ppptpcbNewPorts )
    {
        *ppptpcbNewPorts = LocalAlloc (
                            LPTR,
                            totalports * sizeof (TapiPortControlBlock *));

        if ( NULL == *ppptpcbNewPorts )
        {
            retcode = ERROR_OUTOFMEMORY;

            RasTapiTrace(
                "dwCreateTapiPortsPerLine: LocalAlloc Failed. %d",
                retcode );

            goto error;
        }
    }

#if DBG
    ASSERT( NULL != pDeviceInfo );
#endif

    for (k = 0; k < totaladdresses; k++)
    {
        ULONG   totalcalls;

        if(     (NULL != pBuffer)
            &&  (buffer != pBuffer))
        {
            LocalFree(pBuffer);
            pBuffer = NULL;
        }

        retcode = DwLineGetAddrCaps(
                    i,
                    k,
                    NegotiatedApiVersion,
                    NegotiatedExtVersion,
                    sizeof(buffer),
                    buffer,
                    &pBuffer);

        if(SUCCESS != retcode)
        {

            RasTapiTrace(
                        "dwCreateTapiPortsPerLine: "
                        "lineGetAddressCaps() Failed."
                        "0x%x",
                        retcode );

            goto error ;
        }

        lineaddrcaps = (LINEADDRESSCAPS *) pBuffer;

        //
        // Some of the legacy wan miniports might not be filling
        // the NumActiveCalls correctly.  They will have at least
        // a single call on each address.
        //
        totalcalls = (lineaddrcaps->dwMaxNumActiveCalls == 0)
                     ? 1
                     : lineaddrcaps->dwMaxNumActiveCalls;

        for ( ; totalcalls ; totalcalls--)
        {
            if (!fModem)
            {
                if ( pDeviceInfo->dwCurrentEndPoints >=
                        pDeviceInfo->rdiDeviceInfo.dwNumEndPoints )
                {
                    RasTapiTrace(
                        "dwCreateTapiPortsPerLine: "
                        "CurrentEndPoints=NumEndPoints=%d",
                        pDeviceInfo->dwCurrentEndPoints );

                    goto error;
                }

                dwEndPoints = pDeviceInfo->rdiDeviceInfo.dwNumEndPoints;

                RasTapiTrace ("dwCreateTapiPortsPerLine: Total = %d",
                               dwEndPoints);
            }
            else
            {
                retcode = (DWORD) dwGetPortUsage(&dwPortUsage);

                if ( retcode )
                {
                    RasTapiTrace(
                            "dwCreateTapiPortsPerLine: failed to get "
                            "modem port usage for %s. 0x%x",
                            devicename,
                            retcode );
                }
                else
                {
                    //
                    // If not rasenabled mask off the callin/router flags
                    //
                    if(!fRasEnabled)
                    {
                        dwPortUsage &= ~CALL_IN;
                    }

                    if(!fRouterEnabled)
                    {
                        dwPortUsage &= ~CALL_ROUTER;
                        
                        if(fRouterOutboundEnabled)
                        {
                            dwPortUsage |= CALL_OUTBOUND_ROUTER;
                        }
                    }

                    RasTapiTrace("dwCreateTapiPortsPerLine: "
                                 "PortUsage for %s = %x",
                                 devicename,
                                 dwPortUsage);
                }
            }

            //
            // Check to see if we already have this port
            // Also get back the information if we already
            // have the line.
            //
            if(fIsPortAlreadyPresent( i,
                        k, totalcalls - 1,
                        &nextline))
            {
                RasTapiTrace(
                    "dwCreateTapiPortsPerLine: line=%d,address=%d,"
                    "call=%d already present",
                    i,k, totalcalls - 1);

                pDeviceInfo->dwCurrentEndPoints += 1;

                continue;
            }

            if(nextline)
            {
                RasTapiTrace(
                    "dwCreateTapiPortsPerLine: line=%d already present",
                    i);

                nextline->TLI_MultiEndpoint = TRUE;
            }
            else
            {
                RasTapiTrace(
                    "dwCreateTapiPortsPerLine: Creating line=%d",
                    i);

                nextline = LocalAlloc (LPTR, sizeof ( TapiLineInfo ));
                if ( NULL == nextline )
                {
                    retcode = GetLastError();

                    RasTapiTrace (
                        "dwCreateTapiPortsPerLine: Failed to allocate"
                        " nextline. %d",
                        retcode );

                    goto error;
                }

                //
                // Insert the new Line Block into global list
                //
                nextline->TLI_Next             = RasTapiLineInfoList;
                RasTapiLineInfoList            = nextline;
                nextline->TLI_pDeviceInfo      = pDeviceInfo;
                nextline->TLI_LineId           = i ;
                nextline->TLI_LineState        = PS_CLOSED ;
                nextline->NegotiatedApiVersion = NegotiatedApiVersion;
                nextline->NegotiatedExtVersion = NegotiatedExtVersion;
                nextline->CharModeSupported    = fCharModeSupported;
            }

            //
            // Get a available TPCB from the global pool
            // this will expand the global pool if necessary
            //
            if (NULL == (nextport = GetNextAvailablePort( &dwPortIndex)))
            {
                retcode = ERROR_OUTOFMEMORY;

                RasTapiTrace (
                    "dwCreateTapiPortsPerLine: GetNextAvailablePort "
                    "Failed. %d",
                    retcode );

                goto error;
            }

            if (ppptpcbNewPorts)
            {
                (*ppptpcbNewPorts) [*pcNewPorts] = nextport;
                *pcNewPorts += 1;
                fIsValid = TRUE;
            }

            pDeviceInfo->dwCurrentEndPoints += 1;

            //
            // nextport is the TPCB for this address
            //
            nextport->TPCB_Line         = nextline ;
            nextport->TPCB_Endpoint     = INVALID_HANDLE_VALUE ;
            nextport->TPCB_AddressId    = k;
            nextport->TPCB_Signature    = CONTROLBLOCKSIGNATURE;
            nextport->TPCB_CallId       = totalcalls - 1;

            //
            // Copy over the devicetype and devicename
            //
            strcpy (nextport->TPCB_DeviceType, devicetype) ;

            //
            // For unimodem devices we need to fix up names
            //
            if (fModem)
            {
                //
                // Device Name is of the form "COM1: Hayes"
                //
                strcpy (nextport->TPCB_Address, address);

                strcpy (nextport->TPCB_DeviceName, devicename) ;

                //
                // also fix the port name to be the same as address "COM1"
                //
                strcpy (nextport->TPCB_Name, address) ;

            }
            else if(RDT_Parallel == RAS_DEVICE_TYPE(
                                        pDeviceInfo->rdiDeviceInfo.eDeviceType
                                        ))
            {
                BYTE bDevCaps[800];
                LINEDEVCAPS *pLineDevCaps = NULL;


                retcode = DwLineGetDevCaps(
                                i,
                                NegotiatedApiVersion,
                                NegotiatedExtVersion,
                                sizeof(bDevCaps),
                                bDevCaps,
                                (PBYTE *) &pLineDevCaps,
                                FALSE);


                if(SUCCESS != retcode)
                {

                    RasTapiTrace("dwCreateTapiPortsPerLine: "
                                 "lineGetDevCaps Failed. 0x%x",
                                 retcode );

                    goto error;
                }

                if(pLineDevCaps->dwLineNameSize > 0)
                {
                    ZeroMemory(nextport->TPCB_Name,
                               MAX_PORT_NAME);

                    memcpy((PBYTE) nextport->TPCB_Name,
                           (PBYTE) (((PBYTE) pLineDevCaps) +
                                   pLineDevCaps->dwLineNameOffset),
                                   (pLineDevCaps->dwLineNameSize < MAX_PORT_NAME - 1)
                                   ? pLineDevCaps->dwLineNameSize
                                   : MAX_PORT_NAME - 1);

                    RasTapiTrace("dwCreateTapiPortsPerLine: found %s",
                                 nextport->TPCB_Name);

                }
                else
                {
                    RasTapiTrace("dwCreateTapiPortsPerLine: No name found!!");

                    wsprintf(nextport->TPCB_Name, "%s%d-%d",
                             szMediaName,
                             pDeviceInfo->dwInstanceNumber,
                             pDeviceInfo->dwNextPortNumber);

                    pDeviceInfo->dwNextPortNumber += 1;
                }

                if(bDevCaps != (PBYTE) pLineDevCaps)
                {
                    LocalFree(pLineDevCaps);
                }
            }
            else
            {
                wsprintf(nextport->TPCB_Name, "%s%d-%d",
                         szMediaName,
                         pDeviceInfo->dwInstanceNumber,
                         pDeviceInfo->dwNextPortNumber);

                pDeviceInfo->dwNextPortNumber += 1;

            }

            if(!fModem)
            {

                memcpy (nextport->TPCB_Address, address, sizeof (GUID));

                if (devicename[0] != '\0')
                {
                    strcpy (nextport->TPCB_DeviceName, devicename) ;
                }

                retcode = dwGetPortUsage(&dwPortUsage);

                if (retcode)
                {
                    RasTapiTrace ("dwCreateTapiPortsPerLine: "
                                  "GetPortUsage failed. %d",
                                  retcode );
                }
                else
                {
                    if(!fRasEnabled)
                    {
                        dwPortUsage &= ~CALL_IN;
                    }

                    if(!fRouterEnabled)
                    {
                        dwPortUsage &= ~CALL_ROUTER;
                        if(fRouterOutboundEnabled)
                        {
                            dwPortUsage |= CALL_OUTBOUND_ROUTER;
                        }
                        
                    }
                }

#if 0                
                //
                // Special Case PPPoE (not really a good thing).
                // Mark the device as CALL_OUT_ONLY if nothing
                // was specified in registry.
                //
                if(     (0 == pDeviceInfo->dwUsage)
                    &&  (RDT_PPPoE == RAS_DEVICE_TYPE(
                        pDeviceInfo->rdiDeviceInfo.eDeviceType)))
                {
                    pDeviceInfo->dwUsage = CALL_OUT_ONLY;
                }   

#endif

                if(CALL_IN_ONLY & pDeviceInfo->dwUsage)
                {
                    dwPortUsage &= ~(CALL_OUT | CALL_OUT_ONLY);
                    dwPortUsage |= CALL_IN_ONLY;
                }
                else if (CALL_OUT_ONLY & pDeviceInfo->dwUsage)
                {
                    dwPortUsage &= ~(CALL_IN | CALL_ROUTER | CALL_IN_ONLY);
                    dwPortUsage |= CALL_OUT_ONLY;
                }
                
                RasTapiTrace ("dwCreateTapiPortsPerLine:"
                              " Friendly Name = %s",
                              nextport->TPCB_Name );
            }

            nextport->TPCB_State        = PS_CLOSED ;
            nextport->TPCB_Usage        = dwPortUsage;

            RasTapiTrace ("dwCreateTapiPortsPerLine: "
                          "Port Usage for %s = %d",
                          nextport->TPCB_Name,
                          dwPortUsage );

            if('\0' == pDeviceInfo->rdiDeviceInfo.szPortName[0])
            {
                strcpy(
                    pDeviceInfo->rdiDeviceInfo.szPortName,
                    nextport->TPCB_Name);
            }

            //
            // Initialize overlapped structures.
            //
            nextport->TPCB_ReadOverlapped.RO_EventType  =
                                        OVEVT_DEV_ASYNCOP;

            nextport->TPCB_WriteOverlapped.RO_EventType =
                                        OVEVT_DEV_IGNORED;

            nextport->TPCB_DiscOverlapped.RO_EventType  =
                                        OVEVT_DEV_STATECHANGE;
        } // total calls
    } // total addresses

error:

    if(     retcode
        ||  !fIsValid)
    {
        if(pcNewPorts)
        {
            *pcNewPorts = 0;
        }

        if(     ppptpcbNewPorts
            &&  *ppptpcbNewPorts)
        {
            LocalFree(*ppptpcbNewPorts);
            *ppptpcbNewPorts = NULL;
        }
    }

    if(     (NULL != buffer)
        &&  (buffer != pBuffer))
    {
        LocalFree(pBuffer);
    }

    RasTapiTrace ("dwGetFriendlyNameAndUsage: done. %d", retcode );
    RasTapiTrace(" ");

    return retcode;
}

/*++

Routine Description:

        Enumerates all lines available in the system and creates
        rastapi ports from each of the lines. Most of the work
        is done by dwCreateTapiPortsPerLine function.

Arguments:

        event - Event handle. This handle is signalled when the
            enumeration is over.

Return Value:

        SUCCESS if operation was successful. error otherwise.
--*/

DWORD
EnumerateTapiPorts (HANDLE event)
{
    WORD                    i ;
    DWORD                   lines     = 0 ;
    MSG                     msg ;
    HINSTANCE               hInst;
    TapiPortControlBlock    *pports ;
    LINEINITIALIZEEXPARAMS  param ;
    DWORD                   version   = HIGH_VERSION ;
    HKEY                    hkey      = NULL;
    DWORD                   retcode;


    RasTapiTrace("EnumerateTapiPorts");

    memset (&param, 0, sizeof (LINEINITIALIZEEXPARAMS)) ;

    param.dwOptions   = LINEINITIALIZEEXOPTION_USEHIDDENWINDOW ;
    param.dwTotalSize = sizeof(param) ;

    //
    // lineInitialize
    //
    if (lineInitializeEx (&RasLine,
                          RasInstance,
                          (LINECALLBACK) RasTapiCallback,
                          REMOTEACCESS_APP,
                          &lines,
                          &version,
                          &param))
    {

        RasTapiTrace( "EnumerateTapiPorts: lineInitializeEx Failed" );

        goto error ;
    }

    RasTapiTrace( "EnumerateTapiPorts: Number of lines = %d",
                  lines );

    if (lines == 0)
    {
        goto error;
    }

    TotalLines = lines;

    for ( i = 0; i < lines; i++ )
    {
        dwCreateTapiPortsPerLine(   i,
                                    NULL,
                                    NULL);
    }


    //
    // Calculate the number of valid ports
    //
    pports = RasPortsList;

    while ( pports )
    {
        if (pports->TPCB_State != PS_UNINITIALIZED)
            ValidPorts++;

        pports = pports->TPCB_next;
    }

    dwGetNumberOfRings( &NumberOfRings );

    //
    // Increase the reference count on our DLL
    // so it won't get unloaded out from under us.
    //
    hInst = LoadLibrary("rastapi.dll");

    g_fDllLoaded = TRUE;

    //
    // Notify the api that the initialization is done
    //
    SetEvent (event) ;

    //
    // In the pnp world, we need to hang around even if
    // there aren't any ports. ports may be added on the
    // fly
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg) ;
    }

    lineShutdown (RasLine) ;
    RasLine = 0;

    //
    // The following call atomically unloads our
    // DLL and terminates this thread.
    //
    FreeLibraryAndExitThread(hInst, SUCCESS);

error:

    if (RasLine)
    {
        lineShutdown (RasLine) ;
    }

    RasLine = 0 ;

    SetEvent (event) ;

    RasTapiTrace("EnumerateTapiPorts done");

    RasTapiTrace(" ");
    return ((DWORD)-1) ;
}

/*++

Routine Description:

        Processes the LINECALLSTATE_OFFERING event.

Arguments:

        hcall - handle of call being offerred

        ppPort - address of location where the port answering
                 the call will be returned.

        line - the line on which the call was offered.

Return Value:

        SUCCESS if operation was successful. error otherwise.
--*/
DWORD
DwProcessOfferEvent(HCALL hcall,
                    TapiPortControlBlock **ppPort,
                    TapiLineInfo *line)
{
    TapiPortControlBlock *port = NULL;

    LINECALLINFO *linecallinfo;

    BYTE buffer[1000];

    BOOL fLimitReached = FALSE;

    DWORD retcode = SUCCESS;

    memset (buffer, 0, sizeof(buffer)) ;

    linecallinfo = (LINECALLINFO *) buffer ;

    linecallinfo->dwTotalSize = sizeof(buffer) ;

    RasTapiTrace("DwProcessOfferEvent: hcall=0x%x",
                hcall);

    //
    // If line get call info fails return.
    //
    if ((retcode = lineGetCallInfo (
                            hcall,
                            linecallinfo))
                            > 0x80000000)
    {

        RasTapiTrace("DwProcessOfferEvent: LINE_CALLSTATE - "
                     "lineGetCallInfo Failed. %d",
                     retcode );

        goto done ;
    }

    //
    // Find a listening port...
    //
    if (NULL == (port = FindListeningPort(
                    line,
                    linecallinfo->dwAddressID)))
    {
        DWORD   RequestID;

        ZOMBIE_CALL *ZombieCall;

        RasTapiTrace("Couldn't find a listening port");

        ZombieCall = LocalAlloc(LPTR, sizeof(ZOMBIE_CALL));

        if (ZombieCall == NULL)
        {

            retcode = GetLastError();

            RasTapiTrace ( "DwProcessOfferEvent: LINE_CALLSTATE - "
                            "ZombieCall = NULL" );

            goto done;
        }

        //
        // There are no listening ports so we will initiate
        // a drop of the call and insert an element on our
        // zombie call list so we can deallocate the call
        // when the drop completes.
        //
        RequestID = lineDrop(hcall, NULL, 0);

        if (    RequestID == 0
            ||  RequestID > 0x80000000)
        {
            //
            // Either the drop completed sync or there was
            // an error.  Either way just deallocate the call.
            //
            lineDeallocateCall(hcall);

            RasTapiTrace("DwProcessOfferEvent: lineDeallocateCall. "
                         "RequestID = 0x%x",
                         RequestID );

        }

        ZombieCall->hCall = hcall;

        ZombieCall->RequestID = RequestID;

        InsertHeadList(&ZombieCallList, &ZombieCall->Linkage);

        retcode = E_FAIL;

        goto done;
    }

    port->TPCB_CallHandle = hcall ;

    *ppPort = port;

    //
    // for unimodem devices wait for the specified
    // number of rings
    //
    if (_stricmp (port->TPCB_DeviceType,
                DEVICETYPE_UNIMODEM) == 0)
    {

        //
        // call has already been answered by somebody
        // else and is being offered to me
        //
        if (linecallinfo->dwCallStates
                == LINECALLSTATE_CONNECTED)
        {

            RasTapiTrace ("DwProcessOfferEvent: call already "
                          "answered on %s",
                          port->TPCB_Name );

            port->TPCB_ListenState = LS_COMPLETE ;

            //
            // Complete event so that rasman calls
            // DeviceWork to proceed the listen
            // state machine.
            //
            PostNotificationCompletion(port);

        }
        else
        {
            if(0 == NumberOfRings)
            {
                port->TPCB_ListenState = LS_ACCEPT;

                RasTapiTrace(
                    "Accepting call on %s hcall = 0x%x",
                    port->TPCB_Name,
                    hcall);

                if(line->TLI_pDeviceInfo)
                {
                    line->TLI_pDeviceInfo->dwCurrentDialedInClients += 1;

                    RasTapiTrace(
                    "DwProcessOfferEvent: CurrentDialInClients=0x%x",
                    line->TLI_pDeviceInfo->dwCurrentDialedInClients);
                }
                
                port->TPCB_dwFlags |= RASTAPI_FLAG_DIALEDIN;

                port->TPCB_NumberOfRings = 0;

                PostNotificationCompletion(port);
            }
            else
            {
                RasTapiTrace(
                    "DwProcessOfferEvent: changing listenstate"
                    " of %s from %d to LS_RINGING",
                    port->TPCB_Name,
                    port->TPCB_ListenState);
                
                port->TPCB_ListenState = LS_RINGING ;
                port->TPCB_NumberOfRings = NumberOfRings ;
            }
        }
    }

    else
    {


        //
        // For other devices make transition to
        // next listening state
        //
        port->TPCB_ListenState = LS_ACCEPT ;

        RasTapiTrace("DwProcessOfferEvent: Accepting call on %s"
                     " hcall = 0x%x",
                     port->TPCB_Name,
                     hcall);

        if(line->TLI_pDeviceInfo)
        {
            line->TLI_pDeviceInfo->dwCurrentDialedInClients += 1;

            RasTapiTrace(
            "DwProcessOfferEvent: CurrentDialInClients=0x%x",
            line->TLI_pDeviceInfo->dwCurrentDialedInClients);
        }

        port->TPCB_dwFlags |= RASTAPI_FLAG_DIALEDIN;

        //
        // Complete event so that rasman calls DeviceWork
        // to proceed the listen state machine.
        //
        PostNotificationCompletion(port);
    }

done:

    RasTapiTrace("DwProcessOfferEvent 0x%x",
                 retcode);

    return retcode;

}

/*++

Routine Description:

        maps LINEDISCONNECTMODE to a raserror so that the proper
        error string can be displayed to the user.

Arguments:

        dm - DisconnectMode

Return Value:

        RasError corresponding to the disconnect mode.

--*/

DWORD
DwRasErrorFromDisconnectMode(DWORD dm)
{
    DWORD dwErr;

    switch (dm)
    {
        case LINEDISCONNECTMODE_BUSY:
        {
            dwErr = ERROR_LINE_BUSY;
            break;
        }

        case LINEDISCONNECTMODE_NOANSWER:
        {
            dwErr = ERROR_NO_ANSWER;
            break;
        }

        case LINEDISCONNECTMODE_OUTOFORDER:
        {
            dwErr = ERROR_OUTOFORDER;
            break;
        }

        case LINEDISCONNECTMODE_NODIALTONE:
        {
            dwErr = ERROR_NO_DIALTONE;
            break;
        }

        case LINEDISCONNECTMODE_CANCELLED:
        {
            dwErr = ERROR_USER_DISCONNECTION;
            break;
        }

        case LINEDISCONNECTMODE_UNREACHABLE:
        case LINEDISCONNECTMODE_BADADDRESS:
        {
            dwErr = ERROR_BAD_ADDRESS_SPECIFIED;
            break;
        }

        case LINEDISCONNECTMODE_REJECT:
        {
            dwErr = ERROR_CONNECTION_REJECT;
            break;
        }

        case LINEDISCONNECTMODE_CONGESTION:
        {
            dwErr = ERROR_CONGESTION;
            break;
        }

        case LINEDISCONNECTMODE_INCOMPATIBLE:
        {
            dwErr = ERROR_INCOMPATIBLE;
            break;
        }

        case LINEDISCONNECTMODE_NUMBERCHANGED:
        {
            dwErr = ERROR_NUMBERCHANGED;
            break;
        }

        case LINEDISCONNECTMODE_TEMPFAILURE:
        {
            dwErr = ERROR_TEMPFAILURE;
            break;
        }

        case LINEDISCONNECTMODE_BLOCKED:
        {
            dwErr = ERROR_BLOCKED;
            break;
        }

        case LINEDISCONNECTMODE_DONOTDISTURB:
        {
            dwErr = ERROR_DONOTDISTURB;
            break;
        }

        default:
        {
            dwErr = ERROR_FROM_DEVICE;
            break;
        }
    }

    return dwErr;
}

/*++

Routine Description:

        Tapi Call back function as described in win32 sdk.

Arguments:

        win32 sdk has explanation of each of the arguments.

Return Value:

        void
--*/

VOID FAR PASCAL
RasTapiCallback (HANDLE context,
        DWORD msg,
        ULONG_PTR instance,
        ULONG_PTR param1,
        ULONG_PTR param2,
        ULONG_PTR param3
        )
{
    LINECALLINFO    *linecallinfo ;
    BYTE            buffer [1000] ;
    HCALL           hcall ;
    HLINE           linehandle ;
    TapiLineInfo    *line ;
    TapiPortControlBlock *port = NULL;
    DWORD           i ;
    DWORD           retcode ;
    BOOL            fLimitReached = FALSE;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    switch (msg)
    {

    case LINE_CALLSTATE:

        hcall = (HCALL) HandleToUlong(context) ;
        line = (TapiLineInfo *) instance ;

        RasTapiTrace("RasTapicallback: linecallstate=0x%x", param1);

        //
        // If line is closed dont bother
        //
        if (line->TLI_LineState == PS_CLOSED)
        {

            RasTapiTrace ("RasTapiCallback: LINE_CALLSTATE - "
                          "linestate = PS_CLOSED" );

            break ;
        }

        //
        // A new call is coming in
        //
        if (param1 == LINECALLSTATE_OFFERING)
        {
            retcode = DwProcessOfferEvent(hcall,
                                          &port,
                                          line);

            if(ERROR_SUCCESS != retcode)
            {
                RasTapiTrace("DwProcessOfferEvent failed. 0x%x",
                             retcode);

                break;
            }
        }

        //
        // Find port by call handle
        //
        if (    (NULL == port)
            &&  ((port = FindPortByCallHandle(line, hcall)) == NULL)
            &&  (LINECALLSTATE_CONNECTED != param1))
        {

            RasTapiTrace ("RasTapiCallback: FindPortByCallHandle, "
                          "hcall = 0x%x failed",
                          hcall );

            break;
        }
        else if (   (NULL == port)
                &&  (LINECALLSTATE_CONNECTED == param1))
        {
            RasTapiTrace("Some one else has already answered "
                         "the call ");

            retcode = DwProcessOfferEvent(hcall,
                                          &port,
                                          line);

            if(     (ERROR_SUCCESS != retcode)
                ||  (NULL == port))
            {
                RasTapiTrace("DwProcessOfferEvent failed. 0x%x",
                             retcode);

                break;
            }
        }

        //
        // Call connected.
        //
        if (param1 == LINECALLSTATE_CONNECTED)
        {
            if(NULL == port->TPCB_pConnectInfo)
            {
                memset (buffer, 0, sizeof(buffer)) ;

                linecallinfo = (LINECALLINFO *) buffer ;

                linecallinfo->dwTotalSize = sizeof(buffer) ;

                if ((retcode = lineGetCallInfo (
                                        hcall,
                                        linecallinfo))
                                        > 0x80000000)
                {
                    if(     (LINEERR_STRUCTURETOOSMALL == retcode)
                        ||  (linecallinfo->dwNeededSize > sizeof(buffer)))
                    {
                        DWORD dwSizeNeeded =
                            linecallinfo->dwNeededSize;

                        //
                        // Allocate the correct size and call
                        // the api again
                        //
                        linecallinfo = LocalAlloc(LPTR,
                                                  dwSizeNeeded);

                        if(NULL == linecallinfo)
                        {
                            retcode = GetLastError();
                            break;
                        }

                        linecallinfo->dwTotalSize = dwSizeNeeded;

                        retcode = lineGetCallInfo(
                                    hcall,
                                    linecallinfo);

                    }
                }

                if(retcode > 0x80000000)
                {

                    RasTapiTrace("RasTapiCallback: LINE_CALLSTATE - "
                                 "lineGetCallInfo Failed. %d",
                                 retcode );

                    if(buffer != (PBYTE) linecallinfo)
                    {
                        LocalFree(linecallinfo);
                    }

                    break ;
                }

                //
                // Do the work to get CONNECTINFO, CALLER/CALLEDID
                //
                retcode = DwGetConnectInfo(port,
                                           hcall,
                                           linecallinfo);

                RasTapiTrace("RasTapiCallback: DwGetConnectInfo"
                            "returned 0x%x",
                            retcode);


                //
                // don't want to stop the dial from happening
                // because we couldn't the connect info
                //
                retcode = SUCCESS;

                //
                // Free the linecallinfo struct. if we allocated
                // it above
                //
                if(buffer != (PBYTE) linecallinfo)
                {
                    LocalFree(linecallinfo);
                }
            }

            RasTapiTrace("RasTapiCallback: Connected on %s",
                         port->TPCB_Name);

            if (port->TPCB_State == PS_CONNECTING)
            {

                RasTapiTrace("RasTapiCallback: Outgoing call");

                //
                // We were requesting the call. Complete event
                // so that rasman calls DeviceWork() to complete
                // the connection process.
                //
                PostNotificationCompletion(port);

            }
            else
            {
                //
                // This is a call we are asnwering. Now we can
                // indicate to rasman that the call has come in.
                // Setting listen state to LS_COMPLETE may be
                // redundant but handles the case where the answer
                // completes *after* the connection is indicated
                //
                port->TPCB_ListenState = LS_COMPLETE ;

                RasTapiTrace ("RasTapiCallback: Incoming Call");

                //
                // Complete event so that rasman knows of
                // incoming call and calls devicework.
                //
                PostNotificationCompletion(port);
            }
        }

        //
        // Failure of sorts.
        //
        if (    (param1 == LINECALLSTATE_BUSY)
            ||  (param1 == LINECALLSTATE_SPECIALINFO))
        {

            RasTapiTrace(
                    "RasTapiCallback: LINECALLSTATE."
                    " Failure. param1 = 0x%x",
                    param1 );

            //
            // If we were connecting, notify rasman to call
            // devicework so that the connection attempt can
            // be gracefully failed.
            //
            if (port->TPCB_State == PS_CONNECTING)
            {
                PostNotificationCompletion(port);
            }

        }

        //
        // Disconnection happened
        //
        if (param1 == LINECALLSTATE_DISCONNECTED)
        {
            //
            // If we were connecting, notify rasman to call
            // devicework so that the connection attempt can
            // be gracefully failed.
            //
            if (port->TPCB_State == PS_CONNECTING)
            {
                /*

                if (param2 == LINEDISCONNECTMODE_BUSY)
                {
                    port->TPCB_AsyncErrorCode = ERROR_LINE_BUSY ;
                }
                else if (   (param2 == LINEDISCONNECTMODE_NOANSWER)
                        ||  (param2 == LINEDISCONNECTMODE_OUTOFORDER))
                {
                    port->TPCB_AsyncErrorCode = ERROR_NO_ANSWER ;
                }
                else if (param2 == LINEDISCONNECTMODE_NODIALTONE)
                {
                    port->TPCB_AsyncErrorCode = ERROR_NO_DIALTONE ;
                }
                else if (param2 == LINEDISCONNECTMODE_CANCELLED)
                {
                    port->TPCB_AsyncErrorCode
                            = ERROR_USER_DISCONNECTION;
                }
                else if (param2 == LINEDISCONNECTMODE_BADADDRESS)
                {
                    port->TPCB_AsyncErrorCode
                            = ERROR_BAD_ADDRESS_SPECIFIED;
                }

                */

                port->TPCB_AsyncErrorCode =
                            DwRasErrorFromDisconnectMode((DWORD) param2);

                RasTapiTrace("RasTapiCallback: "
                             "LINECALLSTATE_DISCONNECTED "
                             "for port %s. AsyncErr = %d, "
                             "param2=0x%x",
                             port->TPCB_Name,
                             port->TPCB_AsyncErrorCode,
                             param2);

                PostNotificationCompletion(port);

            }
            else if (port->TPCB_State != PS_CLOSED)
            {
                //
                // If we were connected and got a disconnect
                // notification then this could be hardware
                // failure or a remote disconnection. Determine
                // this and save the reason away.
                //
                if (port->TPCB_State == PS_CONNECTED)
                {
                    LINECALLSTATUS *pcallstatus ;
                    BYTE buffer[200] ;

                    memset (buffer, 0, sizeof(buffer)) ;

                    pcallstatus = (LINECALLSTATUS *) buffer ;

                    pcallstatus->dwTotalSize = sizeof (buffer) ;

                    lineGetCallStatus (
                        port->TPCB_CallHandle,
                        pcallstatus) ;

                    if (pcallstatus->dwCallState ==
                            LINECALLSTATE_DISCONNECTED)
                    {
                        port->TPCB_DisconnectReason =
                                        SS_LINKDROPPED ;
                    }
                    else
                    {
                        port->TPCB_DisconnectReason =
                                        SS_HARDWAREFAILURE ;
                    }

                    RasTapiTrace("RasTapiCallback: "
                                 "lineGetCallStatus"
                                 " for %s returned 0x%x",
                                 port->TPCB_Name,
                                 pcallstatus->dwCallState );

                    RasTapiTrace ("RasTapiCallback: "
                                  "DisconnectReason "
                                  "mapped to %d",
                                  port->TPCB_DisconnectReason);

                }
                else
                {
                    port->TPCB_DisconnectReason = 0 ;
                }

                //
                // This means that we got a disconnect indication
                // in one of the other states (listening, connected,
                // etc.). We initiate our disconnect state machine.
                //
                RasTapiTrace ("RasTapiCallback: LINECALLSTATE"
                              " - initiating Port Disconnect");

                if (InitiatePortDisconnection (port) != PENDING)
                {
                    //
                    // Disconnection succeeded or failed. Both
                    // are end states for the disconnect state
                    // machine so notify rasman that a
                    // disconnection has happened.
                    //
                    RasTapiTrace ("RasTapiCallback: "
                                  "PortDisconnected sync");

                    PostDisconnectCompletion(port);
                }
            }
        }

        //
        // A busy call state - our attempt to dialout failed
        //
        if (param1 == LINECALLSTATE_BUSY)
        {

            if (port->TPCB_State == PS_CONNECTING)
            {

                port->TPCB_AsyncErrorCode = ERROR_LINE_BUSY ;

                RasTapiTrace("RasTapiCallback: Failed to initiate "
                            "connection. LINECALLSTATE_BUSY" );

                PostNotificationCompletion(port);
            }
        }

        //
        // Idle indication is useful to complete the disconnect
        // state machine.
        //
        if (param1 == LINECALLSTATE_IDLE)
        {

            if (    (   (port->TPCB_State == PS_DISCONNECTING)
                    &&  (port->TPCB_RequestId == INFINITE))
               ||   (   (port->TPCB_State == PS_OPEN )
                    &&  (port->TPCB_ListenState == LS_RINGING))
               ||   (   (PS_UNAVAILABLE == port->TPCB_State))
               ||   (   (port->TPCB_ListenState == LS_RINGING)
                    &&  (port->TPCB_State == PS_LISTENING)))
            {

                if ( LS_RINGING == port->TPCB_ListenState )
                {
                    RasTapiTrace("RasTapiCallback: Receied IDLE in "
                                 "LS_RINGING state!" );

                    port->TPCB_DisconnectReason = SS_HARDWAREFAILURE;
                }

                //
                // IDLE notification came after LineDrop Succeeded
                // so safe to deallocate the call
                //
                if(PS_UNAVAILABLE != port->TPCB_State)
                {
                    port->TPCB_State = PS_OPEN ;
                }

                RasTapiTrace(
                    "RasTapiCallback: Received Idle. "
                     "Deallocating for %s, callhandle = 0x%x",
                     port->TPCB_Name,
                     port->TPCB_CallHandle );

                lineDeallocateCall (port->TPCB_CallHandle) ;

                port->TPCB_CallHandle = (HCALL) -1 ;

                port->IdleReceived = FALSE;

                PostDisconnectCompletion(port);
            }
            else
            {
                //
                // We have not yet disconnected so do not
                // deallocate call yet.  This will be done
                // when the disconnect completes.
                //
                port->IdleReceived = TRUE;
            }
        }

    break ;


    case LINE_REPLY:


        RasTapiTrace("LINE_REPLY. param1=0x%x", param1);

        //
        // This message is sent to indicate completion of an
        // asynchronous API.Find for which port the async request
        // succeeded. This is done by searching for pending
        // request id that is also provided in this message.
        //
        if ((port = FindPortByRequestId ((DWORD) param1)) == NULL)
        {
            ZOMBIE_CALL *ZombieCall =
                    (ZOMBIE_CALL*)ZombieCallList.Flink;

            //
            // If this is the completion of a drop that is
            // in the zombie call state just deallocate
            // the call.
            //
            while ((PLIST_ENTRY)ZombieCall != &ZombieCallList)
            {

                if (param1 = ZombieCall->RequestID)
                {
                    RasTapiTrace (
                        "RasTapiCallback: LINE_REPLY "
                        "Deallocatingcall. hcall = 0x%x",
                        ZombieCall->hCall );

                    lineDeallocateCall(ZombieCall->hCall);

                    RemoveEntryList(&ZombieCall->Linkage);

                    LocalFree(ZombieCall);

                    break;
                }

                ZombieCall = (ZOMBIE_CALL*)
                             ZombieCall->Linkage.Flink;
            }

            break ;
        }
        else
        ;

        if (port->TPCB_SendRequestId == param1)
        {

            //
            // A char mode send has completed.  Clean up
            // the buffer and notify rasman.
            //
            port->TPCB_SendRequestId = INFINITE;

            //
            // Free the send desc
            //
            LocalFree(port->TPCB_SendDesc);
            port->TPCB_SendDesc = NULL;


        }
        else if (port->TPCB_RecvRequestId == param1)
        {

            //
            // A char mode recv has completed.
            //
            port->TPCB_RecvRequestId = INFINITE;

            //
            // If possible notify rasman
            //
            if (port->TPCB_State == PS_CONNECTED)
            {
                //
                // Copy into circular buffer
                //
                CopyDataToFifo(port->TPCB_RecvFifo,
                   ((PRASTAPI_DEV_SPECIFIC)
                   (port->TPCB_RecvDesc))->Data,
                   ((PRASTAPI_DEV_SPECIFIC)
                   (port->TPCB_RecvDesc))->DataSize);

            }

            PostNotificationCompletion( port );

            //
            // Free the recv desc
            //
            LocalFree(port->TPCB_RecvDesc);
            port->TPCB_RecvDesc = NULL;
        }
        else if (port->TPCB_ModeRequestId == param1)
        {
            LocalFree(port->TPCB_ModeRequestDesc);
            port->TPCB_ModeRequestDesc = NULL;
        }
        else
        {
            //
            // Set request id to invalid.
            //
            port->TPCB_RequestId = INFINITE ;

            if (    (PS_DISCONNECTING == port->TPCB_State)
                ||  (PS_UNAVAILABLE == port->TPCB_State))
            {
                //
                // lineDrop completed. Note that we ignore
                // the return code in param2. This is because
                // we cant do anything else.
                //
                if (port->IdleReceived)
                {
                    //
                    // We received IDLE notification before/during
                    // disconnect so deallocate this call
                    //
                    port->IdleReceived = FALSE;

                    RasTapiTrace (
                        "RasTapiCallback: Idle Received for port %s",
                        port->TPCB_Name );

                    if(PS_UNAVAILABLE != port->TPCB_State)
                    {
                        RasTapiTrace(
                            "RasTapiCallback: changing state"
                             " of %s. %d -> %d",
                             port->TPCB_Name,
                             port->TPCB_State,
                             PS_OPEN );

                        port->TPCB_State = PS_OPEN ;
                    }

                    RasTapiTrace(
                        "RasTapiCallback: lineDeallocateCall "
                         "for %s,hcall = 0x%x",
                         port->TPCB_Name,
                         port->TPCB_CallHandle );

                    lineDeallocateCall (port->TPCB_CallHandle) ;

                    port->TPCB_CallHandle = (HCALL) -1 ;

                    PostDisconnectCompletion(port);

                }
                else
                {
                    //
                    // wait for idle message before signalling
                    // disconnect
                    //
                    ;
                }

                break ;
            }

            //
            // Some other api completed
            //
            if (param2 == SUCCESS)
            {
                //
                // Success means take no action - unless we are
                // listening in which case it means move to the
                // next state - we simply set the event that will
                // result in a call to DeviceWork() to make the
                // actual call for the next state
                //
                if (port->TPCB_State != PS_LISTENING)
                {
                    break ;
                }

                //
                // Proceed to the next listening sub-state
                //
                if (port->TPCB_ListenState == LS_ACCEPT)
                {

                    RasTapiTrace(
                        "RasTapiCallback: LINE_REPLY. Changing "
                         "Listen state for %s from %d -> %d",
                         port->TPCB_Name,
                         port->TPCB_ListenState,
                         LS_ANSWER );

                    port->TPCB_ListenState =  LS_ANSWER ;

                    PostNotificationCompletion(port);
                }
                else if (port->TPCB_ListenState == LS_ANSWER)
                {

                    RasTapiTrace(
                        "RasTapiCallback: LINE_REPLY. Changing "
                         "Listen state for %s from %d -> %d",
                         port->TPCB_Name,
                         port->TPCB_ListenState,
                         LS_COMPLETE );

                    port->TPCB_ListenState = LS_COMPLETE ;


                    //
                    // Don't post completion notification in this case.
                    // We should post the completion when the connected
                    // indication is given. Otherwise we may end up
                    // calling lineGetId before it has give a callstate
                    // connected to us.
                    //
                    // PostNotificationCompletion(port);
                    RasTapiTrace(
                        "**** Not posting completion for lineAnswer ***");
                }
            }
            else
            {
                //
                // For connecting and listening ports this means
                // the attempt failed because of some error
                //
                if (port->TPCB_State == PS_CONNECTING)
                {
                    {
                        if (    LINEERR_INUSE == param2
                            ||  LINEERR_CALLUNAVAIL == param2)
                        {
                            //
                            // this means that some other tapi
                            // device is using this port
                            //
                            port->TPCB_AsyncErrorCode =
                                            ERROR_LINE_BUSY;

                            RasTapiTrace(
                                "RasTapiCallback: Connect Attempt "
                                 "on %s failed. 0x%x",
                                 port->TPCB_Name,
                                 param2 );


                            RasTapiTrace (
                                "RasTapiCallback: LINE_REPLY. "
                                "AsyncErr = %d",
                                port->TPCB_AsyncErrorCode );


                        }
                        else
                        {

                            port->TPCB_AsyncErrorCode =
                                        ERROR_PORT_OR_DEVICE ;

                            RasTapiTrace(
                                "RasTapiCallback: ConnectAttempt "
                                 "on %s failed. 0x%x",
                                 port->TPCB_Name,
                                 param2 );

                            RasTapiTrace(
                                "RasTapiCallback: LINE_REPLY. "
                                "AsyncErr = %d",
                                port->TPCB_AsyncErrorCode );

                        }

                        PostNotificationCompletion(port);
                    }
                }
                else if (port->TPCB_State == PS_LISTENING)
                {
                    //
                    // Because ACCEPT may not be supported by
                    // the device - treat error as success
                    //
                    if (port->TPCB_ListenState == LS_ACCEPT)
                    {


                        RasTapiTrace(
                            "RasTapiCallback: Changing Listen "
                            "State for %s from %d -> %d",
                            port->TPCB_Name,
                            port->TPCB_ListenState,
                            LS_ANSWER );

                        port->TPCB_ListenState =  LS_ANSWER ;

                    }
                    else
                    {

                        RasTapiTrace(
                            "RasTapiCallback: Changing "
                             "Listen State for %s from %d -> %d."
                             "param2=0x%x",
                             port->TPCB_Name,
                             port->TPCB_ListenState,
                             LS_ERROR,
                             param2);

                        port->TPCB_ListenState =  LS_ERROR ;
                    }

                    PostNotificationCompletion(port);
                }

                //
                // Some other API failed, we dont know and
                // we dont care. Ignore.
                //
                else if (port->TPCB_State != PS_CLOSED)
                {
                    ;
                }
            }
        }

        break ;

    case LINE_CLOSE:

        RasTapiTrace("LINE_CLOSE. line=0x%x", instance);

        //
        // Typically sent when things go really wrong.
        // Find which line is indication came for.
        //
        line = (TapiLineInfo *) instance ;

        //
        // if line not found or if it is closed just return
        //
        if (    (line == NULL)
            ||  (line->TLI_LineState == PS_CLOSED))
        {
            break ;
        }

        //
        // For every port that is on the line - open the
        // line again and signal hw failure
        //
        port = RasPortsList;

        while ( port )
        {
            //
            // Skip ports that arent initialized
            //
            if (port->TPCB_State == PS_UNINITIALIZED)
            {
                port = port->TPCB_next;

                continue ;
            }

            if (port->TPCB_Line == line)
            {
                if (retcode = lineOpen (
                        RasLine,
                        port->TPCB_Line->TLI_LineId,
                        &port->TPCB_Line->TLI_LineHandle,
                        port->TPCB_Line->NegotiatedApiVersion,
                        port->TPCB_Line->NegotiatedExtVersion,
                        (DWORD_PTR) port->TPCB_Line,
                        LINECALLPRIVILEGE_OWNER,
                        port->TPCB_Line->TLI_MediaMode,
                        NULL))
                {
                    RasTapiTrace(
                        "RasTapiCallback: LINECLOSE:"
                        " lineOpen Failed. 0x%x",
                        retcode );
                }

                //
                // Set monitoring of rings
                //
                lineSetStatusMessages (
                    port->TPCB_Line->TLI_LineHandle,
                    LINEDEVSTATE_RINGING, 0) ;

                if(0 == port->TPCB_AsyncErrorCode)
                {
                    port->TPCB_AsyncErrorCode = ERROR_FROM_DEVICE ;
                }

                port->TPCB_DisconnectReason = SS_HARDWAREFAILURE;

                port->TPCB_CallHandle =  (HCALL) -1 ;

                port->TPCB_ListenState = LS_ERROR ;

                RasTapiTrace(
                    "RasTapiCallback: LINECLOSE - "
                    "Signalling HW Failure for %s",
                    port->TPCB_Name );

                RasTapiTrace(
                    "RasTapiCallback: LINECLOSE - "
                    "AsyncErr = %d",
                    port->TPCB_AsyncErrorCode );

                PostDisconnectCompletion(port);
            }

            port = port->TPCB_next;

        }
        break ;

    case LINE_LINEDEVSTATE:

        RasTapiTrace("LINE_LINEDEVSTATE. param1=0x%x, line=0x%x", param1, instance);

        //
        // we are only interested in ringing message
        //
        if (param1 != LINEDEVSTATE_RINGING)
        {
            break ;
        }

        //
        // Find which line is indication came for.
        //
        line = (TapiLineInfo *) instance ;

        //
        // if line not found or if it is closed
        // just return
        //
        if (    (line == NULL)
            ||  (line->TLI_LineState == PS_CLOSED))
        {
            break ;
        }

        //
        // get the port from the line
        //
        port = RasPortsList;
        while ( port )
        {
            //
            // Skip ports that arent initialized
            //
            if (port->TPCB_State == PS_UNINITIALIZED)
            {
                port = port->TPCB_next;
                continue ;
            }

            if (    (port->TPCB_Line == line)
                &&  (port->TPCB_State == PS_LISTENING)
                &&  (port->TPCB_ListenState == LS_RINGING))
            {


                if(port->TPCB_NumberOfRings > 0)
                {
                    //
                    // count down the rings
                    //
                    port->TPCB_NumberOfRings -= 1 ;
                }

                RasTapiTrace("RasTapiCallback: LINEDEVSTATE - "
                            "Number of rings for %s = %d",
                            port->TPCB_Name,
                            port->TPCB_NumberOfRings);

                //
                // if the ring count has gone down to zero
                // this means that we should pick up the call.
                //
                if (port->TPCB_NumberOfRings == 0)
                {
                    RasTapiTrace (
                        "RasTapiCallback: Changing Listen "
                        "State for %s from %d -> %d",
                        port->TPCB_Name,
                        port->TPCB_ListenState,
                        LS_ACCEPT );

                    if(line->TLI_pDeviceInfo)
                    {
                        line->TLI_pDeviceInfo->dwCurrentDialedInClients
                                += 1;

                        RasTapiTrace(
                        "CurrentDialInClients=0x%x",
                        line->TLI_pDeviceInfo->dwCurrentDialedInClients);
                    }
                    
                    port->TPCB_dwFlags |= RASTAPI_FLAG_DIALEDIN;
                    
                    port->TPCB_ListenState = LS_ACCEPT ;

                    //
                    // Complete event so that rasman calls
                    // DeviceWork to proceed the listen state
                    // machine.
                    //
                    PostNotificationCompletion(port);
                }

                break ;
            }

            port = port->TPCB_next;
        }

    break ;

    case LINE_CREATE:
    {


        DWORD                   dwError;
        PortMediaInfo           *pmiNewDevice = NULL;
        DWORD                   cNewPorts,
                                iNewPort;
        DWORD                   adwPortsCreated[ LEGACY_MAX ] = {0};
        TapiPortControlBlock    *ptpcbPort  = NULL,
                                **pptpcbNewPorts = NULL;
        //
        // A new device was added. Create a new port
        // and add it to rastapi datastructures
        //
        RasTapiTrace ("RasTapiaCallback: LINE_CREATE");

        TotalLines++;

        dwError = dwCreateTapiPortsPerLine(
                        (DWORD) param1,
                        &cNewPorts,
                        &pptpcbNewPorts);

        if ( dwError )
        {

            RasTapiTrace ("RasTapiCallback: "
                          "dwCreateTapiPortsPerLine "
                          "Failed. 0x%x",
                          dwError );

            break;
        }

        RasTapiTrace ("RasTapiCallback: cNewPorts = %d",
                      cNewPorts );

        for (iNewPort = 0; iNewPort < cNewPorts; iNewPort++)
        {
            ptpcbPort = pptpcbNewPorts [ iNewPort ];

            //
            // Allocate a PortMediaInfo Structure and fill
            // it with the information about the new device
            // added. This structure will be freed by rasman.
            //
            pmiNewDevice = LocalAlloc (
                            LPTR,
                            sizeof (PortMediaInfo));

            if (NULL == pmiNewDevice)
            {
                break;
            }

            strcpy (pmiNewDevice->PMI_Name, ptpcbPort->TPCB_Name);

            pmiNewDevice->PMI_Usage = ptpcbPort->TPCB_Usage;

            strcpy (pmiNewDevice->PMI_DeviceType,
                     ptpcbPort->TPCB_DeviceType);

            strcpy (pmiNewDevice->PMI_DeviceName,
                    ptpcbPort->TPCB_DeviceName);

            pmiNewDevice->PMI_LineDeviceId =
                        ptpcbPort->TPCB_Line->TLI_LineId;

            pmiNewDevice->PMI_AddressId =
                        ptpcbPort->TPCB_AddressId;

            pmiNewDevice->PMI_pDeviceInfo =
                    ptpcbPort->TPCB_Line->TLI_pDeviceInfo;

            RasTapiTrace("RasTapiCallback: New Device Created - %s",
                        (ptpcbPort->TPCB_DeviceName
                        ? ptpcbPort->TPCB_DeviceName
                        : "NULL!"));

            PostNotificationNewPort ( pmiNewDevice );
        }

        LocalFree ( pptpcbNewPorts );

        break;
    }

    case LINE_REMOVE:
    {
        TapiPortControlBlock *port = RasPortsList;

        RasTapiTrace ("RasTapiCallback: LINE_REMOVE");

        PostNotificationRemoveLine((DWORD) param1);

        /*
        while ( port )
        {
            if ( port->TPCB_Line->TLI_LineId == param1 )
            {
                PostNotificationRemoveLine(param1);

                RasTapiTrace ("RasTapiCallback: Marking port %s "
                              "for removal\n",
                              port->TPCB_DeviceName);

                //
                // Mark the port for removal. The port will be
                // removed when it is closed.
                //

                RasTapiTrace(
                        "RasTapiCallback: Changing state of %s "
                        "from %d -> %d",
                        port->TPCB_Name,
                        port->TPCB_State,
                        PS_UNAVAILABLE );

                port->TPCB_State = PS_UNAVAILABLE ;
            }

            port = port->TPCB_next;
        } */

        break;
    }

    case LINE_DEVSPECIFIC:
    {

        DWORD   Status;

        hcall = (HCALL) HandleToUlong(context) ;
        line = (TapiLineInfo *) instance ;

        if(NULL == line)
        {
            break;
        }

        RasTapiTrace("RasTapiCallback:LINE_DEVSPECIFIC");

        //
        // If line is closed dont bother
        //
        if (line->TLI_LineState == PS_CLOSED)
        {
            break ;
        }

        //
        // Locate the ras port for this call
        //

        memset (buffer, 0, sizeof(buffer)) ;

        linecallinfo = (LINECALLINFO *) buffer ;

        linecallinfo->dwTotalSize = sizeof(buffer) ;

        //
        // If line get call info fails return.
        //
        if ((Status = lineGetCallInfo(
                        hcall,
                        linecallinfo))
                    > 0x80000000)
        {
                RasTapiTrace(
                    "RastapiCallback: lineGetCallInfo "
                    "failed. 0x%x. hcall=0x%x, line=0x%x",
                    Status,
                    hcall,
                    line );

                break ;
        }

        //
        // Locate the ras port for this call
        //
        if ((port = FindPortByAddressId (line,
                       linecallinfo->dwAddressID)) == NULL)
        {

            RasTapiTrace("RasTapiCallback: Port not found! "
                         "line=0x%x, AddressID=0x%x",
                         line,
                         linecallinfo->dwAddressID );

            //
            // Did not find a ras port for the call. Ignore it.
            //
            break ;
        }

        switch (param1)
        {
            case  RASTAPI_DEV_RECV:
                {
                    PRASTAPI_DEV_SPECIFIC TapiRecv;
                    DWORD   TapiRecvSize;
                    DWORD   requestid;

                    TapiRecvSize = sizeof(RASTAPI_DEV_SPECIFIC) + 1500;

                    if ((TapiRecv = LocalAlloc(
                                LPTR, TapiRecvSize)) == NULL)
                    {
                        RasTapiTrace(
                                "RasTapiCallback: RASTAPI_DEV_RECV. "
                                 "LocalAlloc failed. %d",
                                 GetLastError() );

                        break;
                    }

                    TapiRecv->Command = RASTAPI_DEV_RECV;
                    TapiRecv->DataSize = 1500;

                    port->TPCB_RecvDesc = TapiRecv;

                    port->TPCB_RecvRequestId =
                    lineDevSpecific(port->TPCB_Line->TLI_LineHandle,
                                    port->TPCB_AddressId,
                                    port->TPCB_CallHandle,
                                    TapiRecv,
                                    TapiRecvSize);

                    if (port->TPCB_RecvRequestId == 0)
                    {

                        //
                        // Copy the memory into the circular buffer
                        //
                        CopyDataToFifo(port->TPCB_RecvFifo,
                                       TapiRecv->Data,
                                       TapiRecv->DataSize);

                        port->TPCB_RecvDesc = NULL;

                        LocalFree(TapiRecv);

                    }
                    else if (port->TPCB_RecvRequestId > 0x80000000)
                    {
                        RasTapiTrace(
                                "RasTapiCallback: lineDevSpecific "
                                 "failed. 0x%x",
                                 port->TPCB_RecvRequestId );

                        port->TPCB_RecvDesc = NULL;

                        port->TPCB_RecvRequestId = INFINITE;

                        LocalFree(TapiRecv);

                    }
                    else
                    {
                    }
                }
                break;

            default:
                break;
        }
    }

    break;

    case LINE_ADDRESSSTATE:
    case LINE_CALLINFO:
    case LINE_DEVSPECIFICFEATURE:
    case LINE_GATHERDIGITS:
    case LINE_GENERATE:
    case LINE_MONITORDIGITS:
    case LINE_MONITORMEDIA:
    case LINE_MONITORTONE:
    case LINE_REQUEST:
    default:

        //
        // All unhandled unsolicited messages.
        //
        ;
    }

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;
}


/*++

Routine Description:

        Find a rastapi port given the AddressID

Arguments:

        line - the lineinfo structure of the line this
            address id one

        addid - AddressID of the address.

Return Value:

        Pointer to the control block of the port if found.
        NULL otherwise.

--*/

TapiPortControlBlock *
FindPortByAddressId (TapiLineInfo *line, DWORD addid)
{
    DWORD   i ;
    TapiPortControlBlock *port = RasPortsList;

    while ( port )
    {

        if (    (port->TPCB_AddressId == addid)
            &&  (port->TPCB_Line == line))
        {
            return port ;
        }

        port = port->TPCB_next;
    }

    return NULL ;
}

/*++

Routine Description:

        Find a rastapi port given the Address

Arguments:

        address

Return Value:

        Pointer to the control block of the port if found.
        NULL otherwise.

--*/

TapiPortControlBlock *
FindPortByAddress (CHAR *address)
{
    DWORD   i ;
    TapiPortControlBlock *port = RasPortsList;

    while ( port )
    {

        if (_stricmp (port->TPCB_Address,
            address) == 0)
        {
            return port ;
        }

        port = port->TPCB_next;
    }

    return NULL ;
}


/*++

Routine Description:

        Find a rastapi port given the Address and name

Arguments:

        address

        name

Return Value:

        Pointer to the control block of the port if found.
        NULL otherwise.

--*/

TapiPortControlBlock *
FindPortByAddressAndName (CHAR *address, CHAR *name)
{
    DWORD   i ;
    TapiPortControlBlock *port = RasPortsList;

    while ( port )
    {

        if (    (_stricmp (
                    port->TPCB_Address,
                    address) == 0)
            &&  (_strnicmp (
                    port->TPCB_Name,
                    name,
                    MAX_PORT_NAME-1) == 0))
        {
            return port ;
        }

        port = port->TPCB_next;
    }

    return NULL ;
}


/*++

Routine Description:

        Find a rastapi port given the request id

Arguments:

        reqid

Return Value:

        Pointer to the control block of the port if found.
        NULL otherwise.

--*/

TapiPortControlBlock *
FindPortByRequestId (DWORD reqid)
{
    DWORD   i ;
    TapiPortControlBlock *port = RasPortsList;


    while ( port )
    {
        if (port->TPCB_RequestId == reqid)
        {
            return port ;
        }
        else if ( port->TPCB_CharMode )
        {
            if (    port->TPCB_SendRequestId == reqid
                ||  port->TPCB_RecvRequestId == reqid
                ||  port->TPCB_ModeRequestId == reqid )
            {

                return port;
            }

        }

        port = port->TPCB_next;
    }

    return NULL ;
}


/*++

Routine Description:

        Find a rastapi port given the call handle

Arguments:

        line - line control block of the line on which
            the call was received/made.

        callhandle

Return Value:

        Pointer to the control block of the port if found.
        NULL otherwise.

--*/
TapiPortControlBlock *
FindPortByCallHandle(TapiLineInfo *line, HCALL callhandle)
{
    DWORD   i ;
    TapiPortControlBlock *port = RasPortsList;

    while ( port )
    {
        if (    (port->TPCB_CallHandle == callhandle)
            &&  (port->TPCB_Line == line))
        {
            return port ;
        }

        port = port->TPCB_next;
    }

    return NULL ;
}

/*++

Routine Description:

        Finds a port of with the specified addressid
        which is in a listening state

Arguments:

        line - line control block of the line to which this
            address belongs.

        AddressID

Return Value:

        Pointer to the control block of the port if found.
        NULL otherwise.

--*/

TapiPortControlBlock *
FindListeningPort(TapiLineInfo *line, DWORD AddressID)
{
    DWORD   i ;
    TapiPortControlBlock *port = RasPortsList;

    while ( port )
    {
        if (    (port->TPCB_Line == line)
            &&  (line->TLI_LineState == PS_LISTENING)
            &&  (port->TPCB_State == PS_LISTENING)
            &&  (port->TPCB_ListenState == LS_WAIT))
        {
            port->TPCB_AddressId = AddressID;
            return port ;
        }

        port = port->TPCB_next;
    }

    return NULL ;
}

/*++

Routine Description:

        Finds a line control block  of with the specified
        addressid which is in a listening state

Arguments:

        linehandle

Return Value:

        Pointer to the control block of the line if found.
        NULL otherwise.

--*/

TapiLineInfo *
FindLineByHandle (HLINE linehandle)
{
    DWORD i ;
    TapiLineInfo *line = RasTapiLineInfoList;

    while ( line )
    {
        if (line->TLI_LineHandle == linehandle)
        {
            return line ;
        }

        line = line->TLI_Next;
    }

    return NULL ;
}

/*++

Routine Description:

        Posts a disconnect event notification to rasmans
        completion port.

Arguments:

        pointer to the port control block on which the
        disconnect happened.

Return Value:

        void.

--*/

VOID
PostDisconnectCompletion(
    TapiPortControlBlock *port
    )
{
    BOOL fSuccess;

    fSuccess = PostQueuedCompletionStatus(
                 port->TPCB_IoCompletionPort,
                 0,
                 port->TPCB_CompletionKey,
                 (LPOVERLAPPED)&port->TPCB_DiscOverlapped);

    if (!fSuccess)
    {
        DWORD dwerror = GetLastError();

        RasTapiTrace(
                "PostDisconnectCompletion:"
                "PostQueuedCompletionStatus failed. 0x%x",
                dwerror);
    }
}


/*++

Routine Description:

        Posts a notification to rasmans completion port
        indicating the completion of an asynchronous
        operation.

Arguments:

        pointer to the port control block on which the
        asynchronous operation completed.

Return Value:

        void.

--*/

VOID
PostNotificationCompletion(
    TapiPortControlBlock *port
    )
{
    BOOL fSuccess;

    fSuccess = PostQueuedCompletionStatus(
                 port->TPCB_IoCompletionPort,
                 0,
                 port->TPCB_CompletionKey,
                 (LPOVERLAPPED)&port->TPCB_ReadOverlapped);

    if (!fSuccess)
    {
        DWORD dwerror = GetLastError();

        RasTapiTrace(
                "PostNotificationCompletion:"
                "PostQueuedCompletionStatus failed. 0x%x",
                dwerror);
    }
}

/*++

Routine Description:

        Posts a notification to rasmans completion port
        indicating that a new port was created. For PnP

Arguments:

        pointer to the media control block corresponding
        to the port that was created. Look in
        ..\routing\ras\inc\media.h for the definition
        of PortMediaInfo structure.

Return Value:

        void.

--*/

VOID
PostNotificationNewPort(
    PortMediaInfo *pmiNewPort
    )
{
    BOOL fSuccess;
    PRAS_OVERLAPPED pOvNewPortNotification;
    PNEW_PORT_NOTIF pNewPortNotif;

    RasTapiTrace ("PostNotificationNewPort %s",
                    pmiNewPort->PMI_Name );

    pOvNewPortNotification = LocalAlloc (
                        LPTR, sizeof ( RAS_OVERLAPPED));

    if (NULL == pOvNewPortNotification)
    {
        RasTapiTrace ("PostNotificationNewPort: "
                      "Failed to allocate ov.");
        goto done;
    }

    pNewPortNotif = LocalAlloc (
                        LPTR, sizeof (NEW_PORT_NOTIF) );

    if (NULL == pNewPortNotif)
    {
        RasTapiTrace ("PostNotificationNewPort: Failed "
                    "to allocate NEW_PORT_NOTIF");
        LocalFree(pOvNewPortNotification);
        goto done;
    }

    pNewPortNotif->NPN_pmiNewPort = (PVOID) pmiNewPort;

    strcpy (
        pNewPortNotif->NPN_MediaName,
        "rastapi");

    pOvNewPortNotification->RO_EventType = OVEVT_DEV_CREATE;
    pOvNewPortNotification->RO_Info      = (PVOID) pNewPortNotif;

    fSuccess = PostQueuedCompletionStatus(
                g_hIoCompletionPort,
                0,
                0,
                (LPOVERLAPPED) pOvNewPortNotification);

    if (!fSuccess)
    {
        RasTapiTrace(
            "PostNotificationNewPort: Failed"
            " to Post notification. %d",
            GetLastError());

        LocalFree(pOvNewPortNotification);

        LocalFree(pNewPortNotif);
            
    }
    else
    {
        RasTapiTrace(
            "PostNotificationNewPort: "
            "Posted 0x%x",
            pOvNewPortNotification );
    }

done:
    return;

}

/*++

Routine Description:

        Posts a notification to rasmans completion port
        indicating that a port was removed. For PnP.

Arguments:

        Pointer to the port control block of the port that
        was removed.

Return Value:

        void.

--*/

VOID
PostNotificationRemoveLine (
            DWORD dwLineId
        )
{
    PRAS_OVERLAPPED pOvRemovePortNotification;
    PREMOVE_LINE_NOTIF pRemovePortNotification;

    pOvRemovePortNotification = LocalAlloc (
                                LPTR,
                                sizeof (RAS_OVERLAPPED));

    RasTapiTrace ("PostNotificationRemoveLine: %d",
                  dwLineId);

    if ( NULL == pOvRemovePortNotification )
    {
        RasTapiTrace("PostNotificationRemovePort: "
                     "failed to allocate",
                     GetLastError());
        goto done;
    }

    pRemovePortNotification = LocalAlloc(
                                LPTR,
                                sizeof(REMOVE_LINE_NOTIF));

    if(NULL == pRemovePortNotification)
    {
        RasTapiTrace("PostNotificationRemovePort: "
                     "failed to allocate",
                     GetLastError());

        LocalFree(pOvRemovePortNotification);

        goto done;
    }

    pRemovePortNotification->dwLineId = dwLineId;

    pOvRemovePortNotification->RO_EventType = OVEVT_DEV_REMOVE;
    pOvRemovePortNotification->RO_Info = (PVOID)
                                          pRemovePortNotification;

    if ( !PostQueuedCompletionStatus (
                g_hIoCompletionPort,
                0,
                0,
                (LPOVERLAPPED) pOvRemovePortNotification ))
    {
        RasTapiTrace("PostNotificationRemovePort: Failed"
                     " to post the notification. %d",
                     GetLastError());

        LocalFree(pOvRemovePortNotification);                     
    }
    else
    {
        RasTapiTrace("PostNotificationRemovePort:"
                     " Posted 0x%x",
                     pOvRemovePortNotification );
    }


done:
    return;

}

/*++

Routine Description:

        Removes a port from the global ports list. For PnP

Arguments:

        Pointer to the port control block of the port that
        is being removed.

Return Value:

        SUCCESS.

--*/

DWORD
dwRemovePort ( TapiPortControlBlock * ptpcb )
{

    TapiPortControlBlock *pport;

    GetMutex ( RasTapiMutex, INFINITE );

    if ( NULL == ptpcb )
    {
        goto done;
    }

    RasTapiTrace ("dwRemovePort: %s",
                  ptpcb->TPCB_Name );

    if ( RasPortsList == ptpcb )
    {
        RasPortsList = RasPortsList->TPCB_next;

        LocalFree ( ptpcb );

        goto done;

    }

    //
    // Remove this port from the global list
    //
    pport = RasPortsList;

    while (pport->TPCB_next)
    {
        if ( ptpcb == pport->TPCB_next )
        {
            pport->TPCB_next = pport->TPCB_next->TPCB_next;

            LocalFree (ptpcb);

            break;
        }

        pport = pport->TPCB_next;
    }

done:

    FreeMutex ( RasTapiMutex );

    return SUCCESS;
}

/*++

Routine Description:

        Creates ports represented by the guid. For PnP

Arguments:

        pbGuidAdapter - Guid of the adapter corresponding
            to the ports that are to be created.

        pvReserved.

Return Value:

        SUCCESS.

--*/

DWORD
dwAddPorts( PBYTE pbGuidAdapter, PVOID pvReserved )
{
    DWORD                   retcode             = SUCCESS;
    DWORD                   dwLine;
    DWORD                   cNewPorts;
    TapiPortControlBlock    **pptpcbNewPorts    = NULL,
                            *ptpcbPort;
    DWORD                   iNewPort;
    PortMediaInfo           *pmiNewDevice       = NULL;
    TapiLineInfo            *pLineInfo          = NULL;
    DeviceInfo              *pDeviceInfo        = NULL;

    RasTapiTrace ("dwAddPorts" );

    pDeviceInfo = GetDeviceInfo (pbGuidAdapter, FALSE);

#if DBG
        ASSERT( NULL != pDeviceInfo );
#endif

    //
    // Iterate over all the lines to add the new ports
    //
    for ( dwLine = 0; dwLine < TotalLines; dwLine++)
    {
        retcode = dwCreateTapiPortsPerLine( dwLine,
                                            &cNewPorts,
                                            &pptpcbNewPorts);

        if (    retcode
            ||  NULL == pptpcbNewPorts)
        {
            continue;
        }

        //
        // Added a new pptp port. Fill in the rasman port
        // structure and notify rasman
        //
        for ( iNewPort = 0; iNewPort < cNewPorts; iNewPort++ )
        {

            ptpcbPort = pptpcbNewPorts [ iNewPort ];

            //
            // Allocate a PortMediaInfo Structure and fill it
            // with the information about the new device added.
            // This structure will be freed by rasman.
            //
            pmiNewDevice = LocalAlloc (
                                LPTR,
                                sizeof (PortMediaInfo));

            if (NULL == pmiNewDevice)
            {

                RasTapiTrace("dwAddPorts: Failed to allocate "
                             "memory. %d",
                             GetLastError() );

                retcode = GetLastError();

                break;
            }

            strcpy (
                pmiNewDevice->PMI_Name,
                ptpcbPort->TPCB_Name);

            pmiNewDevice->PMI_Usage = ptpcbPort->TPCB_Usage;

            strcpy (
                pmiNewDevice->PMI_DeviceType,
                ptpcbPort->TPCB_DeviceType);

            strcpy (
                pmiNewDevice->PMI_DeviceName,
                ptpcbPort->TPCB_DeviceName);

            pmiNewDevice->PMI_LineDeviceId =
                    ptpcbPort->TPCB_Line->TLI_LineId;

            pmiNewDevice->PMI_AddressId =
                    ptpcbPort->TPCB_AddressId;

            pmiNewDevice->PMI_pDeviceInfo = pDeviceInfo;

            RasTapiTrace ("dwAddPorts: Posting new port "
                          "notification for %s",
                          ptpcbPort->TPCB_Name);

            PostNotificationNewPort (pmiNewDevice);

        }

        LocalFree ( pptpcbNewPorts );

        pptpcbNewPorts = NULL;

        //
        // We already reached the limit. Don't create any
        // more ports
        //
        if (pDeviceInfo->dwCurrentEndPoints ==
                pDeviceInfo->rdiDeviceInfo.dwNumEndPoints)
        {
            break;
        }
    }

    return retcode;
}

/*++

Routine Description:

        Copies data from the input buffer to the fifo
        maintained. This is for the devices supporting
        Character Mode.

Arguments:

        Fifo - to which the data has to be copied.

        Data - data buffer.

        DataLength - length of the data.

Return Value:

        Number of bytes copied.

--*/

DWORD
CopyDataToFifo(
    PRECV_FIFO  Fifo,
    PBYTE       Data,
    DWORD       DataLength
    )
{
    DWORD   bytescopied = 0;

    while (     Fifo->Count != Fifo->Size
            &&  bytescopied < DataLength)
    {
        Fifo->Buffer[Fifo->In++] = Data[bytescopied++];
        Fifo->Count++;
        Fifo->In %= Fifo->Size;
    }

    return (bytescopied);
}

/*++

Routine Description:

        Copies data to the  buffer from  fifo
        This is for the devices supporting
        Character Mode.

Arguments:

        Fifo - to which the data has to be copied.

        Data - buffer to receive data

        DataLength - length of the buffer.

Return Value:

        Number of bytes copied.

--*/

DWORD
CopyDataFromFifo(
    PRECV_FIFO  Fifo,
    PBYTE   Buffer,
    DWORD   BufferSize
    )
{
    DWORD   bytescopied = 0;

    while (     bytescopied < BufferSize
            &&  Fifo->Count != 0)
    {
        Buffer[bytescopied++] = Fifo->Buffer[Fifo->Out++];
        Fifo->Count--;
        Fifo->Out %= Fifo->Size;
    }

    return (bytescopied);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\tapi32\rastapi.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//  Copyright (C) 1994-95 Microsft Corporation. All rights reserved.
//
//  Filename: rastapi.h
//
//  Revision History
//
//  Mar  28 1992   Gurdeep Singh Pall   Created
//
//
//  Description: This file contains all structs for TAPI.DLL
//
//****************************************************************************

#include <wanpub.h> // for NDIS_WAN_MEDIUM_SUBTYPE

#define DEVICETYPE_ISDN                     "ISDN"
#define DEVICETYPE_X25                      "X25"
#define DEVICETYPE_UNIMODEM                 "MODEM"
#define DEVICETYPE_PPTP                     "VPN"
#define DEVICETYPE_ATM                      "ATM"
#define REMOTEACCESS_APP                    "RemoteAccess"

#define CONTROLBLOCKSIGNATURE               0x06051932

#define CLIENT_USAGE "Client"
#define SERVER_USAGE "Server"
#define ROUTER_USAGE "Router"

#define REGISTRY_RASMAN_TAPI_KEY            "Software\\Microsoft\\RAS\\Tapi Devices"
#define REGISTRY_ADDRESS                    "Address"
#define REGISTRY_FRIENDLYNAME               "Friendly Name"
#define REGISTRY_MEDIATYPE                  "Media Type"
#define REGISTRY_USAGE                      "Usage"

#define LOW_MAJOR_VERSION                   0x0001
#define LOW_MINOR_VERSION                   0x0003
#define HIGH_MAJOR_VERSION                  0x0002
#define HIGH_MINOR_VERSION                  0x0000

#define LOW_VERSION                         ((LOW_MAJOR_VERSION  << 16) | LOW_MINOR_VERSION)
#define HIGH_VERSION                        ((HIGH_MAJOR_VERSION << 16) | HIGH_MINOR_VERSION)

#define LOW_EXT_MAJOR_VERSION               0x0000
#define LOW_EXT_MINOR_VERSION               0x0000
#define HIGH_EXT_MAJOR_VERSION              0x0000
#define HIGH_EXT_MINOR_VERSION              0x0000

#define LOW_EXT_VERSION                     ((LOW_EXT_MAJOR_VERSION  << 16) | LOW_EXT_MINOR_VERSION)
#define HIGH_EXT_VERSION                    ((HIGH_EXT_MAJOR_VERSION << 16) | HIGH_EXT_MINOR_VERSION)

// Generic indexes
#define ADDRESS_INDEX                       0
#define CONNECTBPS_INDEX                    1

// ISDN param indexes
#define ISDN_ADDRESS_INDEX                  ADDRESS_INDEX
#define ISDN_CONNECTBPS_INDEX               CONNECTBPS_INDEX
#define ISDN_LINETYPE_INDEX                 2
#define ISDN_FALLBACK_INDEX                 3
#define ISDN_COMPRESSION_INDEX              4
#define ISDN_CHANNEL_AGG_INDEX              5

// X25 indexes
#define X25_ADDRESS_INDEX                   ADDRESS_INDEX
#define X25_CONNECTBPS_INDEX                CONNECTBPS_INDEX
#define X25_DIAGNOSTICS_INDEX               2
#define X25_USERDATA_INDEX                  3
#define X25_FACILITIES_INDEX                4

enum PORT_STATE {

    PS_CLOSED,

    PS_OPEN,

    PS_LISTENING,

    PS_CONNECTED,

    PS_CONNECTING,

    PS_DISCONNECTING,

    PS_UNINITIALIZED,

    PS_UNAVAILABLE,

} ;

typedef enum PORT_STATE PORT_STATE ;
typedef enum PORT_STATE LINE_STATE ;


enum LISTEN_SUBSTATE {

    LS_WAIT,

    LS_RINGING,

    LS_ACCEPT,

    LS_ANSWER,

    LS_COMPLETE,

    LS_ERROR,

} ;

typedef enum LISTEN_SUBSTATE LISTEN_SUBSTATE ;


struct TapiLineInfo {

    struct      TapiLineInfo    *TLI_Next;

    DWORD       TLI_LineId ;                            // Returned by LineInitialize

    HLINE       TLI_LineHandle ;                        // Returned by LineOpen

//    struct      TapiPortControlBlock *pTPCB;          // TAPI port associated with this line


    LINE_STATE      TLI_LineState ;                     // open?, closed?, listen posted?.

    DWORD       TLI_OpenCount ;

    DWORD       NegotiatedApiVersion;

    DWORD       NegotiatedExtVersion;

    BOOL        CharModeSupported;

    BOOL        TLI_MultiEndpoint;

    DeviceInfo  *TLI_pDeviceInfo;                       // pointer to the deviceinfo block

    DWORD       TLI_MediaMode  ;                       // Media mode to use for lineopens.

#define  MAX_PROVIDER_NAME 48
    CHAR        TLI_ProviderName[MAX_PROVIDER_NAME] ;


} ;

typedef struct TapiLineInfo TapiLineInfo ;

typedef enum RASTAPI_DEV_CMD
{
    RASTAPI_DEV_SEND,       // Send a buffer to the miniport
    RASTAPI_DEV_RECV,       // Read a buffer from the miniport
    RASTAPI_DEV_PPP_MODE    // Put the miniport into PPP framing mode
    
} RASTAPI_DEV_CMD;

typedef struct RASTAPI_DEV_SPECIFIC
{
    RASTAPI_DEV_CMD Command;    // RASTAPI_DEV_SEND, RASTAPI_DEV_RECV, RASTAPI_DEV_PPP_MODE
    DWORD           Reserved;
    DWORD           DataSize;
    UCHAR           Data[1];
    
} RASTAPI_DEV_SPECIFIC, *PRASTAPI_DEV_SPECIFIC;

//
//  Magic Cookie used in DEV_DATA_MODES command
//
#define MINIPORT_COOKIE     0x494E494D

//
// DEV_SPECIFIC Flags
//
#define CHAR_MODE   0x00000001  // Miniport supports character mode

typedef struct RASTAPI_DEV_DATA_MODES
{
    DWORD   MagicCookie;
    DWORD   DataModes;
    
} RASTAPI_DEV_DATA_MODES, *PRASTAPI_DEV_DATA_MODES;

typedef struct _RECV_FIFO
{
    DWORD   Count;          // # of elements in fifo
    DWORD   In;             // indexs into circular buffer
    DWORD   Out;            //
    DWORD   Size;           // Size of Buffer
    BYTE    Buffer[1];      // storage
    
} RECV_FIFO, *PRECV_FIFO;

#define RASTAPI_FLAG_UNAVAILABLE        0x00000001
#define RASTAPI_FLAG_DIALEDIN           0x00000002

struct TapiPortControlBlock {

    DWORD                   TPCB_Signature ;                        // Unique signature for verifying block ptr.

    struct                  TapiPortControlBlock *TPCB_next;        // next TAPI port in the list

    HANDLE                  TPCB_Handle ;                           // Handle used to identify this port

    CHAR                    TPCB_Name[MAX_PORT_NAME] ;              // Friendly Name of the port

    CHAR                    TPCB_Address[MAX_PORT_NAME] ;           // Address - please note for legacy tapi dev. this is
                                                                    // a GUID - so has to be at least 16 bytes.

    PORT_STATE              TPCB_State ;                            // State of the port

    LISTEN_SUBSTATE         TPCB_ListenState ;                      // state of the listen

    CHAR                    TPCB_DeviceType[MAX_DEVICETYPE_NAME] ;  // ISDN, etc.

    CHAR                    TPCB_DeviceName [MAX_DEVICE_NAME] ;     // Digiboard etc.

    RASMAN_USAGE            TPCB_Usage ;                            // CALLIN, CALLOUT or BOTH

    TapiLineInfo            *TPCB_Line ;                            // Handle to the "line" this port belongs to

    DWORD                   TPCB_AddressId ;                        // Address ID for this "port"

    DWORD                   TPCB_CallId;                            // CallI ID for this "port"

    HCALL                   TPCB_CallHandle ;                       // When connected the call id

    HANDLE                  TPCB_IoCompletionPort;                  // passed in on open

    DWORD                   TPCB_CompletionKey;                     // passed in on open

    DWORD                   TPCB_RequestId ;                        // id for async requests.

    DWORD                   TPCB_AsyncErrorCode ;                   // used to store asycn returned code.

    CHAR                    TPCB_Info[6][100] ;                     // port info associated with this connection

    HANDLE                  TPCB_Endpoint ;                         // used to store asyncmac context for unimodem ports

    HANDLE                  TPCB_CommHandle ;                       // used to store comm port handle used in unimodem ports

    RAS_OVERLAPPED          TPCB_ReadOverlapped ;                   // used in read async ops.

    RAS_OVERLAPPED          TPCB_WriteOverlapped ;                  // used in write async ops.

    RAS_OVERLAPPED          TPCB_DiscOverlapped;                    // used in signaling disconnection

    PBYTE                   TPCB_DevConfig ;                        // Opaque blob of data used for configuring tapi
                                                                    // devices - this is passed in to
                                                                    // us using DeviceSetDevConfig() ;

    DWORD                   TPCB_SizeOfDevConfig ;                  // Size of the above blob.

    PBYTE                   TPCB_DefaultDevConfig ;                 // The current config for the device that is saved
                                                                    // away before we write any changes
                                                                    // to the device. This allows RAS to be a good
                                                                    // citizen by not overwriting defauls.

    DWORD                   TPCB_DefaultDevConfigSize ;

    DWORD                   TPCB_DisconnectReason ;                 // Reason for disconnection.

    DWORD                   TPCB_NumberOfRings ;                    // Number of rings received so far.

    DWORD                   IdleReceived;

    BOOL                    TPCB_dwFlags;                         // is this client dialed in

    RASTAPI_CONNECT_INFO    *TPCB_pConnectInfo;

    //
    //  Char Mode Support ( for USR )
    //

    DWORD                   TPCB_SendRequestId;                     // Request Id stored to id the event in callback
                                                                    // that send completed for a char mode port

    PVOID                   TPCB_SendDesc;                          // Send Desc passed to lineDevSpecific call for send request

    DWORD                   TPCB_RecvRequestId;                     // Request Id stored to id the event in callback that recv completed
                                                                    // for a char mode port

    PVOID                   TPCB_RecvDesc;                          // Recv Desc passed to lineDevSpecific call

    PBYTE                   TPCB_RasmanRecvBuffer;

    DWORD                   TPCB_RasmanRecvBufferSize;

    PRECV_FIFO              TPCB_RecvFifo;

    DWORD                   TPCB_ModeRequestId;                     // Request id stored to id the event that mode was set for a char mode

    PVOID                   TPCB_ModeRequestDesc;                   // desc.

    BOOL                    TPCB_CharMode;                          // CharMode ?

} ;

typedef struct TapiPortControlBlock TapiPortControlBlock ;

struct _ZOMBIE_CALL {
    LIST_ENTRY  Linkage;
    DWORD       RequestID;
    HCALL       hCall;
} ;

typedef struct _ZOMBIE_CALL ZOMBIE_CALL;


VOID FAR PASCAL RasTapiCallback ( HANDLE,
                                  DWORD,
                                  ULONG_PTR,
                                  ULONG_PTR,
                                  ULONG_PTR,
                                  ULONG_PTR) ;

VOID SetIsdnParams ( TapiPortControlBlock *,
                     LINECALLPARAMS *) ;

VOID GetMutex (HANDLE, DWORD) ;

VOID FreeMutex (HANDLE) ;

DWORD EnumerateTapiPorts (HANDLE) ;

VOID PostDisconnectCompletion( TapiPortControlBlock * );

VOID PostNotificationCompletion( TapiPortControlBlock * );

VOID PostNotificationNewPort ( PortMediaInfo *);

VOID PostNotificationRemoveLine ( DWORD );

DWORD dwAddPorts( PBYTE, LPVOID );

DWORD dwRemovePort ( TapiPortControlBlock * );

DWORD CopyDataToFifo(PRECV_FIFO, PBYTE, DWORD);

DWORD CopyDataFromFifo(PRECV_FIFO, PBYTE, DWORD);


// rtnetcfg.cpp

DWORD dwGetNumberOfRings ( PDWORD pdwRings );

DWORD dwGetPortUsage(DWORD *pdwUsage);

LONG  lrIsModemRasEnabled(HKEY hkey,
                          BOOL *pfRasEnabled,
                          BOOL *pfRouterEnabled );

DeviceInfo * GetDeviceInfo(PBYTE pbAddress, BOOL fModem);

DWORD GetEndPointInfo(DeviceInfo **ppDeviceInfo,
                      PBYTE pbAddress,
                      BOOL fForceRead,
                      NDIS_WAN_MEDIUM_SUBTYPE eDeviceType);

// init.c
DWORD GetDeviceTypeFromDeviceGuid( GUID *pDeviceGuid );
VOID  RasTapiTrace( CHAR * Format, ... ) ;
VOID  TraceEndPointInfo(DeviceInfo *pInfo);
DWORD DwRasErrorFromDisconnectMode(DWORD dm);

//diag.c
DWORD
DwGetConnectInfo(
    TapiPortControlBlock *port,
    HCALL                hCall,
    LINECALLINFO         *pLineCallInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\tapi32\rtnetcfg.cpp ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  05/29/97s Rao salapaka  Created
//
//
//  Description: All Initialization code for rasman component lives here.
//
//****************************************************************************

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

extern "C" 
{
#include <nt.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <comdef.h>
#include <tchar.h>
#include <rtutils.h>
#include <rasman.h>
extern "C"
{
#include <reghelp.h>
}

#define REGISTRY_NUMBEROFRINGS      TEXT("NumberOfRings")

#define RNETCFG_RASCLI              1

#define RNETCFG_RASSRV              2

#define RNETCFG_ROUTER              4

DWORD   g_dwRasComponent = 0;

#define TRACESETTINGS               (0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC)

extern "C"
{
    
    DWORD dwTraceId;
    
    DWORD dwGetNumberOfRings ( PDWORD pdwRings );
    
    DWORD dwGetPortUsage(DWORD *pdwPortUsage);

    LONG  lrIsModemRasEnabled(HKEY hkey, BOOL *pfRasEnabled);

    DeviceInfo * GetDeviceInfo (PBYTE pbGuid );

}

LONG
lrCheckValue(
        HKEY    hkeyRas,
        LPCTSTR lpcszValue,
        BOOL    *pfEnabled)
{
    DWORD dwdata;
    DWORD dwtype;
    DWORD dwsize = sizeof(DWORD);
    LONG  lr;

    *pfEnabled = FALSE;

    if(ERROR_FILE_NOT_FOUND == (lr = RegQueryValueEx(
                                        hkeyRas,
                                        lpcszValue,
                                        0, &dwtype,
                                        (PBYTE) &dwdata,
                                        &dwsize)))
    {
        TracePrintfExA(
                dwTraceId,
                TRACESETTINGS,
                "lrCheckValue: value %ws not found",
                lpcszValue);

        dwdata = 1;

        if(lr = lrRasEnableDevice(hkeyRas,
                                  lpcszValue))
        {
            TracePrintfExA(
                    dwTraceId,
                    TRACESETTINGS,
                    "lrCheckValue: Couldn't set value %ws. 0x%x",
                    lpcszValue, 
                    lr);
                    
            goto done;                           
        }

        *pfEnabled = TRUE;                        
        
        goto done;                        
    }

    *pfEnabled = dwdata;
    
done:
    return lr;
}

LONG
lrIsModemRasEnabled(HKEY    hkey,
                    BOOL    *pfRasEnabled,
                    BOOL    *pfRouterEnabled)
{
    DWORD dwdata;
    DWORD dwsize = sizeof ( DWORD );
    DWORD dwtype;
    LONG  lr;
    HKEY  hkeyRas = NULL;
    DWORD dwDisposition;

    *pfRasEnabled = FALSE;
    *pfRouterEnabled = FALSE;

    //
    // Open the RAS key and if the key is not present
    // create the key.
    //
    if (lr = RegCreateKeyEx(
               hkey,
               TEXT("Clients\\Ras"),
               0, NULL, 0,
               KEY_ALL_ACCESS,
               NULL,
               &hkeyRas,
               &dwDisposition))
    {
        TracePrintfExA(
                dwTraceId,
                TRACESETTINGS,
                "dwFindModemPortUsage: Failed to"
                "create/open RAS key under modem class. 0x%x",
                lr);

        goto done;
    }

    //
    // Check to see if the modem is enabled for Ras dialin
    //
    if(lr = lrCheckValue(
                hkeyRas,
                TEXT("EnableForRas"),
                pfRasEnabled))
    {
        TracePrintfExA(
                dwTraceId,
                TRACESETTINGS,
                "dwFindModemPortUsage: lrCheckValue"
                "failed for RasEnabled. %d",
                lr );

        lr = ERROR_SUCCESS;                        
        
    }

    if (!*pfRasEnabled)
    {
        TracePrintfExA(
                dwTraceId,
                TRACESETTINGS,
                "dwFindModemPortUsage: Modem"
                "is not enabled for RAS");
    }

    //
    // Check to see if the modem is enabled for routing
    //
    if(lr = lrCheckValue(
                hkeyRas,
                TEXT("EnableForRouting"),
                pfRouterEnabled))
    {
        TracePrintfExA(
                dwTraceId,
                TRACESETTINGS,
                "dwFindModemPortUsage: lrCheckValue "
                "failed for RouterEnabled. %d",
                lr );

        lr = ERROR_SUCCESS;                        
    }

    if(!*pfRouterEnabled)
    {
        TracePrintfExA(
                dwTraceId,
                TRACESETTINGS,
                "dwFindModemPortUsage: Modem "
                "is not enabled for Routing");
    }

done:
    if(hkeyRas)
    {
        RegCloseKey(hkeyRas);
    }
    
    return (DWORD) lr;
}


DWORD
dwGetPortUsage(DWORD *pdwUsage)
{
    HKEY    hkey         = NULL;
    DWORD   dwRetCode    = ERROR_SUCCESS;

    static const TCHAR c_szRemoteAccess[] =
                    TEXT("System\\CurrentControlSet\\Services\\RemoteAccess");

    TracePrintfExA(dwTraceId, TRACESETTINGS,
                   "dwGetPorTUsage:...");

    if(0 == g_dwRasComponent)                       
    {
        // Check to see if Ras Server is installed
        //
        g_dwRasComponent = RNETCFG_RASCLI;

        if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    c_szRemoteAccess,
                    0, KEY_QUERY_VALUE,
                    &hkey))
        {
            TracePrintfExA(
                dwTraceId, TRACESETTINGS,
                "dwAssignDefaultPortUsage: RemoteAccess not installed");
        }
        else
        {
            g_dwRasComponent = RNETCFG_RASSRV;
        }
    }

    *pdwUsage = CALL_OUT;

    *pdwUsage |= ((g_dwRasComponent & RNETCFG_RASSRV) ?
                    (CALL_IN | CALL_ROUTER) : 0);
                    
    return dwRetCode;
}

DWORD
dwGetNumberOfRings (PDWORD pdwRings)
{
    LONG    lr      = ERROR_SUCCESS;
    HKEY    hkey    = NULL;
    DWORD   dwsize  = sizeof(DWORD);
    DWORD   dwtype;
    
    TCHAR c_szRasmanParam[] =
                TEXT("SYSTEM\\CurrentControlSet\\Services\\Rasman\\Parameters");

    if(lr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                c_szRasmanParam,
                0, KEY_READ,
                &hkey))
    {
        TracePrintfExA( 
                dwTraceId, TRACESETTINGS,
                "dwGetNumberOfRings: failed to open rasman key in registry. 0x%x",
                lr);

        goto done;                        
    }

    if(lr = RegQueryValueEx(
                hkey,
                TEXT("NumberOfRings"),
                0, &dwtype,
                (PBYTE) pdwRings,
                &dwsize))
    {
        *pdwRings = 1;
    }

    if (    *pdwRings < 1
        ||  *pdwRings > 20)
    {
        *pdwRings = 1;
    }

done:
    if(hkey)
    {
        RegCloseKey(hkey);
    }

    TracePrintfExA(
        dwTraceId, TRACESETTINGS,
        "dwGetNumberOfRings: dwRings=%d. lr=0x%x",
        *pdwRings, lr);
                    
    
    return (DWORD) lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\cleartxt.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    cleartxt.h
//
// SYNOPSIS
//
//    Declares functions for storing and retrieving cleartext passwords from
//    UserParameters.
//
// MODIFICATION HISTORY
//
//    08/31/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _CLEARTXT_H_
#define _CLEARTXT_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/////////
// Note: These functions return Win32 error codes, not NTSTATUS codes.
/////////

//////////
// Clears the encrypted cleartext password. The new UserParameters must be
// freed through a call to IASParmsUserParmsFree. If the cleartext password
// was not previously set, the function returns NO_ERROR and pszNewUserParms
// is set to NULL.
//////////
DWORD
WINAPI
IASParmsClearUserPassword(
    IN PCWSTR szUserParms,
    OUT PWSTR *pszNewUserParms
    );

//////////
// Retrieves the decrypted cleartext password. The returned password must be
// freed through a call to LocalFree. If the cleartext password is not
// set, the function returns NO_ERROR and pszPassword is set to NULL.
//////////
DWORD
WINAPI
IASParmsGetUserPassword(
    IN PCWSTR szUserParms,
    OUT PWSTR *pszPassword
    );

//////////
// Sets the encrypted cleartext password. The new UserParameters must be
// freed through a call to IASParmsUserParmsFree.
//////////
DWORD
WINAPI
IASParmsSetUserPassword(
    IN PCWSTR szUserParms,
    IN PCWSTR szPassword,
    OUT PWSTR *pszNewUserParms
    );

//////////
// Frees a UserParameters string returned by IASParmsClearUserPassword or
// IASParmsSetUserPassword.
//////////
VOID
WINAPI
IASParmsFreeUserParms(
    IN LPWSTR szNewUserParms
    );

#ifdef __cplusplus
}
#endif
#endif  // _CLEARTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\arapdes.c ===
/*++

Copyright (c) 1987-1994  Microsoft Corporation

Module Name:

    arapdes.c

Abstract:

    This module implements the ARAP-specific authentication that is called in
    by the subauthentication package if the protocol type is ARAP.
    This code is adapted from fcr's des code

Author:

    Shirish Koti 28-Feb-97

Revisions:


--*/


/*
 * Sofware DES functions
 * written 12 Dec 1986 by Phil Karn, KA9Q; large sections adapted from
 * the 1977 public-domain program by Jim Gillogly
 */

// #include "compiler.h"

#include <windows.h>
//#include <ntddk.h>
//#include <ntdef.h>
//#define	NULL	0

unsigned long byteswap();

CRITICAL_SECTION    ArapDesLock;

VOID
des_done(
    IN VOID
);


VOID
des_setkey(
    IN  PCHAR  key          // 64 bits (will use only 56)
);


VOID
des_endes(
    IN  PCHAR  block
);


VOID
des_dedes(
    IN PCHAR    block
);

static
VOID
permute(
    IN PCHAR    inblock,          // result into outblock,64 bits
    IN CHAR     perm[16][16][8],  // 2K bytes defining perm.
    IN PCHAR    outblock          // result into outblock,64 bits
);

static
VOID
round(
    IN  int num,
    IN  unsigned long *block
);

static long f (unsigned long r, unsigned char subkey[8]);

static
VOID
perminit(
    IN CHAR perm[16][16][8],
    IN CHAR p[64]
);

static int spinit();

PCHAR
des_pw_bitshift(
    IN PCHAR    pw
);


PCHAR
des_pw_bitshift_lowbit(
    IN PCHAR    pw
);


//
// Tables defined in the Data Encryption Standard documents */
//


//
// initial permutation IP
//
static char ip[] =
{
	58, 50, 42, 34, 26, 18, 10,  2,
	60, 52, 44, 36, 28, 20, 12,  4,
	62, 54, 46, 38, 30, 22, 14,  6,
	64, 56, 48, 40, 32, 24, 16,  8,
	57, 49, 41, 33, 25, 17,  9,  1,
	59, 51, 43, 35, 27, 19, 11,  3,
	61, 53, 45, 37, 29, 21, 13,  5,
	63, 55, 47, 39, 31, 23, 15,  7
};

//
// final permutation IP^-1
//
static char fp[] =
{
	40,  8, 48, 16, 56, 24, 64, 32,
	39,  7, 47, 15, 55, 23, 63, 31,
	38,  6, 46, 14, 54, 22, 62, 30,
	37,  5, 45, 13, 53, 21, 61, 29,
	36,  4, 44, 12, 52, 20, 60, 28,
	35,  3, 43, 11, 51, 19, 59, 27,
	34,  2, 42, 10, 50, 18, 58, 26,
	33,  1, 41,  9, 49, 17, 57, 25
};

/* expansion operation matrix
 * This is for reference only; it is unused in the code
 * as the f() function performs it implicitly for speed
 */
#ifdef notdef
static char ei[] =
{
	32,  1,  2,  3,  4,  5,
	 4,  5,  6,  7,  8,  9,
	 8,  9, 10, 11, 12, 13,
	12, 13, 14, 15, 16, 17,
	16, 17, 18, 19, 20, 21,
	20, 21, 22, 23, 24, 25,
	24, 25, 26, 27, 28, 29,
	28, 29, 30, 31, 32,  1
};
#endif

//
// permuted choice table (key)
//
static char pc1[] =
{
	57, 49, 41, 33, 25, 17,  9,
	 1, 58, 50, 42, 34, 26, 18,
	10,  2, 59, 51, 43, 35, 27,
	19, 11,  3, 60, 52, 44, 36,

	63, 55, 47, 39, 31, 23, 15,
	 7, 62, 54, 46, 38, 30, 22,
	14,  6, 61, 53, 45, 37, 29,
	21, 13,  5, 28, 20, 12,  4
};

//
// number left rotations of pc1
//
static char totrot[] =
{
	1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28
};

//
// permuted choice key (table)
//
static char pc2[] =
{
	14, 17, 11, 24,  1,  5,
	 3, 28, 15,  6, 21, 10,
	23, 19, 12,  4, 26,  8,
	16,  7, 27, 20, 13,  2,
	41, 52, 31, 37, 47, 55,
	30, 40, 51, 45, 33, 48,
	44, 49, 39, 56, 34, 53,
	46, 42, 50, 36, 29, 32
};

//
// The (in)famous S-boxes
//
static char si[8][64] =
{
    //
	// S1
    //
	14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
	 0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
	 4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
	15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13,

    //
	// S2
    //
	15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,
	 3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,
	 0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,
	13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9,

    //
	// S3
    //
	10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,
	13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,
	13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
	 1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12,

    //
	// S4
    //
	 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,
	13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,
	10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
	 3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14,

    //
	// S5
    //
	 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,
	14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,
	 4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,
	11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3,

    //
	// S6
    //
	12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
	10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
	 9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
	 4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13,

    //
	// S7
    //
	 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
	13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
	 1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
	 6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12,

    //
	// S8
    //
	13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
	 1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
	 7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
	 2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11
};

//
// 32-bit permutation function P used on the output of the S-boxes
//
static char p32i[] =
{	
	16,  7, 20, 21,
	29, 12, 28, 17,
	 1, 15, 23, 26,
	 5, 18, 31, 10,
	 2,  8, 24, 14,
	32, 27,  3,  9,
	19, 13, 30,  6,
	22, 11,  4, 25
};
//
// End of DES-defined tables
//

//
// Lookup tables initialized once only at startup by desinit()
//
static long (*sp)[64];		// Combined S and P boxes

static char (*iperm)[16][8];	// Initial and final permutations
static char (*fperm)[16][8];

//
// 8 6-bit subkeys for each of 16 rounds, initialized by setkey()
//
static unsigned char (*kn)[8];

//
// bit 0 is left-most in byte
//
static int bytebit[] =
{
	0200,0100,040,020,010,04,02,01
};

static int nibblebit[] =
{
	 010,04,02,01
};
static int desmode;

/* Allocate space and initialize DES lookup arrays
 * mode == 0: standard Data Encryption Algorithm
 * mode == 1: DEA without initial and final permutations for speed
 * mode == 2: DEA without permutations and with 128-byte key (completely
 *            independent subkeys for each round)
 */
des_init(mode)
int mode;
{

	if(sp != NULL)
    {
		// Already initialized
		return 0;
	}
	desmode = mode;
	
	sp = (long (*)[64])LocalAlloc(LMEM_FIXED, (sizeof(long) * 8 * 64));

	if(sp == NULL)
    {
		return -1;
	}

	spinit();

	kn = (unsigned char (*)[8])LocalAlloc(LMEM_FIXED, (sizeof(char) * 8 * 16));
	if(kn == NULL)
    {
		LocalFree((char *)sp);
		return -1;
	}
	if(mode == 1 || mode == 2)	// No permutations
		return 0;

	iperm = (char (*)[16][8])
                        LocalAlloc(LMEM_FIXED, (sizeof(char) * 16 * 16 * 8));
	if(iperm == NULL)
    {
		LocalFree((char *)sp);
		LocalFree((char *)kn);
		return -1;
	}
	perminit(iperm,ip);

	fperm = (char (*)[16][8])
                        LocalAlloc(LMEM_FIXED, (sizeof(char) * 16 * 16 * 8));
	if(fperm == NULL)
    {
		LocalFree((char *)sp);
		LocalFree((char *)kn);
		LocalFree((char *)iperm);
		return -1;
	}
	perminit(fperm,fp);
	
	return 0;
}


//
// Free up storage used by DES
//
VOID
des_done(
    IN VOID
)
{
	if(sp == NULL)
		return;	  // Already done

	LocalFree((char *)sp);
	LocalFree((char *)kn);
	if(iperm != NULL)
		LocalFree((char *)iperm);
	if(fperm != NULL)
		LocalFree((char *)fperm);

	sp = NULL;
	iperm = NULL;
	fperm = NULL;
	kn = NULL;
}
//
// Set key (initialize key schedule array)
//
VOID
des_setkey(
    IN  PCHAR  key          // 64 bits (will use only 56)
)
{
	char pc1m[56];		/* place to modify pc1 into */
	char pcr[56];		/* place to rotate pc1 into */
	register int i,j,l;
	int m;

	/* In mode 2, the 128 bytes of subkey are set directly from the
	 * user's key, allowing him to use completely independent
	 * subkeys for each round. Note that the user MUST specify a
	 * full 128 bytes.
	 *
	 * I would like to think that this technique gives the NSA a real
	 * headache, but I'm not THAT naive.
	 */
	if(desmode == 2)
    {
		for(i=0;i<16;i++)
			for(j=0;j<8;j++)
				kn[i][j] = *key++;
		return;
	}
    //
	// Clear key schedule
    //
	for (i=0; i<16; i++)
		for (j=0; j<8; j++)
			kn[i][j]=0;

	for (j=0; j<56; j++)  /* convert pc1 to bits of key */
    {		
		l=pc1[j]-1;		/* integer bit location	 */
		m = l & 07;		/* find bit		 */
		pc1m[j]=(key[l>>3] &	/* find which key byte l is in */
			bytebit[m])	/* and which bit of that byte */
			? 1 : 0;	/* and store 1-bit result */
	}
	for (i=0; i<16; i++)  /* key chunk for each iteration */
    {		
		for (j=0; j<56; j++)	/* rotate pc1 the right amount */
			pcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];
			/* rotate left and right halves independently */
		for (j=0; j<48; j++)
        {	/* select bits individually */
			/* check bit that goes to kn[j] */
			if (pcr[pc2[j]-1])
            {
				/* mask it in if it's there */
				l= j % 6;
				kn[i][j/6] |= bytebit[l] >> 2;
			}
		}
	}
}
//
// In-place encryption of 64-bit block
//
VOID
des_endes(
    IN  PCHAR  block
)
{
	register int i;
	unsigned long work[2]; 		/* Working data storage */
	long tmp;

	permute(block,iperm,(char *)work);	/* Initial Permutation */

	work[0] = byteswap(work[0]);
	work[1] = byteswap(work[1]);


	/* Do the 16 rounds */
	for (i=0; i<16; i++)
		round(i,work);

	/* Left/right half swap */
	tmp = work[0];
	work[0] = work[1];	
	work[1] = tmp;

	work[0] = byteswap(work[0]);
	work[1] = byteswap(work[1]);

    permute((char *)work,fperm,block);	/* Inverse initial permutation */
}
//
// In-place decryption of 64-bit block
//
VOID
des_dedes(
    IN PCHAR    block
)
{
	register int i;
	unsigned long work[2];	/* Working data storage */
	long tmp;

	permute(block,iperm,(char *)work);	/* Initial permutation */

	work[0] = byteswap(work[0]);
	work[1] = byteswap(work[1]);

	/* Left/right half swap */
	tmp = work[0];
	work[0] = work[1];	
	work[1] = tmp;

	/* Do the 16 rounds in reverse order */
	for (i=15; i >= 0; i--)
		round(i,work);

	work[0] = byteswap(work[0]);
	work[1] = byteswap(work[1]);

	permute((char *)work,fperm,block);	/* Inverse initial permutation */
}


PCHAR
des_pw_bitshift(
    IN PCHAR    pw
)
{
    static char pws[8];
    int i;

    /* key is null padded */
    for (i = 0; i < 8; i++)
        pws[i] = 0;

    /* parity bit is always zero (this seem bogus) */
    for (i = 0; i < 8 && pw[i]; i++)
        pws[i] = pw[i] << 1;

    return pws;
}

PCHAR
des_pw_bitshift_lowbit(
    IN PCHAR    pw
)
{
    static char pws[8];
    int i;

    /* key is null padded */
    for (i = 0; i < 8; i++)
        pws[i] = 0;

    // In case of RandNum authentication, we need to drop the low bit!
    for (i = 0; i < 8 && pw[i]; i++)
    {
        pws[i] = (pw[i] & 0x7F);
    }

    return pws;
}

//
// Permute inblock with perm
//
static
VOID
permute(
    IN PCHAR    inblock,          // result into outblock,64 bits
    IN CHAR     perm[16][16][8],  // 2K bytes defining perm.
    IN PCHAR    outblock          // result into outblock,64 bits
)
{
	register int i,j;
	register char *ib, *ob;		/* ptr to input or output block */
	register char *p, *q;

	if(perm == NULL)
    {
		/* No permutation, just copy */
		for(i=8; i!=0; i--)
			*outblock++ = *inblock++;
		return;
	}
	/* Clear output block	 */
	for (i=8, ob = outblock; i != 0; i--)
		*ob++ = 0;

	ib = inblock;
	for (j = 0; j < 16; j += 2, ib++)  /* for each input nibble */
    {
		ob = outblock;
		p = perm[j][(*ib >> 4) & 017];
		q = perm[j + 1][*ib & 017];
		for (i = 8; i != 0; i--)    /* and each output byte */
        {
			*ob++ |= *p++ | *q++;	/* OR the masks together*/
		}
	}
}

//
// Do one DES cipher round
//
static
VOID
round(
    IN  int num,                // i.e. the num-th one
    IN  unsigned long *block
)
{
	long f();

	/* The rounds are numbered from 0 to 15. On even rounds
	 * the right half is fed to f() and the result exclusive-ORs
	 * the left half; on odd rounds the reverse is done.
	 */
	if(num & 1)
    {
		block[1] ^= f(block[0],kn[num]);
	} else
    {
		block[0] ^= f(block[1],kn[num]);
	}
}


//
// The nonlinear function f(r,k), the heart of DES
//
static
long
f(r,subkey)
unsigned long r;		/* 32 bits */
unsigned char subkey[8];	/* 48-bit key for this round */
{
	register unsigned long rval,rt;
#ifdef	TRACE
	unsigned char *cp;
	int i;

	printf("f(%08lx, %02x %02x %02x %02x %02x %02x %02x %02x) = ",
		r,
		subkey[0], subkey[1], subkey[2],
		subkey[3], subkey[4], subkey[5],
		subkey[6], subkey[7]);
#endif
	/* Run E(R) ^ K through the combined S & P boxes
	 * This code takes advantage of a convenient regularity in
	 * E, namely that each group of 6 bits in E(R) feeding
	 * a single S-box is a contiguous segment of R.
	 */
	rt = (r >> 1) | ((r & 1) ? 0x80000000 : 0);
	rval = 0;
	rval |= sp[0][((rt >> 26) ^ *subkey++) & 0x3f];
	rval |= sp[1][((rt >> 22) ^ *subkey++) & 0x3f];
	rval |= sp[2][((rt >> 18) ^ *subkey++) & 0x3f];
	rval |= sp[3][((rt >> 14) ^ *subkey++) & 0x3f];
	rval |= sp[4][((rt >> 10) ^ *subkey++) & 0x3f];
	rval |= sp[5][((rt >> 6) ^ *subkey++) & 0x3f];
	rval |= sp[6][((rt >> 2) ^ *subkey++) & 0x3f];
	rt = (r << 1) | ((r & 0x80000000) ? 1 : 0);
	rval |= sp[7][(rt ^ *subkey) & 0x3f];
#ifdef	TRACE
	printf(" %08lx\n",rval);
#endif
	return rval;
}
//
// initialize a perm array
//
static
VOID
perminit(
    IN CHAR perm[16][16][8],    // 64-bit, either init or final
    IN CHAR p[64]
)
{
	register int l, j, k;
	int i,m;

	/* Clear the permutation array */
	for (i=0; i<16; i++)
		for (j=0; j<16; j++)
			for (k=0; k<8; k++)
				perm[i][j][k]=0;

	for (i=0; i<16; i++)		/* each input nibble position */
		for (j = 0; j < 16; j++)/* each possible input nibble */
		for (k = 0; k < 64; k++)/* each output bit position */
		{   l = p[k] - 1;	/* where does this bit come from*/
			if ((l >> 2) != i)  /* does it come from input posn?*/
			continue;	/* if not, bit k is 0	 */
			if (!(j & nibblebit[l & 3]))
			continue;	/* any such bit in input? */
			m = k & 07;	/* which bit is this in the byte*/
			perm[i][j][k>>3] |= bytebit[m];
		}
}

//
// Initialize the lookup table for the combined S and P boxes
//
static int
spinit()
{
	char pbox[32];
	int p,i,s,j,rowcol;
	long val;

	/* Compute pbox, the inverse of p32i.
	 * This is easier to work with
	 */
	for(p=0;p<32;p++)
    {
		for(i=0;i<32;i++)
        {
			if(p32i[i]-1 == p)
            {
				pbox[p] = (char)i;
				break;
			}
		}
	}
	for(s = 0; s < 8; s++)
    {			/* For each S-box */
		for(i=0; i<64; i++)
        {		/* For each possible input */
			val = 0;
			/* The row number is formed from the first and last
			 * bits; the column number is from the middle 4
			 */
			rowcol = (i & 32) | ((i & 1) ? 16 : 0) | ((i >> 1) & 0xf);
			for(j=0;j<4;j++)
            {	/* For each output bit */
				if(si[s][rowcol] & (8 >> j))
                {
				 val |= 1L << (31 - pbox[4*s + j]);
				}
			}
			sp[s][i] = val;

#ifdef	DEBUG
			printf("sp[%d][%2d] = %08lx\n",s,i,sp[s][i]);
#endif
		}
	}

    return(0);
}


/* Byte swap a long */
static
unsigned long
byteswap(x)
unsigned long x;
{
	register char *cp,tmp;

	cp = (char *)&x;
	tmp = cp[3];
	cp[3] = cp[0];
	cp[0] = tmp;

	tmp = cp[2];
	cp[2] = cp[1];
	cp[1] = tmp;

	return x;
}



VOID
DoTheDESEncrypt(
    IN OUT PCHAR   ChallengeBuf
)
{
    des_endes(ChallengeBuf);
}


VOID
DoTheDESDecrypt(
    IN OUT PCHAR   ChallengeBuf
)
{
    des_dedes(ChallengeBuf);
}


VOID
DoDesInit(
    IN  PCHAR   pClrTxtPwd,
    IN  BOOLEAN DropHighBit  // do we need to drop high bit in key-generation?
)
{
    des_init(0);

    if (DropHighBit)
    {
        des_setkey(des_pw_bitshift(pClrTxtPwd));
    }
    else
    {
        des_setkey(des_pw_bitshift_lowbit(pClrTxtPwd));
    }

}

VOID
DoDesEnd(
    IN  VOID
)
{
    des_done();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\md5port.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    md5port.h
//
// SYNOPSIS
//
//    Declares the NT4/NT5 portability layer for MD5-CHAP support. These
//    routines are the only ones whose implementation varies across the
//    platforms.
//
// MODIFICATION HISTORY
//
//    10/14/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MD5PORT_H_
#define _MD5PORT_H_
#if _MSC_VER >= 1000
#pragma once
#endif

//////////
// Determines whether reversibly encrypted passwords are enabled for the
// specified user.
//////////
NTSTATUS
NTAPI
IsCleartextEnabled(
    IN SAMPR_HANDLE UserHandle,
    OUT PBOOL Enabled
    );

//////////
// Retrieves the user's cleartext password. The returned password should be
// freed through RtlFreeUnicodeString.
//////////
NTSTATUS
NTAPI
RetrieveCleartextPassword(
    IN SAM_HANDLE UserHandle,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PUNICODE_STRING Password
    );

#endif  // _MD5PORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\cleartxt.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    cleartxt.c
//
// SYNOPSIS
//
//    Defines functions for storing and retrieving cleartext passwords.
//
// MODIFICATION HISTORY
//
//    08/31/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <wincrypt.h>

#include <rassfmhp.h>
#include <usrprop.h>
#include <cleartxt.h>

// Name of the private key stored as LSA private data.
UNICODE_STRING PRIVATE_KEY_NAME = { 34, 36, L"G$MSRADIUSPRIVKEY" };

// Length of the private key.
#define PRIVATE_KEY_LENGTH  256

// Length of the user-specific key.
#define USER_KEY_LENGTH     16

// Properties stored in UserParameters.
#define PROPERTY_USER_KEY   L"G$RADIUSCHAPKEY"
#define PROPERTY_PASSWORD   L"G$RADIUSCHAP"

// Fixed key used for decrypting the private key.
BYTE FIXED_KEY[] =
{
   0x05, 0x56, 0xF6, 0x07, 0xC6, 0x56, 0x02, 0x94, 0x02,
   0xC6, 0xF6, 0x67, 0x56, 0x02, 0xC6, 0x96, 0xB6, 0x56,
   0x02, 0x34, 0x86, 0x16, 0xE6, 0x46, 0x27, 0x16, 0xC2,
   0x02, 0x14, 0x46, 0x96, 0x47, 0x96, 0xC2, 0x02, 0x74,
   0x27, 0x56, 0x47, 0x16, 0x02, 0x16, 0x27, 0x56, 0x02,
   0x47, 0x86, 0x56, 0x02, 0x07, 0x56, 0xF6, 0x07, 0xC6,
   0x56, 0x02, 0x94, 0x02, 0x47, 0x27, 0x57, 0x37, 0x47
};

// Shared handle to the cryptographic provider.
HCRYPTPROV theContext;

// Private key used for encrypting/decrypting cleartext passwords.
PLSA_UNICODE_STRING thePrivateKey;

// TRUE if this API has been successfully initialized.
static BOOL theInitFlag;

// Non-zero if the API is locked.
static LONG theLock;

//////////
// Macros to lock/unlock the API during intialization.
//////////
#define API_LOCK() \
   while (InterlockedExchange(&theLock, 1)) Sleep(5)

#define API_UNLOCK() \
      InterlockedExchange(&theLock, 0)

//////////
// Macro that ensures the API has been initialized and bails on failure.
//////////
#define CHECK_INIT() \
  if (!theInitFlag) { \
    status = IASParmsInitialize(); \
    if (status != NO_ERROR) { return status; } \
  }

//////////
// Creates the private key. Should only be called if the key doesn't exist.
//////////
DWORD
WINAPI
IASCreatePrivateKey(
    IN LSA_HANDLE hPolicy
    )
{
   DWORD status;
   BYTE newKey[PRIVATE_KEY_LENGTH];
   LSA_UNICODE_STRING privateData;

   //////////
   // Generate a random key.
   //////////

   if (!CryptGenRandom(
            theContext,
            sizeof(newKey),
            newKey
            ))
   { return GetLastError(); }

   //////////
   // Store it as LSA private data.
   //////////

   privateData.Length = sizeof(newKey);
   privateData.MaximumLength = sizeof(newKey);
   privateData.Buffer = (PWSTR)newKey;

   status = LsaStorePrivateData(
                hPolicy,
                &PRIVATE_KEY_NAME,
                &privateData
                );
   if (NT_SUCCESS(status))
   {
      status = LsaRetrievePrivateData(
                   hPolicy,
                   &PRIVATE_KEY_NAME,
                   &thePrivateKey
                   );
   }

   return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);
}

//////////
// Derives a cryptographic key from an octet string.
//////////
BOOL
WINAPI
IASDeriveUserCryptKey(
    IN PBYTE pbUserKey,
    OUT HCRYPTKEY *phKey
    )
{
   BOOL success;
   HCRYPTHASH hHash;

   success = CryptCreateHash(
                 theContext,
                 CALG_MD5,
                 0,
                 0,
                 &hHash
                 );
   if (!success) { goto exit; }

   success = CryptHashData(
                 hHash,
                 (PBYTE)thePrivateKey->Buffer,
                 thePrivateKey->Length,
                 0
                 );
   if (!success) { goto destroy_hash; }

   success = CryptHashData(
                 hHash,
                 pbUserKey,
                 USER_KEY_LENGTH,
                 0
                 );
   if (!success) { goto destroy_hash; }

   success = CryptDeriveKey(
                 theContext,
                 CALG_RC4,
                 hHash,
                 CRYPT_EXPORTABLE,
                 phKey
                 );

destroy_hash:
   CryptDestroyHash(hHash);

exit:
   return success;
}

DWORD
WINAPI
IASParmsInitialize( VOID )
{
   DWORD status, nbyte;
   OBJECT_ATTRIBUTES objAttribs;
   LSA_HANDLE hPolicy;
   HCRYPTHASH hHash;
   HCRYPTKEY hKey;

   API_LOCK();

   // If we've already been initialized, there's nothing to do.
   if (theInitFlag)
   {
      status = NO_ERROR;
      goto exit;
   }

   /////////
   // Acquire a cryptographic context.
   /////////

   if (!CryptAcquireContext(
            &theContext,
            NULL,
            NULL,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT
            ))
   {
      status = GetLastError();
      goto exit;
   }

   /////////
   // Open a handle to the LSA.
   /////////

   InitializeObjectAttributes(
       &objAttribs,
       NULL,
       0,
       NULL,
       NULL
       );

   status = LsaOpenPolicy(
                NULL,
                &objAttribs,
                POLICY_ALL_ACCESS,
                &hPolicy
                );
   if (!NT_SUCCESS(status))
   {
      status = RtlNtStatusToDosError(status);
      goto exit;
   }

   /////////
   // Retrieve the private key.
   /////////

   status = LsaRetrievePrivateData(
                hPolicy,
                &PRIVATE_KEY_NAME,
                &thePrivateKey
                );
   if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
       (NT_SUCCESS(status) && thePrivateKey->Length == 0))
   {
      // If it doesn't exist, create a new one.
      status = IASCreatePrivateKey(
                   hPolicy
                   );
   }
   else if (!NT_SUCCESS(status))
   {
      status = RtlNtStatusToDosError(status);
   }

   if (status != NO_ERROR) { goto close_policy; }

   /////////
   // Derive a crypto key from the fixed key.
   /////////

   if (!CryptCreateHash(
            theContext,
            CALG_MD5,
            0,
            0,
            &hHash
            ))
   {
      status = GetLastError();
      goto close_policy;
   }

   if (!CryptHashData(
            hHash,
            FIXED_KEY,
            sizeof(FIXED_KEY),
            0
            ))
   {
      status = GetLastError();
      goto destroy_hash;
   }

   if (!CryptDeriveKey(
            theContext,
            CALG_RC4,
            hHash,
            CRYPT_EXPORTABLE,
            &hKey
            ))
   {
      status = GetLastError();
      goto destroy_hash;
   }

   /////////
   // Decrypt the private key.
   /////////

   nbyte = thePrivateKey->Length;

   if (!CryptDecrypt(
            hKey,
            0,
            TRUE,
            0,
            (PBYTE)thePrivateKey->Buffer,
            &nbyte
            ))
   {
      status = GetLastError();
      goto destroy_key;
   }

   thePrivateKey->Length = (USHORT)nbyte;

destroy_key:
   CryptDestroyKey(hKey);

destroy_hash:
   CryptDestroyHash(hHash);

close_policy:
   LsaClose(hPolicy);

exit:
   if (status == NO_ERROR)
   {
      // We succeeded, so set theInitFlag.
      theInitFlag = TRUE;
   }
   else
   {
      // We failed, so clean up.
      if (thePrivateKey)
      {
         LsaFreeMemory(thePrivateKey);
         thePrivateKey = NULL;
      }

      if (theContext)
      {
         CryptReleaseContext(theContext, 0);
         theContext = 0;
      }
   }

   API_UNLOCK();
   return status;
}

DWORD
WINAPI
IASParmsClearUserPassword(
    IN PCWSTR szUserParms,
    OUT PWSTR *pszNewUserParms
    )
{
   DWORD status;
   UNICODE_STRING property;
   PWSTR tempUserParms;
   BOOL updateKey, updatePwd;

   // Check the in parameters.
   if (pszNewUserParms == NULL) { return ERROR_INVALID_PARAMETER; }

   /////////
   // Write a null string to the relevant properties.
   /////////

   memset(&property, 0, sizeof(property));

   status = NetpParmsSetUserProperty(
                (PWSTR)szUserParms,
                PROPERTY_PASSWORD,
                property,
                0,
                &tempUserParms,
                &updatePwd
                );
   if (!NT_SUCCESS(status)) { return RtlNtStatusToDosError(status); }

   status = NetpParmsSetUserProperty(
                tempUserParms,
                PROPERTY_USER_KEY,
                property,
                0,
                pszNewUserParms,
                &updateKey
                );

   NetpParmsUserPropertyFree(tempUserParms);

   if (NT_SUCCESS(status))
   {
      if (!updatePwd && !updateKey)
      {
         // Nothing changed so don't return the NewUserParms.
         NetpParmsUserPropertyFree(*pszNewUserParms);
         *pszNewUserParms = NULL;
      }

      return NO_ERROR;
   }

   return RtlNtStatusToDosError(status);
}

DWORD
WINAPI
IASParmsGetUserPassword(
    IN PCWSTR szUserParms,
    OUT PWSTR *pszPassword
    )
{
   DWORD status, nbyte;
   UNICODE_STRING userKey, encryptedPwd;
   WCHAR propFlag;
   HCRYPTKEY hKey;

   // Check the in parameters.
   if (pszPassword == NULL) { return ERROR_INVALID_PARAMETER; }

   // Make sure we're initialized.
   CHECK_INIT();

   // Read the user key.
   status = NetpParmsQueryUserProperty(
                (PWSTR)szUserParms,
                PROPERTY_USER_KEY,
                &propFlag,
                &userKey
                );
   if (!NT_SUCCESS(status))
   {
      status = RtlNtStatusToDosError(status);
      goto exit;
   }

   // Read the encrypted password.
   status = NetpParmsQueryUserProperty(
                (PWSTR)szUserParms,
                PROPERTY_PASSWORD,
                &propFlag,
                &encryptedPwd
                );
   if (!NT_SUCCESS(status))
   {
      status = RtlNtStatusToDosError(status);
      goto free_key;
   }

   // If they're both NULL, it's not an error. It just means the cleartext
   // password was never set.
   if (userKey.Buffer == NULL && encryptedPwd.Buffer == NULL)
   {
      *pszPassword = NULL;
      goto exit;
   }

   // Make sure the user key is the correct length.
   if (userKey.Length != USER_KEY_LENGTH)
   {
      status = ERROR_INVALID_DATA;
      goto free_password;
   }

   // Convert the user key to a cryptographic key.
   if (!IASDeriveUserCryptKey(
            (PBYTE)userKey.Buffer,
            &hKey
            ))
   {
      status = GetLastError();
      goto free_password;
   }

   // Decrypt the password.
   nbyte = encryptedPwd.Length;
   if (!CryptDecrypt(
            hKey,
            0,
            TRUE,
            0,
            (PBYTE)encryptedPwd.Buffer,
            &nbyte
            ))
   {
      status = GetLastError();
      goto destroy_key;
   }

   // We encrypted the terminating null, so it should still be there.
   if (encryptedPwd.Buffer[nbyte / sizeof(WCHAR) - 1] != L'\0')
   {
      status = ERROR_INVALID_DATA;
      goto destroy_key;
   }

   // Return the cleartext password to the caller.
   *pszPassword = encryptedPwd.Buffer;
   encryptedPwd.Buffer = NULL;

destroy_key:
   CryptDestroyKey(hKey);

free_password:
   LocalFree(encryptedPwd.Buffer);

free_key:
   LocalFree(userKey.Buffer);

exit:
   return status;
}

DWORD
WINAPI
IASParmsSetUserPassword(
    IN PCWSTR szUserParms,
    IN PCWSTR szPassword,
    OUT PWSTR *pszNewUserParms
    )
{
   DWORD status;
   BYTE userKey[USER_KEY_LENGTH];
   HCRYPTKEY hKey;
   DWORD nbyte;
   PBYTE encryptedPwd;
   UNICODE_STRING property;
   PWSTR tempUserParms;
   BOOL update;

   // Check the in parameters.
   if (szPassword == NULL) { return ERROR_INVALID_PARAMETER; }

   // Make sure we're initialized.
   CHECK_INIT();

   // Generate a user key.
   if (!CryptGenRandom(
            theContext,
            USER_KEY_LENGTH,
            userKey
            ))
   {
      status = GetLastError();
      goto exit;
   }

   // Convert the user key to a cryptographic key.
   if (!IASDeriveUserCryptKey(
            userKey,
            &hKey
            ))
   {
      status = GetLastError();
      goto exit;
   }

   // Allocate a buffer for the encrypted password.
   nbyte = sizeof(WCHAR) * (lstrlenW(szPassword) + 1);
   encryptedPwd = RtlAllocateHeap(
                      RasSfmHeap(),
                      0,
                      nbyte
                      );
   if (encryptedPwd == NULL)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto destroy_key;
   }

   memcpy(encryptedPwd, szPassword, nbyte);

   // Encrypt the password.
   if (!CryptEncrypt(
            hKey,
            0,
            TRUE,
            0,
            encryptedPwd,
            &nbyte,
            nbyte
            ))
   {
      status = GetLastError();
      goto free_encrypted_password;
   }

   /////////
   // Store the encrypted password.
   /////////

   property.Buffer = (PWCHAR)encryptedPwd;
   property.Length = (USHORT)nbyte;
   property.MaximumLength = (USHORT)nbyte;

   status = NetpParmsSetUserProperty(
                (PWSTR)szUserParms,
                PROPERTY_PASSWORD,
                property,
                0,
                &tempUserParms,
                &update
                );
   if (!NT_SUCCESS(status))
   {
      status = RtlNtStatusToDosError(status);
      goto free_encrypted_password;
   }

   /////////
   // Store the user key.
   /////////

   property.Buffer = (PWSTR)userKey;
   property.Length = USER_KEY_LENGTH;
   property.MaximumLength = USER_KEY_LENGTH;

   status = NetpParmsSetUserProperty(
                tempUserParms,
                PROPERTY_USER_KEY,
                property,
                0,
                pszNewUserParms,
                &update
                );
   if (!NT_SUCCESS(status)) { status = RtlNtStatusToDosError(status); }

   NetpParmsUserPropertyFree(tempUserParms);

free_encrypted_password:
   RtlFreeHeap(RasSfmHeap(), 0, encryptedPwd);

destroy_key:
   CryptDestroyKey(hKey);

exit:
   return status;
}

VOID
WINAPI
IASParmsFreeUserParms(
    IN LPWSTR szNewUserParms
    )
{
   NetpParmsUserPropertyFree(szNewUserParms);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\rassfm.c ===
/*++

Copyright (c) 1987-1997  Microsoft Corporation

Module Name:

    rassfm.c

Abstract:

    This module implements the subauthentication needed by the various RAS
    protocols (ARAP, MD5 etc.).
    It is adapted from the subauthentication sample from CliffV.

Author:

    Shirish Koti 28-Feb-97

Revisions:

     06/02/97 Steve Cobb, Added MD5-CHAP support


--*/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <windows.h>
#include <ntmsv1_0.h>
#include <crypt.h>
#include <samrpc.h>
#include <lsarpc.h>
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <samisrv.h>
#include <lsaisrv.h>
#include <ntlsa.h>
#include <lmcons.h>
#include <logonmsv.h>
#include <macfile.h>

#include <stdio.h>
#include <stdlib.h>

#include "rasman.h"
#include "rasfmsub.h"
#include "arapio.h"
#include "md5port.h"
#include "cleartxt.h"

#include "rassfm.h"

// Private heap used by the RASSFM module.
PVOID RasSfmPrivateHeap;

// Empty OWF password.
const NT_OWF_PASSWORD EMPTY_OWF_PASSWORD =
{
   {
      { '\x31', '\xD6', '\xCF', '\xE0', '\xD1', '\x6A', '\xE9', '\x31' },
      { '\xB7', '\x3C', '\x59', '\xD7', '\xE0', '\xC0', '\x89', '\xC0' }
   }
};

BOOL
RasSfmSubAuthEntry(
    IN HANDLE hinstDll,
    IN DWORD  fdwReason,
    IN LPVOID lpReserved
)
/*++

Routine Description:

    Entry point into the dll

Arguments:
    hinstDll   - handle
    fdwReason  - why the entry
    lpReserved -

Return Value:

    TRUE

--*/
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            RasSfmPrivateHeap = RtlCreateHeap(
                                    HEAP_GROWABLE,
                                    NULL,
                                    0,
                                    0,
                                    NULL,
                                    NULL
                                    );

            DisableThreadLibraryCalls( hinstDll );

            InitializeCriticalSection( &ArapDesLock );

            break;

        case DLL_PROCESS_DETACH:

            RtlDestroyHeap(RasSfmPrivateHeap);

            break;
    }

    return(TRUE);
}



NTSTATUS
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
)

/*++

Routine Description:

    This is the routine called in by the MSV package (if it was requested that
    the subauth package be called in), as a result of calling LsaLogonUser.
    This routine does RAS protocol specific authentication.

    In case of both ARAP and MD5 CHAP, the only thing we do in this routine is
    actual password authentication and leave everything else (logon hours, pwd
    expiry etc.) to the MSV package.

Arguments:

    LogonLevel       - we don't use it
    LogonInformation - contains the info our client side gave to us
    Flags            - we don't use this flag
    UserAll          - we get password creation,expiry times from this
    UserHandle       - we get the clear text password using this
    ValidationInfo   - set return info
    ActionsPerformed - we always set this to NTLM_SUBAUTH_PASSWORD to indicate
                       to the package that all we did was check for password


Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_WRONG_PASSWORD: The password was invalid.

--*/
{
    NTSTATUS                status;
    PNETLOGON_NETWORK_INFO  pLogonNetworkInfo;
    PRAS_SUBAUTH_INFO       pRasSubAuthInfo;



    pLogonNetworkInfo = (PNETLOGON_NETWORK_INFO) LogonInformation;

    pRasSubAuthInfo = (PRAS_SUBAUTH_INFO)
                        pLogonNetworkInfo->NtChallengeResponse.Buffer;

    switch (pRasSubAuthInfo->ProtocolType)
    {
        //
        // do the ARAP-specific authentication
        //
        case RAS_SUBAUTH_PROTO_ARAP:

            status = ArapSubAuthentication(pLogonNetworkInfo,
                                           UserAll,
                                           UserHandle,
                                           ValidationInfo);


            ValidationInfo->Authoritative = TRUE;

            *ActionsPerformed = MSV1_0_SUBAUTH_PASSWORD;

            break;


        // MD5 CHAP subauthentication.
        //
        case RAS_SUBAUTH_PROTO_MD5CHAP:
        {
            // Subauthenticate the user account.
            //
            status = MD5ChapSubAuthentication(
                         UserHandle,
                         UserAll,
                         pRasSubAuthInfo
                         );

            // No validation information is returned.  Might want to return a
            // session key here in the future.
            //
            ValidationInfo->WhichFields = 0;
            ValidationInfo->Authoritative = TRUE;

            *ActionsPerformed = MSV1_0_SUBAUTH_PASSWORD;
            break;
        }

        // MD5 CHAP Ex subauthentication.
        //
        case RAS_SUBAUTH_PROTO_MD5CHAP_EX:
        {
            // Subauthenticate the user account.
            //
            status = MD5ChapExSubAuthentication(
                         UserHandle,
                         UserAll,
                         pRasSubAuthInfo
                         );

            // No validation information is returned.  Might want to return a
            // session key here in the future.
            //
            ValidationInfo->WhichFields = 0;
            ValidationInfo->Authoritative = TRUE;

            *ActionsPerformed = MSV1_0_SUBAUTH_PASSWORD;
            break;
        }

        default:

            DBGPRINT("RASSFM subauth pkg: bad protocol type %d\n",
                pRasSubAuthInfo->ProtocolType);

            status = STATUS_WRONG_PASSWORD;

            break;

    }

    return(status);

}


NTSTATUS
Msv1_0SubAuthenticationRoutineGeneric(
    IN  PVOID   SubmitBuffer,
    IN  ULONG   SubmitBufferLength,
    OUT PULONG  ReturnBufferLength,
    OUT PVOID  *ReturnBuffer
)

/*++

Routine Description:

    This is the routine called in by the MSV package (if it was requested that
    the subauth package be called in), as a result of calling
    LsaCallAuthenticationPackage.  This routine does RAS protocol specific
    functions.

    In case of ARAP, we implement change password functionality in this routine.

Arguments:

    SubmitBuffer       - the buffer containing password change info
    SubmitBufferLength - length of this buffer
    ReturnBufferLength - we don't use it
    ReturnBuffer       - we don't use it

Return Value:

    STATUS_SUCCESS: if there was no error.

--*/

{

    PARAP_SUBAUTH_REQ       pArapSubAuthInfo;
    PUNICODE_STRING         pUserName;
    PUNICODE_STRING         pDomainName;
    PRAS_SUBAUTH_INFO       pRasSubAuthInfo;
    NTSTATUS                status;




    pRasSubAuthInfo = (PRAS_SUBAUTH_INFO)SubmitBuffer;

    switch (pRasSubAuthInfo->ProtocolType)
    {
        //
        // do the ARAP-specific authentication
        //
        case RAS_SUBAUTH_PROTO_ARAP:

            status = ArapChangePassword(pRasSubAuthInfo,
                                        ReturnBufferLength,
                                        ReturnBuffer);

            break;

        default:

            DBGPRINT("Msv1_0SubAuthenticationRoutineGeneric: bad protocol type\n");

            ASSERT(0);

            status = STATUS_UNSUCCESSFUL;

    }

    return(status);

}


NTSTATUS
ArapSubAuthentication(
    IN OUT PNETLOGON_NETWORK_INFO  pLogonNetworkInfo,
    IN     PUSER_ALL_INFORMATION   UserAll,
    IN     SAM_HANDLE              UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo
)
/*++

Routine Description:

    This is the routine that does the actuall authentication.  It retrieves
    the clear-text password, does the DES encryption of the challenge and
    compares with what the Mac client has sent to determine if authentication
    succeeded.  Also, it returns a response to the challenge sent to us by
    the Mac.

Arguments:

    pLogonNetworkInfo  - ptr to the NETLOGON_NETWORK_INFO struct
    UserAll            - ptr to the USER_ALL_INFORMATION struct
    UserHandle         - sam handle for the user
    ValidationInfo     - what we return to our caller

Return Value:

    STATUS_SUCCESS: if authentication succeeded, appropriate error otherwise

--*/

{

    NTSTATUS                status;
    PARAP_SUBAUTH_REQ       pArapSubAuthInfo;
    ARAP_CHALLENGE          Challenge;
    PARAP_SUBAUTH_RESP      pArapResp;
    PUNICODE_STRING         pUserName;
    PUNICODE_STRING         pDomainName;
    UNICODE_STRING          UnicodePassword;
    ANSI_STRING             AnsiPassword;
    PRAS_SUBAUTH_INFO       pRasSubAuthInfo;
    DWORD                   Response1;
    DWORD                   Response2;
    UCHAR                   ClearTextPassword[64];
    BOOLEAN                 fCallerIsArap;


    pRasSubAuthInfo = (PRAS_SUBAUTH_INFO)
                        pLogonNetworkInfo->NtChallengeResponse.Buffer;

    pArapSubAuthInfo = (PARAP_SUBAUTH_REQ)&pRasSubAuthInfo->Data[0];

    //
    // NOTE: this is a quick-n-dirty workaround to returning a clean buffer
    // We use the KickoffTime,LogoffTime and SessionKey fields of ValidationInfo
    // The SessionKey is a 16 byte field.  We use only 12 bytes, but be careful
    // not to exceed it!!
    ASSERT(sizeof(ARAP_SUBAUTH_RESP) <= sizeof(USER_SESSION_KEY));

    //
    // store the password create and expiry date: we need to send it to Mac
    //
    ValidationInfo->KickoffTime = UserAll->PasswordLastSet;
    ValidationInfo->LogoffTime = UserAll->PasswordMustChange;

    ValidationInfo->WhichFields = ( MSV1_0_VALIDATION_LOGOFF_TIME  |
                                    MSV1_0_VALIDATION_KICKOFF_TIME |
                                    MSV1_0_VALIDATION_SESSION_KEY  |
                                    MSV1_0_VALIDATION_USER_FLAGS );

    ValidationInfo->UserFlags = 0;

    pArapResp = (PARAP_SUBAUTH_RESP)&ValidationInfo->SessionKey;

    if ((pArapSubAuthInfo->PacketType != ARAP_SUBAUTH_LOGON_PKT) &&
        (pArapSubAuthInfo->PacketType != SFM_SUBAUTH_LOGON_PKT))
    {
        DBGPRINT("ARAPSubAuth: PacketType is not ARAP, returning failure\n");
        pArapResp->Result = ARAPERR_BAD_FORMAT;
        return(STATUS_UNSUCCESSFUL);
    }

    fCallerIsArap = (pArapSubAuthInfo->PacketType == ARAP_SUBAUTH_LOGON_PKT);

    //
    // presently no one calls with fGuestLogon.  If in future, we need Guest logon,
    // then we will have to check if (Flags & MSV1_0_GUEST_LOGON) is set to allow
    // Guest logon.  Right now, we fail the request.
    //
    if (pArapSubAuthInfo->Logon.fGuestLogon)
    {
        DBGPRINT("ARAPSubAuth: how come guest logon is reaching here??\n");
        ASSERT(0);
        pArapResp->Result = ARAPERR_AUTH_FAILURE;
        return(STATUS_UNSUCCESSFUL);
    }

    pUserName = &pLogonNetworkInfo->Identity.UserName;
    pDomainName = &pLogonNetworkInfo->Identity.LogonDomainName;


    status = RetrieveCleartextPassword(UserHandle, UserAll, &UnicodePassword);
    if (status != STATUS_SUCCESS)
    {
        DBGPRINT("ARAPSubAuth: RetrieveCleartextPassword failed %lx\n",status);
        pArapResp->Result = ARAPERR_PASSWD_NOT_AVAILABLE;
        return(STATUS_UNSUCCESSFUL);
    }

    RtlZeroMemory(ClearTextPassword, sizeof(ClearTextPassword));

    AnsiPassword.Length = AnsiPassword.MaximumLength = sizeof(ClearTextPassword);
    AnsiPassword.Buffer = ClearTextPassword;

    status = RtlUnicodeStringToAnsiString( &AnsiPassword, &UnicodePassword, FALSE );

    ZeroMemory(UnicodePassword.Buffer, UnicodePassword.Length);

    // we don't need the unicode password anymore
    RtlFreeUnicodeString(&UnicodePassword);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT("ARAPSubAuth: RtlUnicodeStringToAnsiString failed %lx\n",status);
        pArapResp->Result = ARAPERR_PASSWD_NOT_AVAILABLE;
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Mac sends challenge to us as well: compute the response
    //
    Challenge.high = pArapSubAuthInfo->Logon.MacChallenge1;
    Challenge.low  = pArapSubAuthInfo->Logon.MacChallenge2;


    EnterCriticalSection( &ArapDesLock );

    if (fCallerIsArap)
    {
        DoDesInit(ClearTextPassword, TRUE);
    }

    //
    // RandNum expects the low-bit of each byte (of password) to be cleared
    // during key-generation
    //
    else
    {
        DoDesInit(ClearTextPassword, FALSE);
    }

    DoTheDESEncrypt((PBYTE)&Challenge);


    //
    // copy the response that needs to be sent back to the Mac
    //
    pArapResp->Response = Challenge;


    //
    // encrypt the challenge that we sent to find out if this Mac is honest
    //
    Challenge.high = pArapSubAuthInfo->Logon.NTChallenge1;
    Challenge.low  = pArapSubAuthInfo->Logon.NTChallenge2;


    DoTheDESEncrypt((PBYTE)&Challenge);


    Response1 = Challenge.high;
    Response2 = Challenge.low;

    DoDesEnd();

    LeaveCriticalSection( &ArapDesLock );

    //
    // zero the clear text password: we don't need it hanging around
    //
    RtlZeroMemory(ClearTextPassword, sizeof(ClearTextPassword));


    //
    // does the response returned by the Mac match ours?
    //
    if ((Response1 == pArapSubAuthInfo->Logon.MacResponse1) &&
        (Response2 == pArapSubAuthInfo->Logon.MacResponse2))
    {
        pArapResp->Result = ARAPERR_NO_ERROR;
        status = STATUS_SUCCESS;
    }
    else
    {
        DBGPRINT("ARAPSubAuth: our Challenge: %lx %lx\n",
            pArapSubAuthInfo->Logon.NTChallenge1,pArapSubAuthInfo->Logon.NTChallenge2);

        DBGPRINT("ARAPSubAuth: Response don't match! (ours %lx %lx vs. Mac's %lx %lx)\n",
            Response1,Response2,pArapSubAuthInfo->Logon.MacResponse1,
            pArapSubAuthInfo->Logon.MacResponse2);

        pArapResp->Response.high = 0;
        pArapResp->Response.low  = 0;

        pArapResp->Result = ARAPERR_AUTH_FAILURE;
        status = STATUS_WRONG_PASSWORD;
    }

    return(status);

}

NTSTATUS
ArapChangePassword(
    IN  OUT PRAS_SUBAUTH_INFO    pRasSubAuthInfo,
    OUT PULONG                   ReturnBufferLength,
    OUT PVOID                   *ReturnBuffer
)
/*++

Routine Description:

    This routine is called to change the password of the user in question.
    It first retrieves the clear-text password, does the DES decryption of the
    munged old password and munged new password to get the clear-text old and
    new passwords; makes sure that the old password matches with what we have
    as the password and then finally, sets the new password.

Arguments:

    pRasSubAuthInfo    - ptr to RAS_SUBAUTH_INFO struct: input data
    ReturnBufferLength - how much are we returning
    ReturnBuffer       - what we return: output data

Return Value:

    STATUS_SUCCESS: if password change succeeded, appropriate error otherwise

--*/

{
    NTSTATUS                    status;
    PARAP_SUBAUTH_REQ           pArapSubAuthInfo;
    PARAP_SUBAUTH_RESP          pArapResp;
    UNICODE_STRING              UserName;
    UNICODE_STRING              PackageName;
    UNICODE_STRING              UnicodePassword;
    ANSI_STRING                 AnsiPassword;
    USER_INFORMATION_CLASS      UserInformationClass;
    USER_ALL_INFORMATION        UserAllInfo;
    ARAP_CHALLENGE              Challenge;
    USER_PARAMETERS_INFORMATION *oldParmInfo=NULL;
    PSAMPR_USER_ALL_INFORMATION UserParmInfo=NULL;
    UCHAR                       OldPwd[32];
    UCHAR                       NewPwd[32];
    UCHAR                       MacsOldPwd[32];
    WCHAR                       NtPassword[40];
    UCHAR                       NewPwdLen;
    UCHAR                       OldPwdLen;
    UCHAR                       MacOldPwdLen;
    SAMPR_HANDLE                UserHandle;
    PVOID                       Credentials;
    DWORD                       CredentialSize;
    PUCHAR                      pBufPtr;
    BOOLEAN                     fCallerIsArap;
    UCHAR                       FirstByte;
    BOOLEAN                     fPasswordAvailable=TRUE;
    UCHAR                       i;




    *ReturnBuffer = MIDL_user_allocate( sizeof(ARAP_SUBAUTH_RESP) );

    if (*ReturnBuffer == NULL)
    {
        DBGPRINT("ARAPChgPwd: MIDL_alloc failed!\n");
        *ReturnBufferLength = 0;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    *ReturnBufferLength = sizeof(ARAP_SUBAUTH_RESP);

    pArapResp = (PARAP_SUBAUTH_RESP)*ReturnBuffer;


    pArapSubAuthInfo = (PARAP_SUBAUTH_REQ)&pRasSubAuthInfo->Data[0];

    if ((pArapSubAuthInfo->PacketType != ARAP_SUBAUTH_CHGPWD_PKT) &&
        (pArapSubAuthInfo->PacketType != SFM_SUBAUTH_CHGPWD_PKT))
    {
        DBGPRINT("ARAPChgPwd: bad packet type %d!\n",pArapSubAuthInfo->PacketType);
        pArapResp->Result = ARAPERR_BAD_FORMAT;
        return(STATUS_UNSUCCESSFUL);
    }

    fCallerIsArap = (pArapSubAuthInfo->PacketType == ARAP_SUBAUTH_CHGPWD_PKT);

    UserName.Length = (sizeof(WCHAR) * wcslen(pArapSubAuthInfo->ChgPwd.UserName));
    UserName.MaximumLength = UserName.Length;

    UserName.Buffer = pArapSubAuthInfo->ChgPwd.UserName;

    status = ArapGetSamHandle(&UserHandle, &UserName);

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT("Arap: ArapGetSamHandle failed with %lx\n", status);
        pArapResp->Result = ARAPERR_COULDNT_GET_SAMHANDLE;
        return(status);
    }

    RtlZeroMemory(OldPwd, sizeof(OldPwd));
    RtlZeroMemory(MacsOldPwd, sizeof(MacsOldPwd));
    RtlZeroMemory(NewPwd, sizeof(NewPwd));


    //
    // are we on a DS?
    //
    if (SampUsingDsData())
    {
        RtlInitUnicodeString( &PackageName, CLEAR_TEXT_PWD_PACKAGE );

        //
        // get the clear text password
        //
        status = SamIRetrievePrimaryCredentials( (PVOID)UserHandle,
                                                 &PackageName,
                                                 &Credentials,
                                                 &CredentialSize );
        if (status != STATUS_SUCCESS)
        {
            DBGPRINT("ARAPSubAuth: SamI...Credentials failed %lx\n",status);
            pArapResp->Result = ARAPERR_PASSWD_NOT_AVAILABLE;
            SamrCloseHandle( &UserHandle );
            return(status);
        }

        //
        // if we are returned a null password, it could be that the password is really
        // null, or that cleartext password isn't available for this user.  If it's
        // the latter, we need to bail out!
        //
        if (CredentialSize == 0)
        {
            // get the OWF for this user
            status = SamrQueryInformationUser( UserHandle,
                                               UserParametersInformation,
                                               (PSAMPR_USER_INFO_BUFFER*)&oldParmInfo);

            //
            // if the call failed, or if the user's password is not null, bail out!
            //
            if ( !NT_SUCCESS(status) ||
                 (oldParmInfo->Parameters.Length != NT_OWF_PASSWORD_LENGTH) ||
                 (memcmp(oldParmInfo->Parameters.Buffer,
                         &EMPTY_OWF_PASSWORD,
                         NT_OWF_PASSWORD_LENGTH)) )
            {
                fPasswordAvailable = FALSE;
            }

            if (NT_SUCCESS(status))
            {
                SamIFree_SAMPR_USER_INFO_BUFFER( (PSAMPR_USER_INFO_BUFFER)oldParmInfo,
                                                 UserParametersInformation);
            }

            if (!fPasswordAvailable)
            {
                DBGPRINT("ArapChangePassword: password not available\n");
                pArapResp->Result = ARAPERR_PASSWD_NOT_AVAILABLE;
                LocalFree( Credentials );
                SamrCloseHandle( &UserHandle );
                return(status);
            }
        }


        // convert to wide-char size
        CredentialSize = (CredentialSize/sizeof(WCHAR));


        if (CredentialSize > sizeof(OldPwd))
        {
            DBGPRINT("ArapChangePassword: pwd too long (%d bytes)\n",CredentialSize);
            pArapResp->Result = ARAPERR_PASSWORD_TOO_LONG;
            LocalFree( Credentials );
            SamrCloseHandle( &UserHandle );
            return(STATUS_WRONG_PASSWORD);
        }

        wcstombs(OldPwd, Credentials, CredentialSize);

        ZeroMemory( Credentials, CredentialSize );
        LocalFree( Credentials );
    }

    //
    // we are not running on the DS, but on a Standalone (workgroup) box.  We need to
    // retrieve the cleartext pwd differently
    //
    else
    {
        // get the user parms
        status = SamrQueryInformationUser( UserHandle,
                                           UserAllInformation,
                                           (PSAMPR_USER_INFO_BUFFER *)&UserParmInfo);

        if (!NT_SUCCESS(status))
        {
            DBGPRINT("ARAPSubAuth: SamrQueryInformationUser failed %lx\n",status);
            pArapResp->Result = ARAPERR_PASSWD_NOT_AVAILABLE;
            SamrCloseHandle( &UserHandle );
            return(status);
        }

        status = IASParmsGetUserPassword(UserParmInfo->Parameters.Buffer,
                                         &UnicodePassword.Buffer);

        SamIFree_SAMPR_USER_INFO_BUFFER((PSAMPR_USER_INFO_BUFFER)UserParmInfo,
                                            UserAllInformation);

        if ((status != STATUS_SUCCESS) || (UnicodePassword.Buffer == NULL))
        {
            DBGPRINT("ARAPSubAuth: IASParmsGetUserPassword failed %lx\n",status);
            pArapResp->Result = ARAPERR_PASSWD_NOT_AVAILABLE;
            SamrCloseHandle( &UserHandle );
            return(STATUS_WRONG_PASSWORD);
        }

        UnicodePassword.MaximumLength =
            UnicodePassword.Length = (USHORT)(wcslen(UnicodePassword.Buffer) * sizeof( WCHAR ));

        AnsiPassword.Length = AnsiPassword.MaximumLength = sizeof(OldPwd);
        AnsiPassword.Buffer = OldPwd;

        status = RtlUnicodeStringToAnsiString( &AnsiPassword, &UnicodePassword, FALSE );

        ZeroMemory(UnicodePassword.Buffer, UnicodePassword.Length);

        // we don't need the unicode password anymore
        RtlFreeUnicodeString(&UnicodePassword);

        if (!NT_SUCCESS(status))
        {
            DBGPRINT("ARAPSubAuth: RtlUnicodeStringToAnsiString failed %lx\n",status);
            pArapResp->Result = ARAPERR_PASSWD_NOT_AVAILABLE;
            SamrCloseHandle( &UserHandle );
            return(STATUS_UNSUCCESSFUL);
        }
    }


    //
    // password change happens differently for ARAP and SFM: in ARAP, the old pwd
    // as well as the new pwd are encrypted using the old pwd.  In SFM, old pwd is
    // encrypted with the new pwd (the first 8 bytes in after username), and the
    // new pwd is encrypted with the old pwd (the next 8 bytes)
    //
    if (fCallerIsArap)
    {

        //
        // first, get the get the old password out (the way Mac knows it)
        //

        pBufPtr = &pArapSubAuthInfo->ChgPwd.OldMunge[0];

        EnterCriticalSection( &ArapDesLock );

        DoDesInit(OldPwd, TRUE);

        // first 8 bytes of mangled old password

        pBufPtr = &pArapSubAuthInfo->ChgPwd.OldMunge[0];
        Challenge.high = (*((DWORD *)(pBufPtr)));
        pBufPtr += 4;
        Challenge.low  = (*((DWORD *)(pBufPtr)));

        DoTheDESDecrypt((PBYTE)&Challenge);

        RtlCopyMemory(MacsOldPwd, (PBYTE)&Challenge, 8);

        // next 8 bytes of mangled old password

        pBufPtr += 4;
        Challenge.high = (*((DWORD *)(pBufPtr)));
        pBufPtr += 4;
        Challenge.low  = (*((DWORD *)(pBufPtr)));

        DoTheDESDecrypt((PBYTE)&Challenge);

        RtlCopyMemory(MacsOldPwd+8, (PBYTE)&Challenge, 8);


        //
        // now, get the new password
        //

        // first 8 bytes of the mangled new password

        pBufPtr = &pArapSubAuthInfo->ChgPwd.NewMunge[0];
        Challenge.high = (*((DWORD *)(pBufPtr)));
        pBufPtr += 4;
        Challenge.low  = (*((DWORD *)(pBufPtr)));

        DoTheDESDecrypt((PBYTE)&Challenge);

        RtlCopyMemory(NewPwd, (PBYTE)&Challenge, 8);

        // next 8 bytes of the mangled new password

        pBufPtr += 4;
        Challenge.high = (*((DWORD *)(pBufPtr)));
        pBufPtr += 4;
        Challenge.low  = (*((DWORD *)(pBufPtr)));

        DoTheDESDecrypt((PBYTE)&Challenge);

        RtlCopyMemory(NewPwd+8, (PBYTE)&Challenge, 8);

        DoDesEnd();

        LeaveCriticalSection( &ArapDesLock );

        MacOldPwdLen = MacsOldPwd[0];
        NewPwdLen = NewPwd[0];
        FirstByte = 1;
    }
    else
    {
        // using old pwd as the key, get the new pwd out

        EnterCriticalSection( &ArapDesLock );

        DoDesInit(OldPwd, FALSE);    // clear low-bit

        pBufPtr = &pArapSubAuthInfo->ChgPwd.NewMunge[0];

        Challenge.high = (*((DWORD *)(pBufPtr)));
        pBufPtr += 4;
        Challenge.low  = (*((DWORD *)(pBufPtr)));

        DoTheDESDecrypt((PBYTE)&Challenge);

        RtlCopyMemory(NewPwd, (PBYTE)&Challenge, 8);

        DoDesEnd();

        //
        // now, we need to get the old pwd out so that we can make sure the
        // guy really had the pwd to begin with
        //
        DoDesInit(NewPwd, FALSE);    // clear low-bit

        pBufPtr = &pArapSubAuthInfo->ChgPwd.OldMunge[0];

        Challenge.high = (*((DWORD *)(pBufPtr)));
        pBufPtr += 4;
        Challenge.low  = (*((DWORD *)(pBufPtr)));

        DoTheDESDecrypt((PBYTE)&Challenge);

        RtlCopyMemory(MacsOldPwd, (PBYTE)&Challenge, 8);

        DoDesEnd();

        LeaveCriticalSection( &ArapDesLock );

        MacOldPwdLen = (UCHAR)strlen((PBYTE)MacsOldPwd);
        NewPwdLen = (UCHAR)strlen((PBYTE)NewPwd);
        FirstByte = 0;
    }


    OldPwdLen = (UCHAR)strlen((PBYTE)OldPwd);


    if ((MacOldPwdLen != OldPwdLen) || (MacOldPwdLen > MAX_MAC_PWD_LEN))
    {
        DBGPRINT("ArapChangePassword: Length mismatch! old len %d, oldMacLen %d\n",
            OldPwdLen,MacOldPwdLen);

        pArapResp->Result = ARAPERR_PASSWORD_TOO_LONG;

        SamrCloseHandle( &UserHandle );

        RtlZeroMemory(OldPwd, sizeof(OldPwd));
        RtlZeroMemory(MacsOldPwd, sizeof(MacsOldPwd));
        RtlZeroMemory(NewPwd, sizeof(NewPwd));

        return(STATUS_LOGON_FAILURE);
    }

    //
    // make sure the guy really knew the password to begin with
    //
    for (i=0; i<MacOldPwdLen ; i++)
    {
        if (MacsOldPwd[FirstByte+i] != OldPwd[i])
        {
            DBGPRINT("ArapChgPwd: bad pwd: oldpwd=%s Mac's pwd=%s newpwd=%s\n",
                OldPwd,&MacsOldPwd[1],&NewPwd[1]);

            pArapResp->Result = ARAPERR_BAD_PASSWORD;

            SamrCloseHandle( &UserHandle );

            RtlZeroMemory(OldPwd, sizeof(OldPwd));
            RtlZeroMemory(MacsOldPwd, sizeof(MacsOldPwd));
            RtlZeroMemory(NewPwd, sizeof(NewPwd));

            return(STATUS_LOGON_FAILURE);
        }
    }


    RtlZeroMemory(NtPassword, sizeof(NtPassword));

    //
    // convert the thing to unicode..
    // first byte in newpwd is length of the passwd
    //
    mbstowcs(NtPassword, &NewPwd[FirstByte], NewPwdLen);

    NtPassword[NewPwdLen] = 0;

    RtlZeroMemory( &UserAllInfo, sizeof(UserAllInfo) );

    UserAllInfo.UserName.Length = UserName.Length;
    UserAllInfo.UserName.MaximumLength = UserName.MaximumLength;
    UserAllInfo.UserName.Buffer = UserName.Buffer;

    UserAllInfo.WhichFields = USER_ALL_NTPASSWORDPRESENT;
    UserAllInfo.NtPassword.Length = wcslen(NtPassword) * sizeof(WCHAR);
    UserAllInfo.NtPassword.MaximumLength = wcslen(NtPassword) * sizeof(WCHAR);
    UserAllInfo.NtPassword.Buffer = NtPassword;

    status = SamrSetInformationUser( UserHandle,
                                     UserAllInformation,
                                     (PSAMPR_USER_INFO_BUFFER)&UserAllInfo);


    SamrCloseHandle( &UserHandle );


    //
    // wipe out all the clear-text passwords
    //
    RtlZeroMemory(OldPwd, sizeof(OldPwd));
    RtlZeroMemory(NewPwd, sizeof(NewPwd));
    RtlZeroMemory((PUCHAR)NtPassword, sizeof(NtPassword));

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT("ARAPSubAuth: SamrSetInfo.. failed %lx\n",status);
        pArapResp->Result = ARAPERR_SET_PASSWD_FAILED;
        return(STATUS_UNSUCCESSFUL);
    }

    pArapResp->Result = ARAPERR_NO_ERROR;


    return(STATUS_SUCCESS);

}



NTSTATUS
ArapGetSamHandle(
    IN PVOID             *pUserHandle,
    IN PUNICODE_STRING    pUserName
)
/*++

Routine Description:

    This routine gets sam handle to the specified user (when we get into the
    subauth pkg for a password change, we don't have user's sam handle).

Arguments:

    pUserHandle        - sam handle, on return
    pUserName          - name of the user in question

Return Value:

    STATUS_SUCCESS: if handle retrieved successfully,
                    appropriate error otherwise

--*/

{

    NTSTATUS                    status;
    PLSAPR_POLICY_INFORMATION   PolicyInfo = NULL;
    SAMPR_HANDLE                SamHandle = NULL;
    SAMPR_HANDLE                DomainHandle = NULL;
    SAMPR_ULONG_ARRAY           RidArray;
    SAMPR_ULONG_ARRAY           UseArray;



    RidArray.Element = NULL;
    UseArray.Element = NULL;

    status = LsaIQueryInformationPolicyTrusted(
                    PolicyAccountDomainInformation,
                    &PolicyInfo);

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT("ArapGetSamHandle: LsaI...Trusted failed with %lx\n", status);
        goto ArapGetSamHandle_Exit;
    }


    status = SamIConnect(
                    NULL,                   // no server name
                    &SamHandle,
                    0,                      // no desired access
                    TRUE                    // trusted caller
                    );

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT("ArapGetSamHandle: SamIConnect failed with %lx\n", status);
        goto ArapGetSamHandle_Exit;
    }

    status = SamrOpenDomain(
                    SamHandle,
                    0,                      // no desired access
                    (PRPC_SID) PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                    &DomainHandle);

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT("ArapGetSamHandle: SamrOpenDomain failed with %lx\n", status);
        goto ArapGetSamHandle_Exit;
    }

    status = SamrLookupNamesInDomain(
                    DomainHandle,
                    1,
                    (PRPC_UNICODE_STRING) pUserName,
                    &RidArray,
                    &UseArray);

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT("ArapGetSamHandle: Samr..Domain failed with %lx\n", status);
        goto ArapGetSamHandle_Exit;
    }

    if (UseArray.Element[0] != SidTypeUser)
    {
        DBGPRINT("ArapGetSamHandle: didn't find our user\n");
        goto ArapGetSamHandle_Exit;
    }


    //
    // Finally open the user
    //
    status = SamrOpenUser(
                    DomainHandle,
                    0,                      // no desired access,
                    RidArray.Element[0],
                    pUserHandle);


    if (status != STATUS_SUCCESS)
    {
        DBGPRINT("ArapGetSamHandle: SamrOpenUser failed with %lx\n", status);
        goto ArapGetSamHandle_Exit;
    }


ArapGetSamHandle_Exit:

    if (DomainHandle != NULL)
    {
        SamrCloseHandle( &DomainHandle );
    }

    if (SamHandle != NULL)
    {
        SamrCloseHandle( &SamHandle );
    }

    if (PolicyInfo != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
                    PolicyAccountDomainInformation,
                    PolicyInfo);
    }

    SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

    SamIFree_SAMPR_ULONG_ARRAY( &RidArray );

    return(status);
}


NTSTATUS
DeltaNotify(
    IN PSID                     DomainSid,
    IN SECURITY_DB_DELTA_TYPE   DeltaType,
    IN SECURITY_DB_OBJECT_TYPE  ObjectType,
    IN ULONG                    ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER           ModifiedCount,
    IN PSAM_DELTA_DATA          DeltaData
)
{
    DWORD               dwRetCode;
    AFP_SERVER_HANDLE   hAfpServer;
    AFP_SERVER_INFO     afpInfo;


    // ignore any changes other than those to user
    if (ObjectType != SecurityDbObjectSamUser)
    {
        return(STATUS_SUCCESS);
    }

    // we only care about guest account: ignore the notification for other users
    if (ObjectRid != DOMAIN_USER_RID_GUEST)
    {
        return(STATUS_SUCCESS);
    }

    // enable/disable of guest account is all that's interesting to us
    if (DeltaType != SecurityDbChange)
    {
        return(STATUS_SUCCESS);
    }

    // if there is no DeltaData, account enable/disable hasn't been affected
    if (!DeltaData)
    {
        return(STATUS_SUCCESS);
    }

    //
    // ok, looks like Guest account was enabled (or disabled).  Connect to the
    // SFM service on this machine.  If we fail, that means SFM is not started
    // In that case, ignore this change
    //
    dwRetCode = AfpAdminConnect(NULL, &hAfpServer);

    // if we couldn't connect, don't bother: just ignore this notification
    if (dwRetCode != NO_ERROR)
    {
        DBGPRINT("DeltaNotify: AfpAdminConnect failed, dwRetCode = %ld\n",dwRetCode);
        return(STATUS_SUCCESS);
    }

    RtlZeroMemory(&afpInfo, sizeof(AFP_SERVER_INFO));

    //
    // find out if the guest account is enabled or disabled and set the flag
    // appropriately
    //
    if (!(DeltaData->AccountControl & USER_ACCOUNT_DISABLED))
    {
        afpInfo.afpsrv_options = AFP_SRVROPT_GUESTLOGONALLOWED;
    }

    dwRetCode = AfpAdminServerSetInfo(hAfpServer,
                                      (LPBYTE)&afpInfo,
                                      AFP_SERVER_GUEST_ACCT_NOTIFY);

    AfpAdminDisconnect(hAfpServer);

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\md5port.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    md5port.c
//
// SYNOPSIS
//
//    Defines the NT5 specific routines used for MD5-CHAP support.
//
// MODIFICATION HISTORY
//
//    10/13/1998    Original version.
//    11/17/1998    Strip the trailing null.
//    02/24/1999    Check for empty OWF password when credentials are
//                  zero length.
//    05/24/1999    SAM now returns error if cleartext password not set.
//    10/21/1999    Return STATUS_DS_NO_ATTRIBUTE_OR_VALUE if reversibly
//                  encyrpted password is not set.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>

#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>

#include <cleartxt.h>
#include <subauth.h>

// TRUE if this API has been successfully initialized.
static BOOL theInitFlag;

//////////
// Macro that ensures the API has been initialized and bails on failure.
//////////
#define CHECK_INIT() \
  if (!theInitFlag) { \
    status = InitializePolicy(); \
    if (!NT_SUCCESS(status)) { return status; } \
  }

// Name of the cleartext package.
static UNICODE_STRING CLEARTEXT_PACKAGE_NAME = { 18, 20, L"CLEARTEXT" };

// Flag indicating whether this is a native-mode DC.
static BOOL theNativeFlag;

//////////
// Initializes theNativeFlag.
//////////
NTSTATUS
NTAPI
InitializePolicy( VOID )
{
   NTSTATUS status;
   SAMPR_HANDLE hDomain;

   status = GetDomainHandle(&hDomain);
   if (NT_SUCCESS(status))
   {
      if (SampUsingDsData() && !SamIMixedDomain(hDomain))
      {
         theNativeFlag = TRUE;
      }
   }

   return status;
}

//////////
// Determines whether a cleartext password should be stored for the user.
//////////
NTSTATUS
NTAPI
IsCleartextEnabled(
    IN SAMPR_HANDLE UserHandle,
    OUT PBOOL Enabled
    )
{
   NTSTATUS status;
   PUSER_CONTROL_INFORMATION uci;
   SAMPR_HANDLE hDomain;
   PDOMAIN_PASSWORD_INFORMATION dpi;

   CHECK_INIT();

   if (theNativeFlag)
   {
      // In native-mode domains, we never store the cleartext password since
      // the DS will take care of this for us.
      *Enabled = FALSE;
      return STATUS_SUCCESS;
   }

   //////////
   // First check the user's flags since we already have the handle.
   //////////

   uci = NULL;
   status = SamrQueryInformationUser(
                UserHandle,
                UserControlInformation,
                (PSAMPR_USER_INFO_BUFFER*)&uci
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   if (uci->UserAccountControl & USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED)
   {
      *Enabled = TRUE;
      goto free_user_info;
   }

   //////////
   // Then check the domain flags.
   //////////

   status = GetDomainHandle(&hDomain);
   if (!NT_SUCCESS(status)) { goto free_user_info; }

   dpi = NULL;
   status = SamrQueryInformationDomain(
                hDomain,
                DomainPasswordInformation,
                (PSAMPR_DOMAIN_INFO_BUFFER*)&dpi
                );
   if (!NT_SUCCESS(status)) { goto free_user_info; }

   if (dpi->PasswordProperties & DOMAIN_PASSWORD_STORE_CLEARTEXT)
   {
      *Enabled = TRUE;
   }
   else
   {
      *Enabled = FALSE;
   }

   SamIFree_SAMPR_DOMAIN_INFO_BUFFER(
       (PSAMPR_DOMAIN_INFO_BUFFER)dpi,
       DomainPasswordInformation
       );

free_user_info:
   SamIFree_SAMPR_USER_INFO_BUFFER(
       (PSAMPR_USER_INFO_BUFFER)uci,
       UserControlInformation
       );

exit:
   return status;
}

//////////
// Retrieves the user's cleartext password. The returned password should be
// freed through RtlFreeUnicodeString.
//////////
NTSTATUS
NTAPI
RetrieveCleartextPassword(
    IN SAM_HANDLE UserHandle,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PUNICODE_STRING Password
    )
{
   NTSTATUS status;
   PWCHAR credentials;
   ULONG credentialSize;

   if (SampUsingDsData())
   {
      // If we're a DC, then retrieve the credentials from the DS.
      status = SamIRetrievePrimaryCredentials(
                   UserHandle,
                   &CLEARTEXT_PACKAGE_NAME,
                   (PVOID *)&credentials,
                   &credentialSize
                   );

      if (NT_SUCCESS(status))
      {
         Password->Buffer = (PWSTR)credentials;
         Password->Length = Password->MaximumLength = (USHORT)credentialSize;

         // Strip the trailing null (if any).
         if (credentialSize >= sizeof(WCHAR) &&
             Password->Buffer[credentialSize / sizeof(WCHAR) - 1] == L'\0')
         {
            Password->Length -= (USHORT)sizeof(WCHAR);
         }
      }
   }
   else if (UserAll->Parameters.Length > 0)
   {
      // Otherwise, we'll have to retrieve them from UserParameters.
      status = IASParmsGetUserPassword(
                   UserAll->Parameters.Buffer,
                   &credentials
                   );
      if (status == NO_ERROR)
      {
         if (credentials)
         {
            RtlInitUnicodeString(
                Password,
                credentials
                );
         }
         else
         {
            // The reversibly encyrpted password isn't set.
            status = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;
         }
      }
   }
   else
   {
      // No DC and no UserParameters.
      status = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\rassfmhp.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    rassfmhp.h
//
// SYNOPSIS
//
//    Declares the RasSfmHeap macro for acessing the DLL's private heap.
//
// MODIFICATION HISTORY
//
//    11/05/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RASSFMHP_H_
#define _RASSFMHP_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#define RasSfmHeap() (RasSfmPrivateHeap)

// Do not reference this variable directly since it may go away.
// Use the RasSfmHeap() macro instead.
extern PVOID RasSfmPrivateHeap;

#endif  // _RASSFMHP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\customdlg.h ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    customdlg.h

Abstract:

    Contains the definitions for the prototypes to be used for
    the custom dialogs.
    
Author:

    Rao Salapaka (raos) 09-Jan-1998

Revision History:

--*/

#include <ras.h>

DWORD
DwGetCustomDllEntryPoint(
        LPTSTR    lpszPhonebook,
        LPTSTR    lpszEntry,
        BOOL      *pfCustomDllSpecified,
        FARPROC   *pfnCustomEntryPoint,
        HINSTANCE *phInstDll,
        DWORD     dwFnId
        );



DWORD
DwCustomDialDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPTSTR          lpszPhoneNumber,
        LPRASDIALDLG    lpInfo,
        DWORD           dwFlags,
        BOOL            *pfStatus);


DWORD
DwCustomEntryDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPRASENTRYDLG   lpInfo,
        BOOL            *pfStatus);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\subauth.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    subauth.h
//
// SYNOPSIS
//
//    Declares the function GetDomainHandle.
//
// MODIFICATION HISTORY
//
//    10/14/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _SUBAUTH_H_
#define _SUBAUTH_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////
// Returns a SAM handle for the local account domain.
// This handle must not be closed.
//////////
NTSTATUS
NTAPI
GetDomainHandle(
    OUT SAMPR_HANDLE *DomainHandle
    );

#ifdef __cplusplus
}
#endif
#endif  // _SUBAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\rassfm.h ===
/*++

Copyright (c) 1987-1997  Microsoft Corporation

Module Name:

    arapsuba.h

Abstract:

    This is the header file for the subauthenticaion module

Author:

    Shirish Koti 28-Feb-97

Revisions:


--*/


#define CLEAR_TEXT_PWD_PACKAGE  L"CLEARTEXT"

#if DBG
#define DBGPRINT DbgPrint
#else
#define DBGPRINT
#endif

extern CRITICAL_SECTION ArapDesLock;

extern const NT_OWF_PASSWORD EMPTY_OWF_PASSWORD;

BOOL
RasSfmSubAuthEntry(
    IN HANDLE hinstDll,
    IN DWORD  fdwReason,
    IN LPVOID lpReserved
);

NTSTATUS
ArapSubAuthentication(
    IN OUT PNETLOGON_NETWORK_INFO  pLogonNetworkInfo,
    IN     PUSER_ALL_INFORMATION   UserAll,
    IN     SAM_HANDLE              UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo
);


NTSTATUS
ArapChangePassword(
    IN  OUT PRAS_SUBAUTH_INFO    pRasSubAuthInfo,
    OUT PULONG                   ReturnBufferLength,
    OUT PVOID                   *ReturnBuffer
);


NTSTATUS
ArapGetSamHandle(
    IN PVOID             *pUserHandle,
    IN PUNICODE_STRING    pUserName
);



VOID
DoTheDESEncrypt(
    IN OUT PCHAR   ChallengeBuf
);


VOID
DoTheDESDecrypt(
    IN OUT PCHAR   ChallengeBuf
);


VOID
DoDesInit(
    IN     PCHAR   pClrTxtPwd,
    IN     BOOLEAN DropHighBit
);


VOID
DoDesEnd(
    IN  VOID
);


NTSTATUS
NTAPI
MD5ChapSubAuthentication(
    IN SAM_HANDLE UserHandle,
    IN PUSER_ALL_INFORMATION UserAll,
    IN PRAS_SUBAUTH_INFO RasInfo
    );

NTSTATUS
NTAPI
MD5ChapExSubAuthentication(
    IN SAM_HANDLE UserHandle,
    IN PUSER_ALL_INFORMATION UserAll,
    IN PRAS_SUBAUTH_INFO RasInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\debug\debug.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** debug.c
** Debug, trace, and assert library
**
** 08/25/95 Steve Cobb
*/


#include <windows.h> // Win32 root
#include <debug.h>   // Our public header
#include <rtutils.h>


#if (DBG || FREETRACE)


/*----------------------------------------------------------------------------
** Globals
**----------------------------------------------------------------------------
*/

/* The debug trace ID of this module as returned by TraceRegisterExA.
*/
DWORD g_dwTraceId = INVALID_TRACEID;
DWORD g_dwInitRefCount = 0;
HINSTANCE g_hTraceLibrary = NULL;

/* RtUtil DLL tracing entrypoints loaded by DebugInit.  It is safe to assume
** these addresses are loaded if g_dwTraceId is not -1.
*/
TRACEREGISTEREXA    g_pTraceRegisterExA = NULL;
TRACEDEREGISTERA    g_pTraceDeregisterA = NULL;
TRACEDEREGISTEREXA  g_pTraceDeregisterExA = NULL;
TRACEPRINTFA        g_pTracePrintfA = NULL;
TRACEPRINTFEXA      g_pTracePrintfExA = NULL;
TRACEDUMPEXA        g_pTraceDumpExA = NULL;


/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/

DWORD
DebugFreeTraceLibrary()
{
    if (g_dwInitRefCount == 0)
    {
        return NO_ERROR;
    }
    
    InterlockedDecrement(&g_dwInitRefCount);

    if (g_hTraceLibrary)
    {
        FreeLibrary(g_hTraceLibrary);
    }        

    return NO_ERROR;
}

DWORD
DebugLoadTraceLibary()
{
    // Increment the ref count.  
    //
    InterlockedIncrement(&g_dwInitRefCount);
    
    if ((g_hTraceLibrary = LoadLibrary( L"RTUTILS.DLL" ))
        && (g_pTraceRegisterExA = (TRACEREGISTEREXA )GetProcAddress(
               g_hTraceLibrary, "TraceRegisterExA" ))
        && (g_pTraceDeregisterA = (TRACEDEREGISTERA )GetProcAddress(
               g_hTraceLibrary, "TraceDeregisterA" ))
        && (g_pTraceDeregisterExA = (TRACEDEREGISTEREXA )GetProcAddress(
               g_hTraceLibrary, "TraceDeregisterExA" ))
        && (g_pTracePrintfA = (TRACEPRINTFA )GetProcAddress(
               g_hTraceLibrary, "TracePrintfA" ))
        && (g_pTracePrintfExA = (TRACEPRINTFEXA )GetProcAddress(
               g_hTraceLibrary, "TracePrintfExA" ))
        && (g_pTraceDumpExA = (TRACEDUMPEXA )GetProcAddress(
               g_hTraceLibrary, "TraceDumpExA" )))
    {
        return NO_ERROR;
    }

    // The trace library failed to load.  Clean up the 
    // globals as appropriate
    //
    DebugFreeTraceLibrary();
    return GetLastError();
}

DWORD
DebugInitEx(
    IN  CHAR* pszModule,
    OUT LPDWORD lpdwId)
{
    DWORD dwErr = NO_ERROR;
    
    // Return whether the debugging module has already been initialized
    //
    if (*lpdwId != INVALID_TRACEID)
    {
        return NO_ERROR;
    }

    /* Load and register with the trace DLL.
    */
    dwErr = DebugLoadTraceLibary();
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if (NULL != g_hTraceLibrary)
    {
        *lpdwId = g_pTraceRegisterExA( pszModule, 0 );
        if (*lpdwId == INVALID_TRACEID)
        {
            return GetLastError();
        }
    }

    return dwErr;
}

VOID
DebugTermEx(
    OUT LPDWORD lpdwTraceId )

    /* Terminate debug support.
    */
{
    /* De-register with the trace DLL.
    */
    if ((*lpdwTraceId != INVALID_TRACEID) && (NULL != g_pTraceDeregisterExA))
    {
        g_pTraceDeregisterExA( *lpdwTraceId, 4 );
        *lpdwTraceId = INVALID_TRACEID;
    }        

    DebugFreeTraceLibrary();
}

VOID
DebugInit(
    IN CHAR* pszModule )

    /* Initialize debug trace and assertion support.
    */
{
    DebugInitEx(pszModule, &g_dwTraceId);
}

VOID
DebugTerm(
    void )
{
    DebugTermEx(&g_dwTraceId);
}

VOID
Assert(
    IN const CHAR* pszExpression,
    IN const CHAR* pszFile,
    IN UINT        unLine )

    /* Assertion handler called from ASSERT macro with the expression that
    ** failed and the filename and line number where the problem occurred.
    */
{
    CHAR szBuf[ 512 ];

    wsprintfA(
        szBuf,
        "The assertion \"%s\" at line %d of file %s is false.",
        pszExpression, unLine, pszFile );

    MessageBoxA(
        NULL, szBuf, "Assertion Failure", MB_ICONEXCLAMATION + MB_OK );
}


VOID
TracePrintfW1(
    CHAR*  pszFormat,
    TCHAR* psz1 )

    /* Like TracePrintf but provides W->A argument conversion on the single
    ** string argument.  This is better than mixing TracePrinfA and
    ** TracePrintfW calls which causes viewing problems when the trace is sent
    ** to a file.
    */
{
#ifdef UNICODE

    CHAR  szBuf[ 512 ];
    DWORD cb;

    if (WideCharToMultiByte(
            CP_UTF8, 0, psz1, -1, szBuf, 512, NULL, NULL ) <= 0)
    {
        TRACE("TraceW1 failed");
        return;
    }

    TRACE1( pszFormat, szBuf );

#else

    TRACE1( pszFormat, psz1 );

#endif
}


#endif // (DBG || FREETRACE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\usrparms.c ===
/*
    File    usrparms.c

    Callback routines exported to SAM for migrating and updating
    user parms.

    Paul Mayfield, 9/10/98
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <samrpc.h>
#include <samisrv.h>
#include <windows.h>
#include <lm.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <raserror.h>
#include <rasman.h>
#include <rasppp.h>
#include <mprapi.h>
#include <mprapip.h>
#include <usrparms.h>       // for UP_CLIENT_DIAL
#include <cleartxt.h>       // for IASParmsGetUserPassword
#include <rassfmhp.h>       // for RasSfmHeap
#include <oaidl.h>

//
// Flags that restrict the values generated for a given
// set of ras user properties.  See UPGenerateDsAttribs
//
#define UP_F_Dialin             0x1     // Generate dialup params
#define UP_F_Callback           0x2     // Generate callback params
#define UP_F_Upgrade            0x4     // Generate upgraded params

//
// Constants in the profiles
//
#define SDO_FRAMED                 2
#define SDO_FRAMED_CALLBACK        4

// Names of user attributes that we set
//
static const WCHAR pszAttrDialin[]          = L"msNPAllowDialin";
static const WCHAR pszAttrServiceType[]     = L"msRADIUSServiceType";
static const WCHAR pszAttrCbNumber[]        = L"msRADIUSCallbackNumber";
static const WCHAR pszAttrSavedCbNumber[]   = L"msRASSavedCallbackNumber";

//
// Will be equal to the number of times the common allocation
// routine is called minus the number of times the common free
// routine is called.  Should be zero else leaking memory.
//
DWORD dwUpLeakCount = 0;

//
// Prototype of free func.
//
VOID WINAPI
UserParmsFree(
    IN PVOID pvData);

//
// Common tracing for the UserParm functions.
//
DWORD UpTrace (LPSTR pszTrace, ...) {
#if 0
    va_list arglist;
    char szBuffer[1024], szTemp[1024];

    va_start(arglist, pszTrace);
    vsprintf(szTemp, pszTrace, arglist);
    va_end(arglist);

    sprintf(szBuffer, "UserParms: %s\n", szTemp);

    OutputDebugStringA(szBuffer);
#endif

    return NO_ERROR;
}

//
// Allocation and free routines for UserParms functions
//
PVOID
UpAlloc(
    IN DWORD dwSize,
    IN BOOL bZero)
{
    dwUpLeakCount++;
    return RtlAllocateHeap(
               RasSfmHeap(),
               (bZero ? HEAP_ZERO_MEMORY : 0),
               dwSize
               );
}

//
// Callback function called by NT5 SAM to free the blob
// returned by UserParmsConvert.
//
VOID
UpFree(
    IN PVOID pvData)
{
    dwUpLeakCount--;
    if (pvData)
        RtlFreeHeap(
            RasSfmHeap(),
            0,
            pvData
            );
}

//
// Returns a heap-allocated copy of the given
// string
//
PWCHAR
UpStrDup(
    IN PCWSTR pszSrc)
{
    PWCHAR pszRet = NULL;
    DWORD dwLen = wcslen(pszSrc);

    pszRet = (PWCHAR) UpAlloc((dwLen + 1) * sizeof(WCHAR), FALSE);
    if (pszRet)
        wcscpy(pszRet, pszSrc);

    return pszRet;
}

//
// Returns a heap-allocated copy of the given unicode
// string converted into multibyte.
//
PUCHAR
UpWcstombsDup(
    IN PWCHAR pszSrc)
{
    PUCHAR pszRet = NULL;
    DWORD dwSize = (wcslen(pszSrc) + 1) * sizeof(WCHAR);

    pszRet = (PUCHAR) UpAlloc(dwSize, TRUE);
    if (pszRet)
        wcstombs(pszRet, pszSrc, dwSize);

    return pszRet;
}


//
// Returns a heap-allocated copy of the given
// blob
//
PVOID
UpBlobDup(
    IN PVOID pvSrc,
    IN ULONG ulLen)
{
    PVOID pvRet = NULL;

    if (ulLen == 0)
        return NULL;

    pvRet = UpAlloc(ulLen + sizeof(WCHAR), TRUE);
    if (pvRet)
    {
        CopyMemory(pvRet, pvSrc, ulLen);
    }
    else
    {
        UpTrace("UpBlobDup: Failed to dupe %x %d.", pvSrc, ulLen);
    }

    return pvRet;
}

//
// Allocates and initializes a dword attribute
//
NTSTATUS
UpInitializeDwordAttr(
    IN SAM_USERPARMS_ATTR * pAttr,
    IN PWCHAR pszAttr,
    IN DWORD dwVal)
{
    if (pszAttr == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    // Initialize the name
    RtlInitUnicodeString (&(pAttr->AttributeIdentifier), pszAttr);
    pAttr->Syntax = Syntax_Attribute;

    // Alloc/Initailze the value structure
    pAttr->Values =
        (SAM_USERPARMS_ATTRVALS*)
        UpAlloc(sizeof(SAM_USERPARMS_ATTRVALS), TRUE);
    if (pAttr->Values == NULL)
        return STATUS_NO_MEMORY;

    // Alloc/Init the value
    pAttr->Values->value = UpAlloc(sizeof(DWORD), TRUE);
    if (pAttr->Values->value == NULL)
        return STATUS_NO_MEMORY;
    *((DWORD*)pAttr->Values->value) = dwVal;
    pAttr->Values->length = sizeof(DWORD);

    // Put in the value count
    pAttr->CountOfValues = 1;

    return STATUS_SUCCESS;
}

//
// Allocates and initializes a dword attribute
//
NTSTATUS
UpInitializeStringAttrA(
    OUT SAM_USERPARMS_ATTR * pAttr,
    IN  PWCHAR pszAttr,
    IN  PUCHAR pszVal)
{
    if (pszAttr == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    // Initialize the name
    RtlInitUnicodeString (&(pAttr->AttributeIdentifier), pszAttr);
    pAttr->Syntax = Syntax_Attribute;

    // Alloc/Initailze the value structure
    pAttr->Values =
        (SAM_USERPARMS_ATTRVALS*)
        UpAlloc(sizeof(SAM_USERPARMS_ATTRVALS), TRUE);
    if (pAttr->Values == NULL)
        return STATUS_NO_MEMORY;

    // Alloc/Init the value
    pAttr->Values->value = pszVal;

    if (pszVal)
    {
        pAttr->Values->length = (strlen(pszVal) + 1) * sizeof(CHAR);
    }
    else
    {
        pAttr->Values->length = 1 * sizeof(CHAR);
    }

    // Put in the value count
    pAttr->CountOfValues = 1;

    return STATUS_SUCCESS;
}

//
// Allocates and initializes a cleartext password attribute
//
NTSTATUS
UpInitializePasswordAttr(
    OUT SAM_USERPARMS_ATTR * pAttr,
    IN  PWSTR pszPassword)
{
    // Alloc/Initialize the value structure
    pAttr->Values =
        (SAM_USERPARMS_ATTRVALS*)
        UpAlloc(sizeof(SAM_USERPARMS_ATTRVALS), TRUE);
    if (pAttr->Values == NULL)
        return STATUS_NO_MEMORY;

    // Alloc/Init the value
    pAttr->Values->value = pszPassword;
    pAttr->Values->length = (wcslen(pszPassword) + 1) * sizeof(WCHAR);

    // Put in the value count
    pAttr->CountOfValues = 1;

    // Initialize the name and syntax.
    RtlInitUnicodeString(
        &pAttr->AttributeIdentifier,
        UpStrDup(L"CLEARTEXT")
        );
    pAttr->Syntax = Syntax_EncryptedAttribute;

    return STATUS_SUCCESS;
}

//
// Allocates and initializes an attribute
// to be deleted.
//
NTSTATUS
UpInitializeDeletedAttr(
    OUT SAM_USERPARMS_ATTR * pAttr,
    IN  PWCHAR pszAttr)
{
    if (pszAttr == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    // Initialize the name
    RtlInitUnicodeString (&(pAttr->AttributeIdentifier), pszAttr);
    pAttr->Syntax = Syntax_Attribute;

    // Value count of zero means delete
    //
    pAttr->CountOfValues = 0;

    return STATUS_SUCCESS;
}

//
// Converts the given user parms blob into a set of
// ras attributes
//
NTSTATUS
UpUserParmsToRasUser0 (
    IN  PVOID pvUserParms,
    OUT RAS_USER_0 * pRasUser0)
{
    DWORD dwErr;

    // Initalize
    ZeroMemory(pRasUser0, sizeof(RAS_USER_0));
    pRasUser0->bfPrivilege = RASPRIV_NoCallback;
    pRasUser0->wszPhoneNumber[0] = UNICODE_NULL;

    // The the user parms are null, the defaults
    // will do.
    if (pvUserParms == NULL)
    {
        return STATUS_SUCCESS;
    }

    //  Truncate user parms at sizeof USER_PARMS
    if (lstrlenW((PWCHAR)pvUserParms) >= sizeof(USER_PARMS))
    {
        // We slam in a null at sizeof(USER_PARMS)-1 which
        // corresponds to user_parms.up_Null
        ((PWCHAR)pvUserParms)[sizeof(USER_PARMS)-1] = L'\0';
    }

    // Get RAS info (and validate) from usr_parms
    dwErr = MprGetUsrParams(
                UP_CLIENT_DIAL,
                (LPWSTR) pvUserParms,
                (LPWSTR) pRasUser0);
    if (dwErr == NO_ERROR)
    {
        // Get RAS Privilege and callback number
        RasPrivilegeAndCallBackNumber(FALSE, pRasUser0);
    }

    return STATUS_SUCCESS;
}

/////////
// Signature of the extraction function.
/////////
typedef HRESULT (WINAPI *IASPARMSQUERYUSERPROPERTY)(
    IN PCWSTR pszUserParms,
    IN PCWSTR pszName,
    OUT VARIANT *pvarValue
    );

//////////
// Uplevel per-user attributes that will be migrated.
//////////
CONST PCWSTR UPLEVEL_PARMS[] =
{
   L"msNPAllowDialin",
   L"msNPCallingStationID",
   L"msRADIUSCallbackNumber",
   L"msRADIUSFramedIPAddress",
   L"msRADIUSFramedRoute",
   L"msRADIUSServiceType"
};

//////////
// Number of per-user attributes.
//////////
#define NUM_UPLEVEL_PARMS (sizeof(UPLEVEL_PARMS)/sizeof(UPLEVEL_PARMS[0]))

/////////
// Converts a ULONG into a SAM_USERPARMS_ATTRVALS struct.
/////////
NTSTATUS
NTAPI
ConvertULongToAttrVal(
    IN ULONG ulValue,
    OUT PSAM_USERPARMS_ATTRVALS pAttrVal
    )
{
   // Allocate memory to hold the ULONG.
   pAttrVal->value = UpAlloc(sizeof(ULONG), FALSE);
   if (pAttrVal->value == NULL) { return STATUS_NO_MEMORY; }

   // Copy in the value.
   *(PULONG)pAttrVal->value = ulValue;

   // Set the length.
   pAttrVal->length = sizeof(ULONG);

   return STATUS_SUCCESS;
}

//////////
// Converts a single-valued VARIANT into a SAM_USERPARMS_ATTRVALS struct.
//////////
NTSTATUS
NTAPI
ConvertVariantToAttrVal(
    IN CONST VARIANT *pvarValue,
    OUT PSAM_USERPARMS_ATTRVALS pAttrVal
    )
{
   NTSTATUS status;
   ULONG length;
   UNICODE_STRING wide;
   ANSI_STRING ansi;

   switch (V_VT(pvarValue))
   {
      case VT_EMPTY:
      {
         // VT_EMPTY means the attribute was deleted.
         pAttrVal->value = NULL;
         pAttrVal->length = 0;
         return STATUS_SUCCESS;
      }

      case VT_I2:
         return ConvertULongToAttrVal(V_I2(pvarValue), pAttrVal);

      case VT_I4:
         return ConvertULongToAttrVal(V_I4(pvarValue), pAttrVal);

      case VT_BSTR:
      {
         // Check the BSTR.
         if (V_BSTR(pvarValue) == NULL) { return STATUS_INVALID_PARAMETER; }

         // Initialize the source string.
         RtlInitUnicodeString(&wide, V_BSTR(pvarValue));

         // Initialize the destination buffer.
         ansi.Length = 0;
         ansi.MaximumLength = wide.MaximumLength / sizeof(WCHAR);
         ansi.Buffer = UpAlloc(ansi.MaximumLength, FALSE);
         if (ansi.Buffer == NULL) { return STATUS_NO_MEMORY; }

         // Convert from wide to ansi.
         status = RtlUnicodeStringToAnsiString(&ansi, &wide, FALSE);
         if (!NT_SUCCESS(status))
         {
            UpFree(ansi.Buffer);
            return status;
         }

         // Store the result.
         pAttrVal->value = ansi.Buffer;
         pAttrVal->length = ansi.Length + 1;

         return STATUS_SUCCESS;
      }

      case VT_BOOL:
         return ConvertULongToAttrVal((V_BOOL(pvarValue) ? 1 : 0), pAttrVal);

      case VT_I1:
         return ConvertULongToAttrVal(V_I1(pvarValue), pAttrVal);

      case VT_UI1:
         return ConvertULongToAttrVal(V_UI1(pvarValue), pAttrVal);

      case VT_UI2:
         return ConvertULongToAttrVal(V_UI2(pvarValue), pAttrVal);

      case VT_UI4:
         return ConvertULongToAttrVal(V_UI4(pvarValue), pAttrVal);

      case VT_ARRAY | VT_I1:
      case VT_ARRAY | VT_UI1:
      {
         // Check the SAFEARRAY.
         if (V_ARRAY(pvarValue) == NULL) { return STATUS_INVALID_PARAMETER; }

         // Allocate memory for the octet string.
         length = V_ARRAY(pvarValue)->rgsabound[0].cElements;
         pAttrVal->value = UpAlloc(length, FALSE);
         if (pAttrVal->value == NULL) { return STATUS_NO_MEMORY; }

         // Copy in the data.
         memcpy(pAttrVal->value, V_ARRAY(pvarValue)->pvData, length);

         // Set the length.
         pAttrVal->length = length;

         return STATUS_SUCCESS;
      }
   }

   // If we made it here it was an unsupported VARTYPE.
   return STATUS_INVALID_PARAMETER;
}

//////////
// Frees the values array of a SAM_USERPARMS_ATTR struct.
//////////
VOID
NTAPI
FreeUserParmsAttrValues(
    IN PSAM_USERPARMS_ATTR pAttrs
    )
{
   ULONG i;

   if (pAttrs)
   {
      for (i = 0; i < pAttrs->CountOfValues; ++i)
      {
         UpFree(pAttrs->Values[i].value);
      }

      UpFree(pAttrs->Values);
   }
}

//////////
// Converts a VARIANT into a SAM_USERPARMS_ATTR struct.
//////////
NTSTATUS
NTAPI
ConvertVariantToUserParmsAttr(
    IN CONST VARIANT *pvarSrc,
    OUT PSAM_USERPARMS_ATTR pAttrs
    )
{
   NTSTATUS status;
   ULONG nelem;
   CONST VARIANT *srcVal;
   SAM_USERPARMS_ATTRVALS *dstVal;

   // Get the array of values to be converted.
   if (V_VT(pvarSrc) != (VT_VARIANT | VT_ARRAY))
   {
      nelem = 1;
      srcVal = pvarSrc;
   }
   else
   {
      nelem = V_ARRAY(pvarSrc)->rgsabound[0].cElements;
      srcVal = (CONST VARIANT *)V_ARRAY(pvarSrc)->pvData;
   }

   // Initialize CountOfValues to zero. We'll use this to track how many
   // values have been successfully converted.
   pAttrs->CountOfValues = 0;

   // Allocate memory to hold the values.
   pAttrs->Values = UpAlloc(sizeof(SAM_USERPARMS_ATTRVALS) * nelem, TRUE);
   if (pAttrs->Values == NULL) { return STATUS_NO_MEMORY; }

   // Loop through each value to be converted.
   for (dstVal = pAttrs->Values; nelem > 0; ++srcVal, ++dstVal, --nelem)
   {
      status = ConvertVariantToAttrVal(srcVal, dstVal);
      if (!NT_SUCCESS(status))
      {
         // Clean-up the partial results.
         FreeUserParmsAttrValues(pAttrs);
         return status;
      }

      ++(pAttrs->CountOfValues);
   }

   return STATUS_SUCCESS;
}

//////////
// Extracts the NT5 per-user attributes from a SAM UserParameters string and
// converts them to a SAM_USERPARMS_ATTRBLOCK struct.
//////////
NTSTATUS
NTAPI
ConvertUserParmsToAttrBlock(
    IN PCWSTR lpUserParms,
    OUT PSAM_USERPARMS_ATTRBLOCK *ppAttrs
    )
{
   static IASPARMSQUERYUSERPROPERTY IASParmsQueryUserProperty;

   NTSTATUS status;
   PSAM_USERPARMS_ATTR dst;
   PWSTR szPassword;
   ULONG i;
   HRESULT hr;
   VARIANT src;

   //////////
   // Make sure we have the extraction function loaded.
   //////////

   if (IASParmsQueryUserProperty == NULL)
   {
      IASParmsQueryUserProperty = (IASPARMSQUERYUSERPROPERTY)
                                  GetProcAddress(
                                      LoadLibraryW(
                                          L"IASSAM.DLL"
                                          ),
                                      "IASParmsQueryUserProperty"
                                      );

      if (!IASParmsQueryUserProperty) { return STATUS_PROCEDURE_NOT_FOUND; }
   }

   //////////
   // Allocate memory for the SAM_USERPARMS_ATTRBLOCK.
   //////////

   *ppAttrs = (PSAM_USERPARMS_ATTRBLOCK)
              UpAlloc(
                  sizeof(SAM_USERPARMS_ATTRBLOCK),
                  TRUE
                  );
   if (*ppAttrs == NULL)
   {
      return STATUS_NO_MEMORY;
   }

   (*ppAttrs)->UserParmsAttr = (PSAM_USERPARMS_ATTR)
                               UpAlloc(
                                   sizeof(SAM_USERPARMS_ATTR) *
                                   (NUM_UPLEVEL_PARMS + 1),
                                   TRUE
                                   );
   if ((*ppAttrs)->UserParmsAttr == NULL)
   {
      UpFree(*ppAttrs);
      return STATUS_NO_MEMORY;
   }

   //////////
   // Convert the cleartext password.
   //////////

   dst = (*ppAttrs)->UserParmsAttr;

   szPassword = NULL;
   IASParmsGetUserPassword(
       lpUserParms,
       &szPassword
       );

   if (szPassword)
   {
      status = UpInitializePasswordAttr(
                   dst,
                   UpStrDup(szPassword)
                   );

      LocalFree(szPassword);

      if (NT_SUCCESS(status))
      {
         ++dst;
      }
   }

   //////////
   // Convert the dial-in parameters.
   //////////

   for (i = 0; i < NUM_UPLEVEL_PARMS; ++i)
   {
      // Try to extract the parameter from UserParms.
      hr = IASParmsQueryUserProperty(
               lpUserParms,
               UPLEVEL_PARMS[i],
               &src
               );
      if (FAILED(hr) || V_VT(&src) == VT_EMPTY) { continue; }

      // Convert to a SAM_USERPARMS_ATTRVALS array.
      status = ConvertVariantToUserParmsAttr(
                   &src,
                   dst
                   );
      if (NT_SUCCESS(status))
      {
         // Fill in the AttributeIdentifier ...
         RtlInitUnicodeString(
             &dst->AttributeIdentifier,
             UpStrDup(UPLEVEL_PARMS[i])
                      );

         // ... and the Syntax.
         dst->Syntax = Syntax_Attribute;

         // All went well, so advance to the next element in the array.
         ++dst;
      }

      // We're done with the VARIANT.
      VariantClear(&src);
   }

   (*ppAttrs)->attCount = (ULONG)(dst - (*ppAttrs)->UserParmsAttr);

   // If there weren't any attributes, then free the UserParmsAttr array.
   if ((*ppAttrs)->attCount == 0)
   {
      UpFree((*ppAttrs)->UserParmsAttr);

      (*ppAttrs)->UserParmsAttr = NULL;
   }

   return status;
}

//
// Generate an appropriate set of ds attributes based on the
// ras user information provided
//
NTSTATUS
UpGenerateDsAttribs (
    IN DWORD dwFlags,
    IN RAS_USER_0 * pRasUser0,
    IN PWSTR szPassword,
    OUT PSAM_USERPARMS_ATTRBLOCK * ppAttrs)
{
    PSAM_USERPARMS_ATTRBLOCK pRet = NULL;
    SAM_USERPARMS_ATTR * pCurAttr = NULL;
    PWCHAR pszDupPassword, pszCurAttr = NULL;
    DWORD dwCurVal = 0, dwDsParamCount;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    UpTrace("UpGenerateDsAttribs: enter %x", dwFlags);

    do
    {
        // pmay: 330184
        //
        // If we're upgrading, then having NULL userparms or having
        // deny set explicitly should cause us to not add the msNPAllowDialin
        // value so that user will be managed by policy.
        //
        if (
            (dwFlags & UP_F_Upgrade) &&
            (!(pRasUser0->bfPrivilege & RASPRIV_DialinPrivilege))
           )
        {
            dwFlags &= ~UP_F_Dialin;
        }

        // Initialize the return value
        pRet = (PSAM_USERPARMS_ATTRBLOCK)
                    UpAlloc(sizeof(SAM_USERPARMS_ATTRBLOCK), TRUE);
        if (pRet == NULL)
        {
            UpTrace("UpGenerateDsAttribs: alloc block failed");
            ntStatus = STATUS_NO_MEMORY;
            break;
        }

        // Calculate the total number of values
        dwDsParamCount = 0;
        if (dwFlags & UP_F_Dialin)
        {
            dwDsParamCount += 1;
        }
        if (dwFlags & UP_F_Callback)
        {
            dwDsParamCount += 3;
        }
        if (szPassword != NULL)
        {
            dwDsParamCount += 1;
        }

        //
        // Set the array to be big enough to accomodate 4 attributes:
        //   1. Dialin bit
        //   2. Callback Number or Saved Callback Number
        //   3. Deleted version of #2
        //   4. Service Type (for callback policy)
        //
        pCurAttr = (SAM_USERPARMS_ATTR*)
            UpAlloc(sizeof(SAM_USERPARMS_ATTR) * dwDsParamCount, TRUE);
        if (pCurAttr == NULL)
        {
            ntStatus = STATUS_NO_MEMORY;
            UpTrace("UpGenerateDsAttribs: alloc of %d values failed",
                     dwDsParamCount);
            break;
        }
        pRet->attCount = dwDsParamCount;
        pRet->UserParmsAttr = pCurAttr;

        // Set any appropriate dialin parameters
        //
        if (dwFlags & UP_F_Dialin)
        {
            dwCurVal =
                (pRasUser0->bfPrivilege & RASPRIV_DialinPrivilege) ? 1 : 0;

            // Initialize the dialin setting
            ntStatus = UpInitializeDwordAttr(
                        pCurAttr,
                        UpStrDup((PWCHAR)pszAttrDialin),
                        dwCurVal);
            if (ntStatus != STATUS_SUCCESS)
            {
                UpTrace("UpGenerateDsAttribs: fail dialin val %x", ntStatus);
                break;
            }

            pCurAttr++;
        }

        // Set any appropriate callback parameters
        //
        if (dwFlags & UP_F_Callback)
        {

            // The following logic was modified for SP1 of Win2K.  The reason is that
            // the values being set did not conform to the rules outlined in the
            // comments to the UserParmsConvert function.
            //
            // Namely,
            //   1.  the msRADIUSServiceType was being set to SDO_FRAMED instead of
            //       <empty> when RASPRIV_NoCallback was set.
            //
            //   2.  When RASPRIV_NoCallback was set, the msRADIUSCallbackNumber was
            //       set and the msRASSavedCallbackNumber was deleted instead of the
            //       vice-versa
            //

            // Initialize the service type
            if (pRasUser0->bfPrivilege & RASPRIV_NoCallback)
            {
                ntStatus = UpInitializeDeletedAttr(
                            pCurAttr,
                            UpStrDup((PWCHAR)pszAttrServiceType));
            }
            else
            {
                ntStatus = UpInitializeDwordAttr(
                            pCurAttr,
                            UpStrDup((PWCHAR)pszAttrServiceType),
                            SDO_FRAMED_CALLBACK);
            }

            if (ntStatus != STATUS_SUCCESS)
            {
                UpTrace("UpGenerateDsAttribs: fail ST val %x", ntStatus);
                break;
            }
            pCurAttr++;

            // Initialize the callback number that will be committed
            pszCurAttr = (pRasUser0->bfPrivilege & RASPRIV_AdminSetCallback) ?
                         (PWCHAR) pszAttrCbNumber                            :
                         (PWCHAR) pszAttrSavedCbNumber;
            if (*(pRasUser0->wszPhoneNumber))
            {
                ntStatus = UpInitializeStringAttrA(
                            pCurAttr,
                            UpStrDup(pszCurAttr),
                            UpWcstombsDup(pRasUser0->wszPhoneNumber));
                if (ntStatus != STATUS_SUCCESS)
                {
                    UpTrace("UpGenerateDsAttribs: fail CB val %x", ntStatus);
                    break;
                }
            }
            else
            {
                ntStatus = UpInitializeDeletedAttr(
                            pCurAttr,
                            UpStrDup(pszCurAttr));
                if (ntStatus != STATUS_SUCCESS)
                {
                    UpTrace("UpGenerateDsAttribs: fail del CB val %x", ntStatus);
                    break;
                }
            }
            pCurAttr++;

            // Remove the callback number that doesn't apply.
            pszCurAttr = (pszCurAttr == pszAttrCbNumber) ?
                         (PWCHAR) pszAttrSavedCbNumber   :
                         (PWCHAR) pszAttrCbNumber;
            ntStatus = UpInitializeDeletedAttr(
                        pCurAttr,
                        UpStrDup(pszCurAttr));
            if (ntStatus != STATUS_SUCCESS)
            {
                UpTrace("UpGenerateDsAttribs: fail del SCB val %x", ntStatus);
                break;
            }
            pCurAttr++;
        }

        // Set the cleartext password if present
        //
        if (szPassword != NULL)
        {
            // Make a duplicate copy of the password
            if ((pszDupPassword = UpStrDup(szPassword)) == NULL)
            {
                ntStatus = STATUS_NO_MEMORY;
                break;
            }

            // Initialize the password attribute
            ntStatus = UpInitializePasswordAttr(
                        pCurAttr,
                        pszDupPassword);
            if (ntStatus != STATUS_SUCCESS)
            {
                UpTrace("UpGenerateDsAttribs: fail password val %x", ntStatus);
                break;
            }

            pCurAttr++;
        }

    } while (FALSE);

    // Cleanup
    {
        if (ntStatus != STATUS_SUCCESS)
        {
            UserParmsFree(pRet);
            *ppAttrs = NULL;
        }
        else
        {
            *ppAttrs = pRet;
        }
    }

    return ntStatus;
}

//
// Callback function called by NT5 SAM whenever the user parms
// of a particular user are modified.  The job of this callout
// is to take the new value of user parms and generate a set of
// domain attributes that need to be set for the given user so
// that per-user DS attributes and userparms are kept in sync.
//
// This callout will be invoked during dcpromo to upgrade user parms
// and whenever userparms is modified (by downlevel api's and apps).
//
// Callback functions for NT5 SAM are registered in the following
// registry key:
//
//      HKLM\SYS\CCS\Control\LSA\NotificationPackages
//
// The following are the rules of the RAS LDAP parameters:
//
//  msNPAllowDialin
//      - Empty = Use policy to determine dialin privilege
//      - 1 = Allow dialin
//      - 2 = Deny dialin
//
//  msRADIUSServiceType
//      - Empty = NoCallback policy
//      - 4 = CallerCallback if msRADIUSCallbackNumber is empty
//            AdminCallback if msRADIUSCallbackNumber is not empty
//
//  msRADIUSCallbackNumber
//      - Determines the callback policy depending on msRADIUSServiceType
//
//  msRASSavedCallbackNumber
//      - Used to store the last known value of msRADIUSCallbackNumber when
//        switching from AdminCallback policy to some other policy.
//

NTSTATUS
UserParmsConvert (
    IN ULONG ulFlags,
    IN PSID pDomainSid,
    IN ULONG ulObjectRid,
    IN ULONG ulOrigLen,
    IN PVOID pvOrigUserParms,
    IN ULONG ulNewLen,
    IN PVOID pvNewUserParms,
    OUT PSAM_USERPARMS_ATTRBLOCK * ppAttrs)
{
    RAS_USER_0 RasUser00, *pOrigUser = &RasUser00;
    RAS_USER_0 RasUser01, *pNewUser  = &RasUser01;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PVOID pvOrig = NULL, pvNew = NULL;
    DWORD dwFlags = 0, dwMask;
    PWSTR szPassword = NULL;

    UpTrace(
        "UPConvert: F=%x, Rid=%x, OLen=%d, OPar=%x, NLen=%d, NPar=%x",
        ulFlags, ulObjectRid, ulOrigLen, pvOrigUserParms,
        ulNewLen, pvNewUserParms);

    // Validate parameters
    if (ppAttrs == NULL)
        return STATUS_INVALID_PARAMETER;

    // Initialize the return value;
    *ppAttrs = NULL;

    // If the user parms passed to us are NULL,
    // then keep defaults.
    if ((pvNewUserParms == NULL) || (ulNewLen == 0))
    {
        return STATUS_SUCCESS;
    }

    do
    {
        // Allocate and initialize local copies of
        // the user parms
        pvOrig = UpBlobDup(pvOrigUserParms, ulOrigLen);
        pvNew = UpBlobDup(pvNewUserParms, ulNewLen);

        // If this is a NT5 standalone being promoted to a DC, then we
        // just convert the uplevel userparms 'as is'.
        if ((ulFlags & SAM_USERPARMS_DURING_UPGRADE) &&
            !SamINT4UpgradeInProgress())
        {
           ntStatus = ConvertUserParmsToAttrBlock(pvNew, ppAttrs);
           break;
        }

        // Get the new ras properties
        ntStatus = UpUserParmsToRasUser0(
                        pvNew,
                        pNewUser);
        if (ntStatus != STATUS_SUCCESS)
        {
            UpTrace("UPConvert: Conversion to RAS_USER_0 failed.(1)");
            break;
        }

        // If we're upgrading, then we should blindly
        // set whatever information is stored in the user.
        if (ulFlags & SAM_USERPARMS_DURING_UPGRADE)
        {
            IASParmsGetUserPassword(pvNewUserParms, &szPassword);

            ntStatus =  UpGenerateDsAttribs(
                            UP_F_Dialin | UP_F_Callback | UP_F_Upgrade,
                            pNewUser,
                            szPassword,
                            ppAttrs);

            LocalFree(szPassword);

            if (ntStatus != STATUS_SUCCESS)
            {
                UpTrace("UPConvert: GenerateDsAttribs failed %x", ntStatus);
            }
            break;
        }

        // Get the ras properties of the old user parms
        ntStatus = UpUserParmsToRasUser0(
                        pvOrig,
                        pOrigUser);
        if (ntStatus != STATUS_SUCCESS)
        {
            UpTrace("UPConvert: Conversion to RAS_USER_0 failed.(2)");
            break;
        }

        // Find out if the dialin privilege should be updated
        dwFlags = 0;
        if (!!(pOrigUser->bfPrivilege & RASPRIV_DialinPrivilege) !=
            !!(pNewUser->bfPrivilege  & RASPRIV_DialinPrivilege))
        {
            dwFlags |= UP_F_Dialin;
        }

        // pmay: 264409
        //
        // If we are adding null usrparms for the first time,
        // go ahead and add the dialin bit value to the ds.
        //
        if ((pvOrig == NULL) && (pvNew != NULL))
        {
            dwFlags |= UP_F_Dialin;
        }

        // Findout if any callback info should be updated
        dwMask = RASPRIV_NoCallback        |
                 RASPRIV_CallerSetCallback |
                 RASPRIV_AdminSetCallback;
        if (((pOrigUser->bfPrivilege & dwMask)  !=
             (pNewUser->bfPrivilege  & dwMask)) ||
            (wcscmp(pOrigUser->wszPhoneNumber, pNewUser->wszPhoneNumber) != 0)
           )
        {
            dwFlags |= UP_F_Callback;
        }

        // If there were no changes, we're done.
        if (dwFlags == 0)
        {
            UpTrace("UPConvert: nothing to update.");
            ntStatus = STATUS_SUCCESS;
            break;
        }

        // Create the new attributes
        ntStatus =  UpGenerateDsAttribs(dwFlags, pNewUser, NULL, ppAttrs);
        if (ntStatus != STATUS_SUCCESS)
        {
            UpTrace("UPConvert: UpGenerateDsAttribs failed %x.", ntStatus);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        if (pvOrig)
        {
            UpFree(pvOrig);
        }
        if (pvNew)
        {
            UpFree(pvNew);
        }
    }

    return ntStatus;
}

//
// Callback function called by NT5 SAM to free the blob
// returned by UserParmsConvert.
//
VOID
UserParmsFree(
    IN PSAM_USERPARMS_ATTRBLOCK pData)
{
    SAM_USERPARMS_ATTR * pCur = NULL;
    DWORD i, j;

    UpTrace("UserParmsFree: Entered. %x", pData);

    // If no attributes were given, we're all done
    if (pData == NULL)
        return;

    if  (pData->UserParmsAttr)
    {
        // Loop through all the attributes, freeing them
        // as you go.
        for (i = 0; i < pData->attCount; i++)
        {
            // Keep track of the current attribute
            pCur = &(pData->UserParmsAttr[i]);

            // Free the copied attribute name
            if (pCur->AttributeIdentifier.Buffer)
                UpFree(pCur->AttributeIdentifier.Buffer);

            // Free any associated values as well.
            if (pCur->Values)
            {
                for (j = 0; j < pCur->CountOfValues; j++)
                {
                    // Assume there's only one value since that's
                    // all we ever set. Free the value
                    if (pCur->Values[j].value)
                        UpFree(pCur->Values[j].value);
                }

                // Free the value structure
                UpFree(pCur->Values);
            }
        }

        // Free the array of attributes
        UpFree (pData->UserParmsAttr);
    }

    // Finally, free the whole structure
    UpFree (pData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rassfm\subauth.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    subauth.c
//
// SYNOPSIS
//
//    Declares the subauthentication and password change notification routines
//    for MD5-CHAP.
//
// MODIFICATION HISTORY
//
//    09/01/1998    Original version.
//    11/02/1998    Handle change notifications on a separate thread.
//    11/03/1998    NewPassword may be NULL.
//    11/12/1998    Use private heap.
//                  Use CreateThread.
//    03/08/1999    Only store passwords for user accounts.
//    03/29/1999    Initialize out parameters to NULL when calling
//                  SamrQueryInformationUser.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>

#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>

#include <lmcons.h>
#include <logonmsv.h>
#include <rasfmsub.h>

#include <cleartxt.h>
#include <md5.h>
#include <md5port.h>
#include <rassfmhp.h>

// Non-zero if the API is locked.
static LONG theLock;

//////////
// Macros to lock/unlock the API during intialization.
//////////
#define API_LOCK() \
   while (InterlockedExchange(&theLock, 1)) Sleep(5)

#define API_UNLOCK() \
      InterlockedExchange(&theLock, 0)

// Cached handle to the local account domain.
SAMPR_HANDLE theAccountDomain;

// TRUE if we have a handle to the local account domain.
static BOOL theConnectFlag;

//////////
// Macro that ensures we have a connection and bails on failure.
//////////
#define CHECK_CONNECT() \
  if (!theConnectFlag) { \
    status = ConnectToDomain(); \
    if (!NT_SUCCESS(status)) { return status; } \
  }

//////////
// Initializes the cached handle to the local account domain.
//////////
NTSTATUS
NTAPI
ConnectToDomain( VOID )
{
   NTSTATUS status;
   PLSAPR_POLICY_INFORMATION policyInfo;
   SAMPR_HANDLE hServer;

   API_LOCK();

   // If we've already been initialized, there's nothing to do.
   if (theConnectFlag)
   {
      status = STATUS_SUCCESS;
      goto exit;
   }

   //////////
   // Open a handle to the local account domain.
   //////////

   policyInfo = NULL;
   status = LsaIQueryInformationPolicyTrusted(
                PolicyAccountDomainInformation,
                &policyInfo
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   status = SamIConnect(
                NULL,
                &hServer,
                0,
                TRUE
                );
   if (!NT_SUCCESS(status)) { goto free_info; }

   status = SamrOpenDomain(
                hServer,
                0,
                (PRPC_SID)policyInfo->PolicyAccountDomainInfo.DomainSid,
                &theAccountDomain
                );

   // Did we succeed ?
   if (NT_SUCCESS(status)) { theConnectFlag = TRUE; }

   SamrCloseHandle(&hServer);

free_info:
   LsaIFree_LSAPR_POLICY_INFORMATION(
       PolicyAccountDomainInformation,
       policyInfo
       );

exit:
   API_UNLOCK();
   return status;
}

//////////
// Returns a SAM handle for the local account domain.
// This handle must not be closed.
//////////
NTSTATUS
NTAPI
GetDomainHandle(
    OUT SAMPR_HANDLE *DomainHandle
    )
{
   NTSTATUS status;

   CHECK_CONNECT();

   *DomainHandle = theAccountDomain;
   return STATUS_SUCCESS;
}

//////////
// Returns a SAM handle for the given user.
// The caller is responsible for closing the returned handle.
//////////
NTSTATUS
NTAPI
GetUserHandle(
    IN PUNICODE_STRING UserName,
    OUT SAMPR_HANDLE *UserHandle
    )
{
   NTSTATUS status;
   SAMPR_ULONG_ARRAY RidArray;
   SAMPR_ULONG_ARRAY UseArray;

   CHECK_CONNECT();

   RidArray.Element = NULL;
   UseArray.Element = NULL;

   status = SamrLookupNamesInDomain(
                theAccountDomain,
                1,
                (PRPC_UNICODE_STRING)UserName,
                &RidArray,
                &UseArray
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   if (UseArray.Element[0] != SidTypeUser)
   {
      status = STATUS_NONE_MAPPED;
      goto free_arrays;
   }

   status = SamrOpenUser(
                theAccountDomain,
                0,
                RidArray.Element[0],
                UserHandle
                );

free_arrays:
   SamIFree_SAMPR_ULONG_ARRAY( &UseArray );
   SamIFree_SAMPR_ULONG_ARRAY( &RidArray );

exit:
   return status;
}

/////////
// Process an MD5-CHAP authentication.
/////////
NTSTATUS
NTAPI
ProcessMD5ChapAuthentication(
    IN SAM_HANDLE UserHandle,
    IN PUSER_ALL_INFORMATION UserAll,
    IN UCHAR ChallengeId,
    IN DWORD ChallengeLength,
    IN PUCHAR Challenge,
    IN PUCHAR Response
    )
{
   NTSTATUS status;
   UNICODE_STRING uniPwd;
   ANSI_STRING ansiPwd;
   MD5_CTX context;

   /////////
   // Retrieve the cleartext password.
   /////////

   status = RetrieveCleartextPassword(
                UserHandle,
                UserAll,
                &uniPwd
                );
   if (status != STATUS_SUCCESS) { return status; }

   //////////
   // Convert the password to ANSI.
   //////////

   status = RtlUnicodeStringToAnsiString(
                &ansiPwd,
                &uniPwd,
                TRUE
                );

   // We're through with the Unicode password.
   RtlFreeUnicodeString(&uniPwd);

   if (!NT_SUCCESS(status)) { return STATUS_WRONG_PASSWORD; }

   //////////
   // Compute the correct response.
   //////////

   MD5Init(&context);
   MD5Update(&context, &ChallengeId, 1);
   MD5Update(&context, (PBYTE)ansiPwd.Buffer, ansiPwd.Length);
   MD5Update(&context, Challenge, ChallengeLength);
   MD5Final(&context);

   // We're through with the ANSI password.
   RtlFreeAnsiString(&ansiPwd);

   //////////
   // Does the actual response match the correct response ?
   //////////

   if (memcmp(context.digest, Response, 16) == 0)
   {
      return STATUS_SUCCESS;
   }

   return STATUS_WRONG_PASSWORD;
}


NTSTATUS
NTAPI
MD5ChapSubAuthentication(
    IN SAM_HANDLE UserHandle,
    IN PUSER_ALL_INFORMATION UserAll,
    IN PRAS_SUBAUTH_INFO RasInfo
    )
{
   MD5CHAP_SUBAUTH_INFO* info = (MD5CHAP_SUBAUTH_INFO*)(RasInfo->Data);
   return ProcessMD5ChapAuthentication(
              UserHandle,
              UserAll,
              info->uchChallengeId,
              sizeof(info->uchChallenge),
              info->uchChallenge,
              info->uchResponse
              );
}


NTSTATUS
NTAPI
MD5ChapExSubAuthentication(
    IN SAM_HANDLE UserHandle,
    IN PUSER_ALL_INFORMATION UserAll,
    IN PRAS_SUBAUTH_INFO RasInfo
    )
{
   MD5CHAP_EX_SUBAUTH_INFO* info = (MD5CHAP_EX_SUBAUTH_INFO*)(RasInfo->Data);
   DWORD challengeLength = RasInfo->DataSize -
                           sizeof(MD5CHAP_EX_SUBAUTH_INFO) + 1;
   return ProcessMD5ChapAuthentication(
              UserHandle,
              UserAll,
              info->uchChallengeId,
              challengeLength,
              info->uchChallenge,
              info->uchResponse
              );
}

//////////
// Entry point for the subauthentication DLL.
//////////
NTSTATUS
NTAPI
Msv1_0SubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )
{
   NTSTATUS status;
   LARGE_INTEGER logonTime;
   PNETLOGON_NETWORK_INFO logonInfo;
   PRAS_SUBAUTH_INFO rasInfo;
   MD5CHAP_SUBAUTH_INFO *chapInfo;
   PWSTR password;
   UNICODE_STRING uniPassword;
   SAMPR_HANDLE hUser;

   /////////
   // Initialize the out parameters.
   /////////

   *WhichFields = 0;
   *UserFlags = 0;
   *Authoritative = TRUE;

   /////////
   // Check some basic restrictions.
   /////////

   if (LogonLevel != NetlogonNetworkInformation)
   {
      return STATUS_INVALID_INFO_CLASS;
   }

   if (UserAll->UserAccountControl & USER_ACCOUNT_DISABLED)
   {
      return STATUS_ACCOUNT_DISABLED;
   }

   NtQuerySystemTime(&logonTime);

   if (UserAll->AccountExpires.QuadPart != 0 &&
       UserAll->AccountExpires.QuadPart <= logonTime.QuadPart)
   {
      return STATUS_ACCOUNT_EXPIRED;
   }

   if (UserAll->PasswordMustChange.QuadPart <= logonTime.QuadPart)
   {
      return UserAll->PasswordLastSet.QuadPart ? STATUS_PASSWORD_EXPIRED
                                               : STATUS_PASSWORD_MUST_CHANGE;
   }

   /////////
   // Extract the MD5CHAP_SUBAUTH_INFO struct.
   /////////

   logonInfo = (PNETLOGON_NETWORK_INFO)LogonInformation;
   rasInfo = (PRAS_SUBAUTH_INFO)logonInfo->NtChallengeResponse.Buffer;

   if (rasInfo == NULL ||
       logonInfo->NtChallengeResponse.Length < sizeof(RAS_SUBAUTH_INFO) ||
       rasInfo->ProtocolType != RAS_SUBAUTH_PROTO_MD5CHAP ||
       rasInfo->DataSize != sizeof(MD5CHAP_SUBAUTH_INFO))
   {
      return STATUS_INVALID_PARAMETER;
   }

   chapInfo = (MD5CHAP_SUBAUTH_INFO*)rasInfo->Data;

   /////////
   // Open a handle to the user object.
   /////////

   status = GetUserHandle(
                &(logonInfo->Identity.UserName),
                &hUser
                );
   if (status != NO_ERROR) { return status; }

   /////////
   // Verify the MD5-CHAP password.
   /////////

   status = ProcessMD5ChapAuthentication(
                hUser,
                UserAll,
                chapInfo->uchChallengeId,
                sizeof(chapInfo->uchChallenge),
                chapInfo->uchChallenge,
                chapInfo->uchResponse
                );
   if (status != NO_ERROR) { goto close_user; }

   /////////
   // Check account restrictions.
   /////////

   status = SamIAccountRestrictions(
                hUser,
                NULL,
                NULL,
                &UserAll->LogonHours,
                LogoffTime,
                KickoffTime
                );

close_user:
   SamrCloseHandle(&hUser);

   return status;
}

/////////
// Info needed to process a change notification.
/////////
typedef struct _PWD_CHANGE_INFO {
    ULONG RelativeId;
    WCHAR NewPassword[1];
} PWD_CHANGE_INFO, *PPWD_CHANGE_INFO;

/////////
// Start routine for notification worker thread.
/////////
DWORD
WINAPI
PasswordChangeNotifyWorker(
    IN PPWD_CHANGE_INFO ChangeInfo
    )
{
   NTSTATUS status;
   SAMPR_HANDLE hUser;
   PUSER_CONTROL_INFORMATION uci;
   ULONG accountControl;
   USER_PARAMETERS_INFORMATION *oldInfo, newInfo;
   BOOL cleartextAllowed;
   PWSTR oldUserParms, newUserParms;

   //////////
   // Ensure we're connected to the SAM domain.
   //////////

   if (!theConnectFlag)
   {
      status = ConnectToDomain();
      if (!NT_SUCCESS(status)) { goto exit; }
   }

   //////////
   // Retrieve the UserParameters
   //////////

   status = SamrOpenUser(
                theAccountDomain,
                0,
                ChangeInfo->RelativeId,
                &hUser
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   uci = NULL;
   status = SamrQueryInformationUser(
                hUser,
                UserControlInformation,
                (PSAMPR_USER_INFO_BUFFER*)&uci
                );
   if (!NT_SUCCESS(status)) { goto close_user; }

   // Save the info ...
   accountControl = uci->UserAccountControl;

   // ... and free the buffer.
   SamIFree_SAMPR_USER_INFO_BUFFER(
       (PSAMPR_USER_INFO_BUFFER)uci,
       UserControlInformation
       );

   // We're only interested in normal accounts.
   if (!(accountControl & USER_NORMAL_ACCOUNT)) { goto close_user; }

   oldInfo = NULL;
   status = SamrQueryInformationUser(
                hUser,
                UserParametersInformation,
                (PSAMPR_USER_INFO_BUFFER*)&oldInfo
                );
   if (!NT_SUCCESS(status)) { goto close_user; }

   //////////
   // Make a null-terminated copy.
   //////////

   oldUserParms = (PWSTR)
                  RtlAllocateHeap(
                      RasSfmHeap(),
                      0,
                      oldInfo->Parameters.Length + sizeof(WCHAR)
                      );
   if (oldUserParms == NULL)
   {
      status = STATUS_NO_MEMORY;
      goto free_user_info;
   }

   memcpy(
       oldUserParms,
       oldInfo->Parameters.Buffer,
       oldInfo->Parameters.Length
       );

   oldUserParms[oldInfo->Parameters.Length / sizeof(WCHAR)] = L'\0';

   //////////
   // Should we store the cleartext password in UserParameters?
   //////////

   status = IsCleartextEnabled(
                hUser,
                &cleartextAllowed
                );
   if (!NT_SUCCESS(status)) { goto free_user_parms; }

   newUserParms = NULL;

   if (cleartextAllowed)
   {
      // We either set the new password ...
      status = IASParmsSetUserPassword(
                   oldUserParms,
                   ChangeInfo->NewPassword,
                   &newUserParms
                   );
   }
   else
   {
      // ... or we erase the old one.
      status = IASParmsClearUserPassword(
                   oldUserParms,
                   &newUserParms
                   );
   }

   // Write the UserParameters back to SAM if necessary.
   if (NT_SUCCESS(status) && newUserParms != NULL)
   {
      newInfo.Parameters.Length = (USHORT)(sizeof(WCHAR) * (lstrlenW(newUserParms) + 1));
      newInfo.Parameters.MaximumLength = newInfo.Parameters.Length;
      newInfo.Parameters.Buffer = newUserParms;

      status = SamrSetInformationUser(
                   hUser,
                   UserParametersInformation,
                   (PSAMPR_USER_INFO_BUFFER)&newInfo
                   );

      IASParmsFreeUserParms(newUserParms);
   }

free_user_parms:
   RtlFreeHeap(
       RasSfmHeap(),
       0,
       oldUserParms
       );

free_user_info:
   SamIFree_SAMPR_USER_INFO_BUFFER(
       (PSAMPR_USER_INFO_BUFFER)oldInfo,
       UserParametersInformation
       );

close_user:
   SamrCloseHandle(&hUser);

exit:
   RtlFreeHeap(
      RasSfmHeap(),
      0,
      ChangeInfo
      );

   return status;
}

//////////
// Password change DLL entry point.
//////////
NTSTATUS
NTAPI
PasswordChangeNotify(
    IN PUNICODE_STRING UserName,
    IN ULONG RelativeId,
    IN PUNICODE_STRING NewPassword
    )
{
   ULONG length;
   PPWD_CHANGE_INFO info;
   HANDLE hWorker;
   DWORD threadId;

   // Calculate the length of the new password.
   length = NewPassword ? NewPassword->Length : 0;

   // Allocate the PWD_CHANGE_INFO struct.
   info = (PPWD_CHANGE_INFO)
          RtlAllocateHeap(
              RasSfmHeap(),
              0,
              sizeof(PWD_CHANGE_INFO) + length
              );
   if (info == NULL) { return STATUS_NO_MEMORY; }

   // Save the RelativeId.
   info->RelativeId = RelativeId;

   // Save the NewPassword.
   if (length) { memcpy(info->NewPassword, NewPassword->Buffer, length); }

   // Make sure it's null-terminated.
   info->NewPassword[length / sizeof(WCHAR)] = L'\0';

   // Create a worker thread.
   hWorker = CreateThread(
                 NULL,
                 0,
                 PasswordChangeNotifyWorker,
                 info,
                 0,
                 &threadId
                 );

   if (hWorker)
   {
      CloseHandle(hWorker);

      return STATUS_SUCCESS;
   }

   RtlFreeHeap(
      RasSfmHeap(),
      0,
      info
      );

   return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\dtl.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** dtl.c
** Double-threaded linked list manipulation core routines
** Listed alphabetically
**
** 06/28/92 Steve Cobb
*/


#include <windows.h>   // Win32 root
#include <nouiutil.h>  // Heap definitions
#include <dtl.h>       // Our public header
#include <debug.h>     // debug macros

DTLNODE*
DtlMoveToTail(
    IN  DTLLIST*    pdtllist,
    IN  DTLNODE*    pdtlnode
    );


DTLNODE*
DtlAddNodeAfter(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnodeInList,
    IN OUT DTLNODE* pdtlnode )

    /* Adds node 'pdtlnode' to list 'pdtllist' after node 'pdtlnodeInList'.
    ** If 'pdtlnodeInList' is NULL, 'pdtlnode' is added at the end of the
    ** list.
    **
    ** Returns the address of the added node, i.e. 'pdtlnode'.
    */
{
    if (!pdtlnodeInList || !pdtlnodeInList->pdtlnodeNext)
        return DtlAddNodeLast( pdtllist, pdtlnode );

    pdtlnode->pdtlnodePrev = pdtlnodeInList;
    pdtlnode->pdtlnodeNext = pdtlnodeInList->pdtlnodeNext;

    pdtlnodeInList->pdtlnodeNext->pdtlnodePrev = pdtlnode;
    pdtlnodeInList->pdtlnodeNext = pdtlnode;

    ++pdtllist->lNodes;
    return pdtlnode;
}


DTLNODE*
DtlAddNodeBefore(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnodeInList,
    IN OUT DTLNODE* pdtlnode )

    /* Adds node 'pdtlnode' to list 'pdtllist' before node 'pdtlnodeInList'.
    ** If 'pdtlnodeInList' is NULL, 'pdtlnode' is added at the beginning of
    ** the list.
    **
    ** Returns the address of the added node, i.e. 'pdtlnode'.
    */
{
    if (!pdtlnodeInList || !pdtlnodeInList->pdtlnodePrev)
        return DtlAddNodeFirst( pdtllist, pdtlnode );

    pdtlnode->pdtlnodePrev = pdtlnodeInList->pdtlnodePrev;
    pdtlnode->pdtlnodeNext = pdtlnodeInList;

    pdtlnodeInList->pdtlnodePrev->pdtlnodeNext = pdtlnode;
    pdtlnodeInList->pdtlnodePrev = pdtlnode;

    ++pdtllist->lNodes;
    return pdtlnode;
}


DTLNODE*
DtlAddNodeFirst(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnode )

    /* Adds node 'pdtlnode' at the beginning of list 'pdtllist'.
    **
    ** Returns the address of the added node, i.e. 'pdtlnode'.
    */
{
    if (pdtllist->lNodes)
    {
        pdtllist->pdtlnodeFirst->pdtlnodePrev = pdtlnode;
        pdtlnode->pdtlnodeNext = pdtllist->pdtlnodeFirst;
    }
    else
    {
        pdtllist->pdtlnodeLast = pdtlnode;
        pdtlnode->pdtlnodeNext = NULL;
    }

    pdtlnode->pdtlnodePrev = NULL;
    pdtllist->pdtlnodeFirst = pdtlnode;

    ++pdtllist->lNodes;
    return pdtlnode;
}


DTLNODE*
DtlAddNodeLast(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnode )

    /* Adds 'pdtlnode' at the end of list 'pdtllist'.
    **
    ** Returns the address of the added node, i.e. 'pdtlnode'.
    */
{
    if (pdtllist->lNodes)
    {
        pdtlnode->pdtlnodePrev = pdtllist->pdtlnodeLast;
        pdtllist->pdtlnodeLast->pdtlnodeNext = pdtlnode;
    }
    else
    {
        pdtlnode->pdtlnodePrev = NULL;
        pdtllist->pdtlnodeFirst = pdtlnode;
    }

    pdtllist->pdtlnodeLast = pdtlnode;
    pdtlnode->pdtlnodeNext = NULL;

    ++pdtllist->lNodes;
    return pdtlnode;
}


DTLLIST*
DtlCreateList(
    IN LONG lListId )

    /* Allocates a list and initializes it to empty.  The list is marked with
    ** the user-defined list identification code 'lListId'.
    **
    ** Returns the address of the list control block or NULL if out of memory.
    */
{
    DTLLIST* pdtllist = Malloc( sizeof(DTLLIST) );

    if (pdtllist)
    {
        pdtllist->pdtlnodeFirst = NULL;
        pdtllist->pdtlnodeLast = NULL;
        pdtllist->lNodes = 0;
        pdtllist->lListId = lListId;
    }

    return pdtllist;
}


DTLNODE*
DtlCreateNode(
    IN VOID* pData,
    IN LONG_PTR  lNodeId )

    /* Allocates an unsized node and initializes it to contain the address of
    ** the user data block 'pData' and the user-defined node identification
    ** code 'lNodeId'.
    **
    ** Returns the address of the new node or NULL if out of memory.
    */
{
    DTLNODE* pdtlnode = DtlCreateSizedNode( 0, lNodeId );

    if (pdtlnode)
        DtlPutData( pdtlnode, pData );

    return pdtlnode;
}


DTLNODE*
DtlCreateSizedNode(
    IN LONG lDataBytes,
    IN LONG_PTR lNodeId )

    /* Allocates a sized node with space for 'lDataBytes' bytes of user data
    ** built-in.  The node is initialized to contain the address of the
    ** built-in user data block (or NULL if of zero length) and the
    ** user-defined node identification code 'lNodeId'.  The user data block
    ** is zeroed.
    **
    ** Returns the address of the new node or NULL if out of memory.
    */
{
    DTLNODE* pdtlnode = Malloc( sizeof(DTLNODE) + lDataBytes );

    if (pdtlnode)
    {
        ZeroMemory( pdtlnode, sizeof(DTLNODE) + lDataBytes );

        if (lDataBytes)
            pdtlnode->pData = pdtlnode + 1;

        pdtlnode->lNodeId = lNodeId;
    }

    return pdtlnode;
}


DTLNODE*
DtlDeleteNode(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnode )

    /* Destroys node 'pdtlnode' after removing it from list 'pdtllist'.
    **
    ** Returns the address of the node after the deleted node in 'pdtllist' or
    ** NULL if none.
    */
{
    DTLNODE* pdtlnodeNext = pdtlnode->pdtlnodeNext;

    DtlRemoveNode( pdtllist, pdtlnode );
    DtlDestroyNode( pdtlnode );

    return pdtlnodeNext;
}


VOID
DtlDestroyList(
    IN OUT DTLLIST*     pdtllist,
    IN     PDESTROYNODE pfuncDestroyNode )

    /* Deallocates all nodes in list 'pdtllist' using the node deallocation
    ** function 'pfuncDestroyNode' if non-NULL or DtlDestroyNode otherwise.
    ** Won't GP-fault if passed a NULL list, e.g. if 'pdtllist', was never
    ** allocated.
    */
{
    if (pdtllist)
    {
        DTLNODE* pdtlnode;

        while (pdtlnode = DtlGetFirstNode( pdtllist ))
        {
            DtlRemoveNode( pdtllist, pdtlnode );
            if (pfuncDestroyNode)
                pfuncDestroyNode( pdtlnode );
            else
                DtlDestroyNode( pdtlnode );
        }

        Free( pdtllist );
    }
}


VOID
DtlDestroyNode(
    IN OUT DTLNODE* pdtlnode )

    /* Deallocates node 'pdtlnode'.  It is the caller's responsibility to free
    ** the entry in an unsized node, if necessary.
    */
{
    Free( pdtlnode );
}


DTLLIST*
DtlDuplicateList(
    IN DTLLIST*     pdtllist,
    IN PDUPNODE     pfuncDupNode,
    IN PDESTROYNODE pfuncDestroyNode )

    /* Duplicates a list 'pdtllist' using 'pfuncDupNode' to duplicate the
    ** individual nodes.  'PfuncDestroyNode' is used for clean-up before
    ** returning an error.
    **
    ** Returns the address of the new list or NULL if out of memory.  It is
    ** caller's responsibility to free the returned list.
    */
{
    DTLNODE* pdtlnode;
    DTLLIST* pdtllistDup = DtlCreateList( 0 );

    if (!pdtllistDup)
        return NULL;

    for (pdtlnode = DtlGetFirstNode( pdtllist );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        DTLNODE* pdtlnodeDup;

        pdtlnodeDup = pfuncDupNode( pdtlnode );
        if (!pdtlnodeDup)
        {
            DtlDestroyList( pdtllist, pfuncDestroyNode );
            break;
        }

        DtlAddNodeLast( pdtllistDup, pdtlnodeDup );
    }

    return pdtllistDup;
}


DTLNODE*
DtlNodeFromIndex(
    IN DTLLIST* pdtllist,
    IN LONG     lToFind )

    /* Returns the node associated with 0-based index 'lToFind' in the linked
    ** list of nodes, 'pdtllist', or NULL if not found.
    */
{
    DTLNODE* pdtlnode;

    if (!pdtllist || lToFind < 0)
        return NULL;

    pdtlnode = DtlGetFirstNode( pdtllist );
    while (pdtlnode && lToFind--)
        pdtlnode = DtlGetNextNode( pdtlnode );

    return pdtlnode;
}



VOID
DtlMergeSort(
    IN  DTLLIST*        pdtllist,
    IN  PCOMPARENODE    pfnCompare )

    /* Sorts the list 'pdtllist' in-place using merge-sort.
    ** The comparison-function 'pfnCompare' is passed 'DTLNODE' pointers
    ** when entries in the list need to be compared.
    **
    ** This implementation is a bottom-up iterative merge-sort.
    ** The list is sorted by merging adjacent pairs of lists of length i
    ** where i starts as 1 and doubles on each iteration.
    ** Thus for the list (3 1 4 1 5 9 2 6), the following pairs of sublists
    ** are merged, with the intermediate results on the right:
    **
    **  (3)-(1), (4)-(1), (5)-(9), (2)-(6)  ==>     (1 3 1 4 5 9 2 6)
    **
    **  (1 3)-(1 4), (5 9)-(2 6)            ==>     (1 1 3 4 2 5 6 9)
    **
    **  (1 1 3 4)-(2 5 6 9)                 ==>     (1 1 2 3 4 5 6 9)
    **
    ** Mergesort is a stable sort (i.e. the order of equal items is preserved)
    ** and it never does more than N lg N comparisons.
    */
{

    DTLNODE* a, *b;
    INT N, Ncmp = 0, Nsub;

    N = DtlGetNodes(pdtllist);

    TRACE1("DtlMergeSort: N=%d", N);


    //
    // sort and merge all adjacent sublists of length 'Nsub',
    // where 'Nsub' goes from 1 to N^lg('N'), by doubling on each iteration
    //

    for (Nsub = 1; Nsub < N; Nsub *= 2) {

        INT Nremnant;
        INT aLength, bLength;


        //
        // get the head of the first (left) sublist
        //

        a = DtlGetFirstNode(pdtllist);

        //
        // as long as there is a right sublist, sort
        //

        for (Nremnant = N; Nremnant > 0; Nremnant -= Nsub * 2) {

            //
            // get the head of the right sublist;
            // it's just the tail of the left sublist
            //

            INT i, an, bn;

            aLength = min(Nremnant, Nsub);

            for (i = aLength, b = a; i; i--, b = DtlGetNextNode(b)) { }


            //
            // compute the length of the right sublist;
            // in the case where there is no right sublist
            // set the length to zero and the loop below just moves
            // the left sublist
            //

            bLength = min(Nremnant - Nsub, Nsub);

            if (bLength < 0) { bLength = 0; }


            //
            // now merge the left and right sublists in-place;
            // we merge by building a sorted list at the tail of
            // the unsorted list
            //

            an = aLength; bn = bLength;

            //
            // as long as both sublists are non-empty, merge them
            // by moving the entry with the smallest key to the tail.
            //

            while (an && bn) {

                ++Ncmp;

                if (pfnCompare(a, b) <= 0) {
                    a = DtlMoveToTail(pdtllist, a); --an;
                }
                else {
                    b = DtlMoveToTail(pdtllist, b); --bn;
                }
            }


            //
            // one of the sublists is empty; move all the entries
            // in the other sublist to the end of our sorted list
            //

            if (an) do { a = DtlMoveToTail(pdtllist, a); } while(--an);
            else
            if (bn) do { b = DtlMoveToTail(pdtllist, b); } while(--bn);


            //
            // 'b' now points to the end of the right sublist,
            // meaning that the item after 'b' is the one which will be
            // the head of the left sublist on our next iteration;
            // we therefore update 'a' here
            //

            a = b;
        }
    }
    
    TRACE1("DtlMergeSort: Ncmp=%d", Ncmp);
}


DTLNODE*
DtlMoveToTail(
    IN  DTLLIST*    pdtllist,
    IN  DTLNODE*    pdtlnode
    )

    /* Moves a DTLNODE to the end of a list;
    ** Takes the list and the node to be moved, and returns the next node.
    */
{
    DTLNODE* pdtltemp = DtlGetNextNode(pdtlnode);

    DtlRemoveNode(pdtllist, pdtlnode);

    DtlAddNodeLast(pdtllist, pdtlnode);

    return pdtltemp;
}


DTLNODE*
DtlRemoveNode(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnodeInList )

    /* Removes node 'pdtlnodeInList' from list 'pdtllist'.
    **
    ** Returns the address of the removed node, i.e. 'pdtlnodeInList'.
    */
{
    if (pdtlnodeInList->pdtlnodePrev)
        pdtlnodeInList->pdtlnodePrev->pdtlnodeNext = pdtlnodeInList->pdtlnodeNext;
    else
        pdtllist->pdtlnodeFirst = pdtlnodeInList->pdtlnodeNext;

    if (pdtlnodeInList->pdtlnodeNext)
        pdtlnodeInList->pdtlnodeNext->pdtlnodePrev = pdtlnodeInList->pdtlnodePrev;
    else
        pdtllist->pdtlnodeLast = pdtlnodeInList->pdtlnodePrev;

    --pdtllist->lNodes;
    return pdtlnodeInList;
}


VOID
DtlSwapLists(
    IN OUT DTLLIST* pdtllist1,
    IN OUT DTLLIST* pdtllist2 )

    /* Swap the node chains between lists 'pdtllist1' and 'pdtllist2'.
    */
{
    DTLLIST dtllist;

    dtllist.pdtlnodeFirst = pdtllist1->pdtlnodeFirst;
    dtllist.pdtlnodeLast = pdtllist1->pdtlnodeLast;
    dtllist.lNodes = pdtllist1->lNodes;

    pdtllist1->pdtlnodeFirst = pdtllist2->pdtlnodeFirst;
    pdtllist1->pdtlnodeLast = pdtllist2->pdtlnodeLast;
    pdtllist1->lNodes = pdtllist2->lNodes;

    pdtllist2->pdtlnodeFirst = dtllist.pdtlnodeFirst;
    pdtllist2->pdtlnodeLast = dtllist.pdtlnodeLast;
    pdtllist2->lNodes = dtllist.lNodes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\loaddlls.c ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** loaddlls.c
** RAS DLL load routines
** Listed alphabetically
**
** 02/17/96 Steve Cobb
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include "rasrpc.h"
#include <debug.h>    // Trace and assert
#include <nouiutil.h>
#include <loaddlls.h> // Our public header
#include <rasrpclb.h>
#include <rasman.h>

/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

#define RasRpcCatchException(_pStatus) \
    RpcExcept(I_RpcExceptionFilter(*(_pStatus) = RpcExceptionCode()))

#ifdef UNICODE
#define SZ_RasConnectionNotification        "RasConnectionNotificationW"
#define SZ_RasDeleteEntry                   "RasDeleteEntryW"
#define SZ_RasDial                          "RasDialW"
#define SZ_RasDialDlg                       "RasDialDlgW"
#define SZ_RasEntryDlg                      "RasEntryDlgW"
#define SZ_RasEnumConnections               "RasEnumConnectionsW"
#define SZ_RasEnumEntries                   "RasEnumEntriesW"
#define SZ_RasGetAutodialEnable             "RasGetAutodialEnableW"
#define SZ_RasGetAutodialParam              "RasGetAutodialParamW"
#define SZ_RasGetConnectResponse            "RasGetConnectResponse"
#define SZ_RasGetConnectStatus              "RasGetConnectStatusW"
#define SZ_RasGetCountryInfo                "RasGetCountryInfoW"
#define SZ_RasGetCredentials                "RasGetCredentialsW"
#define SZ_RasGetEntryDialParams            "RasGetEntryDialParamsW"
#define SZ_RasGetEntryProperties            "RasGetEntryPropertiesW"
#define SZ_RasGetErrorString                "RasGetErrorStringW"
#define SZ_RasGetProjectionInfo             "RasGetProjectionInfoW"
#define SZ_RasGetSubEntryHandle             "RasGetSubEntryHandleW"
#define SZ_RasHangUp                        "RasHangUpW"
#define SZ_RasPhonebookDlg                  "RasPhonebookDlgW"
#define SZ_RasSetAutodialEnable             "RasSetAutodialEnableW"
#define SZ_RasSetAutodialParam              "RasSetAutodialParamW"
#define SZ_RasSetCredentials                "RasSetCredentialsW"
#define SZ_RasValidateEntryName             "RasValidateEntryNameW"
#define SZ_RouterEntryDlg                   "RouterEntryDlgW"
#define SZ_RasSetEapUserData                "RasSetEapUserDataW"
#else
#define SZ_RasConnectionNotification        "RasConnectionNotificationA"
#define SZ_RasDeleteEntry                   "RasDeleteEntryA"
#define SZ_RasDial                          "RasDialA"
#define SZ_RasDialDlg                       "RasDialDlgA"
#define SZ_RasEnumConnections               "RasEnumConnectionsA"
#define SZ_RasEnumEntries                   "RasEnumEntriesA"
#define SZ_RasGetAutodialEnable             "RasGetAutodialEnableA"
#define SZ_RasGetAutodialParam              "RasGetAutodialParamA"
#define SZ_RasGetConnectResponse            "RasGetConnectResponse"
#define SZ_RasGetConnectStatus              "RasGetConnectStatusA"
#define SZ_RasGetCountryInfo                "RasGetCountryInfoA"
#define SZ_RasGetCredentials                "RasGetCredentialsA"
#define SZ_RasGetEntryDialParams            "RasGetEntryDialParamsA"
#define SZ_RasGetEntryProperties            "RasGetEntryPropertiesA"
#define SZ_RasGetErrorString                "RasGetErrorStringA"
#define SZ_RasGetProjectionInfo             "RasGetProjectionInfoA"
#define SZ_RasGetSubEntryHandle             "RasGetSubEntryHandleA"
#define SZ_RasHangUp                        "RasHangUpA"
#define SZ_RasPhonebookDlg                  "RasPhonebookDlgA"
#define SZ_RasSetAutodialEnable             "RasSetAutodialEnableA"
#define SZ_RasSetAutodialParam              "RasSetAutodialParamA"
#define SZ_RasSetCredentials                "RasSetCredentialsA"
#define SZ_RasValidateEntryName             "RasValidateEntryNameA"
#define SZ_RouterEntryDlg                   "RouterEntryDlgA"
#define SZ_RasSetEapUserData                "RasSetEapUserDataA"
#endif
#define SZ_MprAdminInterfaceCreate          "MprAdminInterfaceCreate"
#define SZ_MprAdminInterfaceDelete          "MprAdminInterfaceDelete"
#define SZ_MprAdminInterfaceGetHandle       "MprAdminInterfaceGetHandle"
#define SZ_MprAdminInterfaceGetCredentials  "MprAdminInterfaceGetCredentials"
#define SZ_MprAdminInterfaceGetCredentialsEx  "MprAdminInterfaceGetCredentialsEx"
#define SZ_MprAdminInterfaceSetCredentials  "MprAdminInterfaceSetCredentials"
#define SZ_MprAdminInterfaceSetCredentialsEx  "MprAdminInterfaceSetCredentialsEx"
#define SZ_MprAdminBufferFree               "MprAdminBufferFree"
#define SZ_MprAdminInterfaceTransportAdd    "MprAdminInterfaceTransportAdd"
#define SZ_MprAdminInterfaceTransportSetInfo "MprAdminInterfaceTransportSetInfo"
#define SZ_MprAdminServerConnect            "MprAdminServerConnect"
#define SZ_MprAdminServerDisconnect         "MprAdminServerDisconnect"
#define SZ_MprAdminTransportSetInfo         "MprAdminTransportSetInfo"
#define SZ_RasAdminBufferFree               "MprAdminBufferFree"
#define SZ_RasAdminConnectionEnum           "MprAdminConnectionEnum"
#define SZ_RasAdminConnectionGetInfo        "MprAdminConnectionGetInfo"
#define SZ_RasAdminPortDisconnect           "MprAdminPortDisconnect"
#define SZ_RasAdminPortEnum                 "MprAdminPortEnum"
#define SZ_RasAdminPortGetInfo              "MprAdminPortGetInfo"
#define SZ_RasAdminServerConnect            "MprAdminServerConnect"
#define SZ_RasAdminServerDisconnect         "MprAdminServerDisconnect"
#define SZ_RasAdminUserSetInfo              "MprAdminUserSetInfo"
#define SZ_MprAdminUserServerConnect        "MprAdminUserServerConnect"
#define SZ_MprAdminUserServerDisconnect     "MprAdminUserServerDisconnect"
#define SZ_MprAdminUserOpen                 "MprAdminUserOpen"
#define SZ_MprAdminUserClose                "MprAdminUserClose"
#define SZ_MprAdminUserWrite                "MprAdminUserWrite"
#define SZ_MprConfigBufferFree              "MprConfigBufferFree"
#define SZ_MprConfigServerConnect           "MprConfigServerConnect"
#define SZ_MprConfigServerDisconnect        "MprConfigServerDisconnect"
#define SZ_MprConfigTransportGetInfo        "MprConfigTransportGetInfo"
#define SZ_MprConfigTransportSetInfo        "MprConfigTransportSetInfo"
#define SZ_MprConfigTransportGetHandle      "MprConfigTransportGetHandle"
#define SZ_MprConfigInterfaceCreate         "MprConfigInterfaceCreate"
#define SZ_MprConfigInterfaceDelete         "MprConfigInterfaceDelete"
#define SZ_MprConfigInterfaceGetHandle      "MprConfigInterfaceGetHandle"
#define SZ_MprConfigInterfaceEnum           "MprConfigInterfaceEnum"
#define SZ_MprConfigInterfaceTransportAdd   "MprConfigInterfaceTransportAdd"
#define SZ_MprConfigInterfaceTransportGetInfo "MprConfigInterfaceTransportGetInfo"
#define SZ_MprConfigInterfaceTransportSetInfo "MprConfigInterfaceTransportSetInfo"
#define SZ_MprConfigInterfaceTransportGetHandle "MprConfigInterfaceTransportGetHandle"
#define SZ_MprInfoCreate                    "MprInfoCreate"
#define SZ_MprInfoDelete                    "MprInfoDelete"
#define SZ_MprInfoDuplicate                 "MprInfoDuplicate"
#define SZ_MprInfoBlockAdd                  "MprInfoBlockAdd"
#define SZ_MprInfoBlockRemove               "MprInfoBlockRemove"
#define SZ_MprInfoBlockSet                  "MprInfoBlockSet"
#define SZ_MprInfoBlockFind                 "MprInfoBlockFind"


//
// RASAPI32.DLL entry points.
//
HINSTANCE g_hRasapi32Dll = NULL;

PRASCONNECTIONNOTIFICATION  g_pRasConnectionNotification = NULL;
PRASDELETEENTRY             g_pRasDeleteEntry            = NULL;
PRASDIAL                    g_pRasDial                   = NULL;
PRASENUMCONNECTIONS         g_pRasEnumConnections        = NULL;
PRASENUMENTRIES             g_pRasEnumEntries            = NULL;
PRASGETAUTODIALENABLE       g_pRasGetAutodialEnable      = NULL;
PRASGETAUTODIALPARAM        g_pRasGetAutodialParam       = NULL;
PRASGETCONNECTRESPONSE      g_pRasGetConnectResponse     = NULL;
PRASGETCONNECTSTATUS        g_pRasGetConnectStatus       = NULL;
PRASGETCOUNTRYINFO          g_pRasGetCountryInfo         = NULL;
PRASGETCREDENTIALS          g_pRasGetCredentials         = NULL;
PRASGETENTRYDIALPARAMS      g_pRasGetEntryDialParams     = NULL;
PRASGETENTRYPROPERTIES      g_pRasGetEntryProperties     = NULL;
PRASGETERRORSTRING          g_pRasGetErrorString         = NULL;
PRASGETHPORT                g_pRasGetHport               = NULL;
PRASGETPROJECTIONINFO       g_pRasGetProjectionInfo      = NULL;
PRASGETSUBENTRYHANDLE       g_pRasGetSubEntryHandle      = NULL;
PRASHANGUP                  g_pRasHangUp                 = NULL;
PRASINVOKEEAPUI             g_pRasInvokeEapUI            = NULL;
PRASSETEAPUSERDATA          g_pRasSetEapUserData         = NULL;
PRASSETAUTODIALENABLE       g_pRasSetAutodialEnable      = NULL;
PRASSETAUTODIALPARAM        g_pRasSetAutodialParam       = NULL;
PRASSETCREDENTIALS          g_pRasSetCredentials         = NULL;
PRASSETOLDPASSWORD          g_pRasSetOldPassword         = NULL;
PRASVALIDATEENTRYNAME       g_pRasValidateEntryName      = NULL;

//
// RASDLG.DLL entry points
//
HINSTANCE g_hRasdlgDll = NULL;

PRASDIALDLG                 g_pRasDialDlg      = NULL;
PRASENTRYDLG                g_pRasEntryDlg     = NULL;
PRASPHONEBOOKDLG            g_pRasPhonebookDlg = NULL;
PROUTERENTRYDLG             g_pRouterEntryDlg  = NULL;

//
// RASMAN.DLL entry points
//
HINSTANCE g_hRasmanDll = NULL;

PRASACTIVATEROUTE           g_pRasActivateRoute             = NULL;
PRASACTIVATEROUTEEX         g_pRasActivateRouteEx           = NULL;
PRASADDCONNECTIONPORT       g_pRasAddConnectionPort         = NULL;
PRASADDNOTIFICATION         g_pRasAddNotification           = NULL;
PRASALLOCATEROUTE           g_pRasAllocateRoute             = NULL;
PRASBUNDLECLEARSTATISTICS   g_pRasBundleClearStatistics     = NULL;
PRASBUNDLECLEARSTATISTICSEX g_pRasBundleClearStatisticsEx   = NULL;
PRASBUNDLEGETSTATISTICS     g_pRasBundleGetStatistics       = NULL;
PRASBUNDLEGETSTATISTICSEX   g_pRasBundleGetStatisticsEx     = NULL;
PRASCONNECTIONENUM          g_pRasConnectionEnum            = NULL;
PRASCONNECTIONGETSTATISTICS g_pRasConnectionGetStatistics   = NULL;
PRASCREATECONNECTION        g_pRasCreateConnection          = NULL;
PRASDESTROYCONNECTION       g_pRasDestroyConnection         = NULL;
PRASDEVICECONNECT           g_pRasDeviceConnect             = NULL;
PRASDEVICEENUM              g_pRasDeviceEnum                = NULL;
PRASDEVICEGETINFO           g_pRasDeviceGetInfo             = NULL;
PRASDEVICESETINFO           g_pRasDeviceSetInfo             = NULL;
PRASENUMCONNECTIONPORTS     g_pRasEnumConnectionPorts       = NULL;
PRASFINDPREREQUISITEENTRY   g_pRasFindPrerequisiteEntry     = NULL;
PRASFREEBUFFER              g_pRasFreeBuffer                = NULL;
PRASGETBUFFER               g_pRasGetBuffer                 = NULL;
PRASGETCONNECTIONPARAMS     g_pRasGetConnectionParams       = NULL;
PRASGETCONNECTIONUSERDATA   g_pRasGetConnectionUserData     = NULL;
PRASGETDEVCONFIG            g_pRasGetDevConfig              = NULL;
PRASGETDEVCONFIG            g_pRasGetDevConfigEx            = NULL;
PRASGETDIALPARAMS           g_pRasGetDialParams             = NULL;
PRASGETHCONNFROMENTRY       g_pRasGetHConnFromEntry         = NULL;
PRASGETHPORTFROMCONNECTION  g_pRasGetHportFromConnection    = NULL;
PRASGETINFO                 g_pRasGetInfo                   = NULL;
PRASGETNDISWANDRIVERCAPS    g_pRasGetNdiswanDriverCaps      = NULL;
PRASGETPORTUSERDATA         g_pRasGetPortUserData           = NULL;
PRASINITIALIZE              g_pRasInitialize                = NULL;
PRASINITIALIZENOWAIT        g_pRasInitializeNoWait          = NULL;
PRASLINKGETSTATISTICS       g_pRasLinkGetStatistics         = NULL;
PRASNUMPORTOPEN             g_pRasNumPortOpen               = NULL;
PRASPORTCANCELRECEIVE       g_pRasPortCancelReceive         = NULL;
PRASPORTCLEARSTATISTICS     g_pRasPortClearStatistics       = NULL;
PRASPORTCLOSE               g_pRasPortClose                 = NULL;
PRASPORTCONNECTCOMPLETE     g_pRasPortConnectComplete       = NULL;
PRASPORTDISCONNECT          g_pRasPortDisconnect            = NULL;
PRASPORTENUM                g_pRasPortEnum                  = NULL;
PRASPORTENUMPROTOCOLS       g_pRasPortEnumProtocols         = NULL;
PRASPORTGETBUNDLE           g_pRasPortGetBundle             = NULL;
PRASPORTGETFRAMINGEX        g_pRasPortGetFramingEx          = NULL;
PRASPORTGETINFO             g_pRasPortGetInfo               = NULL;
PRASPORTGETSTATISTICS       g_pRasPortGetStatistics         = NULL;
PRASPORTGETSTATISTICSEX     g_pRasPortGetStatisticsEx       = NULL;
PRASPORTLISTEN              g_pRasPortListen                = NULL;
PRASPORTOPEN                g_pRasPortOpen                  = NULL;
PRASPORTOPENEX              g_pRasPortOpenEx                = NULL;
PRASPORTRECEIVE             g_pRasPortReceive               = NULL;
PRASPORTRECEIVEEX           g_pRasPortReceiveEx             = NULL;
PRASPORTREGISTERSLIP        g_pRasPortRegisterSlip          = NULL;
PRASPORTSEND                g_pRasPortSend                  = NULL;
PRASPORTSETFRAMING          g_pRasPortSetFraming            = NULL;
PRASPORTSETFRAMINGEX        g_pRasPortSetFramingEx          = NULL;
PRASPORTSETINFO             g_pRasPortSetInfo               = NULL;
PRASPPPCALLBACK             g_pRasPppCallback               = NULL;
PRASPPPCHANGEPASSWORD       g_pRasPppChangePassword         = NULL;
PRASPPPGETEAPINFO           g_pRasPppGetEapInfo             = NULL;
PRASPPPGETINFO              g_pRasPppGetInfo                = NULL;
PRASPPPRETRY                g_pRasPppRetry                  = NULL;
PRASPPPSETEAPINFO           g_pRasPppSetEapInfo             = NULL;
PRASPPPSTART                g_pRasPppStart                  = NULL;
PRASPPPSTOP                 g_pRasPppStop                   = NULL;
PRASREFCONNECTION           g_pRasRefConnection             = NULL;
PRASREFERENCECUSTOMCOUNT    g_pRasReferenceCustomCount      = NULL;
PRASREQUESTNOTIFICATION     g_pRasRequestNotification       = NULL;
PRASRPCBIND                 g_pRasRpcBind                   = NULL;
PRASRPCCONNECT              g_pRasRpcConnect                = NULL;
PRASRPCDISCONNECT           g_pRasRpcDisconnect             = NULL;
PRASSENDPPPMESSAGETORASMAN  g_pRasSendPppMessageToRasman    = NULL;
PRASSETCACHEDCREDENTIALS    g_pRasSetCachedCredentials      = NULL;
PRASSETCONNECTIONPARAMS     g_pRasSetConnectionParams       = NULL;
PRASSETCONNECTIONUSERDATA   g_pRasSetConnectionUserData     = NULL;
PRASSETDEVCONFIG            g_pRasSetDevConfig              = NULL;
PRASSETDIALPARAMS           g_pRasSetDialParams             = NULL;
PRASSETIOCOMPLETIONPORT     g_pRasSetIoCompletionPort       = NULL;
PRASSETPORTUSERDATA         g_pRasSetPortUserData           = NULL;
PRASSETRASDIALINFO          g_pRasSetRasdialInfo            = NULL;
PRASSIGNALNEWCONNECTION     g_pRasSignalNewConnection       = NULL;
PRASGETDEVICENAME           g_pRasGetDeviceName             = NULL;
PRASENABLEIPSEC             g_pRasEnableIpSec               = NULL;
PRASISIPSECENABLED          g_pRasIsIpSecEnabled            = NULL;
PRASGETEAPUSERINFO          g_pRasGetEapUserInfo            = NULL;
PRASSETEAPUSERINFO          g_pRasSetEapUserInfo            = NULL;
PRASSETEAPLOGONINFO         g_pRasSetEapLogonInfo           = NULL;
PRASSTARTRASAUTOIFREQUIRED  g_pRasStartRasAutoIfRequired    = NULL;


//
// MPRAPI.DLL entry points.
//
HINSTANCE g_hMpradminDll = NULL;

PMPRADMININTERFACECREATE            g_pMprAdminInterfaceCreate          = NULL;
PMPRADMININTERFACEDELETE            g_pMprAdminInterfaceDelete          = NULL;
PMPRADMININTERFACEGETHANDLE         g_pMprAdminInterfaceGetHandle       = NULL;
PMPRADMININTERFACEGETCREDENTIALS    g_pMprAdminInterfaceGetCredentials  = NULL;
PMPRADMININTERFACEGETCREDENTIALSEX  g_pMprAdminInterfaceGetCredentialsEx = NULL;
PMPRADMININTERFACESETCREDENTIALS    g_pMprAdminInterfaceSetCredentials  = NULL;
PMPRADMININTERFACESETCREDENTIALSEX  g_pMprAdminInterfaceSetCredentialsEx = NULL;
PMPRADMINBUFFERFREE                 g_pMprAdminBufferFree               = NULL;
PMPRADMININTERFACETRANSPORTADD      g_pMprAdminInterfaceTransportAdd = NULL;
PMPRADMININTERFACETRANSPORTSETINFO  g_pMprAdminInterfaceTransportSetInfo = NULL;
PMPRADMINSERVERCONNECT              g_pMprAdminServerConnect            = NULL;
PMPRADMINSERVERDISCONNECT           g_pMprAdminServerDisconnect         = NULL;
PMPRADMINTRANSPORTSETINFO           g_pMprAdminTransportSetInfo         = NULL;
PRASADMINBUFFERFREE                 g_pRasAdminBufferFree               = NULL;
PRASADMINCONNECTIONENUM             g_pRasAdminConnectionEnum           = NULL;
PRASADMINCONNECTIONGETINFO          g_pRasAdminConnectionGetInfo        = NULL;
PRASADMINPORTDISCONNECT             g_pRasAdminPortDisconnect           = NULL;
PRASADMINPORTENUM                   g_pRasAdminPortEnum                 = NULL;
PRASADMINPORTGETINFO                g_pRasAdminPortGetInfo              = NULL;
PRASADMINSERVERCONNECT              g_pRasAdminServerConnect            = NULL;
PRASADMINSERVERDISCONNECT           g_pRasAdminServerDisconnect         = NULL;
PRASADMINUSERSETINFO                g_pRasAdminUserSetInfo              = NULL;
PMPRADMINUSERSERVERCONNECT          g_pMprAdminUserServerConnect        = NULL;
PMPRADMINUSERSERVERDISCONNECT       g_pMprAdminUserServerDisconnect     = NULL;
PMPRADMINUSEROPEN                   g_pMprAdminUserOpen                 = NULL;
PMPRADMINUSERCLOSE                  g_pMprAdminUserClose                = NULL;
PMPRADMINUSERWRITE                  g_pMprAdminUserWrite                = NULL;
PMPRCONFIGBUFFERFREE                g_pMprConfigBufferFree;
PMPRCONFIGSERVERCONNECT             g_pMprConfigServerConnect;
PMPRCONFIGSERVERDISCONNECT          g_pMprConfigServerDisconnect;
PMPRCONFIGTRANSPORTGETINFO          g_pMprConfigTransportGetInfo;
PMPRCONFIGTRANSPORTSETINFO          g_pMprConfigTransportSetInfo;
PMPRCONFIGTRANSPORTGETHANDLE        g_pMprConfigTransportGetHandle;
PMPRCONFIGINTERFACECREATE           g_pMprConfigInterfaceCreate;
PMPRCONFIGINTERFACEDELETE           g_pMprConfigInterfaceDelete;
PMPRCONFIGINTERFACEGETHANDLE        g_pMprConfigInterfaceGetHandle;
PMPRCONFIGINTERFACEENUM             g_pMprConfigInterfaceEnum;
PMPRCONFIGINTERFACETRANSPORTADD     g_pMprConfigInterfaceTransportAdd;
PMPRCONFIGINTERFACETRANSPORTGETINFO g_pMprConfigInterfaceTransportGetInfo;
PMPRCONFIGINTERFACETRANSPORTSETINFO g_pMprConfigInterfaceTransportSetInfo;
PMPRCONFIGINTERFACETRANSPORTGETHANDLE g_pMprConfigInterfaceTransportGetHandle;
PMPRINFOCREATE                      g_pMprInfoCreate;
PMPRINFODELETE                      g_pMprInfoDelete;
PMPRINFODUPLICATE                   g_pMprInfoDuplicate;
PMPRINFOBLOCKADD                    g_pMprInfoBlockAdd;
PMPRINFOBLOCKREMOVE                 g_pMprInfoBlockRemove;
PMPRINFOBLOCKSET                    g_pMprInfoBlockSet;
PMPRINFOBLOCKFIND                   g_pMprInfoBlockFind;

//
// Miscellaneous DLLs
//
PGETINSTALLEDPROTOCOLS      g_pGetInstalledProtocols    = GetInstalledProtocols;
PGETINSTALLEDPROTOCOLSEX    g_pGetInstalledProtocolsEx  = GetInstalledProtocolsEx;
PGETUSERPREFERENCES         g_pGetUserPreferences       = GetUserPreferences;
PSETUSERPREFERENCES         g_pSetUserPreferences       = SetUserPreferences;
PGETSYSTEMDIRECTORY         g_pGetSystemDirectory       = RasGetSystemDirectory;

//
// RASRPC.DLL
//

RPC_BINDING_HANDLE g_hBinding;
BOOL g_fRasapi32PreviouslyLoaded    = FALSE;
BOOL g_fRasmanPreviouslyLoaded      = FALSE;
BOOL g_Version = VERSION_501;
BOOL g_dwConnectCount = 0;

DWORD APIENTRY
RemoteGetVersion(
    RPC_BINDING_HANDLE hServer,
    PDWORD pdwVersion
);

//
// Routines
//
BOOL
IsRasmanServiceRunning(
    void )

/*++

Routine Description

Arguments

Return Value

    Returns true if the PRASMAN service is running,
    false otherwise.

--*/

{
    BOOL           fStatus;
    SC_HANDLE      schScm;
    SC_HANDLE      schRasman;
    SERVICE_STATUS status;

    fStatus = FALSE;
    schScm = NULL;
    schRasman = NULL;

    do
    {
        schScm = OpenSCManager( NULL, NULL, GENERIC_READ );
        if (!schScm)
            break;

        schRasman = OpenService(
            schScm, TEXT( RASMAN_SERVICE_NAME ), SERVICE_QUERY_STATUS );
        if (!schRasman)
            break;

        if (!QueryServiceStatus( schRasman, &status ))
            break;

        fStatus = (status.dwCurrentState == SERVICE_RUNNING);
    }
    while (FALSE);

    if (schRasman)
        CloseServiceHandle( schRasman );
    if (schScm)
        CloseServiceHandle( schScm );

    TRACE1("IsRasmanServiceRunning=%d",fStatus);
    return fStatus;
}



DWORD
LoadMpradminDll(
    void )

/*++

Routine Description

    Loads MPRAPI DLL and it's entry points.

Arguments

Return Value

    Returns 0 if successful, otherwise a non-zero error code.

--*/

{
    HINSTANCE h;

    if (g_hMpradminDll)
        return 0;

    if (!(h = LoadLibrary(TEXT("MPRAPI.DLL")))
        || !(g_pMprAdminInterfaceCreate =
                (PMPRADMININTERFACECREATE)GetProcAddress(
                    h, SZ_MprAdminInterfaceCreate))
        || !(g_pMprAdminInterfaceDelete =
                (PMPRADMININTERFACEDELETE)GetProcAddress(
                    h, SZ_MprAdminInterfaceDelete))
        || !(g_pMprAdminInterfaceGetHandle =
                (PMPRADMININTERFACEGETHANDLE)GetProcAddress(
                    h, SZ_MprAdminInterfaceGetHandle))
        || !(g_pMprAdminInterfaceGetCredentials =
                (PMPRADMININTERFACEGETCREDENTIALS)GetProcAddress(
                    h, SZ_MprAdminInterfaceGetCredentials))
        || !(g_pMprAdminInterfaceGetCredentialsEx =
                (PMPRADMININTERFACEGETCREDENTIALSEX)GetProcAddress(
                    h, SZ_MprAdminInterfaceGetCredentialsEx))
        || !(g_pMprAdminInterfaceSetCredentials =
                (PMPRADMININTERFACESETCREDENTIALS)GetProcAddress(
                    h, SZ_MprAdminInterfaceSetCredentials))
        || !(g_pMprAdminInterfaceSetCredentialsEx =
                (PMPRADMININTERFACESETCREDENTIALSEX)GetProcAddress(
                    h, SZ_MprAdminInterfaceSetCredentialsEx))
        || !(g_pMprAdminBufferFree =
                (PMPRADMINBUFFERFREE)GetProcAddress(
                    h, SZ_MprAdminBufferFree))
        || !(g_pMprAdminInterfaceTransportAdd =
                (PMPRADMININTERFACETRANSPORTADD)GetProcAddress(
                    h, SZ_MprAdminInterfaceTransportAdd))
        || !(g_pMprAdminInterfaceTransportSetInfo =
                (PMPRADMININTERFACETRANSPORTSETINFO)GetProcAddress(
                    h, SZ_MprAdminInterfaceTransportSetInfo))
        || !(g_pMprAdminServerConnect =
                (PMPRADMINSERVERCONNECT)GetProcAddress(
                    h, SZ_MprAdminServerConnect))
        || !(g_pMprAdminServerDisconnect =
                (PMPRADMINSERVERDISCONNECT)GetProcAddress(
                    h, SZ_MprAdminServerDisconnect))
        || !(g_pMprAdminTransportSetInfo =
                (PMPRADMINTRANSPORTSETINFO)GetProcAddress(
                    h, SZ_MprAdminTransportSetInfo))
        || !(g_pRasAdminServerConnect =
                (PRASADMINSERVERCONNECT)GetProcAddress(
                    h, SZ_RasAdminServerConnect))
        || !(g_pRasAdminServerDisconnect =
                (PRASADMINSERVERDISCONNECT)GetProcAddress(
                    h, SZ_RasAdminServerDisconnect))
        || !(g_pRasAdminBufferFree =
                (PRASADMINBUFFERFREE)GetProcAddress(
                    h, SZ_RasAdminBufferFree))
        || !(g_pRasAdminConnectionEnum =
                (PRASADMINCONNECTIONENUM)GetProcAddress(
                    h, SZ_RasAdminConnectionEnum))
        || !(g_pRasAdminConnectionGetInfo =
                (PRASADMINCONNECTIONGETINFO)GetProcAddress(
                    h, SZ_RasAdminConnectionGetInfo))
        || !(g_pRasAdminPortEnum =
                (PRASADMINPORTENUM)GetProcAddress(
                    h, SZ_RasAdminPortEnum))
        || !(g_pRasAdminPortGetInfo =
                (PRASADMINPORTGETINFO)GetProcAddress(
                    h, SZ_RasAdminPortGetInfo))
        || !(g_pRasAdminPortDisconnect =
                (PRASADMINPORTDISCONNECT)GetProcAddress(
                    h, SZ_RasAdminPortDisconnect))
        || !(g_pRasAdminUserSetInfo =
                (PRASADMINUSERSETINFO)GetProcAddress(
                    h, SZ_RasAdminUserSetInfo))
        || !(g_pMprAdminUserServerConnect =
                (PMPRADMINUSERSERVERCONNECT)GetProcAddress(
                    h, SZ_MprAdminUserServerConnect))
        || !(g_pMprAdminUserServerDisconnect =
                (PMPRADMINUSERSERVERDISCONNECT)GetProcAddress(
                    h, SZ_MprAdminUserServerDisconnect))
        || !(g_pMprAdminUserOpen =
                (PMPRADMINUSEROPEN)GetProcAddress(
                    h, SZ_MprAdminUserOpen))
        || !(g_pMprAdminUserClose =
                (PMPRADMINUSERCLOSE)GetProcAddress(
                    h, SZ_MprAdminUserClose))
        || !(g_pMprAdminUserWrite =
                (PMPRADMINUSERWRITE)GetProcAddress(
                    h, SZ_MprAdminUserWrite))
        || !(g_pMprConfigBufferFree =
                (PMPRCONFIGBUFFERFREE)GetProcAddress(
                    h, SZ_MprConfigBufferFree))
        || !(g_pMprConfigServerConnect =
                (PMPRCONFIGSERVERCONNECT)GetProcAddress(
                    h, SZ_MprConfigServerConnect))
        || !(g_pMprConfigServerDisconnect =
                (PMPRCONFIGSERVERDISCONNECT)GetProcAddress(
                    h, SZ_MprConfigServerDisconnect))
        || !(g_pMprConfigTransportGetInfo =
                (PMPRCONFIGTRANSPORTGETINFO)GetProcAddress(
                    h, SZ_MprConfigTransportGetInfo))
        || !(g_pMprConfigTransportSetInfo =
                (PMPRCONFIGTRANSPORTSETINFO)GetProcAddress(
                    h, SZ_MprConfigTransportSetInfo))
        || !(g_pMprConfigTransportGetHandle =
                (PMPRCONFIGTRANSPORTGETHANDLE)GetProcAddress(
                    h, SZ_MprConfigTransportGetHandle))
        || !(g_pMprConfigInterfaceCreate =
                (PMPRCONFIGINTERFACECREATE)GetProcAddress(
                    h, SZ_MprConfigInterfaceCreate))
        || !(g_pMprConfigInterfaceDelete =
                (PMPRCONFIGINTERFACEDELETE)GetProcAddress(
                    h, SZ_MprConfigInterfaceDelete))
        || !(g_pMprConfigInterfaceGetHandle =
                (PMPRCONFIGINTERFACEGETHANDLE)GetProcAddress(
                    h, SZ_MprConfigInterfaceGetHandle))
        || !(g_pMprConfigInterfaceEnum =
                (PMPRCONFIGINTERFACEENUM)GetProcAddress(
                    h, SZ_MprConfigInterfaceEnum))
        || !(g_pMprConfigInterfaceTransportAdd =
                (PMPRCONFIGINTERFACETRANSPORTADD)GetProcAddress(
                    h, SZ_MprConfigInterfaceTransportAdd))
        || !(g_pMprConfigInterfaceTransportGetInfo =
                (PMPRCONFIGINTERFACETRANSPORTGETINFO)GetProcAddress(
                    h, SZ_MprConfigInterfaceTransportGetInfo))
        || !(g_pMprConfigInterfaceTransportSetInfo =
                (PMPRCONFIGINTERFACETRANSPORTSETINFO)GetProcAddress(
                    h, SZ_MprConfigInterfaceTransportSetInfo))
        || !(g_pMprConfigInterfaceTransportGetHandle =
                (PMPRCONFIGINTERFACETRANSPORTGETHANDLE)GetProcAddress(
                    h, SZ_MprConfigInterfaceTransportGetHandle))
        || !(g_pMprInfoCreate =
                (PMPRINFOCREATE)GetProcAddress(
                    h, SZ_MprInfoCreate))
        || !(g_pMprInfoDelete =
                (PMPRINFODELETE)GetProcAddress(
                    h, SZ_MprInfoDelete))
        || !(g_pMprInfoDuplicate =
                (PMPRINFODUPLICATE)GetProcAddress(
                    h, SZ_MprInfoDuplicate))
        || !(g_pMprInfoBlockAdd =
                (PMPRINFOBLOCKADD)GetProcAddress(
                    h, SZ_MprInfoBlockAdd))
        || !(g_pMprInfoBlockRemove =
                (PMPRINFOBLOCKREMOVE)GetProcAddress(
                    h, SZ_MprInfoBlockRemove))
        || !(g_pMprInfoBlockSet =
                (PMPRINFOBLOCKSET)GetProcAddress(
                    h, SZ_MprInfoBlockSet))
        || !(g_pMprInfoBlockFind =
                (PMPRINFOBLOCKFIND)GetProcAddress(
                    h, SZ_MprInfoBlockFind)) )
    {
        return GetLastError();
    }

    g_hMpradminDll = h;

    return 0;
}

DWORD
LoadRasapi32Dll(
    void )

/*++

Routine Description
    Loads the RASAPI32.DLL and it's entrypoints.

Arguments

Return Value

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    HINSTANCE h;

    if (g_hRasapi32Dll)
        return 0;

    if (!(h = LoadLibrary( TEXT("RASAPI32.DLL") ))
        || !(g_pRasConnectionNotification =
                (PRASCONNECTIONNOTIFICATION )GetProcAddress(
                    h, SZ_RasConnectionNotification ))
        || !(g_pRasDeleteEntry =
                (PRASDELETEENTRY )GetProcAddress(
                    h, SZ_RasDeleteEntry ))
        || !(g_pRasDial =
                (PRASDIAL )GetProcAddress(
                    h, SZ_RasDial ))
        || !(g_pRasEnumEntries =
                (PRASENUMENTRIES )GetProcAddress(
                    h, SZ_RasEnumEntries ))
        || !(g_pRasEnumConnections =
                (PRASENUMCONNECTIONS )GetProcAddress(
                    h, SZ_RasEnumConnections ))
        || !(g_pRasGetAutodialEnable =
                (PRASGETAUTODIALENABLE )GetProcAddress(
                    h, SZ_RasGetAutodialEnable ))
        || !(g_pRasGetAutodialParam =
                (PRASGETAUTODIALPARAM )GetProcAddress(
                    h, SZ_RasGetAutodialParam ))
        || !(g_pRasGetConnectStatus =
                (PRASGETCONNECTSTATUS )GetProcAddress(
                    h, SZ_RasGetConnectStatus ))
        || !(g_pRasGetConnectResponse =
                (PRASGETCONNECTRESPONSE )GetProcAddress(
                    h, SZ_RasGetConnectResponse ))
        || !(g_pRasGetCredentials =
                (PRASGETCREDENTIALS )GetProcAddress(
                    h, SZ_RasGetCredentials ))
        || !(g_pRasGetEntryDialParams =
                (PRASGETENTRYDIALPARAMS )GetProcAddress(
                    h, SZ_RasGetEntryDialParams ))
        || !(g_pRasGetErrorString =
                (PRASGETERRORSTRING )GetProcAddress(
                    h, SZ_RasGetErrorString ))
        || !(g_pRasGetHport =
                (PRASGETHPORT )GetProcAddress(
                    h, "RasGetHport" ))
        || !(g_pRasGetProjectionInfo =
                (PRASGETPROJECTIONINFO )GetProcAddress(
                    h, SZ_RasGetProjectionInfo ))
        || !(g_pRasGetSubEntryHandle =
                (PRASGETSUBENTRYHANDLE )GetProcAddress(
                    h, SZ_RasGetSubEntryHandle ))
        || !(g_pRasHangUp =
                (PRASHANGUP )GetProcAddress(
                    h, SZ_RasHangUp ))
        || !(g_pRasSetAutodialEnable =
                (PRASSETAUTODIALENABLE )GetProcAddress(
                    h, SZ_RasSetAutodialEnable ))
        || !(g_pRasSetAutodialParam =
                (PRASSETAUTODIALPARAM )GetProcAddress(
                    h, SZ_RasSetAutodialParam ))
        || !(g_pRasSetCredentials =
                (PRASSETCREDENTIALS )GetProcAddress(
                    h, SZ_RasSetCredentials ))
        || !(g_pRasSetOldPassword =
                (PRASSETOLDPASSWORD )GetProcAddress(
                    h, "RasSetOldPassword" ))
        || !(g_pRasGetCountryInfo =
                (PRASGETCOUNTRYINFO )GetProcAddress(
                    h, SZ_RasGetCountryInfo ))
        ||  !(g_pRasInvokeEapUI =
                (PRASINVOKEEAPUI)GetProcAddress(
                    h, "RasInvokeEapUI"))
        ||  !(g_pRasSetEapUserData =
                (PRASSETEAPUSERDATA )GetProcAddress(
                    h, SZ_RasSetEapUserData ))
        ||  !(g_pRasGetEntryProperties =
                (PRASGETENTRYPROPERTIES )GetProcAddress(
                    h, SZ_RasGetEntryProperties))
        ||  !(g_pRasValidateEntryName =
                (PRASVALIDATEENTRYNAME )GetProcAddress(
                    h, SZ_RasValidateEntryName)))
    {
        return GetLastError();
    }

    g_hRasapi32Dll = h;
    return 0;
}


DWORD
LoadRasdlgDll(
    void )

/*++

Routine Description

    Loads the RASDLG.DLL and it's entrypoints.

Arguments

Return Value
    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    HINSTANCE h;

    if (g_hRasdlgDll)
        return 0;

    if (!(h = LoadLibrary( TEXT("RASDLG.DLL") ))
        || !(g_pRasPhonebookDlg =
                (PRASPHONEBOOKDLG )GetProcAddress(
                    h, SZ_RasPhonebookDlg ))
        || !(g_pRasEntryDlg =
                (PRASENTRYDLG )GetProcAddress(
                    h, SZ_RasEntryDlg ))
        || !(g_pRouterEntryDlg =
                (PROUTERENTRYDLG )GetProcAddress(
                    h, SZ_RouterEntryDlg ))
        || !(g_pRasDialDlg =
                (PRASDIALDLG )GetProcAddress(
                    h, SZ_RasDialDlg )))
    {
        return GetLastError();
    }

    g_hRasdlgDll = h;
    return 0;
}


DWORD
LoadRasmanDll(
    void )

/*++

Routine Description

    Loads the RASMAN.DLL and it's entrypoints.

Arguments

Return Value

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    HINSTANCE h;
    DWORD     dwErr;

    if (g_hRasmanDll)
        return 0;

    if (!(h = LoadLibrary( TEXT("RASMAN.DLL") ))
        || !(g_pRasPortClearStatistics =
                (PRASPORTCLEARSTATISTICS )GetProcAddress(
                    h, "RasPortClearStatistics" ))
        || !(g_pRasBundleClearStatistics =
                (PRASBUNDLECLEARSTATISTICS )GetProcAddress(
                    h, "RasBundleClearStatistics" ))
        || !(g_pRasBundleClearStatisticsEx =
                (PRASBUNDLECLEARSTATISTICSEX ) GetProcAddress(
                    h, "RasBundleClearStatisticsEx"))
        || !(g_pRasDeviceEnum =
                (PRASDEVICEENUM )GetProcAddress(
                    h, "RasDeviceEnum" ))
        || !(g_pRasDeviceGetInfo =
                (PRASDEVICEGETINFO )GetProcAddress(
                    h, "RasDeviceGetInfo" ))
        || !(g_pRasFreeBuffer =
                (PRASFREEBUFFER )GetProcAddress(
                    h, "RasFreeBuffer" ))
        || !(g_pRasGetBuffer =
                (PRASGETBUFFER )GetProcAddress(
                    h, "RasGetBuffer" ))
        || !(g_pRasGetInfo =
                (PRASGETINFO )GetProcAddress(
                    h, "RasGetInfo" ))
        || !(g_pRasGetNdiswanDriverCaps =
                (PRASGETNDISWANDRIVERCAPS )GetProcAddress(
                    h, "RasGetNdiswanDriverCaps" ))
        || !(g_pRasInitialize =
                (PRASINITIALIZE )GetProcAddress(
                    h, "RasInitialize" ))
        || !(g_pRasInitializeNoWait =
                (PRASINITIALIZENOWAIT )GetProcAddress(
                    h, "RasInitializeNoWait" ))
        || !(g_pRasPortCancelReceive =
                (PRASPORTCANCELRECEIVE )GetProcAddress(
                    h, "RasPortCancelReceive" ))
        || !(g_pRasPortEnum =
                (PRASPORTENUM )GetProcAddress(
                    h, "RasPortEnum" ))
        || !(g_pRasPortGetInfo =
                (PRASPORTGETINFO )GetProcAddress(
                    h, "RasPortGetInfo" ))
        || !(g_pRasPortGetFramingEx =
                (PRASPORTGETFRAMINGEX )GetProcAddress(
                    h, "RasPortGetFramingEx" ))
        || !(g_pRasPortGetStatistics =
                (PRASPORTGETSTATISTICS )GetProcAddress(
                    h, "RasPortGetStatistics" ))
        || !(g_pRasBundleGetStatistics =
                (PRASBUNDLEGETSTATISTICS )GetProcAddress(
                    h, "RasBundleGetStatistics" ))
        || !(g_pRasPortGetStatisticsEx =
                (PRASPORTGETSTATISTICSEX )GetProcAddress(
                    h, "RasPortGetStatisticsEx"))
        || !(g_pRasBundleGetStatisticsEx =
                (PRASBUNDLEGETSTATISTICSEX)GetProcAddress(
                    h, "RasBundleGetStatisticsEx" ))
        || !(g_pRasPortReceive =
                (PRASPORTRECEIVE )GetProcAddress(
                    h, "RasPortReceive" ))
        || !(g_pRasPortReceiveEx =
                (PRASPORTRECEIVEEX )GetProcAddress(
                    h, "RasPortReceiveEx"))
        || !(g_pRasPortSend =
                (PRASPORTSEND )GetProcAddress(
                    h, "RasPortSend" ))
        || !(g_pRasPortGetBundle =
                (PRASPORTGETBUNDLE )GetProcAddress(
                    h, "RasPortGetBundle" ))
        || !(g_pRasGetDevConfig =
                (PRASGETDEVCONFIG )GetProcAddress(
                    h, "RasGetDevConfig" ))
        || !(g_pRasGetDevConfigEx =
                (PRASGETDEVCONFIG )GetProcAddress(
                    h, "RasGetDevConfigEx" ))
        || !(g_pRasSetDevConfig =
                (PRASSETDEVCONFIG )GetProcAddress(
                    h, "RasSetDevConfig" ))
        || !(g_pRasPortClose =
                (PRASPORTCLOSE )GetProcAddress(
                    h, "RasPortClose" ))
        || !(g_pRasPortListen =
                (PRASPORTLISTEN )GetProcAddress(
                    h, "RasPortListen" ))
        || !(g_pRasPortConnectComplete =
                (PRASPORTCONNECTCOMPLETE )GetProcAddress(
                    h, "RasPortConnectComplete" ))
        || !(g_pRasPortDisconnect =
                (PRASPORTDISCONNECT )GetProcAddress(
                    h, "RasPortDisconnect" ))
        || !(g_pRasRequestNotification =
                (PRASREQUESTNOTIFICATION )GetProcAddress(
                    h, "RasRequestNotification" ))
        || !(g_pRasPortEnumProtocols =
                (PRASPORTENUMPROTOCOLS )GetProcAddress(
                    h, "RasPortEnumProtocols" ))
        || !(g_pRasPortSetFraming =
                (PRASPORTSETFRAMING )GetProcAddress(
                    h, "RasPortSetFraming" ))
        || !(g_pRasPortSetFramingEx =
                (PRASPORTSETFRAMINGEX )GetProcAddress(
                    h, "RasPortSetFramingEx" ))
        || !(g_pRasSetCachedCredentials =
                (PRASSETCACHEDCREDENTIALS )GetProcAddress(
                    h, "RasSetCachedCredentials" ))
        || !(g_pRasGetDialParams =
                (PRASGETDIALPARAMS )GetProcAddress(
                    h, "RasGetDialParams" ))
        || !(g_pRasSetDialParams =
                (PRASSETDIALPARAMS )GetProcAddress(
                    h, "RasSetDialParams" ))
        || !(g_pRasCreateConnection =
                (PRASCREATECONNECTION )GetProcAddress(
                    h, "RasCreateConnection" ))
        || !(g_pRasDestroyConnection =
                (PRASDESTROYCONNECTION )GetProcAddress(
                    h, "RasDestroyConnection" ))
        || !(g_pRasConnectionEnum =
                (PRASCONNECTIONENUM )GetProcAddress(
                    h, "RasConnectionEnum" ))
        || !(g_pRasAddConnectionPort =
                (PRASADDCONNECTIONPORT )GetProcAddress(
                    h, "RasAddConnectionPort" ))
        || !(g_pRasEnumConnectionPorts =
                (PRASENUMCONNECTIONPORTS )GetProcAddress(
                    h, "RasEnumConnectionPorts" ))
        || !(g_pRasGetConnectionParams =
                (PRASGETCONNECTIONPARAMS )GetProcAddress(
                    h, "RasGetConnectionParams" ))
        || !(g_pRasSetConnectionParams =
                (PRASSETCONNECTIONPARAMS )GetProcAddress(
                    h, "RasSetConnectionParams" ))
        || !(g_pRasGetConnectionUserData =
                (PRASGETCONNECTIONUSERDATA )GetProcAddress(
                    h, "RasGetConnectionUserData" ))
        || !(g_pRasSetConnectionUserData =
                (PRASSETCONNECTIONUSERDATA )GetProcAddress(
                    h, "RasSetConnectionUserData" ))
        || !(g_pRasGetPortUserData =
                (PRASGETPORTUSERDATA )GetProcAddress(
                    h, "RasGetPortUserData" ))
        || !(g_pRasSetPortUserData =
                (PRASSETPORTUSERDATA )GetProcAddress(
                    h, "RasSetPortUserData" ))
        || !(g_pRasAddNotification =
                (PRASADDNOTIFICATION )GetProcAddress(
                    h, "RasAddNotification" ))
        || !(g_pRasSignalNewConnection =
                (PRASSIGNALNEWCONNECTION )GetProcAddress(
                    h, "RasSignalNewConnection" ))
        || !(g_pRasPppStop =
                (PRASPPPSTOP )GetProcAddress(
                    h, "RasPppStop" ))
        || !(g_pRasPppCallback =
                (PRASPPPCALLBACK )GetProcAddress(
                    h, "RasPppCallback" ))
        || !(g_pRasPppChangePassword =
                (PRASPPPCHANGEPASSWORD )GetProcAddress(
                    h, "RasPppChangePassword" ))
        || !(g_pRasPppGetInfo =
                (PRASPPPGETINFO )GetProcAddress(
                    h, "RasPppGetInfo" ))
        || !(g_pRasPppRetry =
                (PRASPPPRETRY )GetProcAddress(
                    h, "RasPppRetry" ))
        || !(g_pRasPppStart =
                (PRASPPPSTART )GetProcAddress(
                    h, "RasPppStart" ))
        || !(g_pRasPortOpen =
                (PRASPORTOPEN )GetProcAddress(
                    h, "RasPortOpen" ))
        || !(g_pRasPortRegisterSlip =
                (PRASPORTREGISTERSLIP )GetProcAddress(
                    h, "RasPortRegisterSlip" ))
        || !(g_pRasAllocateRoute =
                (PRASALLOCATEROUTE )GetProcAddress(
                    h, "RasAllocateRoute" ))
        || !(g_pRasActivateRoute =
                (PRASACTIVATEROUTE )GetProcAddress(
                    h, "RasActivateRoute" ))
        || !(g_pRasActivateRouteEx =
                (PRASACTIVATEROUTEEX )GetProcAddress(
                    h, "RasActivateRouteEx" ))
        || !(g_pRasDeviceSetInfo =
                (PRASDEVICESETINFO )GetProcAddress(
                    h, "RasDeviceSetInfo" ))
        || !(g_pRasDeviceConnect =
                (PRASDEVICECONNECT )GetProcAddress(
                    h, "RasDeviceConnect" ))
        || !(g_pRasPortSetInfo =
                (PRASPORTSETINFO )GetProcAddress(
                    h, "RasPortSetInfo" ))
        || !(g_pRasSetIoCompletionPort =
                (PRASSETIOCOMPLETIONPORT )GetProcAddress(
                    h, "RasSetIoCompletionPort" ))
        || !(g_pRasSendPppMessageToRasman =
                        (PRASSENDPPPMESSAGETORASMAN)GetProcAddress(
                                h, "RasSendPppMessageToRasman"))
        ||  !(g_pRasSetRasdialInfo =
                (PRASSETRASDIALINFO)GetProcAddress(
                    h, "RasSetRasdialInfo"))
        ||  !(g_pRasRpcConnect =
                (PRASRPCCONNECT)GetProcAddress(
                    h, "RasRpcConnect"))
        ||  !(g_pRasRpcDisconnect =
                (PRASRPCDISCONNECT) GetProcAddress(
                    h, "RasRpcDisconnect"))
        ||  !(g_pRasNumPortOpen =
                (PRASNUMPORTOPEN)GetProcAddress(
                    h, "RasGetNumPortOpen"))
        ||  !(g_pRasRefConnection =
                (PRASREFCONNECTION) GetProcAddress(
                    h, "RasRefConnection"))
        ||  !(g_pRasPppSetEapInfo =
                (PRASPPPSETEAPINFO) GetProcAddress(
                    h, "RasPppSetEapInfo"))
        ||  !(g_pRasPppGetEapInfo =
                (PRASPPPGETEAPINFO) GetProcAddress(
                    h, "RasPppGetEapInfo"))
        ||  !(g_pRasFindPrerequisiteEntry =
                (PRASFINDPREREQUISITEENTRY) GetProcAddress(
                    h, "RasFindPrerequisiteEntry"))
        ||  !(g_pRasPortOpenEx =
                (PRASPORTOPENEX) GetProcAddress(
                    h, "RasPortOpenEx"))
        ||  !(g_pRasLinkGetStatistics =
                (PRASLINKGETSTATISTICS) GetProcAddress(
                    h, "RasLinkGetStatistics"))
        ||  !(g_pRasConnectionGetStatistics =
                (PRASCONNECTIONGETSTATISTICS) GetProcAddress(
                    h, "RasConnectionGetStatistics"))
        ||  !(g_pRasGetHportFromConnection =
                (PRASGETHPORTFROMCONNECTION) GetProcAddress(
                    h, "RasGetHportFromConnection"))
        ||  !(g_pRasRpcBind =
                (PRASRPCBIND) GetProcAddress(
                    h, "RasRPCBind"))
        ||  !(g_pRasReferenceCustomCount =
                (PRASREFERENCECUSTOMCOUNT) GetProcAddress(
                    h, "RasReferenceCustomCount"))
        ||  !(g_pRasGetHConnFromEntry =
                (PRASGETHCONNFROMENTRY)GetProcAddress(
                    h, "RasGetHConnFromEntry"))
        ||  !(g_pRasGetDeviceName =
                (PRASGETDEVICENAME)GetProcAddress(
                    h, "RasGetDeviceName"))
        ||  !(g_pRasEnableIpSec =
                (PRASENABLEIPSEC)GetProcAddress(
                    h, "RasEnableIpSec"))
        ||  !(g_pRasIsIpSecEnabled =
                (PRASISIPSECENABLED)GetProcAddress(
                    h, "RasIsIpSecEnabled"))
        ||  !(g_pRasGetEapUserInfo =
                (PRASGETEAPUSERINFO)GetProcAddress(
                    h, "RasGetEapUserInfo"))
        ||  !(g_pRasSetEapUserInfo =
                (PRASSETEAPUSERINFO)GetProcAddress(
                    h, "RasSetEapUserInfo"))
        ||  !(g_pRasSetEapLogonInfo =
                (PRASSETEAPLOGONINFO)GetProcAddress(
                    h, "RasSetEapLogonInfo"))
        ||  !(g_pRasStartRasAutoIfRequired =
                (PRASSTARTRASAUTOIFREQUIRED) GetProcAddress(
                    h, "RasStartRasAutoIfRequired"))
                )
    {
        return GetLastError();
    }

    g_hRasmanDll = h;
    return 0;
}

DWORD
GetServerVersion(
        RPC_BINDING_HANDLE hServer,
        PDWORD pdwVersion
        )
{
    DWORD dwStatus;

#if DBG
    ASSERT(NULL != pdwVersion);
    ASSERT(NULL != hServer);
#endif

    *pdwVersion = VERSION_501;

    //
    // Call the get version api
    //
    dwStatus = RemoteGetVersion(hServer, pdwVersion);

    //
    // If the api fails, we assume that the server we
    // are talking to is steelhead and initialize the
    // version to 4.0. 
    //
    if (RPC_S_PROCNUM_OUT_OF_RANGE == dwStatus)
    {
        *pdwVersion = VERSION_40;

        dwStatus = NO_ERROR;
    }

    return dwStatus;
}

void
UninitializeConnection(HANDLE hConnection)
{
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG
    ASSERT(NULL != hConnection);
    //DbgPrint("rasman: Disconnecting from server. handle=0x%08x\n",
    //         pRasRpcConnection->hRpcBinding);
#endif

    (void) RpcBindingFree(pRasRpcConnection->hRpcBinding);

    LocalFree(pRasRpcConnection);

    /*
    //
    // Decrement the connect count and Unload rasapi32 dll
    // if this is the last client disconnecting.
    //
    if(!InterlockedDecrement(&g_dwConnectCount))
    {
        UnloadRasapi32Dll();
        UnloadRasmanDll();
    }
    */
}

DWORD
InitializeConnection(
    LPTSTR lpszServer,
    HANDLE *lpHConnection)
{
    RAS_RPC *pRasRpcConnection = NULL;

    DWORD dwError = ERROR_SUCCESS;

    TCHAR szLocalComputer[MAX_COMPUTERNAME_LENGTH + 1] = {0};

    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;

    BOOL fLocal = FALSE;

    LPTSTR lpszSrv = lpszServer;

    RPC_BINDING_HANDLE hServer = NULL;

    DWORD dwVersion;

    //
    // Do some parameter validation. If lpszServer is
    // NULL then we connect to the local server
    //
    if(NULL == lpHConnection)
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    *lpHConnection = NULL;

    //
    // Get the local computername
    //
    if(!GetComputerName(szLocalComputer, &dwSize))
    {
        dwError = GetLastError();
        goto done;
    }

    if(     NULL != lpszServer
        &&  TEXT('\0') != lpszServer[0]
        &&  TEXT('\\') == lpszServer[0]
        &&  TEXT('\\') == lpszServer[1])
    {
        lpszSrv += 2;
    }
    else if(    NULL == lpszServer
            ||  TEXT('\0') == lpszServer[0])
    {
        fLocal = TRUE;
    }

    if(     !fLocal
        &&  0 == lstrcmpi(lpszSrv, szLocalComputer))
    {
        fLocal = TRUE;
    }

    if(fLocal)
    {
        lpszSrv = szLocalComputer;
    }

    //
    // Always load rasman dll and rasapi32.dll if
    // they are not already loaded
    //
    if(     ERROR_SUCCESS != (dwError = LoadRasmanDll())
        ||  ERROR_SUCCESS != (dwError = LoadRasapi32Dll()))
    {
        goto done;
    }

#if DBG
    //DbgPrint("Rasman: Binding to server %ws\n",
    //         lpszSrv);
#endif

    //
    // Bind to the server indicated by the servername
    //
    dwError = g_pRasRpcBind(lpszSrv, &hServer);

#if DBG
        //DbgPrint("Rasman: Bind returned 0x%08x. hServer=0x08x\n",
        //         dwError, hServer);
#endif

    if(NO_ERROR != dwError)
    {
        goto done;
    }

    //
    // Get version of the server
    //
    dwError = GetServerVersion(hServer, &dwVersion);

    if(NO_ERROR != dwError)
    {
        goto done;
    }

    //
    // Allocate and initialize the ControlBlock we
    // keep around for this connection
    //
    if(NULL == (pRasRpcConnection =
        LocalAlloc(LPTR, sizeof(RAS_RPC))))
    {
        dwError = GetLastError();
        goto done;
    }

    pRasRpcConnection->hRpcBinding = hServer;
    pRasRpcConnection->fLocal      = fLocal;

    if(fLocal)
    {
        pRasRpcConnection->dwVersion = VERSION_501;
    }
    else
    {
        pRasRpcConnection->dwVersion   = dwVersion;
    }

    lstrcpyn(
        pRasRpcConnection->szServer, 
        lpszSrv,
        sizeof(pRasRpcConnection->szServer) / sizeof(TCHAR));

    *lpHConnection = (HANDLE) pRasRpcConnection;

/*
    InterlockedIncrement(&g_dwConnectCount);
*/

done:

    if(     NO_ERROR != dwError
        &&  NULL != hServer)
    {
        (void) RpcBindingFree(
            hServer
            );

    }

    return dwError;
}


#if 0

DWORD
LoadRasRpcDll(
    LPTSTR  lpszServer
    )
{
    DWORD       dwErr;
    RPC_STATUS  rpcStatus;
    HINSTANCE   h;
    TCHAR       szComputerName[MAX_COMPUTERNAME_LENGTH + 1] = {0};
    DWORD       dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL        fLocal = (lpszServer ? FALSE : TRUE);
    LPTSTR      pszServer = lpszServer;

    //
    // Get the local computername
    //
    if (!GetComputerName(szComputerName, &dwSize))
    {
        dwErr = GetLastError();
        return dwErr;
    }

    if (    lpszServer
        &&  TEXT('\\') == lpszServer[0]
        &&  TEXT('\\') == lpszServer[1])
    {
        pszServer += 2;
    }

    if (    pszServer
        &&  0 == lstrcmpi (pszServer, szComputerName))
    {
        fLocal = TRUE;
    }

    dwErr = LoadRasmanDll();

    if (dwErr)
    {
        return dwErr;
    }

    //
    // disconnect previous binding if we had one
    //
    if ( NULL != g_hBinding )
    {
        g_pRasRpcDisconnect ( &g_hBinding );

        g_hBinding = NULL;

        g_fRasmanPreviouslyLoaded = TRUE;

    }

    //
    // this will connect to local server
    // if lpszServer = NULL
    //
    dwErr = g_pRasRpcConnect( (fLocal ? NULL : pszServer), &g_hBinding );

    if ( dwErr )
    {
        return dwErr;
    }

    if ( fLocal )
    {
        //
        // LoadRasapi32Dll
        //
        dwErr = LoadRasapi32Dll();

        g_fRasapi32PreviouslyLoaded = TRUE;

        return 0;
    }

    g_fRasapi32PreviouslyLoaded = ( g_hRasapi32Dll != NULL );

    if (g_fRasapi32PreviouslyLoaded)
    {
        UnloadRasapi32Dll();
    }

    //
    // Get version of the server we are talking to
    //
    (void) GetServerVersion(g_hBinding, &g_Version);

    //
    // Remap the RPCable APIs. Note: We don't need
    // to bother about the APIs exported by rasman
    // as all rasman APIs always use RPC We need to
    // remap only the APIs exported by dlls which
    // are not exported by rasman.
    //
    /*
    g_pRasEnumConnections       = RemoteRasEnumConnections;
    g_pRasDeleteEntry           = RemoteRasDeleteEntry;
    g_pRasGetErrorString        = RemoteRasGetErrorString;
    g_pRasGetCountryInfo        = RemoteRasGetCountryInfo;
    g_pGetInstalledProtocolsEx  = RemoteGetInstalledProtocolsEx;
    g_pGetUserPreferences       = RemoteGetUserPreferences;
    g_pSetUserPreferences       = RemoteSetUserPreferences;
    g_pGetSystemDirectory       = RemoteGetSystemDirectory;

    if ( VERSION_40 == g_Version )
    {
        g_pRasPortEnum = RemoteRasPortEnum;
        g_pRasDeviceEnum = RemoteRasDeviceEnum;
        g_pRasGetDevConfig = RemoteRasGetDevConfig;
        g_pRasPortGetInfo = RemoteRasPortGetInfo;
    } */

    return 0;
}

#endif

BOOL
Rasapi32DllLoaded(
    void
    )
{
    return (g_hRasapi32Dll != NULL);
}


BOOL
RasRpcDllLoaded(
    void
    )
{
    return (g_hBinding != NULL);
}

LPTSTR
RemoteGetServerName(HANDLE hConnection)
{
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if(     NULL == pRasRpcConnection
        ||  pRasRpcConnection->fLocal)
    {
        return NULL;
    }
    else
    {
        return pRasRpcConnection->szServer;
    }
}

DWORD
RemoteGetServerVersion(HANDLE hConnection)
{
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if(     NULL == pRasRpcConnection
        ||  pRasRpcConnection->fLocal)
    {
        return VERSION_501;
    }
    else
    {
        return pRasRpcConnection->dwVersion;
    }
}

BOOL
IsRasRemoteConnection(
    HANDLE hConnection
    )
{
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if(NULL == pRasRpcConnection)
    {
        return FALSE;
    }

    return TRUE;
}

DWORD
RemoteGetVersion(
    RPC_BINDING_HANDLE hServer,
    PDWORD pdwVersion
    )
{
    DWORD dwStatus;

#if DBG
    ASSERT(NULL != pdwVersion);
    ASSERT(NULL != hServer);
#endif

    RpcTryExcept
    {
        dwStatus = RasRpcGetVersion(hServer, pdwVersion);
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;

}

//---------------------------------------------------
// The following are remoted version of apis exported
// from rasman.dll. These should never be called if
// the version of the server is 50 since the rasman
// apis themselves are remoteable
//

/*++

Routine Description:

    This api enumerates the port information on the
    remote server. This api should not be called if
    the server is local or if the version of the
    remote server is VERSION_501.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api. This cannot
                  be NULL.

    lpPorts - Buffer to receive the port information

    pdwcbPorts - address of the buffer to receive the
                 count of bytes required to get the
                 information

    pdwcPorts - address of the buffer to receive the
                count of ports/size of buffer passed
                in

Return Value:

    Rpc api errors

--*/
DWORD APIENTRY
RemoteRasPortEnum(
    HANDLE hConnection,
    PBYTE lpPorts,
    PDWORD pdwcbPorts,
    PDWORD pdwcPorts
    )
{
    DWORD dwStatus;
    WORD  wcbPorts;
    WORD  wcPorts;
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

    ASSERT(VERSION_40 == pRasRpcConnection->dwVersion);

#endif

    RpcTryExcept
    {
        wcbPorts = (WORD) *pdwcbPorts;
        wcPorts = (WORD) *pdwcPorts;

        dwStatus = RasRpcPortEnum(
                    pRasRpcConnection->hRpcBinding,
                    lpPorts,
                    &wcbPorts,
                    &wcPorts);

        *pdwcbPorts = (DWORD) wcbPorts;
        *pdwcPorts = (DWORD) wcPorts;

    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}

/*++

Routine Description:

    This api enumerates the devices on the remote
    computer. This api should not be called if the
    server is local or if the version of the remote
    server is VERSION_501.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api. This cannot
                  be NULL.

    pszDeviceType - string indicating the device type

    lpDevices - Buffer to receive the device information

    pdwcbDevices - address of the buffer to receive the
                   count of bytes required to get the
                   information

    pdwcDevices - address of the buffer to receive the
                  count of devices/size of buffer passed
                  in

Return Value:

    Rpc api errors

--*/
DWORD APIENTRY
RemoteRasDeviceEnum(
    HANDLE hConnection,
    PCHAR  pszDeviceType,
    PBYTE  lpDevices,
    PDWORD pdwcbDevices,
    PDWORD pdwcDevices
    )
{
    DWORD dwStatus;
    WORD  wcbDevices;
    WORD  wcDevices;
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

    ASSERT(VERSION_40 == pRasRpcConnection->dwVersion);

#endif

    RpcTryExcept
    {

        wcbDevices = (WORD) *pdwcbDevices;
        wcDevices = (WORD) *pdwcDevices;

        dwStatus = RasRpcDeviceEnum(
                    pRasRpcConnection->hRpcBinding,
                    pszDeviceType,
                    lpDevices,
                    &wcbDevices,
                    &wcDevices);

        *pdwcbDevices = (DWORD) wcbDevices;
        *pdwcDevices = (DWORD) wcDevices;

    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}

/*++

Routine Description:

    This api gets the device configuration information.
    This api should not be called if the server is local
    or if the version of the remote server is VERSION_501.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api. This cannot
                  be NULL.

    hPort - HPORT

    pszDeviceType - string indicating Device type

    lpConfig - buffer to receive the Config info

    lpcbConfig - buffer to receive the count of bytes
                 required for the information/size of
                 buffer passed in

Return Value:

    Rpc api errors

--*/
DWORD APIENTRY
RemoteRasGetDevConfig(
    HANDLE hConnection,
    HPORT hport,
    PCHAR pszDeviceType,
    PBYTE lpConfig,
    LPDWORD lpcbConfig
    )
{
    DWORD dwStatus;
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

    ASSERT(VERSION_40 == pRasRpcConnection->dwVersion);

#endif

    RpcTryExcept
    {
        dwStatus = RasRpcGetDevConfig(
                    pRasRpcConnection->hRpcBinding,
                    HandleToUlong(hport),
                    pszDeviceType,
                    lpConfig,
                    lpcbConfig);
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


/*++

Routine Description:

    This api gets the port information of the port
    indicated by hport passed in for the remote
    computer. This api should not be called if the
    server is local or if the version of the remote
    server is VERSION_501.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api. This cannot
                  be NULL.

    porthandle - HPORT

    buffer - buffer to receive the Port information

    pSize - buffer to receive the count of bytes
            required for the information/size of buffer


Return Value:

    Rpc api errors

--*/
DWORD
RemoteRasPortGetInfo(
    HANDLE hConnection,
        HPORT porthandle,
        PBYTE buffer,
        PDWORD pSize)
{
        DWORD   dwStatus;
        WORD    wSize;
        RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

    ASSERT(VERSION_40 == pRasRpcConnection->dwVersion);

#endif

        RpcTryExcept
        {
            wSize = (WORD) *pSize;

                dwStatus = RasRpcPortGetInfo(
                    pRasRpcConnection->hRpcBinding,
                    HandleToUlong(porthandle),
                    buffer,
                    &wSize);

                *pSize = (DWORD) wSize;
        }
        RasRpcCatchException(&dwStatus)
        {
                dwStatus = RpcExceptionCode();
        }
        RpcEndExcept

        return dwStatus;
}

//
// End of remoted versions of Rasman Dll apis
//----------------------------------------------------


/*++

Routine Description:

    This api gets the Installed protocols in the remote
    server. This api should not be called if the server
    is local.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api. This cannot
                  be NULL.

Return Value:

    Rpc api errors

--*/
DWORD
RemoteGetInstalledProtocols(
    HANDLE hConnection
    )
{
    DWORD dwStatus;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

#endif

    RpcTryExcept
    {
        dwStatus = RasRpcGetInstalledProtocols(
                    pRasRpcConnection->hRpcBinding
                    );
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


/*++

Routine Description:

    This api gets the Installed protocols in the remote
    server. This api should not be called if the server
    is local.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api. This cannot
                  be NULL.

    fRouter - indicates return protocols installed over
              which routing is allowed

    fRasCli - indicates return protocols installed over
              which DialOut is allowed

    fRasSrv - indicates return protocols installed over
              which DialIn is allowed


Return Value:

    Rpc api errors

--*/
DWORD
RemoteGetInstalledProtocolsEx(
    HANDLE hConnection,
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv
    )
{
    DWORD dwStatus;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

#endif

    if ( VERSION_40 == pRasRpcConnection->dwVersion )
    {
        //
        // If the server we are talking to is a
        // 4.0 server call the old api and bail.
        //
        dwStatus = RemoteGetInstalledProtocols(hConnection);

        goto done;
    }

    RpcTryExcept
    {
        dwStatus = RasRpcGetInstalledProtocolsEx(
                    pRasRpcConnection->hRpcBinding,
                    fRouter,
                    fRasCli,
                    fRasSrv);
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

done:
    return dwStatus;
}

/*++

Routine Description:

    This api gets the System Directory of the remote
    server. This api should not be called if the server
    is local.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api. This cannot
                  be NULL.

    lpBuffer - same as the first parameter of the
               GetSystemDirectory api

    uSize - same as the second paramter of the
            GetSystemDirectory api


Return Value:

    Rpc api errors

--*/
UINT WINAPI
RemoteGetSystemDirectory(
    HANDLE hConnection,
    LPTSTR lpBuffer,
    UINT uSize
    )
{
    DWORD dwStatus;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

#endif

    RpcTryExcept
    {
        dwStatus = RasRpcGetSystemDirectory(
                    pRasRpcConnection->hRpcBinding,
                    lpBuffer,
                    uSize);
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}

/*++

Routine Description:

    This api gets the System directory of the remote
    server.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api.

    lpBuffer - same as the first parameter of the
               GetSystemDirectory api

    uSize - same as the second paramter of the
            GetSystemDirectory api


Return Value:

    Rpc api errors

--*/
UINT WINAPI
RasGetSystemDirectory(
    HANDLE hConnection,
    LPTSTR lpBuffer,
    UINT uSize
    )
{
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if(     NULL == pRasRpcConnection
        ||  pRasRpcConnection->fLocal)
    {
        //
        // Local Server
        //
        return GetSystemDirectory(lpBuffer,
                                  uSize);
    }
    else
    {
        return RemoteGetSystemDirectory(
                pRasRpcConnection,
                lpBuffer,
                uSize);
    }
}

/*++

Routine Description:

    This api gets the User Preferences set on the remote
    server. This routine should not be called if for a
    local server.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api.

    lpBuffer - same as the first parameter of the
               GetSystemDirectory api

    uSize - same as the second paramter of the
            GetSystemDirectory api


Return Value:

    Rpc api errors

--*/
DWORD
RemoteGetUserPreferences(
    HANDLE hConnection,
    OUT PBUSER* pPbuser,
    IN DWORD dwMode
    )
{
    DWORD dwStatus;

    RASRPC_PBUSER pbuser;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

#endif

    RtlZeroMemory(&pbuser, sizeof (RASRPC_PBUSER));

    RpcTryExcept
    {
        dwStatus = RasRpcGetUserPreferences(
                    pRasRpcConnection->hRpcBinding,
                    &pbuser,
                    dwMode);
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if (dwStatus)
    {
        return dwStatus;
    }

    //
    // Convert RPC format to RAS format.
    //
    return RpcToRasPbuser(pPbuser, &pbuser);
}


//---------------------------------------------------
// The following are remoted version of apis exported
// from rasapi32.dll.
//

/*++

Routine Description:

    This api is a remoted version of the RasDeleteEntry
    win32 api.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api.

    lpszPhonebook - Same as the first argument of the
                    RasDeleteEntry win32 api

    lpszEntry - same as the second argument of the
                RasDeleteEntry win32 api.

Return Value:

    Rpc api errors

--*/
DWORD APIENTRY
RemoteRasDeleteEntry(
    HANDLE hConnection,
    LPTSTR lpszPhonebook,
    LPTSTR lpszEntry
    )
{
    DWORD dwStatus;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

#endif

    RpcTryExcept
    {
        dwStatus = RasRpcDeleteEntry(
                    pRasRpcConnection->hRpcBinding,
                    lpszPhonebook,
                    lpszEntry);
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}

/*++

Routine Description:

    This api is a remoted version of the RasEnumConnections
    win32 api.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api.

    lpRasConn - Same as the first argument of the
                    RasEnumConnections win32 api

    lpdwcbRasConn - same as the second argument of the
                    RasEnumConnections win32 api.

    lpdwcRasConn - same as the third arguments of the
                   RasEnumConnections win32 api.

Return Value:

    Rpc api errors

--*/
DWORD APIENTRY
RemoteRasEnumConnections(
    HANDLE hConnection,
    LPRASCONN lpRasConn,
    LPDWORD lpdwcbRasConn,
    LPDWORD lpdwcRasConn
    )
{

    DWORD dwStatus;
    DWORD dwcbBufSize = *lpdwcbRasConn;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

#endif

    RpcTryExcept
    {
        dwStatus = RasRpcEnumConnections(
                    pRasRpcConnection->hRpcBinding,
                    (LPBYTE)lpRasConn,
                                lpdwcbRasConn,
                                lpdwcRasConn,
                                dwcbBufSize);
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}

/*++

Routine Description:

    This api is a remoted version of the RasGetCountryInfo
    win32 api.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api.

    lpRasCountryInfo - Same as the first argument of the
                       RasGetCountryInfo win32 api

    lpdwcbRasCountryInfo - same as the second argument of the
                           RasGetCountryInfo win32 api.

Return Value:

    Rpc api errors

--*/
DWORD APIENTRY
RemoteRasGetCountryInfo(
    HANDLE hConnection,
    LPRASCTRYINFO lpRasCountryInfo,
    LPDWORD lpdwcbRasCountryInfo
    )
{
    DWORD dwStatus;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

#endif

    RpcTryExcept
    {
        dwStatus = RasRpcGetCountryInfo(
                    pRasRpcConnection->hRpcBinding,
                    (LPBYTE)lpRasCountryInfo,
                    lpdwcbRasCountryInfo);
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


/*++

Routine Description:

    This api is a remoted version of the RasGetErrorString
    win32 api.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api.

    uErrorValue - Same as the first argument of the
                  RasGetErrorString win32 api

    lpszBuf - same as the second argument of the
              RasGetErrorString win32 api.

    cbBuf - same as the third argument of the
            RasGetErrorString win32 api

Return Value:

    Rpc api errors

--*/
DWORD APIENTRY
RemoteRasGetErrorString(
    HANDLE hConnection,
    UINT uErrorValue,
    LPTSTR lpszBuf,
    DWORD cbBuf
    )
{
    DWORD dwStatus;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

#endif

    RpcTryExcept
    {
        dwStatus = RasRpcGetErrorString(
                    pRasRpcConnection->hRpcBinding,
                    uErrorValue,
                    lpszBuf,
                    cbBuf);
    }
    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}

//
// End of remoted apis corresponding to apis in rasapi32.dll
//----------------------------------------------------------

/*++

Routine Description:

    This api is a remoted version of the RasGetErrorString
    win32 api.

Arguments:

    hConnection - Handle which was obtained with the
                  RasServerConnect api.

    pPbuser - PBUSER *

    dwMode

Return Value:

    Rpc api errors

--*/
DWORD
RemoteSetUserPreferences(
    HANDLE hConnection,
    OUT PBUSER* pPbuser,
    IN DWORD dwMode
    )
{
    DWORD dwStatus;
    RASRPC_PBUSER pbuser;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

#if DBG

    ASSERT(NULL != pRasRpcConnection);

    ASSERT(NULL != pRasRpcConnection->hRpcBinding);

#endif

    //
    // Convert the RAS format to RPC format.
    //
    dwStatus = RasToRpcPbuser(&pbuser, pPbuser);

    if (dwStatus)
    {
        return dwStatus;
    }

    RpcTryExcept
    {
        dwStatus = RasRpcSetUserPreferences(
                    pRasRpcConnection->hRpcBinding,
                    &pbuser,
                    dwMode);
    }

    RasRpcCatchException(&dwStatus)
    {
        dwStatus = RpcExceptionCode();
    }

    RpcEndExcept

    return dwStatus;
}

VOID
UnloadMpradminDll(
    void )

/*++

Routine Description

    Unload the MPRAPI.DLL library and its entrypoints

Arguments

Return Value

--*/

{
    if (g_hMpradminDll)
    {
        HINSTANCE h;

        g_pMprAdminInterfaceCreate          = NULL;
        g_pMprAdminInterfaceDelete          = NULL;
        g_pMprAdminInterfaceGetCredentials  = NULL;
        g_pMprAdminInterfaceGetCredentialsEx  = NULL;
        g_pMprAdminInterfaceSetCredentials  = NULL;
        g_pMprAdminInterfaceSetCredentialsEx = NULL;
        g_pMprAdminBufferFree               = NULL;
        g_pMprAdminInterfaceTransportSetInfo = NULL;
        g_pMprAdminServerConnect            = NULL;
        g_pMprAdminServerDisconnect         = NULL;
        g_pRasAdminServerConnect            = NULL;
        g_pRasAdminServerDisconnect         = NULL;
        g_pRasAdminBufferFree               = NULL;
        g_pRasAdminConnectionEnum           = NULL;
        g_pRasAdminConnectionGetInfo        = NULL;
        g_pRasAdminPortEnum                 = NULL;
        g_pRasAdminPortGetInfo              = NULL;
        g_pRasAdminPortDisconnect           = NULL;
        g_pRasAdminUserSetInfo              = NULL;
        g_pMprConfigBufferFree              = NULL;
        g_pMprConfigServerConnect           = NULL;
        g_pMprConfigServerDisconnect        = NULL;
        g_pMprConfigTransportGetInfo        = NULL;
        g_pMprConfigTransportSetInfo        = NULL;
        g_pMprConfigTransportGetHandle      = NULL;
        g_pMprConfigInterfaceCreate         = NULL;
        g_pMprConfigInterfaceDelete         = NULL;
        g_pMprConfigInterfaceGetHandle      = NULL;
        g_pMprConfigInterfaceEnum           = NULL;
        g_pMprConfigInterfaceTransportAdd   = NULL;
        g_pMprConfigInterfaceTransportGetInfo = NULL;
        g_pMprConfigInterfaceTransportSetInfo = NULL;
        g_pMprConfigInterfaceTransportGetHandle = NULL;
        g_pMprInfoCreate                    = NULL;
        g_pMprInfoDelete                    = NULL;
        g_pMprInfoDuplicate                 = NULL;
        g_pMprInfoBlockAdd                  = NULL;
        g_pMprInfoBlockRemove               = NULL;
        g_pMprInfoBlockSet                  = NULL;
        g_pMprInfoBlockFind                 = NULL;

        h = g_hMpradminDll;
        g_hMpradminDll = NULL;
        FreeLibrary(h);
    }
}

VOID
UnloadRasapi32Dll(
    void )

/*++

Routine Description

    Unload the RASAPI32.DLL library and it's entrypoints.

Arguments

Return Value

--*/

{
    if (g_hRasapi32Dll)
    {
        HINSTANCE h;

        g_pRasConnectionNotification    = NULL;
        g_pRasDeleteEntry               = NULL;
        g_pRasDial                      = NULL;
        g_pRasEnumEntries               = NULL;
        g_pRasEnumConnections           = NULL;
        g_pRasGetConnectStatus          = NULL;
        g_pRasGetConnectResponse        = NULL;
        g_pRasGetCredentials            = NULL;
        g_pRasGetErrorString            = NULL;
        g_pRasHangUp                    = NULL;
        g_pRasGetAutodialEnable         = NULL;
        g_pRasGetAutodialParam          = NULL;
        g_pRasGetProjectionInfo         = NULL;
        g_pRasSetAutodialEnable         = NULL;
        g_pRasSetAutodialParam          = NULL;
        g_pRasGetSubEntryHandle         = NULL;
        g_pRasGetHport                  = NULL;
        g_pRasSetCredentials            = NULL;
        g_pRasSetOldPassword            = NULL;
        g_pRasGetCountryInfo            = NULL;
        g_pRasValidateEntryName         = NULL;

        h = g_hRasapi32Dll;
        g_hRasapi32Dll = NULL;
        FreeLibrary( h );
    }
}


VOID
UnloadRasdlgDll(
    void )

/*++

Routine Description

    Unload the RASDLG.DLL library and it's entrypoints.

Arguments

Return Value

--*/

{
    if (g_hRasdlgDll)
    {
        HINSTANCE h;

        g_pRasPhonebookDlg  = NULL;
        g_pRasEntryDlg      = NULL;
        g_pRouterEntryDlg   = NULL;
        g_pRasDialDlg       = NULL;

        h = g_hRasdlgDll;
        g_hRasdlgDll = NULL;
        FreeLibrary( h );
    }
}


VOID
UnloadRasmanDll(
    void )

/*++

Routine Description

    Unload the RASMAN.DLL library and it's entrypoints.

Arguments

Return Value

--*/

{
    if (g_hRasmanDll)
    {
        HINSTANCE h;

        if ( g_hBinding )
        {
            g_pRasRpcDisconnect( &g_hBinding );

            g_hBinding = NULL;
        }

        g_pRasPortClearStatistics   = NULL;
        g_pRasDeviceEnum            = NULL;
        g_pRasDeviceGetInfo         = NULL;
        g_pRasFreeBuffer            = NULL;
        g_pRasGetBuffer             = NULL;
        g_pRasPortGetFramingEx      = NULL;
        g_pRasGetInfo               = NULL;
        g_pRasGetNdiswanDriverCaps  = NULL;
        g_pRasInitialize            = NULL;
        g_pRasPortCancelReceive     = NULL;
        g_pRasPortEnum              = NULL;
        g_pRasPortGetInfo           = NULL;
        g_pRasPortGetStatistics     = NULL;
        g_pRasPortReceive           = NULL;
        g_pRasPortReceiveEx         = NULL;
        g_pRasPortSend              = NULL;
        g_pRasPortGetBundle         = NULL;
        g_pRasGetDevConfig          = NULL;
        g_pRasGetDevConfigEx        = NULL;
        g_pRasSetDevConfig          = NULL;
        g_pRasPortOpen              = NULL;
        g_pRasPortRegisterSlip      = NULL;
        g_pRasAllocateRoute         = NULL;
        g_pRasActivateRoute         = NULL;
        g_pRasActivateRouteEx       = NULL;
        g_pRasDeviceSetInfo         = NULL;
        g_pRasDeviceConnect         = NULL;
        g_pRasPortSetInfo           = NULL;
        g_pRasPortClose             = NULL;
        g_pRasPortListen            = NULL;
        g_pRasPortConnectComplete   = NULL;
        g_pRasPortDisconnect        = NULL;
        g_pRasRequestNotification   = NULL;
        g_pRasPortEnumProtocols     = NULL;
        g_pRasPortSetFraming        = NULL;
        g_pRasPortSetFramingEx      = NULL;
        g_pRasSetCachedCredentials  = NULL;
        g_pRasGetDialParams         = NULL;
        g_pRasSetDialParams         = NULL;
        g_pRasCreateConnection      = NULL;
        g_pRasDestroyConnection     = NULL;
        g_pRasConnectionEnum        = NULL;
        g_pRasAddConnectionPort     = NULL;
        g_pRasEnumConnectionPorts   = NULL;
        g_pRasGetConnectionParams   = NULL;
        g_pRasSetConnectionParams   = NULL;
        g_pRasGetConnectionUserData = NULL;
        g_pRasSetConnectionUserData = NULL;
        g_pRasGetPortUserData       = NULL;
        g_pRasSetPortUserData       = NULL;
        g_pRasAddNotification       = NULL;
        g_pRasSignalNewConnection   = NULL;
        g_pRasPppStop               = NULL;
        g_pRasPppCallback           = NULL;
        g_pRasPppChangePassword     = NULL;
        g_pRasPppGetInfo            = NULL;
        g_pRasPppRetry              = NULL;
        g_pRasPppStart              = NULL;
        g_pRasSetIoCompletionPort   = NULL;
        g_pRasSetRasdialInfo        = NULL;
        g_pRasRpcConnect            = NULL;
        g_pRasRpcDisconnect         = NULL;
        g_pRasNumPortOpen           = NULL;

        h = g_hRasmanDll;
        g_hRasmanDll = NULL;
        FreeLibrary( h );
    }
}


DWORD
UnloadRasRpcDll(
    void
    )
{
    DWORD dwErr = 0;

    if ( g_hRasapi32Dll == NULL )
    {
        g_pRasEnumConnections   = NULL;
        g_pRasDeleteEntry       = NULL;
        g_pRasGetErrorString    = NULL;
        g_pRasGetCountryInfo    = NULL;
    }

    g_pGetInstalledProtocols    = GetInstalledProtocolsEx;
    g_pGetUserPreferences       = GetUserPreferences;
    g_pSetUserPreferences       = SetUserPreferences;
    g_pGetSystemDirectory       = RasGetSystemDirectory;

    if ( VERSION_40 == g_Version )
    {
        if ( g_hRasmanDll == NULL )
        {
            dwErr = E_FAIL;
            goto done;
        }

        //
        // rasman dll should always be loaded
        //
        g_pRasPortEnum = (PRASPORTENUM) GetProcAddress(
                                        g_hRasmanDll,
                                        "RasPortEnum"
                                        );

        g_pRasDeviceEnum = (PRASDEVICEENUM) GetProcAddress(
                                            g_hRasmanDll,
                                            "RasDeviceEnum"
                                            );

        g_pRasGetDevConfig = (PRASGETDEVCONFIG) GetProcAddress(
                                            g_hRasmanDll,
                                            "RasGetDevConfig"
                                            );

        g_pRasPortGetInfo = (PRASPORTGETINFO) GetProcAddress(
                                                g_hRasmanDll,
                                                "RasPortGetInfo"
                                                );

    }

    g_Version = VERSION_501;

    //
    // Release the binding resources.
    //
    g_pRasRpcDisconnect ( &g_hBinding );

    g_hBinding = NULL;

    if ( g_fRasapi32PreviouslyLoaded )
    {
        dwErr = LoadRasapi32Dll();
        goto done;
    }

    if ( g_fRasmanPreviouslyLoaded )
    {
        //
        // restore connection to local server
        //
        if ( g_pRasRpcConnect )
        {
            dwErr = g_pRasRpcConnect ( NULL, g_hBinding );

            goto done;
        }
    }

done:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\inetcfgp.c ===
/*
    File    inetcfgp.h

    Private helper functions for dealing with inetcfg.

    Paul Mayfield, 1/5/98 (implementation by shaunco)
*/

#include "inetcfgp.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateAndInitializeINetCfg
//
//  Purpose:    Cocreate and initialize the root INetCfg object.  This will
//              optionally initialize COM for the caller too.
//
//  Arguments:
//      fInitCom        [in out]    TRUE to call CoInitialize before creating.
//      ppnc            [out]       The returned INetCfg object.
//      fGetWriteLock   [in]        TRUE if a writable INetCfg is needed
//      cmsTimeout      [in]        See INetCfg::AcquireWriteLock
//      szwClientDesc   [in]        See INetCfg::AcquireWriteLock
//      ppszwClientDesc [out]       See INetCfg::AcquireWriteLock
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:
//
HRESULT APIENTRY
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    LPWSTR*     ppszwClientDesc)
{
    HRESULT hr              = S_OK;
    BOOL    fCoUninitialize = *pfInitCom;

    // Initialize the output parameters.
    *ppnc = NULL;

    if (ppszwClientDesc)
    {
        *ppszwClientDesc = NULL;
    }

    // Initialize COM if the caller requested.
    if (*pfInitCom)
    {
        //For whistler bug 398715       gangz
        //
        hr = CoInitializeEx (NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

        if( RPC_E_CHANGED_MODE == hr )
        {
            hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
        }

        if ( SUCCEEDED(hr) )
        {
            hr = S_OK;
            *pfInitCom = TRUE;
            fCoUninitialize = TRUE;
        }
        else
        {
            *pfInitCom = FALSE;
            fCoUninitialize = FALSE;
        }
        
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance (&CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                               &IID_INetCfg, (void**)&pnc);
        if (SUCCEEDED(hr))
        {
            INetCfgLock* pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = INetCfg_QueryInterface(pnc, &IID_INetCfgLock,
                                         (void**)&pnclock);
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = INetCfgLock_AcquireWriteLock(pnclock, cmsTimeout,
                                szwClientDesc, ppszwClientDesc);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = INetCfg_Initialize (pnc, NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    IUnknown_AddRef (pnc);
                }
                else
                {
                    if (pnclock)
                    {
                        INetCfgLock_ReleaseWriteLock(pnclock);
                    }
                }
                // Transfer reference to caller.
            }
            ReleaseObj (pnclock);

            ReleaseObj (pnc);
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && fCoUninitialize)
        {
            CoUninitialize ();
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndUnlockINetCfg
//
//  Purpose:    Uninitializes and unlocks the INetCfg object
//
//  Arguments:
//      pnc [in]    INetCfg to uninitialize and unlock
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT APIENTRY
HrUninitializeAndUnlockINetCfg(
    INetCfg*    pnc)
{
    HRESULT hr = INetCfg_Uninitialize (pnc);
    if (SUCCEEDED(hr))
    {
        INetCfgLock* pnclock;

        // Get the locking interface
        hr = INetCfg_QueryInterface (pnc, &IID_INetCfgLock, (void**)&pnclock);
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = INetCfgLock_ReleaseWriteLock (pnclock);

            ReleaseObj (pnclock);
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
HRESULT APIENTRY
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock)
{
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg (pnc);
    }
    else
    {
        hr = INetCfg_Uninitialize (pnc);
    }

    ReleaseObj (pnc);

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnumComponentsInClasses
//
//  Purpose:    Given an array of class guids, return all of the components
//              from INetCfg that belong to those classes in one, unified,
//              array.
//
//  Arguments:
//      pNetCfg      [in]
//      cpguidClass  [in]
//      apguidClass  [in]
//      celt         [in]
//      rgelt        [out]
//      pceltFetched [out]
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   12 Dec 1997
//
//  Notes:
//
HRESULT APIENTRY
HrEnumComponentsInClasses (
    INetCfg*            pNetCfg,
    ULONG               cpguidClass,
    GUID**              apguidClass,
    ULONG               celt,
    INetCfgComponent**  rgelt,
    ULONG*              pceltFetched)
{
    ULONG   iGuid;
    HRESULT hr = S_OK;

    // Initialize the output paramters
    //
    *pceltFetched = 0;

    for (iGuid = 0; iGuid < cpguidClass; iGuid++)
    {
        // Get the INetCfgClass object this guid represents.
        //
        INetCfgClass* pClass;
        hr = INetCfg_QueryNetCfgClass (pNetCfg, apguidClass[iGuid],
                        &IID_INetCfgClass, (void**)&pClass);
        if (SUCCEEDED(hr))
        {
            // Get the component enumerator for this class.
            //
            IEnumNetCfgComponent* pEnum;
            hr = INetCfgClass_EnumComponents (pClass, &pEnum);
            if (SUCCEEDED(hr))
            {
                // Enumerate the components.
                //
                ULONG celtFetched;
                hr = IEnumNetCfgComponent_Next (pEnum, celt,
                            rgelt, &celtFetched);
                if (SUCCEEDED(hr))
                {
                    celt  -= celtFetched;
                    rgelt += celtFetched;
                    *pceltFetched += celtFetched;
                }
                ReleaseObj (pEnum);
            }
            ReleaseObj (pClass);
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseObj
//
//  Purpose:    Makes it easier to call punk->Release.  Also allows NULL
//              input.
//
//  Arguments:
//      punk [in]   IUnknown pointer to release.
//
//  Returns:    punk->Release if punk is non-NULL, zero otherwise.
//
//  Author:     shaunco   13 Dec 1997
//
//  Notes:
//
ULONG APIENTRY
ReleaseObj (
    void* punk)
{
    return (punk) ? IUnknown_Release ((IUnknown*)punk) : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateNetConnectionUtilities
//
//  Purpose:    Retrieve an interface to the Net Connection Ui Utilities
//
//  Arguments:
//      ppncuu [out]   The returned INetConnectionUiUtilities interface.
//
//  Returns:    S_OK and SUCCESS, a HRESULT error on failure
//
//  Author:     scottbri    15 Oct 1998
//
//  Notes:
//
HRESULT APIENTRY
HrCreateNetConnectionUtilities(INetConnectionUiUtilities ** ppncuu)
{
    HRESULT hr;

    hr = CoCreateInstance (&CLSID_NetConnectionUiUtilities, NULL,
                           CLSCTX_INPROC_SERVER,
                           &IID_INetConnectionUiUtilities, (void**)ppncuu);
    return hr;
}


//To get the firewall's group policy value  for bug 342810 328673
//
BOOL
IsGPAEnableFirewall(
    void)
{
    BOOL fEnableFirewall = FALSE;
    BOOL fComInitialized = FALSE;
    BOOL fCleanupOle = TRUE;

    HRESULT hr;
    INetConnectionUiUtilities * pNetConUtilities = NULL;        

    
    hr = CoInitializeEx(NULL, 
                COINIT_MULTITHREADED|COINIT_DISABLE_OLE1DDE);

    if ( RPC_E_CHANGED_MODE == hr )
    {
        hr = CoInitializeEx (NULL, 
                COINIT_APARTMENTTHREADED |COINIT_DISABLE_OLE1DDE);
    }
        
    if (FAILED(hr)) 
    {
        fCleanupOle = FALSE;
        fComInitialized = FALSE;
     }
     else
     {
        fCleanupOle = TRUE;
        fComInitialized = TRUE;
     }
        
    if ( fComInitialized )
    {
        hr = HrCreateNetConnectionUtilities(&pNetConUtilities);
        if ( SUCCEEDED(hr))
        {
            fEnableFirewall =
            INetConnectionUiUtilities_UserHasPermission(
                         pNetConUtilities, NCPERM_PersonalFirewallConfig );

            INetConnectionUiUtilities_Release(pNetConUtilities);
        }

        if (fCleanupOle)
        {
            CoUninitialize();
         }
    }

    return fEnableFirewall;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\nnetcfg.cpp ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  05/29/97 Rao Salapaka  Created
//
//
//  Description: All Initialization code for rasman component lives here.
//
//****************************************************************************

#ifndef UNICODE
#define UNICODE
#endif

#ifdef _UNICODE
#define _UNICODE
#endif

extern "C"
{
#include <nt.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
//#include <comdef.h>
#include <ncnetcfg.h>
#include <rtutils.h>
#include <initguid.h>
#include <devguid.h>
#include <netcfg_i.c>


/* Bits returned by GetInstalledProtocols.
*/
#define NP_Nbf 0x1
#define NP_Ipx 0x2
#define NP_Ip  0x4

extern "C"
{
	DWORD dwGetInstalledProtocols(DWORD *pdwInstalledProtocols,
	                              BOOL fRouter,
	                              BOOL fRasCli,
	                              BOOL fRasSrv);
}

DWORD
dwGetInstalledProtocols(DWORD   *pdwInstalledProtocols,
                        BOOL    fRouter,
                        BOOL    fRasCli,
                        BOOL    fRasSrv )
{
    HRESULT             hr                  = S_OK;
    INetCfg             *pINetCfg           = NULL;
    INetCfgComponent    *pINetCfgComp       = NULL;
    INetCfgComponent    *pINetCfgRasCli     = NULL;
    INetCfgComponent    *pINetCfgRasSrv     = NULL;
    INetCfgComponent    *pINetCfgRasRtr     = NULL;
    DWORD               dwCountTries        = 0;


    *pdwInstalledProtocols = 0;

    do
    {

        hr = HrCreateAndInitializeINetCfg( TRUE, &pINetCfg );


        if ( S_OK == hr )
            break;

        if ( NETCFG_E_IN_USE != hr )
            goto done;

        Sleep ( 5000 );

        dwCountTries ++;
            
    } while (   NETCFG_E_IN_USE == hr
            &&  dwCountTries < 6);

    if ( hr )
        goto done;

    //
    //  Get RasClient component
    //
    if ( FAILED( hr = HrFindComponent(pINetCfg,
                                      GUID_DEVCLASS_NETSERVICE,
                                      c_szInfId_MS_RasCli,
                                      &pINetCfgRasCli) ) )
        goto done;


    //
    // Get RasSrv component
    //
    if ( FAILED( hr = HrFindComponent(pINetCfg,
                                      GUID_DEVCLASS_NETSERVICE,
                                      c_szInfId_MS_RasSrv,
                                      &pINetCfgRasSrv ) ) )
        goto done;

    //
    // Get RasRtr component
    //
    if ( FAILED ( hr = HrFindComponent ( pINetCfg,
                                        GUID_DEVCLASS_NETSERVICE,
                                        c_szInfId_MS_RasRtr,
                                        &pINetCfgRasRtr ) ) )
        goto done;                                        

    //
    // Bail if neither DUN Client nor Dial Up Server is installed
    //
    if (    !pINetCfgRasCli
        &&  !pINetCfgRasSrv
        &&  !pINetCfgRasRtr)
    {
        hr = E_FAIL;
        goto done;
    }
    
    //
    // Get Nbf component
    //
    if (FAILED (hr = HrFindComponent(pINetCfg,
                                     GUID_DEVCLASS_NETTRANS,
                                     c_szInfId_MS_NetBEUI,
                                     &pINetCfgComp)))
        goto done;

    if (pINetCfgComp)
    {
        if (    (   fRasCli
                &&  pINetCfgRasCli 
                &&  ( hr = pINetCfgRasCli->IsBoundTo( pINetCfgComp ) ) == S_OK )
            ||  (   fRasSrv
                &&  pINetCfgRasSrv
                &&  ( hr = pINetCfgRasSrv->IsBoundTo( pINetCfgComp ) ) == S_OK )
            ||  (   fRouter
                &&  pINetCfgRasRtr
                &&  ( hr = pINetCfgRasRtr->IsBoundTo( pINetCfgComp ) ) == S_OK ) )
                
                *pdwInstalledProtocols |= NP_Nbf;
                
         ReleaseObj(pINetCfgComp);
         pINetCfgComp = NULL;
    }

    //
    // Get TcpIp component
    //
    if (FAILED (hr = HrFindComponent(pINetCfg,
                                     GUID_DEVCLASS_NETTRANS,
                                     c_szInfId_MS_TCPIP,
                                     &pINetCfgComp)))
        goto done;

    if (pINetCfgComp)
    {
        if (    (   fRasCli
                &&  pINetCfgRasCli 
                &&  ( hr = pINetCfgRasCli->IsBoundTo( pINetCfgComp ) ) == S_OK )
            ||  (   fRasSrv
                &&  pINetCfgRasSrv
                &&  ( hr = pINetCfgRasSrv->IsBoundTo( pINetCfgComp ) ) == S_OK )
            ||  (   fRouter
                &&  pINetCfgRasRtr
                &&  ( hr = pINetCfgRasRtr->IsBoundTo( pINetCfgComp ) ) == S_OK ) )
                
                *pdwInstalledProtocols |= NP_Ip;
                
        ReleaseObj (pINetCfgComp);
        pINetCfgComp = NULL;
    }
            

    //
    // Get NWIpx component
    //
    if (FAILED( hr = HrFindComponent(pINetCfg,
                                     GUID_DEVCLASS_NETTRANS,
                                     c_szInfId_MS_NWIPX,
                                     &pINetCfgComp)))
        goto done;

    if (pINetCfgComp)
    {
        if (    (   fRasCli
                &&  pINetCfgRasCli 
                &&  ( hr = pINetCfgRasCli->IsBoundTo( pINetCfgComp ) ) == S_OK )
            ||  (   fRasSrv
                &&  pINetCfgRasSrv
                &&  ( hr = pINetCfgRasSrv->IsBoundTo( pINetCfgComp ) ) == S_OK )
            ||  (   fRouter
                &&  pINetCfgRasRtr
                &&  ( hr = pINetCfgRasSrv->IsBoundTo( pINetCfgComp ) ) == S_OK ) )
                
                *pdwInstalledProtocols |= NP_Ipx;
                
        ReleaseObj (pINetCfgComp);
        pINetCfgComp = NULL;
    }

done:
    ReleaseObj (pINetCfgRasSrv);
    ReleaseObj (pINetCfgRasCli);
    ReleaseObj (pINetCfgRasRtr);

    if (pINetCfg)
    {
        HrUninitializeAndReleaseINetCfg( TRUE, pINetCfg);
    }        

    if (SUCCEEDED (hr))
        hr = S_OK;

    return HRESULT_CODE( hr );        

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\eapcfg.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// eapcfg.c
// EAP package utility library
//
// These utility routines wrap the third-party EAP authentication
// configuration information written to the registry by third-party EAP
// security package providers.
//
// 11/25/97 Steve Cobb
//


#include <windows.h>
#include <stdlib.h>
#include <debug.h>
#include <nouiutil.h>
#include <raseapif.h>
#include <ole2.h>

// EAP configuration registry definitions.
//
#define REGKEY_Eap TEXT("System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP")
#define REGVAL_szFriendlyName TEXT("FriendlyName")
#define REGVAL_szConfigDll    TEXT("ConfigUIPath")
#define REGVAL_szIdentityDll  TEXT("IdentityPath")
#define REGVAL_fRequirePwd    TEXT("InvokePasswordDialog")
#define REGVAL_fRequireUser   TEXT("InvokeUsernameDialog")
#define REGVAL_pData          TEXT("ConfigData")
#define REGVAL_fForceConfig   TEXT("RequireConfigUI")
#define REGVAL_fMppeSupported TEXT("MPPEEncryptionSupported")


//-----------------------------------------------------------------------------
// EAP configuration utilitiy routines (alphabetically)
//-----------------------------------------------------------------------------

DTLNODE*
CreateEapcfgNode(
    void )

    // Returns a created, empty EAPCFG descriptor node, or NULL on error.
    //
{
    DTLNODE* pNode;
    EAPCFG* pEapcfg;

    pNode = DtlCreateSizedNode( sizeof(EAPCFG), 0L );
    if (pNode)
    {
        pEapcfg = (EAPCFG* )DtlGetData( pNode );
        ASSERT( pEapcfg );

        pEapcfg->dwKey = (DWORD )-1;
        pEapcfg->pszConfigDll = NULL;
        pEapcfg->pszIdentityDll = NULL;
        pEapcfg->dwStdCredentialFlags = 0;
        pEapcfg->fProvidesMppeKeys = FALSE;
        pEapcfg->fForceConfig = FALSE;
        pEapcfg->pData = NULL;
        pEapcfg->cbData = 0;
        pEapcfg->fConfigDllCalled = FALSE;
    }

    return pNode;
}


VOID
DestroyEapcfgNode(
    IN OUT DTLNODE* pNode )

    // Release resources associated with EAPCFG node 'pNode'.  See
    // DtlDestroyList.
    //
{
    EAPCFG* pEapcfg;

    ASSERT( pNode );
    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );

    Free0( pEapcfg->pszConfigDll );
    Free0( pEapcfg->pszIdentityDll );
    Free0( pEapcfg->pData );

    DtlDestroyNode( pNode );
}


DTLNODE*
EapcfgNodeFromKey(
    IN DTLLIST* pList,
    IN DWORD dwKey )

    // Returns the EAPCFG node in list 'pList' with EAP key value of 'dwKey'
    // or NULL if not found.
    //
{
    DTLNODE* pNode;

    for (pNode = DtlGetFirstNode( pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        EAPCFG* pEapcfg = (EAPCFG* )DtlGetData( pNode );
        ASSERT( pEapcfg );

        if (pEapcfg->dwKey == dwKey)
        {
            return pNode;
        }
    }

    return NULL;
}


DTLLIST*
ReadEapcfgList(
    IN TCHAR* pszMachine )

    // Returns the address of a created list of installed custom
    // authentication packages or NULL if none could be read.  On success, it
    // is caller's responsibility to eventually call DtlDestroyList on the
    // returned list.
    //
{
    DWORD dwErr;
    BOOL fOk = FALSE;
    DTLLIST* pList;
    DTLNODE* pNode;
    EAPCFG* pEapcfg;
    HKEY hkeyLM = NULL;
    HKEY hkeyEap = NULL;
    HKEY hkeyPackage = NULL;
    CHAR szEapType[ 11 + 1 ];
    TCHAR* psz;
    DWORD dw;
    DWORD cb;
    INT i;
    TCHAR* szCLSID;
    HRESULT hr;

    pList = DtlCreateList( 0L );
    if (!pList)
    {
        return NULL;
    }

    // Open the EAP key which contains a sub-key for each installed package.
    //
    dwErr = RegConnectRegistry( pszMachine, HKEY_LOCAL_MACHINE, &hkeyLM );

    if (dwErr != 0)
    {
        return pList;
    }

    dwErr = RegOpenKeyEx(
        hkeyLM, (LPCTSTR )REGKEY_Eap, 0, KEY_READ, &hkeyEap );

    RegCloseKey( hkeyLM );

    if (dwErr != 0)
    {
        return pList;
    }



    // Open each sub-key and extract the package definition from it's values.
    // Problems with opening individual sub-keys result in that node only
    // being discarded.
    //
    for (i = 0; TRUE; ++i)
    {
        cb = sizeof(szEapType);
        dwErr = RegEnumKeyExA(
            hkeyEap, i, szEapType, &cb, NULL, NULL, NULL, NULL );
        if (dwErr != 0)
        {
            // Includes "out of items", the normal loop termination.
            //
            break;
        }

        dwErr = RegOpenKeyExA(
            hkeyEap, szEapType, 0, KEY_READ, &hkeyPackage );
        if (dwErr != 0)
        {
            continue;
        }
        // For whistler bug 442519 and 442458      gangz
        // For LEAP, a  RolesSupported DWORD will be added, if it is set to 2, 
        // then we wont show it on the client side
        {
            DWORD dwRolesSupported = 0;

            GetRegDword( hkeyPackage, 
                        RAS_EAP_VALUENAME_ROLES_SUPPORTED, 
                        &dwRolesSupported);

        // This values is not configured, or equals 0 or 1, then go ahead 
        // and show it, or else wont show it
        // 0 means can be either Authenticator or Authenticatee
        // 1 means can ONLY be Authenticator, for LEAP, it is 1
        // 2 means can ONLY be Authenticatee
               
        if ( RAS_EAP_ROLE_AUTHENTICATOR & dwRolesSupported ) 
        {
            continue;
        }
        if ( RAS_EAP_ROLE_EXCLUDE_IN_EAP & dwRolesSupported )
        {
            continue;
        }
        //
        // We should not show PEAP in RAS Forever...
        // 
        if ( !strcmp ( szEapType, "25") )
        {
            continue;
        }
        if ( RAS_EAP_ROLE_DISABLED_IN_VPN_CLIENT & dwRolesSupported )
        {
            continue;
        }

        }

        do
        {
            pNode = CreateEapcfgNode();
            if (!pNode)
            {
                break;
            }

            pEapcfg = (EAPCFG* )DtlGetData( pNode );
            ASSERT( pEapcfg );

            // EAP type ID.
            //
            pEapcfg->dwKey = (LONG )atol( szEapType );

            // Friendly display name.
            //
            psz = NULL;
            dwErr = GetRegSz( hkeyPackage, REGVAL_szFriendlyName, &psz );
            if (dwErr != 0)
            {
                break;
            }
            if (!*psz)
            {
                Free( psz );
                psz = StrDupTFromA( szEapType );
                if (!psz)
                {
                    break;
                }
            }
            pEapcfg->pszFriendlyName = psz;

            // Configuration DLL path.
            //
            psz = NULL;
            dwErr = GetRegExpandSz( hkeyPackage, REGVAL_szConfigDll, &psz );
            if (dwErr != 0)
            {
                break;
            }
            if (*psz)
            {
                pEapcfg->pszConfigDll = psz;
            }
            else
            {
                Free( psz );
            }

            // Identity DLL path.
            //
            psz = NULL;
            dwErr = GetRegExpandSz( hkeyPackage, REGVAL_szIdentityDll, &psz );
            if (dwErr != 0)
            {
                break;
            }
            if (*psz)
            {
                pEapcfg->pszIdentityDll = psz;
            }
            else
            {
                Free( psz );
            }

            // Prompt user name
            //
            dw = 1;
            GetRegDword( hkeyPackage, REGVAL_fRequireUser, &dw );
            if (dw)
                pEapcfg->dwStdCredentialFlags |= EAPCFG_FLAG_RequireUsername;

            // Prompt password
            //
            dw = 0;
            GetRegDword( hkeyPackage, REGVAL_fRequirePwd, &dw );
            if (dw)
                pEapcfg->dwStdCredentialFlags |= EAPCFG_FLAG_RequirePassword;

            // MPPE encryption keys flag.
            //
            dw = 0;
            GetRegDword( hkeyPackage, REGVAL_fMppeSupported, &dw );
            pEapcfg->fProvidesMppeKeys = !!dw;

            // Force configuration API to run at least once.
            //
            dw = FALSE;
            GetRegDword( hkeyPackage, REGVAL_fForceConfig, &dw );
            pEapcfg->fForceConfig = !!dw;

            // Configuration blob.
            //
            GetRegBinary(
                hkeyPackage, REGVAL_pData,
                &pEapcfg->pData, &pEapcfg->cbData );

            // ConfigCLSID
            //
            dwErr = GetRegSz( hkeyPackage, RAS_EAP_VALUENAME_CONFIG_CLSID,
                        &szCLSID );
            if (dwErr != 0)
            {
                break;
            }

            // Ignore errors. Eg. EAP MD5-Challenge does not have a ConfigCLSID.
            //
            hr = CLSIDFromString( szCLSID, &( pEapcfg->guidConfigCLSID ) );
            Free( szCLSID );

            // Add the completed node to the list.
            //
            DtlAddNodeLast( pList, pNode );
            fOk = TRUE;
        }
        while (FALSE);

        if (!fOk && pNode)
        {
            DestroyEapcfgNode( pNode );
        }

        RegCloseKey( hkeyPackage );
    }

    RegCloseKey( hkeyEap );

    return pList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\intl.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    intl.c
//
// History:
//  Abolade Gbadegesin  Nov-14-1995     Created.
//
// Internationalized string routines
//============================================================================

#include <windows.h>

#include <nouiutil.h>


//----------------------------------------------------------------------------
// Function:    padultoa
// 
// This functions formats the specified unsigned integer
// into the specified string buffer, padding the buffer
// so that it is at least the specified width.
//
// It is assumed that the buffer is at least wide enough
// to contain the output, so this function does not truncate
// the conversion result to the length of the 'width' parameter.
//----------------------------------------------------------------------------

PTSTR padultoa(UINT val, PTSTR pszBuf, INT width) {
    TCHAR temp;
    PTSTR psz, zsp;

    psz = pszBuf;

    //
    // write the digits in reverse order
    //

    do {

        *psz++ = TEXT('0') + (val % 10);
        val /= 10;

    } while(val > 0);

    //
    // pad the string to the required width
    //

    zsp = pszBuf + width;
    while (psz < zsp) { *psz++ = TEXT('0'); }


    *psz-- = TEXT('\0');


    //
    // reverse the digits
    //

    for (zsp = pszBuf; zsp < psz; zsp++, psz--) {

        temp = *psz; *psz = *zsp; *zsp = temp;
    }

    //
    // return the result
    //

    return pszBuf;
}



// Function:    GetNumberString
//
// This function takes an integer and formats a string with the value
// represented by the number, grouping digits by powers of one-thousand

DWORD
GetNumberString(
    IN DWORD dwNumber,
    IN OUT PTSTR pszBuffer,
    IN OUT PDWORD pdwBufSize
    ) {

    static TCHAR szSep[4] = TEXT("");

    DWORD i, dwLength;
    TCHAR szDigits[12], *pszNumber;

    if (pdwBufSize == NULL) { return ERROR_INVALID_PARAMETER; }

    if (szSep[0] == TEXT('\0')) {
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, 4);
    }


    //
    // convert the number to a string without thousands-separators
    //

    padultoa(dwNumber, szDigits, 0);

    dwLength = lstrlen(szDigits);

    //
    // if the length of the string without separators is n,
    // then the length of the string with separators is n + (n - 1) / 3
    //

    i = dwLength;
    dwLength += (dwLength - 1) / 3;

    if (pszBuffer != NULL && dwLength < *pdwBufSize) {
        PTSTR pszsrc, pszdst;

        pszsrc = szDigits + i - 1; pszdst = pszBuffer + dwLength;

        *pszdst-- = TEXT('\0');

        while (TRUE) {
            if (i--) { *pszdst-- = *pszsrc--; } else { break; }
            if (i--) { *pszdst-- = *pszsrc--; } else { break; }
            if (i--) { *pszdst-- = *pszsrc--; } else { break; }
            if (i) { *pszdst-- = *szSep; } else { break; }
        }
    }

    *pdwBufSize = dwLength;

    return NO_ERROR;
}


//----------------------------------------------------------------------------
// Function:    GetDurationString
//
// This function takes a millisecond count and formats a string
// with the duration represented by the millisecond count.
// The caller may specify the resolution required by setting the flags field
//----------------------------------------------------------------------------

DWORD
GetDurationString(
    IN DWORD dwMilliseconds,
    IN DWORD dwFormatFlags,
    IN OUT PTSTR pszBuffer,
    IN OUT DWORD *pdwBufSize
    ) {

    static TCHAR szSep[4] = TEXT("");
    DWORD dwSize;
    TCHAR *psz, szOutput[64];

    if (pdwBufSize == NULL || (dwFormatFlags & GDSFLAG_All) == 0) {
        return ERROR_INVALID_PARAMETER;
    }


    if (szSep[0] == TEXT('\0')) {
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, szSep, 4);
    }


    //
    // concatenate the strings together
    //

    psz = szOutput;
    dwFormatFlags &= GDSFLAG_All;

    if (dwFormatFlags & GDSFLAG_Days) {

        padultoa(dwMilliseconds / (24 * 60 * 60 * 1000), psz, 0);
        dwMilliseconds %= (24 * 60 * 60 * 1000);

        if (dwFormatFlags &= ~GDSFLAG_Days) { lstrcat(psz, szSep); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & GDSFLAG_Hours) {

        padultoa(dwMilliseconds / (60 * 60 * 1000), psz, 2);
        dwMilliseconds %= (60 * 60 * 1000);

        if (dwFormatFlags &= ~GDSFLAG_Hours) { lstrcat(psz, szSep); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & GDSFLAG_Minutes) {

        padultoa(dwMilliseconds / (60 * 1000), psz, 2);
        dwMilliseconds %= (60 * 1000);

        if (dwFormatFlags &= ~GDSFLAG_Minutes) { lstrcat(psz, szSep); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & GDSFLAG_Seconds) {

        padultoa(dwMilliseconds / 1000, psz, 2);
        dwMilliseconds %= 1000;

        if (dwFormatFlags &= ~GDSFLAG_Seconds) { lstrcat(psz, szSep); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & GDSFLAG_Mseconds) {

        padultoa(dwMilliseconds, psz, 0);

        psz += lstrlen(psz);
    }

    dwSize = (DWORD) (psz - szOutput + 1);

    if (*pdwBufSize >= dwSize && pszBuffer != NULL) {
        lstrcpy(pszBuffer, szOutput);
    }

    *pdwBufSize = dwSize;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\mdm.c ===
/*
    File    mdm.cpp

    Library for dealing with and installing modems.

    Paul Mayfield, 5/20/98
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <netcfgx.h>
#include <netcon.h>
#include <setupapi.h>
#include <devguid.h>
#include <unimodem.h>
#include "mdm.h"

// 
// String definitions
//
const WCHAR pszNullModemId[]        = L"PNPC031";
const WCHAR pszNullModemInfFile[]   = L"mdmhayes.inf";
const WCHAR pszComPortRegKey[]      = L"HARDWARE\\DEVICEMAP\\SERIALCOMM";

//
// Common allocation
//
PVOID MdmAlloc (DWORD dwSize, BOOL bZero) {
    return LocalAlloc ((bZero) ? LPTR : LMEM_FIXED, dwSize);
}

//
// Common free
//
VOID MdmFree (PVOID pvData) {
    LocalFree(pvData);
}

//
// Enumerates the serial ports on the system
// 
DWORD MdmEnumComPorts(
        IN MdmPortEnumFuncPtr pEnumFunc, 
        IN HANDLE hData)
{
    DWORD dwErr, dwValSize, dwNameSize, dwBufSize, i,
          dwValBufSize, dwNameBufSize, dwType, dwCount;
    PWCHAR pszValBuf = NULL, pszNameBuf = NULL;
    HKEY hkPorts;

    // Open the hardware key
    dwErr = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE, 
                pszComPortRegKey,
                0,
                KEY_READ,
                &hkPorts);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    __try {
        // Get the number of values
        dwErr = RegQueryInfoKeyW (
                    hkPorts,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &dwCount,
                    &dwNameBufSize,
                    &dwValBufSize,
                    NULL,
                    NULL);
        if (dwErr != NO_ERROR)
            return dwErr;

        // If the count is zero, we're done
        if (dwCount == 0)
            return NO_ERROR;

        // Initialize the buffer to hold the names
        dwNameBufSize++;
        dwNameBufSize *= sizeof(WCHAR);
        pszNameBuf = (PWCHAR) MdmAlloc(dwNameBufSize, FALSE);
        if (pszNameBuf == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        
        // Initialize the buffer to hold the values
        dwValBufSize++;
        pszValBuf = (PWCHAR) MdmAlloc(dwValBufSize, FALSE);
        if (pszValBuf == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        
        // Enumerate the values
        for (i = 0; i < dwCount; i++) {
            dwValSize = dwValBufSize;
            dwNameSize = dwNameBufSize;
            dwErr = RegEnumValueW (
                        hkPorts,
                        i,
                        pszNameBuf,
                        &dwNameSize,
                        NULL,
                        NULL,
                        (LPBYTE)pszValBuf,
                        &dwValSize);
            if (dwErr != ERROR_SUCCESS)
                return dwErr;
            
            if ((*(pEnumFunc))(pszValBuf, hData) == TRUE)
                break;
        }            
    }
    __finally {
        RegCloseKey (hkPorts);
        if (pszValBuf)
            MdmFree(pszValBuf);
        if (pszNameBuf)
            MdmFree(pszNameBuf);
    }            
                
    return NO_ERROR;
}

//
// Installs a null modem on the given port
//
DWORD MdmInstallNullModem(
        IN PWCHAR pszPort) 
{
    GUID Guid = GUID_DEVCLASS_MODEM;
    SP_DEVINFO_DATA deid;
    SP_DEVINSTALL_PARAMS deip;
    SP_DRVINFO_DATA drid;
    UM_INSTALL_WIZARD miw = {sizeof(UM_INSTALL_WIZARD), 0};
    SP_INSTALLWIZARD_DATA  iwd;
	PWCHAR pszTempId = NULL;
    DWORD dwSize;
    HDEVINFO hdi;
    BOOL bOk;

    // Create the device info list
    hdi = SetupDiCreateDeviceInfoList (&Guid, NULL);
    if (hdi == INVALID_HANDLE_VALUE)
        return ERROR_CAN_NOT_COMPLETE;

    __try {
        // Create a new devinfo.
        deid.cbSize = sizeof(SP_DEVINFO_DATA);
        bOk = SetupDiCreateDeviceInfo (
                    hdi, 
                    pszNullModemId, 
                    &Guid, 
                    NULL, 
                    NULL,
                    DICD_GENERATE_ID,
                    &deid);
        if (bOk == FALSE)
            return ERROR_CAN_NOT_COMPLETE;

        // In order to find the Inf file, Device Installer Api needs the
        // component id which it calls the Hardware id.
        // We need to include an extra null since this registry value is a
        // multi-sz
        //
        dwSize = sizeof(pszNullModemId) + (2*sizeof(WCHAR));
        pszTempId = (PWCHAR) MdmAlloc(dwSize * sizeof(WCHAR), FALSE);

        if(NULL == pszTempId)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        lstrcpyn(pszTempId, pszNullModemId, dwSize);
        pszTempId[lstrlen(pszNullModemId) + 1] = L'\0';
        bOk = SetupDiSetDeviceRegistryProperty(
                hdi, 
                &deid, 
                SPDRP_HARDWAREID,
                (LPBYTE)pszTempId,
                dwSize);
        if (bOk == FALSE)
            return GetLastError();
            
        // We can let Device Installer Api know that we want 
        // to use a single inf. if we can't get the params and 
        // set it it isn't an error since it only slows things 
        // down a bit.
        //
        deip.cbSize = sizeof(deip);
        bOk = SetupDiGetDeviceInstallParams(
                hdi, 
                &deid, 
                &deip);
        if (bOk == FALSE)
            return GetLastError();
            
        lstrcpyn(deip.DriverPath, pszNullModemInfFile, MAX_PATH);
        deip.Flags |= DI_ENUMSINGLEINF;

        bOk = SetupDiSetDeviceInstallParams(hdi, &deid, &deip);
        if (bOk == FALSE)
            return GetLastError();

        // Now we let Device Installer Api build a driver list 
        // based on the information we have given so far.  This 
        // will result in the Inf file being found if it exists 
        // in the usual Inf directory
        //
        bOk = SetupDiBuildDriverInfoList(
                hdi, 
                &deid,
                SPDIT_COMPATDRIVER);
        if (bOk == FALSE)
            return GetLastError();

        // Now that Device Installer Api has found the right inf
        // file, we need to get the information and make it the
        // selected driver
        //
        ZeroMemory(&drid, sizeof(drid));
        drid.cbSize = sizeof(drid);
        bOk = SetupDiEnumDriverInfo(
                hdi, 
                &deid,
                SPDIT_COMPATDRIVER, 
                0, 
                &drid);
        if (bOk == FALSE)
            return GetLastError();

        bOk = SetupDiSetSelectedDriver(
                hdi, 
                &deid, 
                &drid);
        if (bOk == FALSE)
            return ERROR_CAN_NOT_COMPLETE;

        miw.InstallParams.Flags = MIPF_DRIVER_SELECTED;
        lstrcpyn (miw.InstallParams.szPort, pszPort, UM_MAX_BUF_SHORT);
        ZeroMemory(&iwd, sizeof(iwd));
        iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
        iwd.hwndWizardDlg = NULL;
        iwd.PrivateData = (LPARAM)&miw;

        bOk = SetupDiSetClassInstallParams (
                hdi, 
                &deid, 
                (PSP_CLASSINSTALL_HEADER)&iwd, 
                sizeof(iwd));
        if (bOk == FALSE)
            return GetLastError();

        // Call the class installer to invoke the installation
        // wizard.
        bOk = SetupDiCallClassInstaller (
                DIF_INSTALLWIZARD, 
                hdi, 
                &deid);
        if (bOk == FALSE)
            return GetLastError();

        SetupDiCallClassInstaller (
                DIF_DESTROYWIZARDDATA, 
                hdi, 
                &deid);
    }
    __finally {
        SetupDiDestroyDeviceInfoList (hdi);
        if (pszTempId)
            MdmFree(pszTempId);
    }

    return NO_ERROR;
}


/*
const WCHAR pszComPortService[]     = L"Serial";
const WCHAR pszPortDelimeter[]      = L"(";

//
// Enumerates the serial ports on the system
// 
// The old way
//
DWORD MdmEnumComPorts(
        IN MdmPortEnumFuncPtr pEnumFunc, 
        IN HANDLE hData)
{
    GUID Guid = GUID_DEVCLASS_PORTS;
    SP_DEVINFO_DATA deid;
    DWORD dwErr, i;
    WCHAR pszName[512], pszPort[64], *pszTemp;
    HDEVINFO hdi;
    BOOL bOk;

    // Create the device info list
    hdi = SetupDiGetClassDevs  (&Guid, NULL, NULL, DIGCF_PRESENT);
    if (hdi == INVALID_HANDLE_VALUE)
        return ERROR_CAN_NOT_COMPLETE;
    ZeroMemory(&deid, sizeof(deid));
    deid.cbSize = sizeof(deid);

    __try {
        i = 0; 
        while (TRUE) {
            // Enumerate the next device
            bOk = SetupDiEnumDeviceInfo (hdi, i++, &deid);
            if (bOk == FALSE) {
                dwErr = GetLastError();
                break;
            }

            // Find out if this is a serial port
            bOk = SetupDiGetDeviceRegistryPropertyW(
                    hdi, 
                    &deid, 
                    SPDRP_SERVICE,
                    NULL, 
                    (PBYTE)pszName, 
                    sizeof (pszName), 
                    NULL);
            if (bOk == FALSE)
                continue;

            // Filter out non-serial devices
            if (lstrcmpi(pszName, pszComPortService) != 0)
                continue;

            // Get the friendly name
            bOk = SetupDiGetDeviceRegistryPropertyW(
                    hdi, 
                    &deid, 
                    SPDRP_FRIENDLYNAME,
                    NULL, 
                    (PBYTE)pszName, 
                    sizeof (pszName), 
                    NULL);
            if (bOk == TRUE) {
                // Add the real name of the port.  Use this hack for
                // now.
                pszTemp = wcsstr(pszName, pszPortDelimeter);
                if (pszTemp) {
                    lstrcpynW(pszPort, pszTemp + 1, sizeof(pszPort) / sizeof(WCHAR));
                    pszPort[wcslen(pszPort) - 1] = (WCHAR)0;
                }        

                bOk = (*pEnumFunc)(pszName, pszPort, hData);
                if (bOk)
                    break;
            }
        }
    }
    __finally {
        SetupDiDestroyDeviceInfoList (hdi);
    }

    return NO_ERROR;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\noui.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** noui.c
** Non-UI helper routines (no HWNDs required)
** Listed alphabetically
**
** 08/25/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <stdlib.h>   // for atol()
#include <nouiutil.h> // Our public header
#include <debug.h>    // Trace/Assert library
#include <nnetcfg.h>

WCHAR*
StrDupWFromAInternal(
    LPCSTR psz,
    UINT uiCodePage);

INT
ComparePszNode(
    IN DTLNODE* pNode1,
    IN DTLNODE* pNode2 )

    /* Callback for DtlMergeSort; takes two DTLNODE*'s whose data
    ** are assumed to be strings (TCHAR*), and compares the strings.
    **
    ** Return value is as defined for 'lstrcmpi'.
    */
{
    return lstrcmpi( (TCHAR *)DtlGetData(pNode1), (TCHAR *)DtlGetData(pNode2) );
}


DWORD
CreateDirectoriesOnPath(
    LPTSTR                  pszPath,
    LPSECURITY_ATTRIBUTES   psa)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pszPath && *pszPath)
    {
        LPTSTR pch = pszPath;

        // If the path is a UNC path, we need to skip the \\server\share
        // portion.
        //
        if ((TEXT('\\') == *pch) && (TEXT('\\') == *(pch+1)))
        {
            // pch now pointing at the server name.  Skip to the backslash
            // before the share name.
            //
            pch += 2;
            while (*pch && (TEXT('\\') != *pch))
            {
                pch++;
            }

            if (!*pch)
            {
                // Just the \\server was specified.  This is bogus.
                //
                return ERROR_INVALID_PARAMETER;
            }

            // pch now pointing at the backslash before the share name.
            // Skip to the backslash that should come after the share name.
            //
            pch++;
            while (*pch && (TEXT('\\') != *pch))
            {
                pch++;
            }

            if (!*pch)
            {
                // Just the \\server\share was specified.  No subdirectories
                // to create.
                //
                return ERROR_SUCCESS;
            }
        }

        // Loop through the path.
        //
        for (; *pch; pch++)
        {
            // Stop at each backslash and make sure the path
            // is created to that point.  Do this by changing the
            // backslash to a null-terminator, calling CreateDirecotry,
            // and changing it back.
            //
            if (TEXT('\\') == *pch)
            {
                BOOL fOk;

                *pch = 0;
                fOk = CreateDirectory (pszPath, psa);
                *pch = TEXT('\\');

                // Any errors other than path alredy exists and we should
                // bail out.  We also get access denied when trying to
                // create a root drive (i.e. c:) so check for this too.
                //
                if (!fOk)
                {
                    dwErr = GetLastError ();
                    if (ERROR_ALREADY_EXISTS == dwErr)
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                    else if ((ERROR_ACCESS_DENIED == dwErr) &&
                             (pch - 1 > pszPath) && (TEXT(':') == *(pch - 1)))
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        if (ERROR_ALREADY_EXISTS == dwErr)
        {
            dwErr = ERROR_SUCCESS;
        }
    }

    return dwErr;
}


DTLNODE*
CreateKvNode(
    IN LPCTSTR pszKey,
    IN LPCTSTR pszValue )

    /* Returns a KEYVALUE node containing a copy of 'pszKey' and 'pszValue' or
    ** NULL on error.  It is caller's responsibility to DestroyKvNode the
    ** returned node.
    */
{
    DTLNODE*  pNode;
    KEYVALUE* pkv;

    pNode = DtlCreateSizedNode( sizeof(KEYVALUE), 0L );
    if (!pNode)
        return NULL;

    pkv = (KEYVALUE* )DtlGetData( pNode );
    ASSERT( pkv );
    pkv->pszKey = StrDup( pszKey );
    pkv->pszValue = StrDup( pszValue );

    if (!pkv->pszKey || !pkv->pszValue)
    {
        DestroyKvNode( pNode );
        return NULL;
    }

    return pNode;
}


DTLNODE*
CreatePszNode(
    IN LPCTSTR psz )

    /* Returns a node containing a copy of 'psz' or NULL on error.  It is
    ** caller's responsibility to DestroyPszNode the returned node.
    */
{
    TCHAR*   pszData;
    DTLNODE* pNode;

    pszData = StrDup( psz );
    if (!pszData)
        return NULL;

    pNode = DtlCreateNode( pszData, 0L );
    if (!pNode)
    {
        Free( pszData );
        return NULL;
    }

    return pNode;
}


VOID
DestroyPszNode(
    IN DTLNODE* pdtlnode )

    /* Release memory associated with string (or any simple Malloc) node
    ** 'pdtlnode'.  See DtlDestroyList.
    */
{
    TCHAR* psz;

    ASSERT(pdtlnode);
    psz = (TCHAR* )DtlGetData( pdtlnode );
    Free0( psz );

    DtlDestroyNode( pdtlnode );
}


VOID
DestroyKvNode(
    IN DTLNODE* pdtlnode )

    /* Release memory associated with a KEYVALUE node 'pdtlnode'.  See
    ** DtlDestroyList.
    */
{
    KEYVALUE* pkv;

    ASSERT(pdtlnode);
    pkv = (KEYVALUE* )DtlGetData( pdtlnode );
    ASSERT(pkv);

    Free0( pkv->pszKey );
    Free0( pkv->pszValue );

    DtlDestroyNode( pdtlnode );
}


BOOL
DeviceAndPortFromPsz(
    IN  TCHAR*  pszDP,
    OUT TCHAR** ppszDevice,
    OUT TCHAR** ppszPort )

    /* Loads '*ppszDevice' and '*ppszPort' with the parsed out device and port
    ** names from 'pszDP', a display string created with PszFromDeviceAndPort.
    **
    ** Returns true if successful, false if 'pszDP' is not of the stated form.
    ** It is caller's responsibility to Free the returned '*ppszDevice' and
    ** '*ppszPort'.
    */
{
    TCHAR szDP[ RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1 ];
    INT   cb;

    *ppszDevice = NULL;
    *ppszPort = NULL;

    lstrcpyn( szDP, pszDP, sizeof(szDP) / sizeof(TCHAR) );
    cb = lstrlen( szDP );

    if (cb > 0)
    {
        TCHAR* pch;

        pch = szDP + cb;
        pch = CharPrev( szDP, pch );

        while (pch != szDP)
        {
            if (*pch == TEXT(')'))
            {
                *pch = TEXT('\0');
            }
            else if (*pch == TEXT('('))
            {
                *ppszPort = StrDup( CharNext( pch ) );
                // [pmay] backup trailing spaces
                pch--;
                while ((*pch == TEXT(' ')) && (pch != szDP))
                    pch--;
                pch++;
                *pch = TEXT('\0');
                *ppszDevice = StrDup( szDP );
                break;
            }

            pch = CharPrev( szDP, pch );
        }
    }

    return (*ppszDevice && *ppszPort);
}


DTLNODE*
DuplicateKvNode(
    IN DTLNODE* pdtlnode )

    /* Duplicates KEYVALUE node 'pdtlnode'.  See DtlDuplicateList.
    **
    ** Returns the address of the allocated node or NULL if out of memory.  It
    ** is caller's responsibility to free the returned node.
    */
{
    DTLNODE*  pNode;
    KEYVALUE* pKv;

    pKv = (KEYVALUE* )DtlGetData( pdtlnode );
    ASSERT(pKv);

    pNode = CreateKvNode( pKv->pszKey, pKv->pszValue );
    if (pNode)
    {
        DtlPutNodeId( pNode, DtlGetNodeId( pdtlnode ) );
    }
    return pNode;
}


DTLNODE*
DuplicatePszNode(
    IN DTLNODE* pdtlnode )

    /* Duplicates string node 'pdtlnode'.  See DtlDuplicateList.
    **
    ** Returns the address of the allocated node or NULL if out of memory.  It
    ** is caller's responsibility to free the returned node.
    */
{
    DTLNODE* pNode;
    TCHAR*   psz;

    psz = (TCHAR* )DtlGetData( pdtlnode );
    ASSERT(psz);

    pNode = CreatePszNode( psz );
    if (pNode)
    {
        DtlPutNodeId( pNode, DtlGetNodeId( pdtlnode ) );
    }
    return pNode;
}


BOOL
FFileExists(
    IN TCHAR* pszPath )

    /* Returns true if the path 'pszPath' exists, false otherwise.
    */
{
    WIN32_FIND_DATA finddata;
    HANDLE          h;
    DWORD dwErr;
    
    if ((h = FindFirstFile( pszPath, &finddata )) != INVALID_HANDLE_VALUE)
    {

        FindClose( h );
        return TRUE;
    }

    dwErr = GetLastError();

    TRACE1("FindFirstFile failed with 0x%x",
          dwErr);
              
    return FALSE;
}

BOOL
FIsTcpipInstalled()
{
    BOOL fInstalled;
    SC_HANDLE ScmHandle;
    ScmHandle = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (!ScmHandle) {
        fInstalled = FALSE;
    } else {
        static const TCHAR c_szTcpip[] = TEXT("Tcpip");
        SC_HANDLE ServiceHandle;
        ServiceHandle = OpenService(ScmHandle, c_szTcpip, SERVICE_QUERY_STATUS);
        if (!ServiceHandle) {
            fInstalled = FALSE;
        } else {
            SERVICE_STATUS ServiceStatus;
            if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
                fInstalled = FALSE;
            } else {
                fInstalled = (ServiceStatus.dwCurrentState == SERVICE_RUNNING);
            }
            CloseServiceHandle(ServiceHandle);
        }
        CloseServiceHandle(ScmHandle);
    }
    return fInstalled;
}

BOOL
FIsUserAdminOrPowerUser()
{
    SID_IDENTIFIER_AUTHORITY    SidAuth = SECURITY_NT_AUTHORITY;
    PSID                        psid;
    BOOL                        fIsMember = FALSE;
    BOOL                        fRet = FALSE;
    SID                         sidLocalSystem = { 1, 1,
                                    SECURITY_NT_AUTHORITY,
                                    SECURITY_LOCAL_SYSTEM_RID };


    // Check to see if running under local system first
    //
    if (!CheckTokenMembership( NULL, &sidLocalSystem, &fIsMember ))
    {
        TRACE( "CheckTokenMemberShip for local system failed.");
        fIsMember = FALSE;
    }

    fRet = fIsMember;

    if (!fIsMember)
    {
        // Allocate a SID for the Administrators group and check to see
        // if the user is a member.
        //
        if (AllocateAndInitializeSid( &SidAuth, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0, 0, 0, 0, 0, 0,
                     &psid ))
        {
            if (!CheckTokenMembership( NULL, psid, &fIsMember ))
            {
                TRACE( "CheckTokenMemberShip for admins failed.");
                fIsMember = FALSE;
            }

            FreeSid( psid );

// Changes to the Windows 2000 permission model mean that regular Users
// on workstations are in the power user group.  So we no longer want to
// check for power user.
#if 0
            if (!fIsMember)
            {
                // They're not a member of the Administrators group so allocate a
                // SID for the Power Users group and check to see
                // if the user is a member.
                //
                if (AllocateAndInitializeSid( &SidAuth, 2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_POWER_USERS,
                             0, 0, 0, 0, 0, 0,
                             &psid ))
                {
                    if (!CheckTokenMembership( NULL, psid, &fIsMember ))
                    {
                        TRACE( "CheckTokenMemberShip for power users failed.");
                        fIsMember = FALSE;
                    }

                    FreeSid( psid );
                }
            }
#endif
        }

        fRet = fIsMember;
    }

    return fRet;
}


VOID*
Free0(
    VOID* p )

    /* Like Free, but deals with NULL 'p'.
    */
{
    if (!p)
        return NULL;

    return Free( p );
}


DWORD
GetInstalledProtocols(
    void
    )
{

    ASSERT(FALSE);

    return 0 ;
}


LONG
RegQueryDword (HKEY hkey, LPCTSTR szValueName, LPDWORD pdwValue)
{
    // Get the value.
    //
    DWORD dwType;
    DWORD cbData = sizeof(DWORD);
    LONG  lr = RegQueryValueEx (hkey, szValueName, NULL, &dwType,
                                (LPBYTE)pdwValue, &cbData);

    // It's type should be REG_DWORD. (duh).
    //
    if ((ERROR_SUCCESS == lr) && (REG_DWORD != dwType))
    {
        lr = ERROR_INVALID_DATATYPE;
    }

    // Make sure we initialize the output value on error.
    // (We don't know for sure that RegQueryValueEx does this.)
    //
    if (ERROR_SUCCESS != lr)
    {
        *pdwValue = 0;
    }

    return lr;
}

BOOL
FProtocolEnabled(
    HKEY    hkeyProtocol,
    BOOL    fRasSrv,
    BOOL    fRouter )
{
    static const TCHAR c_szRegValEnableIn[]    = TEXT("EnableIn");
    static const TCHAR c_szRegValEnableRoute[] = TEXT("EnableRoute");

    DWORD dwValue;
    LONG  lr;

    if (fRasSrv)
    {
        lr = RegQueryDword(hkeyProtocol, c_szRegValEnableIn, &dwValue);
        if ((ERROR_FILE_NOT_FOUND == lr) ||
            ((ERROR_SUCCESS == lr) && (dwValue != 0)))
        {
            return TRUE;
        }
    }

    if (fRouter)
    {
        lr = RegQueryDword(hkeyProtocol, c_szRegValEnableRoute, &dwValue);
        if ((ERROR_FILE_NOT_FOUND == lr) ||
            ((ERROR_SUCCESS == lr) && (dwValue != 0)))
        {
            return TRUE;
        }
    }

    return FALSE;
}

DWORD
DwGetInstalledProtocolsEx(
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv )

    /* Returns a bit field containing NP_<protocol> flags for the installed
    ** PPP protocols.  The term "installed" here includes enabling in RAS
    ** Setup.
    */
{
    static const TCHAR c_szRegKeyIp[]  = TEXT("SYSTEM\\CurrentControlSet\\Services\\Tcpip");
    static const TCHAR c_szRegKeyIpx[] = TEXT("SYSTEM\\CurrentControlSet\\Services\\NwlnkIpx");
    static const TCHAR c_szRegKeyNbf[] = TEXT("SYSTEM\\CurrentControlSet\\Services\\Nbf");

    static const TCHAR c_szRegKeyRemoteAccessParams[] =
        TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters");

    static const TCHAR c_szRegSubkeyIp[]  = TEXT("Ip");
    static const TCHAR c_szRegSubkeyIpx[] = TEXT("Ipx");
    static const TCHAR c_szRegSubkeyNbf[] = TEXT("Nbf");

    DWORD dwfInstalledProtocols = 0;

    // First check if the protocols are installed.
    //
    struct INSTALLED_PROTOCOL_INFO
    {
        DWORD   dwFlag;
        LPCTSTR pszRegKey;
        LPCTSTR pszSubkey;
    };
    static const struct INSTALLED_PROTOCOL_INFO c_aProtocolInfo[] =
    {
        { NP_Ip,    c_szRegKeyIp,   c_szRegSubkeyIp  },
        { NP_Ipx,   c_szRegKeyIpx,  c_szRegSubkeyIpx },
        { NP_Nbf,   c_szRegKeyNbf,  c_szRegSubkeyNbf },
    };

    #define celems(_x) (sizeof(_x) / sizeof(_x[0]))

    HKEY hkey;
    int i;
    for (i = 0; i < celems (c_aProtocolInfo); i++)
    {
        const struct INSTALLED_PROTOCOL_INFO* pInfo = c_aProtocolInfo + i;

        if (RegOpenKey( HKEY_LOCAL_MACHINE, pInfo->pszRegKey, &hkey ) == 0)
        {
            dwfInstalledProtocols |= pInfo->dwFlag;
            RegCloseKey( hkey );
        }
    }

    // Now see if they are to be used for the router and/or server.
    // The client uses the protocols if they are installed and not excluded
    // in the phonebook entry.
    //
    if ((fRouter || fRasSrv) && dwfInstalledProtocols)
    {
        if (RegOpenKey( HKEY_LOCAL_MACHINE, c_szRegKeyRemoteAccessParams, &hkey ) == 0)
        {
            for (i = 0; i < celems (c_aProtocolInfo); i++)
            {
                const struct INSTALLED_PROTOCOL_INFO* pInfo = c_aProtocolInfo + i;

                // If the protocol is installed (as determined above), check
                // to see if its enabled.
                //
                if (dwfInstalledProtocols & pInfo->dwFlag)
                {
                    HKEY hkeyProtocol;
                    if (RegOpenKey( hkey, pInfo->pszSubkey, &hkeyProtocol ) == 0)
                    {
                        if (!FProtocolEnabled( hkeyProtocol, fRasSrv, fRouter ))
                        {
                            dwfInstalledProtocols &= ~pInfo->dwFlag;
                        }

                        RegCloseKey( hkeyProtocol );
                    }
                }
            }

            RegCloseKey( hkey );
        }
        else
        {
            dwfInstalledProtocols = 0;
        }
    }


    TRACE1("GetInstalledProtocolsEx=$%x. ",dwfInstalledProtocols);

    return dwfInstalledProtocols;
}

DWORD
GetInstalledProtocolsEx(HANDLE hConnection,
                        BOOL fRouter,
                        BOOL fRasCli,
                        BOOL fRasSrv)
{
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if(     NULL == pRasRpcConnection
        ||  pRasRpcConnection->fLocal)
    {
        return DwGetInstalledProtocolsEx(fRouter,
                                         fRasCli,
                                         fRasSrv);
    }
    else
    {
        //
        // Remote Server
        //
        return RemoteGetInstalledProtocolsEx(hConnection,
                                             fRouter,
                                             fRasCli,
                                             fRasSrv);
    }
}

/*

DWORD
GetInstalledProtocolsEx(
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv )

{

    DWORD dwRetCode;
    DWORD dwfInstalledProtocols;


    dwRetCode = dwGetInstalledProtocols ( &dwfInstalledProtocols,
                                          fRouter,
                                          fRasCli,
                                          fRasSrv);

    TRACE2("GetInstalledProtocols=$%x. dwErr = %d",dwfInstalledProtocols, dwRetCode);

    return dwfInstalledProtocols;
} */


CHAR
HexChar(
    IN BYTE byte )

    /* Returns an ASCII hexidecimal character corresponding to 0 to 15 value,
    ** 'byte'.
    */
{
    const CHAR* pszHexDigits = "0123456789ABCDEF";

    if (byte >= 0 && byte < 16)
        return pszHexDigits[ byte ];
    else
        return '0';
}


BYTE
HexValue(
    IN CHAR ch )

    /* Returns the value 0 to 15 of hexadecimal character 'ch'.
    */
{
    if (ch >= '0' && ch <= '9')
        return (BYTE )(ch - '0');
    else if (ch >= 'A' && ch <= 'F')
        return (BYTE )((ch - 'A') + 10);
    else if (ch >= 'a' && ch <= 'f')
        return (BYTE )((ch - 'a') + 10);
    else
        return 0;
}


BOOL
IsAllWhite(
    IN LPCTSTR psz )

    /* Returns true if 'psz' consists entirely of spaces and tabs.  NULL
    ** pointers and empty strings are considered all white.  Otherwise,
    ** returns false.
    */
{
    LPCTSTR pszThis;

    for (pszThis = psz; *pszThis != TEXT('\0'); ++pszThis)
    {
        if (*pszThis != TEXT(' ') && *pszThis != TEXT('\t'))
            return FALSE;
    }

    return TRUE;
}


void
IpHostAddrToPsz(
    IN  DWORD   dwAddr,
    OUT LPTSTR  pszBuffer )

    // Converts an IP address in host byte order to its
    // string representation.
    // pszBuffer should be allocated by the caller and be
    // at least 16 characters long.
    //
{
    BYTE* pb = (BYTE*)&dwAddr;
    static const TCHAR c_szIpAddr [] = TEXT("%d.%d.%d.%d");
    wsprintf (pszBuffer, c_szIpAddr, pb[3], pb[2], pb[1], pb[0]);
}

DWORD
IpPszToHostAddr(
    IN  LPCTSTR cp )

    // Converts an IP address represented as a string to
    // host byte order.
    //
{
    DWORD val, base, n;
    TCHAR c;
    DWORD parts[4], *pp = parts;

again:
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*cp == TEXT('0'))
        base = 8, cp++;
    if (*cp == TEXT('x') || *cp == TEXT('X'))
        base = 16, cp++;
    while (c = *cp)
    {
        if ((c >= TEXT('0')) && (c <= TEXT('9')))
        {
            val = (val * base) + (c - TEXT('0'));
            cp++;
            continue;
        }
        if ((base == 16) &&
            ( ((c >= TEXT('0')) && (c <= TEXT('9'))) ||
              ((c >= TEXT('A')) && (c <= TEXT('F'))) ||
              ((c >= TEXT('a')) && (c <= TEXT('f'))) ))
        {
            val = (val << 4) + (c + 10 - (
                        ((c >= TEXT('a')) && (c <= TEXT('f')))
                            ? TEXT('a')
                            : TEXT('A') ) );
            cp++;
            continue;
        }
        break;
    }
    if (*cp == TEXT('.'))
    {
        // Internet format:
        //  a.b.c.d
        //  a.b.c   (with c treated as 16-bits)
        //  a.b (with b treated as 24 bits)
        //
        if (pp >= parts + 3)
            return (DWORD) -1;
        *pp++ = val, cp++;
        goto again;
    }

    // Check for trailing characters.
    //
    if (*cp && (*cp != TEXT(' ')))
        return 0xffffffff;

    *pp++ = val;

    // Concoct the address according to
    // the number of parts specified.
    //
    n = (DWORD) (pp - parts);
    switch (n)
    {
    case 1:             // a -- 32 bits
        val = parts[0];
        break;

    case 2:             // a.b -- 8.24 bits
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:             // a.b.c -- 8.8.16 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
            (parts[2] & 0xffff);
        break;

    case 4:             // a.b.c.d -- 8.8.8.8 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        return 0xffffffff;
    }

    return val;
}


#if 0
BOOL
IsNullTerminatedA(
    IN CHAR* psz,
    IN DWORD dwSize )

    /* Returns true is 'psz' contains a null character somewhere in it's
    ** 'dwSize' bytes, false otherwise.
    */
{
    CHAR* pszThis;
    CHAR* pszEnd;

    pszEnd = psz + dwSize;
    for (pszThis = psz; pszThis < pszEnd; ++pszThis)
    {
        if (*pszThis == '\0')
            return TRUE;
    }

    return FALSE;
}
#endif


TCHAR*
LToT(
    LONG   lValue,
    TCHAR* pszBuf,
    INT    nRadix )

    /* Like ltoa, but returns TCHAR*.
    */
{
#ifdef UNICODE
    WCHAR szBuf[ MAXLTOTLEN + 1 ];

    ASSERT(nRadix==10||nRadix==16);

    if (nRadix == 10)
        wsprintf( pszBuf, TEXT("%d"), lValue );
    else
        wsprintf( pszBuf, TEXT("%x"), lValue );
#else
    _ltoa( lValue, pszBuf, nRadix );
#endif

    return pszBuf;
}



LONG
TToL(
    TCHAR *pszBuf )

    /* Like atol, but accepts TCHAR*.
    */
{
    CHAR* psz;
    CHAR  szBuf[ MAXLTOTLEN + 1 ];

#ifdef UNICODE
    psz = szBuf;

    WideCharToMultiByte(
        CP_ACP, 0, pszBuf, -1, psz, MAXLTOTLEN + 1, NULL, NULL );
#else
    psz = pszBuf;
#endif

    return atol( psz );
}


TCHAR*
PszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort )

    /* Returns address of heap block psz containing the MXS modem list display
    ** form, i.e. the device name 'pszDevice' followed by the port name
    ** 'pszPort'.  It's caller's responsibility to Free the returned string.
    */
{
    /* If you're thinking of changing this format string be aware that
    ** DeviceAndPortFromPsz parses it.
    */
    const TCHAR* pszF = TEXT("%s (%s)");

    TCHAR* pszResult;
    TCHAR* pszD;
    TCHAR* pszP;

    if (pszDevice)
        pszD = pszDevice;
    else
        pszD = TEXT("");

    if (pszPort)
        pszP = pszPort;
    else
        pszP = TEXT("");

    pszResult = Malloc(
        (lstrlen( pszD ) + lstrlen( pszP ) + lstrlen( pszF ) + 1)
            * sizeof(TCHAR) );

    if (pszResult)
        wsprintf( pszResult, pszF, pszD, pszP );

    return pszResult;
}


TCHAR*
PszFromId(
    IN HINSTANCE hInstance,
    IN DWORD     dwStringId )

    /* String resource message loader routine.
    **
    ** Returns the address of a heap block containing the string corresponding
    ** to string resource 'dwStringId' or NULL if error.  It is caller's
    ** responsibility to Free the returned string.
    */
{
    HRSRC  hrsrc;
    TCHAR* pszBuf;
    int    cchBuf = 256;
    int    cchGot;

    for (;;)
    {
        pszBuf = Malloc( cchBuf * sizeof(TCHAR) );
        if (!pszBuf)
            break;

        /* LoadString wants to deal with character-counts rather than
        ** byte-counts...weird.  Oh, and if you're thinking I could
        ** FindResource then SizeofResource to figure out the string size, be
        ** advised it doesn't work.  From perusing the LoadString source, it
        ** appears the RT_STRING resource type requests a segment of 16
        ** strings not an individual string.
        */
        cchGot = LoadString( hInstance, (UINT )dwStringId, pszBuf, cchBuf );

        if (cchGot < cchBuf - 1)
        {
            TCHAR *pszTemp = pszBuf;
            
            /* Good, got the whole string.  Reduce heap block to actual size
            ** needed.
            */
            pszBuf = Realloc( pszBuf, (cchGot + 1) * sizeof(TCHAR));

            if(NULL == pszBuf)
            {
                Free(pszTemp);
            }
            
            break;
        }

        /* Uh oh, LoadStringW filled the buffer entirely which could mean the
        ** string was truncated.  Try again with a larger buffer to be sure it
        ** wasn't.
        */
        Free( pszBuf );
        cchBuf += 256;
        TRACE1("Grow string buf to %d",cchBuf);
    }

    return pszBuf;
}


#if 0
TCHAR*
PszFromError(
    IN DWORD dwError )

    /* Error message loader routine.
    **
    ** Returns the address of a heap block containing the error string
    ** corresponding to RAS or system error code 'dwMsgid' or NULL if error.
    ** It is caller's responsibility to Free the returned string.
    */
{
    return NULL;
}
#endif


BOOL
RestartComputer()

    /* Called if user chooses to shut down the computer.
    **
    ** Return false if failure, true otherwise
    */
{
   HANDLE            hToken =  NULL;      /* handle to process token */
   TOKEN_PRIVILEGES  tkp;                 /* ptr. to token structure */
   BOOL              fResult;             /* system shutdown flag */

   TRACE("RestartComputer");

   /* Enable the shutdown privilege */

   if (!OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
      return FALSE;

   /* Get the LUID for shutdown privilege. */

   LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

   tkp.PrivilegeCount = 1;  /* one privilege to set    */
   tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

   /* Get shutdown privilege for this process. */

   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, 0);

   /* Cannot test the return value of AdjustTokenPrivileges. */

   if (GetLastError() != ERROR_SUCCESS)
   {
        CloseHandle(hToken);
        return FALSE;
   }

   if( !ExitWindowsEx(EWX_REBOOT, 0))
   {
      CloseHandle(hToken);
      return FALSE;
   }

   /* Disable shutdown privilege. */

   tkp.Privileges[0].Attributes = 0;
   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, 0);

   if (GetLastError() != ERROR_SUCCESS)
   {
      CloseHandle(hToken);
      return FALSE;
   }

   CloseHandle(hToken);
   return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   PszLoadStringPcch
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//      pcch  [out] Pointer to returned character length.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      The loaded string is pointer directly into the read-only
//              resource section.  Any attempt to write through this pointer
//              will generate an access violation.
//
//              The implementations is referenced from "Win32 Binary Resource
//              Formats" (MSDN) 4.8 String Table Resources
//
//              User must have RCOPTIONS = -N turned on in the sources file.
//
LPCTSTR
PszLoadStringPcch (
        HINSTANCE   hinst,
        UINT        unId,
        int*        pcch)
{
    static const WCHAR c_szwSpace[] = L" ";
    LPCWSTR pszw;
    int     cch;
    HRSRC   hrsrcInfo;

    ASSERT(hinst);
    ASSERT(unId);
    ASSERT(pcch);

    pszw = c_szwSpace;
    cch = 0;

    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.
    hrsrcInfo = FindResource(hinst, (LPTSTR)UlongToPtr((LONG)(((USHORT)unId >> 4) + 1)),
                             RT_STRING);
    if (hrsrcInfo)
    {
        // Page the resource segment into memory.
        HGLOBAL hglbSeg = LoadResource(hinst, hrsrcInfo);
        if (hglbSeg)
        {
            // Lock the resource.
            pszw = (LPCWSTR)LockResource(hglbSeg);
            if (pszw)
            {
                // Move past the other strings in this segment.
                // (16 strings in a segment -> & 0x0F)
                unId &= 0x0F;

                ASSERT(!cch);   // first time through, cch should be zero
                do
                {
                    pszw += cch;                // Step to start of next string
                    cch = *((WCHAR*)pszw++);    // PASCAL like string count
                }
                while (unId--);

                if (!cch)
                {
                    ASSERT(0); // String resource not found
                    pszw = c_szwSpace;
                }
            }
            else
            {
                pszw = c_szwSpace;
                TRACE("PszLoadStringPcch: LockResource failed.");
            }
        }
        else
            TRACE("PszLoadStringPcch: LoadResource failed.");
    }
    else
        TRACE("PszLoadStringPcch: FindResource failed.");

    *pcch = cch;
    ASSERT(*pcch);
    ASSERT(pszw);
    return pszw;
}

//+---------------------------------------------------------------------------
//
//  Function:   PszLoadString
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      See PszLoadStringPcch()
//
LPCTSTR
PszLoadString (
        HINSTANCE   hinst,
        UINT        unId)
{
    int cch;
    return PszLoadStringPcch (hinst, unId, &cch);
}


DWORD
ShellSort(
    IN VOID*        pItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare )

    /* Sort an array of items in-place using shell-sort.
    ** This function calls ShellSortIndirect to sort a table of pointers
    ** to table items. We then move the items into place by copying.
    ** This algorithm allows us to guarantee that the number
    ** of copies necessary in the worst case is N + 1.
    **
    ** Note that if the caller merely needs to know the sorted order
    ** of the array, ShellSortIndirect should be called since that function
    ** avoids moving items altogether, and instead fills an array with pointers
    ** to the array items in the correct order. The array items can then
    ** be accessed through the array of pointers.
    */
{

    VOID** ppItemTable;

    INT N;
    INT i;
    BYTE *a, **p, *t = NULL;

    if (!dwItemCount) { return NO_ERROR; }


    /* allocate space for the table of pointers.
    */
    ppItemTable = Malloc(dwItemCount * sizeof(VOID*));
    if (!ppItemTable) { return ERROR_NOT_ENOUGH_MEMORY; }


    /* call ShellSortIndirect to fill our table of pointers
    ** with the sorted positions for each table element.
    */
    ShellSortIndirect(
        pItemTable, ppItemTable, dwItemSize, dwItemCount, pfnCompare );


    /* now that we know the sort order, move each table item into place.
    ** This involves going through the table of pointers making sure
    ** that the item which should be in 'i' is in fact in 'i', moving
    ** things around if necessary to achieve this condition.
    */

    a = (BYTE*)pItemTable;
    p = (BYTE**)ppItemTable;
    N = (INT)dwItemCount;

    for (i = 0; i < N; i++)
    {
        INT j, k;
        BYTE* ai =  (a + i * dwItemSize), *ak, *aj;

        /* see if item 'i' is not in-place
        */
        if (p[i] != ai)
        {


            /* item 'i' isn't in-place, so we'll have to move it.
            ** if we've delayed allocating a temporary buffer so far,
            ** we'll need one now.
            */

            if (!t) {
                t = Malloc(dwItemSize);
                if (!t) { return ERROR_NOT_ENOUGH_MEMORY; }
            }

            /* save a copy of the item to be overwritten
            */
            CopyMemory(t, ai, dwItemSize);

            k = i;
            ak = ai;


            /* Now move whatever item is occupying the space where it should be.
            ** This may involve moving the item occupying the space where
            ** it should be, etc.
            */

            do
            {

                /* copy the item which should be in position 'j'
                ** over the item which is currently in position 'j'.
                */
                j = k;
                aj = ak;
                CopyMemory(aj, p[j], dwItemSize);

                /* set 'k' to the position from which we copied
                ** into position 'j'; this is where we will copy
                ** the next out-of-place item in the array.
                */
                ak = p[j];
                k = (INT)(ak - a) / dwItemSize;

                /* keep the array of position pointers up-to-date;
                ** the contents of 'aj' are now in their sorted position.
                */
                p[j] = aj;

            } while (ak != ai);


            /* now write the item which we first overwrote.
            */
            CopyMemory(aj, t, dwItemSize);
        }
    }

    Free0(t);
    Free(ppItemTable);

    return NO_ERROR;
}


VOID
ShellSortIndirect(
    IN VOID*        pItemTable,
    IN VOID**       ppItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare )

    /* Sorts an array of items indirectly using shell-sort.
    ** 'pItemTable' points to the table of items, 'dwItemCount' is the number
    ** of items in the table,  and 'pfnCompare' is a function called
    ** to compare items.
    **
    ** Rather than sort the items by moving them around,
    ** we sort them by initializing the table of pointers 'ppItemTable'
    ** with pointers such that 'ppItemTable[i]' contains a pointer
    ** into 'pItemTable' for the item which would be in position 'i'
    ** if 'pItemTable' were sorted.
    **
    ** For instance, given an array pItemTable of 5 strings as follows
    **
    **      pItemTable[0]:      "xyz"
    **      pItemTable[1]:      "abc"
    **      pItemTable[2]:      "mno"
    **      pItemTable[3]:      "qrs"
    **      pItemTable[4]:      "def"
    **
    ** on output ppItemTable contains the following pointers
    **
    **      ppItemTable[0]:     &pItemTable[1]  ("abc")
    **      ppItemTable[1]:     &pItemTable[4]  ("def")
    **      ppItemTable[2]:     &pItemTable[2]  ("mno")
    **      ppItemTable[3]:     &pItemTable[3]  ("qrs")
    **      ppItemTable[4]:     &pItemTable[0]  ("xyz")
    **
    ** and the contents of pItemTable are untouched.
    ** And the caller can print out the array in sorted order using
    **      for (i = 0; i < 4; i++) {
    **          printf("%s\n", (char *)*ppItemTable[i]);
    **      }
    */
{

    /* The following algorithm is derived from Sedgewick's Shellsort,
    ** as given in "Algorithms in C++".
    **
    ** The Shellsort algorithm sorts the table by viewing it as
    ** a number of interleaved arrays, each of whose elements are 'h'
    ** spaces apart for some 'h'. Each array is sorted separately,
    ** starting with the array whose elements are farthest apart and
    ** ending with the array whose elements are closest together.
    ** Since the 'last' such array always has elements next to each other,
    ** this degenerates to Insertion sort, but by the time we get down
    ** to the 'last' array, the table is pretty much sorted.
    **
    ** The sequence of values chosen below for 'h' is 1, 4, 13, 40, 121, ...
    ** and the worst-case running time for the sequence is N^(3/2), where
    ** the running time is measured in number of comparisons.
    */

#define PFNSHELLCMP(a,b) (++Ncmp, pfnCompare((a),(b)))

    DWORD dwErr;
    INT i, j, h, N, Ncmp;
    BYTE* a, *v, **p;


    a = (BYTE*)pItemTable;
    p = (BYTE**)ppItemTable;
    N = (INT)dwItemCount;
    Ncmp = 0;

    TRACE1("ShellSortIndirect: N=%d", N);

    /* Initialize the table of position pointers.
    */
    for (i = 0; i < N; i++) { p[i] = (a + i * dwItemSize); }


    /* Move 'h' to the largest increment in our series
    */
    for (h = 1; h < N/9; h = 3 * h + 1) { }


    /* For each increment in our series, sort the 'array' for that increment
    */
    for ( ; h > 0; h /= 3)
    {

        /* For each element in the 'array', get the pointer to its
        ** sorted position.
        */
        for (i = h; i < N; i++)
        {
            /* save the pointer to be inserted
            */
            v = p[i]; j = i;

            /* Move all the larger elements to the right
            */
            while (j >= h && PFNSHELLCMP(p[j - h], v) > 0)
            {
                p[j] = p[j - h]; j -= h;
            }

            /* put the saved pointer in the position where we stopped.
            */
            p[j] = v;
        }
    }

    TRACE1("ShellSortIndirect: Ncmp=%d", Ncmp);

#undef PFNSHELLCMP

}


TCHAR*
StrDup(
    LPCTSTR psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  It is caller's responsibility to
    ** 'Free' the returned string.
    */
{
    TCHAR* pszNew = NULL;

    if (psz)
    {
        pszNew = Malloc( (lstrlen( psz ) + 1) * sizeof(TCHAR) );
        if (!pszNew)
        {
            TRACE("StrDup Malloc failed");
            return NULL;
        }

        lstrcpy( pszNew, psz );
    }

    return pszNew;
}


CHAR*
StrDupAFromTInternal(
    LPCTSTR psz,
    IN DWORD dwCp)

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  The output string is converted to
    ** MB ANSI.  It is caller's responsibility to 'Free' the returned string.
    */
{
#ifdef UNICODE

    CHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = WideCharToMultiByte( dwCp, 0, psz, -1, NULL, 0, NULL, NULL );
        ASSERT(cb);

        pszNew = (CHAR* )Malloc( cb + 1 );
        if (!pszNew)
        {
            TRACE("StrDupAFromT Malloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte( dwCp, 0, psz, -1, pszNew, cb, NULL, NULL );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupAFromT conversion failed");
            return NULL;
        }
    }

    return pszNew;

#else // !UNICODE

    return StrDup( psz );

#endif
}

CHAR*
StrDupAFromT(
    LPCTSTR psz)
{
    return StrDupAFromTInternal(psz, CP_UTF8);
}

CHAR*
StrDupAFromTAnsi(
    LPCTSTR psz)
{
    return StrDupAFromTInternal(psz, CP_ACP);
}    

TCHAR*
StrDupTFromA(
    LPCSTR psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return StrDupWFromA( psz );

#else // !UNICODE

    return StrDup( psz );

#endif
}

TCHAR*
StrDupTFromAUsingAnsiEncoding(
    LPCSTR psz )
{
#ifdef UNICODE

    return StrDupWFromAInternal(psz, CP_ACP);

#else // !UNICODE

    return StrDup( psz );

#endif
}

TCHAR*
StrDupTFromW(
    LPCWSTR psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return StrDup( psz );

#else // !UNICODE

    CHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = WideCharToMultiByte( CP_UTF8, 0, psz, -1, NULL, 0, NULL, NULL );
        ASSERT(cb);

        pszNew = (CHAR* )Malloc( cb + 1 );
        if (!pszNew)
        {
            TRACE("StrDupTFromW Malloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte( CP_UTF8, 0, psz, -1, pszNew, cb, NULL, NULL );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupTFromW conversion failed");
            return NULL;
        }
    }

    return pszNew;

#endif
}


WCHAR*
StrDupWFromAInternal(
    LPCSTR psz,
    UINT uiCodePage)

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or if 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
    WCHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = MultiByteToWideChar( uiCodePage, 0, psz, -1, NULL, 0 );
        ASSERT(cb);

        pszNew = Malloc( (cb + 1) * sizeof(TCHAR) );
        if (!pszNew)
        {
            TRACE("StrDupWFromA Malloc failed");
            return NULL;
        }

        cb = MultiByteToWideChar( uiCodePage, 0, psz, -1, pszNew, cb );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupWFromA conversion failed");
            return NULL;
        }
    }

    return pszNew;
}

WCHAR*
StrDupWFromA(
    LPCSTR psz )
{
    return StrDupWFromAInternal(psz, CP_UTF8);
}

WCHAR*
StrDupWFromT(
    LPCTSTR psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or if 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return StrDup( psz );

#else // !UNICODE

    WCHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = MultiByteToWideChar( CP_UTF8, 0, psz, -1, NULL, 0 );
        ASSERT(cb);

        pszNew = Malloc( (cb + 1) * sizeof(TCHAR) );
        if (!pszNew)
        {
            TRACE("StrDupWFromT Malloc failed");
            return NULL;
        }

        cb = MultiByteToWideChar( CP_UTF8, 0, psz, -1, pszNew, cb );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE1("StrDupWFromT conversion failed");
            return NULL;
        }
    }

    return pszNew;
#endif
}

WCHAR*
StrDupWFromAUsingAnsiEncoding(
    LPCSTR psz )
{
    return StrDupWFromAInternal(psz, CP_ACP);
}

DWORD
StrCpyWFromA(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD dwDstChars)
{
    DWORD cb, dwErr;

    cb = MultiByteToWideChar( CP_UTF8, 0, pszSrc, -1, pszDst, dwDstChars );
    if (cb == 0)
    {
        dwErr = GetLastError();
        TRACE1("StrCpyWFromA conversion failed %x", dwErr);
        dwErr;
    }

    return NO_ERROR;
}

DWORD
StrCpyAFromW(
    LPSTR pszDst,
    LPCWSTR pszSrc,
    DWORD dwDstChars)
{
    DWORD cb, dwErr;

    cb = WideCharToMultiByte(
            CP_UTF8, 0, pszSrc, -1,
            pszDst, dwDstChars, NULL, NULL );

    if (cb == 0)
    {
        dwErr = GetLastError();
        TRACE1("StrCpyAFromW conversion failed %x", dwErr);
        dwErr;
    }

    return NO_ERROR;
}

DWORD
StrCpyAFromWUsingAnsiEncoding(
    LPSTR pszDst,
    LPCWSTR pszSrc,
    DWORD dwDstChars)
{
    DWORD cb, dwErr;

    cb = WideCharToMultiByte(
            CP_ACP, 0, pszSrc, -1,
            pszDst, dwDstChars, NULL, NULL );

    if (cb == 0)
    {
        dwErr = GetLastError();
        TRACE1("StrCpyAFromWUsingAnsiEncoding conversion failed %x", dwErr);
        dwErr;
    }

    return NO_ERROR;
}

DWORD
StrCpyWFromAUsingAnsiEncoding(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD dwDstChars)
{
    DWORD cb, dwErr;

    *pszDst = L'\0';
    cb = MultiByteToWideChar( CP_ACP, 0, pszSrc, -1, pszDst, dwDstChars );
    if (cb == 0)
    {
        dwErr = GetLastError();
        TRACE1("StrCpyWFromA conversion failed %x", dwErr);
        dwErr;
    }

    return NO_ERROR;
}

TCHAR*
StripPath(
    IN TCHAR* pszPath )

    /* Returns a pointer to the file name within 'pszPath'.
    */
{
    TCHAR* p;

    p = pszPath + lstrlen( pszPath );

    while (p > pszPath)
    {
        if (*p == TEXT('\\') || *p == TEXT('/') || *p == TEXT(':'))
        {
            p = CharNext( p );
            break;
        }

        p = CharPrev( pszPath, p );
    }

    return p;
}


int
StrNCmpA(
    IN CHAR* psz1,
    IN CHAR* psz2,
    IN INT   nLen )

    /* Like strncmp, which is not in Win32 for some reason.
    */
{
    INT i;

    for (i= 0; i < nLen; ++i)
    {
        if (*psz1 == *psz2)
        {
            if (*psz1 == '\0')
                return 0;
        }
        else if (*psz1 < *psz2)
            return -1;
        else
            return 1;

        ++psz1;
        ++psz2;
    }

    return 0;
}


CHAR*
StrStrA(
    IN CHAR* psz1,
    IN CHAR* psz2 )

    /* Like strstr, which is not in Win32.
    */
{
    CHAR* psz;
    INT   nLen2;

    if (!psz1 || !psz2 || !*psz1 || !*psz2)
        return NULL;

    nLen2 = lstrlenA( psz2 );

    for (psz = psz1;
         *psz && StrNCmpA( psz, psz2, nLen2 ) != 0;
         ++psz);

    if (*psz)
        return psz;
    else
        return NULL;
}


TCHAR*
UnNull(
    TCHAR* psz )

    // Returns 'psz' or, if NULL, empty string.
    //
{
    return (psz) ? psz : TEXT("");
}

DWORD
DwGetExpandedDllPath(LPTSTR pszDllPath,
                     LPTSTR *ppszExpandedDllPath)
{
    DWORD   dwErr = 0;
    DWORD   dwSize = 0;

    //
    // find the size of the expanded string
    //
    if (0 == (dwSize =
              ExpandEnvironmentStrings(pszDllPath,
                                       NULL,
                                       0)))
    {
        dwErr = GetLastError();
        goto done;
    }

    *ppszExpandedDllPath = LocalAlloc(
                                LPTR,
                                dwSize * sizeof (TCHAR));

    if (NULL == *ppszExpandedDllPath)
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Get the expanded string
    //
    if (0 == ExpandEnvironmentStrings(
                                pszDllPath,
                                *ppszExpandedDllPath,
                                dwSize))
    {
        dwErr = GetLastError();
    }

done:
    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\nnetcfg.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  05/29/97 Rao Salapaka  Created
//
//
//  Description: All Initialization code for rasman component lives here.
//
//****************************************************************************

DWORD dwGetInstalledProtocols(DWORD *pdwInstalledProtocols,
                              BOOL fRouter,
                              BOOL fRasCli,
                              BOOL fRasSrv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\pwutil.c ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** pwutil.c
** Remote Access
** Password handling routines
**
** 03/01/94 Steve Cobb
*/

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include "pwutil.h"

#define PASSWORDMAGIC 0xA5


VOID
ReverseSzA(
    CHAR* psz )

    /* Reverses order of characters in 'psz'.
    */
{
    CHAR* pszBegin;
    CHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + strlen( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        CHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}


VOID
ReverseSzW(
    WCHAR* psz )

    /* Reverses order of characters in 'psz'.
    */
{
    WCHAR* pszBegin;
    WCHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + wcslen( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        WCHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}


VOID
DecodePasswordA(
    IN OUT CHAR* pszPassword )

    /* Un-obfuscate 'pszPassword' in place.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    EncodePasswordA( pszPassword );
}


VOID
DecodePasswordW(
    IN OUT WCHAR* pszPassword )

    /* Un-obfuscate 'pszPassword' in place.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    EncodePasswordW( pszPassword );
}


VOID
EncodePasswordA(
    IN OUT CHAR* pszPassword )

    /* Obfuscate 'pszPassword' in place to foil memory scans for passwords.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    if (pszPassword)
    {
        CHAR* psz;

        ReverseSzA( pszPassword );

        for (psz = pszPassword; *psz != '\0'; ++psz)
        {
            if (*psz != PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
        }
    }
}


VOID
EncodePasswordW(
    IN OUT WCHAR* pszPassword )

    /* Obfuscate 'pszPassword' in place to foil memory scans for passwords.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    if (pszPassword)
    {
        WCHAR* psz;

        ReverseSzW( pszPassword );

        for (psz = pszPassword; *psz != L'\0'; ++psz)
        {
            if (*psz != PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
        }
    }
}


VOID
WipePasswordA(
    IN OUT CHAR* pszPassword )

    /* Zero out the memory occupied by a password.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    if (pszPassword)
    {
        CHAR* psz = pszPassword;

        while (*psz != '\0')
            *psz++ = '\0';
    }
}


VOID
WipePasswordW(
    IN OUT WCHAR* pszPassword )

    /* Zero out the memory occupied by a password.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    if (pszPassword)
    {
        WCHAR* psz = pszPassword;

        while (*psz != L'\0')
            *psz++ = L'\0';
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\reg.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// reg.c
// Registry utility routines
// Listed alphabetically
//
// 11/31/95 Steve Cobb


#include <windows.h>  // Win32 root
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Prototypes and heap macros


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOL
RegDeleteTreeWorker(
    IN  HKEY ParentKeyHandle,
    IN  TCHAR* KeyName,
    OUT DWORD* ErrorCode );


//-----------------------------------------------------------------------------
// Routines (alphabetically)
//-----------------------------------------------------------------------------

VOID
GetRegBinary(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT BYTE** ppbResult,
    OUT DWORD* pcbResult )

    // Set '*ppbResult' to the BINARY registry value 'pszName' under key
    // 'hkey'.  If the value does not exist *ppbResult' is set to NULL.
    // '*PcbResult' is the number of bytes in the returned '*ppbResult'.  It
    // is caller's responsibility to Free the returned block.
    //
{
    DWORD dwErr;
    DWORD dwType;
    BYTE* pb;
    DWORD cb = 0;

    *ppbResult = NULL;
    *pcbResult = 0;

    // Get result buffer size required.
    //
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, NULL, &cb );
    if (dwErr != 0)
    {
        return;
    }

    // Allocate result buffer.
    //
    pb = Malloc( cb );
    if (!pb)
    {
        return;
    }

    // Get the result block.
    //
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )pb, &cb );
    if (dwErr == 0)
    {
        *ppbResult = pb;
        *pcbResult = cb;
    }
}


VOID
GetRegDword(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT DWORD* pdwResult )

    // Set '*pdwResult' to the DWORD registry value 'pszName' under key
    // 'hkey'.  If the value does not exist '*pdwResult' is unchanged.
    //
{
    DWORD dwErr;
    DWORD dwType;
    DWORD dwResult;
    DWORD cb;

    cb = sizeof(DWORD);
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )&dwResult, &cb );

    if (dwErr == 0 && dwType == REG_DWORD && cb == sizeof(DWORD))
    {
        *pdwResult = dwResult;
    }
}


DWORD
GetRegExpandSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult )

    // Set '*ppszResult' to the fully expanded EXPAND_SZ registry value
    // 'pszName' under key 'hkey'.  If the value does not exist *ppszResult'
    // is set to empty string.
    //
    // Returns 0 if successful or an error code.  It is caller's
    // responsibility to Free the returned string.
    //
{
    DWORD dwErr;
    DWORD cb;
    TCHAR* pszResult;

    // Get the unexpanded result string.
    //
    dwErr = GetRegSz( hkey, pszName, ppszResult );
    if (dwErr != 0)
    {
        return dwErr;
    }

    // Find out how big the expanded string will be.
    //
    cb = ExpandEnvironmentStrings( *ppszResult, NULL, 0 );
    if (cb == 0)
    {
        dwErr = GetLastError();
        ASSERT( dwErr != 0 );
        Free( *ppszResult );
        return dwErr;
    }

    // Allocate a buffer for the expanded string.
    //
    pszResult = Malloc( (cb + 1) * sizeof(TCHAR) );
    if (!pszResult)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Expand the environmant variables in the string, storing the result in
    // the allocated buffer.
    //
    cb = ExpandEnvironmentStrings( *ppszResult, pszResult, cb + 1 );
    if (cb == 0)
    {
        dwErr = GetLastError();
        ASSERT( dwErr != 0 );
        Free( *ppszResult );
        Free( pszResult );
        return dwErr;
    }

    Free( *ppszResult );
    *ppszResult = pszResult;
    return 0;
}


DWORD
GetRegMultiSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN OUT DTLLIST** ppListResult,
    IN DWORD dwNodeType )

    // Replaces '*ppListResult' with a list containing a node for each string
    // in the MULTI_SZ registry value 'pszName' under key 'hkey'.  If the
    // value does not exist *ppListResult' is replaced with an empty list.
    // 'DwNodeType' determines the type of node.
    //
    // Returns 0 if successful or an error code.  It is caller's
    // responsibility to destroy the returned list.
    //
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cb;
    TCHAR* pszzResult;
    DTLLIST* pList;

    pList = DtlCreateList( 0 );
    if (!pList)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pszzResult = NULL;

    // Get result buffer size required.
    //
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, NULL, &cb );

    if (dwErr != 0)
    {
        // If can't find the value, just return an empty list.  This not
        // considered an error.
        //
        dwErr = 0;
    }
    else
    {
        // Allocate result buffer.
        //
        pszzResult = Malloc( cb );
        if (!pszzResult)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            // Get the result string.  It's not an error if we can't get it.
            //
            dwErr = RegQueryValueEx(
                hkey, pszName, NULL, &dwType, (LPBYTE )pszzResult, &cb );

            if (dwErr != 0)
            {
                // Not an error if can't read the string, though this should
                // have been caught by the query retrieving the buffer size.
                //
                dwErr = 0;
            }
            else if (dwType == REG_MULTI_SZ)
            {
                TCHAR* psz;
                TCHAR* pszKey;

                // Convert the result to a list of strings.
                //
                pszKey = NULL;
                for (psz = pszzResult;
                     *psz != TEXT('\0');
                     psz += lstrlen( psz ) + 1)
                {
                    DTLNODE* pNode;

                    if (dwNodeType == NT_Psz)
                    {
                        pNode = CreatePszNode( psz );
                    }
                    else
                    {
                        if (pszKey)
                        {
                            ASSERT(*psz==TEXT('='));
                            pNode = CreateKvNode( pszKey, psz + 1 );
                            pszKey = NULL;
                        }
                        else
                        {
                            pszKey = psz;
                            continue;
                        }
                    }

                    if (!pNode)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }

                    DtlAddNodeLast( pList, pNode );
                }
            }
        }
    }

    {
        PDESTROYNODE pfunc;

        if (dwNodeType == NT_Psz)
        {
            pfunc = DestroyPszNode;
        }
        else
        {
            pfunc = DestroyKvNode;
        }

        if (dwErr == 0)
        {
            DtlDestroyList( *ppListResult, pfunc );
            *ppListResult = pList;
        }
        else
        {
            DtlDestroyList( pList, pfunc );
        }
    }

    Free0( pszzResult );
    return 0;
}


DWORD
GetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult )

    // Set '*ppszResult' to the SZ registry value 'pszName' under key 'hkey'.
    // If the value does not exist *ppszResult' is set to empty string.
    //
    // Returns 0 if successful or an error code.  It is caller's
    // responsibility to Free the returned string.
    //
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cb = 0;
    TCHAR* pszResult;

    // Get result buffer size required.
    //
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, NULL, &cb );
    if (dwErr != 0)
    {
        cb = sizeof(TCHAR);
    }

    // Allocate result buffer.
    //
    pszResult = Malloc( cb );
    if (!pszResult)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *pszResult = TEXT('\0');
    *ppszResult = pszResult;

    // Get the result string.  It's not an error if we can't get it.
    //
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )pszResult, &cb );

    return 0;
}


DWORD
GetRegSzz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult )

    // Set '*ppszResult to the MULTI_SZ registry value 'pszName' under key
    // 'hkey', returned as a null-terminated list of null-terminated strings.
    // If the value does not exist, *ppszResult is set to an empty string
    // (single null character).
    //
    // Returns 0 if successful or an error code.  It is caller's
    // responsibility to Free the returned string.
    //
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cb = 0;
    TCHAR* pszResult;

    // Get result buffer size required.
    //
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, NULL, &cb );
    if (dwErr != 0)
    {
        cb = sizeof(TCHAR);
    }

    // Allocate result buffer.
    //
    pszResult = Malloc( cb );
    if (!pszResult)
        return ERROR_NOT_ENOUGH_MEMORY;

    *pszResult = TEXT('\0');
    *ppszResult = pszResult;

    // Get the result string list.  It's not an error if we can't get it.
    //
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )pszResult, &cb );

    return 0;
}


DWORD
RegDeleteTree(
    IN HKEY RootKey,
    IN TCHAR* SubKeyName )

    // Delete registry tree 'SubKeyName' under key 'RootKey'.
    //
    // (taken from Ted Miller's setup API)
    //
{
    DWORD d,err;

    d = RegDeleteTreeWorker(RootKey,SubKeyName,&err) ? NO_ERROR : err;

    if((d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
        d = NO_ERROR;
    }

    if(d == NO_ERROR) {
        //
        // Delete top-level key
        //
        d = RegDeleteKey(RootKey,SubKeyName);
        if((d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
            d = NO_ERROR;
        }
    }

    return(d);
}


BOOL
RegDeleteTreeWorker(
    IN  HKEY ParentKeyHandle,
    IN  TCHAR* KeyName,
    OUT DWORD* ErrorCode )

    // Delete all subkeys of a key whose name and parent's handle was passed
    // as parameter.  The algorithm used in this function guarantees that the
    // maximum number of descendent keys will be deleted.
    //
    // 'ParentKeyHandle' is a handle to the parent of the key that is
    // currently being examined.
    //
    // 'KeyName' is the name of the key that is currently being examined.
    // This name can be an empty string (but not a NULL pointer), and in this
    // case ParentKeyHandle refers to the key that is being examined.
    //
    // 'ErrorCode' is the address to receive a Win32 error code if the
    // function fails.
    //
    // Returns true if successful, false otherwise.
    //
    // (taken from Ted Miller's setup API)
    //
{
    HKEY     CurrentKeyTraverseAccess;
    DWORD    iSubKey;
    TCHAR    SubKeyName[MAX_PATH+1];
    DWORD    SubKeyNameLength;
    FILETIME ftLastWriteTime;
    LONG     Status;
    LONG     StatusEnum;
    LONG     SavedStatus;


    //
    //  Do not accept NULL pointer for ErrorCode
    //
    if(ErrorCode == NULL) {
        return(FALSE);
    }
    //
    //  Do not accept NULL pointer for KeyName.
    //
    if(KeyName == NULL) {
        *ErrorCode = ERROR_INVALID_PARAMETER;
        return(FALSE);
    }

    //
    // Open a handle to the key whose subkeys are to be deleted.
    // Since we need to delete its subkeys, the handle must have
    // KEY_ENUMERATE_SUB_KEYS access.
    //
    Status = RegOpenKeyEx(
                ParentKeyHandle,
                KeyName,
                0,
                KEY_ENUMERATE_SUB_KEYS | DELETE,
                &CurrentKeyTraverseAccess
                );

    if(Status != ERROR_SUCCESS) {
        //
        //  If unable to enumerate the subkeys, return error.
        //
        *ErrorCode = Status;
        return(FALSE);
    }

    //
    //  Traverse the key
    //
    iSubKey = 0;
    SavedStatus = ERROR_SUCCESS;
    do {
        //
        // Get the name of a subkey
        //
        SubKeyNameLength = sizeof(SubKeyName) / sizeof(TCHAR);
        StatusEnum = RegEnumKeyEx(
                        CurrentKeyTraverseAccess,
                        iSubKey,
                        SubKeyName,
                        &SubKeyNameLength,
                        NULL,
                        NULL,
                        NULL,
                        &ftLastWriteTime
                        );

        if(StatusEnum == ERROR_SUCCESS) {
            //
            // Delete all children of the subkey.
            // Just assume that the children will be deleted, and don't check
            // for failure.
            //
            RegDeleteTreeWorker(CurrentKeyTraverseAccess,SubKeyName,&Status);
            //
            // Now delete the subkey, and check for failure.
            //
            Status = RegDeleteKey(CurrentKeyTraverseAccess,SubKeyName);
            //
            // If unable to delete the subkey, then save the error code.
            // Note that the subkey index is incremented only if the subkey
            // was not deleted.
            //
            if(Status != ERROR_SUCCESS) {
                iSubKey++;
                SavedStatus = Status;
            }
        } else {
            //
            // If unable to get a subkey name due to ERROR_NO_MORE_ITEMS,
            // then the key doesn't have subkeys, or all subkeys were already
            // enumerated. Otherwise, an error has occurred, so just save
            // the error code.
            //
            if(StatusEnum != ERROR_NO_MORE_ITEMS) {
                SavedStatus = StatusEnum;
            }
        }
        //if((StatusEnum != ERROR_SUCCESS ) && (StatusEnum != ERROR_NO_MORE_ITEMS)) {
        //    printf( "RegEnumKeyEx() failed, Key Name = %ls, Status = %d, iSubKey = %d \n",KeyName,StatusEnum,iSubKey);
        //}
    } while(StatusEnum == ERROR_SUCCESS);

    //
    // Close the handle to the key whose subkeys were deleted, and return
    // the result of the operation.
    //
    RegCloseKey(CurrentKeyTraverseAccess);

    if(SavedStatus != ERROR_SUCCESS) {
        *ErrorCode = SavedStatus;
        return(FALSE);
    }
    return(TRUE);
}


BOOL
RegValueExists(
    IN HKEY hkey,
    IN TCHAR* pszValue )

    // Returns true if 'pszValue' is an existing value under 'hkey', false if
    // not.
    //
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cb = 0;

    dwErr = RegQueryValueEx( hkey, pszValue, NULL, &dwType, NULL, &cb );
    return !!(dwErr == 0);
}


DWORD
SetRegDword(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN DWORD  dwValue )

    // Set registry value 'pszName' under key 'hkey' to REG_DWORD value
    // 'dwValue'.
    //
    // Returns 0 is successful or an error code.
    //
{
    return RegSetValueEx(
        hkey, pszName, 0, REG_DWORD, (LPBYTE )&dwValue, sizeof(dwValue) );
}


DWORD
SetRegMultiSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN DTLLIST* pListValues,
    IN DWORD dwNodeType )

    // Set registry value 'pszName' under key 'hkey' to a REG_MULTI_SZ value
    // containing the strings in the Psz list 'pListValues'.  'DwNodeType'
    // determines the type of node.
    //
    // Returns 0 is successful or an error code.
    //
{
    DWORD dwErr;
    DWORD cb;
    DTLNODE* pNode;
    TCHAR* pszzValues;
    TCHAR* pszValue;

    // Count up size of MULTI_SZ buffer needed.
    //
    cb = sizeof(TCHAR);
    for (pNode = DtlGetFirstNode( pListValues );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        if (dwNodeType == NT_Psz)
        {
            TCHAR* psz;
            psz = (TCHAR* )DtlGetData( pNode );
            ASSERT(psz);
            cb += (lstrlen( psz ) + 1) * sizeof(TCHAR);
        }
        else
        {
            KEYVALUE* pkv;

            ASSERT(dwNodeType==NT_Kv);
            pkv = (KEYVALUE* )DtlGetData( pNode );
            ASSERT(pkv);
            ASSERT(pkv->pszKey);
            ASSERT(pkv->pszValue);
            cb += (lstrlen( pkv->pszKey ) + 1
                      + 1 + lstrlen( pkv->pszValue ) + 1) * sizeof(TCHAR);
        }
    }

    if (cb == sizeof(TCHAR))
    {
        cb += sizeof(TCHAR);
    }

    // Allocate MULTI_SZ buffer.
    //
    pszzValues = Malloc( cb );
    if (!pszzValues)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Fill MULTI_SZ buffer from list.
    //
    if (cb == 2 * sizeof(TCHAR))
    {
        pszzValues[ 0 ] = pszzValues[ 1 ] = TEXT('\0');
    }
    else
    {
        pszValue = pszzValues;
        for (pNode = DtlGetFirstNode( pListValues );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            if (dwNodeType == NT_Psz)
            {
                TCHAR* psz;

                psz = (TCHAR* )DtlGetData( pNode );
                ASSERT(psz);
                lstrcpy( pszValue, psz );
                pszValue += lstrlen( pszValue ) + 1;
            }
            else
            {
                KEYVALUE* pkv;

                pkv = (KEYVALUE* )DtlGetData( pNode );
                ASSERT(pkv);
                ASSERT(pkv->pszKey);
                ASSERT(pkv->pszValue);
                lstrcpy( pszValue, pkv->pszKey );
                pszValue += lstrlen( pszValue ) + 1;
                *pszValue = TEXT('=');
                ++pszValue;
                lstrcpy( pszValue, pkv->pszValue );
                pszValue += lstrlen( pszValue ) + 1;
            }
        }

        *pszValue = TEXT('\0');
    }

    /* Set registry value from MULTI_SZ buffer.
    */
    dwErr = RegSetValueEx(
        hkey, pszName, 0, REG_MULTI_SZ, (LPBYTE )pszzValues, cb );

    Free( pszzValues );
    return dwErr;
}


DWORD
SetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue )

    // Set registry value 'pszName' under key 'hkey' to a REG_SZ value
    // 'pszValue'.
    //
    // Returns 0 is successful or an error code.
    //
{
    TCHAR* psz;

    if (pszValue)
    {
        psz = pszValue;
    }
    else
    {
        psz = TEXT("");
    }

    return
        RegSetValueEx(
            hkey, pszName, 0, REG_SZ,
            (LPBYTE )psz, (lstrlen( psz ) + 1) * sizeof(TCHAR) );
}


DWORD
SetRegSzz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue )

    // Set registry value 'pszName' under key 'hkey' to a REG_MULTI_SZ value
    // 'pszValue'.
    //
    // Returns 0 is successful or an error code.
    //
{
    DWORD cb;
    TCHAR* psz;

    cb = sizeof(TCHAR);
    if (!pszValue)
    {
        psz = TEXT("");
    }
    else
    {
        INT nLen;

        for (psz = pszValue; *psz; psz += nLen)
        {
            nLen = lstrlen( psz ) + 1;
            cb += nLen * sizeof(TCHAR);
        }

        psz = pszValue;
    }

    return RegSetValueEx( hkey, pszName, 0, REG_MULTI_SZ, (LPBYTE )psz, cb );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\rassrv.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rassrv.c
** RAS Server helpers
** Listed alphabetically
**
** 03/05/96 Abolade Gbadegesin
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Our public header
#include <raserror.h> // RAS error constants


HANDLE g_hserver = NULL;

DWORD
RasServerConnect(
    IN  HANDLE*  phserver );


DWORD
GetRasConnection0Table(
    OUT RAS_CONNECTION_0 ** ppRc0Table,
    OUT DWORD *             piRc0Count )

    /* This function queries the RAS server for a table of the inbound
    ** connections on the local machine.
    **
    ** (Abolade Gbadegesin Mar-05-1996)
    */
{

    DWORD dwErr, dwTotal;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return dwErr; }

    return g_pRasAdminConnectionEnum(
                g_hserver,
                0,
                (BYTE**)ppRc0Table,
                (DWORD)-1,
                piRc0Count,
                &dwTotal,
                NULL
                );
}



DWORD
GetRasdevFromRasPort0(
    IN  RAS_PORT_0* pport,
    OUT RASDEV**    ppdev,
    IN  RASDEV*     pDevTable OPTIONAL,
    IN  DWORD       iDevCount OPTIONAL )

    /* Given a RAS_PORT_0 structure, this function
    ** retrieves the RASDEV for the device referred to by the RAS_PORT_0.
    ** The second and third arguments are optional; they specify a
    ** table of RASDEV structures to be searched.  This is useful if the
    ** caller has already enumerated the existing devices, so that this
    ** function does not need to re-enumerate them.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    DWORD i, dwErr;
    BOOL bFreeTable;
    TCHAR szPort[MAX_PORT_NAME + 1], *pszPort;

    //
    // validate the arguments
    //

    if (pport == NULL || ppdev == NULL) { return ERROR_INVALID_PARAMETER; }

    *ppdev = NULL;

    //
    // retrieve the device table if the caller didn't pass one in
    //

    bFreeTable = FALSE;

    if (pDevTable == NULL) {

        dwErr = GetRasdevTable(&pDevTable, &iDevCount);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        bFreeTable = TRUE;
    }

    //
    // retrieve the portname for the RAS_PORT_0 passed in
    //

#ifdef UNICODE
    pszPort = pport->wszPortName;
#else
    StrCpyAFromW(
        szPort, 
        pport->wszPortName,
        MAX_PORT_NAME + 1);
    pszPort = szPort;
#endif

    //
    // find the device to which the HPORT corresponds
    //

    for (i = 0; i < iDevCount; i++) {
        if (lstrcmpi(pszPort, (pDevTable + i)->RD_PortName) == 0) { break; }
    }


    //
    // see how the search ended
    //

    if (i >= iDevCount) {
        dwErr = ERROR_NO_DATA;
    }
    else {

        dwErr = NO_ERROR;

        if (!bFreeTable) {
            *ppdev = pDevTable + i;
        }
        else {

            *ppdev = Malloc(sizeof(RASDEV));

            if (!*ppdev) { dwErr = ERROR_NOT_ENOUGH_MEMORY; }
            else {

                **ppdev = *(pDevTable + i);

                (*ppdev)->RD_DeviceName = StrDup(pDevTable[i].RD_DeviceName);

                if (!(*ppdev)->RD_DeviceName) {
                    Free(*ppdev);
                    *ppdev = NULL;
                    dwErr = ERROR_NOT_ENOUGH_MEMORY; 
                }
            }
        }
    }

    if (bFreeTable) { FreeRasdevTable(pDevTable, iDevCount); }

    return dwErr;
}



DWORD
GetRasPort0FromRasdev(
    IN RASDEV*          pdev,
    OUT RAS_PORT_0**    ppport,
    IN RAS_PORT_0*      pPortTable OPTIONAL,
    IN DWORD            iPortCount OPTIONAL )

    /* Given a RASDEV structure for an active device, this function retrieves
    ** the RAS_PORT_0 which corresponds to the device.  The
    ** second and third arguments are optional; they specify a table of
    ** RAS_PORT_0 structures to be searched.  This is useful if the caller has
    ** already enumerated the server's ports, so that this function does
    ** not need to re-enumerate them.
    **
    ** (Abolade Gbadegesin Feb-13-1996)
    */
{
    BOOL bFreeTable;
    DWORD dwErr, i;
    WCHAR wszPort[MAX_PORT_NAME + 1], *pwszPort;

    //
    // validate arguments
    //

    if (pdev == NULL || ppport == NULL) { return ERROR_INVALID_PARAMETER; }

    *ppport = NULL;

    bFreeTable = FALSE;

    //
    // if the caller didn't pass in a table of RAS_PORT_0's, retrieve one
    //

    if (pPortTable == NULL) {

        dwErr = GetRasPort0Table(&pPortTable, &iPortCount);

        if (dwErr != NO_ERROR) { return dwErr; }

        bFreeTable = TRUE;
    }


    //
    // find the admin port which matches the RASDEV passed in
    //

#ifdef UNICODE
    pwszPort = pdev->RD_PortName;
#else
    StrCpyWFromA(wszPort, pdev->P_PortName, MAX_PORT_NAME);
    pwszPort = wszPort;
#endif

    for (i = 0; i < iPortCount; i++) {
        if (lstrcmpiW(pwszPort, (pPortTable + i)->wszPortName) == 0) {
            break;
        }
    }

    //
    // see how the search ended
    //

    if (i >= iPortCount) {
        dwErr = ERROR_NO_DATA;
    }
    else {

        dwErr = NO_ERROR;

        if (!bFreeTable) {

            //
            // point to the place where we found the RAS_PORT_0
            //

            *ppport = pPortTable + i;
        }
        else {

            //
            // make a copy of the RAS_PORT_0 found
            //

            *ppport = Malloc(sizeof(RAS_PORT_0));

            if (!*ppport) { dwErr = ERROR_NOT_ENOUGH_MEMORY; }
            else { **ppport = *(pPortTable + i); }
        }
    }

    if (bFreeTable) { g_pRasAdminBufferFree(pPortTable); }

    return dwErr;
}



DWORD
GetRasPort0Info(
    IN  HANDLE                  hPort,
    OUT RAS_PORT_1 *            pRasPort1 )

    /* This function queries the local RAS server for information
    ** about the specified port.
    **
    ** (Abolade Gbadegesin Mar-05-1996)
    */
{

    DWORD dwErr;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return dwErr; }

    return g_pRasAdminPortGetInfo(
                g_hserver,
                1,
                hPort,
                (BYTE**)&pRasPort1
                );
}



DWORD
GetRasPort0Table(
    OUT RAS_PORT_0 **   ppPortTable,
    OUT DWORD *         piPortCount )

    /* This function queries the RAS server for a table of the dial-in ports
    ** on the local machine.
    **
    ** (Abolade Gbadegesin Mar-05-1996)
    */
{

    DWORD dwErr;
    DWORD dwTotal;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return dwErr; }

    dwErr = g_pRasAdminPortEnum(
                g_hserver,
                0,
                INVALID_HANDLE_VALUE,
                (BYTE**)ppPortTable,
                (DWORD)-1,
                piPortCount,
                &dwTotal,
                NULL
                );

    return dwErr;
}



TCHAR *
GetRasPort0UserString(
    IN  RAS_PORT_0 *    pport,
    IN  TCHAR *         pszUser OPTIONAL )

    /* This function formats the user and domain in the specified port
    ** as a standard DOMAINNAME\username string and returns the result,
    ** unless the argument 'pszUser' is non-NULL in which case 
    ** the result is formatted into the given string.
    **
    ** (Abolade Gbadegesin Mar-06-1996)
    */
{

    DWORD dwErr;
    PTSTR psz = NULL;
    RAS_CONNECTION_0 *prc0 = NULL;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return NULL; }

    do {

        dwErr = g_pRasAdminConnectionGetInfo(
                    g_hserver,
                    0,
                    pport->hConnection,
                    (BYTE**)&prc0
                    );
    
        if (dwErr != NO_ERROR) { break; }
    
    
        if (pszUser) { psz = pszUser; }
        else {
        
            psz = Malloc(
                    (lstrlenW(prc0->wszUserName) +
                     lstrlenW(prc0->wszLogonDomain) + 2) * sizeof(TCHAR)
                    );
        
            if (!psz) { break; }
        }
    
        wsprintf(psz, TEXT("%ls\\%ls"), prc0->wszLogonDomain, prc0->wszUserName);
    
    } while(FALSE);

    if (prc0) { g_pRasAdminBufferFree(prc0); }

    return psz;
}





DWORD
RasPort0Hangup(
    IN  HANDLE      hPort )

    /* This function hangs up the specified dial-in port
    ** on the local RAS server.
    **
    ** (Abolade Gbadegesin Mar-05-1996)
    */
{
    DWORD dwErr;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return dwErr; }

    dwErr = g_pRasAdminPortDisconnect(g_hserver, hPort);

    return dwErr;
}



DWORD
RasServerConnect(
    IN  HANDLE*  phserver )

    /* This function establishes a connection to the local MPR RAS server,
    ** if the connection has not already been established.
    */
{
    DWORD dwErr;

    if (*phserver) { return NO_ERROR; }

    dwErr = g_pRasAdminServerConnect(NULL, phserver);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\pbuser.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pbuser.c
** User preference storage routines
** Listed alphabetically
**
** 10/31/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Heap macros
#include <pbuser.h>   // Our public header
#include <rasdlg.h>   // RAS common dialog header for RASMD_*


/* Default user preference settings.
*/
static const PBUSER g_pbuserDefaults =
{
    FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE,
    0, 15, 1200, FALSE, TRUE, FALSE,
    CBM_Maybe, NULL, NULL,
    PBM_System, NULL, NULL, NULL,
    NULL, FALSE,
    NULL, NULL, NULL,
    0x7FFFFFFF, 0x7FFFFFFF, NULL,
    FALSE, FALSE
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
GetCallbackList(
    IN  HKEY      hkey,
    OUT DTLLIST** ppListResult );

VOID
GetLocationList(
    IN  HKEY      hkey,
    OUT DTLLIST** ppListResult );

VOID
MoveLogonPreferences(
    void );

VOID
MoveUserPreferences(
    void );

DWORD
ReadUserPreferences(
    IN  HKEY    hkey,
    OUT PBUSER* pUser );

DWORD
SetCallbackList(
    IN HKEY     hkey,
    IN DTLLIST* pList );

DWORD
SetDefaultUserPreferences(
    OUT PBUSER* pUser,
    IN  DWORD   dwMode );

DWORD
SetLocationList(
    IN HKEY     hkey,
    IN DTLLIST* pList );

DWORD
WriteUserPreferences(
    IN HKEY    hkey,
    IN PBUSER* pUser );


/*----------------------------------------------------------------------------
** Phonebook preference routines (alphabetically)
**----------------------------------------------------------------------------
*/

DTLNODE*
CreateLocationNode(
    IN DWORD dwLocationId,
    IN DWORD iPrefix,
    IN DWORD iSuffix )

    /* Returns a LOCATIONINFO node associated with TAPI location
    ** 'dwLocationId', prefix index 'iPrefix' and suffix index 'iSuffix'.
    */
{
    DTLNODE*      pNode;
    LOCATIONINFO* pInfo;

    pNode = DtlCreateSizedNode( sizeof(LOCATIONINFO), 0L );
    if (!pNode)
        return NULL;

    pInfo = (LOCATIONINFO* )DtlGetData( pNode );
    pInfo->dwLocationId = dwLocationId;
    pInfo->iPrefix = iPrefix;
    pInfo->iSuffix = iSuffix;

    return pNode;
}


DTLNODE*
CreateCallbackNode(
    IN TCHAR* pszPortName,
    IN TCHAR* pszDeviceName,
    IN TCHAR* pszNumber,
    IN DWORD  dwDeviceType )

    /* Returns a CALLBACKINFO node containing a copy of 'pszPortName',
    ** 'pszDeviceName' and 'pszNumber' and 'dwDeviceType' or NULL on error.
    ** It is caller's responsibility to DestroyCallbackNode the returned node.
    */
{
    DTLNODE*      pNode;
    CALLBACKINFO* pInfo;

    pNode = DtlCreateSizedNode( sizeof(CALLBACKINFO), 0L );
    if (!pNode)
        return NULL;

    pInfo = (CALLBACKINFO* )DtlGetData( pNode );
    pInfo->pszPortName = StrDup( pszPortName );
    pInfo->pszDeviceName = StrDup( pszDeviceName );
    pInfo->pszNumber = StrDup( pszNumber );
    pInfo->dwDeviceType = dwDeviceType;

    if (!pInfo->pszPortName || !pInfo->pszDeviceName || !pInfo->pszNumber)
    {
        Free0( pInfo->pszPortName );
        Free0( pInfo->pszDeviceName );
        Free0( pInfo->pszNumber );
        DtlDestroyNode( pNode );
        return NULL;
    }

    return pNode;
}


VOID
DestroyLocationNode(
    IN DTLNODE* pNode )

    /* Release memory allociated with location node 'pNode'.
    */
{
    DtlDestroyNode( pNode );
}


VOID
DestroyCallbackNode(
    IN DTLNODE* pNode )

    /* Release memory allociated with callback node 'pNode'.
    */
{
    CALLBACKINFO* pInfo;

    ASSERT(pNode);
    pInfo = (CALLBACKINFO* )DtlGetData( pNode );
    ASSERT(pInfo);

    Free0( pInfo->pszPortName );
    Free0( pInfo->pszDeviceName );
    Free0( pInfo->pszNumber );

    DtlDestroyNode( pNode );
}


VOID
DestroyUserPreferences(
    IN PBUSER* pUser )

    /* Releases memory allocated by GetUserPreferences and zeros the
    ** structure.
    */
{
    if (pUser->fInitialized)
    {
        DtlDestroyList( pUser->pdtllistCallback, DestroyCallbackNode );
        DtlDestroyList( pUser->pdtllistPhonebooks, DestroyPszNode );
        DtlDestroyList( pUser->pdtllistAreaCodes, DestroyPszNode );
        DtlDestroyList( pUser->pdtllistPrefixes, DestroyPszNode );
        DtlDestroyList( pUser->pdtllistSuffixes, DestroyPszNode );
        DtlDestroyList( pUser->pdtllistLocations, DestroyLocationNode );
        Free0( pUser->pszPersonalFile );
        Free0( pUser->pszAlternatePath );
        Free0( pUser->pszLastCallbackByCaller );
        Free0( pUser->pszDefaultEntry );
    }

    ZeroMemory( pUser, sizeof(*pUser) );
}


DTLNODE*
DuplicateLocationNode(
    IN DTLNODE* pNode )

    /* Duplicates LOCATIONINFO node 'pNode'.  See DtlDuplicateList.
    **
    ** Returns the address of the allocated node or NULL if out of memory.  It
    ** is caller's responsibility to free the returned node.
    */
{
    LOCATIONINFO* pInfo = (LOCATIONINFO* )DtlGetData( pNode );

    return CreateLocationNode(
        pInfo->dwLocationId, pInfo->iPrefix, pInfo->iSuffix );
}


DWORD
DwGetUserPreferences(
    OUT PBUSER* pUser,
    IN  DWORD   dwMode )

    /* Load caller's 'pUser' with user phonebook preferences from the
    ** registry.  'DwMode' indicates the preferences to get, either the normal
    ** interactive user, the pre-logon, or router preferences.
    **
    ** Returns 0 if successful or an error code.  If successful, caller should
    ** eventually call DestroyUserPreferences to release the returned heap
    ** buffers.
    */
{
    DWORD dwErr;

    TRACE1("GetUserPreferences(m=%d)",dwMode);

    /* Move the user preferences, if it's not already been done.
    */
    if (dwMode == UPM_Normal)
        MoveUserPreferences();
    else if (dwMode == UPM_Logon)
        MoveLogonPreferences();

    dwErr = SetDefaultUserPreferences( pUser, dwMode );
    if (dwErr == 0)
    {
        HKEY  hkey;
        DWORD dwErr2;

        if (dwMode == UPM_Normal)
        {
            dwErr2 = RegOpenKeyEx(
                HKEY_CURRENT_USER, (LPCTSTR )REGKEY_HkcuRas,
                0, KEY_READ, &hkey );
        }
        else if (dwMode == UPM_Logon)
        {
            dwErr2 = RegOpenKeyEx(
                HKEY_USERS, (LPCTSTR )REGKEY_HkuRasLogon,
                0, KEY_READ, &hkey );
        }
        else
        {
            ASSERT(dwMode==UPM_Router);
            dwErr2 = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE, (LPCTSTR )REGKEY_HklmRouter,
                0, KEY_READ, &hkey );
        }

        if (dwErr2 == 0)
        {
            if (ReadUserPreferences( hkey, pUser ) != 0)
                dwErr = SetDefaultUserPreferences( pUser, dwMode );
            RegCloseKey( hkey );
        }
        else
        {
            TRACE1("RegOpenKeyEx=%d",dwErr2);
        }
    }

    TRACE1("GetUserPreferences=%d",dwErr);
    return dwErr;
}

DWORD
GetUserPreferences(HANDLE hConnection,
                   PBUSER *pUser,
                   DWORD dwMode)
{
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    DWORD dwError = ERROR_SUCCESS;

    if(     NULL == pRasRpcConnection
        ||  pRasRpcConnection->fLocal)
    {
        dwError = DwGetUserPreferences(pUser, dwMode);
    }
    else
    {
        dwError = RemoteGetUserPreferences(hConnection,
                                           pUser,
                                           dwMode);
    }

    return dwError;
}


DWORD
DwSetUserPreferences(
    IN PBUSER* pUser,
    IN DWORD   dwMode )

    /* Set current user phonebook preferences in the registry from caller's
    ** settings in 'pUser', if necessary.  'DwMode' indicates the preferences
    ** to get, either the normal interactive user, the pre-logon, or router
    ** preferences.
    **
    ** Returns 0 if successful, or an error code.  Caller's 'pUser' is marked
    ** clean if successful.
    */
{
    DWORD dwErr;
    DWORD dwDisposition;
    HKEY  hkey;

    TRACE1("SetUserPreferences(m=%d)",dwMode);

    if (!pUser->fDirty)
        return 0;

    /* Create the preference key, or if it exists just open it.
    */
    if (dwMode == UPM_Normal)
    {
        dwErr = RegCreateKeyEx( HKEY_CURRENT_USER, REGKEY_HkcuRas,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }
    else if (dwMode == UPM_Logon)
    {
        dwErr = RegCreateKeyEx( HKEY_USERS, REGKEY_HkuRasLogon,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }
    else
    {
        ASSERT(dwMode==UPM_Router);
        dwErr = RegCreateKeyEx( HKEY_LOCAL_MACHINE, REGKEY_HklmRouter,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }

    if (dwErr == 0)
    {
        dwErr = WriteUserPreferences( hkey, pUser );
        RegCloseKey( hkey );
    }

    TRACE1("SetUserPreferences=%d",dwErr);
    return dwErr;
}


DWORD
SetUserPreferences(HANDLE hConnection,
                   PBUSER *pUser,
                   DWORD  dwMode)
{
    DWORD dwError = ERROR_SUCCESS;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if(     NULL == pRasRpcConnection
        ||  pRasRpcConnection->fLocal)
    {
        dwError = DwSetUserPreferences(pUser, dwMode);
    }
    else
    {
        dwError = RemoteSetUserPreferences(hConnection,
                                           pUser,
                                           dwMode);
    }

    return dwError;
}

// Reads the operator assisted dial user parameter directly from
// the registry.
DWORD SetUserManualDialEnabling (
    IN OUT BOOL bEnable,
    IN DWORD dwMode )
{
    DWORD dwErr;
    DWORD dwDisposition;
    HKEY  hkey;

    TRACE2("SetUserManualDialEnabling (en=%d) (m=%d)",bEnable, dwMode);

    /* Create the preference key, or if it exists just open it.
    */
    if (dwMode == UPM_Normal)
    {
        dwErr = RegCreateKeyEx( HKEY_CURRENT_USER, REGKEY_HkcuRas,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }
    else if (dwMode == UPM_Logon)
    {
        dwErr = RegCreateKeyEx( HKEY_USERS, REGKEY_HkuRasLogon,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }
    else
        return ERROR_INVALID_PARAMETER;

    if (dwErr != 0)
        return dwErr;

    dwErr = SetRegDword( hkey, REGVAL_fOperatorDial,
                         !!bEnable );
    RegCloseKey( hkey );

    return dwErr;
}

// Sets the operator assisted dialing parameter directly in the
// registry.
DWORD GetUserManualDialEnabling (
    IN PBOOL pbEnabled,
    IN DWORD dwMode )
{
    DWORD dwErr;
    DWORD dwDisposition;
    HKEY  hkey;

    TRACE1("GetUserManualDialEnabling (m=%d)", dwMode);

    if (!pbEnabled)
        return ERROR_INVALID_PARAMETER;

    // Set defaults
    *pbEnabled = g_pbuserDefaults.fOperatorDial;

    /* Create the preference key, or if it exists just open it.
    */
    if (dwMode == UPM_Normal)
    {
        dwErr = RegCreateKeyEx( HKEY_CURRENT_USER, REGKEY_HkcuRas,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }
    else if (dwMode == UPM_Logon)
    {
        dwErr = RegCreateKeyEx( HKEY_USERS, REGKEY_HkuRasLogon,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }
    else
        return ERROR_INVALID_PARAMETER;

    if (dwErr != 0)
        return dwErr;

    GetRegDword( hkey, REGVAL_fOperatorDial,
                 pbEnabled );

    RegCloseKey( hkey );

    return dwErr;
}

/*----------------------------------------------------------------------------
** Utilities (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
GetCallbackList(
    IN  HKEY      hkey,
    OUT DTLLIST** ppListResult )

    /* Replaces '*ppListResult' with a list containing a node for each device
    ** name under registry value "REGVAL_szCallback" of registry key 'hkey'.
    ** If no values exist *ppListResult' is replaced with an empty list.
    **
    ** It is caller's responsibility to destroy the returned list if non-NULL.
    */
{
    DWORD    dwErr;
    TCHAR    szDP[ RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1 ];
    TCHAR*   pszDevice;
    TCHAR*   pszPort;
    TCHAR*   pszNumber;
    DWORD    dwDeviceType;
    DWORD    cb;
    INT      i;
    DTLLIST* pList;
    DTLNODE* pNode;
    HKEY     hkeyCb;
    HKEY     hkeyDP;

    pList = DtlCreateList( 0 );
    if (!pList)
        return;

    dwErr = RegOpenKeyEx( hkey, REGKEY_Callback, 0, KEY_READ, &hkeyCb );
    if (dwErr == 0)
    {
        for (i = 0; TRUE; ++i)
        {
            cb = sizeof(szDP)/sizeof(TCHAR);
            dwErr = RegEnumKeyEx(
                        hkeyCb, i, szDP, &cb, NULL, NULL, NULL, NULL );
            if (dwErr == ERROR_NO_MORE_ITEMS)
                break;
            if (dwErr != 0)
                continue;

            /* Ignore keys not of the form "device (port)".
            */
            if (!DeviceAndPortFromPsz( szDP, &pszDevice, &pszPort ))
                continue;

            dwErr = RegOpenKeyEx( hkeyCb, szDP, 0, KEY_READ, &hkeyDP );
            if (dwErr == 0)
            {
                GetRegDword( hkeyDP, REGVAL_dwDeviceType, &dwDeviceType );

                dwErr = GetRegSz( hkeyDP, REGVAL_szNumber, &pszNumber );
                if (dwErr == 0)
                {
                    pNode = CreateCallbackNode(
                                pszPort, pszDevice, pszNumber, dwDeviceType );
                    if (pNode)
                        DtlAddNodeLast( pList, pNode );
                    Free( pszNumber );
                }

                RegCloseKey( hkeyDP );
            }

            Free( pszDevice );
            Free( pszPort );
        }

        RegCloseKey( hkeyCb );
    }

    DtlDestroyList( *ppListResult, DestroyCallbackNode );
    *ppListResult = pList;
}


VOID
GetLocationList(
    IN  HKEY      hkey,
    OUT DTLLIST** ppListResult )

    /* Replaces '*ppListResult' with a list containing a node for each
    ** location under registry value "REGVAL_szLocation" of registry key
    ** 'hkey'.  If no values exist *ppListResult' is replaced with an empty
    ** list.
    **
    ** It is caller's responsibility to destroy the returned list if non-NULL.
    */
{
    DWORD    dwErr;
    TCHAR    szId[ MAXLTOTLEN + 1 ];
    DWORD    cb;
    INT      i;
    DTLLIST* pList;
    DTLNODE* pNode;
    HKEY     hkeyL;
    HKEY     hkeyId;

    pList = DtlCreateList( 0 );
    if (!pList)
        return;

    dwErr = RegOpenKeyEx( hkey, REGKEY_Location, 0, KEY_READ, &hkeyL );
    if (dwErr == 0)
    {
        for (i = 0; TRUE; ++i)
        {
            cb = MAXLTOTLEN + 1;
            dwErr = RegEnumKeyEx( hkeyL, i, szId, &cb, NULL, NULL, NULL, NULL );
            if (dwErr == ERROR_NO_MORE_ITEMS)
                break;
            if (dwErr != 0)
                continue;

            dwErr = RegOpenKeyEx( hkeyL, szId, 0, KEY_READ, &hkeyId );
            if (dwErr == 0)
            {
                DWORD dwId;
                DWORD iPrefix;
                DWORD iSuffix;

                dwId = (DWORD )TToL( szId );
                iPrefix = 0;
                GetRegDword( hkeyId, REGVAL_dwPrefix, &iPrefix );
                iSuffix = 0;
                GetRegDword( hkeyId, REGVAL_dwSuffix, &iSuffix );

                pNode = CreateLocationNode( dwId, iPrefix, iSuffix );
                if (!pNode)
                    continue;

                DtlAddNodeLast( pList, pNode );

                RegCloseKey( hkeyId );
            }
        }

        RegCloseKey( hkeyL );
    }

    DtlDestroyList( *ppListResult, DestroyLocationNode );
    *ppListResult = pList;
}


VOID
MoveLogonPreferences(
    void )

    /* Move logon preferences from the NT 4.0 location to a new unique
    ** position, if necessary.  This manuever is added because in NT 4.0 user
    ** preference calls from LocalSystem service use the old logon location at
    ** HKU\.DEFAULT due to fallbacks in the registry APIs causing logon and
    ** LocalSystem settings to overwrite each other.
    */
{
    DWORD  dwErr;
    HKEY   hkeyOld;
    HKEY   hkeyNew;
    PBUSER user;

    dwErr = RegOpenKeyEx(
        HKEY_USERS, (LPCTSTR )REGKEY_HkuOldRasLogon,
        0, KEY_READ, &hkeyOld );
    if (dwErr != 0)
        return;

    dwErr = RegOpenKeyEx(
        HKEY_USERS, (LPCTSTR )REGKEY_HkuRasLogon,
        0, KEY_READ, &hkeyNew );
    if (dwErr == 0)
        RegCloseKey( hkeyNew );
    else
    {
        /* Old tree exists and new tree doesn't.  Move a copy of the old tree
        ** to the new tree.
        */
        dwErr = SetDefaultUserPreferences( &user, UPM_Logon );
        if (dwErr == 0)
        {
            dwErr = ReadUserPreferences( hkeyOld, &user );
            if (dwErr == 0)
                dwErr = SetUserPreferences( NULL, &user, UPM_Logon );
        }

        DestroyUserPreferences( &user );
        TRACE1("MoveLogonPreferences=%d",dwErr);
    }

    RegCloseKey( hkeyOld );
}


VOID
MoveUserPreferences(
    void )

    /* Move user preferences from their old net-tools registry location to the
    ** new location nearer the other RAS keys.
    */
{
    DWORD dwErr;
    HKEY  hkeyOld;
    HKEY  hkeyNew;

    /* See if the old current-user key exists.
    */
    dwErr = RegOpenKeyEx(
        HKEY_CURRENT_USER, (LPCTSTR )REGKEY_HkcuOldRas, 0,
        KEY_ALL_ACCESS, &hkeyOld );

    if (dwErr == 0)
    {
        PBUSER user;

        /* Read the preferences at the old key.
        */
        TRACE("Getting old prefs");
        dwErr = SetDefaultUserPreferences( &user, UPM_Normal );
        if (dwErr == 0)
        {
            dwErr = ReadUserPreferences( hkeyOld, &user );
            if (dwErr == 0)
            {
                /* Write the preferences at the new key.
                */
                user.fDirty = TRUE;
                dwErr = SetUserPreferences( NULL, &user, FALSE );
                if (dwErr == 0)
                {
                    /* Blow away the old tree.
                    */
                    dwErr = RegOpenKeyEx(
                        HKEY_CURRENT_USER, (LPCTSTR )REGKEY_HkcuOldRasParent,
                        0, KEY_ALL_ACCESS, &hkeyNew );
                    if (dwErr == 0)
                    {
                        TRACE("Delete old prefs");
                        dwErr = RegDeleteTree( hkeyNew, REGKEY_HkcuOldRasRoot );
                        RegCloseKey( hkeyNew );
                    }
                }
            }
        }

        RegCloseKey( hkeyOld );

        TRACE1("MoveUserPreferences=%d",dwErr);
    }
}


DWORD
ReadUserPreferences(
    IN  HKEY    hkey,
    OUT PBUSER* pUser )

    /* Fill caller's 'pUser' buffer with user preferences from RAS-Phonebook
    ** registry tree 'hkey'.
    **
    ** Returns 0 if successful, false otherwise.
    */
{
    BOOL  fOldSettings;
    DWORD dwErr;

    TRACE("ReadUserPreferences");

    /* Read the values.
    */
    {
        DWORD dwMode;

        /* Lack of a phonebook mode key indicates that we are updating old NT
        ** 3.51-style settings.
        */
        dwMode = 0xFFFFFFFF;
        GetRegDword( hkey, REGVAL_dwPhonebookMode, &dwMode );
        if (dwMode != 0xFFFFFFFF)
        {
            pUser->dwPhonebookMode = dwMode;
            fOldSettings = FALSE;
        }
        else
            fOldSettings = TRUE;
    }

    GetRegDword( hkey, REGVAL_fOperatorDial,
        &pUser->fOperatorDial );
    GetRegDword( hkey, REGVAL_fPreviewPhoneNumber,
        &pUser->fPreviewPhoneNumber );
    GetRegDword( hkey, REGVAL_fUseLocation,
        &pUser->fUseLocation );
    GetRegDword( hkey, REGVAL_fShowLights,
        &pUser->fShowLights );
    GetRegDword( hkey, REGVAL_fShowConnectStatus,
        &pUser->fShowConnectStatus );
    GetRegDword( hkey, REGVAL_fNewEntryWizard,
        &pUser->fNewEntryWizard );
    GetRegDword( hkey, REGVAL_fCloseOnDial,
        &pUser->fCloseOnDial );
    GetRegDword( hkey, REGVAL_fAllowLogonPhonebookEdits,
        &pUser->fAllowLogonPhonebookEdits );
    GetRegDword( hkey, REGVAL_fAllowLogonLocationEdits,
        &pUser->fAllowLogonLocationEdits );
    GetRegDword( hkey, REGVAL_fSkipConnectComplete,
        &pUser->fSkipConnectComplete );
    GetRegDword( hkey, REGVAL_dwRedialAttempts,
        &pUser->dwRedialAttempts );
    GetRegDword( hkey, REGVAL_dwRedialSeconds,
        &pUser->dwRedialSeconds );
    GetRegDword( hkey, REGVAL_dwIdleDisconnectSeconds,
        &pUser->dwIdleDisconnectSeconds );
    GetRegDword( hkey, REGVAL_fRedialOnLinkFailure,
        &pUser->fRedialOnLinkFailure );
    GetRegDword( hkey, REGVAL_fPopupOnTopWhenRedialing,
        &pUser->fPopupOnTopWhenRedialing );
    GetRegDword( hkey, REGVAL_fExpandAutoDialQuery,
        &pUser->fExpandAutoDialQuery );
    GetRegDword( hkey, REGVAL_dwCallbackMode,
        &pUser->dwCallbackMode );
    GetRegDword( hkey, REGVAL_fUseAreaAndCountry,
        &pUser->fUseAreaAndCountry );
    GetRegDword( hkey, REGVAL_dwXWindow,
        &pUser->dwXPhonebook );
    GetRegDword( hkey, REGVAL_dwYWindow,
        &pUser->dwYPhonebook );

    //
    // For NT5, we ignore the "require wizard" setting since
    // we always require the user to use the wizard to create
    // new connections
    //
    pUser->fNewEntryWizard = TRUE;

    do
    {
        GetCallbackList( hkey, &pUser->pdtllistCallback );

        dwErr = GetRegMultiSz( hkey, REGVAL_mszPhonebooks,
            &pUser->pdtllistPhonebooks, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = GetRegMultiSz( hkey, REGVAL_mszAreaCodes,
            &pUser->pdtllistAreaCodes, NT_Psz );
        if (dwErr != 0)
            break;

        /* If the prefixes key doesn't exist don't read an empty list over the
        ** defaults.
        */
        if (RegValueExists( hkey, REGVAL_mszPrefixes ))
        {
            dwErr = GetRegMultiSz( hkey, REGVAL_mszPrefixes,
                &pUser->pdtllistPrefixes, NT_Psz );
            if (dwErr != 0)
                break;
        }

        dwErr = GetRegMultiSz( hkey, REGVAL_mszSuffixes,
            &pUser->pdtllistSuffixes, NT_Psz );
        if (dwErr != 0)
            break;

        GetLocationList( hkey, &pUser->pdtllistLocations );

        dwErr = GetRegSz( hkey, REGVAL_szLastCallbackByCaller,
            &pUser->pszLastCallbackByCaller );
        if (dwErr != 0)
            break;

        /* Get the personal phonebook file name, if any.  In NT 3.51, the full
        ** path was stored, but now "<nt>\system32\ras" directory is assumed.
        ** This gives better (not perfect) behavior with user profiles rooted
        ** on different drive letters.
        */
        {
            TCHAR* psz;

            dwErr = GetRegSz( hkey, REGVAL_szPersonalPhonebookPath, &psz );
            if (dwErr != 0)
                break;

            if (*psz == TEXT('\0'))
            {
                Free(psz);
                dwErr = GetRegSz( hkey, REGVAL_szPersonalPhonebookFile,
                    &pUser->pszPersonalFile );
                if (dwErr != 0)
                    break;
            }
            else
            {
                pUser->pszPersonalFile = StrDup( StripPath( psz ) );
                Free( psz );
                if (!pUser->pszPersonalFile)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
        }

        dwErr = GetRegSz( hkey, REGVAL_szAlternatePhonebookPath,
            &pUser->pszAlternatePath );
        if (dwErr != 0)
            break;

        dwErr = GetRegSz( hkey, REGVAL_szDefaultEntry,
            &pUser->pszDefaultEntry );
        if (dwErr != 0)
            break;

        if (fOldSettings)
        {
            TCHAR* psz;

            psz = NULL;
            dwErr = GetRegSz( hkey, REGVAL_szUsePersonalPhonebook, &psz );
            if (dwErr != 0)
                break;
            if (psz)
            {
                if (*psz == TEXT('1'))
                    pUser->dwPhonebookMode = PBM_Personal;
                Free( psz );
            }
        }
    }
    while (FALSE);

    if (dwErr != 0)
        DestroyUserPreferences( pUser );

    TRACE1("ReadUserPreferences=%d",dwErr);
    return dwErr;
}


DWORD
SetCallbackList(
    IN HKEY     hkey,
    IN DTLLIST* pList )

    /* Sets callback tree under registry key 'hkey' to the list of callback
    ** nodes 'pList'.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD    dwErr;
    TCHAR    szDP[ RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1 ];
    DWORD    cb;
    DWORD    i;
    DWORD    dwDisposition;
    HKEY     hkeyCb;
    HKEY     hkeyDP;
    DTLNODE* pNode;

    dwErr = RegCreateKeyEx( hkey, REGKEY_Callback,
        0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
        &hkeyCb, &dwDisposition );
    if (dwErr != 0)
        return dwErr;

    /* Delete all keys and values under the callback key.
    */
    for (;;)
    {
        cb = sizeof(szDP);
        dwErr = RegEnumKeyEx(
            hkeyCb, 0, szDP, &cb, NULL, NULL, NULL, NULL );
        if (dwErr != 0)
            break;

        dwErr = RegDeleteKey( hkeyCb, szDP );
        if (dwErr != 0)
            break;
    }

    if (dwErr == ERROR_NO_MORE_ITEMS)
        dwErr = 0;

    if (dwErr == 0)
    {
        /* Add the new device/port sub-trees.
        */
        for (pNode = DtlGetFirstNode( pList );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            CALLBACKINFO* pInfo;
            TCHAR*        psz;

            pInfo = (CALLBACKINFO* )DtlGetData( pNode );
            ASSERT(pInfo);
            ASSERT(pInfo->pszPortName);
            ASSERT(pInfo->pszDeviceName);
            ASSERT(pInfo->pszNumber);

            psz = PszFromDeviceAndPort(
                pInfo->pszDeviceName, pInfo->pszPortName );
            if (psz)
            {
                dwErr = RegCreateKeyEx( hkeyCb, psz, 0, TEXT(""),
                    REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDP,
                    &dwDisposition );
                if (dwErr != 0)
                    break;

                dwErr = SetRegDword( hkeyDP, REGVAL_dwDeviceType,
                    pInfo->dwDeviceType );
                if (dwErr == 0)
                {
                    dwErr = SetRegSz( hkeyDP,
                        REGVAL_szNumber, pInfo->pszNumber );
                }

                RegCloseKey( hkeyDP );
            }
            else
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

            if (dwErr != 0)
                break;
        }
    }

    RegCloseKey( hkeyCb );
    return dwErr;
}


DWORD
SetDefaultUserPreferences(
    OUT PBUSER* pUser,
    IN  DWORD   dwMode )

    /* Fill caller's 'pUser' buffer with default user preferences.  'DwMode'
    ** indicates the type of user preferences.
    **
    ** Returns 0 if successful, false otherwise.
    */
{
    DTLNODE* pNode;

    /* Set defaults.
    */
    CopyMemory( pUser, &g_pbuserDefaults, sizeof(*pUser) );
    pUser->pdtllistCallback = DtlCreateList( 0L );
    pUser->pdtllistPhonebooks = DtlCreateList( 0L );
    pUser->pdtllistAreaCodes = DtlCreateList( 0L );
    pUser->pdtllistPrefixes = DtlCreateList( 0L );
    pUser->pdtllistSuffixes = DtlCreateList( 0L );
    pUser->pdtllistLocations = DtlCreateList( 0L );

    if (!pUser->pdtllistCallback
        || !pUser->pdtllistPhonebooks
        || !pUser->pdtllistAreaCodes
        || !pUser->pdtllistPrefixes
        || !pUser->pdtllistSuffixes
        || !pUser->pdtllistLocations)
    {
        /* Can't even get empty lists, so we're forced to return an error.
        */
        DestroyUserPreferences( pUser );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    /* Add the default prefixes.
    */
    pNode = CreatePszNode( TEXT("0,") );
    if (pNode)
        DtlAddNodeLast( pUser->pdtllistPrefixes, pNode );
    pNode = CreatePszNode( TEXT("9,") );
    if (pNode)
        DtlAddNodeLast( pUser->pdtllistPrefixes, pNode );
    pNode = CreatePszNode( TEXT("8,") );
    if (pNode)
        DtlAddNodeLast( pUser->pdtllistPrefixes, pNode );
    pNode = CreatePszNode( TEXT("70#") );
    if (pNode)
        DtlAddNodeLast( pUser->pdtllistPrefixes, pNode );

    if (dwMode == UPM_Logon)
    {
        ASSERT(pUser->dwPhonebookMode!=PBM_Personal);
        pUser->fShowLights = FALSE;
        pUser->fSkipConnectComplete = TRUE;
    }

    if (dwMode == UPM_Router)
    {
        pUser->dwCallbackMode = CBM_No;
    }

    pUser->fInitialized = TRUE;
    return 0;
}


DWORD
SetLocationList(
    IN HKEY     hkey,
    IN DTLLIST* pList )

    /* Sets by-location tree under registry key 'hkey' to the list of
    ** by-location nodes 'pList'.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD    dwErr;
    TCHAR    szId[ MAXLTOTLEN + 1 ];
    DWORD    cb;
    DWORD    i;
    DWORD    dwDisposition;
    HKEY     hkeyL;
    HKEY     hkeyId;
    DTLNODE* pNode;

    dwErr = RegCreateKeyEx( hkey, REGKEY_Location,
        0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
        &hkeyL, &dwDisposition );
    if (dwErr != 0)
        return dwErr;

    /* Delete all keys and values under the location key.
    */
    for (;;)
    {
        cb = MAXLTOTLEN + 1;
        dwErr = RegEnumKeyEx( hkeyL, 0, szId, &cb, NULL, NULL, NULL, NULL );
        if (dwErr != 0)
            break;

        dwErr = RegDeleteKey( hkeyL, szId );
        if (dwErr != 0)
            break;
    }

    if (dwErr == ERROR_NO_MORE_ITEMS)
        dwErr = 0;

    if (dwErr == 0)
    {
        /* Add the new ID sub-trees.
        */
        for (pNode = DtlGetFirstNode( pList );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            LOCATIONINFO* pInfo;

            pInfo = (LOCATIONINFO* )DtlGetData( pNode );
            ASSERT(pInfo);

            LToT( pInfo->dwLocationId, szId, 10 );

            dwErr = RegCreateKeyEx( hkeyL, szId, 0, TEXT(""),
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyId,
                &dwDisposition );
            if (dwErr != 0)
                break;

            dwErr = SetRegDword( hkeyId, REGVAL_dwPrefix, pInfo->iPrefix );
            if (dwErr == 0)
                dwErr = SetRegDword( hkeyId, REGVAL_dwSuffix, pInfo->iSuffix );

            RegCloseKey( hkeyId );

            if (dwErr != 0)
                break;
        }
    }

    RegCloseKey( hkeyL );
    return dwErr;
}


DWORD
WriteUserPreferences(
    IN HKEY    hkey,
    IN PBUSER* pUser )

    /* Write user preferences 'pUser' at RAS-Phonebook registry key 'hkey'.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD dwErr;

    TRACE("WriteUserPreferences");

    do
    {
        dwErr = SetRegDword( hkey, REGVAL_fOperatorDial,
            pUser->fOperatorDial );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fPreviewPhoneNumber,
            pUser->fPreviewPhoneNumber );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fUseLocation,
            pUser->fUseLocation );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fShowLights,
            pUser->fShowLights );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fShowConnectStatus,
            pUser->fShowConnectStatus );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fNewEntryWizard,
            pUser->fNewEntryWizard );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fCloseOnDial,
            pUser->fCloseOnDial );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fAllowLogonPhonebookEdits,
            pUser->fAllowLogonPhonebookEdits );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fAllowLogonLocationEdits,
            pUser->fAllowLogonLocationEdits );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fSkipConnectComplete,
            pUser->fSkipConnectComplete );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwRedialAttempts,
            pUser->dwRedialAttempts );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwRedialSeconds,
            pUser->dwRedialSeconds );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwIdleDisconnectSeconds,
            pUser->dwIdleDisconnectSeconds );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fRedialOnLinkFailure,
            pUser->fRedialOnLinkFailure );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fPopupOnTopWhenRedialing,
            pUser->fPopupOnTopWhenRedialing );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fExpandAutoDialQuery,
            pUser->fExpandAutoDialQuery );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwCallbackMode,
            pUser->dwCallbackMode );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwPhonebookMode,
            pUser->dwPhonebookMode );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fUseAreaAndCountry,
            pUser->fUseAreaAndCountry );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwXWindow,
            pUser->dwXPhonebook );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwYWindow,
            pUser->dwYPhonebook );

        dwErr = SetCallbackList( hkey, pUser->pdtllistCallback );
        if (dwErr != 0)
            break;

        dwErr = SetRegMultiSz( hkey, REGVAL_mszPhonebooks,
            pUser->pdtllistPhonebooks, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = SetRegMultiSz( hkey, REGVAL_mszAreaCodes,
            pUser->pdtllistAreaCodes, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = SetRegMultiSz( hkey, REGVAL_mszPrefixes,
            pUser->pdtllistPrefixes, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = SetRegMultiSz( hkey, REGVAL_mszSuffixes,
            pUser->pdtllistSuffixes, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = SetLocationList( hkey, pUser->pdtllistLocations );
        if (dwErr != 0)
            break;

        dwErr = SetRegSz( hkey, REGVAL_szLastCallbackByCaller,
            pUser->pszLastCallbackByCaller );
        if (dwErr != 0)
            break;

        dwErr = SetRegSz( hkey, REGVAL_szPersonalPhonebookFile,
            pUser->pszPersonalFile );
        if (dwErr != 0)
            break;

        dwErr = SetRegSz( hkey, REGVAL_szAlternatePhonebookPath,
            pUser->pszAlternatePath );
        if (dwErr != 0)
            break;

        dwErr = SetRegSz( hkey, REGVAL_szDefaultEntry,
            pUser->pszDefaultEntry );
        if (dwErr != 0)
            break;

        RegDeleteValue( hkey, REGVAL_szPersonalPhonebookPath );
    }
    while (FALSE);

    if (dwErr == 0)
        pUser->fDirty = FALSE;

    TRACE1("WriteUserPreferences=%d",dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\rasapi.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rasapi.c
** RAS API helpers (with no RASMAN calls)
** Listed alphabetically
**
** 12/20/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <list.h>     // for LIST_ENTRY definitions
#include <stdlib.h>   // for atol()
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Our public header
#include <raserror.h> // RAS error constants


DWORD
FreeRasconnList(
    LIST_ENTRY *pListHead )

    /* Frees a list built by GetRasconnList.
    **
    ** Returns 0 always.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    RASCONNLINK *plink;
    RASCONNENTRY *pentry;
    LIST_ENTRY *ple, *plel;

    while (!IsListEmpty(pListHead)) {

        ple = RemoveHeadList(pListHead);

        pentry = CONTAINING_RECORD(ple, RASCONNENTRY, RCE_Node);

        while (!IsListEmpty(&pentry->RCE_Links)) {

            plel = RemoveHeadList(&pentry->RCE_Links);

            plink = CONTAINING_RECORD(plel, RASCONNLINK, RCL_Node);

            Free(plink);
        }

        Free(pentry);
    }

    return NO_ERROR;
}



DWORD
GetRasconnList(
    LIST_ENTRY *pListHead )

    /* Builds a sorted list containing entries for each connected network.
    ** Each entry consists of an entry-name and a list of RASCONN structures
    ** for each link connected to the entry-name's network.
    **
    ** The type of each node in the list of entries is RASCONNENTRY.
    ** The type of each node in each list of links is RASCONNLINK.
    **
    ** Returns 0 if successful, or an error code.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    DWORD dwErr;
    INT cmp, cmpl;
    RASCONNLINK *plink;
    RASCONNENTRY *pentry;
    DWORD i, iConnCount;
    RASCONN *pConnTable, *pconn;
    LIST_ENTRY *ple, *plel, *pheadl;

    InitializeListHead(pListHead);

    //
    // get an array of all the connections
    //

    dwErr = GetRasconnTable(&pConnTable, &iConnCount);
    if (dwErr != NO_ERROR) { return dwErr; }

    //
    // convert the array into a list
    //

    for (i = 0, pconn = pConnTable; i < iConnCount; i++, pconn++) {

        //
        // see if there is an entry for the network to which
        // this RASCONN corresponds
        //

        for (ple = pListHead->Flink; ple != pListHead; ple = ple->Flink) {

            pentry = CONTAINING_RECORD(ple, RASCONNENTRY, RCE_Node);

            cmp = lstrcmp(pconn->szEntryName, pentry->RCE_Entry->szEntryName);
            if (cmp > 0) { continue; }
            else
            if (cmp < 0) { break; }

            //
            // the entry has been found;
            // now insert a link for the connection
            //

            pheadl = &pentry->RCE_Links;

            for (plel = pheadl->Flink; plel != pheadl; plel = plel->Flink) {

                plink = CONTAINING_RECORD(plel, RASCONNLINK, RCL_Node);

                cmpl = lstrcmp(
                          pconn->szDeviceName, plink->RCL_Link.szDeviceName
                          );
                if (cmpl > 0) { continue; }
                else
                if (cmpl < 0) { break; }

                //
                // the link already exists, so do nothing
                //

                break;
            }

            //
            // the link was not found but we found where to insert it,
            // insert the link now
            //

            if (plel == pheadl || cmpl < 0) {

                plink = Malloc(sizeof(RASCONNLINK));

                if (plink == NULL) {
                    FreeRasconnList(pListHead);
                    Free(pConnTable);
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                plink->RCL_Link = *pconn;

                InsertTailList(plel, &plink->RCL_Node);
            }

            break;
        }

        //
        // the entry was not found, but now we know where to insert it
        //

        if (ple == pListHead || cmp < 0) {

            //
            // allocate the new entry
            //

            pentry = Malloc(sizeof(RASCONNENTRY));

            if (pentry == NULL) {
                FreeRasconnList(pListHead);
                Free(pConnTable);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            InitializeListHead(&pentry->RCE_Links);

            //
            // insert it in the list of entries
            //

            InsertTailList(ple, &pentry->RCE_Node);

            //
            // allocate the link which corresponds to the RASCONN
            // we are currently working on
            //

            plink = Malloc(sizeof(RASCONNLINK));

            if (plink == NULL) {
                FreeRasconnList(pListHead);
                Free(pConnTable);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            plink->RCL_Link = *pconn;

            //
            // insert it in the entry's list of links
            //

            InsertHeadList(&pentry->RCE_Links, &plink->RCL_Node);

            pentry->RCE_Entry = &plink->RCL_Link;
        }
    }

    Free(pConnTable);
    return NO_ERROR;
}


DWORD
GetRasconnTable(
    OUT RASCONN** ppConnTable,
    OUT DWORD*    pdwConnCount )

    /* Get active RAS dial-out connections.  Loads '*ppConnTable' with the
    ** address of a heap block containing an array of '*pdwConnCount' active
    ** connections.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    RASCONN conn, *pconn;
    DWORD dwErr, dwSize, dwCount;

    //
    // validate arguments
    //

    if (ppConnTable == NULL || pdwConnCount == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pdwConnCount = 0;
    *ppConnTable = NULL;

    //
    // RasEnumConnections doesn't give the size required
    // unless a valid buffer is specified, so pass in a dummy buffer
    //

    conn.dwSize = dwSize = sizeof(RASCONN);

    pconn = &conn;

    ASSERT(g_pRasEnumConnections);
    dwErr = g_pRasEnumConnections(pconn, &dwSize, &dwCount);

    if (dwErr == NO_ERROR) {

        if (dwCount == 0) {
            return NO_ERROR;
        }
        else {

            //
            // only one entry, so return it
            //

            pconn = Malloc(sizeof(RASCONN));

            if (pconn == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            *pconn = conn;
            *ppConnTable = pconn;
            *pdwConnCount = 1;

            return NO_ERROR;
        }
    }

    if (dwErr != ERROR_BUFFER_TOO_SMALL) {
        return dwErr;
    }

    //
    // allocate more space
    //

    pconn = Malloc(dwSize);

    if (pconn == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pconn->dwSize = sizeof(RASCONN);
    dwErr = g_pRasEnumConnections(pconn, &dwSize, &dwCount);

    if (dwErr != NO_ERROR) {
        Free(pconn);
        return dwErr;
    }

    *ppConnTable = pconn;
    *pdwConnCount = dwCount;

    return NO_ERROR;
}


DWORD
GetRasEntrynameTable(
    OUT RASENTRYNAME**  ppEntrynameTable,
    OUT DWORD*          pdwEntrynameCount )

    /* Get active RAS dial-out connections.  Loads '*ppEntrynameTable' with the
    ** address of a heap block containing an array of '*pdwEntrynameCount'
    ** active connections.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    RASENTRYNAME ename, *pename;
    DWORD dwErr, dwSize, dwCount;

    //
    // validate arguments
    //

    if (ppEntrynameTable == NULL || pdwEntrynameCount == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pdwEntrynameCount = 0;
    *ppEntrynameTable = NULL;


    //
    // RasEnumEntries doesn't give the size required
    // unless a valid buffer is specified, so pass in a dummy buffer
    //

    ename.dwSize = dwSize = sizeof(ename);

    pename = &ename;

    ASSERT(g_pRasEnumEntries);
    dwErr = g_pRasEnumEntries(NULL, NULL, pename, &dwSize, &dwCount);

    if (dwErr == NO_ERROR) {

        if (dwCount == 0) {
            return NO_ERROR;
        }
        else {

            //
            // only one entry, so return it
            //

            pename = Malloc(sizeof(*pename));

            if (pename == NULL) { return ERROR_NOT_ENOUGH_MEMORY; }

            *pename = ename;
            *ppEntrynameTable = pename;
            *pdwEntrynameCount = 1;

            return NO_ERROR;
        }
    }

    if (dwErr != ERROR_BUFFER_TOO_SMALL) {
        return dwErr;
    }


    //
    // allocate more space
    //

    pename = Malloc(dwSize);

    if (pename == NULL) { return ERROR_NOT_ENOUGH_MEMORY; }

    pename->dwSize = sizeof(*pename);

    dwErr = g_pRasEnumEntries(NULL, NULL, pename, &dwSize, &dwCount);

    if (dwErr != NO_ERROR) { Free(pename); return dwErr; }

    *ppEntrynameTable = pename;
    *pdwEntrynameCount = dwCount;

    return NO_ERROR;
}

DWORD
GetRasProjectionInfo(
    IN  HRASCONN    hrasconn,
    OUT RASAMB*     pamb,
    OUT RASPPPNBF*  pnbf,
    OUT RASPPPIP*   pip,
    OUT RASPPPIPX*  pipx,
    OUT RASPPPLCP*  plcp,
    OUT RASSLIP*    pslip,
    OUT RASPPPCCP*  pccp)

    /* Reads projection info for all protocols, translating "not requested"
    ** into an in-structure code of ERROR_PROTOCOL_NOT_CONFIGURED.
    **
    ** Returns 0 is successful, otherwise a non-0 error code.
    */
{
    DWORD dwErr;
    DWORD dwSize;

    ZeroMemory( pamb, sizeof(*pamb) );
    ZeroMemory( pnbf, sizeof(*pnbf) );
    ZeroMemory( pip,  sizeof(*pip) );
    ZeroMemory( pipx, sizeof(*pipx) );
    ZeroMemory( plcp, sizeof(*plcp) );
    ZeroMemory( pslip,sizeof(*pslip) );
    ZeroMemory( pccp, sizeof(*pccp) );

    dwSize = pamb->dwSize = sizeof(*pamb);
    ASSERT(g_pRasGetProjectionInfo);
    TRACE("RasGetProjectionInfo(AMB)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_Amb, pamb, &dwSize );
    TRACE2("RasGetProjectionInfo(AMB)=%d,e=%d",dwErr,pamb->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        ZeroMemory( pamb, sizeof(*pamb) );
        pamb->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }
    else if (dwErr != 0)
        return dwErr;

    dwSize = pnbf->dwSize = sizeof(*pnbf);
    TRACE("RasGetProjectionInfo(NBF)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_PppNbf, pnbf, &dwSize );
    TRACE2("RasGetProjectionInfo(NBF)=%d,e=%d",dwErr,pnbf->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        ZeroMemory( pnbf, sizeof(*pnbf) );
        pnbf->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }
    else if (dwErr != 0)
        return dwErr;

    dwSize = pip->dwSize = sizeof(*pip);
    TRACE("RasGetProjectionInfo(IP)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_PppIp, pip, &dwSize );
    TRACE2("RasGetProjectionInfo(IP)=%d,e=%d",dwErr,pip->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        ZeroMemory( pip, sizeof(*pip) );
        pip->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }
    else if (dwErr != 0)
        return dwErr;

    dwSize = pipx->dwSize = sizeof(*pipx);
    TRACE("RasGetProjectionInfo(IPX)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_PppIpx, pipx, &dwSize );
    TRACE2("RasGetProjectionInfo(IPX)=%d,e=%d",dwErr,pipx->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        dwErr = 0;
        ZeroMemory( pipx, sizeof(*pipx) );
        pipx->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }

    dwSize = plcp->dwSize = sizeof(*plcp);
    TRACE("RasGetProjectionInfo(LCP)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_PppLcp, plcp, &dwSize );
    TRACE2("RasGetProjectionInfo(LCP)=%d,f=%d",dwErr,plcp->fBundled);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        dwErr = 0;
        plcp->fBundled = FALSE;
    }

    dwSize = pccp->dwSize = sizeof(*pccp);
    TRACE("RasGetProjectionInfo(CCP)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_PppCcp, pccp, &dwSize);
    TRACE1("RasGetProjectionInfo(CCP)=%d",dwErr);

#if 0
    pslip->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
#else

    dwSize = pslip->dwSize = sizeof(*pslip);
    TRACE("RasGetProjectionInfo(SLIP)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_Slip, pslip, &dwSize );
    TRACE2("RasGetProjectionInfo(SLIP)=%d,e=%d",dwErr,pslip->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        dwErr = 0;
        ZeroMemory( pslip, sizeof(*pslip) );
        pslip->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }
#endif

    return dwErr;
}


HRASCONN
HrasconnFromEntry(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry )

    /* Returns the HRASCONN associated with entry 'pszEntry' from phonebook
    ** 'pszPhonebook' or NULL if not connected or error.
    */
{
    DWORD    dwErr;
    RASCONN* prc;
    DWORD    c;
    HRASCONN h;

    TRACE("HrasconnFromEntry");

    if (!pszEntry)
        return NULL;

    h = NULL;

    dwErr = GetRasconnTable( &prc, &c );
    if (dwErr == 0 && c > 0)
    {
        RASCONN* p;
        DWORD    i;

        for (i = 0, p = prc; i < c; ++i, ++p)
        {
        //let the entryname non-case sensitive, for whislter bug 311846		gangz
        //
            if ((!pszPhonebook
                  || lstrcmpi( p->szPhonebook, pszPhonebook ) == 0)
                && lstrcmpi( p->szEntryName, pszEntry ) == 0)	            
            {
                h = p->hrasconn;
                break;
            }
        }

        Free( prc );
    }

    TRACE1("HrasconnFromEntry=$%08x",h);
    return h;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\rasman.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rasman.c
** RAS Manager helpers
** Listed alphabetically
**
** These routines have been exempted from the TCHARizing applied to the rest
** of the library because RASMAN is still an ANSI interface.
**
** 09/20/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <stdlib.h>   // for atol()
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Our public header
#include <raserror.h> // RAS error constants
#include <mcx.h>      // Unimodem

#include <unimodem.h>

/* These types are described in MSDN and appear in Win95's unimdm.h private
** header (complete with typo) but not in any SDK headers.
*/

typedef struct tagDEVCFGGDR
{
    DWORD dwSize;
    DWORD dwVersion;
    WORD  fwOptions;
    WORD  wWaitBong;
}
DEVCFGHDR;

typedef struct tagDEVCFG
{
    DEVCFGHDR  dfgHdr;
    COMMCONFIG commconfig;
}
DEVCFG;

#define MANUAL_DIAL  0x0004
#define TERMINAL_PRE 0x0001

// Test rig to return a variety of fake ports from GetRasPorts.
//
#define DUMMYPORTS 0
#if DUMMYPORTS
DWORD g_cPorts = 6;
#endif


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

DWORD
GetRasDevices(
    IN  HANDLE          hConnection,
    IN  CHAR*           pszDeviceType,
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*           pdwEntries );

DWORD
GetRasPortParam(
    IN  HPORT             hport,
    IN  CHAR*             pszKey,
    OUT RASMAN_PORTINFO** ppPortInfo,
    OUT RAS_PARAMS**      ppParam );


/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/


DWORD
ClearRasdevStats(
    IN RASDEV* pdev,
    IN BOOL    fBundle )

    /* Resets statistics counters for a device.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    if (pdev == NULL) { return ERROR_INVALID_PARAMETER; }

    if ((HPORT)pdev->RD_Handle == (HPORT)INVALID_HANDLE_VALUE) {
        return ERROR_INVALID_HANDLE;
    }

    ASSERT(g_pRasPortClearStatistics);
    return (fBundle ? g_pRasBundleClearStatistics(NULL, (HPORT)pdev->RD_Handle)
                    : g_pRasPortClearStatistics(NULL, (HPORT)pdev->RD_Handle));
}


#if 0
DWORD
DeviceIdFromDeviceName(
    TCHAR* pszDeviceName )

    /* Returns the TAPI device ID associated with 'pszDeviceName'.  Returns
    ** 0xFFFFFFFE if not found, 0xFFFFFFFF if found but not a Unimodem.
    **
    ** This routine assumes that TAPI devices have unique names.
    */
{
    DWORD        dwErr;
    DWORD        dwId;
    DWORD        dwPorts;
    RASMAN_PORT* pPorts;

    TRACE("DeviceIdFromDeviceName");

    dwId = 0xFFFFFFFE;

    if (pszDeviceName)
    {
        dwErr = GetRasPorts( &pPorts, &dwPorts );
        if (dwErr == 0)
        {
            CHAR* pszDeviceNameA;
            pszDeviceNameA = StrDupAFromT( pszDeviceName );
            if (pszDeviceNameA)
            {
                INT          i;
                RASMAN_PORT* pPort;

                for (i = 0, pPort = pPorts; i < dwPorts; ++i, ++pPort)
                {
                    if (lstrcmpiA( pszDeviceNameA, pPort->P_DeviceName ) == 0)
                    {
                        dwId = pPort->P_LineDeviceId;
                        break;
                    }
                }
                Free( pszDeviceNameA );
            }
            Free( pPorts );
        }
    }

    TRACE1("DeviceIdFromDeviceName=%d",dwErr);
    
    return dwId;
}
#endif


DWORD
FreeRasdevTable(
    RASDEV* pDevTable,
    DWORD   iDevCount )

    /* Frees a table built by GetRasdevTable.
    **
    ** Returns 0 if succesful, or an error code.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    DWORD i;

    //
    // validate arguments
    //

    if (pDevTable == NULL) { return ERROR_INVALID_PARAMETER; }

    //
    // free the device-name string fields
    //

    for (i = 0; i < iDevCount; i++) {
        if (pDevTable[i].RD_DeviceName) { Free(pDevTable[i].RD_DeviceName); }
    }

    //
    // free the array itself
    //

    Free(pDevTable);

    return NO_ERROR;
}


DWORD
GetConnectTime(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwConnectTime )

    /* Loads '*pdwConnectTime' with the duration in milliseconds of the
    ** connection on pdev.
    **
    ** Returns 0 if succesful, or an error code.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    HPORT hport;
    DWORD dwErr;
    RASMAN_INFO info;

    if (pdwConnectTime == NULL) { return ERROR_INVALID_PARAMETER; }

    //
    // initialize the argument
    //

    *pdwConnectTime = 0;

    //
    // get an HPORT for the HRASCONN
    //

    ASSERT(g_pRasGetHport);
    hport = g_pRasGetHport(hrasconn);
    if (hport == (HPORT)INVALID_HANDLE_VALUE) { return ERROR_INVALID_HANDLE; }

    //
    // get information on the HPORT
    //

    ASSERT(g_pRasGetInfo);
    dwErr = g_pRasGetInfo(NULL, hport, &info);
    if (dwErr != NO_ERROR) { return dwErr; }


    if (info.RI_ConnState != CONNECTED) { *pdwConnectTime = 0; }
    else { *pdwConnectTime = info.RI_ConnectDuration; }

    return NO_ERROR;
}


DWORD
GetRasconnFraming(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwSendFraming,
    OUT DWORD*   pdwRecvFraming )

    /* Retrieves the framing bits for an active RAS connection.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    DWORD dwErr;
    HPORT hport;
    RAS_FRAMING_INFO info;

    //
    // validate arguments
    //

    if (pdwSendFraming == NULL || pdwRecvFraming == NULL) {
        return ERROR_INVALID_HANDLE;
    }


    //
    // retrieve the HPORT for this connection
    //

    ASSERT(g_pRasGetHport);
    hport = g_pRasGetHport(hrasconn);
    if (hport == (HPORT)INVALID_HANDLE_VALUE) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // retrieve the framing information for this port
    //

    ASSERT(g_pRasPortGetFramingEx);
    dwErr = g_pRasPortGetFramingEx(NULL, hport, &info);
    if (dwErr != NO_ERROR) { return dwErr; }


    *pdwSendFraming = info.RFI_SendFramingBits;
    *pdwRecvFraming = info.RFI_RecvFramingBits;

    return NO_ERROR;
}


DWORD
GetRasconnFromRasdev(
    IN  RASDEV*   pdev,
    OUT RASCONN** ppconn,
    IN  RASCONN*  pConnTable OPTIONAL,
    IN  DWORD     iConnCount OPTIONAL )

    /* Given a RASDEV structure for an active device, this function retrieves
    ** the RASCONN which corresponds to the device's current connection.  The
    ** second and third arguments are optional; they specify a table of
    ** RASCONN structures to be searched.  This is useful if the caller has
    ** already enumerated the active connections, so that this function does
    ** not need to re-enumerate them.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    BOOL bFreeTable;
    DWORD dwErr, i;
    RASDEVSTATS stats;

    //
    // validate arguments
    //

    if (pdev == NULL || ppconn == NULL) { return ERROR_INVALID_PARAMETER; }

    *ppconn = NULL;

    //
    // get stats for the RASDEV
    //

    dwErr = GetRasdevStats(pdev, &stats);
    if (dwErr != NO_ERROR) { return dwErr; }


    bFreeTable = FALSE;

    //
    // if the caller didn't pass in a table of RASCONNs, retrieve one
    //

    if (pConnTable == NULL) {

        dwErr = GetRasconnTable(&pConnTable, &iConnCount);
        if (dwErr != NO_ERROR) { return dwErr; }

        bFreeTable = TRUE;
    }


    //
    // find the connection which matches the RASDEV passed in
    //

    for (i = 0; i < iConnCount; i++) {

        if ((HRASCONN)stats.RDS_Hrasconn == (pConnTable + i)->hrasconn) {
            break;
        }
    }

    //
    // see how the search ended
    //

    if (i >= iConnCount) {
        dwErr = ERROR_NO_DATA;
    }
    else {

        dwErr = NO_ERROR;

        if (!bFreeTable) {

            //
            // point to the place where we found the RASCONN
            //

            *ppconn = pConnTable + i;
        }
        else {

            //
            // make a copy of the RASCONN found
            //

            *ppconn = Malloc(sizeof(RASCONN));

            if (!*ppconn) { dwErr = ERROR_NOT_ENOUGH_MEMORY; }
            else { **ppconn = *(pConnTable + i); }
        }
    }

    if (bFreeTable) { Free(pConnTable); }

    return dwErr;
}


DWORD
GetRasdevBundle(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwBundle )

    /* Retrieves a handle which represents the current connection
    ** on the given device. This handle has the property that it will be
    ** identical for two devices which are multi-linked together.
    ** In the case of NT RAS, the RASMAN HBUNDLE is retrieved.
    **
    ** (Abolade Gbadegesin Mar-6-1996)
    */
{

    return g_pRasPortGetBundle(NULL, (HPORT)pdev->RD_Handle, (HBUNDLE *)pdwBundle);
}


DWORD
GetRasdevFraming(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwFraming )

    /* Retrieves the framing bits for an active RAS connection.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    DWORD dwErr;
    RAS_FRAMING_INFO info;

    //
    // validate arguments
    //

    if (pdwFraming == NULL) { return ERROR_INVALID_HANDLE; }


    //
    // retrieve the framing information for this port
    //

    ASSERT(g_pRasPortGetFramingEx);
    dwErr = g_pRasPortGetFramingEx(NULL, (HPORT)pdev->RD_Handle, &info);
    if (dwErr != NO_ERROR) { return dwErr; }


    if (info.RFI_SendFramingBits & OLD_RAS_FRAMING) {
        *pdwFraming = RASFP_Ras;
    }
    else
    if (info.RFI_SendFramingBits & PPP_MULTILINK_FRAMING ||
        info.RFI_SendFramingBits & PPP_FRAMING) {
        *pdwFraming = RASFP_Ppp;
    }
    else
    if (info.RFI_SendFramingBits & SLIP_FRAMING) {
        *pdwFraming = RASFP_Slip;
    }
    else {
        *pdwFraming = 0;
    }

    return NO_ERROR;
}

DWORD
GetRasdevFromRasconn(
    IN  RASCONN* pconn,
    OUT RASDEV** ppdev,
    IN  RASDEV*  pDevTable OPTIONAL,
    IN  DWORD    iDevCount OPTIONAL )

    /* Given a RASCONN structure for an active connection, this function
    ** retrieves the RASDEV for the device over which the connection is
    ** active.  The second and third arguments are optional; they specify a
    ** table of RASDEV structures to be searched.  This is useful if the
    ** caller has already enumerated the existing devices, so that this
    ** function does not need to re-enumerate them.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    HPORT hport;
    DWORD i, dwErr;
    BOOL bFreeTable;

    //
    // validate the arguments
    //

    if (pconn == NULL || ppdev == NULL) { return ERROR_INVALID_PARAMETER; }

    *ppdev = NULL;


    //
    // retrieve the device table if the caller didn't pass one in
    //

    bFreeTable = FALSE;

    if (pDevTable == NULL) {

        dwErr = GetRasdevTable(&pDevTable, &iDevCount);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        bFreeTable = TRUE;
    }

    //
    // retrieve the HPORT for the RASCONN passed in
    //

    ASSERT(g_pRasGetHport);
    hport = g_pRasGetHport(pconn->hrasconn);
    if (hport == (HPORT)INVALID_HANDLE_VALUE) { return ERROR_INVALID_HANDLE; }

    //
    // find the device to which the HPORT corresponds
    //

    for (i = 0; i < iDevCount; i++) {
        if (hport == pDevTable[i].RD_Handle) { break; }
    }

    //
    // see how the search ended
    //

    if (i >= iDevCount) {
        dwErr = ERROR_NO_DATA;
    }
    else {

        dwErr = NO_ERROR;

        if (!bFreeTable) {
            *ppdev = pDevTable + i;
        }
        else {

            *ppdev = Malloc(sizeof(RASDEV));

            if (!*ppdev) { dwErr = ERROR_NOT_ENOUGH_MEMORY; }
            else {

                **ppdev = *(pDevTable + i);

                (*ppdev)->RD_DeviceName = StrDup(pDevTable[i].RD_DeviceName);

                if (!(*ppdev)->RD_DeviceName) {
                    Free(*ppdev);
                    *ppdev = NULL;
                    dwErr = ERROR_NOT_ENOUGH_MEMORY; 
                }
            }
        }
    }

    if (bFreeTable) { FreeRasdevTable(pDevTable, iDevCount); }

    return dwErr;
}


DWORD
GetRasDevices(
    IN  HANDLE          hConnection,
    IN  CHAR*           pszDeviceType,
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*          pdwEntries )

    /* Fills caller's '*ppDevices' with the address of a heap block containing
    ** '*pwEntries' RASMAN_DEVICE structures.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to free the returned memory block.
    */
{
    DWORD dwSize = 0;
    DWORD dwErr;

    TRACE1("GetRasDevices(%s)",pszDeviceType);

    ASSERT(g_pRasDeviceEnum);
    TRACE("RasDeviceEnum...");
    dwErr = g_pRasDeviceEnum(hConnection, pszDeviceType, NULL, &dwSize, pdwEntries );
    TRACE2("RasDeviceEnum=%d,c=%d",dwErr,*pdwEntries);

    if (dwErr == 0)
    {
        /* No devices to enumerate.  Set up to allocate a single byte anyway,
        ** so things work without lots of special code.
        */
        dwSize = 1;
    }
    else if (dwErr != ERROR_BUFFER_TOO_SMALL)
        return dwErr;

    *ppDevices = (RASMAN_DEVICE* )Malloc( dwSize );
    if (!*ppDevices)
        return ERROR_NOT_ENOUGH_MEMORY;

    TRACE("RasDeviceEnum...");
    dwErr = g_pRasDeviceEnum(
                hConnection,
                pszDeviceType, 
                (PBYTE )*ppDevices,
                &dwSize,
                pdwEntries );
                
    TRACE1("RasDeviceEnum=%d",dwErr);

    if (dwErr != 0)
    {
        Free( *ppDevices );
        return dwErr;
    }

    return 0;
}


DWORD
GetRasDeviceString(
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    IN  CHAR*  pszDeviceName,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate )

    /* Loads callers '*ppszValue' with the address of a heap block containing
    ** a NUL-terminated copy of the value string associated with key 'pszKey'
    ** for the device on port 'hport'.  'pszDeviceType' specifies the type of
    ** device, e.g. "modem".  'pszDeviceName' specifies the name of the
    ** device, e.g. "Hayes V-Series 9600".  'dwXlate' is a bit mask of XLATE_
    ** bits specifying translations to perform on the returned string.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to Free the returned string.
    */
{
    DWORD              dwErr = 0;
    RASMAN_DEVICEINFO* pDeviceInfo = NULL;
    RAS_PARAMS*        pParam;
    DWORD              dwSize = 0;
    INT                i;

    TRACE2("GetRasDeviceString(%s,%s)",pszDeviceName,pszKey);

    *ppszValue = NULL;

    do
    {
        ASSERT(g_pRasDeviceGetInfo);
        TRACE("RasDeviceGetInfo...");
        dwErr = g_pRasDeviceGetInfo(
            NULL, hport, pszDeviceType, pszDeviceName, NULL, &dwSize );
        TRACE2("RasDeviceGetInfo=%d,s=%d",dwErr,(INT)dwSize);

        if (dwErr != ERROR_BUFFER_TOO_SMALL && dwErr != 0)
            break;

        /* So it will fall thru and be "not found".
        */
        if (dwSize == 0)
            dwSize = 1;

        pDeviceInfo = (RASMAN_DEVICEINFO* )Malloc( dwSize );
        if (!pDeviceInfo)
            return ERROR_NOT_ENOUGH_MEMORY;

        TRACE("RasDeviceGetInfo...");
        dwErr = g_pRasDeviceGetInfo(
            NULL, hport, pszDeviceType, pszDeviceName, (PBYTE )pDeviceInfo, &dwSize );
        TRACE2("RasDeviceGetInfo=%d,s=%d",dwErr,(INT)dwSize);

        if (dwErr != 0)
            break;

        dwErr = ERROR_KEY_NOT_FOUND;

        for (i = 0, pParam = pDeviceInfo->DI_Params;
             i < (INT )pDeviceInfo->DI_NumOfParams;
             ++i, ++pParam)
        {
            if (lstrcmpiA( pParam->P_Key, pszKey ) == 0)
            {
                *ppszValue = PszFromRasValue( &pParam->P_Value, dwXlate );

                dwErr = (*ppszValue) ? 0 : ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
    }
    while (FALSE);

    Free0( pDeviceInfo );

    TRACE1("String=\"%s\"",(*ppszValue)?*ppszValue:"");

    return dwErr;
}


DWORD
GetRasdevStats(
    IN  RASDEV*      pdev,
    OUT RASDEVSTATS* pstats )

    /* Retrieves statistics for a device.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    DWORD dwsize;
    RASMAN_INFO info;
    RAS_STATISTICS *prs;
    BYTE buffer[sizeof(RAS_STATISTICS) + MAX_STATISTICS * 2 * sizeof(DWORD)];
    DWORD dwErr, *pdw, dwGone, dwB, dwBC, dwBU;

    if (pdev == NULL || pstats == NULL) { return ERROR_INVALID_PARAMETER; }

    ZeroMemory(pstats, sizeof(RASDEVSTATS));


    //
    // retrieve the condition and connect time
    //

    ASSERT(g_pRasGetInfo);
    dwErr = g_pRasGetInfo(NULL, (HPORT)pdev->RD_Handle, &info);

    if (dwErr != NO_ERROR) {
        pstats->RDS_Condition = DISCONNECTED;
        return dwErr;
    }



    //
    // need to handle ports which are not connected
    // already a bug filed.
    //

    if (info.RI_PortStatus != OPEN) {
        pstats->RDS_Condition = DISCONNECTED;
        return NO_ERROR;
    }

    pstats->RDS_Condition = info.RI_ConnState;
    if (info.RI_ConnState == CONNECTED) {

        pstats->RDS_ConnectTime = info.RI_ConnectDuration;
        pstats->RDS_Hrasconn = (HRASCONN)info.RI_ConnectionHandle;
    }


    //
    // get dial-in/dial-out  usage
    //

    if (info.RI_CurrentUsage & CALL_IN)
        pstats->RDS_Flags |= RDFLAG_IsDialedIn;
    if (info.RI_CurrentUsage & CALL_OUT)
        pstats->RDS_Flags |= RDFLAG_IsDialedOut;
    if (info.RI_CurrentUsage & CALL_ROUTER)
        pstats->RDS_Flags |= RDFLAG_IsRouter;


    //
    // Retrieve the line speed
    //

    pstats->RDS_LineSpeed = info.RI_LinkSpeed;


    //
    // Retrieve the i/o statistics for both the link and the bundle
    //

    prs = (RAS_STATISTICS *)buffer;
    dwsize = sizeof(RAS_STATISTICS) + MAX_STATISTICS * 2 * sizeof(DWORD);
    ZeroMemory(buffer, dwsize);

    ASSERT(g_pRasBundleGetStatistics);
    dwErr = g_pRasBundleGetStatistics(
                NULL, (HPORT)pdev->RD_Handle, (PBYTE)prs, &dwsize
                );

    if (dwErr != NO_ERROR) { return dwErr; }


    //
    // Save the statistics in the caller's RASDEVSTATS structure.
    //

    pdw = prs->S_Statistics;

    pstats->RDS_InFrames = pdw[FRAMES_RCVED];
    pstats->RDS_OutFrames = pdw[FRAMES_XMITED];

    pstats->RDS_InBytesTotal =
        pdw[BYTES_RCVED] +
        pdw[BYTES_RCVED_UNCOMPRESSED] -
        pdw[BYTES_RCVED_COMPRESSED];
    pstats->RDS_OutBytesTotal =
        pdw[BYTES_XMITED] +
        pdw[BYTES_XMITED_UNCOMPRESSED] -
        pdw[BYTES_XMITED_COMPRESSED];

    pstats->RDS_InBytes =
        pdw[MAX_STATISTICS + BYTES_RCVED] +
        pdw[MAX_STATISTICS + BYTES_RCVED_UNCOMPRESSED] -
        pdw[MAX_STATISTICS + BYTES_RCVED_COMPRESSED];
    pstats->RDS_OutBytes =
        pdw[MAX_STATISTICS + BYTES_XMITED] +
        pdw[MAX_STATISTICS + BYTES_XMITED_UNCOMPRESSED] -
        pdw[MAX_STATISTICS + BYTES_XMITED_COMPRESSED];

    pstats->RDS_ErrCRC =
        pdw[MAX_STATISTICS + CRC_ERR];
    pstats->RDS_ErrTimeout =
        pdw[MAX_STATISTICS + TIMEOUT_ERR];
    pstats->RDS_ErrAlignment =
        pdw[MAX_STATISTICS + ALIGNMENT_ERR];
    pstats->RDS_ErrFraming =
        pdw[MAX_STATISTICS + FRAMING_ERR];
    pstats->RDS_ErrHwOverruns =
        pdw[MAX_STATISTICS + HARDWARE_OVERRUN_ERR];
    pstats->RDS_ErrBufOverruns =
        pdw[MAX_STATISTICS + BUFFER_OVERRUN_ERR];


#if 0
    TRACE4(
        "RasBundleGetStatistics(rx=%d,tx=%d,rxb=%d,txb=%d)",
        pstats->RDS_InBytes, pstats->RDS_OutBytes,
        pstats->RDS_InBytesTotal, pstats->RDS_OutBytesTotal
        );
#endif

    //
    // Compute compression ratios, using the bundle-stats
    //

    pstats->RDS_InCompRatio = 0;
    dwGone = 0;
    dwB = pdw[BYTES_RCVED];
    dwBC = pdw[BYTES_RCVED_COMPRESSED];
    dwBU = pdw[BYTES_RCVED_UNCOMPRESSED];

    if (dwBC < dwBU) { dwGone = dwBU - dwBC; }
    if (dwB + dwGone > 100) {
        DWORD dwDen = (dwB + dwGone) / 100;
        pstats->RDS_InCompRatio = (dwGone + (dwDen / 2)) / dwDen;
    }

    pstats->RDS_OutCompRatio = 0;
    dwGone = 0;
    dwB = pdw[BYTES_XMITED];
    dwBC = pdw[BYTES_XMITED_COMPRESSED];
    dwBU = pdw[BYTES_XMITED_UNCOMPRESSED];

    if (dwBC < dwBU) { dwGone = dwBU - dwBC; }
    if (dwB + dwGone > 100) {
        DWORD dwDen = (dwB + dwGone) / 100;
        pstats->RDS_OutCompRatio = (dwGone + (dwDen / 2)) / dwDen;
    }

    return NO_ERROR;
}


DWORD
GetRasdevTable(
    OUT RASDEV** ppDevTable,
    OUT DWORD*   piDevCount )

    /* Gets an array of RAS devices configured.  Loads '*ppDevTable' with a
    ** heap block of '*ppDevTable' entries.  On NT, this is essentially the
    ** output of GetRasPorts(), in a format which includes a devicename,
    ** flags, and a handle.  Given a RASMAN_PORT structure, we append the
    ** device and port names to make a unique device string which is part of
    ** the output.
    **
    ** Returns 0 if successful, or an error.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    DWORD dwPortCount;
    DWORD i, iLength, dwErr;
    RASDEV *pDevTable, *pdev;
    PTSTR pszDevice, pszPort;
    TCHAR szDevice[RAS_MaxDeviceName + 1];
    RASMAN_PORT *pPortTable, *pport;

    //
    // validate the arguments
    //

    if (ppDevTable == NULL || piDevCount == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *piDevCount = 0;
    *ppDevTable = NULL;

    //
    // get a table of ports from RASMAN; the string fields are ANSI
    //

    dwErr = GetRasPorts(NULL, &pPortTable, &dwPortCount);
    if (dwErr != NO_ERROR) { return dwErr; }

    if (dwPortCount == 0) { return NO_ERROR; }

    //
    // allocate space for as many device structs as there are ports
    //

    pDevTable = Malloc(dwPortCount * sizeof(RASDEV));
    if (pDevTable == NULL) {
        Free(pPortTable);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(pDevTable, dwPortCount * sizeof(RASDEV));

    //
    // convert each RASMAN_PORT structure to a RASDEV structure.
    //

    for (i = 0, pport = pPortTable; i < dwPortCount; i++, pport++) {

        pdev = pDevTable + i;

        //
        // copy over code-page-independent fields
        //

        pdev->RD_Handle = pport->P_Handle;

        if (pport->P_ConfiguredUsage & CALL_IN)
            pdev->RD_Flags |= RDFLAG_DialIn;
        if (pport->P_ConfiguredUsage & CALL_OUT)
            pdev->RD_Flags |= RDFLAG_DialOut;
        if (pport->P_ConfiguredUsage & CALL_ROUTER)
            pdev->RD_Flags |= RDFLAG_Router;

        if (pport->P_CurrentUsage & CALL_IN)
            pdev->RD_Flags |= RDFLAG_IsDialedIn;
        if (pport->P_CurrentUsage & CALL_OUT)
            pdev->RD_Flags |= RDFLAG_IsDialedOut;
        if (pport->P_CurrentUsage & CALL_ROUTER)
            pdev->RD_Flags |= RDFLAG_IsRouter;


        //
        // copy the device-type string 
        //

#ifdef UNICODE
        StrCpyWFromAUsingAnsiEncoding(
            pdev->RD_DeviceType, 
            pport->P_DeviceType, 
            RAS_MaxDeviceType);
#else
        lstrcpy(pdev->RD_DeviceType, pport->P_DeviceType);
#endif


        //
        // copy the device-name and portname,
        // storing them in temporary strings
        //

#ifdef UNICODE
        StrCpyWFromAUsingAnsiEncoding(
            szDevice, 
            pport->P_DeviceName, 
            RAS_MaxDeviceName);

        StrCpyWFromAUsingAnsiEncoding(
            pdev->RD_PortName, 
            pport->P_PortName, 
            MAX_PORT_NAME);
            
        pszDevice = szDevice;
        pszPort = pdev->RD_PortName;
#else
        pszDevice = pport->P_DeviceName;
        lstrcpyn(pdev->RD_PortName, pport->P_PortName, MAX_PORT_NAME + 1);
        pszPort = pdev->RD_PortName;
#endif


        //
        // get a display name from the device and port names
        //

        pdev->RD_DeviceName = PszFromDeviceAndPort(pszDevice, pszPort);

        if (pdev->RD_DeviceName == NULL) {
            Free(pPortTable);
            FreeRasdevTable(pDevTable, dwPortCount);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Free(pPortTable);

    *ppDevTable = pDevTable;
    *piDevCount = dwPortCount;

    return NO_ERROR;
}


DWORD
GetRasMessage(
    IN  HRASCONN hrasconn,
    OUT TCHAR**  ppszMessage )

    /* Loads caller's '*ppszMessage' with the address of a heap block
    ** containing the current MXS_MESSAGE_KEY value associated with RAS
    ** connection 'hrasconn'.
    **
    ** Returns 0 if successful or an error code.  It is caller's
    ** responsibility to Free the returned string.
    */
{
    DWORD         dwErr;
    RASCONNSTATUS rcs;
    CHAR*         pszMessage;

    TRACE("GetRasMessage");

    *ppszMessage = 0;

    ZeroMemory( &rcs, sizeof(rcs) );
    rcs.dwSize = sizeof(rcs);
    ASSERT(g_pRasGetConnectStatus);
    TRACE("RasGetConnectStatus");
    dwErr = g_pRasGetConnectStatus( hrasconn, &rcs );
    TRACE1("RasGetConnectStatus=%d",dwErr);

    if (dwErr == 0)
    {
        CHAR* pszDeviceTypeA;
        CHAR* pszDeviceNameA;

        pszDeviceTypeA = StrDupAFromT( rcs.szDeviceType );
        pszDeviceNameA = StrDupAFromT( rcs.szDeviceName );
        if (!pszDeviceTypeA || !pszDeviceNameA)
        {
            Free0( pszDeviceNameA );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = GetRasDeviceString(
            g_pRasGetHport( hrasconn ), pszDeviceTypeA, pszDeviceNameA,
            MXS_MESSAGE_KEY, &pszMessage, XLATE_ErrorResponse );

        Free0( pszDeviceTypeA );
        Free0( pszDeviceNameA );

        if (dwErr == 0)
        {
            *ppszMessage = StrDupTFromA( pszMessage );
            if (!*ppszMessage)
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            Free0( pszMessage );
        }
    }

    return dwErr;
}


DWORD
GetRasPads(
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*          pdwEntries )

    /* Fills caller's '*ppDevices' with the address of a heap block containing
    ** '*pwEntries' X.25 PAD DEVICE structures.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to free the returned memory block.
    */
{
    return GetRasDevices( NULL, MXS_PAD_TXT, ppDevices, pdwEntries );
}


VOID
GetRasPortMaxBps(
    IN  HPORT  hport,
    OUT DWORD* pdwMaxConnectBps,
    OUT DWORD* pdwMaxCarrierBps )

    /* Loads callers '*pdwMaxConnectBps' with the maximum port->modem bps rate
    ** for port 'pport', or with 0 if not found.  '*pdwMaxCarrierBps' is the
    ** same but for maximum modem->modem speed.
    */
{
    CHAR* pszValue = NULL;
    DWORD dwErr;

    TRACE("GetRasPortMaxBps");

    dwErr = GetRasPortString(
        hport, SER_CONNECTBPS_KEY, &pszValue, XLATE_None );
    if (dwErr == 0)
        *pdwMaxConnectBps = (DWORD )atol( pszValue );
    else
        *pdwMaxConnectBps = 0;

    Free0(pszValue);

    pszValue = NULL;

    dwErr = GetRasPortString(
        hport, SER_CARRIERBPS_KEY, &pszValue, XLATE_None );
    if (dwErr == 0)
        *pdwMaxCarrierBps = (DWORD )atol( pszValue );
    else
        *pdwMaxCarrierBps = 0;

    Free0(pszValue);        
}


VOID
GetRasPortModemSettings(
    IN  HPORT hport,
    OUT BOOL* pfHwFlowDefault,
    OUT BOOL* pfEcDefault,
    OUT BOOL* pfEccDefault )

    /* Loads caller's flags with the default setting of Hardware Flow Control,
    ** Error Control, and Error Control and Compression for the given 'hport'.
    */
{
    CHAR* pszValue = NULL;

    *pfHwFlowDefault = TRUE;
    *pfEcDefault = TRUE;
    *pfEccDefault = TRUE;

    if (GetRasPortString(
            hport, SER_C_DEFAULTOFFSTR_KEY, &pszValue, XLATE_None ) == 0)
    {
        if (StrStrA( pszValue, MXS_HDWFLOWCONTROL_KEY ) != NULL)
            *pfHwFlowDefault = FALSE;

        if (StrStrA( pszValue, MXS_PROTOCOL_KEY ) != NULL)
            *pfEcDefault = FALSE;

        if (StrStrA( pszValue, MXS_COMPRESSION_KEY ) != NULL)
            *pfEccDefault = FALSE;

        Free0( pszValue );
    }
}


DWORD
GetRasPortParam(
    IN  HPORT             hport,
    IN  CHAR*             pszKey,
    OUT RASMAN_PORTINFO** ppPortInfo,
    OUT RAS_PARAMS**      ppParam )

    /* Loads callers '*ppParam' with the address of a RAS_PARAM block
    ** associated with key 'pszKey', or NULL if none.  'ppPortInfo' is the
    ** address of the array of RAS_PARAMS containing the found 'pparam'.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to Free the returned '*ppPortInfo'.
    */
{
    DWORD dwErr = 0;
    DWORD dwSize = 0;
    INT   i;

    TRACE("GetRasPortParam");

    *ppPortInfo = NULL;

    do
    {
        ASSERT(g_pRasPortGetInfo);
        TRACE("RasPortGetInfo");
        dwErr = g_pRasPortGetInfo(NULL, hport, NULL, &dwSize );
        TRACE2("RasPortGetInfo=%d,s=%d",dwErr,(INT)dwSize);

        if (dwErr != ERROR_BUFFER_TOO_SMALL && dwErr != 0)
            break;

        /* So it will fall thru and be "not found".
        */
        if (dwSize == 0)
            dwSize = 1;

        *ppPortInfo = (RASMAN_PORTINFO* )Malloc( dwSize );
        if (!*ppPortInfo)
            return ERROR_NOT_ENOUGH_MEMORY;

        TRACE("RasPortGetInfo");
        dwErr = g_pRasPortGetInfo(NULL, hport, (PBYTE )*ppPortInfo, &dwSize );
        TRACE2("RasPortGetInfo=%d,s=%d",dwErr,(INT)dwSize);

        if (dwErr != 0)
            break;

        for (i = 0, *ppParam = (*ppPortInfo)->PI_Params;
             i < (INT )(*ppPortInfo)->PI_NumOfParams;
             ++i, ++(*ppParam))
        {
            if (lstrcmpiA( (*ppParam)->P_Key, pszKey ) == 0)
                break;
        }

        if (i >= (INT )(*ppPortInfo)->PI_NumOfParams)
            dwErr = ERROR_KEY_NOT_FOUND;
    }
    while (FALSE);

    return dwErr;
}


DWORD
GetRasPorts(
    IN  HANDLE        hConnection,
    OUT RASMAN_PORT** ppPorts,
    OUT DWORD*        pdwEntries )

    /* Enumerate RAS ports.  Sets '*ppPort' to the address of a heap memory
    ** block containing an array of PORT structures with '*pwEntries'
    ** elements.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to free the returned memory block.
    */
{
    DWORD dwSize = 0;
    DWORD dwErr;

    TRACE("GetRasPorts");

#if DUMMYPORTS

    {
        RASMAN_PORT* pPort;
        DWORD c;

        TRACE("TEST: Fake ISDN ports");

        *pdwEntries = c = g_cPorts;
        dwSize = *pdwEntries * sizeof(RASMAN_PORT);

        *ppPorts = (RASMAN_PORT* )Malloc( dwSize );
        if (!*ppPorts)
            return ERROR_NOT_ENOUGH_MEMORY;

        do
        {
            pPort = *ppPorts;
            ZeroMemory( pPort, sizeof(*pPort) );
            lstrcpyA( pPort->P_PortName, "COM1" );
            pPort->P_Status = CLOSED;
            pPort->P_ConfiguredUsage = CALL_OUT;
            pPort->P_CurrentUsage = CALL_OUT;
            lstrcpyA( pPort->P_MediaName, "rasser" );
            lstrcpyA( pPort->P_DeviceName, "US Robotics Courier V32 bis" );
            lstrcpyA( pPort->P_DeviceType, "MODEM" );
            if (--c == 0)
                break;

            ++pPort;
            ZeroMemory( pPort, sizeof(*pPort) );
            lstrcpyA( pPort->P_PortName, "ISDN1" );
            pPort->P_Status = CLOSED;
            pPort->P_ConfiguredUsage = CALL_OUT;
            pPort->P_CurrentUsage = CALL_OUT;
            lstrcpyA( pPort->P_MediaName, "rastapi" );
            lstrcpyA( pPort->P_DeviceName, "Digiboard PCIMac ISDN adapter" );
            lstrcpyA( pPort->P_DeviceType, "ISDN" );
            if (--c == 0)
                break;

            ++pPort;
            ZeroMemory( pPort, sizeof(*pPort) );
            lstrcpyA( pPort->P_PortName, "ISDN2" );
            pPort->P_Status = CLOSED;
            pPort->P_ConfiguredUsage = CALL_OUT;
            pPort->P_CurrentUsage = CALL_OUT;
            lstrcpyA( pPort->P_MediaName, "rastapi" );
            lstrcpyA( pPort->P_DeviceName, "Digiboard PCIMac ISDN adapter" );
            lstrcpyA( pPort->P_DeviceType, "ISDN" );
            if (--c == 0)
                break;

            ++pPort;
            ZeroMemory( pPort, sizeof(*pPort) );
            lstrcpyA( pPort->P_PortName, "COM500" );
            pPort->P_Status = CLOSED;
            pPort->P_ConfiguredUsage = CALL_OUT;
            pPort->P_CurrentUsage = CALL_OUT;
            lstrcpyA( pPort->P_MediaName, "rasser" );
            lstrcpyA( pPort->P_DeviceName, "Eicon X.PAD" );
            lstrcpyA( pPort->P_DeviceType, "PAD" );
            if (--c == 0)
                break;

            ++pPort;
            ZeroMemory( pPort, sizeof(*pPort) );
            lstrcpyA( pPort->P_PortName, "X251" );
            pPort->P_Status = CLOSED;
            pPort->P_ConfiguredUsage = CALL_OUT;
            pPort->P_CurrentUsage = CALL_OUT;
            lstrcpyA( pPort->P_MediaName, "rastapi" );
            lstrcpyA( pPort->P_DeviceName, "Digiboard X.25 adapter" );
            lstrcpyA( pPort->P_DeviceType, "X25" );
            if (--c == 0)
                break;

            ++pPort;
            ZeroMemory( pPort, sizeof(*pPort) );
            lstrcpyA( pPort->P_PortName, "VPN1" );
            pPort->P_Status = CLOSED;
            pPort->P_ConfiguredUsage = CALL_OUT;
            pPort->P_CurrentUsage = CALL_OUT;
            lstrcpyA( pPort->P_MediaName, "rastapi" );
            lstrcpyA( pPort->P_DeviceName, "RASPPTPM" );
            lstrcpyA( pPort->P_DeviceType, "VPN1" );
            if (--c == 0)
                break;
        }
        while (FALSE);
    }

#else

    ASSERT(g_pRasPortEnum);
    TRACE("RasPortEnum...");
    dwErr = g_pRasPortEnum(hConnection,  NULL, &dwSize, pdwEntries );
    TRACE2("RasPortEnum=%d,c=%d",dwErr,(INT)*pdwEntries);

    if (dwErr == 0)
    {
        /* No ports to enumerate.  Set up to allocate a single byte anyway, so
        ** things work without lots of special code.
        */
        dwSize = 1;
    }
    else if (dwErr != ERROR_BUFFER_TOO_SMALL)
        return dwErr;

    *ppPorts = (RASMAN_PORT* )Malloc( dwSize );
    if (!*ppPorts)
        return ERROR_NOT_ENOUGH_MEMORY;

    TRACE("RasPortEnum...");
    dwErr = g_pRasPortEnum(hConnection, (PBYTE )*ppPorts, &dwSize, pdwEntries );
    TRACE2("RasPortEnum=%d,c=%d",dwErr,(INT)*pdwEntries);

    if (dwErr != 0)
    {
        Free( *ppPorts );
        *ppPorts = NULL;
        return dwErr;
    }

#endif

#if 1 // Verbose trace
    {
        RASMAN_PORT* pPort;
        DWORD         i;

        for (pPort = *ppPorts, i = 0; i < *pdwEntries; ++i, ++pPort)
        {
            TRACE4("Port[%d]=%s,DID=$%08x,AID=$%08x",
                pPort->P_Handle,pPort->P_PortName,
                pPort->P_LineDeviceId,pPort->P_AddressId);
            TRACE3(" M=%s,DT=%s,DN=%s",
                pPort->P_MediaName,pPort->P_DeviceType,pPort->P_DeviceName);
            TRACE3(" S=$%08x,CfgU=$%08x,CurU=$%08x",
                pPort->P_Status,pPort->P_ConfiguredUsage,pPort->P_CurrentUsage);
        }
    }
#endif

    return 0;
}


DWORD
GetRasPortString(
    IN  HPORT  hport,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate )

    /* Loads callers '*ppszValue' with the address of a heap block containing
    ** a NUL-terminated copy of the value string associated with key 'pszKey'
    ** on port 'hport'.  'dwXlate' is a bit mask of XLATE_ bits specifying
    ** translations to be done on the string value.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to Free the returned string.
    */
{
    RASMAN_PORTINFO* pPortInfo;
    RAS_PARAMS*      pParam;
    DWORD            dwErr;

    TRACE("GetRasPortString");

    dwErr = GetRasPortParam( hport, pszKey, &pPortInfo, &pParam );

    *ppszValue = NULL;

    if (dwErr == 0)
    {
        *ppszValue = PszFromRasValue( &pParam->P_Value, dwXlate );
        dwErr = (*ppszValue) ? 0 : ERROR_NOT_ENOUGH_MEMORY;
    }

    Free0( pPortInfo );

    return dwErr;
}



DWORD
GetRasSwitches(
    IN  HANDLE hConnection,
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*          pdwEntries )

    /* Fills caller's '*ppDevices' with the address of a heap block containing
    ** '*pwEntries' switch DEVICE structures.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to free the returned memory block.
    */
{
    return GetRasDevices( hConnection, MXS_SWITCH_TXT, ppDevices, pdwEntries );
}

DWORD
GetRasUnimodemBlob(
    IN  HANDLE hConnection,
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    OUT BYTE** ppBlob,
    OUT DWORD* pcbBlob )
{
    return GetRasUnimodemBlobEx(
                hConnection,
                hport,
                pszDeviceType,
                FALSE,
                ppBlob,
                pcbBlob);
}

DWORD
GetRasUnimodemBlobEx(
    IN  HANDLE hConnection,
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    IN  BOOL   fGlobal,
    OUT BYTE** ppBlob,
    OUT DWORD* pcbBlob )

    /* Loads '*ppBlob' and '*pcbBlob' with the sanitized Unimodem blob and
    ** size associated with 'hport' and 'pszDeviceType'.  It is caller's
    ** responsibility to Free the returned '*ppBlob'.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD dwErr;
    BYTE* pBlob;
    DWORD cbBlob;
    PRASGETDEVCONFIG pFunc;
    CHAR* pszFuncName;
    cbBlob = 0;

    pFunc = (fGlobal) ? g_pRasGetDevConfigEx : g_pRasGetDevConfig;
    pszFuncName = (fGlobal) ? "RasGetDevConfigEx" : "RasGetDevConfig";
    
    ASSERT(pFunc);
    TRACE(pszFuncName);
    dwErr = pFunc(hConnection, hport, pszDeviceType, NULL, &cbBlob );
    TRACE2("%s=%d", pszFuncName, dwErr);

    if (dwErr != 0 && dwErr != ERROR_BUFFER_TOO_SMALL)
        return dwErr;

    if (cbBlob > 0)
    {
        pBlob = Malloc( cbBlob );
        if (!pBlob)
            return ERROR_NOT_ENOUGH_MEMORY;

        TRACE(pszFuncName);
        dwErr = pFunc(hConnection, hport, pszDeviceType, pBlob, &cbBlob );
        TRACE2("%s=%d", pszFuncName, dwErr);

        if (dwErr != 0)
        {
            Free( pBlob );
            return dwErr;
        }

        SanitizeUnimodemBlob( pBlob );
    }
    else
        pBlob = NULL;

    *ppBlob = pBlob;
    *pcbBlob = cbBlob;

    return dwErr;
}


VOID
GetRasUnimodemInfo(
    IN  HANDLE        hConnection,
    IN  HPORT         hport,
    IN  CHAR*         pszDeviceType,
    OUT UNIMODEMINFO* pInfo )

    /* Loads 'pInfo' with the RAS-relevant information of the port 'hport'
    ** with device name 'pszDeviceName'.
    */
{
    DWORD dwErr;
    BYTE* pBlob = NULL;
    DWORD cbBlob = 0;

    SetDefaultUnimodemInfo( pInfo );

    dwErr = GetRasUnimodemBlob( 
                        hConnection,
                        hport, 
                        pszDeviceType, 
                        &pBlob, 
                        &cbBlob );
                                
    if (dwErr == 0 && cbBlob > 0)
        UnimodemInfoFromBlob( pBlob, pInfo );

    Free0( pBlob );
}


TCHAR*
GetRasX25Diagnostic(
    IN HRASCONN hrasconn )

    /* Returns the X.25 diagnostics string or NULL if none.  It is caller's
    ** responsibility to Free the returned string.
    */
{
    DWORD       dwErr;
    HPORT       hport;
    RASMAN_INFO info;
    CHAR*       pszDiagnosticA = NULL;
    TCHAR*      pszDiagnostic = NULL;

    pszDiagnosticA = NULL;
    hport = g_pRasGetHport( hrasconn );

    ASSERT(g_pRasGetInfo);
    TRACE1("RasGetInfo(%d)",hport);
    dwErr = g_pRasGetInfo( NULL, hport, &info );
    TRACE1("RasGetInfo=%d",dwErr);

    /* Error codes are ignored here since the diagnosistic
    ** is informational only.  If they fail the diagnostic
    ** will simply appear blank.
    */
    if (dwErr == 0)
    {
        GetRasDeviceString(
            hport, info.RI_DeviceTypeConnecting,
            info.RI_DeviceConnecting, MXS_DIAGNOSTICS_KEY,
            &pszDiagnosticA, XLATE_Diagnostic );
    }

    if(NULL != pszDiagnosticA)
    {
        pszDiagnostic = StrDupTFromA( pszDiagnosticA );
        Free( pszDiagnosticA );
    }
    return pszDiagnostic;
}


BOOL
IsRasdevBundled(
    IN  RASDEV* pdev,
    IN  RASDEV* pDevTable,
    IN  DWORD   iDevCount
    )

    /* Determines whether the device described by 'pdev' is bundled,
    ** by looking for another device in 'pDevTable' which has the same bundle
    ** as 'pdev'.
    **
    ** Returnes TRUE if the device is bundled, FALSE otherwise.
    */
{

    DWORD   i;
    RASDEV* pdev2;
    DWORD   dwBundle;

    //
    // First get the device's bundle;
    // If this fails, assume it is not connected and return FALSE.
    //

    if (GetRasdevBundle(pdev, &dwBundle) != NO_ERROR) { return FALSE; }


    //
    // Walk through the other devices in the table, looking for one
    // with the same bundle.
    //

    for (i = 0, pdev2 = pDevTable;
         i < iDevCount; i++, pdev2++) {

        DWORD dwBundle2;

        //
        // skip this if it is the device we already know about
        //

        if (pdev->RD_Handle == pdev2->RD_Handle) { continue; }


        //
        // get the bundle
        //

        if (GetRasdevBundle(pdev2, &dwBundle2) != NO_ERROR) { continue; }


        //
        // if the bundle is the same, we know its multilinked
        //

        if (dwBundle == dwBundle2) { return TRUE; }
    }

    return FALSE;
}


CHAR*
PszFromRasValue(
    IN RAS_VALUE* prasvalue,
    IN DWORD      dwXlate )

    /* Returns the address of a heap block containing a NUL-terminated string
    ** value from caller's '*prasvalue', or NULL if out of memory.  'dwXlate'
    ** is a bit mask of XLATE_ bits specifying translations to be performed on
    ** the string.  The value is assumed to be of format String.  It is
    ** translated to modem.inf style.
    */
{
#define MAXEXPANDPERCHAR 5
#define HEXCHARS         "0123456789ABCDEF"

    INT   i;
    BOOL  fXlate;
    BOOL  fXlateCtrl;
    BOOL  fXlateCr;
    BOOL  fXlateCrSpecial;
    BOOL  fXlateLf;
    BOOL  fXlateLfSpecial;
    BOOL  fXlateLAngle;
    BOOL  fXlateRAngle;
    BOOL  fXlateBSlash;
    BOOL  fXlateSSpace;
    BOOL  fNoCharSinceLf;
    INT   nLen;
    CHAR* pszIn;
    CHAR* pszBuf;
    CHAR* pszOut;
    CHAR* pszTemp;

    nLen = prasvalue->String.Length;
    pszIn = prasvalue->String.Data;

    pszBuf = Malloc( (nLen * MAXEXPANDPERCHAR) + 1 );
    if (!pszBuf)
        return NULL;

    /* Translate the returned string based on the translation bit map.  The
    ** assumption here is that all these devices talk ASCII and not some
    ** localized ANSI.
    */
    fXlate = (dwXlate != 0);
    fXlateCtrl = (dwXlate & XLATE_Ctrl);
    fXlateCr = (dwXlate & XLATE_Cr);
    fXlateCrSpecial = (dwXlate & XLATE_CrSpecial);
    fXlateLf = (dwXlate & XLATE_Lf);
    fXlateLfSpecial = (dwXlate & XLATE_LfSpecial);
    fXlateLAngle = (dwXlate & XLATE_LAngle);
    fXlateRAngle = (dwXlate & XLATE_RAngle);
    fXlateBSlash = (dwXlate & XLATE_BSlash);
    fXlateSSpace = (dwXlate & XLATE_SSpace);

    pszOut = pszBuf;
    fNoCharSinceLf = TRUE;
    for (i = 0; i < nLen; ++i)
    {
        CHAR ch = pszIn[ i ];

        if (fXlate)
        {
            if (ch == 0x0D)
            {
                if (fXlateSSpace && fNoCharSinceLf)
                    continue;

                if (fXlateCrSpecial)
                {
                    /* Special symbol for carriage return.
                    */
                    lstrcpyA( pszOut, "<cr>" );
                    pszOut += 4;
                    continue;
                }
            }

            if (ch == 0x0A)
            {
                if (fXlateSSpace && fNoCharSinceLf)
                    continue;

                fNoCharSinceLf = TRUE;

                if (fXlateLfSpecial)
                {
                    /* Special symbol for line feed.
                    */
                    lstrcpyA( pszOut, "<lf>" );
                    pszOut += 4;
                    continue;
                }
            }

            if (ch != 0x0A && ch != 0x0D)
                fNoCharSinceLf = FALSE;

            if ((((ch < 0x20 || ch > 0x7E)
                   && ch != 0x0D && ch != 0x0A) && fXlateCtrl)
                || (ch == 0x0D && fXlateCr)
                || (ch == 0x0A && fXlateLf)
                || (ch == 0x3C && fXlateLAngle)
                || (ch == 0x3E && fXlateRAngle)
                || (ch == 0x5C && fXlateBSlash))
            {
                /* Expand to "dump" form, i.e. <hFF> where FF is the hex value
                ** of the character.
                */
                *pszOut++ = '<';
                *pszOut++ = 'h';
                *pszOut++ = HEXCHARS[ ch / 16 ];
                *pszOut++ = HEXCHARS[ ch % 16 ];
                *pszOut++ = '>';
                continue;
            }
        }

        /* Just copy without translation.
        */
        *pszOut++ = ch;
    }

    *pszOut = '\0';

    pszTemp = pszBuf;
    
    pszBuf = Realloc( pszBuf, lstrlenA( pszBuf ) + 1 );

    if(NULL == pszBuf)
    {
        Free(pszTemp);
    }

    return pszBuf;
}


VOID
SanitizeUnimodemBlob(
    IN OUT BYTE* pBlob )

    /* Fix non-RAS-compatible settings in unimodem blob 'pBlob'.
    **
    ** (Based on Gurdeepian routine)
    */
{
    DEVCFG*        pDevCfg;
    MODEMSETTINGS* pModemSettings;

    RAS_DEVCONFIG* pRasDevCfg;

    pRasDevCfg = (RAS_DEVCONFIG*)pBlob;

    pDevCfg = (DEVCFG *)
        ((PBYTE) pRasDevCfg + pRasDevCfg->dwOffsetofModemSettings);

    pModemSettings = (MODEMSETTINGS* )(((BYTE* )&pDevCfg->commconfig)
        + pDevCfg->commconfig.dwProviderOffset);

    TRACE1(
        "SanitizeUnimodemBlob: mdm prot=%d", 
        MDM_GET_EXTENDEDINFO(pModemSettings->dwPreferredModemOptions)); 

    /* No unimodem service provider pre/post-connect terminal, operator dial,
    ** or tray lights.  RAS does these itself.
    */
    pDevCfg->dfgHdr.fwOptions = 0;

    pDevCfg->commconfig.dcb.fBinary           = TRUE;
    pDevCfg->commconfig.dcb.fParity           = TRUE;
    pDevCfg->commconfig.dcb.fOutxDsrFlow      = FALSE;
    pDevCfg->commconfig.dcb.fDtrControl       = DTR_CONTROL_ENABLE;
    pDevCfg->commconfig.dcb.fTXContinueOnXoff = FALSE;
    pDevCfg->commconfig.dcb.fOutX             = FALSE;
    pDevCfg->commconfig.dcb.fInX              = FALSE;
    pDevCfg->commconfig.dcb.fErrorChar        = FALSE;
    pDevCfg->commconfig.dcb.fNull             = FALSE;
    pDevCfg->commconfig.dcb.fAbortOnError     = FALSE;
    pDevCfg->commconfig.dcb.ByteSize          = 8;
    pDevCfg->commconfig.dcb.Parity            = NOPARITY;
    pDevCfg->commconfig.dcb.StopBits          = ONESTOPBIT;

    /* Wait 55 seconds to establish call.
    */
/*    
    pModemSettings->dwCallSetupFailTimer = 55;

*/  

    /* Disable inactivity timeout.
    */
    pModemSettings->dwInactivityTimeout = 0;
}


VOID
SetDefaultUnimodemInfo(
    OUT UNIMODEMINFO* pInfo )

    /* Sets 'pInfo' to default settings.
    */
{
    pInfo->fHwFlow = FALSE;
    pInfo->fEc = FALSE;
    pInfo->fEcc = FALSE;
    pInfo->dwBps = 9600;
    pInfo->fSpeaker = TRUE;
    pInfo->fOperatorDial = FALSE;
    pInfo->fUnimodemPreTerminal = FALSE;
}

VOID
UnimodemProtInfoFromExtendedCaps(
    OUT UNIMODEMINFO*  pInfo,
    IN  BYTE*          pExtCapsBlob)

    /* Loads the modem protocol info for 'pInfo' from the extended caps
    ** blob retrieved from tapi.
    **
    */
{
    MODEM_PROTOCOL_CAPS* lpProtCaps = NULL;
    PROTOCOL_ITEM*       pProtItem  = NULL;
    DWORD                dwIndex;

    do
    {
        // Extract the modem caps
        //
        lpProtCaps  = (MODEM_PROTOCOL_CAPS *)pExtCapsBlob;

        if (lpProtCaps->hdr.dwSig != dwSIG_MODEM_PROTOCOL_CAPS ||
            lpProtCaps->dwNumProtocols == 0                    ||
            lpProtCaps->dwProtocolListOffset == 0)
        {
            break;
        }

        // If no protocols are supported, don't bother creating the
        // list
        if (lpProtCaps->dwNumProtocols == 0)
        {
            break;
        }

        // Create the list
        //
        pInfo->pListProtocols = DtlCreateList(0);
        if (pInfo->pListProtocols == NULL)
        {
            break;
        }

        // Get the list of supported protocols
        //
        pProtItem = (PROTOCOL_ITEM*)
            (((LPBYTE)lpProtCaps) + lpProtCaps->dwProtocolListOffset);

        // Enumerate the protocols
        //
        for (dwIndex = 0;
             dwIndex < lpProtCaps->dwNumProtocols;
             dwIndex++, pProtItem++)
        {
            DTLNODE * pNode = NULL;
            PWCHAR    pszName = NULL;
            DWORD     dwSize;

            // Get the friendly name from the structure
            //
            pszName = (PWCHAR)
                (pExtCapsBlob + pProtItem->dwProtocolNameOffset);
            if (pszName == NULL)
            {
                continue;
            }

            // Calculate the size of the friendly name
            //
            dwSize = (wcslen(pszName) + 1) * sizeof(WCHAR);

            // Allocate a node accordingly
            //
            pNode =
                DtlCreateSizedNode(dwSize, (LONG_PTR)pProtItem->dwProtocol);
            if (pNode == NULL)
            {
                continue;
            }

            // Initialize the node and add it to the list
            //
            wcscpy((PWCHAR) DtlGetData(pNode), pszName);
            DtlAddNodeLast(pInfo->pListProtocols, pNode);
        }

    } while (FALSE);

    // Cleanup
    {
    }
}

VOID
UnimodemInfoFromBlob(
    IN  BYTE*         pBlob,
    OUT UNIMODEMINFO* pInfo )

    /* Loads 'pInfo' with RAS-relevant Unimodem information retrieved from
    ** Unimodem blob 'pBlob'.
    **
    ** (Based on Gurdeepian routine)
    */
{
    DEVCFG*        pDevCfg;
    MODEMSETTINGS* pModemSettings;

    RAS_DEVCONFIG* pRasDevCfg;

    pRasDevCfg = (RAS_DEVCONFIG*)pBlob;

    pDevCfg = (DEVCFG *)
        ((PBYTE) pRasDevCfg + pRasDevCfg->dwOffsetofModemSettings);

    pModemSettings = (MODEMSETTINGS* )(((BYTE* )&pDevCfg->commconfig)
        + pDevCfg->commconfig.dwProviderOffset);

    pInfo->fSpeaker =
        (pModemSettings->dwSpeakerMode != MDMSPKR_OFF)
            ? TRUE : FALSE;

    pInfo->fHwFlow =
        (pModemSettings->dwPreferredModemOptions & MDM_FLOWCONTROL_HARD)
            ? TRUE : FALSE;

    pInfo->fEcc =
        (pModemSettings->dwPreferredModemOptions & MDM_COMPRESSION)
            ? TRUE : FALSE;

    pInfo->fEc =
        (pModemSettings->dwPreferredModemOptions & MDM_ERROR_CONTROL)
            ? TRUE : FALSE;

    pInfo->dwBps = pDevCfg->commconfig.dcb.BaudRate;

    pInfo->fOperatorDial =
        (pDevCfg->dfgHdr.fwOptions & MANUAL_DIAL)
            ? TRUE : FALSE;

    pInfo->fUnimodemPreTerminal =
        (pDevCfg->dfgHdr.fwOptions & TERMINAL_PRE)
            ? TRUE : FALSE;

    // Get the modem protocol
    //
    pInfo->dwModemProtocol =
        MDM_GET_EXTENDEDINFO(pModemSettings->dwPreferredModemOptions);

    // Pull out the extended caps stuff
    //
    if ( pRasDevCfg->dwSizeofExtendedCaps )
    {
        UnimodemProtInfoFromExtendedCaps(
            pInfo,
            (BYTE*)(pBlob + pRasDevCfg->dwOffsetofExtendedCaps));
    }
    else
    {
        pInfo->pListProtocols = NULL;
    }
}


VOID
UnimodemInfoToBlob(
    IN     UNIMODEMINFO* pInfo,
    IN OUT BYTE*         pBlob )

    /* Applies RAS-relevant Unimodem information supplied in 'pInfo' to
    ** Unimodem blob 'pBlob'.
    **
    ** (Based on Gurdeepian routine)
    */
{
    DEVCFG*        pDevCfg;
    MODEMSETTINGS* pModemSettings;

    RAS_DEVCONFIG* pRasDevCfg;

    pRasDevCfg = (RAS_DEVCONFIG*) pBlob;

    // Pull out the device config stuff
    //
    pDevCfg = (DEVCFG *)
        ((PBYTE) pRasDevCfg + pRasDevCfg->dwOffsetofModemSettings);

    pModemSettings = (MODEMSETTINGS* )(((BYTE* )&pDevCfg->commconfig)
        + pDevCfg->commconfig.dwProviderOffset);

    pModemSettings->dwSpeakerMode =
        (pInfo->fSpeaker) ? MDMSPKR_DIAL : MDMSPKR_OFF;

    if (pInfo->fHwFlow)
    {
        pDevCfg->commconfig.dcb.fOutxCtsFlow = TRUE;
        pDevCfg->commconfig.dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
        pModemSettings->dwPreferredModemOptions |= MDM_FLOWCONTROL_HARD;
    }
    else
    {
        pDevCfg->commconfig.dcb.fOutxCtsFlow = FALSE;
        pDevCfg->commconfig.dcb.fRtsControl = RTS_CONTROL_DISABLE;
        pModemSettings->dwPreferredModemOptions &= ~(MDM_FLOWCONTROL_HARD);
    }

    if (pInfo->fEc)
        pModemSettings->dwPreferredModemOptions |= MDM_ERROR_CONTROL;
    else
        pModemSettings->dwPreferredModemOptions &= ~(MDM_ERROR_CONTROL);

    if (pInfo->fEcc)
        pModemSettings->dwPreferredModemOptions |= MDM_COMPRESSION;
    else
        pModemSettings->dwPreferredModemOptions &= ~(MDM_COMPRESSION);

    pDevCfg->commconfig.dcb.BaudRate = pInfo->dwBps;

    if (pInfo->fOperatorDial)
        pDevCfg->dfgHdr.fwOptions |= MANUAL_DIAL;

    if (pInfo->fUnimodemPreTerminal)
        pDevCfg->dfgHdr.fwOptions |= TERMINAL_PRE;

      // Set the modem protocol
      //
      MDM_SET_EXTENDEDINFO(
          pModemSettings->dwPreferredModemOptions,
          pInfo->dwModemProtocol);

}

WCHAR *GetUnicodeName(HPORT hport)
{
    WCHAR *pwsz = Malloc(sizeof(WCHAR) * (MAX_DEVICE_NAME + 1));

    if(NULL != pwsz)
    {
        if(ERROR_SUCCESS != RasGetUnicodeDeviceName(
                                hport,
                                pwsz))
        {
            Free(pwsz);
            pwsz = NULL;
        }
    }

    return pwsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\rasrpc.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    rasrpclb.c

ABSTRACT
    rasrpc client/server common routines

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include "rasrpc.h"
#include <ras.h>
#include <rasman.h>
#include <raserror.h>
#include <mprapi.h>
#include <nouiutil.h>
#include <dtl.h>
#include <debug.h>

//
// Handle NULL string parameters 
// to the TRACE macro.
//
#define TRACESTR(s)     (s) != NULL ? (s) : TEXT("")

DWORD
CallbackListToRpc(
    OUT LPRASRPC_CALLBACKLIST *pCallbacks,
    IN DTLLIST *pdtllistCallbacks
    )
{
    DTLNODE *pdtlnode;
    LPRASRPC_CALLBACKLIST pNewCallback, pTail = NULL;
    CALLBACKINFO *pCallback;

TRACE("CallbackListToRpc: begin");
    *pCallbacks = NULL;
    for (pdtlnode = DtlGetFirstNode(pdtllistCallbacks);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        pCallback = (CALLBACKINFO *)DtlGetData(pdtlnode);
        
        //
        // Allocate and initialize
        // the new structure.
        //
        pNewCallback = MIDL_user_allocate(sizeof (RASRPC_CALLBACKLIST));
        if (pNewCallback == NULL)
            return GetLastError();
        if (pCallback->pszPortName != NULL)
            lstrcpyn(pNewCallback->pszPortName, pCallback->pszPortName, 17);
        else 
            *pNewCallback->pszPortName = TEXT('\0');
        if (pCallback->pszDeviceName != NULL)
            lstrcpyn(pNewCallback->pszDeviceName, pCallback->pszDeviceName, 129);
        else 
            *pNewCallback->pszDeviceName = TEXT('\0');
        if (pCallback->pszNumber != NULL)
            lstrcpyn(pNewCallback->pszNumber, pCallback->pszNumber, 129);
        else 
            *pNewCallback->pszNumber = TEXT('\0');
        pNewCallback->dwDeviceType = pCallback->dwDeviceType;
TRACE2("CallbackListToRpc: new node: %S, %S", pCallback->pszPortName, pCallback->pszDeviceName);
        pNewCallback->pNext = NULL;
        //
        // Insert it at the tail of the list.
        //
        if (*pCallbacks == NULL)
            *pCallbacks = pTail = pNewCallback;
        else {
            pTail->pNext = pNewCallback;
            pTail = pNewCallback;
        }
    }
TRACE("CallbackListToRpc: end");
    return 0;
}


DWORD
CallbackListFromRpc(
    OUT DTLLIST **pdtllistCallbacks,
    IN LPRASRPC_CALLBACKLIST pCallbacks
    )
{
    LPRASRPC_CALLBACKLIST pCallback;
    DTLNODE *pdtlnode;

TRACE("CallbackListFromRpc: begin");
    //
    // Initialize the new list.
    //
    *pdtllistCallbacks = DtlCreateList(0);
    if (*pdtllistCallbacks == NULL)
        return GetLastError();

    for (pCallback = pCallbacks; pCallback != NULL; pCallback = pCallback->pNext)
    {
        pdtlnode = CreateCallbackNode(pCallback->pszPortName, pCallback->pszDeviceName, pCallback->pszNumber, pCallback->dwDeviceType);
        if (pdtlnode == NULL)
            return GetLastError();
TRACE2("CallbackListToRpc: new node: %S, %S", pCallback->pszPortName, pCallback->pszDeviceName);
        DtlAddNodeLast(*pdtllistCallbacks, pdtlnode);
    }
TRACE("CallbackListFromRpc: end");
    return 0;
}


DWORD
StringListToRpc(
    OUT LPRASRPC_STRINGLIST *pStrings,
    IN DTLLIST *pdtllistStrings
    )
{
    DTLNODE *pdtlnode;
    LPRASRPC_STRINGLIST pNewString, pTail = NULL;
    PWCHAR psz;

TRACE("StringListToRpc: begin");
    *pStrings = NULL;
    for (pdtlnode = DtlGetFirstNode(pdtllistStrings);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        psz = (PWCHAR)DtlGetData(pdtlnode);
        
        //
        // Allocate and initialize
        // the new structure.
        //
        pNewString = MIDL_user_allocate(sizeof (RASRPC_STRINGLIST));
        if (pNewString == NULL)
            return GetLastError();
        if (psz != NULL)
            lstrcpyn(pNewString->psz, psz, 256);
        else
            *pNewString->psz = TEXT('\0');
        pNewString->pNext = NULL;
TRACE1("StringListToRpc: new node: %S", psz);
        //
        // Insert it at the tail of the list.
        //
        if (*pStrings == NULL)
            *pStrings = pTail = pNewString;
        else {
            pTail->pNext = pNewString;
            pTail = pNewString;
        }
    }
TRACE("StringListToRpc: end");
    return 0;
}


DWORD
StringListFromRpc(
    OUT DTLLIST **pdtllistStrings,
    IN LPRASRPC_STRINGLIST pStrings
    )
{
    LPRASRPC_STRINGLIST pString;
    DTLNODE *pdtlnode;

    //
    // Initialize the new list.
    //
TRACE("StringListFromRpc: begin");
    *pdtllistStrings = DtlCreateList(0);
    if (*pdtllistStrings == NULL)
        return GetLastError();

    for (pString = pStrings; pString != NULL; pString = pString->pNext)
    {
        pdtlnode = CreatePszNode(pString->psz);
        if (pdtlnode == NULL)
            return GetLastError();
TRACE1("StringListToRpc: new node: %S", pString->psz);
        DtlAddNodeLast(*pdtllistStrings, pdtlnode);
    }
TRACE("StringListFromRpc: end");
    return 0;
}


DWORD
LocationListToRpc(
    OUT LPRASRPC_LOCATIONLIST *pLocations,
    IN DTLLIST *pdtllistLocations
    )
{
    DTLNODE *pdtlnode;
    LPRASRPC_LOCATIONLIST pNewLocation, pTail = NULL;
    LOCATIONINFO *pLocation;

TRACE("LocationListToRpc: begin");
    *pLocations = NULL;
    for (pdtlnode = DtlGetFirstNode(pdtllistLocations);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        pLocation = (LOCATIONINFO *)DtlGetData(pdtlnode);
        
        //
        // Allocate and initialize
        // the new structure.
        //
        pNewLocation = MIDL_user_allocate(sizeof (RASRPC_LOCATIONLIST));
        if (pNewLocation == NULL)
            return GetLastError();
        pNewLocation->dwLocationId = pLocation->dwLocationId;
        pNewLocation->iPrefix = pLocation->iPrefix;
        pNewLocation->iSuffix = pLocation->iSuffix;
        pNewLocation->pNext = NULL;
TRACE3("LocationListToRpc: new node: %d, %d, %d", pLocation->dwLocationId, pLocation->iPrefix, pLocation->iSuffix);
        //
        // Insert it at the tail of the list.
        //
        if (*pLocations == NULL)
            *pLocations = pTail = pNewLocation;
        else {
            pTail->pNext = pNewLocation;
            pTail = pNewLocation;
        }
    }
TRACE("LocationListToRpc: end");
    return 0;
}


DWORD
LocationListFromRpc(
    OUT DTLLIST **pdtllistLocations,
    IN LPRASRPC_LOCATIONLIST pLocations
    )
{
    LPRASRPC_LOCATIONLIST pLocation;
    DTLNODE *pdtlnode;

    //
    // Initialize the new list.
    //
TRACE("LocationListFromRpc: begin");
    *pdtllistLocations = DtlCreateList(0);
    if (*pdtllistLocations == NULL)
        return GetLastError();

    for (pLocation = pLocations; pLocation != NULL; pLocation = pLocation->pNext)
    {
        pdtlnode = CreateLocationNode(pLocation->dwLocationId, pLocation->iPrefix, pLocation->iSuffix);
        if (pdtlnode == NULL)
            return GetLastError();
TRACE3("LocationListFromRpc: new node: %d, %d, %d", pLocation->dwLocationId, pLocation->iPrefix, pLocation->iSuffix);
        DtlAddNodeLast(*pdtllistLocations, pdtlnode);
    }
TRACE("LocationListFromRpc: end");
    return 0;
}


DWORD
RasToRpcPbuser(
    LPRASRPC_PBUSER pUser,
    PBUSER *pPbuser
    )
{
    DWORD dwErr;

    TRACE("RasToRpcPbUser: begin");
    pUser->fOperatorDial = pPbuser->fOperatorDial;
    pUser->fPreviewPhoneNumber = pPbuser->fPreviewPhoneNumber;
    pUser->fUseLocation = pPbuser->fUseLocation;
    pUser->fShowLights = pPbuser->fShowLights;
    pUser->fShowConnectStatus = pPbuser->fShowConnectStatus;
    pUser->fCloseOnDial = pPbuser->fCloseOnDial;
    pUser->fAllowLogonPhonebookEdits = pPbuser->fAllowLogonPhonebookEdits;
    pUser->fAllowLogonLocationEdits = pPbuser->fAllowLogonLocationEdits;
    pUser->fSkipConnectComplete = pPbuser->fSkipConnectComplete;
    pUser->fNewEntryWizard = pPbuser->fNewEntryWizard;
    pUser->dwRedialAttempts = pPbuser->dwRedialAttempts;
    pUser->dwRedialSeconds = pPbuser->dwRedialSeconds;
    pUser->dwIdleDisconnectSeconds = pPbuser->dwIdleDisconnectSeconds;
    pUser->fRedialOnLinkFailure = pPbuser->fRedialOnLinkFailure;
    pUser->fPopupOnTopWhenRedialing = pPbuser->fPopupOnTopWhenRedialing;
    pUser->fExpandAutoDialQuery = pPbuser->fExpandAutoDialQuery;
    pUser->dwCallbackMode = pPbuser->dwCallbackMode;
    dwErr = CallbackListToRpc(&pUser->pCallbacks, pPbuser->pdtllistCallback);
    if (dwErr)
        return dwErr;
    if (pPbuser->pszLastCallbackByCaller != NULL)
        lstrcpyn(pUser->pszLastCallbackByCaller, pPbuser->pszLastCallbackByCaller, 129);
    else
        *pUser->pszLastCallbackByCaller = TEXT('\0');
    pUser->dwPhonebookMode = pPbuser->dwPhonebookMode;
    if (pPbuser->pszPersonalFile != NULL)
        lstrcpyn(pUser->pszPersonalFile, pPbuser->pszPersonalFile, 260);
    else 
        *pUser->pszPersonalFile = TEXT('\0');
    if (pPbuser->pszAlternatePath != NULL)
        lstrcpyn(pUser->pszAlternatePath, pPbuser->pszAlternatePath, 260);
    else 
        *pUser->pszAlternatePath = TEXT('\0');
    dwErr = StringListToRpc(&pUser->pPhonebooks, pPbuser->pdtllistPhonebooks);
    if (dwErr)
        return dwErr;
    dwErr = StringListToRpc(&pUser->pAreaCodes, pPbuser->pdtllistAreaCodes);
    if (dwErr)
        return dwErr;
    pUser->fUseAreaAndCountry = pPbuser->fUseAreaAndCountry;
    dwErr = StringListToRpc(&pUser->pPrefixes, pPbuser->pdtllistPrefixes);
    if (dwErr)
        return dwErr;
    dwErr = StringListToRpc(&pUser->pSuffixes, pPbuser->pdtllistSuffixes);
    if (dwErr)
        return dwErr;
    dwErr = LocationListToRpc(&pUser->pLocations, pPbuser->pdtllistLocations);
    if (dwErr)
        return dwErr;
    pUser->dwXPhonebook = pPbuser->dwXPhonebook;
    pUser->dwYPhonebook = pPbuser->dwYPhonebook;
    if (pPbuser->pszDefaultEntry != NULL)
        lstrcpyn(pUser->pszDefaultEntry, pPbuser->pszDefaultEntry, 257);
    else 
        *pUser->pszDefaultEntry = TEXT('\0');
    pUser->fInitialized = pPbuser->fInitialized;
    pUser->fDirty = pPbuser->fDirty;
    TRACE("RasToRpcPbUser: end");

    return 0;
}


DWORD
RpcToRasPbuser(
    PBUSER *pPbuser,
    LPRASRPC_PBUSER pUser
    )
{
    DWORD dwErr;

    TRACE("RpcToRasPbUser: begin");
    pPbuser->fOperatorDial = pUser->fOperatorDial;
    pPbuser->fPreviewPhoneNumber = pUser->fPreviewPhoneNumber;
    pPbuser->fUseLocation = pUser->fUseLocation;
    pPbuser->fShowLights = pUser->fShowLights;
    pPbuser->fShowConnectStatus = pUser->fShowConnectStatus;
    pPbuser->fCloseOnDial = pUser->fCloseOnDial;
    pPbuser->fAllowLogonPhonebookEdits = pUser->fAllowLogonPhonebookEdits;
    pPbuser->fAllowLogonLocationEdits = pUser->fAllowLogonLocationEdits;
    pPbuser->fSkipConnectComplete = pUser->fSkipConnectComplete;
    pPbuser->fNewEntryWizard = pUser->fNewEntryWizard;
    pPbuser->dwRedialAttempts = pUser->dwRedialAttempts;
    pPbuser->dwRedialSeconds = pUser->dwRedialSeconds;
    pPbuser->dwIdleDisconnectSeconds = pUser->dwIdleDisconnectSeconds;
    pPbuser->fRedialOnLinkFailure = pUser->fRedialOnLinkFailure;
    pPbuser->fPopupOnTopWhenRedialing = pUser->fPopupOnTopWhenRedialing;
    pPbuser->fExpandAutoDialQuery = pUser->fExpandAutoDialQuery;
    pPbuser->dwCallbackMode = pUser->dwCallbackMode;
    dwErr = CallbackListFromRpc(&pPbuser->pdtllistCallback, pUser->pCallbacks);
    if (dwErr)
        return dwErr;

    pUser->pszLastCallbackByCaller[RAS_MaxPhoneNumber] = TEXT('\0');
        
    pPbuser->pszLastCallbackByCaller = StrDup(pUser->pszLastCallbackByCaller);
    if (pPbuser->pszLastCallbackByCaller == NULL)
        return GetLastError();
    pPbuser->dwPhonebookMode = pUser->dwPhonebookMode;

    pUser->pszPersonalFile[MAX_PATH - 1] = TEXT('\0');
    
    pPbuser->pszPersonalFile = StrDup(pUser->pszPersonalFile);
    if (pPbuser->pszPersonalFile == NULL)
        return GetLastError();

    pUser->pszAlternatePath[MAX_PATH - 1] = TEXT('\0');
        
    pPbuser->pszAlternatePath = StrDup(pUser->pszAlternatePath);
    if (pPbuser->pszAlternatePath == NULL)
        return GetLastError();
    dwErr = StringListFromRpc(&pPbuser->pdtllistPhonebooks, pUser->pPhonebooks);
    if (dwErr)
        return dwErr;
    dwErr = StringListFromRpc(&pPbuser->pdtllistAreaCodes, pUser->pAreaCodes);
    if (dwErr)
        return dwErr;
    pPbuser->fUseAreaAndCountry = pUser->fUseAreaAndCountry;
    dwErr = StringListFromRpc(&pPbuser->pdtllistPrefixes, pUser->pPrefixes);
    if (dwErr)
        return dwErr;
    dwErr = StringListFromRpc(&pPbuser->pdtllistSuffixes, pUser->pSuffixes);
    if (dwErr)
        return dwErr;
    dwErr = LocationListFromRpc(&pPbuser->pdtllistLocations, pUser->pLocations);
    if (dwErr)
        return dwErr;
    pPbuser->dwXPhonebook = pUser->dwXPhonebook;
    pPbuser->dwYPhonebook = pUser->dwYPhonebook;

    pUser->pszDefaultEntry[RAS_MaxEntryName - 1] = TEXT('\0');
    
    pPbuser->pszDefaultEntry = StrDup(pUser->pszDefaultEntry);
    if (pPbuser->pszDefaultEntry == NULL)
        return GetLastError();
    pPbuser->fInitialized = pUser->fInitialized;
    pPbuser->fDirty = pUser->fDirty;

#if DBG
    TRACE1("fOperatorDial=%d", pPbuser->fOperatorDial);
    TRACE1("fPreviewPhoneNumber=%d", pPbuser->fPreviewPhoneNumber);
    TRACE1("fUseLocation=%d", pPbuser->fUseLocation);
    TRACE1("fShowLights=%d", pPbuser->fShowLights);
    TRACE1("fShowConnectStatus=%d", pPbuser->fShowConnectStatus);
    TRACE1("fCloseOnDial=%d", pPbuser->fCloseOnDial);
    TRACE1("fAllowLogonPhonebookEdits=%d", pPbuser->fAllowLogonPhonebookEdits);
    TRACE1("fAllowLogonLocationEdits=%d", pPbuser->fAllowLogonLocationEdits);
    TRACE1("fSkipConnectComplete=%d", pPbuser->fSkipConnectComplete);
    TRACE1("fNewEntryWizard=%d", pPbuser->fNewEntryWizard);
    TRACE1("dwRedialAttempts=%d", pPbuser->dwRedialAttempts);
    TRACE1("dwRedialSeconds=%d", pPbuser->dwRedialSeconds);
    TRACE1("dwIdleDisconnectSeconds=%d", pPbuser->dwIdleDisconnectSeconds);
    TRACE1("fRedialOnLinkFailure=%d", pPbuser->fRedialOnLinkFailure);
    TRACE1("fPopupOnTopWhenRedialing=%d", pPbuser->fPopupOnTopWhenRedialing);
    TRACE1("fExpandAutoDialQuery=%d", pPbuser->fExpandAutoDialQuery);
    TRACE1("dwCallbackMode=%d", pPbuser->dwCallbackMode);
    TRACE1("pszLastCallbackByCaller=%S", TRACESTR(pPbuser->pszLastCallbackByCaller));
    TRACE1("dwPhonebookMode=%d", pPbuser->dwPhonebookMode);
    TRACE1("pszPersonalFile=%S", TRACESTR(pPbuser->pszPersonalFile));
    TRACE1("pszAlternatePath=%S", TRACESTR(pPbuser->pszAlternatePath));
    TRACE1("fUseAreaAndCountry=%d", pPbuser->fUseAreaAndCountry);
    TRACE1("dwXPhonebook=%d", pPbuser->dwXPhonebook);
    TRACE1("dwYPhonebook=%d", pPbuser->dwYPhonebook);
    TRACE1("pszDefaultEntry=%S", TRACESTR(pPbuser->pszDefaultEntry));
    TRACE1("fInitialized=%d", pPbuser->fInitialized);
    TRACE1("fDirty=%d", pPbuser->fDirty);
#endif
    TRACE("RpcToRasPbUser: end");

    return 0;
}


//
// Utility routines.
//
void * __RPC_USER 
MIDL_user_allocate(size_t size)
{
    return(Malloc(size));
}


void __RPC_USER 
MIDL_user_free( void *pointer)
{
    Free(pointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\nouiutil\utilsys.c ===
/* Copyright (c) 2000, Microsoft Corporation, all rights reserved
**
** utilsys.c
** Non-UI system helper routines (no HWNDs required)
** Listed alphabetically
**
** 12/14/2000  gangz,  cut from original ...\rasdlg\util.c to make some system utility funciton to
** the very base for both rassrvui and rasdlg
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace/Assert library
#include <lmwksta.h>   // NetWkstaGetInfo
#include <lmapibuf.h>  // NetApiBufferFree
#include <dsrole.h>    // machine is a member of a workgroup or domain, etc.
#include <tchar.h>
#include <nouiutil.h>  

// Cached workstation and logon information.  See GetLogonUser,
// GetLogonDomain, and GetComputer.
//
static TCHAR g_szLogonUser[ UNLEN + 1 ];
static TCHAR g_szLogonDomain[ DNLEN + 1 ];
static TCHAR g_szComputer[ CNLEN + 1 ];
static DWORD g_dwSku, g_dwProductType;
static DSROLE_MACHINE_ROLE g_DsRole;
static BOOL g_fMachineSkuAndRoleInitialized = FALSE;

//-----------------------------------------------------------------------------
// Local helper prototypes (alphabetically)
//-----------------------------------------------------------------------------
DWORD
GetComputerRole(
    DSROLE_MACHINE_ROLE* pRole );

DWORD
GetComputerSuite(
    LPDWORD lpdwSku );

DWORD
GetComputerSuiteAndProductType(
    LPDWORD lpdwSku,
    LPDWORD lpdwType);

VOID
GetWkstaUserInfo(
    void );

DWORD 
LoadSkuAndRole(
    void);


//-----------------------------------------------------------------------------
// Utility routines 
//-----------------------------------------------------------------------------

TCHAR*
GetLogonUser(
    void )

    // Returns the address of a static buffer containing the logged on user's
    // account name.
    //
{
    if (g_szLogonUser[ 0 ] == TEXT('\0'))
    {
        GetWkstaUserInfo();
    }

    TRACEW1( "GetLogonUser=%s",g_szLogonUser );
    return g_szLogonUser;
}


VOID
GetWkstaUserInfo(
    void )

    // Helper to load statics with NetWkstaUserInfo information.  See
    // GetLogonUser and GetLogonDomain.
    //
{
    DWORD dwErr;
    WKSTA_USER_INFO_1* pInfo;

    pInfo = NULL;
    TRACE( "NetWkstaUserGetInfo" );
    dwErr = NetWkstaUserGetInfo( NULL, 1, (LPBYTE* )&pInfo );
    TRACE1( "NetWkstaUserGetInfo=%d", dwErr );

    if (pInfo)
    {
        if (dwErr == 0)
        {
            lstrcpyn( g_szLogonUser, pInfo->wkui1_username, UNLEN + 1 );
            lstrcpyn( g_szLogonDomain, pInfo->wkui1_logon_domain, DNLEN + 1 );
        }

        NetApiBufferFree( pInfo );
    }
}


TCHAR*
GetLogonDomain(
    void )

    // Returns the address of a static buffer containing the logged on user's
    // domain name.
    //
{
    if (g_szLogonDomain[ 0 ] == TEXT('\0'))
    {
        GetWkstaUserInfo();
    }

    TRACEW1( "GetLogonDomain=%s", g_szLogonDomain );
    return g_szLogonDomain;
}

//Add this for bug 342810   328673
//
//Firewall is available for Personal, Professional and Standard Server
//And Domain membership doesnt affect
//
BOOL
IsFirewallAvailablePlatform(
    void)
{
    DWORD dwSku, dwType;
    BOOL fAvailable = TRUE;

    if (GetComputerSuiteAndProductType(&dwSku, &dwType) != NO_ERROR)
    {
        return FALSE;
    }

    do {
        //If it is a personal
        //
        if ( dwSku & VER_SUITE_PERSONAL )
        {   
            fAvailable = TRUE;
            break;
         }

        //if it is a Professional
        //
        if ( dwType & VER_NT_WORKSTATION && 
             !(dwSku & VER_SUITE_PERSONAL) )
        {
            fAvailable = TRUE;
            break;
         }

        //if it is a standard Server
        //
        if ( dwType & VER_NT_SERVER  &&
             !(dwSku & VER_SUITE_ENTERPRISE) &&
             !(dwSku & VER_SUITE_DATACENTER) )
        {
            fAvailable = TRUE;
            break;
        }
    }
    while (FALSE);

    return fAvailable;
}

BOOL
IsAdvancedServerPlatform(
    void)
{
    DWORD dwSku;

    if (GetComputerSuite(&dwSku) != NO_ERROR)
    {
        return FALSE;
    }
    
    return ( dwSku & VER_SUITE_ENTERPRISE );
}

BOOL
IsPersonalPlatform(
    void)
{
    DWORD dwSku;

    if (GetComputerSuite(&dwSku) != NO_ERROR)
    {
        return FALSE;
    }
    
    return ( dwSku & VER_SUITE_PERSONAL );
}

BOOL
IsStandaloneWKS(
    void)
{
    DSROLE_MACHINE_ROLE DsRole;

    if (GetComputerRole(&DsRole) != NO_ERROR)
    {
        return FALSE;
    }

    return ( DsRole == DsRole_RoleStandaloneWorkstation );

}

BOOL
IsConsumerPlatform(
    void)

    // Returns whether this is a consumer platform so the UI can render itself
    // for simpler cases.  In Whistler, the consumer platforms were the 
    // (personal sku) and the (professional sku if the machine wasn't a 
    // member of a domain)
    //
   
{
    return ( IsPersonalPlatform() ||
             IsStandaloneWKS() );
}


TCHAR*
GetComputer(
    void )

    // Returns the address of a static buffer containing the local
    // workstation's computer name.
    //
{
    if (g_szComputer[ 0 ] == TEXT('\0'))
    {
        DWORD           dwErr;
        WKSTA_INFO_100* pInfo;

        pInfo = NULL;
        TRACE( "NetWkstaGetInfo" );
        dwErr = NetWkstaGetInfo( NULL, 100, (LPBYTE* )&pInfo );
        TRACE1( "NetWkstaGetInfo=%d", dwErr );

        if (pInfo)
        {
            if (dwErr == 0)
            {
                lstrcpyn( 
                    g_szComputer, 
                    pInfo->wki100_computername,
                    CNLEN + 1);
            }
            NetApiBufferFree( pInfo );
        }
    }

    TRACEW1( "GetComputer=%s",g_szComputer );
    return g_szComputer;
}

DWORD
GetComputerSuiteAndProductType(
    LPDWORD lpdwSku,
    LPDWORD lpdwType)

    // Returns the machine's product sku
{
    DWORD dwErr = NO_ERROR;
    
    if (! g_fMachineSkuAndRoleInitialized)
    {
        dwErr = LoadSkuAndRole();
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }

    *lpdwSku  = g_dwSku;
    *lpdwType = g_dwProductType;
    return dwErr;
}

DWORD
GetComputerSuite(
    LPDWORD lpdwSku )

    // Returns the machine's product sku
{
    DWORD dwErr = NO_ERROR;
    
    if (! g_fMachineSkuAndRoleInitialized)
    {
        dwErr = LoadSkuAndRole();
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }

    *lpdwSku = g_dwSku;
    return dwErr;
}

DWORD
GetComputerRole(
    DSROLE_MACHINE_ROLE* pRole )

    // Returns whether this machine is a member of domain, etc.
{
    DWORD dwErr = NO_ERROR;
    
    if (! g_fMachineSkuAndRoleInitialized)
    {
        dwErr = LoadSkuAndRole();
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }

    *pRole = g_DsRole;
    return dwErr;
}

DWORD 
LoadSkuAndRole(
    void)

    // Loads the machine's role and it's sku
{
    OSVERSIONINFOEX osVer;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pInfo = NULL;
    DWORD dwErr = NO_ERROR;
    
    // Get the product sku
    //
    ZeroMemory(&osVer, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO) &osVer))
    {
        g_dwSku = osVer.wSuiteMask;
        g_dwProductType = osVer.wProductType;
    }
    else
    {
        return GetLastError();
    }
    
    // Get the product role
    //
    dwErr = DsRoleGetPrimaryDomainInformation(
                        NULL,   
                        DsRolePrimaryDomainInfoBasic,
                        (LPBYTE *)&pInfo );

    if (dwErr != NO_ERROR) 
    {
        return dwErr;
    }

    g_DsRole = pInfo->MachineRole;

    DsRoleFreeMemory( pInfo );

    // Mark the information as having been loaded
    //
    g_fMachineSkuAndRoleInitialized = TRUE;
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\pbk\pbkp.h ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// pbkp.h
// Remote Access phonebook file (.PBK) library
// Private header
//
// 06/20/95 Steve Cobb


#ifndef _PBKP_H_
#define _PBKP_H_


#include <pbk.h>    // RAS phonebook library (our public header)
#include <stdlib.h> // ltoa
#include <debug.h>  // Trace/Assert library
#include <ras.h>    // Win32 RAS header, for constants
#include <serial.h> // RAS serial media header, for SERIAL_TXT, SER_*
#include <tchar.h>  // TCHAR equivalents for CRT
#include <isdn.h>   // RAS ISDN media header, for ISDN_TXT, for ISDN_*
#include <x25.h>    // RAS X.25 media header, for X25_TXT
#include <rasmxs.h> // RAS modem/X.25/switch device header, for MXS_*


//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

// PBK file section names.
//
#define GLOBALSECTIONNAME "."

// PBK file key names.
//
#define KEY_Port                     "Port"
#define KEY_InitBps                  SER_CONNECTBPS_KEY
#define KEY_HwFlow                   MXS_HDWFLOWCONTROL_KEY
#define KEY_Ec                       MXS_PROTOCOL_KEY
#define KEY_Ecc                      MXS_COMPRESSION_KEY
#define KEY_PhoneNumber              "PhoneNumber"
#define KEY_PromoteAlternates        "PromoteAlternates"
#define KEY_AutoLogon                "AutoLogon"
#define KEY_Domain                   "Domain"
#define KEY_User                     "User"
#define KEY_UID                      "DialParamsUID"
#define KEY_SavePw                   "SavePw"
#define KEY_Device                   "Device"
#define KEY_SwCompression            "SwCompression"
#define KEY_NegotiateMultilinkAlways "NegotiateMultilinkAlways"
#define KEY_UseCountryAndAreaCodes   "UseCountryAndAreaCodes"
#define KEY_AreaCode                 "AreaCode"
#define KEY_CountryID                "CountryID"
#define KEY_CountryCode              "CountryCode"
#define KEY_DialMode                 "DialMode"
#define KEY_DialPercent              "DialPercent"
#define KEY_DialSeconds              "DialSeconds"
#define KEY_HangUpPercent            "HangUpPercent"
#define KEY_HangUpSeconds            "HangUpSeconds"
#define KEY_AuthRestrictions         "AuthRestrictions"
#define KEY_TypicalAuth              "TypicalAuth"
#define KEY_TapiBlob                 "TapiBlob"
#define KEY_Type                     "Type"
#define KEY_PAD_Type                 MXS_X25PAD_KEY
#define KEY_PAD_Address              MXS_X25ADDRESS_KEY
#define KEY_PAD_UserData             MXS_USERDATA_KEY
#define KEY_PAD_Facilities           MXS_FACILITIES_KEY
#define KEY_X25_Address              X25_ADDRESS_KEY
#define KEY_X25_UserData             X25_USERDATA_KEY
#define KEY_X25_Facilities           X25_FACILITIES_KEY
#define KEY_RedialAttempts           "RedialAttempts"
#define KEY_RedialPauseSecs          "RedialPauseSecs"
#define KEY_RedialOnLinkFailure      "RedialOnLinkFailure"
#define KEY_CallbackNumber           "CallbackNumber"
#define KEY_ExcludedProtocols        "ExcludedProtocols"
#define KEY_LcpExtensions            "LcpExtensions"
#define KEY_Authentication           "Authentication"
#define KEY_BaseProtocol             "BaseProtocol"
#define KEY_VpnStrategy              "VpnStrategy"
#define KEY_Item                     "Item"
#define KEY_Selection                "Selection"
#define KEY_SlipHeaderCompression    "SlipHeaderCompression"
#define KEY_SlipFrameSize            "SlipFrameSize"
#define KEY_SlipIpAddress            "SlipIpAddress"
#define KEY_SlipPrioritizeRemote     "SlipPrioritizeRemote"
#define KEY_PppIpPrioritizeRemote    "PppIpPrioritizeRemote"
#define KEY_PppIpVjCompression       "PppIpVjCompression"
#define KEY_PppIpAddress             "PppIpAddress"
#define KEY_PppIpAddressSource       "PppIpAssign"
#define KEY_PppIpDnsAddress          "PppIpDnsAddress"
#define KEY_PppIpDns2Address         "PppIpDns2Address"
#define KEY_PppIpWinsAddress         "PppIpWinsAddress"
#define KEY_PppIpWins2Address        "PppIpWins2Address"
#define KEY_PppIpNameSource          "PppIpNameAssign"
#define KEY_IpPrioritizeRemote       "IpPrioritizeRemote"
#define KEY_IpHeaderCompression      "IpHeaderCompression"
#define KEY_IpAddress                "IpAddress"
#define KEY_IpAddressSource          "IpAssign"
#define KEY_IpDnsAddress             "IpDnsAddress"
#define KEY_IpDns2Address            "IpDns2Address"
#define KEY_IpWinsAddress            "IpWinsAddress"
#define KEY_IpWins2Address           "IpWins2Address"
#define KEY_IpNameSource             "IpNameAssign"
#define KEY_IpFrameSize              "IpFrameSize"
#define KEY_IpDnsFlags               "IpDnsFlags"
#define KEY_IpNbtFlags               "IpNBTFlags"
#define KEY_TcpWindowSize            "TcpWindowSize"
#define KEY_IpDnsSuffix              "IpDnsSuffix"
#define KEY_SkipNwcWarning           "SkipNwcWarning"
#define KEY_SkipDownLevelDialog      "SkipDownLevelDialog"
#define KEY_SkipDoubleDialDialog     "SkipDoubleDialDialog"
#define KEY_PppTextAuthentication    "PppTextAuthentication"
#define KEY_DataEncryption           "DataEncryption"
#define KEY_CustomDialDll            "CustomDialDll"
#define KEY_CustomDialFunc           "CustomDialFunc"
#define KEY_CustomDialerName         "CustomRasDialDll"
#define KEY_IdleDisconnectSeconds    "IdleDisconnectSeconds"
#define KEY_SecureLocalFiles         "SecureLocalFiles"
#define KEY_LineType                 ISDN_LINETYPE_KEY
#define KEY_Fallback                 ISDN_FALLBACK_KEY
#define KEY_Compression              ISDN_COMPRESSION_KEY
#define KEY_Channels                 ISDN_CHANNEL_AGG_KEY
#define KEY_Description              "Description"
#define KEY_Speaker                  "Speaker"
#define KEY_MdmProtocol              "MdmProtocol"
#define KEY_ProprietaryIsdn          "Proprietary"
#define KEY_DisableModemSpeaker      "DisableModemSpeaker"
#define KEY_DisableSwCompression     "DisableSwCompression"
#define KEY_OtherPortOk              "OtherPortOk"
#define KEY_OverridePref             "OverridePref"
#define KEY_RedialAttempts           "RedialAttempts"
#define KEY_RedialSeconds            "RedialSeconds"
#define KEY_RedialOnLinkFailure      "RedialOnLinkFailure"
#define KEY_CallbackMode             "CallbackMode"
#define KEY_AuthenticateServer       "AuthenticateServer"
#define KEY_ShareMsFilePrint         "ShareMsFilePrint"
#define KEY_BindMsNetClient          "BindMsNetClient"
#define KEY_SharedPhoneNumbers       "SharedPhoneNumbers"
#define KEY_GlobalDeviceSettings     "GlobalDeviceSettings" // whist bug 281306
#define KEY_PrerequisiteEntry        "PrerequisiteEntry"
#define KEY_PrerequisitePbk          "PrerequisitePbk"
#define KEY_PreferredPort            "PreferredPort"
#define KEY_PreferredDevice          "PreferredDevice"
#define KEY_PreferredModemProtocol   "PreferredMdmProtocol" //whistler 402522, XPSP1 664578
#define KEY_PreferredBps             "PreferredBps"         //.Net 639551
#define KEY_PreferredHwFlow          "PreferredHwFlow"      //.Net 639551
#define KEY_PreferredEc              "PreferredProtocol"    //.Net 639551
#define KEY_PreferredEcc             "PreferredCompression" //.Net 639551
#define KEY_PreferredSpeaker         "PreferredSpeaker"     //.Net 639551
#define KEY_PreviewUserPw            "PreviewUserPw"
#define KEY_PreviewDomain            "PreviewDomain"
#define KEY_PreviewPhoneNumber       "PreviewPhoneNumber"
#define KEY_ShowDialingProgress      "ShowDialingProgress"
#define KEY_CustomScript             "CustomScript"
#define KEY_Comment                  "Comment"
#define KEY_UseDialingRules          "UseDialingRules"
#define KEY_TryNextAlternateOnFail   "TryNextAlternateOnFail"
#define KEY_ShowMonitorIconInTaskBar "ShowMonitorIconInTaskBar"
#define KEY_Guid                     "Guid"
#define KEY_SharePhoneNumbers        "SharePhoneNumbers"
#define KEY_CustomAuthKey            "CustomAuthKey"
#define KEY_CustomAuthStdCreds       "CustomAuthStdCreds"
#define KEY_CustomAuthData           "CustomAuthData"
#define KEY_Terminal                 "Terminal"
#define KEY_Script                   "Script"
#define KEY_Name                     "Name"
#define KEY_LastSelectedPhone        "LastSelectedPhone"
#define KEY_Version                  "Version"
#define KEY_Encoding                 "Encoding"
#define KEY_UseRasCredentials        "UseRasCredentials"
#define KEY_IpSecFlags               "IpSecFlags"       //For whistler bug 193987
#define KEY_UseFlags                 "UseFlags"       // Special uses for connection

// The switch device type text value written to the phonebook file.
//
#define SM_TerminalText "Terminal"

// Whistler 326015 PBK: if ATM device name is NULL, we should seek out a device
// name just like w/serial/ISDN
//
#define S_WIN9XATM  "ATM"
#define S_SYSRASDIR TEXT("\\System32\\Ras")

//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

BOOL
IsDeviceLine(
    IN CHAR* pszText );

BOOL
IsMediaLine(
    IN CHAR* pszText );

BOOL
IsNetComponentsLine(
    IN CHAR* pszText );

BOOL
IsServerOS ( );

#endif // _PBKP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\pbk\pbk.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// pbk.c
// Remote Access phonebook library
// General routines
// Listed alphabetically
//
// 06/20/95 Steve Cobb


#include "pbkp.h"
#include <search.h>  // Qsort

#ifdef UNICODE
#define SZ_PathCanonicalize     "PathCanonicalizeW"
#define SZ_PathRemoveFileSpec   "PathRemoveFileSpecW"
#else
#define SZ_PathCanonicalize     "PathCanonicalizeA"
#define SZ_PathRemoveFileSpec   "PathRemoveFileSpecA"
#endif

// WinSE #22865
#include "tapi.h"

//----------------------------------------------------------------------------
// Local prototypes
//----------------------------------------------------------------------------

DWORD
AppendPbportToList(
    IN HANDLE hConnection,
    IN DTLLIST* pdtllist,
    IN RASMAN_PORT* pPort );

DWORD
AppendStringToList(
    IN DTLLIST* pdtllist,
    IN TCHAR* psz );

int __cdecl
CompareDevices(
    const void* pDevice1,
    const void* pDevice2 );

int __cdecl
ComparePorts(
    const void* pPort1,
    const void* pPort2 );

CHAR*
PbMedia(
    IN PBDEVICETYPE pbdt,
    IN CHAR* pszMedia );

WCHAR *
GetUnicodeName(HANDLE hPort);


//----------------------------------------------------------------------------
// Routines
//----------------------------------------------------------------------------

DWORD
RdtFromPbdt(PBDEVICETYPE pbdt, DWORD dwFlags)
{
    DWORD rdt;

    switch(pbdt)
    {
        case PBDT_Modem:
        {
            rdt = RDT_Modem;

            if(PBP_F_NullModem & dwFlags)
            {
                rdt |= (RDT_Direct | RDT_Null_Modem);
            }

            break;
        }

        case PBDT_X25:
        {
            rdt = RDT_X25;
            break;
        }

        case PBDT_Isdn:
        {
            rdt = RDT_Isdn;
            break;
        }

        case PBDT_Serial:
        {
            rdt = RDT_Serial;
            break;
        }

        case PBDT_FrameRelay:
        {
            rdt = RDT_FrameRelay;
            break;
        }

        case PBDT_Atm:
        {
            rdt = RDT_Atm;
            break;
        }

        case PBDT_Vpn:
        {
            rdt = RDT_Tunnel;

            if(PBP_F_L2tpDevice & dwFlags)
            {
                rdt |= RDT_Tunnel_L2tp;
            }
            else if(PBP_F_PptpDevice & dwFlags)
            {
                rdt |= RDT_Tunnel_Pptp;
            }

            break;
        }

        case PBDT_Sonet:
        {
            rdt = RDT_Sonet;
            break;
        }

        case PBDT_Sw56:
        {
            rdt = RDT_Sw56;
            break;
        }

        case PBDT_Irda:
        {
            rdt = (RDT_Irda | RDT_Direct);
            break;
        }

        case PBDT_Parallel:
        {
            rdt = (RDT_Parallel | RDT_Direct);
            break;
        }

        case PBDT_Null:
        {
            rdt = (RDT_Direct | RDT_Null_Modem);
            break;
        }

        case PBDT_PPPoE:
        {
            rdt = (RDT_PPPoE | RDT_Broadband);
            break;
        }

        default:
        {
            rdt = RDT_Other;
            break;
        }
    }

    return rdt;
}


PBDEVICETYPE
PbdtFromRdt(
    IN DWORD rdt
    )
{
    PBDEVICETYPE pbdt;

    switch(rdt)
    {
        case RDT_Modem:
        {
            pbdt = PBDT_Modem;
            break;
        }

        case RDT_X25:
        {
            pbdt = PBDT_X25;
            break;
        }

        case RDT_Isdn:
        {
            pbdt = PBDT_Isdn;
            break;
        }

        case RDT_Serial:
        {
            pbdt = PBDT_Serial;
            break;
        }

        case RDT_FrameRelay:
        {
            pbdt = PBDT_FrameRelay;
            break;
        }

        case RDT_Atm:
        {
            pbdt = PBDT_Atm;
            break;
        }

        case RDT_Tunnel_Pptp:
        case RDT_Tunnel_L2tp:
        {
            pbdt = PBDT_Vpn;
            break;
        }

        case RDT_Sonet:
        {
            pbdt = PBDT_Sonet;
            break;
        }

        case RDT_Sw56:
        {
            pbdt = PBDT_Sw56;
            break;
        }

        case RDT_Irda:
        {
            pbdt = PBDT_Irda;
            break;
        }

        case RDT_Parallel:
        {
            pbdt = PBDT_Parallel;
            break;
        }

        case RDT_PPPoE:
        {
            pbdt = PBDT_PPPoE;
            break;
        }

        default:
        {
            pbdt = PBDT_Other;
            break;
        }
    }

    return pbdt;
}

TCHAR *
pszDeviceTypeFromRdt(RASDEVICETYPE rdt)
{
    TCHAR *pszDeviceType = NULL;

    switch(RAS_DEVICE_TYPE(rdt))
    {
        case RDT_Modem:
        {
            pszDeviceType = RASDT_Modem;
            break;
        }

        case RDT_X25:
        {
            pszDeviceType = RASDT_X25;
            break;
        }

        case RDT_Isdn:
        {
            pszDeviceType = RASDT_Isdn;
            break;
        }

        case RDT_Serial:
        {
            pszDeviceType = RASDT_Serial;
            break;
        }

        case RDT_FrameRelay:
        {
            pszDeviceType = RASDT_FrameRelay;
            break;
        }

        case RDT_Atm:
        {
            pszDeviceType = RASDT_Atm;
            break;
        }

        case RDT_Sonet:
        {
            pszDeviceType = RASDT_Sonet;
            break;
        }

        case RDT_Sw56:
        {
            pszDeviceType = RASDT_SW56;
            break;
        }

        case RDT_Tunnel_Pptp:
        case RDT_Tunnel_L2tp:
        {
            pszDeviceType = RASDT_Vpn;
            break;
        }

        case RDT_Irda:
        {
            pszDeviceType = RASDT_Irda;
            break;
        }

        case RDT_Parallel:
        {
            pszDeviceType = RASDT_Parallel;
            break;
        }

        case RDT_PPPoE:
        {
            pszDeviceType = RASDT_PPPoE;
            break;
        }

        default:
        {
            pszDeviceType = NULL;
            break;
        }
    }

    return StrDup(pszDeviceType);
}

DWORD
AppendPbportToList(
    IN HANDLE hConnection,
    IN DTLLIST* pdtllist,
    IN RASMAN_PORT* pPort )

    // Append a PBPORT onto the list 'pdtllist' which has the characteristics
    // of RAS Manager port 'pPort'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.
    //
{
    DWORD dwErr;
    DTLNODE* pdtlnode;
    PBPORT* ppbport;
    DWORD dwType, dwClass;

    dwErr = 0;

    pdtlnode = CreatePortNode();
    if (    !pdtlnode)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Get detailed information about the device from
    // rasman
    dwClass = RAS_DEVICE_CLASS(pPort->P_rdtDeviceType);
    dwType = RAS_DEVICE_TYPE(pPort->P_rdtDeviceType);

    // Now set the device info
    ppbport = (PBPORT* )DtlGetData( pdtlnode );
    // ppbport->pszDevice = StrDupTFromAUsingAnsiEncoding( pPort->P_DeviceName );
    ppbport->pszDevice = GetUnicodeName(pPort->P_Handle);

    if(ppbport->pszDevice == NULL)
    {
        ppbport->pszDevice = StrDupTFromAUsingAnsiEncoding( pPort->P_DeviceName );
    }

    ppbport->pszPort = StrDupTFromAUsingAnsiEncoding( pPort->P_PortName );

    // Record the flags appropriate to this device
    if ( dwType == RDT_Tunnel_Pptp )
    {
        ppbport->dwFlags |= PBP_F_PptpDevice;
    }
    else if ( dwType == RDT_Tunnel_L2tp )
    {
        ppbport->dwFlags |= PBP_F_L2tpDevice;
    }
    //For whistler 349087 345068    gangz
    //
    else if ( dwType == RDT_PPPoE )
    {
        ppbport->dwFlags |= PBP_F_PPPoEDevice;
    }

    if ( dwClass & RDT_Null_Modem )
    {
        ppbport->dwFlags |= PBP_F_NullModem;
    }
    //For whistler 349087 345068    gangz
    //
    else if ( dwClass & RDT_Broadband )
    {
        ppbport->dwFlags |= PBP_F_PPPoEDevice;
    }

    // Compute the phonebook device type
    //
    ppbport->pbdevicetype = PbdtFromRdt(dwType);
    if ( PBDT_Other == ppbport->pbdevicetype )
    {
        ppbport->pbdevicetype = PbdevicetypeFromPszTypeA( pPort->P_DeviceType);
    }

    ppbport->pszMedia = StrDupTFromAUsingAnsiEncoding(
        PbMedia( ppbport->pbdevicetype, pPort->P_MediaName ) );

    if (!ppbport->pszPort || !ppbport->pszDevice || !ppbport->pszMedia)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else if ((ppbport->pbdevicetype == PBDT_Modem)  ||
             (ppbport->dwFlags & PBP_F_NullModem))
    {

#ifdef MXSMODEMS
        if (pPort->P_LineDeviceId == 0xFFFFFFFF)
        {
            // MXS modem port.
            //
            ppbport->fMxsModemPort = TRUE;

            GetRasPortMaxBps( pPort->P_Handle,
                &ppbport->dwMaxConnectBps, &ppbport->dwMaxCarrierBps );

            GetRasPortModemSettings( pPort->P_Handle, &ppbport->fHwFlowDefault,
                &ppbport->fEcDefault, &ppbport->fEccDefault );
        }
        else
#else
        ASSERT( pPort->P_LineDeviceId != 0xFFFFFFFF );
#endif

        {
            // Unimodem port.
            //
            UNIMODEMINFO info;

            ZeroMemory((PBYTE) &info, sizeof(info));

            GetRasUnimodemInfo(
                        hConnection,
                        pPort->P_Handle,
                        pPort->P_DeviceType,
                        &info );

            TRACE6( "Port=%s,fHw=%d,fEc=%d,bps=%d,fSp=%d,prot=%x",
                pPort->P_PortName, info.fHwFlow, info.fEc,
                info.dwBps, info.fSpeaker, info.dwModemProtocol );

            ppbport->fHwFlowDefault = info.fHwFlow;
            ppbport->fEcDefault = info.fEc;
            ppbport->fEccDefault = info.fEcc;
            ppbport->dwBpsDefault = info.dwBps;
            ppbport->fSpeakerDefault = info.fSpeaker;

            // pmay: 228565
            // Add the modem protocol information
            //
            ppbport->dwModemProtDefault = info.dwModemProtocol;
            ppbport->pListProtocols = info.pListProtocols;
        }
    }

    if (dwErr == 0)
    {
        ppbport->dwType = EntryTypeFromPbport( ppbport );
        DtlAddNodeLast( pdtllist, pdtlnode );
    }
    else
    {
        Free0( ppbport->pszDevice );
        Free0( ppbport->pszMedia );
        Free0( ppbport->pszPort );
        DtlDestroyNode( pdtlnode );
    }

    return dwErr;
}


DWORD
AppendStringToList(
    IN DTLLIST* pdtllist,
    IN TCHAR* psz )

    // Appends a copy of 'psz' to the end of list 'pdtllist'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.
    // ERROR_NOT_ENOUGH_MEMORY is returned if 'psz' is NULL.
    //
{
    DTLNODE* pdtlnode;
    TCHAR*   pszDup;

    if (!psz)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pszDup = StrDup( psz );
    if (!pszDup)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pdtlnode = DtlCreateNode( pszDup, 0L );
    if (!pdtlnode )
    {
        Free( pszDup );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DtlAddNodeLast( pdtllist, pdtlnode );
    return 0;
}


DTLNODE*
CloneEntryNode(
    DTLNODE* pdtlnodeSrc )

    // Duplicates entry node 'pdtlnodeSrc' with fields that cannot be cloned
    // set to "like new" settings.
    //
{
    DTLNODE* pdtlnode;

    pdtlnode = DuplicateEntryNode( pdtlnodeSrc );
    if (pdtlnode)
    {
        PBENTRY* ppbentry = (PBENTRY* )DtlGetData( pdtlnode );
        ASSERT( ppbentry );

        ppbentry->fSkipDownLevelDialog = FALSE;
        ppbentry->fSkipDoubleDialDialog = FALSE;
        ppbentry->fSkipNwcWarning = FALSE;
        ppbentry->dwDialParamsUID = GetTickCount();

        if (ppbentry->dwType != RASET_Phone)
        {
            ppbentry->fPreviewPhoneNumber = FALSE;
            ppbentry->fSharedPhoneNumbers = FALSE;
        }

        Free0( ppbentry->pGuid );
        ppbentry->pGuid = Malloc( sizeof(GUID) );
        if (ppbentry->pGuid)
        {
            UuidCreate( (UUID* )ppbentry->pGuid );
        }

        ppbentry->fDirty = FALSE;
    }

    return pdtlnode;
}


int __cdecl
CompareDevices(
    const void* pDevice1,
    const void* pDevice2 )

    // Qsort compare function for RASMAN_DEVICEs.
    //
{
    return
        lstrcmpiA( ((RASMAN_DEVICE* )pDevice1)->D_Name,
                   ((RASMAN_DEVICE* )pDevice2)->D_Name );
}


int __cdecl
ComparePorts(
    const void* pPort1,
    const void* pPort2 )

    // Qsort compare function for RASMAN_PORTs.
    //
{
    return
        lstrcmpiA( ((RASMAN_PORT* )pPort1)->P_PortName,
                   ((RASMAN_PORT* )pPort2)->P_PortName );
}


DWORD
CopyToPbport(
    IN PBPORT* ppbportDst,
    IN PBPORT* ppbportSrc )

    // Make a duplicate of 'ppbportSrc' in 'ppbportDst'.  If 'ppbportSrc' is
    // NULL it sets 'ppbportDst' to defaults.
    //
    // Returns 0 if successful or an error code.
    //
{
    DTLNODE *pdtlnode, *pNode;
    WCHAR *pwsz;
    DTLLIST *pdtllist = NULL;

    Free0( ppbportDst->pszDevice );
    Free0( ppbportDst->pszMedia );
    Free0( ppbportDst->pszPort );

    if (!ppbportSrc)
    {
        ppbportDst->pszPort = NULL;
        ppbportDst->fConfigured = TRUE;
        ppbportDst->pszDevice = NULL;
        ppbportDst->pszMedia = NULL;
        ppbportDst->pbdevicetype = PBDT_None;
        ppbportDst->dwType = RASET_Phone;
        ppbportDst->fHwFlowDefault = FALSE;
        ppbportDst->fEcDefault = FALSE;
        ppbportDst->fEccDefault = FALSE;
        ppbportDst->dwBpsDefault = 0;
        ppbportDst->fSpeakerDefault = TRUE;
        ppbportDst->fScriptBeforeTerminal = FALSE;
        ppbportDst->fScriptBefore = FALSE;
        ppbportDst->pszScriptBefore = NULL;
        return 0;
    }

    CopyMemory( ppbportDst, ppbportSrc, sizeof(*ppbportDst) );
    ppbportDst->pszDevice = StrDup( ppbportSrc->pszDevice );
    ppbportDst->pszMedia = StrDup( ppbportSrc->pszMedia );
    ppbportDst->pszPort = StrDup( ppbportSrc->pszPort );
    ppbportDst->pszScriptBefore = StrDup( ppbportSrc->pszScriptBefore );

    //
    // Copy the protocol list.
    //
    if(ppbportSrc->pListProtocols)
    {
        for (pdtlnode = DtlGetFirstNode( ppbportSrc->pListProtocols);
             pdtlnode;
             pdtlnode = DtlGetNextNode( pdtlnode ))
        {
            if(NULL == pdtllist)
            {
                pdtllist = DtlCreateList(0);
                if(NULL == pdtllist)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            pwsz = (WCHAR *) DtlGetData(pdtlnode);

            pNode = DtlCreateSizedNode(
                        (wcslen(pwsz) + 1) * sizeof(WCHAR),
                        pdtlnode->lNodeId);

            if(NULL == pNode)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            wcscpy((WCHAR *) DtlGetData(pNode), pwsz);
            DtlAddNodeLast(pdtllist, pNode);
        }
    }

    ppbportDst->pListProtocols = pdtllist;

    if ((ppbportSrc->pszDevice && !ppbportDst->pszDevice)
        || (ppbportSrc->pszMedia && !ppbportDst->pszMedia)
        || (ppbportSrc->pszPort && !ppbportDst->pszPort)
        || (ppbportSrc->pszScriptBefore && !ppbportDst->pszScriptBefore))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return 0;
}


VOID
ChangeEntryType(
    PBENTRY* ppbentry,
    DWORD dwType )

    // Changes the type of 'ppbentry' to 'dwType' and sets defaults
    // accordingly.
    //
{
    ppbentry->dwType = dwType;

    if (dwType == RASET_Phone)
    {
        ppbentry->fPreviewPhoneNumber = TRUE;

        // Defaults for Phones changed per bug 230240 and 363809.
        //
        ppbentry->dwAuthRestrictions = AR_F_TypicalUnsecure;
        ppbentry->dwTypicalAuth =  TA_Unsecure;
        ppbentry->dwDataEncryption = DE_IfPossible;
        ppbentry->fIpHeaderCompression = TRUE;

        ppbentry->fShareMsFilePrint = FALSE;

        // Disable File and Print services by default for phone
        //
        EnableOrDisableNetComponent( ppbentry, TEXT("ms_server"),
            FALSE);

        ppbentry->fBindMsNetClient = TRUE;

        EnableOrDisableNetComponent( ppbentry, TEXT("ms_msclient"),
                TRUE);
    }
    else if (dwType == RASET_Vpn)
    {
        // NOTE: If you change this you may need to also make a change in
        //       CloneEntryNode.
        //
        ppbentry->fPreviewPhoneNumber = FALSE;
        ppbentry->fSharedPhoneNumbers = FALSE;

        // Defaults for VPN changed per bug 230240 and 363809.
        //
        ppbentry->dwAuthRestrictions = AR_F_TypicalSecure;
        ppbentry->dwTypicalAuth =  TA_Secure;
        ppbentry->dwDataEncryption = DE_Require;
        ppbentry->fIpHeaderCompression = FALSE;

        // We share file and print by default for vpn
        //
        ppbentry->fShareMsFilePrint = TRUE;

        // Enable File and Print services by default
        //
        EnableOrDisableNetComponent( ppbentry, TEXT("ms_server"),
            TRUE);

        ppbentry->fBindMsNetClient = TRUE;

        EnableOrDisableNetComponent( ppbentry, TEXT("ms_msclient"),
                TRUE);
    }
    else if (dwType == RASET_Broadband)
    {
        // NOTE: If you change this you may need to also make a change in
        //       CloneEntryNode.
        //
        ppbentry->fPreviewPhoneNumber = FALSE;
        ppbentry->fSharedPhoneNumbers = FALSE;

        // Defaults for broadband connections
        //
        ppbentry->dwAuthRestrictions = AR_F_TypicalSecure;
        ppbentry->dwTypicalAuth =  TA_Secure;
        ppbentry->dwDataEncryption = DE_IfPossible;
        ppbentry->fIpHeaderCompression = FALSE;

        // We share file and print by default for vpn
        //
        ppbentry->fShareMsFilePrint = TRUE;

        // Enable File and Print services by default
        //
        EnableOrDisableNetComponent( ppbentry, TEXT("ms_server"),
            FALSE);

        ppbentry->fBindMsNetClient = TRUE;

        EnableOrDisableNetComponent( ppbentry, TEXT("ms_msclient"),
                TRUE);
    }
    else if (dwType == RASET_Direct)
    {
        // NOTE: If you change this you may need to also make a change in
        //       CloneEntryNode.
        //
        ppbentry->fPreviewPhoneNumber = FALSE;
        ppbentry->fSharedPhoneNumbers = FALSE;

        // Defaults for DCC (like Phones in this regard) changed per bug
        // 230240 and 363809.
        //
        ppbentry->dwAuthRestrictions = AR_F_TypicalUnsecure;
        ppbentry->dwTypicalAuth =  TA_Unsecure;
        ppbentry->dwDataEncryption = DE_IfPossible;
        ppbentry->fIpHeaderCompression = TRUE;

        // We share file and print by default for dcc
        //
        ppbentry->fShareMsFilePrint = TRUE;

        // Enable File and Print services by default
        //
        EnableOrDisableNetComponent( ppbentry, TEXT("ms_server"),
            TRUE);

        ppbentry->fBindMsNetClient = TRUE;

        EnableOrDisableNetComponent( ppbentry, TEXT("ms_msclient"),
                TRUE);
    }
}


DTLNODE*
CreateEntryNode(
    BOOL fCreateLink )

    // Allocates a sized phonebook entry node of type RASET_Phone and fills it
    // with default values.  See ChangeEntryNodeType routine.  'If
    // 'fCreateLink' is true a default node is added the list of links.
    // Otherwise, the list of links is empty.
    //
    // Returns the address of the allocated node if successful, NULL
    // otherwise.
    //
{
    DTLNODE* pdtlnode;
    PBENTRY* ppbentry;

    TRACE( "CreateEntryNode" );

    // Allocate the node with built-in PBENTRY.
    //
    pdtlnode = DtlCreateSizedNode( sizeof(PBENTRY), 0L );
    if (!pdtlnode)
    {
        return NULL;
    }

    ppbentry = (PBENTRY* )DtlGetData( pdtlnode );
    ASSERT( ppbentry );

    // Create the list of links with a default link node or no link nodes as
    // chosen by caller.
    //
    ppbentry->pdtllistLinks = DtlCreateList( 0 );
    if (!ppbentry->pdtllistLinks)
    {
        DestroyEntryNode( pdtlnode );
        return NULL;
    }

    if (fCreateLink)
    {
        DTLNODE* pLinkNode;

        pLinkNode = CreateLinkNode();
        if (!pLinkNode)
        {
            DestroyEntryNode( pdtlnode );
            return NULL;
        }

        DtlAddNodeLast( ppbentry->pdtllistLinks, pLinkNode );
    }

    // Set fields to defaults.
    //
    ppbentry->pszEntryName = NULL;
    ppbentry->dwType = RASET_Phone;

    // General page fields.
    //
    ppbentry->pszPrerequisiteEntry = NULL;
    ppbentry->pszPrerequisitePbk = NULL;
    ppbentry->fSharedPhoneNumbers = TRUE;
    ppbentry->fGlobalDeviceSettings = FALSE;
    ppbentry->fShowMonitorIconInTaskBar = TRUE;
    ppbentry->pszPreferredDevice = NULL;
    ppbentry->pszPreferredPort = NULL;

    //For XPSP1 664578, .Net 639551   Add preferred info for Modem settings
    ppbentry->dwPreferredBps    = 0;
    ppbentry->fPreferredHwFlow  = 0;
    ppbentry->fPreferredEc      = 0;
    ppbentry->fPreferredEcc     = 0;
    ppbentry->fPreferredSpeaker = 0;
    
    ppbentry->dwPreferredModemProtocol=0;   //For whislter bug 402522


    // Options page fields.
    //
    ppbentry->fShowDialingProgress = TRUE;
    ppbentry->fPreviewPhoneNumber = TRUE;
    ppbentry->fPreviewUserPw = TRUE;
    ppbentry->fPreviewDomain = FALSE;  // See bug 281673

    ppbentry->dwDialMode = RASEDM_DialAll;
    ppbentry->dwDialPercent = 75;
    ppbentry->dwDialSeconds = 120;
    ppbentry->dwHangUpPercent = 10;
    ppbentry->dwHangUpSeconds = 120;

    ppbentry->dwfOverridePref =
        RASOR_RedialAttempts | RASOR_RedialSeconds
        | RASOR_IdleDisconnectSeconds | RASOR_RedialOnLinkFailure;

    ppbentry->lIdleDisconnectSeconds = 0;
    ppbentry->dwRedialAttempts = 3;
    ppbentry->dwRedialSeconds = 60;
    ppbentry->fRedialOnLinkFailure = FALSE;

    // Security page fields.
    //
    ppbentry->dwAuthRestrictions = AR_F_TypicalUnsecure;
    ppbentry->dwTypicalAuth = TA_Unsecure;
    ppbentry->dwDataEncryption = DE_IfPossible;
    ppbentry->fAutoLogon = FALSE;
    ppbentry->fUseRasCredentials = TRUE;

    ppbentry->dwCustomAuthKey = (DWORD )-1;
    ppbentry->pCustomAuthData = NULL;
    ppbentry->cbCustomAuthData = 0;

    ppbentry->fScriptAfterTerminal = FALSE;
    ppbentry->fScriptAfter = FALSE;
    ppbentry->pszScriptAfter = NULL;

    ppbentry->pszX25Network = NULL;
    ppbentry->pszX25Address = NULL;
    ppbentry->pszX25UserData = NULL;
    ppbentry->pszX25Facilities = NULL;

    // Use is unknown
    //
    ppbentry->dwUseFlags = 0;

    //IP Security Dialog box
    //
    ppbentry->dwIpSecFlags = 0;

    // Network page fields.
    //
    ppbentry->dwBaseProtocol = BP_Ppp;
    ppbentry->dwVpnStrategy = VS_Default;
    ppbentry->dwfExcludedProtocols = 0;
    ppbentry->fLcpExtensions = TRUE;
    ppbentry->fSkipNwcWarning = FALSE;
    ppbentry->fSkipDownLevelDialog = FALSE;
    ppbentry->fSkipDoubleDialDialog = FALSE;
    ppbentry->fSwCompression = TRUE;

    // (shaunco) Gibbs and QOS guys want this on by default.
    // for whislter bug 385842      gangz
    // we cut this functionality, so set the default to be FALSE
    //
    ppbentry->fNegotiateMultilinkAlways = FALSE;

    // Create the list of links with a default link node or no link nodes as
    // chosen by caller.
    //
    ppbentry->pdtllistNetComponents = DtlCreateList( 0 );
    if (!ppbentry->pdtllistNetComponents)
    {
        DestroyEntryNode( pdtlnode );
        return NULL;
    }

#ifdef AMB
    ppbentry->dwAuthentication = (DWORD )AS_Default;
#endif

    ppbentry->fIpPrioritizeRemote = TRUE;
    ppbentry->fIpHeaderCompression = TRUE;
    ppbentry->pszIpAddress = NULL;
    ppbentry->pszIpDnsAddress = NULL;
    ppbentry->pszIpDns2Address = NULL;
    ppbentry->pszIpWinsAddress = NULL;
    ppbentry->pszIpWins2Address = NULL;
    ppbentry->dwIpAddressSource = ASRC_ServerAssigned;
    ppbentry->dwIpNameSource = ASRC_ServerAssigned;
    ppbentry->dwFrameSize = 1006;

    //Changed Vivekk - BugId: 105777
    if ( !IsServerOS() )
        ppbentry->dwIpDnsFlags = 0;
    else
        ppbentry->dwIpDnsFlags = DNS_RegDefault;

    ppbentry->dwIpNbtFlags = PBK_ENTRY_IP_NBT_Enable;

    // Whistler bug 300933.  0=default
    //
    ppbentry->dwTcpWindowSize = 0;

    ppbentry->pszIpDnsSuffix = NULL;

    // Router page fields.
    //
    ppbentry->dwCallbackMode = CBM_No;
    ppbentry->fAuthenticateServer = FALSE;

    // Other fields not shown in UI.
    //
    ppbentry->pszCustomDialDll = NULL;
    ppbentry->pszCustomDialFunc = NULL;

    ppbentry->pszCustomDialerName = NULL;

    ppbentry->dwDialParamsUID = GetTickCount();

    ppbentry->pGuid = Malloc( sizeof(GUID) );
    if (ppbentry->pGuid)
    {
        if(UuidCreate( (UUID* )(ppbentry->pGuid) ))
        {
        }
    }

    ppbentry->pszOldUser = NULL;
    ppbentry->pszOldDomain = NULL;

    // Status flags.  'fDirty' is set when the entry has changed so as to
    // differ from the phonebook file on disk.  'fCustom' is set when the
    // entry contains at least one MEDIA and DEVICE (so RASAPI is able to read
    // it) but was not created by us.  When 'fCustom' is set only 'pszEntry'
    // is guaranteed valid and the entry cannot be edited.
    //
    ppbentry->fDirty = FALSE;
    ppbentry->fCustom = FALSE;

    return pdtlnode;
}


DTLNODE*
CreateLinkNode(
    void )

    // Allocates a sized phonebook entry link node and fills it with default
    // values.
    //
    // Returns the address of the allocated node if successful, NULL
    // otherwise.  It's the caller's responsibility to free the block.
    //
{
    DTLNODE* pdtlnode;
    PBLINK* ppblink;

    TRACE( "CreateLinkNode" );

    pdtlnode = DtlCreateSizedNode( sizeof(PBLINK), 0L );
    if (!pdtlnode)
    {
        return NULL;
    }

    ppblink = (PBLINK* )DtlGetData( pdtlnode );
    ASSERT( ppblink );

    CopyToPbport( &ppblink->pbport, NULL );

    ppblink->dwBps = 0;
    ppblink->fHwFlow = TRUE;
    ppblink->fEc = TRUE;
    ppblink->fEcc = TRUE;
    ppblink->fSpeaker = TRUE;
    ppblink->dwModemProtocol = 0;

    ppblink->fProprietaryIsdn = FALSE;
    ppblink->lLineType = 0;
    ppblink->fFallback = TRUE;
    ppblink->fCompression = TRUE;
    ppblink->lChannels = 1;

    ppblink->pTapiBlob = NULL;
    ppblink->cbTapiBlob = 0;

    ppblink->iLastSelectedPhone = 0;
    ppblink->fPromoteAlternates = FALSE;
    ppblink->fTryNextAlternateOnFail = TRUE;

    ppblink->fEnabled = TRUE;

    // The list of phone number blocks is created but left empty.
    //
    ppblink->pdtllistPhones = DtlCreateList( 0 );
    if (!ppblink->pdtllistPhones)
    {
        Free( ppblink );
        return NULL;
    }

    return pdtlnode;
}

// WinSE #22865
VOID
GetCountryCodeAndID(
    IN PBPHONE* pPhone )

    // Get TAPIs country ID for the current location.  This is needed because
    // its needed for lineGetCountry.
    //
{
    static BOOLEAN fAlreadyQueried = FALSE;
    static DWORD   dwPreviousCountryCode = 1;
    static DWORD   dwPreviousCountryID   = 1;

    LPLINETRANSLATECAPS lpTranslateCaps = NULL;
    LPLINELOCATIONENTRY lpLocationList  = NULL;
    DWORD dwErr = 0;
    DWORD dwNeededSize = 0;
    DWORD dwLocationIndex = 0;

    TRACE("GetCountryCodeAndID");
    ASSERT(pPhone != NULL);

    // Check to see if we've done this already so we don't have to do it again.
    //
    if (fAlreadyQueried)
    {
        pPhone->dwCountryCode = dwPreviousCountryCode;
        pPhone->dwCountryID   = dwPreviousCountryID;
        return;
    }

    // It's okay to set fAlreadyQueried since the defaults are set up to valid
    // values.
    //
    fAlreadyQueried = TRUE;

    // Setup the defaults in case something fails.
    //
    pPhone->dwCountryCode = 1;
    pPhone->dwCountryID = 1;

    lpTranslateCaps = Malloc(sizeof(LINETRANSLATECAPS));
    if (lpTranslateCaps == NULL)
    {
        return;
    }

    // Query lineGetTranslateCaps to find out how big our LINETRANSLATECAPS
    // structure needs to be.
    //
    lpTranslateCaps->dwTotalSize = sizeof(LINETRANSLATECAPS);
    // HLINEAPP is actually a DWORD. Let's pass 0 instead of NULL to avoid
    // typecast error on IA64
    dwErr = lineGetTranslateCaps((HLINEAPP)0, TAPI_CURRENT_VERSION, lpTranslateCaps);
    if (dwErr != 0)
    {
        Free(lpTranslateCaps);
        return;
    }

    // Make our LINETRANSLATECAPS structure big enough.
    //
    dwNeededSize = lpTranslateCaps->dwNeededSize;
    Free(lpTranslateCaps);
    lpTranslateCaps = Malloc(dwNeededSize);
    if (lpTranslateCaps == NULL)
    {
        return;
    }

    // Now we can actually go and get the locations.
    //
    lpTranslateCaps->dwTotalSize = dwNeededSize;
    dwErr = lineGetTranslateCaps((HLINEAPP)0, TAPI_CURRENT_VERSION, lpTranslateCaps);
    if (dwErr != 0)
    {
        Free(lpTranslateCaps);
        return;
    }

    // Walk through the locations, looking for the current location.
    //
    lpLocationList = (LPLINELOCATIONENTRY) ( ((LPSTR)lpTranslateCaps) + lpTranslateCaps->dwLocationListOffset );
    for ( dwLocationIndex=0; dwLocationIndex < lpTranslateCaps->dwNumLocations; dwLocationIndex++ )
    {
        if (lpLocationList[dwLocationIndex].dwPermanentLocationID == lpTranslateCaps->dwCurrentLocationID)
        {
                break;
        }
    }

    // If we found the current location, we know which countrys ID to use for dialing rules.
    //
    if (dwLocationIndex < lpTranslateCaps->dwNumLocations)
    {
        pPhone->dwCountryCode = lpLocationList[dwLocationIndex].dwCountryCode;
        pPhone->dwCountryID = lpLocationList[dwLocationIndex].dwCountryID;

        // Save the values in case we're called again.
        //
        dwPreviousCountryCode = pPhone->dwCountryCode;
        dwPreviousCountryID = pPhone->dwCountryID;
    }

    Free(lpTranslateCaps);
}

DTLNODE*
CreatePhoneNode(
    void )

    // Allocates a sized phone number node and fills it with default values.
    //
    // Returns the address of the allocated node if successful, NULL
    // otherwise.  It's the caller's responsibility to free the block.
    //
{
    DTLNODE* pNode;
    PBPHONE* pPhone;

    TRACE( "CreatePhoneNode" );

    pNode = DtlCreateSizedNode( sizeof(PBPHONE), 0L );
    if (!pNode)
    {
        return NULL;
    }

    pPhone = (PBPHONE* )DtlGetData( pNode );
    ASSERT( pPhone );

	// WinSE #22865
    GetCountryCodeAndID( pPhone );

    pPhone->fUseDialingRules = FALSE;

    return pNode;
}


DTLNODE*
CreatePortNode(
    void )

    // Allocates a sized port node and fills it with default values.
    //
    // Returns the address of the allocated node if successful, NULL
    // otherwise.  It's the caller's responsibility to free the block.
    //
{
    DTLNODE* pdtlnode;
    PBPORT* ppbport;

    TRACE( "CreatePortNode" );

    pdtlnode = DtlCreateSizedNode( sizeof(PBPORT), 0L );
    if (!pdtlnode)
    {
        return NULL;
    }

    ppbport = (PBPORT* )DtlGetData( pdtlnode );
    ASSERT( ppbport );

    CopyToPbport( ppbport, NULL );

    return pdtlnode;
}

VOID
DestroyPort(
    PBPORT* pPort)
{
    Free0( pPort->pszDevice );
    Free0( pPort->pszMedia );
    Free0( pPort->pszPort );
    Free0( pPort->pszScriptBefore );

    // pmay: 228565
    // Clean up the list of available protocols
    // if any.
    //
    if ( pPort->pListProtocols )
    {
        DtlDestroyList( pPort->pListProtocols, NULL );
    }
}

VOID
DestroyEntryTypeNode(
    IN DTLNODE *pdtlnode)
{
    DtlDestroyNode(pdtlnode);
}

VOID
DestroyEntryNode(
    IN DTLNODE* pdtlnode )

    // Release all memory associated with phonebook entry node 'pdtlnode'.
    // See DtlDestroyList.
    //
{
    PBENTRY* ppbentry;

    TRACE( "DestroyEntryNode" );

    ASSERT( pdtlnode );
    ppbentry = (PBENTRY* )DtlGetData( pdtlnode );
    ASSERT( ppbentry );

    Free0( ppbentry->pszEntryName );
    Free0( ppbentry->pszPrerequisiteEntry );
    Free0( ppbentry->pszPrerequisitePbk );
    Free0( ppbentry->pszPreferredPort );
    Free0( ppbentry->pszPreferredDevice );

    Free0( ppbentry->pCustomAuthData );

    Free0( ppbentry->pszScriptAfter );
    Free0( ppbentry->pszX25Network );
    Free0( ppbentry->pszX25Address );
    Free0( ppbentry->pszX25UserData );
    Free0( ppbentry->pszX25Facilities );

    Free0( ppbentry->pszIpAddress );
    Free0( ppbentry->pszIpDnsAddress );
    Free0( ppbentry->pszIpDns2Address );
    Free0( ppbentry->pszIpWinsAddress );
    Free0( ppbentry->pszIpWins2Address );
    Free0( ppbentry->pszIpDnsSuffix );

    Free0( ppbentry->pszCustomDialDll );
    Free0( ppbentry->pszCustomDialFunc );
    Free0( ppbentry->pszCustomDialerName);

    Free0( ppbentry->pszOldUser );
    Free0( ppbentry->pszOldDomain );

    Free0( ppbentry->pGuid );

    DtlDestroyList( ppbentry->pdtllistLinks, DestroyLinkNode );
    DtlDestroyList( ppbentry->pdtllistNetComponents, DestroyKvNode );

    DtlDestroyNode( pdtlnode );
}


VOID
DestroyLinkNode(
    IN DTLNODE* pdtlnode )

    // Release all memory associated with phonebook entry link node
    // 'pdtlnode'.  See DtlDestroyList.
    //
{
    PBLINK* ppblink;

    TRACE( "DestroyLinkNode" );

    ASSERT( pdtlnode );
    ppblink = (PBLINK* )DtlGetData( pdtlnode );
    ASSERT( ppblink );

    DestroyPort(&(ppblink->pbport));
    Free0( ppblink->pTapiBlob );
    DtlDestroyList( ppblink->pdtllistPhones, DestroyPhoneNode );

    DtlDestroyNode( pdtlnode );
}


VOID
DestroyPhoneNode(
    IN DTLNODE* pdtlnode )

    // Release memory associated with PBPHONE node 'pdtlnode'.  See
    // DtlDestroyList.
    //
{
    PBPHONE* pPhone;

    TRACE( "DestroyPhoneNode" );

    ASSERT( pdtlnode );
    pPhone = (PBPHONE* )DtlGetData( pdtlnode );
    ASSERT( pPhone );

    Free0( pPhone->pszAreaCode );
    Free0( pPhone->pszPhoneNumber );
    Free0( pPhone->pszComment );

    DtlDestroyNode( pdtlnode );
}

VOID
DestroyPortNode(
    IN DTLNODE* pdtlnode )

    // Release memory associated with PBPORT node 'pdtlnode'.  See
    // DtlDestroyList.
    //
{
    PBPORT* pPort;

    TRACE( "DestroyPortNode" );

    ASSERT( pdtlnode );
    pPort = (PBPORT* )DtlGetData( pdtlnode );
    ASSERT( pPort );

    DestroyPort(pPort);

    DtlDestroyNode( pdtlnode );
}


DTLNODE*
DuplicateEntryNode(
    DTLNODE* pdtlnodeSrc )

    // Duplicates phonebook entry node 'pdtlnodeSrc'.  See CloneEntryNode and
    // DtlDuplicateList.
    //
    // Returns the address of the allocated node if successful, NULL
    // otherwise.  It's the caller's responsibility to free the block.
    //
{
    DTLNODE* pdtlnodeDst;
    PBENTRY* ppbentrySrc;
    PBENTRY* ppbentryDst;
    BOOL fDone;

    TRACE( "DuplicateEntryNode" );

    pdtlnodeDst = DtlCreateSizedNode( sizeof(PBENTRY), 0L );
    if (!pdtlnodeDst)
    {
        return NULL;
    }

    ppbentrySrc = (PBENTRY* )DtlGetData( pdtlnodeSrc );
    ppbentryDst = (PBENTRY* )DtlGetData( pdtlnodeDst );
    fDone = FALSE;

    CopyMemory( ppbentryDst, ppbentrySrc, sizeof(PBENTRY) );

    ppbentryDst->pszEntryName = NULL;
    ppbentryDst->pdtllistLinks = NULL;
    ppbentryDst->pszPrerequisiteEntry = NULL;
    ppbentryDst->pszPrerequisitePbk = NULL;
    ppbentryDst->pszPreferredPort = NULL;
    ppbentryDst->pszPreferredDevice = NULL;

    //For XPSP1 664578, .Net 639551   Add preferred info for Modem settings
    ppbentryDst->dwPreferredBps    = 0;
    ppbentryDst->fPreferredHwFlow  = 0;
    ppbentryDst->fPreferredEc      = 0;
    ppbentryDst->fPreferredEcc     = 0;
    ppbentryDst->fPreferredSpeaker = 0;
    
    ppbentryDst->dwPreferredModemProtocol = 0;


    ppbentryDst->pCustomAuthData = NULL;

    ppbentryDst->pszScriptAfter = NULL;
    ppbentryDst->pszX25Network = NULL;
    ppbentryDst->pszX25Address = NULL;
    ppbentryDst->pszX25UserData = NULL;
    ppbentryDst->pszX25Facilities = NULL;

    ppbentryDst->pdtllistNetComponents = NULL;

    ppbentryDst->pszIpAddress = NULL;
    ppbentryDst->pszIpDnsAddress = NULL;
    ppbentryDst->pszIpDns2Address = NULL;
    ppbentryDst->pszIpWinsAddress = NULL;
    ppbentryDst->pszIpWins2Address = NULL;
    ppbentryDst->pszIpDnsSuffix = NULL;

    ppbentryDst->pszCustomDialDll = NULL;
    ppbentryDst->pszCustomDialFunc = NULL;
    ppbentryDst->pszCustomDialerName = NULL;

    ppbentryDst->pGuid = NULL;

    ppbentryDst->pszOldUser = NULL;
    ppbentryDst->pszOldDomain = NULL;

    do
    {
        // Duplicate strings.
        //
        if (ppbentrySrc->pszEntryName
            && (!(ppbentryDst->pszEntryName =
                    StrDup( ppbentrySrc->pszEntryName ))))
        {
            break;
        }

        if (ppbentrySrc->pszPrerequisiteEntry
            && (!(ppbentryDst->pszPrerequisiteEntry =
                    StrDup( ppbentrySrc->pszPrerequisiteEntry ))))
        {
            break;
        }

        if (ppbentrySrc->pszPrerequisitePbk
            && (!(ppbentryDst->pszPrerequisitePbk =
                    StrDup( ppbentrySrc->pszPrerequisitePbk ))))
        {
            break;
        }

        if (ppbentrySrc->pszPreferredPort
            && (!(ppbentryDst->pszPreferredPort =
                    StrDup( ppbentrySrc->pszPreferredPort ))))
        {
            break;
        }

        if (ppbentrySrc->pszPreferredDevice
            && (!(ppbentryDst->pszPreferredDevice =
                    StrDup( ppbentrySrc->pszPreferredDevice ))))
        {
            break;
        }

	// For XPSP1 664578
        ppbentryDst->dwPreferredModemProtocol =
            ppbentrySrc->dwPreferredModemProtocol;

        //For .Net 639551   Add preferred info for Modem settings
        ppbentryDst->dwPreferredBps    = ppbentrySrc->dwPreferredBps;
        ppbentryDst->fPreferredHwFlow  = ppbentrySrc->fPreferredHwFlow;
        ppbentryDst->fPreferredEc      = ppbentrySrc->fPreferredEc;
        ppbentryDst->fPreferredEcc     = ppbentrySrc->fPreferredEcc ;
        ppbentryDst->fPreferredSpeaker = ppbentrySrc->fPreferredSpeaker;
        

        if (ppbentrySrc->cbCustomAuthData && ppbentrySrc->pCustomAuthData)
        {
            ppbentryDst->pCustomAuthData = Malloc( ppbentrySrc->cbCustomAuthData );
            if (!ppbentryDst->pCustomAuthData)
            {
                break;
            }
            CopyMemory( ppbentryDst->pCustomAuthData,
                        ppbentrySrc->pCustomAuthData,
                        ppbentrySrc->cbCustomAuthData);
            ppbentryDst->cbCustomAuthData = ppbentrySrc->cbCustomAuthData;
        }

        if (ppbentrySrc->pszIpAddress
            && (!(ppbentryDst->pszIpAddress =
                    StrDup( ppbentrySrc->pszIpAddress ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpDnsAddress
            && (!(ppbentryDst->pszIpDnsAddress =
                    StrDup( ppbentrySrc->pszIpDnsAddress ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpDns2Address
            && (!(ppbentryDst->pszIpDns2Address =
                    StrDup( ppbentrySrc->pszIpDns2Address ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpWinsAddress
            && (!(ppbentryDst->pszIpWinsAddress =
                    StrDup( ppbentrySrc->pszIpWinsAddress ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpWins2Address
            && (!(ppbentryDst->pszIpWins2Address =
                    StrDup( ppbentrySrc->pszIpWins2Address ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpDnsSuffix
            && (!(ppbentryDst->pszIpDnsSuffix =
                    StrDup( ppbentrySrc->pszIpDnsSuffix ))))
        {
            break;
        }

        if (ppbentrySrc->pszScriptAfter
            && (!(ppbentryDst->pszScriptAfter =
                    StrDup( ppbentrySrc->pszScriptAfter ))))
        {
            break;
        }

        if (ppbentrySrc->pszX25Network
            && (!(ppbentryDst->pszX25Network =
                    StrDup( ppbentrySrc->pszX25Network ))))
        {
            break;
        }

        if (ppbentrySrc->pszX25Address
            && (!(ppbentryDst->pszX25Address =
                    StrDup( ppbentrySrc->pszX25Address ))))
        {
            break;
        }

        if (ppbentrySrc->pszX25UserData
            && (!(ppbentryDst->pszX25UserData =
                    StrDup( ppbentrySrc->pszX25UserData ))))
        {
            break;
        }

        if (ppbentrySrc->pszX25Facilities
            && (!(ppbentryDst->pszX25Facilities =
                    StrDup( ppbentrySrc->pszX25Facilities ))))
        {
            break;
        }

        if (ppbentrySrc->pszCustomDialDll
            && (!(ppbentryDst->pszCustomDialDll =
                    StrDup( ppbentrySrc->pszCustomDialDll ))))
        {
            break;
        }

        if (ppbentrySrc->pszCustomDialFunc
            && (!(ppbentryDst->pszCustomDialFunc =
                    StrDup( ppbentrySrc->pszCustomDialFunc ))))
        {
            break;
        }

        if (ppbentrySrc->pszCustomDialerName
            && (!(ppbentryDst->pszCustomDialerName =
                    StrDup( ppbentrySrc->pszCustomDialerName))))
        {
            break;
        }

        if (ppbentrySrc->pszOldUser
            && (!(ppbentryDst->pszOldUser =
                    StrDup( ppbentrySrc->pszOldUser ))))
        {
            break;
        }

        if (ppbentrySrc->pszOldDomain
            && (!(ppbentryDst->pszOldDomain =
                    StrDup( ppbentrySrc->pszOldDomain ))))
        {
            break;
        }

        // Duplicate GUID.
        //
        if (ppbentrySrc->pGuid)
        {
            ppbentryDst->pGuid = Malloc( sizeof( GUID ) );
            if (!ppbentryDst->pGuid)
            {
                break;
            }

            *ppbentryDst->pGuid = *ppbentrySrc->pGuid;
        }

        // Duplicate net component list information.
        //
        if (ppbentrySrc->pdtllistNetComponents
            && (!(ppbentryDst->pdtllistNetComponents =
                    DtlDuplicateList(
                        ppbentrySrc->pdtllistNetComponents,
                        DuplicateKvNode,
                        DestroyKvNode ))))
        {
            break;
        }

        // Duplicate list of link information.
        //
        if (ppbentrySrc->pdtllistLinks
            && (!(ppbentryDst->pdtllistLinks =
                    DtlDuplicateList(
                        ppbentrySrc->pdtllistLinks,
                        DuplicateLinkNode,
                        DestroyLinkNode ))))
        {
            break;
        }

        fDone = TRUE;
    }
    while (FALSE);

    if (!fDone)
    {
        DestroyEntryNode( pdtlnodeDst );
        return NULL;
    }

    // Since the copy is "new" it is inherently dirty relative to the
    // phonebook file.
    //
    ppbentryDst->fDirty = TRUE;

    return pdtlnodeDst;
}


DTLNODE*
DuplicateLinkNode(
    IN DTLNODE* pdtlnodeSrc )

    // Duplicates phonebook entry link node 'pdtlnodeSrc'.  See
    // DtlDuplicateList.
    //
    // Returns the address of the allocated node if successful, NULL
    // otherwise.  It's the caller's responsibility to free the block.
    //
{
    DTLNODE* pdtlnodeDst;
    PBLINK* ppblinkSrc;
    PBLINK* ppblinkDst;
    BOOL fDone;

    TRACE( "DuplicateLinkNode" );

    pdtlnodeDst = DtlCreateSizedNode( sizeof(PBLINK), 0L );
    if (!pdtlnodeDst)
    {
        return NULL;
    }

    ppblinkSrc = (PBLINK* )DtlGetData( pdtlnodeSrc );
    ppblinkDst = (PBLINK* )DtlGetData( pdtlnodeDst );
    fDone = FALSE;

    CopyMemory( ppblinkDst, ppblinkSrc, sizeof(PBLINK) );

    ppblinkDst->pbport.pszDevice = NULL;
    ppblinkDst->pbport.pszMedia = NULL;
    ppblinkDst->pbport.pszPort = NULL;
    ppblinkDst->pbport.pszScriptBefore = NULL;
    ppblinkDst->pbport.pListProtocols = NULL;
    ppblinkDst->pTapiBlob = NULL;
    ppblinkDst->pdtllistPhones = NULL;

    do
    {
        // Duplicate strings.
        //
        if (ppblinkSrc->pbport.pszDevice
            && (!(ppblinkDst->pbport.pszDevice =
                    StrDup( ppblinkSrc->pbport.pszDevice ))))
        {
            break;
        }

        if (ppblinkSrc->pbport.pszMedia
            && (!(ppblinkDst->pbport.pszMedia =
                    StrDup( ppblinkSrc->pbport.pszMedia ))))
        {
            break;
        }


        if (ppblinkSrc->pbport.pszPort
            && (!(ppblinkDst->pbport.pszPort =
                    StrDup( ppblinkSrc->pbport.pszPort ))))
        {
            break;
        }

        if (ppblinkSrc->pbport.pszScriptBefore
            && (!(ppblinkDst->pbport.pszScriptBefore =
                    StrDup( ppblinkSrc->pbport.pszScriptBefore ))))
        {
            break;
        }

        // Duplicate TAPI blob.
        //
        if (ppblinkSrc->pTapiBlob)
        {
            VOID* pTapiBlobDst;

            ppblinkDst->pTapiBlob = (VOID* )Malloc( ppblinkSrc->cbTapiBlob );
            if (!ppblinkDst->pTapiBlob)
                break;

            CopyMemory( ppblinkDst->pTapiBlob, ppblinkSrc->pTapiBlob,
                ppblinkSrc->cbTapiBlob );
        }

        // Duplicate list of phone numbers.
        //
        if (ppblinkSrc->pdtllistPhones
            &&  (!(ppblinkDst->pdtllistPhones =
                     DtlDuplicateList(
                         ppblinkSrc->pdtllistPhones,
                         DuplicatePhoneNode,
                         DestroyPhoneNode ))))
        {
            break;
        }

        //For whistler bug 398438       gangz
        //If the pListProtocls is not duplicated, then in EuFree() which calls
        // DestoryEntryNode() to free EINFO->pNode, ClosePhonebookFile() to
        // free EINFO->pFile, both of them will eventually free this
        // pListProtocols, then an AV will occur.
        //
        if (ppblinkSrc->pbport.pListProtocols
            && ( !(ppblinkDst->pbport.pListProtocols =
                    DtlDuplicateList(
                        ppblinkSrc->pbport.pListProtocols,
                        DuplicateProtocolNode,
                        DestroyProtocolNode))))
        {
            break;
        }

        fDone = TRUE;
    }
    while (FALSE);

    if (!fDone)
    {
        DestroyLinkNode( pdtlnodeDst );
        return NULL;
    }

    return pdtlnodeDst;
}

//For whistler bug 398438       gangz
//
DTLNODE*
DuplicateProtocolNode(
    IN DTLNODE* pdtlnodeSrc )
{
    DTLNODE* pdtlnodeDst = NULL;
    BOOL fDone = FALSE;
    PVOID pNameSrc = NULL;

    TRACE( "DuplicateProtocolNode" );

    pdtlnodeDst = DtlCreateSizedNode( sizeof(DTLNODE), 0L );
    if ( !pdtlnodeDst )
    {
        return NULL;
    }

    do
    {
        pNameSrc = DtlGetData( pdtlnodeSrc );
        if(pNameSrc
            && ( !(pdtlnodeDst->pData = StrDup(pNameSrc) ))
            )
        {
            break;
        }

        pdtlnodeDst->lNodeId = pdtlnodeSrc->lNodeId;

        fDone = TRUE;
    }
    while(FALSE);

    if (!fDone)
    {
        DestroyProtocolNode(pdtlnodeDst);
        return NULL;
    }

    return pdtlnodeDst;
}

VOID
DestroyProtocolNode(
    IN DTLNODE* pdtlnode )

    // Release memory associated with PBPHONE node 'pdtlnode'.  See
    // DtlDestroyList.
    //
{
    TRACE( "DestroyProtocolNode" );

    DtlDestroyNode( pdtlnode );
}


DTLNODE*
DuplicatePhoneNode(
    IN DTLNODE* pdtlnodeSrc )

    // Duplicates phone number set node 'pdtlnodeSrc'.  See DtlDuplicateList.
    //
    // Returns the address of the allocated node if successful, NULL
    // otherwise.  It's the caller's responsibility to free the block.
    //
{
    DTLNODE* pdtlnodeDst;
    PBPHONE* pPhoneSrc;
    PBPHONE* pPhoneDst;
    BOOL fDone;

    TRACE( "DuplicatePhoneNode" );

    pdtlnodeDst = DtlCreateSizedNode( sizeof(PBPHONE), 0L );
    if (!pdtlnodeDst)
    {
        return NULL;
    }

    pPhoneSrc = (PBPHONE* )DtlGetData( pdtlnodeSrc );
    pPhoneDst = (PBPHONE* )DtlGetData( pdtlnodeDst );
    fDone = FALSE;

    CopyMemory( pPhoneDst, pPhoneSrc, sizeof(PBPHONE) );

    pPhoneDst->pszPhoneNumber = NULL;
    pPhoneDst->pszAreaCode = NULL;
    pPhoneDst->pszComment = NULL;

    do
    {
        // Duplicate strings.
        //
        if (pPhoneSrc->pszPhoneNumber
            && (!(pPhoneDst->pszPhoneNumber =
                    StrDup( pPhoneSrc->pszPhoneNumber ))))
        {
            break;
        }

        if (pPhoneSrc->pszAreaCode
            && (!(pPhoneDst->pszAreaCode =
                    StrDup( pPhoneSrc->pszAreaCode ))))
        {
            break;
        }

        if (pPhoneSrc->pszComment
            && (!(pPhoneDst->pszComment =
                    StrDup( pPhoneSrc->pszComment ))))
        {
            break;
        }

        fDone = TRUE;
    }
    while (FALSE);

    if (!fDone)
    {
        DestroyPhoneNode( pdtlnodeDst );
        return NULL;
    }

    return pdtlnodeDst;
}


VOID
EnableOrDisableNetComponent(
    IN PBENTRY* pEntry,
    IN LPCTSTR  pszComponent,
    IN BOOL     fEnable)
{
    KEYVALUE*   pKv;
    BOOL        fIsEnabled;

    static const TCHAR c_pszDisabledValue[] = TEXT("0");
    static const TCHAR c_pszEnabledValue [] = TEXT("1");

    ASSERT (pEntry);
    ASSERT (pszComponent);

    // If the component already exists in the list, update its value.
    //
    if (FIsNetComponentListed (pEntry, pszComponent, &fIsEnabled, &pKv))
    {
        LPCTSTR pszNewValue = NULL;

        // If we need to change the value, do so, otherwise, we don't have
        // any work to do.  (Use a logical XOR here instead of == because
        // there are many values of TRUE.
        //
        if (fEnable && !fIsEnabled)
        {
            pszNewValue = c_pszEnabledValue;
        }
        else if (!fEnable && fIsEnabled)
        {
            pszNewValue = c_pszDisabledValue;
        }

        if (pszNewValue)
        {
            Free0 (pKv->pszValue);
            pKv->pszValue = StrDup(pszNewValue);
        }
    }

    // If the component does not exist in the list, we need to add it.
    //
    else
    {
        LPCTSTR     pszValue;
        DTLNODE*    pdtlnode;

        pszValue = (fEnable) ? c_pszEnabledValue : c_pszDisabledValue;
        pdtlnode = CreateKvNode (pszComponent, pszValue);
        if (pdtlnode)
        {
            ASSERT( DtlGetData(pdtlnode) );
            DtlAddNodeLast (pEntry->pdtllistNetComponents, pdtlnode);
        }
    }
}


BOOL
FIsNetComponentListed(
    IN PBENTRY*     pEntry,
    IN LPCTSTR      pszComponent,
    OUT BOOL*       pfEnabled,
    OUT KEYVALUE**  ppKv)

    // Returns TRUE if the pszComponent exists as the key of the NETCOMPONENTs
    // KEYVALUE pairs in pEntry.  If TRUE is returned, *pfEnabled is the
    // BOOL form of the value part of the pair.  This represents whether the
    // component is 'checked' in the property UI on the networking page.
    // ppKv is an optional output parameter.  If ppKv is specfied, and the
    // function returns TRUE, it will point to the KEYVALUE in the DTLLIST
    // of NETCOMPONENTS.
{
    DTLNODE*    pdtlnode;
    BOOL        fPresent = FALSE;

    ASSERT (pEntry);
    ASSERT (pEntry->pdtllistNetComponents);
    ASSERT (pszComponent);
    ASSERT (pfEnabled);

    // Initialize the output parameters.
    //
    *pfEnabled = FALSE;
    if (ppKv)
    {
        *ppKv = NULL;
    }

    // Look for pszComponent in the list.
    //
    for (pdtlnode = DtlGetFirstNode (pEntry->pdtllistNetComponents);
         pdtlnode;
         pdtlnode = DtlGetNextNode (pdtlnode))
    {
        KEYVALUE* pKv = (KEYVALUE* )DtlGetData (pdtlnode);
        ASSERT (pKv);

        if (0 == lstrcmp(pszComponent, pKv->pszKey))
        {
            // If we found the component, get its value (as a BOOL)
            // and return the KEYVALUE pointer if requested.
            //
            LONG lValue = _ttol (pKv->pszValue);
            *pfEnabled = !!lValue;

            fPresent = TRUE;

            if (ppKv)
            {
                *ppKv = pKv;
            }

            break;
        }
    }

    return fPresent;
}


DTLNODE*
EntryNodeFromName(
    IN DTLLIST* pdtllistEntries,
    IN LPCTSTR pszName )

    // Returns the address of the node in the global phonebook entries list
    // whose Entry Name matches 'pszName' or NULL if none.
    //
{
    DTLNODE* pdtlnode;

    for (pdtlnode = DtlGetFirstNode( pdtllistEntries );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        PBENTRY* ppbentry = (PBENTRY* )DtlGetData( pdtlnode );

        if (lstrcmpi( ppbentry->pszEntryName, pszName ) == 0)
        {
            return pdtlnode;
        }
    }

    return NULL;
}


DWORD
EntryTypeFromPbport(
    IN PBPORT* ppbport )

    // Returns the RASET_* entry type associated with the 'ppbport' port type.
    //
{
    DWORD dwType;

    // Default is phone type
    //
    dwType = RASET_Phone;

    if ((ppbport->pbdevicetype == PBDT_Null)      ||
        (ppbport->dwFlags & PBP_F_NullModem)      ||
        (ppbport->pbdevicetype == PBDT_Irda)      ||
        (ppbport->pbdevicetype == PBDT_Parallel))
    {
        dwType = RASET_Direct;
    }
    else if (ppbport->pbdevicetype == PBDT_Vpn)
    {
        dwType = RASET_Vpn;
    }
    else if (ppbport->pbdevicetype == PBDT_PPPoE)
    {
        dwType = RASET_Broadband;
    }
    else if (ppbport->pszPort)
    {
        TCHAR achPort[ 3 + 1 ];

        lstrcpyn( achPort, ppbport->pszPort, 3 + 1 );

        if (lstrcmp( achPort, TEXT("VPN") ) == 0)
        {
            dwType = RASET_Vpn;
        }
    }

    return dwType;
}


DWORD
GetOverridableParam(
    IN PBUSER* pUser,
    IN PBENTRY* pEntry,
    IN DWORD dwfRasorBit )

    // Return the value of the parameter identified by RASOR_* the single bit
    // in bitmask 'dwfRasorBit', retrieving the value from the 'pUser' or
    // 'pEntry' based on the override mask in 'pEntry'.
    //
{
    switch (dwfRasorBit)
    {
        case RASOR_RedialAttempts:
        {
            if (pEntry->dwfOverridePref & RASOR_RedialAttempts)
            {
                return pEntry->dwRedialAttempts;
            }
            else
            {
                return pUser->dwRedialAttempts;
            }
        }

        case RASOR_RedialSeconds:
        {
            if (pEntry->dwfOverridePref & RASOR_RedialSeconds)
            {
                return pEntry->dwRedialSeconds;
            }
            else
            {
                return pUser->dwRedialSeconds;
            }
        }

        case RASOR_IdleDisconnectSeconds:
        {
            if (pEntry->dwfOverridePref & RASOR_IdleDisconnectSeconds)
            {
                return (DWORD )pEntry->lIdleDisconnectSeconds;
            }
            else
            {
                return pUser->dwIdleDisconnectSeconds;
            }
        }

        case RASOR_RedialOnLinkFailure:
        {
            if (pEntry->dwfOverridePref & RASOR_RedialOnLinkFailure)
            {
                return pEntry->fRedialOnLinkFailure;
            }
            else
            {
                return pUser->fRedialOnLinkFailure;
            }
        }

        case RASOR_PopupOnTopWhenRedialing:
        {
            if (pEntry->dwfOverridePref & RASOR_PopupOnTopWhenRedialing)
            {
#if 0
                return pEntry->fPopupOnTopWhenRedialing;
#else
                return (DWORD )TRUE;
#endif
            }
            else
            {
                return pUser->fPopupOnTopWhenRedialing;
            }
        }

        case RASOR_CallbackMode:
        {
            if (pEntry->dwfOverridePref & RASOR_CallbackMode)
            {
                return pEntry->dwCallbackMode;
            }
            else
            {
                return pUser->dwCallbackMode;
            }
        }
    }

    return 0;
}


#if 0
INT
IndexFromName(
    IN DTLLIST* pdtllist,
    IN TCHAR* pszName )

    // Returns the 0-based index of the first node that matches 'pszName' in
    // the linked list of strings, 'pdtllist', or -1 if not found.
    //
{
    DTLNODE* pdtlnode;
    INT i;

    for (pdtlnode = DtlGetFirstNode( pdtllist ), i = 0;
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ), ++i)
    {
        if (lstrcmp( pszName, (TCHAR* )DtlGetData( pdtlnode ) ) == 0)
        {
            break;
        }
    }

    return (pdtlnode) ? i : -1;
}
#endif


#if 0
INT
IndexFromDeviceName(
    IN DTLLIST* pdtllist,
    IN TCHAR* pszDeviceName )

    // Returns the 0-based index of the first node that matches
    // 'pszDeviceName' in the linked list of PBPORTs, 'pdtllist', or -1 if not
    // found.
    //
{
    DTLNODE* pdtlnode;
    INT i;

    for (pdtlnode = DtlGetFirstNode( pdtllist ), i = 0;
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ), ++i)
    {
        PBPORT* pPort = (PBPORT* )DtlGetData( pdtlnode );

        if (lstrcmp( pszDeviceName, pPort->pszDevice ) == 0)
        {
            break;
        }
    }

    return (pdtlnode) ? i : -1;
}
#endif

BOOL
IsPublicPhonebook(
    IN LPCTSTR pszPhonebookPath )

    // Returns TRUE if the given phonebook is in the 'All Users' directory
    // and hence is a shared phonebook; returns FALSE otherwise
    //
{
    BOOL bPublic = FALSE;
    HMODULE h = NULL;
    FARPROC pPathCanonicalize;
    FARPROC pPathRemoveFileSpec;
    TCHAR* pszAllUsers = NULL;
    TCHAR* pszAllUsersCanon = NULL;
    TCHAR* pszPhonebook = NULL;
    TCHAR* pszSysRas = NULL;

    // Whistler Bug 318063 STRESS: IsPublicPbk should heap allocate its local
    // buffers
    //
    do
    {
        pszAllUsers = Malloc( (MAX_PATH + 1) * sizeof(TCHAR) );
        if ( !pszAllUsers ) { break; }

        pszAllUsersCanon = Malloc( (MAX_PATH + 1) * sizeof(TCHAR) );
        if ( !pszAllUsersCanon ) { break; }

        pszPhonebook = Malloc( (MAX_PATH + 1) * sizeof(TCHAR) );
        if ( !pszPhonebook ) { break; }

        if (GetPhonebookDirectory(PBM_System, pszAllUsers)
            && (h = LoadLibrary(TEXT("shlwapi.dll")))
            && (pPathCanonicalize = GetProcAddress(h, SZ_PathCanonicalize))
            && (pPathRemoveFileSpec = GetProcAddress(h, SZ_PathRemoveFileSpec)))
        {
            pPathCanonicalize(pszAllUsersCanon, pszAllUsers);

            if(TEXT('\\') == *(pszAllUsersCanon + lstrlen(pszAllUsersCanon) - 1))
            {
                *(pszAllUsersCanon + lstrlen(pszAllUsersCanon) - 1) = TEXT('\0');
            }
            pPathCanonicalize(pszPhonebook, pszPhonebookPath);
            pPathRemoveFileSpec(pszPhonebook);

            // Whistler 326015 PBK: if ATM device name is NULL, we should seek
            // out a device name just like w/serial/ISDN
            //
            if (!lstrcmpi(pszPhonebook, pszAllUsersCanon))
            {
                bPublic = TRUE;
            }
            else
            {
                pszSysRas = Malloc( (MAX_PATH + 1) * sizeof(TCHAR) );
                if ( !pszSysRas ) { break; }

                if (!GetSystemWindowsDirectory(pszSysRas, MAX_PATH))
                {
                    break;
                }

                lstrcat(pszSysRas, S_SYSRASDIR);
                bPublic = (!lstrcmpi(pszPhonebook, pszSysRas) ? TRUE : FALSE);
            }
        }

    } while ( FALSE );

    // Clean up
    //
    if (h) { FreeLibrary(h); }

    Free0 ( pszAllUsers );
    Free0 ( pszAllUsersCanon );
    Free0 ( pszPhonebook );
    Free0 ( pszSysRas );

    TRACE1( "IsPublicPhonebook=%u", bPublic);
    return bPublic;
}

DWORD
LoadPadsList(
    OUT DTLLIST** ppdtllistPads )

    // Build a list of all X.25 PAD devices in '*ppdtllistPads'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  It is
    // caller's responsibility to DtlDestroyList the list when done.
    //
{
    INT i;
    DWORD dwErr;
    RASMAN_DEVICE* pDevices;
    DWORD dwDevices;

    TRACE( "LoadPadsList" );

    *ppdtllistPads = NULL;

    dwErr = GetRasPads( &pDevices, &dwDevices );
    if (dwErr != 0)
    {
        return dwErr;
    }

    *ppdtllistPads = DtlCreateList( 0L );
    if (!*ppdtllistPads)
    {
        Free( pDevices );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    qsort( (VOID* )pDevices, (size_t )dwDevices, sizeof(RASMAN_DEVICE),
           CompareDevices );

    for (i = 0; i < (INT )dwDevices; ++i)
    {
        TCHAR* pszDup;

        pszDup = StrDupTFromA( pDevices[ i ].D_Name );
        dwErr = AppendStringToList( *ppdtllistPads, pszDup );
        Free0( pszDup );

        if (dwErr != 0)
        {
            Free( pDevices );
            DtlDestroyList( *ppdtllistPads, NULL );
            *ppdtllistPads = NULL;
            return dwErr;
        }
    }

    Free( pDevices );

    TRACE( "LoadPadsList=0" );
    return 0;
}


DWORD
LoadPortsList(
    OUT DTLLIST** ppdtllistPorts )

    // Build a sorted list of all RAS ports in '*ppdtllistPorts'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  It is
    // caller's responsibility to DtlDestroyList the list when done.
    //
{
    return LoadPortsList2( NULL, ppdtllistPorts, FALSE );
}


DWORD
LoadPortsList2(
    IN  HANDLE hConnection,
    OUT DTLLIST** ppdtllistPorts,
    IN  BOOL fRouter)

    // Build a sorted list of all RAS ports in '*ppdtllistPorts'.  'FRouter'
    // indicates only ports with "router" usage should be returned.
    // Otherwise, only dialout ports are returned.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  It is
    // caller's responsibility to DtlDestroyList the list when done.
    //
{
    INT i;
    DWORD dwErr;
    RASMAN_PORT* pPorts;
    RASMAN_PORT* pPort;
    DWORD dwPorts;

    TRACE( "LoadPortsList2" );

    *ppdtllistPorts = NULL;

    dwErr = GetRasPorts( hConnection, &pPorts, &dwPorts );
    if (dwErr != 0)
    {
        return dwErr;
    }

    *ppdtllistPorts = DtlCreateList( 0L );
    if (!*ppdtllistPorts)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    qsort( (VOID* )pPorts, (size_t )dwPorts, sizeof(RASMAN_PORT),
           ComparePorts );

    for (i = 0, pPort = pPorts; i < (INT )dwPorts; ++i, ++pPort)
    {
        if (fRouter)
        {
            // We're only interested in router ports.
            //
            //Add this CALL_OUTBOUND_ROUTER for bug 349087 345068
            //
            if (!(pPort->P_ConfiguredUsage & CALL_ROUTER) &&
                !(pPort->P_ConfiguredUsage &CALL_OUTBOUND_ROUTER)
                )
            {
                continue;
            }
        }
        else
        {
            // We're only interested in ports you can dial-out on.
            //
            if (!(pPort->P_ConfiguredUsage & CALL_OUT))
            {
                continue;
            }
        }

        dwErr = AppendPbportToList( hConnection, *ppdtllistPorts, pPort );
        if (dwErr != 0)
        {
            Free( pPorts );
            DtlDestroyList( *ppdtllistPorts, NULL );
            *ppdtllistPorts = NULL;
            return dwErr;
        }
    }

    Free( pPorts );

    TRACE( "LoadPortsList=0" );
    return 0;
}


DWORD
LoadScriptsList(
    HANDLE  hConnection,
    OUT DTLLIST** ppdtllistScripts )

    // Build a sorted list of all RAS switch devices in '*ppdtllistPorts'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  It is
    // caller's responsibility to DtlDestroyList the list when done.
    //
{
    INT i;
    DWORD dwErr;
    RASMAN_DEVICE* pDevices;
    DWORD dwDevices;

    TRACE( "LoadScriptsList" );

    *ppdtllistScripts = NULL;

    dwErr = GetRasSwitches( hConnection, &pDevices, &dwDevices );
    if (dwErr != 0)
    {
        return dwErr;
    }

    *ppdtllistScripts = DtlCreateList( 0L );
    if (!*ppdtllistScripts)
    {
        Free( pDevices );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    qsort( (VOID* )pDevices, (size_t )dwDevices, sizeof(RASMAN_DEVICE),
           CompareDevices );

    for (i = 0; i < (INT )dwDevices; ++i)
    {
        TCHAR* pszDup;

        pszDup = StrDupTFromA( pDevices[ i ].D_Name );

        if(NULL == pszDup)
        {
            return E_OUTOFMEMORY;
        }

        dwErr = AppendStringToList( *ppdtllistScripts, pszDup );
        Free( pszDup );

        if (dwErr != 0)
        {
            Free( pDevices );
            DtlDestroyList( *ppdtllistScripts, NULL );
            *ppdtllistScripts = NULL;
            return dwErr;
        }
    }

    Free( pDevices );

    TRACE( "LoadScriptsList=0" );
    return 0;
}


#if 0
TCHAR*
NameFromIndex(
    IN DTLLIST* pdtllist,
    IN INT iToFind )

    // Returns the name associated with 0-based index 'iToFind' in the linked
    // list of strings, 'pdtllist', or NULL if not found.
    //
{
    DTLNODE* pdtlnode;

    if (!pdtllist)
    {
        return NULL;
    }

    pdtlnode = DtlGetFirstNode( pdtllist );

    if (iToFind < 0)
    {
        return NULL;
    }

    while (pdtlnode && iToFind--)
    {
        pdtlnode = DtlGetNextNode( pdtlnode );
    }

    return (pdtlnode) ? (TCHAR* )DtlGetData( pdtlnode ) : NULL;
}
#endif


PBDEVICETYPE
PbdevicetypeFromPszType(
    IN TCHAR* pszDeviceType )

    // Returns the device type corresponding to the device type string,
    // 'pszDeviceType'.
    //
{
    CHAR* pszA;
    PBDEVICETYPE pbdt;

    pbdt = PBDT_None;
    pszA = StrDupAFromT( pszDeviceType );
    if (pszA)
    {
        pbdt = PbdevicetypeFromPszTypeA( pszA );
        Free( pszA );
    }
    return pbdt;
}


PBDEVICETYPE
PbdevicetypeFromPszTypeA(
    IN CHAR* pszDeviceTypeA )

    // Returns the device type corresponding to the ANSI device type string,
    // 'pszDeviceType'.
    //
{
    PBDEVICETYPE pbdt;
    TCHAR *pszDeviceType = StrDupTFromA(pszDeviceTypeA);

    if(NULL == pszDeviceType)
    {
        return PBDT_None;
    }

    if (lstrcmpi( pszDeviceType, RASDT_Modem ) == 0)
    {
        pbdt =  PBDT_Modem;
    }
    else if (lstrcmpi(pszDeviceType, TEXT("null")) == 0)
    {
        pbdt =  PBDT_Null;
    }
    else if (lstrcmpi(pszDeviceType, RASDT_Parallel) == 0)
    {
        pbdt = PBDT_Parallel;
    }
    else if (lstrcmpi(pszDeviceType, RASDT_Irda) == 0)
    {
        pbdt = PBDT_Irda;
    }
    else if (lstrcmpi( pszDeviceType, RASDT_Pad ) == 0)
    {
        pbdt =  PBDT_Pad;
    }
    else if (lstrcmpi( pszDeviceType, TEXT("switch") ) == 0)
    {
        pbdt =  PBDT_Switch;
    }
    else if (lstrcmpi( pszDeviceType, RASDT_Isdn ) == 0)
    {
        pbdt =  PBDT_Isdn;
    }
    else if (lstrcmpi( pszDeviceType, RASDT_X25 ) == 0)
    {
        pbdt =  PBDT_X25;
    }
    else if (lstrcmpi( pszDeviceType, RASDT_Vpn) == 0)
    {
        pbdt =  PBDT_Vpn;
    }
    else if (lstrcmpi(pszDeviceType, RASDT_Atm) == 0)
    {
        pbdt =  PBDT_Atm;
    }
    else if (lstrcmpi(pszDeviceType, RASDT_Serial) == 0)
    {
        pbdt =  PBDT_Serial;
    }
    else if (lstrcmpi(pszDeviceType, RASDT_FrameRelay) == 0)
    {
        pbdt =  PBDT_FrameRelay;
    }
    else if (lstrcmpi(pszDeviceType, RASDT_Sonet) == 0)
    {
        pbdt =  PBDT_Sonet;
    }
    else if (lstrcmpi(pszDeviceType, RASDT_SW56) == 0)
    {
        pbdt =  PBDT_Sw56;
    }
    else if (lstrcmpi(pszDeviceType, RASDT_PPPoE) == 0)
    {
        pbdt = PBDT_PPPoE;
    }
    else
    {
        pbdt =  PBDT_Other;
    }

    if(pszDeviceType)
    {
        Free(pszDeviceType);
    }

    return pbdt;
}

CHAR*
PbMedia(
    IN PBDEVICETYPE pbdt,
    IN CHAR* pszMedia )

    // The media names stored in the phonebook are not exactly the same as
    // those returned by RASMAN.  This translates a RASMAN media name to
    // equivalent phonebook media names given the device type.  The reason for
    // this is historical and obscure.
    //
{
    if (pbdt == PBDT_Isdn)
    {
        return ISDN_TXT;
    }
    else if (pbdt == PBDT_X25)
    {
        return X25_TXT;
    }
    else if (   pbdt == PBDT_Other
            ||  pbdt == PBDT_Vpn
            ||  pbdt == PBDT_Irda
            ||  pbdt == PBDT_Serial
            ||  pbdt == PBDT_Atm
            ||  pbdt == PBDT_Parallel
            ||  pbdt == PBDT_Sonet
            ||  pbdt == PBDT_Sw56
            ||  pbdt == PBDT_FrameRelay
            ||  pbdt == PBDT_PPPoE)
    {
        return pszMedia;
    }
    else
    {
        return SERIAL_TXT;
    }
}


PBPORT*
PpbportFromPortAndDeviceName(
    IN DTLLIST* pdtllistPorts,
    IN TCHAR* pszPort,
    IN TCHAR* pszDevice )

    // Return port with port name 'pszPort' and device name 'pszDevice' in
    // list of ports 'pdtllistPorts' or NULL if not found.  'PszPort' may be
    // an old-style name such as PcImacISDN1, in which case it will match
    // ISDN1.  'PszDevice' may be NULL in which case any device name is
    // assumed to match.
    //
{
    DTLNODE* pdtlnode;

    TCHAR szPort[MAX_PORT_NAME+1];

    if (!pszPort)
    {
        return NULL;
    }

    for (pdtlnode = DtlGetFirstNode( pdtllistPorts );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        PBPORT* ppbport = (PBPORT* )DtlGetData( pdtlnode );

        if ((ppbport->pszPort && lstrcmp( ppbport->pszPort, pszPort ) == 0)
            && (!ppbport->pszDevice || !pszDevice
                || lstrcmp( ppbport->pszDevice, pszDevice ) == 0))
        {
            return ppbport;
        }
    }

    // No match.  Look for the old port name format.
    //
    for (pdtlnode = DtlGetFirstNode( pdtllistPorts );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        TCHAR szBuf[ MAX_DEVICE_NAME + MAX_DEVICETYPE_NAME + 10 + 1 ];
        PBPORT* ppbport;

        ppbport = (PBPORT* )DtlGetData( pdtlnode );

        // Skip modems (COM ports) and unconfigured ports, since they do not
        // follow the same port name formatting rules as other ports.
        //
        if (!ppbport->pszDevice || ppbport->pbdevicetype == PBDT_Modem)
        {
            continue;
        }

        lstrcpy( szBuf, ppbport->pszDevice );
        lstrcat( szBuf, ppbport->pszPort );

        if (lstrcmp( szBuf, pszPort ) == 0)
        {
            return ppbport;
        }
    }

    return NULL;
}

PBPORT*
PpbportFromNT4PortandDevice(
    IN DTLLIST* pdtllistPorts,
    IN TCHAR* pszPort,
    IN TCHAR* pszDevice )
    // This function is called when we couldn't
    // find a port that matches the one in the
    // phonebook. This will take care of the case
    // where the port is pre-nt5 type of port. Since
    // the portnames have changed in nt5 for isdn
    // and vpn, this routine will try to find a
    // port with the same type.
{
    PBPORT *ppbport;
    PBPORT *ppbportRet = NULL;
    DTLNODE *pdtlnode;
    TCHAR   szPort[MAX_PORT_NAME+1];

    if(NULL == pszPort)
    {
        return NULL;
    }

    ZeroMemory(szPort, sizeof(szPort));

    lstrcpyn(szPort, pszPort, MAX_PORT_NAME);

    szPort[lstrlen(TEXT("VPN"))] = TEXT('\0');

    if(0 == lstrcmp(szPort, TEXT("VPN")))
    {
        for (pdtlnode = DtlGetFirstNode( pdtllistPorts );
             pdtlnode;
             pdtlnode = DtlGetNextNode( pdtlnode ))
        {
            ppbport = (PBPORT *) DtlGetData(pdtlnode);

            if(PBDT_Vpn == ppbport->pbdevicetype)
            {
                ppbportRet = ppbport;
                break;
            }
        }

        return ppbportRet;
    }

    return NULL;
}


PBPORT*
PpbportFromNullModem(
    IN DTLLIST* pdtllistPorts,
    IN TCHAR* pszPort,
    IN TCHAR* pszDevice )

    //
    // pmay: 226594
    //
    // Added this function because sometimes we just need to
    // match a given port to a null modem
    //
    // Will attempt to match the ports, but returns any
    // NULL modem it finds if it can't match ports.
    //
{
    DTLNODE* pdtlnode;
    PBPORT * pRet = NULL;

    for (pdtlnode = DtlGetFirstNode( pdtllistPorts );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        PBPORT* ppbport = (PBPORT* )DtlGetData( pdtlnode );

        if ((ppbport->dwFlags & PBP_F_NullModem) && (pRet == NULL))
        {
            pRet = ppbport;
        }

        if ((ppbport->pszPort)                          &&
            (pszPort)                                   &&
            (lstrcmpi( ppbport->pszPort, pszPort ) == 0)
           )
        {
            pRet =  ppbport;
            break;
        }
    }

    return pRet;
}

BOOL
PbportTypeMatchesEntryType(
    IN PBPORT * pPort,
    IN PBENTRY* pEntry)

    // Returns whether the given port has a type that's compatible
    // with the type of the given entry.
{
    if (!pPort || !pEntry)
    {
        return TRUE;
    }

    if ( ( pEntry->dwType == RASET_Phone ) )
    {
        if ( ( pPort->pbdevicetype == PBDT_Null )      ||
             ( pPort->pbdevicetype == PBDT_Parallel )  ||
             ( pPort->pbdevicetype == PBDT_Irda )      ||
             ( pPort->dwFlags & PBP_F_NullModem )      ||
             ( pPort->pbdevicetype == PBDT_Vpn )       ||
             ( pPort->pbdevicetype == PBDT_PPPoE )
           )
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
SetDefaultModemSettings(
    IN PBLINK* pLink )

    // Set the MXS modem settings for link 'pLink' to the defaults.
    //
    // Returns true if something changed, false otherwise.
    //
{
    BOOL fChange;

    fChange = FALSE;

    if (pLink->fHwFlow != pLink->pbport.fHwFlowDefault)
    {
        fChange = TRUE;
        pLink->fHwFlow = pLink->pbport.fHwFlowDefault;
    }

    if (pLink->fEc != pLink->pbport.fEcDefault)
    {
        fChange = TRUE;
        pLink->fEc = pLink->pbport.fEcDefault;
    }

    if (pLink->fEcc != pLink->pbport.fEccDefault)
    {
        fChange = TRUE;
        pLink->fEcc = pLink->pbport.fEccDefault;
    }

    if (pLink->fSpeaker != pLink->pbport.fSpeakerDefault)
    {
        fChange = TRUE;
        pLink->fSpeaker = pLink->pbport.fSpeakerDefault;
    }

    if (pLink->dwBps != pLink->pbport.dwBpsDefault)
    {
        fChange = TRUE;
        pLink->dwBps = pLink->pbport.dwBpsDefault;
    }

    // pmay: 228565
    // Add the default modem protocol
    if (pLink->dwModemProtocol != pLink->pbport.dwModemProtDefault)
    {
        fChange = TRUE;
        pLink->dwModemProtocol = pLink->pbport.dwModemProtDefault;
    }

    TRACE2( "SetDefaultModemSettings(bps=%d)=%d", pLink->dwBps, fChange );
    return fChange;
}


BOOL
ValidateAreaCode(
    IN OUT TCHAR* pszAreaCode )

    // Checks that area code consists of decimal digits only.  If the area
    // code is all white characters it is reduced to empty string.  Returns
    // true if 'pszAreaCode' is a valid area code, false if not.
    //
{
    if (IsAllWhite( pszAreaCode ))
    {
        *pszAreaCode = TEXT('\0');
        return TRUE;
    }

    if (lstrlen( pszAreaCode ) > RAS_MaxAreaCode)
    {
        return FALSE;
    }

    while (*pszAreaCode != TEXT('\0'))
    {
        if (*pszAreaCode < TEXT('0') || *pszAreaCode > TEXT('9'))
        {
            return FALSE;
        }

        ++pszAreaCode;
    }

    return TRUE;
}


BOOL
ValidateEntryName(
    IN LPCTSTR pszEntry )

    // Returns true if 'pszEntry' is a valid phonebook entry name, false if
    // not.
    //
{
    INT nLen = lstrlen( pszEntry );

    if (nLen <= 0
        || nLen > RAS_MaxEntryName
        || IsAllWhite( pszEntry )
        || pszEntry[ 0 ] == TEXT('.'))
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\pbk\util.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** util.c
** Remote Access External APIs
** Utility routines
**
** 10/12/92 Steve Cobb
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <debug.h>    // Trace and assert
#include <rasman.h>
#include <rasapip.h>
#include <pbk.h>

#define EAP_CUSTOM_KEY      0x43424431

typedef struct _EAP_CUSTOM_DATA
{
    DWORD dwSignature;
    DWORD dwCustomAuthKey;
    DWORD dwSize;
    BYTE  abdata[1];
} EAP_CUSTOM_DATA;


BOOL IsRouterPhonebook(LPCTSTR pszPhonebook)
{
    const TCHAR *psz;

    BOOL fRouter = FALSE;

    if(NULL == pszPhonebook)
    {
        goto done;
    }

    psz = pszPhonebook + lstrlen(pszPhonebook);

    //
    // Seek back to the beginning of the filename
    //
    while(psz != pszPhonebook)
    {
        if(TEXT('\\') == *psz)
        {
            break;
        }

        psz--;
    }

    if(TEXT('\\') == *psz)
    {
        psz += 1;
    }

    TRACE1("IsRouterPhonebook: pbk=%ws", psz);

    fRouter = (0 == lstrcmpi(psz, TEXT("router.pbk")));

done:

    return fRouter;
}

BOOL
DwIsDefaultConnection(
    IN PWCHAR pszEntryName)
{
    DWORD dwErr = NO_ERROR, dwCb = 0, dwCount = 1;
    RASAUTODIALENTRYW adEntry;
    INT iCmp;

    // Validate parameters
    //
    if (!pszEntryName)
    {
        return FALSE;
    }
    
    // Initialze
    //
    ZeroMemory(&adEntry, sizeof(adEntry));
    adEntry.dwSize = sizeof(adEntry);

    dwErr = RasGetAutodialAddressW(
                NULL,
                NULL,
                &adEntry,
                &dwCb,
                &dwCount);
    if (dwErr != NO_ERROR)
    {
        return FALSE;
    }
                
    iCmp = _wcsnicmp(
                adEntry.szEntry, 
                pszEntryName, 
                sizeof(adEntry.szEntry) / sizeof(WCHAR));
            
    return (0 == iCmp);
}

DWORD
DwPbentryToDetails(
    IN  PBENTRY* pEntry,
    IN  LPCWSTR pszPhonebookPath,
    IN  BOOL fIsAllUsersPbk,
    OUT RASENUMENTRYDETAILS* pDetails)
{
    DWORD dwErr = NO_ERROR;
    DTLNODE *pdtlnode;
    PBLINK  *pLink;

    pDetails->dwSize = sizeof(RASENUMENTRYDETAILS);
    pDetails->dwType = pEntry->dwType;

    pDetails->fShowMonitorIconInTaskBar = 
        pEntry->fShowMonitorIconInTaskBar;

    if(pEntry->pGuid)
    {
        pDetails->guidId = *pEntry->pGuid;
    }

    wcsncpy(pDetails->szEntryName,
            pEntry->pszEntryName,
            RASAPIP_MAX_ENTRY_NAME);

    pDetails->dwFlags = (fIsAllUsersPbk) ? REN_AllUsers : REN_User;

    if(pszPhonebookPath)
    {
        wcsncpy(pDetails->szPhonebookPath,
                pszPhonebookPath,
                MAX_PATH);
    }
    else
    {
        pDetails->szPhonebookPath[0] = L'\0';
    }

    //
    // Get the devicename associated with the first
    // link in the list of entries associated with
    // this entry
    //
    pDetails->szDeviceName[0] = TEXT('\0');
    pDetails->szPhoneNumber[0] = TEXT('\0');

    pdtlnode = (DTLNODE *)
               DtlGetFirstNode(pEntry->pdtllistLinks);

    if(pdtlnode)
    {
        pLink = (PBLINK *) DtlGetData(pdtlnode);

        if(     (NULL != pLink)
            &&  (pLink->pbport.pszDevice))
        {
            pDetails->rdt = RdtFromPbdt(
                            pLink->pbport.pbdevicetype,
                            pLink->pbport.dwFlags);

            if(RAS_DEVICE_CLASS(pDetails->rdt) == RDT_Tunnel)
            {
                (void) DwGetVpnDeviceName(
                        pEntry->dwVpnStrategy,
                        pLink->pbport.pszDevice,
                        pDetails->szDeviceName);
            }
            else
            {
                lstrcpy(pDetails->szDeviceName,
                        pLink->pbport.pszDevice);
            }                            
        }

        // XP 351412
        //
        // Populate the phone number as well
        //
        if(     (NULL != pLink)
            &&  (pLink->pdtllistPhones))
        {
            DTLNODE* pnodeNum = DtlGetFirstNode(pLink->pdtllistPhones);
            PBPHONE* pPhone = NULL;

            if (NULL != pnodeNum)
            {
                pPhone = DtlGetData(pnodeNum);
                if ((NULL != pPhone) && (NULL != pPhone->pszPhoneNumber))
                {
                    lstrcpyn(
                        pDetails->szPhoneNumber,
                        pPhone->pszPhoneNumber,
                        RAS_MaxPhoneNumber);
                }
            }
        }
        
    }

    // Mark whether this is the default connection
    // XP 286752
    //
    if (DwIsDefaultConnection(pEntry->pszEntryName))
    {
        pDetails->dwFlagsPriv |= REED_F_Default;
    }

    return dwErr;
}

DWORD
DwSendRasNotification(
    IN RASEVENTTYPE     Type,
    IN PBENTRY*         pEntry,
    IN LPCTSTR          pszPhonebookPath,
    IN HANDLE           hData)             // Extra Type-specific info
{
    RASEVENT RasEvent;
    DWORD dwErr = ERROR_SUCCESS;

    ZeroMemory((PBYTE) &RasEvent, sizeof(RASEVENT));

    RasEvent.Type = Type;

    //
    // Ignore the notification if this is a router interface
    //
    if(IsRouterPhonebook(pszPhonebookPath))
    {
        goto done;
    }

    switch(Type)
    {
        case ENTRY_ADDED:
        case ENTRY_MODIFIED:
        case ENTRY_AUTODIAL:
        {
            BOOL fAllUsers = TRUE;

            if (NULL != pszPhonebookPath)
            {
                fAllUsers = IsPublicPhonebook(pszPhonebookPath);
            }
            
            DwPbentryToDetails(
                pEntry, 
                pszPhonebookPath,
                fAllUsers,
                &(RasEvent.Details)
                );
                
            break;
        }

        case ENTRY_DELETED:
        case ENTRY_RENAMED:
        {
            if(NULL != pEntry->pGuid)
            {
                RasEvent.guidId = *pEntry->pGuid;
            }

            if(ENTRY_RENAMED == Type)
            {
                lstrcpy(RasEvent.pszwNewName,
                        pEntry->pszEntryName);

            }
            
            break;
        }

        default:
        {
#if DBG
            ASSERT(FALSE);
#endif
            goto done;
        }

    }        

    dwErr = RasSendNotification(&RasEvent);

done:

    return dwErr;
}

DWORD
DwGetCustomAuthData(PBENTRY *pEntry,
                    DWORD *pcbCustomAuthData,
                    PBYTE *ppCustomAuthData)
{
    DWORD retcode = SUCCESS;
    DWORD cbOffset = 0;
    EAP_CUSTOM_DATA *pCustomData = NULL;

    ASSERT(NULL != pcbCustomAuthData);
    ASSERT(NULL != ppCustomAuthData);
    ASSERT(NULL != pEntry);

    *pcbCustomAuthData = 0;
    *ppCustomAuthData = NULL;

    //
    // first check to see if we understand the format of the
    // eap blob stored in the phonebook
    //
    if(NULL == pEntry->pCustomAuthData)
    {
        goto done;
    }

    if(     (sizeof(DWORD) > pEntry->cbCustomAuthData)
        ||  ((*((DWORD *) pEntry->pCustomAuthData)) != EAP_CUSTOM_KEY))
    {
        Free(pEntry->pCustomAuthData);
        pEntry->pCustomAuthData = NULL;
        pEntry->cbCustomAuthData = 0;

        goto done;
    }

    //
    // Loop through the blob and return the blob corresponding
    // to the eap type of the entry
    //
    while(cbOffset < pEntry->cbCustomAuthData)
    {
        pCustomData = (EAP_CUSTOM_DATA *) 
                      ((PBYTE) pEntry->pCustomAuthData + cbOffset);

        if(     (sizeof(DWORD) > (pEntry->cbCustomAuthData - cbOffset))
            ||  ((*((DWORD *) pEntry->pCustomAuthData)) != EAP_CUSTOM_KEY))
        {
            //
            // The data is corrupt. Blow away the data.
            // should we return an error?
            //
            Free(pEntry->pCustomAuthData);
            pEntry->pCustomAuthData = NULL;
            pEntry->cbCustomAuthData = 0;

            TRACE("GetCustomAuthdata: data is corrupt");
            
            goto done;
        }

        if(pCustomData->dwCustomAuthKey == pEntry->dwCustomAuthKey)
        {
            break;
        }

        cbOffset += sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize;
    }

    if(cbOffset < pEntry->cbCustomAuthData)
    {
        *pcbCustomAuthData = pCustomData->dwSize;
        *ppCustomAuthData = pCustomData->abdata;
    }

done:
    return retcode;
}

DWORD
DwSetCustomAuthData(PBENTRY *pEntry,
                    DWORD cbCustomAuthData,
                    PBYTE pCustomAuthData)
{
    DWORD retcode = SUCCESS;
    DWORD cbOffset = 0;
    EAP_CUSTOM_DATA *pCustomData = NULL;
    DWORD dwSize;
    PBYTE pNewCustomAuthData;

    ASSERT(NULL != pEntry);

    if(NULL != pEntry->pCustomAuthData)
    {
        if(     (sizeof(DWORD) > pEntry->cbCustomAuthData)
            ||  ((*((DWORD *) pEntry->pCustomAuthData)) != EAP_CUSTOM_KEY))
        {   
            Free(pEntry->pCustomAuthData);
            pEntry->pCustomAuthData = NULL;
            pEntry->cbCustomAuthData = 0;
        }
    }

    //
    // Find the old Eap Data
    //
    while(cbOffset < pEntry->cbCustomAuthData)
    {
        pCustomData = (EAP_CUSTOM_DATA *) 
                      ((PBYTE)pEntry->pCustomAuthData + cbOffset);

        if(     (sizeof(DWORD) > (pEntry->cbCustomAuthData - cbOffset))
            ||  ((*((DWORD *) pEntry->pCustomAuthData)) != EAP_CUSTOM_KEY))
        {
            //
            // The data is corrupt. Blow away the data.
            // should we return an error?
            //
            Free(pEntry->pCustomAuthData);
            pEntry->pCustomAuthData = NULL;
            pEntry->cbCustomAuthData = 0;

            TRACE("SetCustomAuthData: data is corrupt!");
            
            break;
        }
        
        if(pCustomData->dwCustomAuthKey == pEntry->dwCustomAuthKey)
        {
            break;
        }

        cbOffset += (sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize);
    }

    if((NULL != pCustomData) 
       && (cbOffset < pEntry->cbCustomAuthData))
    {
        dwSize = sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize;

        ASSERT(pEntry->cbCustomAuthData >= (cbOffset + dwSize));
        
        MoveMemory(pEntry->pCustomAuthData + cbOffset,
                   pEntry->pCustomAuthData 
                   + cbOffset + dwSize,
                   pEntry->cbCustomAuthData - cbOffset - dwSize);

        pEntry->cbCustomAuthData -= dwSize;                   
    }

    if(0 == pEntry->cbCustomAuthData)
    {
        Free0(pEntry->pCustomAuthData);
        pEntry->pCustomAuthData = NULL;
    }

    if(     (0 == cbCustomAuthData)
        ||  (NULL == pCustomAuthData))
    {
        goto done;
    }

    dwSize = cbCustomAuthData 
           + pEntry->cbCustomAuthData 
           + sizeof(EAP_CUSTOM_DATA);

    pNewCustomAuthData = Malloc(dwSize);

    if(NULL == pNewCustomAuthData)
    {
        retcode = E_OUTOFMEMORY;
        goto done;
    }

    ZeroMemory(pNewCustomAuthData, dwSize);

    CopyMemory(pNewCustomAuthData, 
               pEntry->pCustomAuthData,
               pEntry->cbCustomAuthData);

    pCustomData = (EAP_CUSTOM_DATA *) (pNewCustomAuthData 
                                     + pEntry->cbCustomAuthData);

    pCustomData->dwSignature = EAP_CUSTOM_KEY;
    pCustomData->dwCustomAuthKey = pEntry->dwCustomAuthKey;
    pCustomData->dwSize = cbCustomAuthData;
    CopyMemory(pCustomData->abdata,
               pCustomAuthData,
               cbCustomAuthData);

    pEntry->cbCustomAuthData = dwSize;               

    if(NULL != pEntry->pCustomAuthData)
    {
        Free(pEntry->pCustomAuthData);
    }

    pEntry->pCustomAuthData = pNewCustomAuthData;

done:
    return retcode;
}

DWORD
DwGetVpnDeviceName(
    DWORD dwVpnStrategy, 
    WCHAR *pszDeviceDefault, 
    WCHAR *pszDeviceName)
{
    DWORD dwErr = ERROR_SUCCESS, dwType;

    // Figure out the device name we're interested in 
    // discovering.
    //
    dwType = RDT_Tunnel_L2tp;
    switch (dwVpnStrategy)
    {
        case VS_Default:
        case VS_L2tpFirst:
        case VS_L2tpOnly:
            dwType = RDT_Tunnel_L2tp;
            break;

        case VS_PptpFirst:
        case VS_PptpOnly:
            dwType = RDT_Tunnel_Pptp;
            break;
    }
        
    TRACE1("RasGetDeviceName(rdt=%d)...", dwType);

    dwErr = RasGetDeviceNameW(
                dwType,
                pszDeviceName);

    TRACE1("RasGetDeviceName. 0x%x", dwErr);

    if(ERROR_SUCCESS != dwErr)
    {
        dwErr = ERROR_SUCCESS;

        // We can't determine from rasman -- use the phonebook
        // value if possible
        //
        if (NULL != pszDeviceDefault)
        {
            lstrcpyn(
                pszDeviceName, 
                pszDeviceDefault,
                RASAPIP_MAX_DEVICE_NAME);
        }
    }

    return dwErr;        
}

BOOL 
IsServerOS ( )
{
    BOOL        fServerOS = TRUE;      //Default
    //Check to see if the OS is server -  Data Center, Server, Advanced Server

    OSVERSIONINFOEX     stOsvEx;
    ZeroMemory( &stOsvEx, sizeof(stOsvEx) );
    stOsvEx.dwOSVersionInfoSize = sizeof(stOsvEx);
    GetVersionEx((LPOSVERSIONINFO)&stOsvEx);
    if ( stOsvEx.wProductType == VER_NT_WORKSTATION )
        fServerOS = FALSE;
    return fServerOS;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\pbk\cstmdlg.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    cstmdlg.c

Abstract:

    Contains the code to call the custom Entrypoints corresponding
    to RasCustomDialDlg and RasCustomEntryDlg.
    
Author:

    Rao Salapaka (raos) 09-Jan-1998

Revision History:

    Rao Salapaka (raos) 07-Mar-2000 Added DwCustomTerminalDlg for scripting
                                    changes.

--*/


#include <windows.h>  // Win32 root
#include <debug.h>    // Trace/Assert library
#include <pbk.h> // Heap macros
#include <rasdlg.h>   // RAS common dialog 

/*++

Routine Description:

    Loads entrypoints for rasman and rasapi32 dlls.

Arguments:

    void

Return Value:

    ERROR_SUCCESS if successful

--*/
DWORD
DwInitializeCustomDlg()
{
    DWORD dwErr;

    dwErr = LoadRasapi32Dll();
    
    if(ERROR_SUCCESS != dwErr)
    {   
        TRACE1("Failed to load rasapi32.dll. %d",
                dwErr);
                
        goto done;
    }

    dwErr = LoadRasmanDll();

    if(ERROR_SUCCESS != dwErr)
    {
        TRACE1("Failed to load rasman.dll. %d",
                dwErr);
                
        goto done;
    }

done:

    return dwErr;
        
}


/*++

Routine Description:

    Loads the custom dll if specified in the ras phonebook
    entry and Gets the entry point specified by the dwFnId.
    The possible entry points retrieved are RasCustomDialDlg
    and  RasCustomEntryDlg.
    

Arguments:

    lpszPhonebook - The phonebook path to be used to look for
                    the entry. This is not allowed to be NULL.

    lpszEntry - The EntryName to be used. This is not allowed
                to be NULL.

    pfCustomDllSpecified - Buffer to hold a BOOL indicating if
                           a custom dll was specified for the
                           entry.

    pfnCustomEntryPoint - Buffer to hold the address of the
                          Custom Entry Point.

    phInstDll - Buffer to hold the HINSTANCE  of the loaded
                dll.

    dwFnId - Function Id indicating which Entry Point to load.
             The possible values are CUSTOM_RASDIALDLG and
             CUSTOM_RASENTRYDLG.
                        

Return Value:

    ERROR_SUCCESS if successful

--*/
DWORD
DwGetCustomDllEntryPoint(
        LPCTSTR     lpszPhonebook,
        LPCTSTR     lpszEntry,
        BOOL       *pfCustomDllSpecified,
        FARPROC    *pfnCustomEntryPoint,
        HINSTANCE  *phInstDll,
        DWORD      dwFnId,
        LPTSTR     pszCustomDialerName
        )
{
    DWORD       dwErr           = ERROR_SUCCESS;
    DWORD       dwSize          = sizeof(RASENTRY);
    LPTSTR      pszExpandedPath = NULL;
    BOOL        fTrusted        = FALSE;
    
    CHAR *apszFn[] = {
                         "RasCustomDialDlg",
                         "RasCustomEntryDlg",
                         "RasCustomDial",
                         "RasCustomDeleteEntryNotify"
                     };

    TRACE("DwGetCustomDllEntryPoints..");

    //
    // Initialize. This will load rasman and
    // rasapi32 dlls
    //
    dwErr = DwInitializeCustomDlg();
    
    if(ERROR_SUCCESS != dwErr)
    {
        TRACE1("Failed to load Initialize. %d",
                dwErr);
                
        goto done;                
    }

    //
    // Initialize Out parameters
    //
    *pfnCustomEntryPoint    = NULL;

    if(pfCustomDllSpecified)
    {
        *pfCustomDllSpecified   = FALSE;
    }

    if(NULL == pszCustomDialerName)
    {
        RASENTRY    re;
        RASENTRY    *pre            = &re;
        
        ZeroMemory(&re, sizeof(RASENTRY));

        //
        // Get the entry properties if customdialer is
        // not specified
        //
        re.dwSize = sizeof(RASENTRY);

        dwErr = g_pRasGetEntryProperties(
                            lpszPhonebook,
                            lpszEntry,
                            &re,
                            &dwSize,
                            NULL,
                            NULL);

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            pre = (RASENTRY *) LocalAlloc(LPTR, dwSize);

            if(NULL == pre)
            {
                dwErr = GetLastError();
                goto done;
            }

            pre->dwSize = sizeof(RASENTRY);

            dwErr = g_pRasGetEntryProperties(
                            lpszPhonebook,
                            lpszEntry,
                            pre,
                            &dwSize,
                            NULL,
                            NULL);
        }

        if(     (ERROR_SUCCESS != dwErr)
            ||  (TEXT('\0') == pre->szCustomDialDll[0]))
        {
            if(pre != &re)
            {
                LocalFree(pre);
            }

            goto done;
        }

        pszCustomDialerName = pre->szCustomDialDll;
    }

    if(pfCustomDllSpecified)
    {
        *pfCustomDllSpecified = TRUE;
    }

    //
    // Check to see if this dll is a trusted dll
    //
    dwErr = RasIsTrustedCustomDll(
                    NULL,
                    pszCustomDialerName,
                    &fTrusted);

    if(!fTrusted)
    {
        dwErr = ERROR_ACCESS_DENIED;
        goto done;
    }

    //
    // Expand the path in case it has environment variables.
    //
    dwErr = DwGetExpandedDllPath(pszCustomDialerName,
                                &pszExpandedPath);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Load the dll
    //
    if (NULL == (*phInstDll = LoadLibrary(
                                pszExpandedPath
                                )))
    {
        dwErr = GetLastError();
        
        TRACE2("LoadLibrary %ws failed. %d",
                pszCustomDialerName,
                dwErr);
                
        goto done;
    }

    //
    // Get the custom entrypoint
    //
    if(NULL == (*pfnCustomEntryPoint = GetProcAddress(
                                            *phInstDll,
                                            apszFn[dwFnId])))
    {
        dwErr = GetLastError();

        TRACE2("GetProcAddress %s failed. %d",
                apszFn[dwFnId],
                dwErr);

        goto done;                
    }

done:

    if(     ERROR_SUCCESS != dwErr
        &&  *phInstDll)
    {
        FreeLibrary(*phInstDll);
        *phInstDll = NULL;
    }

    if(NULL != pszExpandedPath)
    {
        LocalFree(pszExpandedPath);
    }

    TRACE1("DwGetCustomDllEntryPoints done. %d",
            dwErr);
            
    return dwErr;
}

DWORD
DwGetEntryMode(LPCTSTR lpszPhonebook, 
               LPCTSTR lpszEntry,
               PBFILE  *pFileIn,
               DWORD   *pdwFlags)
{
    DWORD   dwErr       = ERROR_SUCCESS;
    PBFILE  file;
    PBFILE  *pFile;
    DTLNODE *pdtlnode   = NULL;
    DWORD   dwFlags     = 0;

    if(NULL == pdwFlags)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    if(NULL != pFileIn)
    {
        pFile = pFileIn;
    }
    else
    {
        pFile = &file;
    }
    
    if(NULL == lpszPhonebook)
    {
        dwErr = GetPbkAndEntryName(lpszPhonebook,
                                   lpszEntry,
                                   0,
                                   pFile,
                                   &pdtlnode);

        if(ERROR_SUCCESS != dwErr)
        {
            goto done;
        }
        
        if(IsPublicPhonebook(pFile->pszPath))
        {
            dwFlags |= REN_AllUsers;
        }

        if(NULL == pFileIn)
        {
            ClosePhonebookFile(pFile);
        }
    }
    else if(IsPublicPhonebook(lpszPhonebook))
    {
        dwFlags |= REN_AllUsers;
    }

    *pdwFlags = dwFlags;
    
done:
    return dwErr;
}

/*++

Routine Description:

    Invokes the custom dial dlg if such a dialog is specified
    in the phonebook entry.

Arguments:

    lpszPhonebook - Semantics of this is the same as in the
                    win32 api RasDialDlg.

    lpszEntry - Semantics of this is the same as in the win32
                api RasDialDlg.

    lpPhoneNumber - Semantics of this is the same as in the
                    win32 api RasDialDlg.

    lpInfo - Semantics of this is the same as in the win32
             api RasDialDlg.

    pfStatus - Buffer to hold the result of calling the custom
               Dial Dlg. The semantics of the value stored is
               the same as the return value of the win32 api
               RasDialdlg.

Return Value:

    ERROR_SUCCESS if successful

--*/
DWORD
DwCustomDialDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPTSTR          lpszPhoneNumber,
        LPRASDIALDLG    lpInfo,
        DWORD           dwFlags,
        BOOL            *pfStatus,
        PVOID           pvInfo,
        LPTSTR          pszCustomDialerName)
{
    DWORD               dwErr               = ERROR_SUCCESS;
    HINSTANCE           hInstDll            = NULL;
    BOOL                fCustomDll;
    RasCustomDialDlgFn  pfnRasCustomDialDlg = NULL;
    CHAR                *pszPhonebookA      = NULL;
    CHAR                *pszEntryNameA      = NULL;
    PBFILE              file;
    DTLNODE             *pdtlnode           = NULL;
    DWORD               dwEntryMode         = 0;

    TRACE("DwCustomDialDlg..");

    if(     NULL == lpszEntry
        ||  TEXT('\0') == lpszEntry[0])
    {
        dwErr = E_NOINTERFACE;
        goto done;
    }
    
    //
    // Load rasman and rasapi32 dlls
    //
    dwErr = DwInitializeCustomDlg();

    if(ERROR_SUCCESS != dwErr)
    {
        lpInfo->dwError = dwErr;
        *pfStatus       = FALSE;
        dwErr           = ERROR_SUCCESS;
        
        goto done;
    }

    //
    // Get the EntryPoint
    //
    dwErr = DwGetCustomDllEntryPoint(
                        lpszPhonebook,
                        lpszEntry,    
                        &fCustomDll,
                        (FARPROC *) &pfnRasCustomDialDlg,
                        &hInstDll,
                        CUSTOM_RASDIALDLG,
                        pszCustomDialerName);

    if(     ERROR_SUCCESS != dwErr
        &&  fCustomDll)
    {
        //
        // Custom dll was specified for this 
        // entry but something else failed.
        //
        lpInfo->dwError = dwErr;
        *pfStatus       = FALSE;
        dwErr           = ERROR_SUCCESS;

        goto done;
    }
    else if (!fCustomDll)
    {
        dwErr = E_NOINTERFACE;
        
        goto done;
    }

    ASSERT(NULL != pfnRasCustomDialDlg);

    dwErr = DwGetEntryMode(lpszPhonebook,
                           lpszEntry,
                           &file,
                           &dwEntryMode);

    if(ERROR_SUCCESS != dwErr)
    {
        lpInfo->dwError = dwErr;
        *pfStatus       = FALSE;
        dwErr           = ERROR_SUCCESS;

        goto done;
    }

    dwFlags |= dwEntryMode;

    pszPhonebookA = StrDupAFromT((NULL == lpszPhonebook)
                                 ? file.pszPath
                                 : lpszPhonebook);

    if(NULL == lpszPhonebook)
    {
        ClosePhonebookFile(&file);                                     
    }

    pszEntryNameA = StrDupAFromT(lpszEntry);                                  

    if(     NULL == pszPhonebookA
        ||  NULL == pszEntryNameA)
    {
        *pfStatus       = FALSE;
        lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
        dwErr           = ERROR_SUCCESS;
        
        goto done;
    }
    
    //
    // Call the entry point. After this point dwErr
    // returned should always be ERROR_SUCCESS, Since
    // this means CustomDialDlg was handled and any
    // error will be returned via the fStatus and
    // lpInfo->dwError pair.
    //
    *pfStatus = (pfnRasCustomDialDlg) (
                            hInstDll,
                            dwFlags,
                            lpszPhonebook,
                            lpszEntry,
                            lpszPhoneNumber,
                            lpInfo,
                            pvInfo);

    if(*pfStatus)
    {
        //
        // Mark this connection as being connected
        // through custom dialing
        //
        dwErr = g_pRasReferenceCustomCount((HCONN) NULL,
                                           TRUE,
                                           pszPhonebookA,
                                           pszEntryNameA,
                                           NULL);

        if(ERROR_SUCCESS != dwErr)
        {
            TRACE1("RasReferenceCustomCount failed. %d",
                   dwErr);
                   
            *pfStatus       = FALSE;
            lpInfo->dwError = dwErr;
            dwErr           = ERROR_SUCCESS;
            
            goto done;
        }
    }
                            
done:

    if(NULL != hInstDll)
    {
        FreeLibrary(hInstDll);           
    }

    if(NULL != pszPhonebookA)
    {
        Free(pszPhonebookA);
    }

    if(NULL != pszEntryNameA)
    {
        Free(pszEntryNameA);
    }

    TRACE1("DwCustomDialDlg done. %d",
           dwErr);

    return dwErr;
    
}

/*++

Routine Description:

    Invokes the Custom EntryDlg if such a dialog is specified
    in the RasPhonebookEntry

Arguments:

    lpszPhonebook - Semantics of this is the same as the win32
                    api RasEntryDlg

    lpszEntry - Semantics of this is the same as the win32 api
                RasEntryDlg

    lpInfo - Semantics of this is the same as the win32 api
             RasEntryDlg.

    pfStatus - Buffer to hold the result of calling the custom
               Entry Point. The semantics of the value returned
               in this buffer is the same as the return value
               of the win32 api RasEntryDlg.

Return Value:

    ERROR_SUCCESS if successful

--*/
DWORD
DwCustomEntryDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPRASENTRYDLG   lpInfo,
        BOOL            *pfStatus)
{
    DWORD               dwErr                = ERROR_SUCCESS;
    HINSTANCE           hInstDll             = NULL;
    BOOL                fCustomDll           = FALSE;
    RasCustomEntryDlgFn pfnRasCustomEntryDlg = NULL;
    DWORD               dwFlags              = REN_User;

    TRACE("DwCustomEntryDlg..");

    if(     NULL == lpszEntry
        ||  TEXT('\0') == lpszEntry[0])
    {
        dwErr = E_NOINTERFACE;
        goto done;
    }

    //
    // Get the EntryPoint
    //
    dwErr = DwGetCustomDllEntryPoint(
                            lpszPhonebook,
                            lpszEntry,
                            &fCustomDll,
                            (FARPROC *) &pfnRasCustomEntryDlg,
                            &hInstDll,
                            CUSTOM_RASENTRYDLG,
                            NULL);

    if(     ERROR_SUCCESS != dwErr
        &&  fCustomDll)
    {
        //
        // Custom dll was specified for this 
        // entry but something else failed.
        //
        lpInfo->dwError = dwErr;
        *pfStatus       = FALSE;
        dwErr           = ERROR_SUCCESS;

        goto done;
    }
    else if (!fCustomDll)
    {
        dwErr = E_NOINTERFACE;

        goto done;
    }

    ASSERT(NULL != pfnRasCustomEntryDlg);

    dwErr = DwGetEntryMode(lpszPhonebook,
                           lpszEntry,
                           NULL,
                           &dwFlags);

    if(ERROR_SUCCESS != dwErr)
    {
        //
        // Custom dll was specified for this 
        // entry but something else failed.
        //
        lpInfo->dwError = dwErr;
        *pfStatus       = FALSE;
        dwErr           = ERROR_SUCCESS;

        goto done;
    }

    //
    // Call the entry point. After this point dwErr
    // returned should always be ERROR_SUCCESS, Since
    // this means CustomDialDlg was handled and any
    // error will be returned via the fStatus and
    // lpInfo->dwError pair.
    //
    *pfStatus = (pfnRasCustomEntryDlg) (
                                hInstDll,
                                lpszPhonebook,
                                lpszEntry,
                                lpInfo,
                                dwFlags);

done:

    if(NULL != hInstDll)
    {
        FreeLibrary(hInstDll);
    }

    TRACE1("DwCustomEntryDlg done. %d",
            dwErr);
            
    return dwErr;
}

DWORD
DwCustomDeleteEntryNotify(
        LPCTSTR          pszPhonebook,
        LPCTSTR          pszEntry,
        LPTSTR           pszCustomDialerName)
{
    DWORD dwErr = NO_ERROR;
    RasCustomDeleteEntryNotifyFn pfnCustomDeleteEntryNotify;
    HINSTANCE hInstDll = NULL;
    BOOL fCustomDll;
    DWORD dwFlags = 0;
    
    if(     NULL == pszEntry
        ||  TEXT('\0') == pszEntry[0])
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    //
    // Get the EntryPoint
    //
    dwErr = DwGetCustomDllEntryPoint(
                            pszPhonebook,
                            pszEntry,
                            &fCustomDll,
                            (FARPROC *) &pfnCustomDeleteEntryNotify,
                            &hInstDll,
                            CUSTOM_RASDELETEENTRYNOTIFY,
                            pszCustomDialerName);

    if(NO_ERROR != dwErr)
    {
        goto done;
    }

    dwErr = DwGetEntryMode(pszPhonebook,
                           pszEntry,
                           NULL,
                           &dwFlags);

    if(NO_ERROR != dwErr)
    {
        goto done;
    }

    dwErr = pfnCustomDeleteEntryNotify(
                        pszPhonebook,
                        pszEntry,
                        dwFlags);
done:

    if(NULL != hInstDll)
    {
        FreeLibrary(hInstDll);
    }
    
    return dwErr;
}

DWORD
DwCustomTerminalDlg(TCHAR *pszPhonebook,
                    HRASCONN hrasconn,
                    PBENTRY *pEntry,
                    HWND hwndDlg,
                    RASDIALPARAMS *prdp,
                    PVOID pvReserved)
{
    DWORD retcode = SUCCESS;
    HPORT hport;
    CHAR szCustomScriptDll[MAX_PATH + 1];
    HINSTANCE hInst = NULL;
    RasCustomScriptExecuteFn fnCustomScript;
    RASCUSTOMSCRIPTEXTENSIONS rcse;

    hport = g_pRasGetHport(hrasconn);

    if(INVALID_HPORT == hport)
    {
        TRACE("DwCustomTermianlDlg: RasGetHport retured INVALID_HPORT");
        retcode = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    //
    // Get the custom script dll from rasman
    //
    retcode = RasGetCustomScriptDll(szCustomScriptDll);

    if(ERROR_SUCCESS != retcode)
    {
        TRACE1(
            "DwCustomTerminalDlg: RasGetCustomScriptDll "
            "returned 0x%x",
            retcode);
            
        goto done;
    }

    //
    // Load the 3rd party dll
    //
    hInst = LoadLibraryA(szCustomScriptDll);

    if(NULL == hInst)
    {   
        retcode = GetLastError();
        TRACE2(
            "DwCustomTerminalDlg: couldn't load %s. 0x%x",
            szCustomScriptDll,
            retcode);
        
        goto done;
    }

    //
    // Get the exported function pointer
    //
    fnCustomScript = (RasCustomScriptExecuteFn) GetProcAddress(
                        hInst,
                        "RasCustomScriptExecute");

    if(NULL == fnCustomScript)
    {
        retcode = GetLastError();
        TRACE1(
            "DwCustomTerminalDlg: GetprocAddress failed 0x%x",
            retcode);
            
        goto done;
    }

    ZeroMemory(&rcse, sizeof(RASCUSTOMSCRIPTEXTENSIONS));

    rcse.dwSize = sizeof(RASCUSTOMSCRIPTEXTENSIONS);
    rcse.pfnRasSetCommSettings = RasSetCommSettings;

    //
    // Call the function
    //
    retcode = (DWORD) fnCustomScript(
                hport,
                pszPhonebook,
                pEntry->pszEntryName,
                g_pRasGetBuffer,
                g_pRasFreeBuffer,
                g_pRasPortSend,
                g_pRasPortReceive,
                g_pRasPortReceiveEx,
                hwndDlg,
                prdp,
                &rcse);

    TRACE1(
        "DwCustomTerminalDlg: fnCustomScript returned 0x%x",
        retcode);

done:

    if(NULL != hInst)
    {
        FreeLibrary(hInst);
    }

    return retcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\rnk\rnk.c ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** rnk.c
** Remote Access shortcut file (.RNK) library
**
** 02/15/96 Steve Cobb
*/

#include <windows.h>   // Win32 core
#include <debug.h>     // TRACE/ASSERT macros
#include <nouiutil.h>  // Heap macros
#include <rnk.h>       // Our public header


VOID
FreeRnkInfo(
    IN RNKINFO* pInfo )

    /* Destroys 'pInfo' buffer returned from ReadShortcutFile.
    */
{
    if (pInfo)
    {
        Free0( pInfo->pszEntry );
        Free0( pInfo->pszPhonebook );
        Free( pInfo );
    }
}


RNKINFO*
ReadShortcutFile(
    IN TCHAR* pszRnkPath )

    /* Reads shortcut file at 'pszRnkPath' returning a RNKINFO buffer.  Caller
    ** should eventually call FreeRnkInfo on the returned buffer.
    **
    ** Returns 0 or an error code.
    */
{
    RNKINFO* pInfo;
    TCHAR    szBuf[ 1024 ];

    TRACE("ReadShortcutFile");

    pInfo = (RNKINFO* )Malloc( sizeof(RNKINFO) );
    if (!pInfo)
        return NULL;

    ZeroMemory( pInfo, sizeof(*pInfo) );

    GetPrivateProfileString( TEXT(RNK_SEC_Main), TEXT(RNK_KEY_Entry),
        TEXT(""), szBuf, sizeof(szBuf) / sizeof(TCHAR), pszRnkPath );
    pInfo->pszEntry = StrDup( szBuf );

    GetPrivateProfileString( TEXT(RNK_SEC_Main), TEXT(RNK_KEY_Phonebook),
        TEXT(""), szBuf, sizeof(szBuf) / sizeof(TCHAR), pszRnkPath );
    pInfo->pszPhonebook = StrDup( szBuf );

    return pInfo;
}



DWORD
WriteShortcutFile(
    IN TCHAR* pszRnkPath,
    IN TCHAR* pszPbkPath,
    IN TCHAR* pszEntry )

    /* Write the shortcut file 'pszRnkPath' with a command line to dial entry
    ** 'pszEntry' from phonebook 'pszPath'.
    **
    ** Returns 0 if succesful or an error code.
    */
{
    DWORD  dwErr;
    HANDLE hFile;
    CHAR*  pszRnkPathA;
    CHAR*  pszEntryA;
    CHAR*  pszPbkPathA;

    TRACE("WriteShortcutFile");

    /* The file is written in ANSI to
    ** avoid potential portability/compatibility problems with Windows 95.
    */
    dwErr = 0;

    pszRnkPathA = StrDupAFromT( pszRnkPath );
    if (!pszRnkPathA)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        hFile = CreateFileA( pszRnkPathA, GENERIC_WRITE, 0, NULL,
                    CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

        if (hFile == INVALID_HANDLE_VALUE)
        {
            dwErr = GetLastError();
        }
        else
        {
            CloseHandle( hFile );

            pszEntryA = StrDupAFromT( pszEntry );
            pszPbkPathA = StrDupAFromT( pszPbkPath );

            if (!pszEntryA || !pszPbkPathA)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                BOOL  f;
                CHAR  szBuf[ (2 * MAX_PATH) + 100 ];
                CHAR* pszKey;

                ZeroMemory( szBuf, sizeof(szBuf) );

                pszKey = szBuf;
                wsprintfA( pszKey, "%s=%s",
                    RNK_KEY_Entry, pszEntryA );

                pszKey += lstrlenA( pszKey ) + 1;
                wsprintfA( pszKey, "%s=%s",
                    RNK_KEY_Phonebook, pszPbkPathA );

                f = WritePrivateProfileSectionA(
                        RNK_SEC_Main, szBuf, pszRnkPathA );
                if (!f)
                    dwErr = GetLastError();
            }

            Free0( pszPbkPathA );
            Free0( pszEntryA );
        }

        Free( pszRnkPathA );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\phonenum\phonenum.c ===
// Copyright (c) 1996, Microsoft Corporation, all rights reserved
//
// phonenum.c
// Phone number helper library
// Listed alphabetically
//
// 03/06/96 Steve Cobb


#include <windows.h>  // Win32 root
#include <nouiutil.h> // No-HWND utilities
#include <tapiutil.h> // TAPI wrappers
#include <phonenum.h> // Our public header
#include <debug.h>    // Trace/Assert library


TCHAR*
LinkPhoneNumberFromParts(
    IN HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN PBUSER* pUser,
    IN PBENTRY* pEntry,
    IN PBLINK* pLink,
    IN DWORD iPhoneNumber,
    IN TCHAR* pszOverrideNumber,
    IN BOOL fDialable )

    // Like PhoneNumberFromParts but takes a link and hunt group index as
    // input instead of a base number, and handles not modifying the number
    // associated with non-modem/ISDN links.  If 'pszOverrideNumber' is
    // non-NULL and non-"" it is used instead of the derived number.
    //
{
    DTLNODE* pNode;
    TCHAR* pszBaseNumber;
    PBPHONE* pPhone;

    if (pszOverrideNumber && *pszOverrideNumber)
    {
        // So, this is useful?  RaoS?
        //
        return StrDup( pszOverrideNumber );
    }

    pNode = DtlNodeFromIndex( pLink->pdtllistPhones, iPhoneNumber );
    if (!pNode)
    {
        ASSERT( FALSE );
        return NULL;
    }

    pPhone = (PBPHONE *) DtlGetData(pNode);
    ASSERT( pPhone );

    if (pLink->pbport.pbdevicetype == PBDT_Modem
        || pLink->pbport.pbdevicetype == PBDT_Isdn)
    {
        BOOL fDownLevelIsdn;

        fDownLevelIsdn =
            (pLink->pbport.pbdevicetype == PBDT_Isdn
             && pLink->fProprietaryIsdn);

        return PhoneNumberFromParts(
            hInst, pHlineapp, pUser, pPhone, fDownLevelIsdn, fDialable );
    }
    else
    {
        return StrDup( pPhone->pszPhoneNumber );
    }
}


TCHAR*
PhoneNumberFromParts(
    IN HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN PBUSER* pUser,
    IN PBPHONE* pPhone,
    IN BOOL fDownLevelIsdn,
    IN BOOL fDialable )

    // Returns a heap block containing the composite phone number using the
    // rules of 'pPhone' and 'pUser'.  'HInst' is the module handle.
    // 'PHlineapp' is the TAPI context.  'FDialable' indicates the dialable
    // string, instead of the displayable string, should be returned.
    //
    // It is caller's responsibility to Free the returned string.
    //
{
    TCHAR* pszResult;
    TCHAR* pszBaseNumber;

    TRACE( "PhoneNumberFromParts" );

    pszBaseNumber = pPhone->pszPhoneNumber;
    if (!pszBaseNumber)
    {
        pszBaseNumber = TEXT("");
    }

    if (pPhone->fUseDialingRules)
    {
        pszResult =
            PhoneNumberFromTapiPartsEx( hInst, pszBaseNumber,
                pPhone->pszAreaCode, pPhone->dwCountryCode, fDownLevelIsdn,
                pHlineapp, fDialable );
    }
    else
    {
        TCHAR* pszPrefix;
        TCHAR* pszSuffix;

        PrefixSuffixFromLocationId( pUser,
            GetCurrentLocation( hInst, pHlineapp ),
            &pszPrefix, &pszSuffix );

        pszResult =
            PhoneNumberFromPrefixSuffixEx(
                pszBaseNumber, pszPrefix, pszSuffix, fDownLevelIsdn );

        Free0( pszPrefix );
        Free0( pszSuffix );
    }

    if (!pszResult)
    {
        TRACE( "!Phone#" );
        pszResult = StrDup( pszBaseNumber );
    }

    return pszResult;
}


TCHAR*
PhoneNumberFromPrefixSuffix(
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszPrefix,
    IN TCHAR* pszSuffix )

    // Returns a heap block containing the composite phone number comprised of
    // prefix 'pszPrefix', base phone number 'pszBaseNumber', and suffix
    // 'pszSuffix', or NULL if the composite number is too long or on a memory
    // error.
    //
    // It is caller's responsibility to Free the returned string.
    //
{
    TCHAR* pszResult;
    DWORD  cch;

    TRACE( "PhoneNumberFromPrefixSuffix" );

    pszResult = NULL;

    if (!pszBaseNumber)
    {
        pszBaseNumber = TEXT("");
    }
    if (!pszPrefix)
    {
        pszPrefix = TEXT("");
    }
    if (!pszSuffix)
    {
        pszSuffix = TEXT("");
    }

    cch = lstrlen( pszPrefix ) + lstrlen( pszBaseNumber ) + lstrlen( pszSuffix );
    if (cch > RAS_MaxPhoneNumber)
    {
        return NULL;
    }

    pszResult = Malloc( (cch + 1) * sizeof(TCHAR) );
    if (pszResult)
    {
        *pszResult = TEXT('\0');
        lstrcat( pszResult, pszPrefix );
        lstrcat( pszResult, pszBaseNumber );
        lstrcat( pszResult, pszSuffix );
    }

    return pszResult;
}


TCHAR*
PhoneNumberFromPrefixSuffixEx(
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszPrefix,
    IN TCHAR* pszSuffix,
    IN BOOL fDownLevelIsdn )

    // Returns a heap block containing the composite phone number comprised of
    // prefix 'pszPrefix', base phone number 'pszBaseNumber', and suffix
    // 'pszSuffix', or NULL if the composite number is too long or on a memory
    // error.
    //
    // If 'fDownLevelIsdn' is set colons are recognized as separaters with
    // each colon separated token built treated separately.
    //
    // It is caller's responsibility to Free the returned string.
    //
{
    TCHAR* psz;
    TCHAR* pszResult;
    INT cchResult;

    TRACE( "PhoneNumberFromPrefixSuffixEx" );

    if (fDownLevelIsdn)
    {
        TCHAR* pszNum;
        TCHAR* pszS;
        TCHAR* pszE;

        pszResult = StrDup( TEXT("") );

        for (pszS = pszE = pszBaseNumber;
             *pszE != TEXT('\0');
             pszE = CharNext( pszE ))
        {
            if (*pszE == TEXT(':'))
            {
                *pszE = TEXT('\0');

                pszNum =
                    PhoneNumberFromPrefixSuffix(
                        pszS, pszPrefix, pszSuffix );

                *pszE = TEXT(':');

                if (pszNum)
                {
                    if (pszResult)
                        cchResult = lstrlen( pszResult );

                    psz = Realloc( pszResult,
                        (cchResult + lstrlen( pszNum ) + 2) * sizeof(TCHAR) );

                    if (!psz)
                    {
                        Free0( pszResult );
                        Free( pszNum );
                        return NULL;
                    }

                    pszResult = psz;
                    lstrcat( pszResult, pszNum );
                    lstrcat( pszResult, TEXT(":") );
                    Free( pszNum );
                }

                pszS = CharNext( pszE );
            }
        }

        {
            pszNum =
                PhoneNumberFromPrefixSuffix(
                    pszS, pszPrefix, pszSuffix );

            if (pszNum)
            {
                if (pszResult)
                    cchResult = lstrlen( pszResult );

                psz = Realloc( pszResult,
                    (cchResult + lstrlen( pszNum ) + 1) * sizeof(TCHAR) );

                if (!psz)
                {
                    Free0( pszResult );
                    Free( pszNum );
                    return NULL;
                }

                pszResult = psz;
                lstrcat( pszResult, pszNum );
                Free( pszNum );
            }
        }
    }
    else
    {
        pszResult =
            PhoneNumberFromPrefixSuffix(
                pszBaseNumber, pszPrefix, pszSuffix );
    }

    if (pszResult && (lstrlen( pszResult ) > RAS_MaxPhoneNumber ))
    {
        Free( pszResult );
        return NULL;
    }

    return pszResult;
}


TCHAR*
PhoneNumberFromTapiParts(
    IN HINSTANCE hInst,
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszAreaCode,
    IN DWORD dwCountryCode,
    IN OUT HLINEAPP* pHlineapp,
    IN BOOL fDialable )

    // Returns a heap block containing the composite phone number comprised of
    // base phone number 'pszBaseNumber', area code 'pszAreaCode', and country
    // code 'dwCountryCode, or NULL if the composite number is too long or on
    // a memory error.  'HInst' is the module instance handle.  '*PHlineapp'
    // is the address of the TAPI context.  'FDialable' indicates the dialable
    // string, as opposed to the displayable string, should be returned.
    //
    // It is caller's responsibility to Free the returned string.
    //
{
    TCHAR* pszResult;

    TRACE( "PhoneNumberFromTapiParts" );

    pszResult = NULL;

    TapiTranslateAddress(
        hInst, pHlineapp, dwCountryCode, pszAreaCode, pszBaseNumber,
        0, fDialable, &pszResult );

    return pszResult;
}


TCHAR*
PhoneNumberFromTapiPartsEx(
    IN HINSTANCE hInst,
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszAreaCode,
    IN DWORD dwCountryCode,
    IN BOOL fDownLevelIsdn,
    IN OUT HLINEAPP* pHlineapp,
    IN BOOL fDialable )

    // Returns  heap block containing the composite phone number comprised of
    // base phone number 'pszBaseNumber', area code 'pszAreaCode', and country
    // code 'dwCountryCode or NULL if the composite number is too long or on a
    // memory error.  'HInst' is the module instance handle.  '*PHlineapp' is
    // the address of the TAPI context.  'FDialable' indicates the dialable
    // string, as opposed to the displayable string, should be returned.
    //
    // If 'fDownLevelIsdn' is set colons are recognized as separaters with
    // each colon separated token built treated separately.
    //
    // It is caller's responsibility to Free the returned string.
    //
{
    TCHAR* psz;
    TCHAR* pszResult;
    INT cchResult;

    TRACE( "PhoneNumberFromTapiPartsEx" );

    if (fDownLevelIsdn)
    {
        TCHAR* pszNum;
        TCHAR* pszS;
        TCHAR* pszE;

        pszResult = StrDup( TEXT("") );

        for (pszS = pszE = pszBaseNumber;
             *pszE != TEXT('\0');
             pszE = CharNext( pszE ))
        {
            if (*pszE == TEXT(':'))
            {
                *pszE = TEXT('\0');

                pszNum = PhoneNumberFromTapiParts(
                    hInst, pszS, pszAreaCode, dwCountryCode, pHlineapp, fDialable );

                *pszE = TEXT(':');

                if (pszNum)
                {
                    if (pszResult)
                    {
                        cchResult = lstrlen( pszResult );
                    }

                    psz = Realloc( pszResult,
                        (cchResult + lstrlen( pszNum ) + 2) * sizeof(TCHAR) );

                    if (!psz)
                    {
                        Free0( pszResult );
                        Free( pszNum );
                        return NULL;
                    }

                    pszResult = psz;
                    lstrcat( pszResult, pszNum );
                    lstrcat( pszResult, TEXT(":") );
                    Free( pszNum );
                }

                pszS = CharNext( pszE );
            }
        }

        {
            pszNum = PhoneNumberFromTapiParts(
                hInst, pszS, pszAreaCode, dwCountryCode, pHlineapp, fDialable );

            if (pszNum)
            {
                if (pszResult)
                {
                    cchResult = lstrlen( pszResult );
                }

                psz = Realloc( pszResult,
                    (cchResult + lstrlen( pszNum ) + 1) * sizeof(TCHAR) );

                if (!psz)
                {
                    Free0( pszResult );
                    Free( pszNum );
                    return NULL;
                }

                pszResult = psz;
                lstrcat( pszResult, pszNum );
                Free( pszNum );
            }
        }
    }
    else
    {
        pszResult = PhoneNumberFromTapiParts(
            hInst, pszBaseNumber, pszAreaCode, dwCountryCode, pHlineapp,
            fDialable );
    }

    if (pszResult && (lstrlen( pszResult ) > RAS_MaxPhoneNumber ))
    {
        Free( pszResult );
        return NULL;
    }

    return pszResult;
}


VOID
PrefixSuffixFromLocationId(
    IN PBUSER* pUser,
    IN DWORD dwLocationId,
    OUT TCHAR** ppszPrefix,
    OUT TCHAR** ppszSuffix )

    // Retrieve the prefix and suffix strings, '*ppszPrefix' and '*ppszSuffix'
    // associated with TAPI location 'dwLocationId'.  'PUser' is the user
    // preferences from which to retrieve.
    //
    // It is caller's responsibility to Free the returned strings.
    //
{
#if 0 // NT4-style

    DTLNODE* pNode;
    INT iPrefix;
    INT iSuffix;

    TRACE( "PrefixSuffixFromLocationId" );

    iPrefix = iSuffix = 0;
    for (pNode = DtlGetFirstNode( pUser->pdtllistLocations );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        LOCATIONINFO* p = (LOCATIONINFO* )DtlGetData( pNode );
        ASSERT( p );

        if (p->dwLocationId == dwLocationId)
        {
            iPrefix = p->iPrefix;
            iSuffix = p->iSuffix;
            break;
        }
    }

    *ppszPrefix = NULL;
    if (iPrefix != 0)
    {
        pNode = DtlNodeFromIndex( pUser->pdtllistPrefixes, iPrefix - 1 );
        if (pNode)
        {
            *ppszPrefix = StrDup( (TCHAR* )DtlGetData( pNode ) );
        }
    }

    *ppszSuffix = NULL;
    if (iSuffix != 0)
    {
        pNode = DtlNodeFromIndex( pUser->pdtllistSuffixes, iSuffix - 1 );
        if (pNode)
        {
            *ppszSuffix = StrDup( (TCHAR* )DtlGetData( pNode ) );
        }
    }

#else // Stubbed in NT5/Connections

    *ppszPrefix = StrDup( TEXT("") );
    *ppszSuffix = StrDup( TEXT("") );

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\sharing\precomp.h ===
#define COBJMACROS
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <netcon.h>
#include <hnetcfg.h>
#include <ras.h>
#include <rasuip.h>
#include <raserror.h>
#include <iprtrmib.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <debug.h>
#include <nouiutil.h>
#include <sainfo.h>
#include "sharing.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\sharing\api.c ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    api.c

Abstract:

    This module contains code for the API routines which support connection
    sharing.

Author:

    Abolade Gbadegesin  (aboladeg)  22-Apr-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <netconp.h>
#include <routprot.h>
#include <mprapip.h>

const WCHAR c_szNetmanDll[] = L"NETMAN.DLL";
const WCHAR c_szSharedAutoDial[] = L"SharedAutoDial";


DWORD
APIENTRY
RasAutoDialSharedConnection(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to attempt to connect the shared connection.
    It returns before the connection is completed, having signalled
    the autodial service to perform the connection.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    HANDLE Event;

    TRACE("RasAutoDialSharedConnection");

    Event =
        OpenEventA(
            SYNCHRONIZE|EVENT_MODIFY_STATE,
            FALSE,
            RAS_AUTO_DIAL_SHARED_CONNECTION_EVENT
            );
    if (!Event) {
        Error = GetLastError();
        TRACE1("RasAutoDialSharedConnection: OpenEvent=%d", Error);
        return Error;
    }

    //
    // Signal the event
    //

    Error = (SetEvent(Event) ? NO_ERROR : GetLastError());
    if (Error) { TRACE1("RasAutoDialSharedConnection: SetEvent=%d", Error); }

    CloseHandle(Event);
    return Error;

} // RasAutoDialSharedConnection


DWORD
APIENTRY
RasIsSharedConnection (
    IN LPRASSHARECONN pConn,
    OUT PBOOL pfShared
    )

/*++

Routine Description:

    This routine attempts to determine whether or not the given connection
    is currently the shared connection.

Arguments:

    pConn - the connection to be examined

    pfShared - receives 'TRUE' if connection is found to be shared,
        and 'FALSE' otherwise.

Return Value:

    DWORD - Win32 status code.

--*/

{
    ULONG Error;
    BOOLEAN Shared;
    TRACE("RasIsSharedConnection");
 
    if (!pfShared) { return ERROR_INVALID_PARAMETER; }
    if (Error = CsInitializeModule()) { return Error; }
    
    Error = CsIsSharedConnection(pConn, &Shared);
    if (!Error) { *pfShared = (Shared ? TRUE : FALSE); }

    return Error;

} // RasIsSharedConnection


DWORD
APIENTRY
RasQuerySharedAutoDial(
    IN PBOOL pfEnabled
    )

/*++

Routine Description:

    This routine retrieves the autodial-setting for shared connections
    from the registry.

Arguments:

    pfEnabled - receives the autodial-setting

Return Value:

    DWORD - Win32 status code.

--*/

{
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    HANDLE Key;
    NTSTATUS status;
    TRACE("RasQuerySharedAutoDial");

    *pfEnabled = TRUE;

    //
    // Bypass initialization, since this is just a registry access.
    //

    status = CsOpenKey(&Key, KEY_READ, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(status)) {
        TRACE1("RasQuerySharedAutoDial: NtOpenKey=%x", status);
        return RtlNtStatusToDosError(status);
    }

    //
    // Read the 'SharedAutoDial' value
    //

    status = CsQueryValueKey(Key, c_szSharedAutoDial, &Information);
    NtClose(Key);
    if (NT_SUCCESS(status)) {
        if (!*(PULONG)Information->Data) { *pfEnabled = FALSE; }
        Free(Information);
    }

    return NO_ERROR;

} // RasQuerySharedAutoDial


DWORD
APIENTRY
RasQuerySharedConnection(
    OUT LPRASSHARECONN pConn
    )

/*++

Routine Description:

    This routine is invoked to retrieve the name of the connection
    that is currently shared, if any.

Arguments:

    pConn - receives information about the shared connection, if any

Return Value:

    DWORD - Win32 status code.

--*/

{
    ULONG Error;
    TRACE("RasQuerySharedConnection");

    if (Error = CsInitializeModule()) { return Error; }
    return CsQuerySharedConnection(pConn);
} // RasQuerySharedConnection


DWORD
APIENTRY
RasSetSharedAutoDial(
    IN BOOL fEnable
    )

/*++

Routine Description:

    This routine sets the autodial-setting for shared connections
    in the registry.

Arguments:

    fEnable - contains the new autodial-setting

Return Value:

    DWORD - Win32 status code.

--*/

{
    HANDLE Key;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;
    ULONG Value;
    TRACE("RasSetSharedAutoDial");

    //
    // Bypass initialization, since this is just a registry access.
    //

    status = CsOpenKey(&Key, KEY_ALL_ACCESS, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(status)) {
        TRACE1("RasSetSharedAutoDial: CsOpenKey=%x", status);
        return RtlNtStatusToDosError(status);
    }

    //
    // Install the new 'SharedAutoDial' value
    //

    RtlInitUnicodeString(&UnicodeString, c_szSharedAutoDial);
    Value = !!fEnable;
    status =
        NtSetValueKey(
            Key,
            &UnicodeString,
            0,
            REG_DWORD,
            &Value,
            sizeof(Value)
            );
    NtClose(Key);
    CsControlService(IPNATHLP_CONTROL_UPDATE_AUTODIAL);
    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // RasSetSharedAutoDial
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\sharing\sharing.c ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    sharing.c

Abstract:

    This module contains code for routines which support connection sharing
    configuration.

    Connection sharing involves a public (internet) interface, ordinarily
    a dialup interface identified by phonebook/entry-name, as well as
    a private (home) interface, required to be a lan interface.

    On setting up connection sharing, the service is enabled if necessary,
    and the private lan interface is configured with static address 169.254.0.1
    via the TCP/IP 'SetAdapterIpAddress' API routine.

    The name of the shared connection is stored in the registry along with
    the GUID of the shared private LAN connection, under the registry key
    HKLM\Software\Microsoft\SharedAccess\Parameters.

    N.B. NT registry routines are used, to avoid the hit incurred by
    going through the Win32 server.

Author:

    Abolade Gbadegesin  (aboladeg)  22-Apr-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#define _PNP_POWER_
#include <ndispnp.h>
#include <ntddip.h>
#include <winsock2.h>
#include <dhcpcapi.h>
#include <netconp.h>

#if 0

//
// Structure:   CS_ADDRESS_INFORMATION
//

typedef struct _CS_ADDRESS_INFORMATION {
    PKEY_VALUE_PARTIAL_INFORMATION IPAddress;
    PKEY_VALUE_PARTIAL_INFORMATION SubnetMask;
    PKEY_VALUE_PARTIAL_INFORMATION DefaultGateway;
    PKEY_VALUE_PARTIAL_INFORMATION EnableDHCP;
} CS_ADDRESS_INFORMATION, *PCS_ADDRESS_INFORMATION;

//
// DHCPCSVC.DLL import prototype
//

typedef DWORD
(APIENTRY* PDHCPNOTIFYCONFIGCHANGE)(
    LPWSTR,
    LPWSTR,
    BOOL,
    DWORD,
    DWORD,
    DWORD,
    SERVICE_ENABLE
    );

#endif

//
// OLE entrypoints loaded dynamically
//

PCOINITIALIZEEX g_pCoInitializeEx;
PCOUNINITIALIZE g_pCoUninitialize;
PCOCREATEINSTANCE g_pCoCreateInstance;
PCOSETPROXYBLANKET g_pCoSetProxyBlanket;
PCOTASKMEMFREE g_pCoTaskMemFree;

//
// CONSTANT DEFINITIONS
//

#if 0
const CHAR c_szAllocateAndGetIpAddrTableFromStack[] =
    "AllocateAndGetIpAddrTableFromStack";
#endif
const CHAR c_szCoInitializeEx[] = "CoInitializeEx";
const CHAR c_szCoUninitialize[] = "CoUninitialize";
const CHAR c_szCoCreateInstance[] = "CoCreateInstance";
const CHAR c_szCoSetProxyBlanket[] = "CoSetProxyBlanket";
const CHAR c_szCoTaskMemFree[] = "CoTaskMemFree";
#if 0
const CHAR c_szDhcpNotifyConfigChange[] = "DhcpNotifyConfigChange";
const CHAR c_szGetInterfaceInfo[] = "GetInterfaceInfo";
#endif
const CHAR c_szMprConfigBufferFree[] = "MprConfigBufferFree";
const CHAR c_szMprConfigServerConnect[] = "MprConfigServerConnect";
const CHAR c_szMprConfigServerDisconnect[] = "MprConfigServerDisconnect";
const CHAR c_szMprConfigTransportGetHandle[] = "MprConfigTransportGetHandle";
const CHAR c_szMprConfigTransportGetInfo[] = "MprConfigTransportGetInfo";
const CHAR c_szMprInfoBlockFind[] = "MprInfoBlockFind";
#if 0
const CHAR c_szSetAdapterIpAddress[] = "SetAdapterIpAddress";
#endif
const TCHAR c_szSharedAccess[] = TEXT("SharedAccess");
#if 0
const WCHAR c_szBackupDefaultGateway[] = L"BackupDefaultGateway";
const WCHAR c_szBackupEnableDHCP[] = L"BackupEnableDHCP";
const WCHAR c_szBackupIPAddress[] = L"BackupIPAddress";
const WCHAR c_szBackupSubnetMask[] = L"BackupSubnetMask";
const WCHAR c_szDefaultGateway[] = L"DefaultGateway";
const WCHAR c_szDevice[] = L"\\Device\\";
const WCHAR c_szDhcpcsvcDll[] = L"DHCPCSVC.DLL";
const WCHAR c_szEmpty[] = L"";
const WCHAR c_szEnableDHCP[] = L"EnableDHCP";
const WCHAR c_szInterfaces[] = L"Interfaces";
const WCHAR c_szIPAddress[] = L"IPAddress";
const WCHAR c_szIphlpapiDll[] = L"IPHLPAPI.DLL";
#endif
const WCHAR c_szMprapiDll[] = L"MPRAPI.DLL";
const WCHAR c_szMsTcpip[] = L"MS_TCPIP";
const WCHAR c_szOle32Dll[] = L"OLE32.DLL";
#if 0
const WCHAR c_szScopeAddress[] = L"ScopeAddress";
const WCHAR c_szScopeMask[] = L"ScopeMask";
#endif
const WCHAR c_szSharedAccessParametersKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\SharedAccess"
    L"\\Parameters";
#if 0
const WCHAR c_szSharedConnection[] = L"SharedConnection";
const WCHAR c_szSharedPrivateLan[] = L"SharedPrivateLan";
const WCHAR c_szSubnetMask[] = L"SubnetMask";
const WCHAR c_szTcpip[] = L"Tcpip";
const WCHAR c_szTcpipParametersKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip"
    L"\\Parameters";
const WCHAR c_szFirewallConnection[] = L"FirewallConnection";
const WCHAR c_szFirewallConnectionCount[] = L"FirewallConnectionCount";
#endif

//
// LOCAL VARIABLE DEFINITIONS
//

static BOOLEAN CsInitialized = FALSE;
static CRITICAL_SECTION CsCriticalSection;
static BOOLEAN CsDllMainCalled = FALSE;
static HINSTANCE CsOle32Dll = NULL;

//
// FUNCTION PROTOTYPES
//

#if 0

VOID
CspBackupAddressInformation(
    HANDLE Key,
    PCS_ADDRESS_INFORMATION AddressInformation
    );

NTSTATUS
CspCaptureAddressInformation(
    PWCHAR AdapterGuid,
    PCS_ADDRESS_INFORMATION Information
    );

VOID
CspCleanupAddressInformation(
    PCS_ADDRESS_INFORMATION AddressInformation
    );

NTSTATUS
CspRestoreAddressInformation(
    HANDLE Key,
    PWCHAR AdapterGuid
    );

BOOLEAN
CspIsConnectionFwWorker(
    LPRASSHARECONN ConnectionArray,
    ULONG Count,
    LPRASSHARECONN Connection,
    ULONG *ConnNumber OUT OPTIONAL
    );

ULONG
CspAddFirewallConnection(
    LPRASSHARECONN Connection,
    ULONG Number
    );

ULONG
CspRemoveFirewallConnection(
    LPRASSHARECONN Connection,
    ULONG Position,
    LPRASSHARECONN ConnectionArray,
    ULONG Count
    );
    
#endif


BOOL
CsDllMain(
    ULONG Reason
    )

/*++

Routine Description:

    This pseudo-entrypoint is invoked by RASAPI32.DLL's DllMain,
    to initialize and shutdown the connection-sharing module.
    Initialization is minimal to keep down the performance hit incurred
    on systems which make no use of the shared-access functionality.

Arguments:

    Reason - indicates whether to initialize or shutdown.

Return Value:

    BOOL - indicates success (TRUE) or failure (FALSE).

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        __try {
            InitializeCriticalSection(&CsCriticalSection);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }
        CsDllMainCalled = TRUE;
    } else if (Reason == DLL_PROCESS_DETACH) {
        if (!CsDllMainCalled) { return TRUE; }
        __try {
            EnterCriticalSection(&CsCriticalSection);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
        }
        CsShutdownModule();
        LeaveCriticalSection(&CsCriticalSection);
        DeleteCriticalSection(&CsCriticalSection);
    }
    return TRUE;
} // DllMain


VOID
CsControlService(
    ULONG ControlCode
    )

/*++

Routine Description:

    This routine is called to send a control-code to the Shared Access service
    if it is active. Control-codes are used to indicate changes to the settings
    for the service; see IPNATHLP.H for a list of private control-codes used
    to indicate configuration changes.

Arguments:

    ControlCode - the control to be sent.

Return Value:

    none.

--*/

{
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (ScmHandle) {
        ServiceHandle =
            OpenService(ScmHandle, c_szSharedAccess, SERVICE_ALL_ACCESS);
        if (ServiceHandle) {
            ControlService(ServiceHandle, ControlCode, &ServiceStatus);
            CloseServiceHandle(ServiceHandle);
        }
        CloseServiceHandle(ScmHandle);
    }

} // CsControlService

#if 0


ULONG
CsFirewallConnection(
    LPRASSHARECONN Connection,
    BOOLEAN Enable
    )

/*++

Routine Description:

    This routine is invoked to enable or disable the firewall on a connection.

Arguments:

    Connection - the connection to [un]firewall

    Enable - true if the firewall is to be enabled for this connection,
             false if the firewall is to be disabled
             
Return Value:

    Win32 Error code

--*/

{
    ULONG Count = 0;
    ULONG Position;
    LPRASSHARECONN ConnectionArray;
    DWORD Error;
    BOOLEAN IsFirewalled = FALSE;

    //
    // Query the number of currently firewalled connections, and
    // retrieve the connection array if any exists.
    //

    Error = CsQueryFirewallConnections(NULL, &Count);
    if (Error && Error != ERROR_INSUFFICIENT_BUFFER) {
        return Error;
    }

    if (Count) {
        ConnectionArray =
            (LPRASSHARECONN) Malloc(Count * sizeof(RASSHARECONN));

        if (!ConnectionArray) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Error = CsQueryFirewallConnections(ConnectionArray, &Count);
        if (Error) {
            Free(ConnectionArray);
            return Error;
        }
    } else {
        ConnectionArray = NULL;
    }

    //
    // If there are firewalled connections, check to see if the connection
    // passed in is one of them.
    //

    if (Count) {
        IsFirewalled = CspIsConnectionFwWorker(
                            ConnectionArray,
                            Count,
                            Connection,
                            &Position
                            );
    }

    if (Enable) {
    
        if (!IsFirewalled) {
            Error = CspAddFirewallConnection(
                        Connection,
                        Count
                        );

            if(ERROR_SUCCESS == Error) {
            
                //
                // Start (if needed) and update service. If the service
                // is already running, CsStartService returns ERROR_SUCCESS.
                //

                if (0 == Count) {
                    Error = CsStartService();
                }
                CsControlService(IPNATHLP_CONTROL_UPDATE_CONNECTION);
            }
            
        } else {

            //
            // Define ALREADY_ENABLED error?
            //
            
            Error = ERROR_CAN_NOT_COMPLETE;
        }

    } else {
    
        if (IsFirewalled) {
            Error = CspRemoveFirewallConnection(
                        Connection,
                        Position,
                        ConnectionArray,
                        Count
                        );

            if (ERROR_SUCCESS == Error) {
            
                //
                // Stop or update service. We only stop the service if
                // there is no shared connection, and this was the last
                // firewalled connection (i.e., count was 10
                //
                
                RASSHARECONN SharedConn;
                Error = CsQuerySharedConnection(&SharedConn);

                if (ERROR_SUCCESS != Error && 1 == Count) { 
                    CsStopService();
                } else {
                    CsControlService(IPNATHLP_CONTROL_UPDATE_CONNECTION);
                }
                Error = ERROR_SUCCESS;
            }

        } else {

            //
            // Define NOT_FIREWALLED error?
            //
            
            Error = ERROR_CAN_NOT_COMPLETE;
        }
    }

    if (ConnectionArray) {
        Free(ConnectionArray);
    }

    return Error;
} // CsFirewallConnection

#endif


ULONG
CsInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the connection-sharing configuration
    module. Initialization consists of loading the entrypoints which we have
    deferred loading up till now, in both MPRAPI.DLL and OLE32.DLL.

Arguments:

    Instance - handle to the module-instance

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    HINSTANCE Hinstance;
    EnterCriticalSection(&CsCriticalSection);
    if (CsInitialized) {
        Error = NO_ERROR;
    } else {
        if (!(CsOle32Dll = LoadLibraryW(c_szOle32Dll)) ||
            !(g_pCoInitializeEx =
                (PCOINITIALIZEEX)GetProcAddress(
                    CsOle32Dll, c_szCoInitializeEx
                    )) ||
            !(g_pCoUninitialize =
                (PCOUNINITIALIZE)GetProcAddress(
                    CsOle32Dll, c_szCoUninitialize
                    )) ||
            !(g_pCoCreateInstance =
                (PCOCREATEINSTANCE)GetProcAddress(
                    CsOle32Dll, c_szCoCreateInstance
                    )) ||
            !(g_pCoSetProxyBlanket =
                (PCOSETPROXYBLANKET)GetProcAddress(
                    CsOle32Dll, c_szCoSetProxyBlanket
                    )) ||
            !(g_pCoTaskMemFree =
                (PCOTASKMEMFREE)GetProcAddress(
                    CsOle32Dll, c_szCoTaskMemFree
                    ))) {
            if (CsOle32Dll) { FreeLibrary(CsOle32Dll); CsOle32Dll = NULL; }
            TRACE1("CsInitializeModule: %d", GetLastError());
            Error = ERROR_PROC_NOT_FOUND;
        } else {
            CsInitialized = TRUE;
            Error = NO_ERROR;
        }
    }
    LeaveCriticalSection(&CsCriticalSection);
    return Error;

} // CsInitializeModule

#if 0


ULONG
CsIsFirewalledConnection(
    LPRASSHARECONN Connection,
    PBOOLEAN Firewalled
    )

/*++

Routine Description:

    This routine is invoked to determine if a connection is firewalled

Arguments:

    Connection - the connection to check

    Firewalled - receives the return value

Return Value:

    ULONG - win32 error
    
--*/

{
    ULONG Count = 0;
    LPRASSHARECONN ConnectionArray;
    ULONG Error;

    if (!Firewalled) {
        return ERROR_INVALID_PARAMETER;
    }
    *Firewalled = FALSE;

    Error = CsQueryFirewallConnections(NULL, &Count);
    if (Error && Error != ERROR_INSUFFICIENT_BUFFER) {
        return Error;
    }

    ConnectionArray =
        (LPRASSHARECONN) Malloc(Count * sizeof(RASSHARECONN));

    if (!ConnectionArray) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = CsQueryFirewallConnections(ConnectionArray, &Count);
    if (Error) {
        Free(ConnectionArray);
        return Error;
    }

    *Firewalled = CspIsConnectionFwWorker(ConnectionArray, Count, Connection, NULL);
    Free(ConnectionArray);
    return NO_ERROR;
} // CsIsConnectionFirewalled


BOOLEAN
CsIsRoutingProtocolInstalled(
    ULONG ProtocolId
    )

/*++

Routine Description:

    This routine is invoked to determine whether the routing protocol
    with the given protocol-ID is installed for Routing and Remote Access.
    This is determined by examining the configuration for the service.

Arguments:

    ProtocolId - identifies the protocol to be found

Return Value:

    TRUE if the protocol is installed, FALSE otherwise.

--*/

{
    PUCHAR Buffer;
    ULONG BufferLength;
    HINSTANCE Hinstance;
    PMPRCONFIGBUFFERFREE MprConfigBufferFree;
    PMPRCONFIGSERVERCONNECT MprConfigServerConnect;
    PMPRCONFIGSERVERDISCONNECT MprConfigServerDisconnect;
    PMPRCONFIGTRANSPORTGETHANDLE MprConfigTransportGetHandle;
    PMPRCONFIGTRANSPORTGETINFO MprConfigTransportGetInfo;
    PMPRINFOBLOCKFIND MprInfoBlockFind;
    HANDLE ServerHandle;
    HANDLE TransportHandle;

    //
    // Load the MPRAPI.DLL module and retrieve the entrypoints
    // to be used for examining the RRAS configuration.
    //

    if (!(Hinstance = LoadLibraryW(c_szMprapiDll)) ||
        !(MprConfigBufferFree = 
            (PMPRCONFIGBUFFERFREE)
                GetProcAddress(Hinstance, c_szMprConfigBufferFree)) ||
        !(MprConfigServerConnect = 
            (PMPRCONFIGSERVERCONNECT)
                GetProcAddress(Hinstance, c_szMprConfigServerConnect)) ||
        !(MprConfigServerDisconnect = 
            (PMPRCONFIGSERVERDISCONNECT)
                GetProcAddress(Hinstance, c_szMprConfigServerDisconnect)) ||
        !(MprConfigTransportGetHandle = 
            (PMPRCONFIGTRANSPORTGETHANDLE)
                GetProcAddress(Hinstance, c_szMprConfigTransportGetHandle)) ||
        !(MprConfigTransportGetInfo = 
            (PMPRCONFIGTRANSPORTGETINFO)
                GetProcAddress(Hinstance, c_szMprConfigTransportGetInfo)) ||
        !(MprInfoBlockFind = 
            (PMPRINFOBLOCKFIND)
                GetProcAddress(Hinstance, c_szMprInfoBlockFind))) {
        if (Hinstance) { FreeLibrary(Hinstance); }
        return FALSE;
    }

    //
    // Connect to the RRAS configuration, and retrieve the configuration
    // for the IP transport-layer routing protocols. This should include
    // the configuration for the routing-protocol in 'ProtocolId',
    // if installed.
    //

    ServerHandle = NULL;
    if (MprConfigServerConnect(NULL, &ServerHandle) != NO_ERROR ||
        MprConfigTransportGetHandle(ServerHandle, PID_IP, &TransportHandle)
            != NO_ERROR ||
        MprConfigTransportGetInfo(
            ServerHandle,
            TransportHandle,
            &Buffer,
            &BufferLength, 
            NULL,
            NULL,
            NULL
            ) != NO_ERROR) {
        if (ServerHandle) { MprConfigServerDisconnect(ServerHandle); }
        FreeLibrary(Hinstance);
        return FALSE;
    }

    MprConfigServerDisconnect(ServerHandle);

    //
    // Look for the requested protocol's configuration,
    // and return TRUE if it is found; otherwise, return FALSE.
    //

    if (MprInfoBlockFind(Buffer, ProtocolId, NULL, NULL, NULL) == NO_ERROR) {
        MprConfigBufferFree(Buffer);
        FreeLibrary(Hinstance);
        return TRUE;
    }
    MprConfigBufferFree(Buffer);
    FreeLibrary(Hinstance);
    return FALSE;
} // CsIsRoutingProtocolInstalled

#endif


ULONG
CsIsSharedConnection(
    LPRASSHARECONN Connection,
    PBOOLEAN Shared
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given connection
    is the currently-shared connection.

    For added performance, this may be changed to cache the shared-connection
    and use registry change-notification to detect updates.

Arguments:

    Connection - the connection in question

    Shared - receives 'TRUE' if the 'Name' is the shared connection,
        and 'FALSE' otherwise

Return Value:

    ULONG - Win32 status code.

Environment:

    This routine is called *without* initializing the module
    (i.e. loading mprapi.dll and ole32.dll), for performance reasons.
    Hence, it may not invoke any mprapi.dll routines.

--*/

{
    ULONG Error;
    RASSHARECONN SharedConnection;
    if (Shared) {
        Error = CsQuerySharedConnection(&SharedConnection);
        if (Error) {
            *Shared = FALSE;
        } else {
            *Shared = RasIsEqualSharedConnection(Connection, &SharedConnection);
        }
    }
    return NO_ERROR;
} // CsIsSharedConnection

#if 0


ULONG
CsMapGuidToAdapterIndex(
    PWCHAR Guid,
    PGETINTERFACEINFO GetInterfaceInfo
    )

/*++

Routine Description:

    This routine is called to match the GUID in the given string to
    an adapter in the list returned by calling the given entrypoint.

Arguments:

    Guid - identifies the GUID of the adapter to be found

    GetInterfaceInfo - supplies GUID information for each adapter

Return Value:

    ULONG - the index of the adapter, if found; otherwise, -1.

--*/

{
    ULONG AdapterIndex = (ULONG)-1;
    ULONG i;
    ULONG GuidLength;
    PIP_INTERFACE_INFO Info;
    PWCHAR Name;
    ULONG NameLength;
    ULONG Size;
    Size = 0;
    GuidLength = lstrlenW(Guid);
    if (GetInterfaceInfo(NULL, &Size) == ERROR_INSUFFICIENT_BUFFER) {
        Info = Malloc(Size);
        if (Info) {
            if (GetInterfaceInfo(Info, &Size) == NO_ERROR) {
                for (i = 0; i < (ULONG)Info->NumAdapters; i++) {
                    NameLength = lstrlenW(Info->Adapter[i].Name);
                    if (NameLength < GuidLength) { continue; }
                    Name = Info->Adapter[i].Name + (NameLength - GuidLength);
                    if (lstrcmpiW(Guid, Name) == 0) {
                        AdapterIndex = Info->Adapter[i].Index;
                        break;
                    }
                }
            }
            Free(Info);
        }
    }
    return AdapterIndex;
} // CsMapGuidToAdapter

#endif


NTSTATUS
CsOpenKey(
    PHANDLE Key,
    ACCESS_MASK DesiredAccess,
    PCWSTR Name
    )

/*++

Routine Description:

    This routine is invoked to open a given registry key.

Arguments:

    Key - receives the opened key

    DesiredAccess - specifies the requested access

    Name - specifies the key to be opened

Return Value:

    NTSTATUS - NT status code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    RtlInitUnicodeString(&UnicodeString, Name);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    return NtOpenKey(Key, DesiredAccess, &ObjectAttributes);
} // CsOpenKey

#if 0


ULONG
CspAddFirewallConnection(
    LPRASSHARECONN Connection,
    ULONG Number
    )

/*++

Routine Description:

    This routine is invoked to add a connection to the registry set.

Arguments:

    Connection - the connection to add

    Number - the number of this connection
    
Return Value:

    Win32 error code

--*/

{
    HANDLE Key;
    UNICODE_STRING ValueName;
    ULONG Count;
    NTSTATUS Status;

    //
    // +11 is enough room to hold the digits of a number >4,000,000,000, so
    // buffer overflow won't be an issue below.
    //
    
    WCHAR wsz[sizeof(c_szFirewallConnection)/sizeof(WCHAR) + 11];

    //
    // Open the key to SharedAccess/Parameters
    //

    Status = CsOpenKey(&Key, KEY_ALL_ACCESS, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError(Status);
    }

    //
    // Generate the string for the connection value
    //

    swprintf(wsz, L"%s%u", c_szFirewallConnection, Number);
    RtlInitUnicodeString(&ValueName, wsz);

    //
    // Write the connection to the registry
    //

    Status = NtSetValueKey(
                Key,
                &ValueName,
                0,
                REG_BINARY,
                Connection,
                Connection->dwSize
                );

    if(!NT_SUCCESS(Status)) {
        NtClose(Key);
        return RtlNtStatusToDosError(Status);
    }

    //
    // Write the updated count to the registry
    //

    RtlInitUnicodeString(&ValueName, c_szFirewallConnectionCount);
    Count = Number + 1; // number is 0 indexed

    Status = NtSetValueKey(
                Key,
                &ValueName,
                0,
                REG_DWORD,
                &Count,
                sizeof(DWORD)
                );

    NtClose(Key);
    return RtlNtStatusToDosError(Status);
} // CspAddFirewallConnection


VOID
CspBackupAddressInformation(
    HANDLE Key,
    PCS_ADDRESS_INFORMATION Information
    )
{
    NTSTATUS status;
    UNICODE_STRING UnicodeString;
    do {
        RtlInitUnicodeString(&UnicodeString, c_szBackupIPAddress);
        status =
            NtSetValueKey(
                Key,
                &UnicodeString,
                0,
                Information->IPAddress->Type,
                Information->IPAddress->Data,
                Information->IPAddress->DataLength
                );
        if (!NT_SUCCESS(status)) { break; }
        RtlInitUnicodeString(&UnicodeString, c_szBackupSubnetMask);
        status =
            NtSetValueKey(
                Key,
                &UnicodeString,
                0,
                Information->SubnetMask->Type,
                Information->SubnetMask->Data,
                Information->SubnetMask->DataLength
                );
        if (!NT_SUCCESS(status)) { break; }
        RtlInitUnicodeString(&UnicodeString, c_szBackupDefaultGateway);
        status =
            NtSetValueKey(
                Key,
                &UnicodeString,
                0,
                Information->DefaultGateway->Type,
                Information->DefaultGateway->Data,
                Information->DefaultGateway->DataLength
                );
        if (!NT_SUCCESS(status)) { break; }
        RtlInitUnicodeString(&UnicodeString, c_szBackupEnableDHCP);
        status =
            NtSetValueKey(
                Key,
                &UnicodeString,
                0,
                Information->EnableDHCP->Type,
                Information->EnableDHCP->Data,
                Information->EnableDHCP->DataLength
                );
        if (!NT_SUCCESS(status)) { break; }
        return;
    } while(FALSE);
    RtlInitUnicodeString(&UnicodeString, c_szBackupIPAddress);
    NtDeleteValueKey(Key, &UnicodeString);
    RtlInitUnicodeString(&UnicodeString, c_szBackupSubnetMask);
    NtDeleteValueKey(Key, &UnicodeString);
    RtlInitUnicodeString(&UnicodeString, c_szBackupDefaultGateway);
    NtDeleteValueKey(Key, &UnicodeString);
    RtlInitUnicodeString(&UnicodeString, c_szBackupEnableDHCP);
    NtDeleteValueKey(Key, &UnicodeString);
} // CspBackupAddressInformation


NTSTATUS
CspCaptureAddressInformation(
    PWCHAR AdapterGuid,
    PCS_ADDRESS_INFORMATION Information
    )
{
    HANDLE Key;
    PWCHAR KeyName;
    ULONG KeyNameLength;
    NTSTATUS status;

    KeyNameLength =
        sizeof(WCHAR) *
        (lstrlenW(c_szTcpipParametersKey) + 1 +
         lstrlenW(c_szInterfaces) + 1 +
         lstrlenW(AdapterGuid) + 2);
    if (!(KeyName = Malloc(KeyNameLength))) { return STATUS_NO_MEMORY; }

    wsprintfW(
        KeyName, L"%ls\\%ls\\%ls", c_szTcpipParametersKey, c_szInterfaces,
        AdapterGuid
        );
    status = CsOpenKey(&Key, KEY_READ, KeyName);
    Free(KeyName);
    if (!NT_SUCCESS(status)) { return status; }

    do {
        status =
            CsQueryValueKey(
                Key, c_szIPAddress, &Information->IPAddress
                );
        if (!NT_SUCCESS(status)) { break; }
        status =
            CsQueryValueKey(
                Key, c_szSubnetMask, &Information->SubnetMask
                );
        if (!NT_SUCCESS(status)) { break; }
        status =
            CsQueryValueKey(
                Key, c_szDefaultGateway, &Information->DefaultGateway
                );
        if (!NT_SUCCESS(status)) { break; }
        status =
            CsQueryValueKey(
                Key, c_szEnableDHCP, &Information->EnableDHCP
                );
        if (!NT_SUCCESS(status)) { break; }
    } while(FALSE);

    NtClose(Key);
    return status;
} // CspCaptureAddressInformation


VOID
CspCleanupAddressInformation(
    PCS_ADDRESS_INFORMATION Information
    )
{
    Free0(Information->IPAddress);
    Free0(Information->SubnetMask);
    Free0(Information->DefaultGateway);
    Free0(Information->EnableDHCP);
} // CspCleanupAddressInformation


ULONG
CspRemoveFirewallConnection(
    LPRASSHARECONN Connection,
    ULONG Position,
    LPRASSHARECONN ConnectionArray,
    ULONG Count
    )

/*++

Routine Description:

    This routine is invoked to remove a connection to the registry set.

Arguments:

    Connection - the connection to remove

    Number - its index in ConnectionArray

    ConnectionArray - currently firewalled connections

    Count - the number of entries in ConnectionArray
    
Return Value:

    Win32 error code

--*/

{
    HANDLE Key;
    UNICODE_STRING ValueName;
    ULONG i;
    NTSTATUS Status;

    //
    // +11 is enough room to hold the digits of a number >4,000,000,000, so
    // buffer overflow won't be an issue below.
    //
    
    WCHAR wsz[sizeof(c_szFirewallConnection)/sizeof(WCHAR) + 11];

    //
    // Open the key to IPFirewall/Parameters
    //

    Status = CsOpenKey(&Key, KEY_ALL_ACCESS, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError(Status);
    }

    //
    // Shift entries above the connection we're removing down one
    // (overwriting the entry we want to remove)
    //

    for (i = Position + 1; i < Count; i++) {
    
        //
        // Generate key name for previous entry
        //

        swprintf(wsz, L"%s%u", c_szFirewallConnection, i - 1);
        RtlInitUnicodeString(&ValueName, wsz);

        //
        // Write current entry into previous slot
        //

        Status = NtSetValueKey(
                Key,
                &ValueName,
                0,
                REG_BINARY,
                &ConnectionArray[i],
                ConnectionArray[i].dwSize
                );

        if(!NT_SUCCESS(Status)) {
            NtClose(Key);
            return RtlNtStatusToDosError(Status);
        }
    }

    //
    // Delete the last entry. This is either the entry we want to
    // remove (if it was the last entry to begin with), or an entry
    // that has already been duplicated into the previous position.
    //

    swprintf(wsz, L"%s%u", c_szFirewallConnection, Count - 1);
    RtlInitUnicodeString(&ValueName, wsz);

    Status = NtDeleteValueKey(Key, &ValueName);

    if(!NT_SUCCESS(Status)) {
        NtClose(Key);
        return RtlNtStatusToDosError(Status);
    }


    //
    // Store the decremented count in the registry
    //

    RtlInitUnicodeString(&ValueName, c_szFirewallConnectionCount);
    i = Count - 1;

    Status = NtSetValueKey(
                Key,
                &ValueName,
                0,
                REG_DWORD,
                &i,
                sizeof(DWORD)
                );


    NtClose(Key);
    return RtlNtStatusToDosError(Status);
} // CspRemoveFirewallConnection



ULONG
CsQueryFirewallConnections(
    LPRASSHARECONN ConnectionArray,
    ULONG *ConnectionCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the firewalled connections, if any.

Arguments:

    ConnectionArray - receives the retrieved connections.

    ConnectionCount - in: how many entries the array can hold
                       out: number of entries returned, or the needed
                            size of the array (for ERROR_INSUFFICIENT_BUFFER)

Return Value:

    ULONG - Win32 status code.

--*/

{
    HANDLE Key;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    NTSTATUS Status;
    ULONG Count;
    ULONG i;

    if (!ConnectionCount) { return ERROR_INVALID_PARAMETER; }
    if (*ConnectionCount && !ConnectionArray) {
        //
        // It's OK to pass in NULL for the array if just trying
        // to determine what size buffer to use
        //
        
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open the 'SharedAccess\Parameters' key,
    // and read the 'FirewallConnectionCount' value
    //

    Status = CsOpenKey(&Key, KEY_READ, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(Status)) {
        TRACE1(
            "CsQueryFirewallConnections: CsOpenKey=%x", Status
            );
        return RtlNtStatusToDosError(Status);
    }

    Status = CsQueryValueKey(Key, c_szFirewallConnectionCount, &Information);
    if (NT_SUCCESS(Status)) {

        //
        // Validate the information, and check to see if the passed in array
        // is sufficient in size.
        //

        if (Information->DataLength != sizeof(DWORD) ||
            Information->Type != REG_DWORD) {
            
            TRACE(
                "CsQueryFirewallConnections: invalid data in registry for count"
                );
            NtClose(Key);
            Free(Information);
            return ERROR_INVALID_DATA;

        }

        Count = (ULONG) *Information->Data;
        Free(Information);

    } else {
        Count = 0;
    }

    if (*ConnectionCount < Count) {
        //
        // Too many entries for the passed in buffer
        //

        NtClose(Key);
        *ConnectionCount = Count;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *ConnectionCount = Count;

    //
    // Read all of the connection entries from the registry.
    //

    for(i = 0; i < Count; i++) {
        WCHAR wsz[sizeof(c_szFirewallConnection)/sizeof(WCHAR) + 11];

        swprintf(wsz, L"%s%u", c_szFirewallConnection, i);
        Status = CsQueryValueKey(Key, wsz, &Information);
        if (!NT_SUCCESS(Status)) {
            NtClose(Key);
            return RtlNtStatusToDosError(Status);
        }

        //
        // Validate the retrieved information,
        // and copy it to the given buffer
        //

        if (Information->DataLength != sizeof(RASSHARECONN) ||
            ((LPRASSHARECONN)Information->Data)->dwSize != sizeof(RASSHARECONN)) {

            TRACE2(
                "CsQueryFirewallConnections: invalid length %d (size=%d) in registry",
                Information->DataLength,
                ((LPRASSHARECONN)Information->Data)->dwSize
                );
                
            Free(Information);
            NtClose(Key);
            return ERROR_INVALID_DATA;
        }

        CopyMemory(&ConnectionArray[i], Information->Data, sizeof(RASSHARECONN));
        Free(Information);
    }

    return NO_ERROR;

} // CsQueryFirewallConnections


BOOLEAN
CspIsConnectionFwWorker(
    LPRASSHARECONN ConnectionArray,
    ULONG Count,
    LPRASSHARECONN Connection,
    ULONG *Position OUT OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to determine if a connection is firewalled

Arguments:

    ConnectionArray - Buffer containing currently FWd connections

    Count - number of connections in the array

    Connection - the connection to check

    Position - receives the number of the connection, if found (undefined otherwise)

Return Value:

    BOOLEAN -- true if the passed in connection is currently firewalled

--*/

{
    ULONG i;

    for (i = 0; i < Count; i++) {
        if (RasIsEqualSharedConnection(Connection, &ConnectionArray[i])) {
            if (Position) *Position = i;
            return TRUE;
        }
    }

    return FALSE;
} // FwpIsConnectionFwWorker


NTSTATUS
CspRestoreAddressInformation(
    HANDLE Key,
    PWCHAR AdapterGuid
    )
{
    HANDLE AdapterKey = NULL;
    PWCHAR AdapterKeyName = NULL;
    PDHCPNOTIFYCONFIGCHANGE DhcpNotifyConfigChange;
    ULONG Error;
    HINSTANCE Hinstance;
    CS_ADDRESS_INFORMATION Information;
    ULONG Length;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    if (!(Hinstance = LoadLibraryW(c_szDhcpcsvcDll)) ||
        !(DhcpNotifyConfigChange =
            (PDHCPNOTIFYCONFIGCHANGE)
                GetProcAddress(
                    Hinstance, c_szDhcpNotifyConfigChange
                    ))) {
        if (Hinstance) { FreeLibrary(Hinstance); }
        return ERROR_PROC_NOT_FOUND;
    }

    do {

        ZeroMemory(&Information, sizeof(Information));
        status =
            CsQueryValueKey(
                Key, c_szBackupIPAddress, &Information.IPAddress
                );
        if (!NT_SUCCESS(status)) { break; }
        status =
            CsQueryValueKey(
                Key, c_szBackupSubnetMask, &Information.SubnetMask
                );
        if (!NT_SUCCESS(status)) { break; }
        status =
            CsQueryValueKey(
                Key, c_szBackupDefaultGateway, &Information.DefaultGateway
                );
        if (!NT_SUCCESS(status)) { break; }
        status =
            CsQueryValueKey(
                Key, c_szBackupEnableDHCP, &Information.EnableDHCP
                );
        if (!NT_SUCCESS(status)) { break; }

        Length =
            sizeof(WCHAR) *
            (lstrlenW(c_szTcpipParametersKey) + 1 +
             lstrlenW(c_szInterfaces) + 1 +
             lstrlenW(AdapterGuid) + 2);
        if (!(AdapterKeyName = Malloc(Length))) {
            status = STATUS_NO_MEMORY;
            break;
        }

        wsprintfW(
            AdapterKeyName, L"%ls\\%ls\\%ls", c_szTcpipParametersKey,
            c_szInterfaces, AdapterGuid
            );
        status = CsOpenKey(&AdapterKey, KEY_ALL_ACCESS, AdapterKeyName);
        if (!NT_SUCCESS(status)) { break; }

        RtlInitUnicodeString(&UnicodeString, c_szIPAddress);
        status =
            NtSetValueKey(
                AdapterKey,
                &UnicodeString,
                0,
                Information.IPAddress->Type,
                Information.IPAddress->Data,
                Information.IPAddress->DataLength
                );
        RtlInitUnicodeString(&UnicodeString, c_szSubnetMask);
        status =
            NtSetValueKey(
                AdapterKey,
                &UnicodeString,
                0,
                Information.SubnetMask->Type,
                Information.SubnetMask->Data,
                Information.SubnetMask->DataLength
                );
        RtlInitUnicodeString(&UnicodeString, c_szDefaultGateway);
        status =
            NtSetValueKey(
                AdapterKey,
                &UnicodeString,
                0,
                Information.DefaultGateway->Type,
                Information.DefaultGateway->Data,
                Information.DefaultGateway->DataLength
                );
        RtlInitUnicodeString(&UnicodeString, c_szEnableDHCP);
        status =
            NtSetValueKey(
                AdapterKey,
                &UnicodeString,
                0,
                Information.EnableDHCP->Type,
                Information.EnableDHCP->Data,
                Information.EnableDHCP->DataLength
                );
        if (!NT_SUCCESS(status)) { break; }

        RtlInitUnicodeString(&UnicodeString, c_szBackupIPAddress);
        NtDeleteValueKey(Key, &UnicodeString);
        RtlInitUnicodeString(&UnicodeString, c_szBackupSubnetMask);
        NtDeleteValueKey(Key, &UnicodeString);
        RtlInitUnicodeString(&UnicodeString, c_szBackupDefaultGateway);
        NtDeleteValueKey(Key, &UnicodeString);
        RtlInitUnicodeString(&UnicodeString, c_szBackupEnableDHCP);
        NtDeleteValueKey(Key, &UnicodeString);

        if (*(PULONG)Information.EnableDHCP->Data) {
            Error =
                DhcpNotifyConfigChange(
                    NULL,
                    AdapterGuid,
                    FALSE,
                    0,
                    0,
                    0,
                    DhcpEnable
                    );
        } else {

            ULONG Address;
            UNICODE_STRING BindList;
            UNICODE_STRING LowerComponent;
            ULONG Mask;
            IP_PNP_RECONFIG_REQUEST Request;
            UNICODE_STRING UpperComponent;

            Address = IpPszToHostAddr((PWCHAR)Information.IPAddress->Data);
            if (Address) {
                Address = RtlUlongByteSwap(Address);
                Mask = IpPszToHostAddr((PWCHAR)Information.SubnetMask->Data);
                if (Mask) {
                    Mask = RtlUlongByteSwap(Mask);
                    Error =
                        DhcpNotifyConfigChange(
                            NULL,
                            AdapterGuid,
                            TRUE,
                            0,
                            Address,
                            Mask,
                            DhcpDisable
                            );
                }
            }

            RtlInitUnicodeString(&BindList, c_szEmpty);
            RtlInitUnicodeString(&LowerComponent, c_szEmpty);
            RtlInitUnicodeString(&UpperComponent, c_szTcpip);
            ZeroMemory(&Request, sizeof(Request));
            Request.version = IP_PNP_RECONFIG_VERSION;
            Request.gatewayListUpdate = TRUE;
            Request.Flags = IP_PNP_FLAG_GATEWAY_LIST_UPDATE;
            status =
                NdisHandlePnPEvent(
                    NDIS,
                    RECONFIGURE,
                    &LowerComponent,
                    &UpperComponent,
                    &BindList,
                    &Request,
                    sizeof(Request)
                    );
        }
    } while(FALSE);
    if (AdapterKey) { NtClose(AdapterKey); }
    Free0(AdapterKeyName);
    CspCleanupAddressInformation(&Information);
    FreeLibrary(Hinstance);
    return status;
} // CspRestoreAddressInformation


ULONG
CsQueryLanConnTable(
    LPRASSHARECONN ExcludedConnection,
    NETCON_PROPERTIES** LanConnTable,
    LPDWORD LanConnCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve an array of LAN connections,
    discounting 'ExcludeConnection', which will typically be the name
    of the public interface.

Arguments:

    ExcludeConnection - a connection not allowed to be the private connection

    LanConnTable - optionally receives a table of possible private networks.

    LanConnCount - receives a count of the possible private networks.

Return Value:

    ULONG - Win32 status code.

--*/

{
    BOOLEAN CleanupOle = TRUE;
    INetConnection* ConArray[32];
    ULONG ConCount;
    INetConnectionManager* ConMan = NULL;
    IEnumNetConnection* EnumCon = NULL;
    ULONG Error;
    HRESULT hr;
    ULONG i;
    ULONG j;
    ULONG LanCount = 0;
    NETCON_PROPERTIES* LanProps = NULL;
    NETCON_PROPERTIES* LanTable = NULL;
    BSTR Name;
    NETCON_STATUS ncs;
    NTSTATUS status;
    ULONG Size;
    NETCON_MEDIATYPE MediaType;
    UNICODE_STRING UnicodeString;

    *LanConnCount = 0;
    if (LanConnTable) { *LanConnTable = NULL; }

    hr = g_pCoInitializeEx(NULL, COINIT_MULTITHREADED|COINIT_DISABLE_OLE1DDE);
    if (!SUCCEEDED(hr)) {
        if (hr == RPC_E_CHANGED_MODE) {
            CleanupOle = FALSE;
        } else {
            TRACE1("CsQueryLanConnTable: CoInitializeEx=%x", hr);
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    i = 0;
    Error = NO_ERROR;

    do {

        //
        // Instantiate the connection manager
        //

        hr =
            g_pCoCreateInstance(
                &CLSID_ConnectionManager,
                NULL,
                CLSCTX_SERVER,
                &IID_INetConnectionManager,
                (PVOID*)&ConMan
                );
        if (!SUCCEEDED(hr)) {
            TRACE1("CsQueryLanConnTable: CoCreateInstance=%x", hr);
            ConMan = NULL; break;
        }

        //
        // Instantiate a connection-enumerator
        //

        hr =
            INetConnectionManager_EnumConnections(
                ConMan,
                NCME_DEFAULT,
                &EnumCon
                );
        if (!SUCCEEDED(hr)) {
            TRACE1("CsQueryLanConnTable: EnumConnections=%x", hr);
            EnumCon = NULL; break;
        }

        hr =
            g_pCoSetProxyBlanket(
                (IUnknown*)EnumCon,
                RPC_C_AUTHN_WINNT,
                RPC_C_AUTHN_NONE,
                NULL,
                RPC_C_AUTHN_LEVEL_CALL,
                RPC_C_IMP_LEVEL_IMPERSONATE,
                NULL,
                EOAC_NONE
                );

        //
        // Enumerate the items
        //

        for ( ; ; ) {

            hr =
                IEnumNetConnection_Next(
                    EnumCon,
                    Dimension(ConArray),
                    ConArray,
                    &ConCount
                    );
            if (!SUCCEEDED(hr) || !ConCount) { hr = S_OK; break; }

            if (LanConnTable) {

                //
                // Allocate or reallocate the memory for storing
                // connections which we will return to the caller.
                //

                if (!LanTable) {
                    LanTable =
                        (NETCON_PROPERTIES*)
                            GlobalAlloc(
                                0,
                                ConCount * sizeof(NETCON_PROPERTIES)
                                );
                } else {
                    PVOID Temp =
                        GlobalAlloc(
                            0,
                            (LanCount + ConCount) * sizeof(NETCON_PROPERTIES)
                            );
                    if (Temp) {
                        CopyMemory(
                            Temp,
                            LanTable,
                            LanCount * sizeof(NETCON_PROPERTIES)
                            );
                    }
                    GlobalFree(LanTable);
                    LanTable = Temp;
                }

                if (!LanTable) { Error = ERROR_NOT_ENOUGH_MEMORY; break; }
            }

            LanCount += ConCount;

            //
            // Examine the properties for the connections retrieved
            //

            for (j = 0; j < ConCount; j++) {

                hr = INetConnection_GetProperties(ConArray[j], &LanProps);
                INetConnection_Release(ConArray[j]);

                if (SUCCEEDED(hr) &&
                    LanProps->MediaType == NCM_LAN &&
                    (!ExcludedConnection->fIsLanConnection ||
                     !IsEqualGUID(
                        &ExcludedConnection->guid, &LanProps->guidId))) {

                    //
                    // This connection qualifies to be private; copy it.
                    //

                    if (!LanConnTable) {
                        ++i;
                    } else {
                        LanTable[i] = *LanProps;
                        LanTable[i].pszwName = StrDupW(LanProps->pszwName);
                        LanTable[i].pszwDeviceName =
                            StrDupW(LanProps->pszwDeviceName);
                        if (LanTable[i].pszwName &&
                            LanTable[i].pszwDeviceName
                            ) {
                            ++i;
                        } else {
                            Free0(LanTable[i].pszwName);
                            Free0(LanTable[i].pszwDeviceName);
                        }
                    }
                }

                if (LanProps) {
                    g_pCoTaskMemFree(LanProps->pszwName);
                    g_pCoTaskMemFree(LanProps->pszwDeviceName);
                    g_pCoTaskMemFree(LanProps);
                    LanProps = NULL;
                }
            }
        }

    } while (FALSE);

    if (EnumCon) { IEnumNetConnection_Release(EnumCon); }
    if (ConMan) { INetConnectionManager_Release(ConMan); }
    if (CleanupOle) { g_pCoUninitialize(); }

    if (LanConnTable) { *LanConnTable = LanTable; }
    *LanConnCount = i;

    return Error;

} // CsQueryLanConnTable


VOID
CsQueryScopeInformation(
    IN OUT PHANDLE Key,
    PULONG Address,
    PULONG Mask
    )

/*++

Routine Description:

    This routine is called to retrieve the private network address and mask
    to be used for shared access. If no value is found, the default
    is supplied.

Arguments:

    Key - optionally supplies an open handle to the SharedAccess\Parameters
        registry key

    Address - receives the address for the private network,
        in network byte order

    Mask - receives the mask for the private network, in network byte order

Return Value:

    none.

--*/

{
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    HANDLE LocalKey = NULL;
    NTSTATUS status;

    if (!Key) { Key = &LocalKey; }
    if (*Key) {
        status = STATUS_SUCCESS;
    } else {
        status = CsOpenKey(Key, KEY_ALL_ACCESS, c_szSharedAccessParametersKey);
    }

    if (NT_SUCCESS(status)) {
        status = CsQueryValueKey(*Key, c_szScopeAddress, &Information);
        if (NT_SUCCESS(status)) {
            if (!(*Address = IpPszToHostAddr((PWCHAR)Information->Data))) {
                Free(Information);
            } else {
                Free(Information);
                status = CsQueryValueKey(*Key, c_szScopeMask, &Information);
                if (NT_SUCCESS(status)) {
                    if (!(*Mask = IpPszToHostAddr((PWCHAR)Information->Data))) {
                        Free(Information);
                    } else {
                        Free(Information);
                        *Address = RtlUlongByteSwap(*Address);
                        *Mask = RtlUlongByteSwap(*Mask);
                        if (LocalKey) { NtClose(LocalKey); }
                        return;
                    }
                }
            }
        }
    }

    *Address = DEFAULT_SCOPE_ADDRESS;
    *Mask = DEFAULT_SCOPE_MASK;
    if (LocalKey) { NtClose(LocalKey); }

} // CsQueryScopeInformation

#endif


ULONG
CsQuerySharedConnection(
    LPRASSHARECONN Connection
    )

/*++

Routine Description:

    This routine is invoked to retrieve the shared connection, if any.

Arguments:

    Connection - receives the retrieved connection.

Return Value:

    ULONG - Win32 status code.

--*/

{
    BOOL fUninitializeCOM = TRUE;
    IHNetIcsSettings *pIcsSettings;
    IEnumHNetIcsPublicConnections *pEnumIcsPub;
    IHNetIcsPublicConnection *pIcsPub;
    IHNetConnection *pConn;
    ULONG ulCount;
    HRESULT hr;
    
    ASSERT(NULL != g_pCoInitializeEx);
    ASSERT(NULL != g_pCoCreateInstance);
    ASSERT(NULL != g_pCoUninitialize);

    if (!Connection) { return ERROR_INVALID_PARAMETER; }
    
    hr = g_pCoInitializeEx(
            NULL,
            COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE
            );

    if (FAILED(hr))
    {
        fUninitializeCOM = FALSE;
                
        if(RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;    
        }
    }
    
    if (SUCCEEDED(hr)) 
    {
        hr = g_pCoCreateInstance(
                &CLSID_HNetCfgMgr,
                NULL,
                CLSCTX_ALL,
                &IID_IHNetIcsSettings,
                (VOID**)&pIcsSettings
                );
    }

    if (SUCCEEDED(hr))
    {
        hr = IHNetIcsSettings_EnumIcsPublicConnections(
                pIcsSettings,
                &pEnumIcsPub
                );

        IHNetIcsSettings_Release(pIcsSettings);
    }

    if (SUCCEEDED(hr))
    {
        hr = IEnumHNetIcsPublicConnections_Next(
                pEnumIcsPub,
                1,
                &pIcsPub,
                &ulCount
                );

        IEnumHNetIcsPublicConnections_Release(pEnumIcsPub);
    }

    if (SUCCEEDED(hr) && 1 == ulCount)
    {
        hr = IHNetIcsPublicConnection_QueryInterface(
                pIcsPub,
                &IID_IHNetConnection,
                (VOID**)&pConn
                );

        IHNetIcsPublicConnection_Release(pIcsPub);
    }
    else
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        HNET_CONN_PROPERTIES *pProps;
        
        //
        // Convert the IHNetConnection to a RASSHARECONN
        //

        hr = IHNetConnection_GetProperties(pConn, &pProps);

        if (SUCCEEDED(hr) && pProps->fLanConnection)
        {
            GUID *pGuid;
        
            g_pCoTaskMemFree(pProps);
            hr = IHNetConnection_GetGuid(pConn, &pGuid);

            if (SUCCEEDED(hr))
            {
                RasGuidToSharedConnection(pGuid, Connection);
                g_pCoTaskMemFree(pGuid);
            }
        }
        else if (SUCCEEDED(hr))
        {
            LPWSTR pszwName;
            LPWSTR pszwPath;
            
            g_pCoTaskMemFree(pProps);

            hr = IHNetConnection_GetName(pConn, &pszwName);

            if (SUCCEEDED(hr))
            {
                hr = IHNetConnection_GetRasPhonebookPath(pConn, &pszwPath);

                if (SUCCEEDED(hr))
                {
                    RasEntryToSharedConnection(pszwPath, pszwName, Connection);

                    g_pCoTaskMemFree(pszwPath);
                }

                g_pCoTaskMemFree(pszwName);
            }
        }

        IHNetConnection_Release(pConn);
    }

    if (fUninitializeCOM)
    {
        g_pCoUninitialize();
    }

    return SUCCEEDED(hr) ? NO_ERROR : ERROR_CAN_NOT_COMPLETE;

} // CsQuerySharedConnection

#if 0


ULONG
CsQuerySharedPrivateLan(
    GUID* LanGuid
    )

/*++

Routine Description:

    This routine is invoked to retrieve the private LAN connection, if any.

Arguments:

    LanGuid - receives the retrieved GUID.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    HANDLE Key;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    //
    // Open the 'SharedAccess\Parameters' key, read the 'SharedPrivateLan'
    // value, and convert it to a GUID
    //

    status = CsOpenKey(&Key, KEY_READ, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(status)) {
        TRACE1("CsQuerySharedPrivateLan: NtOpenKey=%x", status);
        return RtlNtStatusToDosError(status);
    }

    status = CsQueryValueKey(Key, c_szSharedPrivateLan, &Information);
    NtClose(Key);
    if (!NT_SUCCESS(status)) { return NO_ERROR; }

    RtlInitUnicodeString(&UnicodeString, (PWCHAR)Information->Data);
    status = RtlGUIDFromString(&UnicodeString, LanGuid);
    Free(Information);
    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // CsQuerySharedPrivateLan


ULONG
CsQuerySharedPrivateLanAddress(
    PULONG Address
    )

/*++

Routine Description:

    This routine is invoked to retrieve the IP address assigned
    to the shared private LAN interface.

Arguments:

    Address - on output, receives the IP address of the shared private LAN
        interface.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG AdapterIndex;
    PALLOCATEANDGETIPADDRTABLEFROMSTACK AllocateAndGetIpAddrTableFromStack;
    ULONG Error;
    PGETINTERFACEINFO GetInterfaceInfo;
    HINSTANCE Hinstance;
    ULONG i;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    HANDLE Key = NULL;
    NTSTATUS status;
    PMIB_IPADDRTABLE Table;

    if (!Address) { return ERROR_INVALID_PARAMETER; }

    //
    // Open the service's Parameters key and attempt to retrieve
    // the GUID for the shared private LAN interface.
    //

    status = CsOpenKey(&Key, KEY_READ, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(status)) {
        TRACE1("CsQuerySharedPrivateLanAddress: NtOpenKey=%x", status);
        return RtlNtStatusToDosError(status);
    }
    status = CsQueryValueKey(Key, c_szSharedPrivateLan, &Information);
    NtClose(Key);
    if (!NT_SUCCESS(status)) { return ERROR_SHARING_NO_PRIVATE_LAN; }

    //
    // Load IPHLPAPI, which contains the 'GetInterfaceInfo' entrypoint
    // that we will use to map this GUID to an adapter-index,
    // as well as the 'AllocateAndGetIpAddrTableFromStack' entrypoint
    // that we will use to map the adapter-index to an IP address list.
    //

    if (!(Hinstance = LoadLibraryW(c_szIphlpapiDll)) ||
        !(AllocateAndGetIpAddrTableFromStack =
            (PALLOCATEANDGETIPADDRTABLEFROMSTACK)
                GetProcAddress(
                    Hinstance, c_szAllocateAndGetIpAddrTableFromStack
                    )) ||
        !(GetInterfaceInfo =
            (PGETINTERFACEINFO)
                GetProcAddress(
                    Hinstance, c_szGetInterfaceInfo
                    ))) {
        if (Hinstance) { FreeLibrary(Hinstance); }
        Free(Information);
        return ERROR_PROC_NOT_FOUND;
    }

    //
    // Map the GUID to an adapter index.
    //

    AdapterIndex =
        CsMapGuidToAdapterIndex((PWCHAR)Information->Data, GetInterfaceInfo);
    Free(Information);
    if (AdapterIndex == (ULONG)-1) {
        FreeLibrary(Hinstance);
        return ERROR_SHARING_NO_PRIVATE_LAN;
    }

    //
    // Map the adapter index to an IP address
    //

    Error =
        AllocateAndGetIpAddrTableFromStack(
            &Table,
            FALSE,
            GetProcessHeap(),
            0
            );
    FreeLibrary(Hinstance);
    if (Error) { return Error; }
    for (i = 0; i < Table->dwNumEntries; i++) {
        if (AdapterIndex == Table->table[i].dwIndex) {
            break;
        }
    }
    if (i >= Table->dwNumEntries) {
        Error = ERROR_SHARING_NO_PRIVATE_LAN;
    } else {
        *Address = Table->table[i].dwAddr;
    }
    HeapFree(GetProcessHeap(), 0, Table);
    return Error;

} // CsQuerySharedPrivateLanAddress

#endif


NTSTATUS
CsQueryValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    )

/*++

Routine Description:

    This routine is called to obtain the value of a registry key.

Arguments:

    Key - the key to be queried

    ValueName - the value to be queried

    Information - receives a pointer to the information read

Return Value:

    NTSTATUS - NT status code.

--*/

{
    UCHAR Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)];
    ULONG InformationLength;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString(&UnicodeString, ValueName);

    *Information = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
    InformationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION);

    //
    // Read the value's size
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );

    if (!NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        *Information = NULL;
        return status;
    }

    //
    // Allocate space for the value's size
    //

    *Information = (PKEY_VALUE_PARTIAL_INFORMATION)Malloc(InformationLength+2);
    if (!*Information) { return STATUS_NO_MEMORY; }

    //
    // Read the value's data
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );
    if (!NT_SUCCESS(status)) { Free(*Information); *Information = NULL; }
    return status;

} // CsQueryValueKey

#if 0


ULONG
CsRenameSharedConnection(
    LPRASSHARECONN NewConnection
    )

/*++

Routine Description:

    This routine is invoked to change the name of the currently-shared
    connection, if any. It is assumed that the private LAN will remain
    unchanged, and that the connection which is currently shared is a dialup
    connection.

Arguments:

    NewConnection - the new name for the shared connection

Return Value:

    ULONG - Win32 status code.

--*/

{
    HANDLE AdminHandle;
    PUCHAR Buffer;
    LPRASSHARECONN OldConnection;
    ULONG Error;
    PUCHAR Header;
    HANDLE Key;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    HANDLE InterfaceHandle;
    ULONG Length;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ServerHandle;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    //
    // Open the 'SharedAccess\Parameters' key,
    // and read the 'SharedConnection' value
    //

    status = CsOpenKey(&Key, KEY_READ, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(status)) {
        TRACE1("CsRenameSharedConnection: NtOpenKey=%x", status);
        return RtlNtStatusToDosError(status);
    }

    status = CsQueryValueKey(Key, c_szSharedConnection, &Information);
    NtClose(Key);
    if (!NT_SUCCESS(status)) { return NO_ERROR; }

    //
    // Validate the data retrieved
    //

    if (Information->DataLength != sizeof(RASSHARECONN) ||
        ((LPRASSHARECONN)Information->Data)->dwSize != sizeof(RASSHARECONN)
        ) {
        TRACE2(
            "CsRenameSharedConnection: invalid length %d (size=%d) in registry",
            Information->DataLength, ((LPRASSHARECONN)Information->Data)->dwSize
            );
        Free(Information); return NO_ERROR;
    }

    //
    // Ensure that the connection which was shared is not a LAN connection,
    // and if so proceed to share the new connection instead.
    //

    OldConnection = (LPRASSHARECONN)Information->Data;
    if (OldConnection->fIsLanConnection) {
        TRACE("CsRenameSharedConnection: cannot rename shared LAN connection");
        Free(Information); return ERROR_INVALID_PARAMETER;
    }

    //
    // Clear any cached credentials for the old connection,
    // and share the new connection.
    //

    RasSetSharedConnectionCredentials(OldConnection, NULL);
    Free(Information);
    
    return CsShareConnection(NewConnection);

} // CsRenameSharedConnection


ULONG
CsSetupSharedPrivateLan(
    REFGUID LanGuid,
    BOOLEAN EnableSharing
    )

/*++

Routine Description:

    This routine is invoked to configure the designated private connection.

Arguments:

    LanGuid - identifies the LAN connection to be configured

    EnableSharing - if TRUE, sharing is enabled and the static address is set;
        otherwise, sharing is disabled.

Return Value:

    ULONG - Win32 status code.

--*/

{
    CS_ADDRESS_INFORMATION AddressInformation;
    PALLOCATEANDGETIPADDRTABLEFROMSTACK AllocateAndGetIpAddrTableFromStack;
    ANSI_STRING AnsiString;
    ULONG Error;
    PGETINTERFACEINFO GetInterfaceInfo;
    HINSTANCE Hinstance;
    ULONG i;
    HANDLE Key = NULL;
    UNICODE_STRING LanGuidString;
    ULONG ScopeAddress;
    ULONG ScopeMask;
    PSETADAPTERIPADDRESS SetAdapterIpAddress;
    ULONG Size;
    NTSTATUS status;
    PMIB_IPADDRTABLE Table;
    UNICODE_STRING UnicodeString;

    //
    // To install or remove the static private IP address,
    // we make use of several entrypoints in IPHLPAPI.DLL,
    // which we now load dynamically.
    //

    RtlStringFromGUID(LanGuid, &UnicodeString);
    RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);
    if (!(Hinstance = LoadLibraryW(c_szIphlpapiDll)) ||
        !(AllocateAndGetIpAddrTableFromStack =
            (PALLOCATEANDGETIPADDRTABLEFROMSTACK)
                GetProcAddress(
                    Hinstance, c_szAllocateAndGetIpAddrTableFromStack
                    )) ||
        !(GetInterfaceInfo =
            (PGETINTERFACEINFO)
                GetProcAddress(
                    Hinstance, c_szGetInterfaceInfo
                    )) ||
        !(SetAdapterIpAddress =
            (PSETADAPTERIPADDRESS)
                GetProcAddress(
                    Hinstance, c_szSetAdapterIpAddress
                    ))) {
        if (Hinstance) { FreeLibrary(Hinstance); }
        RtlFreeUnicodeString(&UnicodeString);
        RtlFreeAnsiString(&AnsiString);
        return ERROR_PROC_NOT_FOUND;
    }

    //
    // Determine whether some LAN adapter other than the private LAN
    // is already using a 169.254.0.0 address.
    // In the process, make sure that the private LAN has only one
    // IP address (otherwise, 'SetAdapterIpAddress' fails.)
    //

    CsQueryScopeInformation(&Key, &ScopeAddress, &ScopeMask);
    if (!Key) {
        FreeLibrary(Hinstance);
        RtlFreeUnicodeString(&UnicodeString);
        RtlFreeAnsiString(&AnsiString);
        return ERROR_CAN_NOT_COMPLETE;
    }
    Error =
        AllocateAndGetIpAddrTableFromStack(
            &Table,
            FALSE,
            GetProcessHeap(),
            0
            );
    if (!Error) {
        ULONG Index;
        ULONG Count;
        Index = CsMapGuidToAdapterIndex(UnicodeString.Buffer, GetInterfaceInfo);
        for (i = 0, Count = 0; i < Table->dwNumEntries; i++) {
            if (Index == Table->table[i].dwIndex) {
                ++Count;
            } else if ((Table->table[i].dwAddr & ScopeMask) ==
                       (ScopeAddress & ScopeMask)) {
                //
                // It appears that some other LAN adapter has an address in
                // the proposed scope.
                // This may happen when multiple netcards go into autonet mode
                // or when the RAS server is handing out autonet addresses.
                // Therefore, as long as we're using the autonet scope,
                // allow this behavior; otherwise prohibit it.
                //
                if ((ScopeAddress & ScopeMask) != 0x0000fea9) {
                    break;
                }
            }
        }
        if (i < Table->dwNumEntries) {
            Error = ERROR_SHARING_ADDRESS_EXISTS;
        } else if (Count > 1) {
            Error = ERROR_SHARING_MULTIPLE_ADDRESSES;
        }
        HeapFree(GetProcessHeap(), 0, Table);
    }

    if (Error) {
        FreeLibrary(Hinstance);
        RtlFreeUnicodeString(&UnicodeString);
        RtlFreeAnsiString(&AnsiString);
        NtClose(Key);
        return Error;
    }

    //
    // Set the predefined static IP address for the private LAN,
    // which we now read either from the registry or from the internal default.
    //
    // Before actually making the change, we capture the original IP address
    // so that it can be restored when the user turns off shared access.
    // Once the IP address is changed, we backup the original IP address
    // in the shared access parameters key.
    //

    status =
        CspCaptureAddressInformation(
            UnicodeString.Buffer, &AddressInformation
            );

    Error =
        SetAdapterIpAddress(
            AnsiString.Buffer,
            FALSE,
            ScopeAddress,
            ScopeMask,
            0
            );
    if (!Error) {
        if (NT_SUCCESS(status)) {
            CspBackupAddressInformation(Key, &AddressInformation);
        }
    } else {
        TRACE1("CsSetupSharedPrivateLan: SetAdapterIpAddress=%d", Error);
        if (Error == ERROR_TOO_MANY_NAMES) {
            Error = ERROR_SHARING_MULTIPLE_ADDRESSES;
        } else {
            //
            // Query the state of the connection.
            // If it is disconnected, convert the error code
            // to something more informative.
            //
            UNICODE_STRING DeviceString;
            NIC_STATISTICS NdisStatistics;
            RtlInitUnicodeString(&DeviceString, c_szDevice);
            RtlAppendUnicodeStringToString(&DeviceString, &UnicodeString);
            NdisStatistics.Size = sizeof(NdisStatistics);
            NdisQueryStatistics(&DeviceString, &NdisStatistics);
            RtlFreeUnicodeString(&DeviceString);
            if  (NdisStatistics.MediaState == MEDIA_STATE_UNKNOWN) {
                Error = ERROR_SHARING_HOST_ADDRESS_CONFLICT;
            } else if (NdisStatistics.DeviceState != DEVICE_STATE_CONNECTED ||
                NdisStatistics.MediaState != MEDIA_STATE_CONNECTED) {
                Error = ERROR_SHARING_NO_PRIVATE_LAN;
            }
        }
    }

    CspCleanupAddressInformation(&AddressInformation);
    FreeLibrary(Hinstance);
    RtlFreeUnicodeString(&UnicodeString);
    RtlFreeAnsiString(&AnsiString);
    if (Error) { NtClose(Key); return Error; }

    //
    // All went well above; now we save the name of the private LAN connection
    // under the 'SharedAccess\\Parameters' registry key.
    //

    RtlStringFromGUID(LanGuid, &LanGuidString);
    RtlInitUnicodeString(&UnicodeString, c_szSharedPrivateLan);
    status =
        NtSetValueKey(
            Key,
            &UnicodeString,
            0,
            REG_SZ,
            LanGuidString.Buffer,
            LanGuidString.Length + sizeof(WCHAR)
            );
    NtClose(Key);
    RtlFreeUnicodeString(&LanGuidString);
    if (!NT_SUCCESS(status)) { return RtlNtStatusToDosError(status); }
    return NO_ERROR;

} // CsSetupSharedPrivateLan


ULONG
CsSetSharedPrivateLan(
    REFGUID LanGuid
    )

/*++

Routine Description:

    This routine is invoked to (re)configure the designated private connection

Arguments:

    LanGuid - identifies the new LAN connection to be configured

Return Value:

    ULONG - Win32 status code.

--*/

{
    HANDLE Key;
    ULONG Error;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    UNICODE_STRING UnicodeString;

    status = CsOpenKey(&Key, KEY_ALL_ACCESS, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(status)) {
        TRACE1("CsSetSharedPrivateLan: CsOpenKey=%x", status);
        return RtlNtStatusToDosError(status);
    }

    //
    // Remove old information (and reset old interface) in registry if present
    //
    
    status = CsQueryValueKey(Key, c_szSharedPrivateLan, &Information);
    RtlInitUnicodeString(&UnicodeString, c_szSharedPrivateLan);
    NtDeleteValueKey(Key, &UnicodeString);
    if (NT_SUCCESS(status)) {
        CspRestoreAddressInformation(Key, (PWCHAR)Information->Data);
        Free(Information);
    }

    //
    // Setup the private network with a private address
    //

    Error = CsSetupSharedPrivateLan(LanGuid, TRUE);
    if (Error) {
        TRACE1("CsSetSharedPrivateLan: CsSetupSharedPrivateLan=%d",Error);
        return Error;
    }

    return NO_ERROR;
    
} // CsSetSharedPrivateLan


ULONG
CsShareConnection(
    LPRASSHARECONN Connection
    )

/*++

Routine Description:

    This routine enables sharing on the connection with the given name.
    
Arguments:

    Connection - the connection to be shared

Return Value:

    ULONG - Win32 status code.

--*/

{
    UNICODE_STRING BindList;
    HANDLE Key;
    UNICODE_STRING LowerComponent;
    IP_PNP_RECONFIG_REQUEST Request;
    NTSTATUS status;
    UNICODE_STRING UpperComponent;
    ULONG Value;
    UNICODE_STRING ValueString;

    //
    // Set the 'SharedConnection' value in the registry,
    // under the 'SharedAccess\Parameters' key.
    //

    status = CsOpenKey(&Key, KEY_ALL_ACCESS, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(status)) {
        TRACE1("CsShareConnection: CsOpenKey=%x", status);
        return RtlNtStatusToDosError(status);
    }

    RtlInitUnicodeString(&ValueString, c_szSharedConnection);
    status =
        NtSetValueKey(
            Key,
            &ValueString,
            0,
            REG_BINARY,
            Connection,
            Connection->dwSize
            );
    
    NtClose(Key);
    if (!NT_SUCCESS(status)) {
        TRACE1("CsShareConnection: NtSetValueKey=%x", status);
        return RtlNtStatusToDosError(status);
    }

    return NO_ERROR;
    
} // CsShareConnection

#endif


VOID
CsShutdownModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to clean up state for the module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked with 'CsCriticalSection' held by the caller.

--*/

{
    if (CsInitialized) {
        if (CsOle32Dll) { FreeLibrary(CsOle32Dll); CsOle32Dll = NULL; }
    }
} // CsShutdownModule

#if 0


ULONG
CsStartService(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to start the routing and remote access service.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Revision History:

    Loosely based on CService::HrMoveOutOfState by KennT.

--*/

{
    ULONG Error;
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;
    ULONG Timeout;

    //
    // Connect to the service control manager
    //

    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (!ScmHandle) { return GetLastError(); }

    do {

        //
        // Open the shared access service
        //

        ServiceHandle =
            OpenService(ScmHandle, c_szSharedAccess, SERVICE_ALL_ACCESS);
        if (!ServiceHandle) { Error = GetLastError(); break; }

        //
        // Mark it as auto-start
        //

        ChangeServiceConfig(
            ServiceHandle,
            SERVICE_NO_CHANGE,
            SERVICE_AUTO_START,
            SERVICE_NO_CHANGE,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
            );

        //
        // Attempt to start the service
        //

        if (!StartService(ServiceHandle, 0, NULL)) {
            Error = GetLastError();
            if (Error == ERROR_SERVICE_ALREADY_RUNNING) { Error = NO_ERROR; }
            break;
        }

        //
        // Wait for the service to start
        //

        Timeout = 30;
        Error = ERROR_CAN_NOT_COMPLETE;

        do {

            //
            // Query the service's state
            //

            if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
                Error = GetLastError(); break;
            }

            //
            // See if the service has started
            //

            if (ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
                Error = NO_ERROR; break;
            } else if (ServiceStatus.dwCurrentState == SERVICE_STOPPED ||
                       ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) {
                break;
            }

            //
            // Wait a little longer
            //

            Sleep(1000);

        } while(Timeout--);

    } while(FALSE);

    if (ServiceHandle) { CloseServiceHandle(ServiceHandle); }
    CloseServiceHandle(ScmHandle);

    return Error;

} // CsStartService


VOID
CsStopService(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to uninstall the service.
    The routine, however, does not uninstall the service at all,
    which just goes to show you...
    Instead, it marks the service as demand-start.

Arguments:

    none.

Return Value:

    none.

--*/

{
    ULONG Error;
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    //
    // Connect to the service control manager
    //

    ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (!ScmHandle) { return; }

    do {

        //
        // Open the shared access service
        //

        ServiceHandle =
            OpenService(ScmHandle, c_szSharedAccess, SERVICE_ALL_ACCESS);
        if (!ServiceHandle) { Error = GetLastError(); break; }

        //
        // Mark it as demand-start
        //

        ChangeServiceConfig(
            ServiceHandle,
            SERVICE_NO_CHANGE,
            SERVICE_DEMAND_START,
            SERVICE_NO_CHANGE,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
            );

        //
        // Attempt to stop the service
        //

        ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);

    } while(FALSE);

    if (ServiceHandle) { CloseServiceHandle(ServiceHandle); }
    CloseServiceHandle(ScmHandle);

    return;


} // CsStopService


ULONG
CsUnshareConnection(
    BOOLEAN RemovePrivateLan,
    PBOOLEAN Shared
    )

/*++

Routine Description:

    This routine is invoked to unshare a shared connection.
    This is accomplished by removing the settings from the registry.

Arguments:

    RemovePrivateLan - if TRUE, the private LAN connection is reset
        to use DHCP rather than the NAT private address.

    Shared - receives 'TRUE' if a shared connection was found, FALSE otherwise.

Return Value:

    ULONG - Win32 status code.

--*/

{
    LPRASSHARECONN Connection;
    HANDLE Key;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    PIP_NAT_INTERFACE_INFO Info;
    GUID LanGuid;
    ULONG Length;
    ULONG Size;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    if (Shared) { *Shared = FALSE; }

    //
    // Open the 'SharedAccess\Parameters' key, read the 'SharedConnection'
    // value, and validate the information retrieved.
    //

    status = CsOpenKey(&Key, KEY_ALL_ACCESS, c_szSharedAccessParametersKey);
    if (!NT_SUCCESS(status)) {
        TRACE1("CsUnshareConnection: NtOpenKey=%x", status);
        return RtlNtStatusToDosError(status);
    }

    //
    // Read the 'SharedConnection' value
    //

    status = CsQueryValueKey(Key, c_szSharedConnection, &Information);
    if (!NT_SUCCESS(status)) { return NO_ERROR; }

    if (Information->DataLength != sizeof(RASSHARECONN) ||
        ((LPRASSHARECONN)Information->Data)->dwSize != sizeof(RASSHARECONN)) {
        TRACE2(
            "CsUnshareConnection: invalid length %d (size=%d) in registry",
            Information->DataLength, ((LPRASSHARECONN)Information->Data)->dwSize
            );
        NtClose(Key); Free(Information); return NO_ERROR;
    }

    //
    // Inform the caller that a connection was indeed originally shared,
    // clear any credentials cached for that connection, free the buffer
    // containing the shared connection's information, and delete the
    // 'SharedConnection' value from the registry.
    //

    if (Shared) { *Shared = TRUE; }
    Connection = (LPRASSHARECONN)Information->Data;
    RasSetSharedConnectionCredentials(Connection, NULL);

    Free(Information);
    RtlInitUnicodeString(&UnicodeString, c_szSharedConnection);
    NtDeleteValueKey(Key, &UnicodeString);

    //
    // See if we're resetting the private LAN connection,
    // and if so, read (and delete) the 'SharedPrivateLan' value.
    // In the process, restore the original address-information
    // for the connection.
    //

    if (RemovePrivateLan) {
        status = CsQueryValueKey(Key, c_szSharedPrivateLan, &Information);
        RtlInitUnicodeString(&UnicodeString, c_szSharedPrivateLan);
        NtDeleteValueKey(Key, &UnicodeString);
        if (NT_SUCCESS(status)) {
            CspRestoreAddressInformation(Key, (PWCHAR)Information->Data);
            Free(Information);
        }
    }

    NtClose(Key);
    return NO_ERROR;

} // CsUnshareConnection


WCHAR*
StrDupW(
    LPCWSTR psz
    )
{
    WCHAR* psz2 = Malloc((lstrlenW(psz) + 1) * sizeof(WCHAR));
    if (psz2) { lstrcpyW(psz2, psz); }
    return psz2;
}


VOID
TestBackupAddress(
    PWCHAR Guid
    )
{
    HANDLE Key;
    CS_ADDRESS_INFORMATION Information;
    NTSTATUS status;
    status = CspCaptureAddressInformation(Guid, &Information);
    if (NT_SUCCESS(status)) {
        status = CsOpenKey(&Key, KEY_ALL_ACCESS, c_szSharedAccessParametersKey);
        if (NT_SUCCESS(status)) {
            CspBackupAddressInformation(Key, &Information);
            NtClose(Key);
        }
        CspCleanupAddressInformation(&Information);
    }
}

VOID
TestRestoreAddress(
    PWCHAR Guid
    )
{
    HANDLE Key;
    NTSTATUS status;
    status = CsOpenKey(&Key, KEY_ALL_ACCESS, c_szSharedAccessParametersKey);
    if (NT_SUCCESS(status)) {
        status = CspRestoreAddressInformation(Key, Guid);
    }
}

VOID CsRefreshNetConnections(
    VOID
    )
{
    BOOL bUninitializeCOM = TRUE;
    HRESULT hResult;
    
    ASSERT(NULL != g_pCoInitializeEx);
    ASSERT(NULL != g_pCoCreateInstance);
    ASSERT(NULL != g_pCoUninitialize);
    
    hResult = g_pCoInitializeEx(NULL, COINIT_MULTITHREADED|COINIT_DISABLE_OLE1DDE); // we don't know if the thread is COM or not
    if(RPC_E_CHANGED_MODE == hResult)
    {
        hResult = S_OK;
        bUninitializeCOM = FALSE;
    }
    
    if (SUCCEEDED(hResult)) 
    {
        INetConnectionRefresh * pRefresh = NULL;
        hResult = g_pCoCreateInstance(&CLSID_ConnectionManager, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD, &IID_INetConnectionRefresh, (void**) &pRefresh);
        if(SUCCEEDED(hResult))
        {

            g_pCoSetProxyBlanket((IUnknown*) pRefresh, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,  RPC_C_AUTHN_LEVEL_CALL,  RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
            // ignore error as the interface is not invalidated by error
            
            hResult = INetConnectionRefresh_RefreshAll(pRefresh);
            INetConnectionRefresh_Release(pRefresh);
        }
        
        if(TRUE == bUninitializeCOM)
        {
            g_pCoUninitialize();
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\sharing\cstest.c ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    cstest.c

Abstract:

    This module contains code for testing connection-sharing setup.

Author:

    Abolade Gbadegesin (aboladeg)   23-Apr-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <tchar.h>
#include <winsock.h>

extern
DWORD
SetAdapterIpAddress(
    PCHAR AdapterName,
    BOOL EnableDhcp,
    ULONG IpAddress,
    ULONG SubnetMask,
    ULONG DefaultGateway
    );

#define ArgToSharedConnection(prsc) \
if (argc == 4) { \
    RasEntryToSharedConnection((PWCHAR)argv[2],(PWCHAR)argv[3],(prsc)); \
} else if (argc == 3) { \
    GUID _Guid; \
    UNICODE_STRING _us; \
    RtlInitUnicodeString(&_us, (PWCHAR)argv[2]); \
    RtlGUIDFromString(&_us, &_Guid); \
    RasGuidToSharedConnection(&_Guid,(prsc)); \
}

ULONG
inet_addrw(
    PWCHAR Address
    )
{
    CHAR String[32];
    wcstombs(String, Address, sizeof(String));
    return inet_addr(String);
}

VOID
DumpSharedAccessSettings(
    SAINFO* Info
    )
{
    SAAPPLICATION* Application;
    PLIST_ENTRY Link;
    SARESPONSE* Response;
    PLIST_ENTRY SavedLink;
    SASERVER* Server;

    for (Link = Info->ApplicationList.Flink; Link != &Info->ApplicationList;
         Link = Link->Flink) {
        Application = CONTAINING_RECORD(Link, SAAPPLICATION, Link);
        printf("[Application.%08x]\n", Application->Key);
        printf("Enabled=%d\n", Application->Enabled);
        printf("Title=%ls\n", Application->Title);
        printf("Protocol=%d\n", Application->Protocol);
        printf("Port=%d\n", ntohs(Application->Port));
        printf("ResponseList=");
        SavedLink = Link;
        Response = NULL;
        for (Link = Application->ResponseList.Flink;
             Link != &Application->ResponseList; Link = Link->Flink) {
            if (Response) { printf(","); }
            Response = CONTAINING_RECORD(Link, SARESPONSE, Link);
            printf("%d/%d", Response->Protocol, ntohs(Response->StartPort));
            if (Response->StartPort != Response->EndPort) {
                printf("-%d", ntohs(Response->EndPort));
            }
        }
        Link = SavedLink;
        printf("\n\n");
    }
    for (Link = Info->ServerList.Flink; Link != &Info->ServerList;
         Link = Link->Flink) {
        Server = CONTAINING_RECORD(Link, SASERVER, Link);
        printf("[Server.%08x]\n", Server->Key);
        printf("Enabled=%d\n", Server->Enabled);
        printf("Title=%ls\n", Server->Title);
        printf("Protocol=%d\n", Server->Protocol);
        printf("Port=%d\n", ntohs(Server->Port));
        printf("InternalName=%ls\n", Server->InternalName);
        printf("InternalPort=%d\n", ntohs(Server->InternalPort));
        printf(
            "ReservedAddress=%s\n",
            inet_ntoa(*(PIN_ADDR)&Server->ReservedAddress)
            );
        printf("\n");
    }
}

int __cdecl
wmain(
    int argc,
    wchar_t* argv[]
    )
{
    RASSHARECONN rsc;
    WSADATA wd;
    if (argc < 2) {
        printf("cstest 1 - CsQuerySharedPrivateLan\n");
        printf("cstest 2 {guid} - CsSetupSharedPrivateLan\n");
        printf("cstest 3 - CsStartService\n");
        printf("cstest 4 [{pbk,name} | {guid}] - RasIsSharedConnection\n");
        printf("cstest 5 - RasQuerySharedConnection\n");
        printf("cstest 6 [{pbk,name} | {guid}] - RasShareConnection\n");
        printf("cstest 7 - RasUnshareConnection\n");
        printf("cstest 8 {guid} {addr} {mask} {gway} - SetAdapterIpAddress\n");
        printf("cstest 9 {guid} - SetAdapterIpAddress\n");
        printf("cstest 10 {guid} - RasNameFromSharedConnection\n");
        printf("cstest 11 {bool} - RasLoadSharedAccessSettings\n");
        printf("cstest 12 {guid} - TestBackupAddress\n");
        printf("cstest 13 {guid} - TestRestoreAddress\n");
        printf("cstest 14 - CsQuerySharedPrivateLanAddress\n");
        printf("cstest 15 {guid} - RasSetSharedPrivateLan\n");
        return 0;
    }
    WSAStartup(MAKEWORD(2,2), &wd);
    CsDllMain(DLL_PROCESS_ATTACH);
    switch (_wtol(argv[1])) {
        case 1: {
            ULONG Error;
            GUID Guid;
            NTSTATUS status;
            UNICODE_STRING UnicodeString;
            Error = CsQuerySharedPrivateLan(&Guid);
            status = RtlStringFromGUID(&Guid, &UnicodeString);
            printf(
                "CsQuerySharedPrivateLan:e=%d,g=%ls\n",
                Error,
                NT_SUCCESS(status) ? UnicodeString.Buffer : L"{}"
                );
            if (NT_SUCCESS(status)) { RtlFreeUnicodeString(&UnicodeString); }
            break;
        }
        case 2: {
            GUID Guid;
            NTSTATUS status;
            UNICODE_STRING UnicodeString;
            RtlInitUnicodeString(&UnicodeString, (PWCHAR)argv[2]);
            status = RtlGUIDFromString(&UnicodeString, &Guid);
            if (!NT_SUCCESS(status)) {
                printf("RtlGUIDFromString:s=%08x\n", status);
            }
            else {
                printf(
                    "CsSetupSharedPrivateLan:e=%d\n",
                    CsSetupSharedPrivateLan(&Guid, TRUE)
                    );
            }
            break;
        }
        case 3: {
            printf("CsStartService:e=%d\n", CsStartService());
            break;
        }
        case 4: {
            ULONG Error;
            BOOL Shared;
            ArgToSharedConnection(&rsc);
            Error = RasIsSharedConnection(&rsc, &Shared);
            printf("RasIsSharedConnection:f=%d,e=%d\n", Shared, Error);
            break;
        }
        case 5: {
            ULONG Error;
            BOOL Shared;
            NTSTATUS status;
            UNICODE_STRING UnicodeString;
            Error = RasQuerySharedConnection(&rsc);
            if (Error) {
                printf("RasQuerySharedConnection:e=%d\n", Error);
            } else if (rsc.fIsLanConnection) {
                status = RtlStringFromGUID(&rsc.guid, &UnicodeString);
                printf(
                    "RasQuerySharedConnection:g=%ls,e=%d\n",
                    UnicodeString.Buffer, Error
                    );
                RtlFreeUnicodeString(&UnicodeString);
            } else {
                printf(
                    "RasQuerySharedConnection:en=%ls,e=%d\n",
                    rsc.name.szEntryName, Error
                    );
            }
            break;
        }
        case 6: {
            ArgToSharedConnection(&rsc);
            printf("RasShareConnection:e=%d\n", RasShareConnection(&rsc, NULL));
            break;
        }
        case 7: {
            ULONG Error;
            BOOL Shared;
            Error = RasUnshareConnection(&Shared);
            printf("RasUnshareConnection:e=%d,f=%d\n", Error, Shared);
            break;
        }
        case 8: {
            ULONG Error;
            ULONG Address = inet_addrw(argv[3]);
            ULONG Mask = inet_addrw(argv[4]);
            ULONG Gateway = inet_addrw(argv[5]);
            CHAR String[64];
            wcstombs(String, argv[2], sizeof(String));
            Error = SetAdapterIpAddress(String, FALSE, Address, Mask, Gateway);
            printf("SetAdapterIpAddress=%d\n", Error);
            break;
        }
        case 9: {
            ULONG Error;
            CHAR String[64];
            wcstombs(String, argv[2], sizeof(String));
            Error = SetAdapterIpAddress(String, TRUE, 0, 0, 0);
            printf("SetAdapterIpAddress=%d\n", Error);
            break;
        }
        case 10: {
            ULONG Error;
            LPWSTR pszwName;
            ArgToSharedConnection(&rsc);
            Error = RasNameFromSharedConnection(&rsc, &pszwName);
            printf("RasNameFromSharedConnection=%d,n=%ls\n", Error, pszwName);
            if (pszwName) { Free(pszwName); }
            break;
        }
        case 11: {
            BOOL EnabledOnly = (argc >= 3 ? (BOOL)!!_wtol(argv[2]) : FALSE);
            SAINFO* Info = RasLoadSharedAccessSettings(EnabledOnly);
            printf("RasLoadSharedAccessSettings=%p\n", Info);
            if (Info) {
                DumpSharedAccessSettings(Info);
                if (argc >= 4) {
                    RasSaveSharedAccessSettings(Info);
                }
                RasFreeSharedAccessSettings(Info);
            }
            break;
        }
        case 12: {
            TestBackupAddress(argv[2]);
            break;
        }
        case 13: {
            TestRestoreAddress(argv[2]);
            break;
        }
        case 14: {
            ULONG Address = 0;
            ULONG Error;
            Error = CsQuerySharedPrivateLanAddress(&Address);
            printf(
                "CsQuerySharedPrivateLanAddress=%s (%d)\n",
                inet_ntoa(*(PIN_ADDR)&Address), Error
                );
            break;
        }
        case 15: {
            GUID Guid;
            NTSTATUS status;
            UNICODE_STRING UnicodeString;
            RtlInitUnicodeString(&UnicodeString, (PWCHAR)argv[2]);
            status = RtlGUIDFromString(&UnicodeString, &Guid);
            if (!NT_SUCCESS(status)) {
                printf("RtlGUIDFromString:s=%08x\n", status);
            }
            else {
                printf(
                    "RasSetSharedPrivateLan:e=%d\n",
                    RasSetSharedPrivateLan(&Guid)
                    );
            }
            break;
        }
    }
    CsDllMain(DLL_PROCESS_DETACH);
    WSACleanup();
    return 0;
} // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\sharing\sainfo.c ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    sainfo.c

Abstract:

    This module contains code for managing shared access settings.

    Shared Access Settings are stored in a file and consist of a list
    of sections which correspond either to 'applications' or 'servers',
    and content indices which list all applications and servers in the file.
    E.g.
        [Contents.Application]
            <key>=1 ; Enabled
        [Contents.Server]
            <key>=1 ; Enabled

    An 'application' entry specifies parameters for a dynamic ticket
    which will allow the application to work through the NAT,
    by dynamically allowing an inbound secondary session.
    E.g.
        [Application.<key>]
            Title=DirectPlay
            Protocol=TCP
            Port=47624
            TcpResponseList=2300-2400
            UdpResponseList=2300-2400
            BuiltIn=1 ; optional flag, defaults to 0

    A 'server' entry specifies parameters for a static port mapping
    which will direct all sessions for a particular protocol and port
    to a particular internal machine.
    E.g.
        [Server.<key>]
            Title=WWW
            Protocol=TCP
            Port=80
            InternalName=MACHINENAME
            InternalPort=8080
            ReservedAddress=192.168.0.200
            BuiltIn=0 ; optional flag, defaults to 0

Author:

    Abolade Gbadegesin (aboladeg)   17-Oct-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <pbk.h>
#include <tchar.h>
#include <limits.h>

#define LSTRLEN(s) ((sizeof(s) / sizeof(TCHAR)) - 1)
#define HTONS(s) ((UCHAR)((s) >> 8) | ((UCHAR)(s) << 8))
#define HTONL(l) ((HTONS(l) << 16) | HTONS((l) >> 16))
#define NTOHS(s) HTONS(s)
#define NTOHL(l) HTONL(l)

#if 0

const TCHAR c_szApplication[] = TEXT("Application");
const TCHAR c_szBuiltIn[] = TEXT("BuiltIn");
const TCHAR c_szContents[] = TEXT("Contents");
const TCHAR c_szInternalName[] = TEXT("InternalName");
const TCHAR c_szInternalPort[] = TEXT("InternalPort");
const TCHAR c_szKeyFormat[] = TEXT("%08X");
#endif
const TCHAR c_szMaxResponseEntry[] = TEXT("65535-65535,");
#if 0
const TCHAR c_szPort[] = TEXT("Port");
const TCHAR c_szProtocol[] = TEXT("Protocol");
const TCHAR c_szReservedAddress[] = TEXT("ReservedAddress");
#endif
const TCHAR c_szResponseFormat1[] = TEXT("%d");
const TCHAR c_szResponseFormat2[] = TEXT("%d-%d");
#if 0
const TCHAR c_szSectionFormat[] = TEXT("%s.%s");
const TCHAR c_szServer[] = TEXT("Server");
const TCHAR c_szSharedAccessIni[] = TEXT("SharedAccess.ini");
const TCHAR c_szTagBuiltIn[] = TEXT("BuiltIn=");
const TCHAR c_szTagInternalName[] = TEXT("InternalName=");
const TCHAR c_szTagInternalPort[] = TEXT("InternalPort=");
const TCHAR c_szTagPort[] = TEXT("Port=");
const TCHAR c_szTagProtocol[] = TEXT("Protocol=");
const TCHAR c_szTagReservedAddress[] = TEXT("ReservedAddress=");
const TCHAR c_szTagTcpResponseList[] = TEXT("TcpResponseList=");
const TCHAR c_szTagTitle[] = TEXT("Title=");
const TCHAR c_szTagUdpResponseList[] = TEXT("UdpResponseList=");
const TCHAR c_szTCP[] = TEXT("TCP");
const TCHAR c_szTcpResponseList[] = TEXT("TcpResponseList");
const TCHAR c_szTitle[] = TEXT("Title");
const TCHAR c_szUDP[] = TEXT("UDP");
const TCHAR c_szUdpResponseList[] = TEXT("UdpResponseList");

//
// FORWARD DECLARATIONS
//

SAAPPLICATION*
LoadApplication(
    ULONG KeyValue,
    BOOL Enabled,
    const TCHAR* Path
    );

TCHAR*
LoadEntryList(
    const TCHAR* Path,
    const TCHAR* Section
    );

TCHAR*
LoadPath(
    VOID
    );

SASERVER*
LoadServer(
    ULONG KeyValue,
    BOOL Enabled,
    const TCHAR* Path
    );

LONG
Lstrcmpni(
    const TCHAR* String1,
    const TCHAR* String2,
    LONG Length
    );

TCHAR*
QueryEntryList(
    const TCHAR* EntryList,
    const TCHAR* Tag
    );

BOOL
SaveApplication(
    SAAPPLICATION* Application,
    const TCHAR* Path
    );

BOOL
SaveServer(
    SAINFO* Info,
    SASERVER* Server,
    const TCHAR* Path
    );

BOOL
WritePrivateProfileStringUTF8(
    const TCHAR* Section,
    const TCHAR* Key,
    const TCHAR* Value,
    const TCHAR* Path
    );


VOID APIENTRY
RasFreeSharedAccessSettings(
    IN SAINFO* Info
    )

/*++

Routine Description:

    Frees memory allocated for the contents of 'Info'.

Arguments:

    Info - the settings to be freed

Return Value:

    none.

--*/

{
    SAAPPLICATION* Application;
    PLIST_ENTRY Link;
    SASERVER* Server;
    TRACE("RasFreeSharedAccessSettings");

    while (!IsListEmpty(&Info->ApplicationList)) {
        Link = RemoveHeadList(&Info->ApplicationList);
        Application = CONTAINING_RECORD(Link, SAAPPLICATION, Link);
        FreeSharedAccessApplication(Application);
    }

    while (!IsListEmpty(&Info->ServerList)) {
        Link = RemoveHeadList(&Info->ServerList);
        Server = CONTAINING_RECORD(Link, SASERVER, Link);
        FreeSharedAccessServer(Server);
    }

    Free(Info);
} // RasFreeSharedAccessSettings


SAINFO* APIENTRY
RasLoadSharedAccessSettings(
    BOOL EnabledOnly
    )

/*++

Routine Description:

    Reads in the local shared access settings, returning an allocated
    'SAINFO' containing the settings retrieved.

Arguments:

    EnabledOnly - if TRUE, only the application-entries which are enabled
        are retrieved.

Return Value:

    SAINFO* - the settings retrieved

--*/

{
    SAAPPLICATION* Application;
    BOOL Enabled;
    SAINFO* Info;
    TCHAR* Key;
    TCHAR* KeyEnd;
    TCHAR* KeyList;
    ULONG KeyValue;
    TCHAR* Path;
    TCHAR SectionName[32];
    SASERVER* Server;
    TRACE("RasLoadSharedAccessSettings");

    //
    // Allocate and initialize the settings-structure
    //

    Info = (SAINFO*)Malloc(sizeof(SAINFO));
    if (!Info) { return NULL; }

    InitializeListHead(&Info->ApplicationList);
    InitializeListHead(&Info->ServerList);

    //
    // Read scope information from the registry
    //

    CsQueryScopeInformation(NULL, &Info->ScopeAddress, &Info->ScopeMask);

    //
    // Construct the path to the shared access information file,
    // and read the index of 'application' sections.
    // Each section should contain a valid application-description,
    // for which we construct a corresponding 'SAAPPLICATION' entry
    // in the application-list.
    //

    if (!(Path = LoadPath())) {
        RasFreeSharedAccessSettings(Info);
        return NULL;
    }

    wsprintf(SectionName, c_szSectionFormat, c_szContents, c_szApplication);

    if (KeyList = LoadEntryList(SectionName, Path)) {

        for (Key = KeyList; *Key; Key += lstrlen(Key) + 1) {

            //
            // Ensure the key is a valid hexadecimal integer,
            // and read the 'Enabled' setting which is its value.
            // N.B. if the entry is disabled and the caller only wants
            // enabled entries, exclude this one.
            //

            KeyValue = _tcstoul(Key, &KeyEnd, 16);
            if (*KeyEnd++ != TEXT('=')) {
                continue;
            } else if (!(Enabled = !!_ttol(KeyEnd)) && EnabledOnly) {
                continue;
            }

            //
            // Read in the corresponding 'Application.<key>' section.
            //

            Application = LoadApplication(KeyValue, Enabled, Path);
            if (Application) {
                InsertTailList(&Info->ApplicationList, &Application->Link);
            }
        }

        Free(KeyList);
    }

    //
    // Finally, read the index of 'server' sections, and read each section.
    // Each section contains a server-description for which we construct
    // a corresponding 'SASERVER' entry in the server-list.
    //

    wsprintf(SectionName, c_szSectionFormat, c_szContents, c_szServer);

    if (KeyList = LoadEntryList(SectionName, Path)) {

        for (Key = KeyList; *Key; Key += lstrlen(Key) + 1) {

            //
            // Ensure the key is a valid hexadecimal integer,
            // and read the 'Enabled' setting which is its value.
            // N.B. if the entry is disabled and the caller only wants
            // enabled entries, exclude this one.
            //

            KeyValue = _tcstoul(Key, &KeyEnd, 16);
            if (*KeyEnd++ != TEXT('=')) {
                continue;
            } else if (!(Enabled = !!_ttol(KeyEnd)) && EnabledOnly) {
                continue;
            }

            //
            // Read in the corresponding 'Server.<key>' section.
            //

            Server = LoadServer(KeyValue, Enabled, Path);
            if (Server) {
                InsertTailList(&Info->ServerList, &Server->Link);
            }
        }

        Free(KeyList);
    }

    return Info;

} // RasLoadSharedAccessSettings


BOOL APIENTRY
RasSaveSharedAccessSettings(
    IN SAINFO* Info
    )

/*++

Routine Description:

    Stores the shared access settings in 'Info' back into the local registry
    from where the settings were read.

    N.B. If 'Info' was loaded with the 'EnableOnly' flag, saving it back
    will erase all disabled entries.

Arguments:

    Info - supplies the settings to be saved

Return Value:

    BOOL - TRUE if successful, FALSE otherwise.

--*/

{
    SAAPPLICATION* Application;
    TCHAR Buffer[10];
    PLIST_ENTRY Link;
    TCHAR Key[10];
    TCHAR* Path;
    TCHAR SectionName[32];
    SASERVER* Server;

    TRACE("RasSaveSharedAccessSettings");

    //
    // First erase the existing file.
    //

    if (!(Path = LoadPath()) || CreateDirectoriesOnPath(Path, NULL)) {
        Free0(Path);
        return FALSE;
    }

    DeleteFile(Path);

    //
    // Now we reconstruct the file.
    // We begin by saving each application entry, in the process building
    // a content index of all the saved entries.
    //

    wsprintf(SectionName, c_szSectionFormat, c_szContents, c_szApplication);

    for (Link = Info->ApplicationList.Flink; Link != &Info->ApplicationList;
         Link = Link->Flink) {
        Application = CONTAINING_RECORD(Link, SAAPPLICATION, Link);
        if (SaveApplication(Application, Path)) {
            wsprintf(Key, c_szKeyFormat, Application->Key);
            _ltot(!!Application->Enabled, Buffer, 10);
            WritePrivateProfileStringUTF8(
                SectionName,
                Key,
                Buffer,
                Path
                );
        }
    }

    //
    // Similarly, save each server entry, in the process building
    // a content index of all the saved entries.
    //

    wsprintf(SectionName, c_szSectionFormat, c_szContents, c_szServer);

    for (Link = Info->ServerList.Flink; Link != &Info->ServerList;
         Link = Link->Flink) {
        Server = CONTAINING_RECORD(Link, SASERVER, Link);
        if (SaveServer(Info, Server, Path)) {
            wsprintf(Key, c_szKeyFormat, Server->Key);
            _ltot(!!Server->Enabled, Buffer, 10);
            WritePrivateProfileStringUTF8(
                SectionName,
                Key,
                Buffer,
                Path
                );
        }
    }

    Free(Path);
    CsControlService(IPNATHLP_CONTROL_UPDATE_SETTINGS);
    return TRUE;
} // RasSaveSharedAccessSettings


VOID APIENTRY
FreeSharedAccessApplication(
    SAAPPLICATION* Application
    )
{
    PLIST_ENTRY Link;
    SARESPONSE* Response;
    while (!IsListEmpty(&Application->ResponseList)) {
        Link = RemoveHeadList(&Application->ResponseList);
        Response = CONTAINING_RECORD(Link, SARESPONSE, Link);
        Free(Response);
    }
    Free0(Application->Title);
    Free(Application);
}


VOID APIENTRY
FreeSharedAccessServer(
    SASERVER* Server
    )
{
    Free0(Server->Title);
    Free0(Server->InternalName);
    Free(Server);
}


SAAPPLICATION*
LoadApplication(
    ULONG KeyValue,
    BOOL Enabled,
    const TCHAR* Path
    )
{
    SAAPPLICATION* Application;
    TCHAR* EntryList;
    TCHAR Key[10];
    TCHAR SectionName[32];
    TCHAR* Value;

    wsprintf(Key, c_szKeyFormat, KeyValue);
    wsprintf(SectionName, c_szSectionFormat, c_szApplication, Key);
    if (!(EntryList = LoadEntryList(SectionName, Path))) { return NULL; }

    do {

        //
        // Allocate and initialize an 'application' entry.
        //

        Application = (SAAPPLICATION*)Malloc(sizeof(SAAPPLICATION));
        if (!Application) { break; }

        ZeroMemory(Application, sizeof(*Application));
        InitializeListHead(&Application->ResponseList);
        Application->Key = KeyValue;
        Application->Enabled = Enabled;

        //
        // Read each required '<tag>=<value>' entry in the section.
        // The tags required for an application are
        //      'Title='
        //      'Protocol='
        //      'Port='
        // The optional tags, at least one of which must be present, are
        //      'TcpResponseList='
        //      'UdpResponseList='
        // The optional tags which may be absent are
        //      'BuiltIn='
        //

        Value = QueryEntryList(EntryList, c_szTagTitle);
        if (!Value) { break; }
        Application->Title = StrDup(Value);

        Value = QueryEntryList(EntryList, c_szTagProtocol);
        if (!Value) { break; }
        if (!Lstrcmpni(Value, c_szTCP, LSTRLEN(c_szTCP))) {
            Application->Protocol = NAT_PROTOCOL_TCP;
        } else if (!Lstrcmpni(Value, c_szUDP, LSTRLEN(c_szTCP))) {
            Application->Protocol = NAT_PROTOCOL_UDP;
        } else {
            break;
        }

        Value = QueryEntryList(EntryList, c_szTagPort);
        if (!Value || !(Application->Port = (USHORT)_ttol(Value))) { break; }
        Application->Port = HTONS(Application->Port);

        Value = QueryEntryList(EntryList, c_szTagTcpResponseList);
        if (Value) {
            SharedAccessResponseStringToList(
                NAT_PROTOCOL_TCP,
                Value,
                &Application->ResponseList
                );
        }
        Value = QueryEntryList(EntryList, c_szTagUdpResponseList);
        if (Value) {
            SharedAccessResponseStringToList(
                NAT_PROTOCOL_UDP,
                Value,
                &Application->ResponseList
                );
        }
        if (IsListEmpty(&Application->ResponseList)) { break; }

        Value = QueryEntryList(EntryList, c_szTagBuiltIn);
        if (Value) {
            Application->BuiltIn = _ttol(Value) ? TRUE : FALSE;
        } else {
            Application->BuiltIn = FALSE;
        }

        //
        // The entry was loaded successfully.
        //

        Free(EntryList);
        return Application;

    } while (FALSE);

    //
    // Something went wrong.
    //

    if (Application) { FreeSharedAccessApplication(Application); }
    Free(EntryList);
    return NULL;
}


TCHAR*
LoadEntryList(
    const TCHAR* Section,
    const TCHAR* Path
    )
{
    CHAR* BufferA = NULL;
    ULONG Length;
    CHAR* PathA = NULL;
    CHAR* SectionA = NULL;
    ULONG Size;
    CHAR* Source;
    TCHAR* Target;
    TCHAR* BufferW = NULL;

    if (!(SectionA = StrDupAFromT(Section))) {
        return NULL;
    }
    if (!(PathA = StrDupAFromTAnsi(Path))) {
        Free(SectionA);
        return NULL;
    }
    for (BufferA = NULL, Size = MAX_PATH; ; Size += MAX_PATH, Free(BufferA)) {

        BufferA = (CHAR*)Malloc(Size);
        if (!BufferA) {
            break;
        }

        if (GetPrivateProfileSectionA(SectionA, BufferA, Size, PathA)
                == Size-2) {
            continue;
        }

        //
        // Convert each string in the buffer from UTF8 format to Unicode.
        // The conversion will result in at most 'Size' Unicode characters,
        // and fewer if 2- or 3-byte UTF8 sequences are present in the
        // source buffer.
        //

        BufferW = (TCHAR*)Malloc(Size * sizeof(TCHAR));
        if (!BufferW) {
            break;
        }
        Target = BufferW;
        for (Source = BufferA; *Source; Source += lstrlenA(Source) + 1) {
            if (StrCpyWFromA(Target, Source, Size) != NO_ERROR) {
                break;
            }
            Length = lstrlen(Target) + 1;
            Target += Length;
            Size -= Length;
        }
        if (*Source) { break; }
        Free(BufferA);
        Free(PathA);
        Free(SectionA);
        return BufferW;
    }
    Free0(BufferW);
    Free0(BufferA);
    Free0(PathA);
    Free0(SectionA);
    return NULL;
}


TCHAR*
LoadPath(
    VOID
    )
{
    TCHAR* Path;
    Path =
        (TCHAR*)Malloc(
            (MAX_PATH + lstrlen(c_szSharedAccessIni) + 1) * sizeof(TCHAR)
            );
    if (!Path || !GetPhonebookDirectory(PBM_System, Path)) {
        Free0(Path);
        return NULL;
    }

    lstrcat(Path, c_szSharedAccessIni);
    return Path;
}


SASERVER*
LoadServer(
    ULONG KeyValue,
    BOOL Enabled,
    const TCHAR* Path
    )
{
    SASERVER* Server;
    TCHAR* EntryList;
    TCHAR Key[10];
    TCHAR SectionName[32];
    TCHAR* Value;

    wsprintf(Key, c_szKeyFormat, KeyValue);
    wsprintf(SectionName, c_szSectionFormat, c_szServer, Key);
    if (!(EntryList = LoadEntryList(SectionName, Path))) { return NULL; }

    do {

        //
        // Allocate and initialize a 'server' entry.
        //

        Server = (SASERVER*)Malloc(sizeof(SASERVER));
        if (!Server) { break; }

        ZeroMemory(Server, sizeof(*Server));
        Server->Key = KeyValue;
        Server->Enabled = Enabled;

        //
        // Read each required '<tag>=<value>' entry in the section.
        // The tags required for a server are
        //      'Title='
        //      'Protocol='
        //      'Port='
        //      'InternalPort='
        // The optional tags which may be absent are
        //      'BuiltIn='
        //      'InternalName='
        //      'ReservedAddress='
        // The 'InternalName=' and 'ReservedAddress=' tags may only be absent
        // if 'BuiltIn' is set, in which case the entry is disabled.
        //

        Value = QueryEntryList(EntryList, c_szTagTitle);
        if (!Value) { break; }
        Server->Title = StrDup(Value);

        Value = QueryEntryList(EntryList, c_szTagProtocol);
        if (!Value) { break; }
        if (!Lstrcmpni(Value, c_szTCP, LSTRLEN(c_szTCP))) {
            Server->Protocol = NAT_PROTOCOL_TCP;
        } else if (!Lstrcmpni(Value, c_szUDP, LSTRLEN(c_szTCP))) {
            Server->Protocol = NAT_PROTOCOL_UDP;
        } else {
            break;
        }

        Value = QueryEntryList(EntryList, c_szTagPort);
        if (!Value || !(Server->Port = (USHORT)_ttol(Value))) { break; }
        Server->Port = HTONS(Server->Port);

        Value = QueryEntryList(EntryList, c_szTagInternalPort);
        if (!Value || !(Server->InternalPort = (USHORT)_ttol(Value))) { break; }
        Server->InternalPort = HTONS(Server->InternalPort);

        Value = QueryEntryList(EntryList, c_szTagBuiltIn);
        if (Value) {
            Server->BuiltIn = _ttol(Value) ? TRUE : FALSE;
        } else {
            Server->BuiltIn = FALSE;
        }

        Value = QueryEntryList(EntryList, c_szTagInternalName);
        if (!Value || !lstrlen(Value)) {
            if (!Server->BuiltIn) {
                break;
            } else {
                Server->InternalName = NULL;
                Server->Enabled = FALSE;
            }
        } else {
            Server->InternalName = StrDup(Value);
        }

        Value = QueryEntryList(EntryList, c_szTagReservedAddress);
        if (!Value || !lstrlen(Value)) {
            if (!Server->BuiltIn) {
                break;
            } else {
                Server->ReservedAddress = INADDR_NONE;
                Server->Enabled = FALSE;
            }
        } else {
            Server->ReservedAddress = IpPszToHostAddr(Value);
            if (Server->ReservedAddress == INADDR_NONE && !Server->BuiltIn) {
                break;
            }
            Server->ReservedAddress = HTONL(Server->ReservedAddress);
        }

        //
        // The entry was loaded successfully.
        //

        Free(EntryList);
        return Server;

    } while (FALSE);

    //
    // Something went wrong.
    //

    if (Server) { FreeSharedAccessServer(Server); }
    Free(EntryList);
    return NULL;
}


LONG
Lstrcmpni(
    const TCHAR* String1,
    const TCHAR* String2,
    LONG Length
    )
{
    return
        CSTR_EQUAL -
        CompareString(
            LOCALE_SYSTEM_DEFAULT,
            NORM_IGNORECASE,
            String1,
            Length,
            String2,
            Length
            );
}


TCHAR*
QueryEntryList(
    const TCHAR* EntryList,
    const TCHAR* Tag
    )
{
    TCHAR* Entry;
    ULONG TagLength = lstrlen(Tag);
    for (Entry = (TCHAR*)EntryList; *Entry; Entry += lstrlen(Entry) + 1) {
        if (Entry[0] == Tag[0] && !Lstrcmpni(Tag, Entry, TagLength)) {
            return Entry + TagLength;
        }
    }
    return NULL;
}


BOOL
SaveApplication(
    SAAPPLICATION* Application,
    const TCHAR* Path
    )
{
    TCHAR Buffer[32];
    ULONG Length;
    PLIST_ENTRY Link;
    SARESPONSE* Response;
    TCHAR SectionName[32];
    TCHAR* Value;

    wsprintf(Buffer, c_szKeyFormat, Application->Key);
    wsprintf(SectionName, c_szSectionFormat, c_szApplication, Buffer);

    WritePrivateProfileStringUTF8(
        SectionName,
        c_szTitle,
        Application->Title,
        Path
        );

    if (Application->Protocol == NAT_PROTOCOL_TCP) {
        Value = (TCHAR*)c_szTCP;
    } else if (Application->Protocol == NAT_PROTOCOL_UDP) {
        Value = (TCHAR*)c_szUDP;
    } else {
        return FALSE;
    }
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szProtocol,
        Value,
        Path
        );

    _ltot(NTOHS(Application->Port), Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szPort,
        Buffer,
        Path
        );

    Value = SharedAccessResponseListToString(&Application->ResponseList, NAT_PROTOCOL_TCP);
    if (Value) {
        WritePrivateProfileStringUTF8(
            SectionName,
            c_szTcpResponseList,
            Value,
            Path
            );
        Free(Value);
    }

    Value = SharedAccessResponseListToString(&Application->ResponseList, NAT_PROTOCOL_UDP);
    if (Value) {
        WritePrivateProfileStringUTF8(
            SectionName,
            c_szUdpResponseList,
            Value,
            Path
            );
        Free(Value);
    }

    _ltot(Application->BuiltIn, Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szBuiltIn,
        Buffer,
        Path
        );

    return TRUE;
}


BOOL
SaveServer(
    SAINFO* Info,
    SASERVER* Server,
    const TCHAR* Path
    )
{
    TCHAR Buffer[32];
    ULONG ReservedAddress;
    TCHAR SectionName[32];
    TCHAR* Value;

    wsprintf(Buffer, c_szKeyFormat, Server->Key);
    wsprintf(SectionName, c_szSectionFormat, c_szServer, Buffer);

    WritePrivateProfileStringUTF8(
        SectionName,
        c_szTitle,
        Server->Title,
        Path
        );

    if (Server->Protocol == NAT_PROTOCOL_TCP) {
        Value = (TCHAR*)c_szTCP;
    } else if (Server->Protocol == NAT_PROTOCOL_UDP) {
        Value = (TCHAR*)c_szUDP;
    } else {
        return FALSE;
    }
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szProtocol,
        Value,
        Path
        );

    _ltot(NTOHS(Server->Port), Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szPort,
        Buffer,
        Path
        );

    WritePrivateProfileStringUTF8(
        SectionName,
        c_szInternalName,
        Server->InternalName,
        Path
        );

    _ltot(NTOHS(Server->InternalPort), Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szInternalPort,
        Buffer,
        Path
        );

    if (Server->InternalName && lstrlen(Server->InternalName)) {
        ReservedAddress = IpPszToHostAddr(Server->InternalName);
        if (ReservedAddress != INADDR_NONE) {
            Server->ReservedAddress = HTONL(ReservedAddress);
        }
        if (Server->ReservedAddress == INADDR_NONE) {
            SASERVER* Entry;
            ULONG Index;
            PLIST_ENTRY Link;
            ULONG ScopeLength;
            for (Link = Info->ServerList.Flink; Link != &Info->ServerList;
                 Link = Link->Flink) {
                Entry = CONTAINING_RECORD(Link, SASERVER, Link);
                if (Entry != Server &&
                    Entry->ReservedAddress &&
                    Entry->ReservedAddress != INADDR_NONE &&
                    lstrcmpi(Entry->InternalName, Server->InternalName) == 0) {
                    Server->ReservedAddress = Entry->ReservedAddress;
                    break;
                }
            }
            if (Server->ReservedAddress == INADDR_NONE) {
                ScopeLength = NTOHL(~Info->ScopeMask);
                for (Index = 1; Index < ScopeLength - 1; Index++) {
                    ReservedAddress =
                        (Info->ScopeAddress & Info->ScopeMask) | HTONL(Index);
                    if (ReservedAddress == Info->ScopeAddress) { continue; }
                    for (Link = Info->ServerList.Flink;
                         Link != &Info->ServerList; Link = Link->Flink) {
                        Entry = CONTAINING_RECORD(Link, SASERVER, Link);
                        if (Entry->ReservedAddress == ReservedAddress) {
                            break;
                        }
                    }
                    if (Link == &Info->ServerList) { break; }
                }
                if (Index > ScopeLength) { return FALSE; }
                Server->ReservedAddress = ReservedAddress;
            }
        }

        IpHostAddrToPsz(NTOHL(Server->ReservedAddress), Buffer);
        WritePrivateProfileStringUTF8(
            SectionName,
            c_szReservedAddress,
            Buffer,
            Path
            );
    }

    _ltot(Server->BuiltIn, Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szBuiltIn,
        Buffer,
        Path
        );

    return TRUE;
}

#endif


TCHAR* APIENTRY
SharedAccessResponseListToString(
    PLIST_ENTRY ResponseList,
    UCHAR Protocol
    )
{
    TCHAR Buffer[LSTRLEN(c_szMaxResponseEntry)];
    ULONG Length;
    PLIST_ENTRY Link;
    SARESPONSE* Response;
    TCHAR* Value;

    Length = 2;
    for (Link = ResponseList->Flink;
         Link != ResponseList; Link = Link->Flink) {
        Response = CONTAINING_RECORD(Link, SARESPONSE, Link);
        if (Response->Protocol != Protocol) { continue; }
        Length += LSTRLEN(c_szMaxResponseEntry);
    }

    if (Length == 2) { return NULL; }

    Value = (TCHAR*)Malloc(Length * sizeof(TCHAR));
    if (!Value) { return NULL; }

    Value[0] = TEXT('\0');
    for (Link = ResponseList->Flink;
         Link != ResponseList; Link = Link->Flink) {
        Response = CONTAINING_RECORD(Link, SARESPONSE, Link);
        if (Response->Protocol != Protocol) { continue; }
        if (Value[0] != TEXT('\0')) {
            lstrcat(Value, TEXT(","));
        }
        if (Response->StartPort == Response->EndPort) {
            wsprintf(
                Buffer,
                c_szResponseFormat1,
                NTOHS(Response->StartPort)
                );
        } else {
            wsprintf(
                Buffer,
                c_szResponseFormat2,
                NTOHS(Response->StartPort),
                NTOHS(Response->EndPort)
                );
        }
        lstrcat(Value, Buffer);
    }
    return Value;
}


BOOL APIENTRY
SharedAccessResponseStringToList(
    UCHAR Protocol,
    TCHAR* Value,
    PLIST_ENTRY ListHead
    )
{
    TCHAR* Endp;
    ULONG EndPort;
    LONG Length;
    SARESPONSE* Response;
    ULONG StartPort;

    while (*Value) {
        //
        // Read either a single port or a range of ports.
        //
        if (!(StartPort = _tcstoul(Value, &Endp, 10))) {
            return FALSE;
        } else if (StartPort > USHRT_MAX) {
            return FALSE;
        }
        while(*Endp == ' ') Endp++; // consume whitespace
        if (!*Endp || *Endp == ',') {
            EndPort = StartPort;
            Value = (!*Endp ? Endp : Endp + 1);
        } else if (*Endp != '-') {
            return FALSE;
        } else if (!(EndPort = _tcstoul(++Endp, &Value, 10))) {
            return FALSE;
        } else if (EndPort > USHRT_MAX) {
            return FALSE;
        } else if (EndPort < StartPort) {
            return FALSE;
        } else if (*Value && *Value++ != ',') {
            return FALSE;
        }
        //
        // Allocate and append another response entry
        //
        Response = (SARESPONSE*)Malloc(sizeof(SARESPONSE));
        if (!Response) { return FALSE; }
        Response->Protocol = Protocol;
        Response->StartPort = HTONS((USHORT)StartPort);
        Response->EndPort = HTONS((USHORT)EndPort);
        InsertTailList(ListHead, &Response->Link);
    }
    return TRUE;
}

#if 0


BOOL
WritePrivateProfileStringUTF8(
    const TCHAR* Section,
    const TCHAR* Key,
    const TCHAR* Value,
    const TCHAR* Path
    )
{
    CHAR* KeyA;
    CHAR* PathA;
    CHAR* SectionA;
    BOOL Succeeded;
    CHAR* ValueA = NULL;

    if (!(SectionA = StrDupAFromT(Section))) {
        Succeeded = FALSE;
    } else {
        if (!(KeyA = StrDupAFromT(Key))) {
            Succeeded = FALSE;
        } else {
            if (Value && !(ValueA = StrDupAFromT(Value))) {
                Succeeded = FALSE;
            } else {
                if (!(PathA = StrDupAFromTAnsi(Path))) {
                    Succeeded = FALSE;
                } else {
                    Succeeded =
                        WritePrivateProfileStringA(
                            SectionA,
                            KeyA,
                            ValueA,
                            PathA
                            );
                    Free(PathA);
                }
                Free0(ValueA);
            }
            Free(KeyA);
        }
        Free(SectionA);
    }
    return Succeeded;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\sharing\sharing.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    sharing.h

Abstract:

    This module contains declarations for the API routines which support
    connection sharing.

Author:

    Abolade Gbadegesin  (aboladeg)  22-Apr-1998

Revision History:

--*/

#ifndef _RASSHARE_SHARING_H_
#define _RASSHARE_SHARING_H_

//
// MACRO DECLARATIONS
//

#define Dimension(x)        (sizeof(x) / sizeof(x[0]))

//
// MPRAPI.DLL import prototypes
//

typedef DWORD
(APIENTRY* PMPRCONFIGBUFFERFREE)(
    LPVOID
    );

typedef DWORD
(APIENTRY* PMPRCONFIGSERVERCONNECT)(
    LPWSTR,
    PHANDLE
    );

typedef VOID
(APIENTRY* PMPRCONFIGSERVERDISCONNECT)(
    HANDLE
    );

typedef DWORD
(APIENTRY* PMPRCONFIGTRANSPORTGETHANDLE)(
    HANDLE,
    DWORD,
    PHANDLE
    );

typedef DWORD
(APIENTRY* PMPRCONFIGTRANSPORTGETINFO)(
    HANDLE,
    HANDLE,
    LPBYTE*,
    LPDWORD,
    LPBYTE*,
    LPDWORD,
    LPWSTR*
    );

typedef DWORD
(APIENTRY* PMPRINFOBLOCKFIND)(
    LPVOID,
    DWORD,
    LPDWORD,
    LPDWORD,
    LPBYTE*
    );

//
// IPHLPAPI.DLL import prototypes
//

typedef DWORD
(APIENTRY* PALLOCATEANDGETIPADDRTABLEFROMSTACK)(
    PMIB_IPADDRTABLE*,
    BOOL,
    HANDLE,
    DWORD
    );

typedef DWORD
(APIENTRY* PGETINTERFACEINFO)(
    PIP_INTERFACE_INFO,
    PULONG
    );

typedef DWORD
(APIENTRY* PSETADAPTERIPADDRESS)(
    PCHAR,
    BOOL,
    ULONG,
    ULONG,
    ULONG
    );

//
// OLE32.DLL import prototypes and instances
//

typedef HRESULT
(STDAPICALLTYPE* PCOINITIALIZEEX)(
    LPVOID,
    DWORD
    );
extern PCOINITIALIZEEX g_pCoInitializeEx;

typedef VOID
(STDAPICALLTYPE* PCOUNINITIALIZE)(
    VOID
    );
extern PCOUNINITIALIZE g_pCoUninitialize;

typedef HRESULT
(STDAPICALLTYPE* PCOCREATEINSTANCE)(
    REFCLSID,
    LPUNKNOWN,
    DWORD,
    REFIID,
    LPVOID FAR*
    );
extern PCOCREATEINSTANCE g_pCoCreateInstance;

typedef HRESULT
(STDAPICALLTYPE* PCOSETPROXYBLANKET)(
    IUnknown*,
    DWORD,
    DWORD,
    OLECHAR*,
    DWORD,
    DWORD,
    RPC_AUTH_IDENTITY_HANDLE,
    DWORD
    );
extern PCOSETPROXYBLANKET g_pCoSetProxyBlanket;

typedef VOID
(STDAPICALLTYPE* PCOTASKMEMFREE)(
    LPVOID
    );
extern PCOTASKMEMFREE g_pCoTaskMemFree;

//
// GLOBAL DATA DECLARATIONS
//

extern const WCHAR c_szSharedAccessParametersKey[];

//
// FUNCTION DECLARATIONS (in alphabetical order)
//

VOID
CsControlService(
    ULONG ControlCode
    );

BOOL
CsDllMain(
    ULONG Reason
    );

#if 0

ULONG
CsFirewallConnection(
    LPRASSHARECONN Connection,
    BOOLEAN Enable
    );

#endif

ULONG
CsInitializeModule(
    VOID
    );

#if 0

BOOLEAN
CsIsRoutingProtocolInstalled(
    ULONG ProtocolId
    );

ULONG
CsIsFirewalledConnection(
    LPRASSHARECONN Connection,
    PBOOLEAN Firewalled
    );

#endif

ULONG
CsIsSharedConnection(
    LPRASSHARECONN Connection,
    PBOOLEAN Shared
    );

#if 0

ULONG
CsMapGuidToAdapterIndex(
    PWCHAR Guid,
    PGETINTERFACEINFO GetInterfaceInfo
    );

#endif

NTSTATUS
CsOpenKey(
    PHANDLE Key,
    ACCESS_MASK DesiredAccess,
    PCWSTR Name
    );

#if 0

ULONG
CsQueryFirewallConnections(
    LPRASSHARECONN ConnectionArray,
    ULONG *ConnectionCount
    );


ULONG
CsQueryLanConnTable(
    LPRASSHARECONN ExcludeConnection,
    NETCON_PROPERTIES** LanConnTable,
    LPDWORD LanConnCount
    );

#endif

ULONG
CsQuerySharedConnection(
    LPRASSHARECONN Connection
    );

#if 0

ULONG
CsQuerySharedPrivateLan(
    GUID* LanGuid
    );

ULONG
CsQuerySharedPrivateLanAddress(
    PULONG Address
    );

VOID
CsQueryScopeInformation(
    IN OUT PHANDLE Key,
    PULONG Address,
    PULONG Mask
    );

#endif

NTSTATUS
CsQueryValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    );

#if 0

ULONG
CsRenameSharedConnection(
    LPRASSHARECONN NewConnection
    );

ULONG
CsSetupSharedPrivateLan(
    REFGUID LanGuid,
    BOOLEAN EnableSharing
    );

ULONG
CsSetSharedPrivateLan(
    REFGUID LanGuid
    );
    
ULONG
CsShareConnection(
    LPRASSHARECONN Connection
    );

#endif

VOID
CsShutdownModule(
    VOID
    );

#if 0

ULONG
CsStartService(
    VOID
    );

VOID
CsStopService(
    VOID
    );

ULONG
CsUnshareConnection(
    BOOLEAN RemovePrivateLan,
    PBOOLEAN Shared
    );

VOID
RasIdFromSharedConnection(
    IN LPRASSHARECONN pConn,
    IN LPWSTR pszId,
    IN INT cchMax
    );

WCHAR*
StrDupW(
    LPCWSTR psz
    );

VOID
TestBackupAddress(
    PWCHAR Guid
    );

VOID
TestRestoreAddress(
    PWCHAR Guid
    );

VOID CsRefreshNetConnections(
    VOID
    );

#endif
    

#endif // _RASSHARE_SHARING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\uiutil\bubble.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    bubble.c
//
// History:
//  Abolade Gbadegesin  Mar-1-1996  Created.
//
// This file contains code for the bubble-popup control.
//============================================================================

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

#include <debug.h>
#include <nouiutil.h>
#include <uiutil.h>

#include "bpopup.h"     // public declarations
#include "bubble.h"     // private declarations



//----------------------------------------------------------------------------
// Function:    BubblePopup_Init
//
// This function is called to initialize the control class.
// It registers the bubble-popup window class.
//----------------------------------------------------------------------------

BOOL
BubblePopup_Init(
    IN  HINSTANCE   hinstance
    ) {

    //
    // if the window class is registered already, return
    //

    WNDCLASS wc;

    if (GetClassInfo(hinstance, WC_BUBBLEPOPUP, &wc)) { return TRUE; }


    //
    // set up the window class for registration
    //

    wc.lpfnWndProc = BP_WndProc;
    wc.hCursor = LoadCursor(hinstance, IDC_ARROW);
    wc.hIcon = NULL;
    wc.lpszMenuName = NULL;
    wc.hInstance = hinstance;
    wc.lpszClassName = WC_BUBBLEPOPUP;
    wc.hbrBackground = (HBRUSH)(COLOR_INFOBK + 1);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.cbWndExtra = sizeof(BPOPUP *);
    wc.cbClsExtra = 0;

    return RegisterClass(&wc);
}



//----------------------------------------------------------------------------
// Function:    BP_WndProc
//
// This is the window procedure for all windows in the BubblePopup class.
//----------------------------------------------------------------------------

LRESULT
CALLBACK
BP_WndProc(
    IN  HWND    hwnd,
    IN  UINT    uiMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    ) {

    BPOPUP *pbp;

    //
    // attempt to retrieve the private data pointer for the window
    // on WM_NCCREATE, this fails, so we allocate the data.
    //

    if ( NULL == hwnd) 
    { 
        return (LRESULT)FALSE; 
    }

    pbp = BP_GetPtr(hwnd);

    if (pbp == NULL) {

        if (uiMsg != WM_NCCREATE) {
            return DefWindowProc(hwnd, uiMsg, wParam, lParam);
        }


        //
        // allocate a block of memory
        //

        pbp = (BPOPUP *)Malloc(sizeof(BPOPUP));
        if (pbp == NULL) { return (LRESULT)FALSE; }


        //
        // save the pointer in the window's private bytes
        //

        pbp->hwnd = hwnd;

        //
        //Reset Error code, because BP_SetPtr won't reset the error code when
        //it succeeds
        //

        SetLastError( 0 );
        if ((0 == BP_SetPtr(hwnd, pbp)) && (0 != GetLastError())) 
        {
            Free(pbp);
            return (LRESULT)FALSE;
        }

        return DefWindowProc(hwnd, uiMsg, wParam, lParam);
    }


    //
    // if the window is being destroyed, free the block allocated
    // and set the private bytes pointer to NULL
    //

    if (uiMsg == WM_NCDESTROY) {

        Free(pbp);

        BP_SetPtr(hwnd, 0);

        return (LRESULT)0;
    }



    //
    // handle other messages
    //

    switch(uiMsg) {

        HANDLE_MSG(pbp, WM_CREATE, BP_OnCreate);
        HANDLE_MSG(pbp, WM_DESTROY, BP_OnDestroy);

        case WM_PAINT: {

            return BP_OnPaint(pbp);
        }

        case WM_WINDOWPOSCHANGED: {

            BP_ResizeClient(pbp);

            return 0;
        }

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN: {

            //
            // hide the window if it is showing
            //

            BP_OnDeactivate(pbp);

            return 0;
        }

        case WM_GETFONT: {

            return (LRESULT)pbp->hfont;
        }

        case WM_SETFONT: {

            BOOL bRet = BP_OnSetFont(pbp, (HFONT)wParam, (BOOL)LOWORD(lParam));

            BP_ResizeClient(pbp);

            if (pbp->dwFlags & BPFLAG_Activated) {

                InvalidateRect(pbp->hwnd, NULL, TRUE);
                UpdateWindow(pbp->hwnd);
            }

            return bRet;
        }

        case WM_SETTEXT: {

            //
            // change the text we're currently using,
            // and invalidate our client area
            //

            Free0(pbp->pszText);

            pbp->pszText = StrDup((PTSTR)lParam);

            BP_ResizeClient(pbp);

            if (pbp->dwFlags & BPFLAG_Activated) {

                InvalidateRect(pbp->hwnd, NULL, TRUE);
                UpdateWindow(pbp->hwnd);
            }

            return (pbp->pszText) ? TRUE : FALSE;
        }

        case WM_GETTEXT: {

            //
            // return the text we're currently using
            //

            PTSTR dst = (LPTSTR)lParam;
            PTSTR src = pbp->pszText;
            return lstrlen(lstrcpyn(dst, src ? src : TEXT(""), (int)wParam));
        }

        case WM_TIMER: {

            BP_OnDeactivate(pbp);

            return 0;
        }

        case BPM_SETTIMEOUT: {

            pbp->uiTimeout = (UINT)lParam;

            if (pbp->dwFlags & BPFLAG_Activated) {

                KillTimer(pbp->hwnd, pbp->ulpTimer);

                pbp->ulpTimer = SetTimer(
                                    pbp->hwnd, BP_TimerId, pbp->uiTimeout, NULL
                                    );
            }

            return 0;
        }

        case BPM_ACTIVATE: {

            return BP_OnActivate(pbp);
        }

        case BPM_DEACTIVATE: {

            return BP_OnDeactivate(pbp);
        }
    }

    return DefWindowProc(hwnd, uiMsg, wParam, lParam);
}



//----------------------------------------------------------------------------
// Function:    BP_OnCreate
//
// This function handles the creation of private data for a bubble-popup.
//----------------------------------------------------------------------------

BOOL
BP_OnCreate(
    IN  BPOPUP *        pbp,
    IN  CREATESTRUCT *  pcs
    ) {


    //
    // initialize the structure members
    //

    pbp->iCtrlId = PtrToUlong(pcs->hMenu);
    pbp->pszText = (pcs->lpszName ? StrDup((PTSTR)pcs->lpszName) : NULL);
    pbp->dwFlags = 0;
    pbp->ulpTimer = 0;
    pbp->uiTimeout = 5000;


    //
    // we force the window to have the WS_POPUP style
    //

    SetWindowLong(pbp->hwnd, GWL_STYLE, WS_POPUP);


    //
    // set the WS_EX_TOOLWINDOW style to make sure
    // that this window doesn't show up in the tasklist
    //

    SetWindowLong(pbp->hwnd, GWL_EXSTYLE, pcs->dwExStyle | WS_EX_TOOLWINDOW);

    return BP_OnSetFont(pbp, NULL, FALSE);
}



//----------------------------------------------------------------------------
// Function:    BP_OnDestroy
//
// This function handles the deallocation of private data for a bubble-popup.
//----------------------------------------------------------------------------

VOID
BP_OnDestroy(
    IN  BPOPUP *    pbp
    ) {

    //
    // if the font was created by this window, delete it
    //

    if (pbp->dwFlags & BPFLAG_FontCreated) { DeleteObject(pbp->hfont); }

    pbp->dwFlags = 0;
    pbp->hfont = NULL;
}



//----------------------------------------------------------------------------
// Function:    BP_OnSetFont
//
// This function handles the changing of the font in use by a bubble-popup.
//----------------------------------------------------------------------------

BOOL
BP_OnSetFont(
    IN  BPOPUP *    pbp,
    IN  HFONT       hfont,
    IN  BOOL        bRedraw
    ) {

    if (pbp->dwFlags & BPFLAG_FontCreated) { DeleteObject(pbp->hfont); }

    pbp->dwFlags &= ~BPFLAG_FontCreated;
    pbp->hfont = NULL;

    if (!hfont) {

        //
        // (re)create the default font.
        //

        NONCLIENTMETRICS ncm;

        ncm.cbSize = sizeof(ncm);

        if (!SystemParametersInfo(
                SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0
                )) {

            TRACE1("error %d getting font info", GetLastError());
            return FALSE;
        }

        hfont = CreateFontIndirect(&ncm.lfStatusFont);

        if (!hfont) {

            TRACE("error creating bubble-popup font");
            return FALSE;
        }

        pbp->dwFlags |= BPFLAG_FontCreated;
    }

    pbp->hfont = hfont;

    if (bRedraw) { InvalidateRect(pbp->hwnd, NULL, TRUE); }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    BP_OnGetRect
//
// This function recomputes the rectangle required to display
// a bubble-popup's current text.
//----------------------------------------------------------------------------

VOID
BP_OnGetRect(
    IN  BPOPUP *    pbp,
    IN  RECT *      prc
    ) {

    if (!pbp->pszText) { SetRectEmpty(prc); }
    else {
    
        HFONT hfontOld;
        HDC hdc = GetDC(pbp->hwnd);

        if (hdc)
        {
            //
            // select the font into the DC and compute the new rectangle
            //
        
            hfontOld = SelectObject(hdc, pbp->hfont);
        
            DrawText(hdc, pbp->pszText, -1, prc, DT_CALCRECT | DT_EXPANDTABS);
        
            if (hfontOld) { SelectObject(hdc, hfontOld); }
        
            ReleaseDC(pbp->hwnd, hdc);
        
        
            //
            // make space in the rectangle for the border
            //
        
            InflateRect(
                prc, GetSystemMetrics(SM_CXEDGE), GetSystemMetrics(SM_CYEDGE)
                );
        }
    }


    //
    // convert the rectangle to screen coordinates
    //

    MapWindowPoints(pbp->hwnd, NULL, (POINT *)prc, 2);
}


//----------------------------------------------------------------------------
// Function:    BP_ResizeClient
//
// When a change occurs (e.g. font-change, new text) this function is called
// to resize the bubble-popup's window so the text still fits.
//----------------------------------------------------------------------------

VOID
BP_ResizeClient(
    IN  BPOPUP *    pbp
    ) {

    RECT rc;


    //
    // find out what size the window needs to be to hold
    // the text it is currently set to display
    //

    BP_OnGetRect(pbp, &rc);


    //
    // resize the window so its client area is large enough
    // to hold DrawText's output
    //

    SetWindowPos(
        pbp->hwnd, HWND_TOPMOST, 0, 0, rc.right - rc.left,
        rc.bottom - rc.top, SWP_NOMOVE
        );
}



//----------------------------------------------------------------------------
// Function:    BP_OnPaint
//
// This function handles the painting of a bubble-popup window.
//----------------------------------------------------------------------------

DWORD
BP_OnPaint(
    IN  BPOPUP *    pbp
    ) {

    HDC hdc;
    HBRUSH hbr;
    HFONT hfontOld;
    PAINTSTRUCT ps;
    RECT rc, rcText;

    if (!pbp->hfont || !pbp->pszText) { return (DWORD)-1; }

    hdc = BeginPaint(pbp->hwnd, &ps);


    GetClientRect(pbp->hwnd, &rc);
    rcText = rc;
    InflateRect(
        &rcText, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE)
        );

    hfontOld = SelectObject(hdc, pbp->hfont);

    SetTextColor(hdc, GetSysColor(COLOR_INFOTEXT));


    //
    // clear the window's background
    //

    hbr = CreateSolidBrush(GetSysColor(COLOR_INFOBK));
    if (hbr)
    {
        FillRect(hdc, &rc, hbr);
        DeleteObject(hbr);
    }        


    //
    // draw our formatted text in the window
    //

    SetBkMode(hdc, TRANSPARENT);
    DrawText(hdc, pbp->pszText, -1, &rcText, DT_EXPANDTABS);


    //
    // draw a border around the window
    //

    DrawEdge(hdc, &rc, BDR_RAISEDOUTER, BF_RECT);

    if (hfontOld) { SelectObject(hdc, hfontOld); }

    EndPaint(pbp->hwnd, &ps);

    return 0;
}


BOOL
BP_OnActivate(
    IN  BPOPUP *    pbp
    ) {

    if (pbp->dwFlags & BPFLAG_Activated) {

        KillTimer(pbp->hwnd, pbp->ulpTimer);
    }

    ShowWindow(pbp->hwnd, SW_SHOW);

    UpdateWindow(pbp->hwnd);

    pbp->ulpTimer = SetTimer(pbp->hwnd, BP_TimerId, pbp->uiTimeout, NULL);

    pbp->dwFlags |= BPFLAG_Activated;

    return TRUE;
}


BOOL
BP_OnDeactivate(
    IN  BPOPUP *    pbp
    ) {

    if (pbp->ulpTimer) { KillTimer(pbp->hwnd, pbp->ulpTimer); pbp->ulpTimer = 0; }

    ShowWindow(pbp->hwnd, SW_HIDE);

    pbp->dwFlags &= ~BPFLAG_Activated;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\uiutil\bubble.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    bubble.h
//
// History:
//  Abolade-Gbadegesin  Mar-1-1996  Created.
//
// This file contains popup declarations for the bubble-popup controls.
//============================================================================


typedef struct _BPOPUP {

    HWND        hwnd;
    UINT        iCtrlId;
    PTSTR       pszText;
    HFONT       hfont;
    DWORD       dwFlags;
    ULONG_PTR   ulpTimer;
    UINT        uiTimeout;

} BPOPUP, *PBPOPUP;


#define BPFLAG_Activated        0x0001
#define BPFLAG_FontCreated      0x0002

#define BP_TimerId              0xa09

#define BP_GetPtr(hwnd)         (BPOPUP *)GetWindowLongPtr((hwnd), 0)
#define BP_SetPtr(hwnd,ptr)     (BPOPUP *)SetWindowLongPtr((hwnd), 0, (ULONG_PTR)ptr)


LRESULT
CALLBACK
BP_WndProc(
    IN  HWND    hwnd,
    IN  UINT    uiMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    );

BOOL
BP_OnCreate(
    IN  BPOPUP *        pbp,
    IN  CREATESTRUCT *  pcs
    );

VOID
BP_OnDestroy(
    IN  BPOPUP *pbp
    );

VOID
BP_OnGetRect(
    IN  BPOPUP *    pbp,
    IN  RECT *      prc
    );

VOID
BP_ResizeClient(
    IN  BPOPUP *    pbp
    );

BOOL
BP_OnSetFont(
    IN  BPOPUP *    pbp,
    IN  HFONT       hfont,
    IN  BOOL        bRedraw
    );

DWORD
BP_OnPaint(
    IN  BPOPUP *    pbp
    );

BOOL
BP_OnActivate(
    IN  BPOPUP *    pbp
    );


BOOL
BP_OnDeactivate(
    IN  BPOPUP *    pbp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\tapiutil\tapi.c ===
/* Copyright (c) 1995-1996, Microsoft Corporation, all rights reserved
**
** tapi.c
** TAPI utility routines
** Listed alphabetically
**
** 10/20/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Heap macros
#include <tapiutil.h> // Our public header


#define TAPIVERSION 0x00010004

TCHAR g_szTapiDevClass[] = TEXT("tapi/line");


/*----------------------------------------------------------------------------
** Private TAPI entrypoint prototypes
**----------------------------------------------------------------------------
*/

DWORD APIENTRY
internalNewLocationW(
    IN WCHAR* pszName );

DWORD APIENTRY
internalRemoveLocation(
    IN DWORD dwID );

DWORD APIENTRY
internalRenameLocationW(
    IN WCHAR* pszOldName,
    IN WCHAR* pszNewName );


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

TCHAR*
GetCanonPhoneNumber(
    IN DWORD  dwCountryCode,
    IN TCHAR* pszAreaCode,
    IN TCHAR* pszPhoneNumber );

DWORD
GetDefaultDeviceBlob(
    IN  DWORD       dwDeviceId,
    OUT VARSTRING** ppVs,
    OUT BYTE**      ppBlob,
    OUT DWORD*      pcbBlob );

void
TapiLineCallback(
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD dwInstance,
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN DWORD dwParam3 );


/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/

VOID
FreeCountryInfo(
    IN COUNTRY* pCountries,
    IN DWORD    cCountries )

    /* Frees the 'pCountries' buffer of 'cCountries' elements as returned by
    ** GetCountryInfo.
    */
{
    if (cCountries)
    {
        Free( *((VOID** )(pCountries + cCountries)) );
        Free( pCountries );
    }
}


VOID
FreeLocationInfo(
    IN LOCATION* pLocations,
    IN DWORD     cLocations )

    /* Frees the 'pLocations' buffer of 'cLocations' elements as returned by
    ** GetLocationInfo.
    */
{
    if (cLocations)
    {
        Free( *((VOID** )(pLocations + cLocations)) );
        Free( pLocations );
    }
}


TCHAR*
GetCanonPhoneNumber(
    IN DWORD  dwCountryCode,
    IN TCHAR* pszAreaCode,
    IN TCHAR* pszPhoneNumber )

    /* Returns a TAPI canonical phone number from constituent parts or NULL on
    ** error or when 'pszPhoneNumber' is NULL.  It is caller's responsibility
    ** to Free the returned string.
    */
{
    TCHAR szBuf[ 512 ];

    TRACE("GetCanonPhoneNumber");

    if (!pszPhoneNumber)
        return NULL;

    if (pszAreaCode && *pszAreaCode)
    {
        wsprintf( szBuf, TEXT("+%d (%s) %s"),
            dwCountryCode, pszAreaCode, pszPhoneNumber );
    }
    else
    {
        wsprintf( szBuf, TEXT("+%d %s"),
            dwCountryCode, pszPhoneNumber );
    }

    return StrDup( szBuf );
}


DWORD
GetCountryInfo(
    OUT COUNTRY** ppCountries,
    OUT DWORD*    pcCountries,
    IN  DWORD     dwCountryID )

    /* Sets '*ppCountries' to a heap block containing an array of TAPI country
    ** information.  '*pcCountries' is set to the number of elements in the
    ** array.  If 'dwCountryID' is 0, all countries are loaded.  Otherwise,
    ** only the specific country is loaded.
    **
    ** Returns 0 if successful, or an error code.  If successful, it is
    ** caller's responsibility to call FreeLocationInfo on *ppLocations.
    */
{
    DWORD             dwErr;
    LINECOUNTRYLIST   list;
    LINECOUNTRYLIST*  pList;
    LINECOUNTRYENTRY* pEntry;
    COUNTRY*          pCountry;
    DWORD             cb;
    DWORD             i;

    TRACE("GetCountryInfo");

    *ppCountries = NULL;
    *pcCountries = 0;

    /* Get the buffer size needed.
    */
    ZeroMemory( &list, sizeof(list) );
    list.dwTotalSize = sizeof(list);
    TRACE("lineGetCountryW");
    dwErr = lineGetCountryW( dwCountryID, TAPIVERSION, &list );
    TRACE1("lineGetCountryW=$%X",dwErr);
    if (dwErr != 0)
        return dwErr;

    /* Allocate the buffer.
    */
    pList = (LINECOUNTRYLIST* )Malloc( list.dwNeededSize );
    if (!pList)
        return ERROR_NOT_ENOUGH_MEMORY;

    /* Fill the buffer with TAPI country info.
    */
    ZeroMemory( pList, list.dwNeededSize );
    pList->dwTotalSize = list.dwNeededSize;
    TRACE("lineGetCountryW");
    dwErr = lineGetCountryW( dwCountryID, TAPIVERSION, pList );
    TRACE1("lineGetCountryW=$%X",dwErr);
    if (dwErr != 0)
    {
        Free( pList );
        return dwErr;
    }

    /* Allocate array returned to caller.
    */
    *pcCountries = pList->dwNumCountries;
    TRACE1("countries=%d",*pcCountries);
    cb = (sizeof(COUNTRY) * *pcCountries) + sizeof(LINECOUNTRYLIST*);
    *ppCountries = Malloc( cb );
    if (!*ppCountries)
    {
        *pcCountries = 0;
        Free( pList );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    /* Fill buffer returned to caller with information from TAPI location
    ** buffer.  References to the CAPS buffer are included, so the address
    ** of the CAPS buffer is tacked on the end for freeing later.
    */
    pEntry = (LINECOUNTRYENTRY* )
        (((BYTE* )pList) + pList->dwCountryListOffset);
    pCountry = *ppCountries;
    ZeroMemory( pCountry, cb );
    for (i = 0; i < *pcCountries; ++i)
    {
        pCountry->dwId = pEntry->dwCountryID;
        pCountry->dwCode = pEntry->dwCountryCode;
        pCountry->pszName =
            (TCHAR* )(((BYTE* )pList) + pEntry->dwCountryNameOffset);

        ++pEntry;
        ++pCountry;
    }

    *((LINECOUNTRYLIST** )pCountry) = pList;
    return 0;
}


DWORD
GetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp )

    /* Returns the ID of the current TAPI location, or the default 0 if there
    ** is none.  'HInst' is the module instance handle.  '*PHlineapp' is the
    ** TAPI handle returned from a previous TAPI call or NULL if none.
    */
{
    DWORD             dwErr;
    LINETRANSLATECAPS caps;
    DWORD             dwId;

    dwId = 0;

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr == 0)
#endif
    {
        ZeroMemory( &caps, sizeof(caps) );
        caps.dwTotalSize = sizeof(caps);
        TRACE("lineGetTranslateCapsW");
        dwErr = lineGetTranslateCapsW( *pHlineapp, TAPIVERSION, &caps );
        TRACE1("lineGetTranslateCapsW=$%X",dwErr);
        if (dwErr == 0)
            dwId = caps.dwCurrentLocationID;
    }

    TRACE1("GetCurrentLocation=%d",dwId);
    return dwId;
}


DWORD
GetDefaultDeviceBlob(
    IN  DWORD       dwDeviceId,
    OUT VARSTRING** ppVs,
    OUT BYTE**      ppBlob,
    OUT DWORD*      pcbBlob )

    /* Returns the default device blob for device 'dwDeviceId' in caller's
    ** '*ppBlob'.  '*pcbBlob' is set to the size of the blob.
    **
    ** Returns 0 if successful or an error code.  If succussful, it is
    ** caller's responsibility to Free the returned '*ppVs', which is a buffer
    ** containing the returned blob.
    */
{
    DWORD      dwErr;
    VARSTRING  vs;
    VARSTRING* pVs;

    *ppVs = NULL;
    *ppBlob = NULL;
    *pcbBlob = 0;

    /* Get the buffer size needed.
    */
    ZeroMemory( &vs, sizeof(vs) );
    vs.dwTotalSize = sizeof(vs);
    TRACE("lineGetDevConfigW");
    dwErr = lineGetDevConfigW( dwDeviceId, &vs, g_szTapiDevClass );
    TRACE1("lineGetDevConfigW=$%X",dwErr);
    if (dwErr != LINEERR_STRUCTURETOOSMALL && dwErr != 0)
        return dwErr;

    /* Allocate the buffer.
    */
    pVs = (VARSTRING* )Malloc( vs.dwNeededSize );
    if (!pVs)
        return ERROR_NOT_ENOUGH_MEMORY;

    /* Fill buffer with TAPI VARSTRING containing blob information.
    */
    ZeroMemory( pVs, vs.dwNeededSize );
    pVs->dwTotalSize = vs.dwNeededSize;
    TRACE("lineGetDevConfigW");
    dwErr = lineGetDevConfigW( dwDeviceId, pVs, g_szTapiDevClass );
    TRACE1("lineGetDevConfigW=$%X",dwErr);
    if (dwErr != 0)
    {
        Free( pVs );
        return dwErr;
    }

    *ppVs = pVs;
    *ppBlob = ((BYTE* )pVs) + pVs->dwStringOffset;
    *pcbBlob = pVs->dwStringSize;
    TRACE1("GetDefaultDeviceBlob=0,cb=%d",*pcbBlob);
    return 0;
}


DWORD
GetLocationInfo(
    IN     HINSTANCE  hInst,
    IN OUT HLINEAPP*  pHlineapp,
    OUT    LOCATION** ppLocations,
    OUT    DWORD*     pcLocations,
    OUT    DWORD*     pdwCurLocation )

    /* Sets '*ppLocations' to a heap block containing TAPI location
    ** information.  '*PcLocations' is set to the number of elements in the
    ** array.  '*pdwLocation' is set to the TAPI ID of the currently selected
    ** location.  '*PHlineapp' is the TAPI handle returned from a previous
    ** TAPI call or NULL if none.  'HInst' is the module instance handle.
    **
    ** Returns 0 if successful, or an error code.  If successful, it is
    ** caller's responsibility to call FreeLocationInfo on *ppLocations.
    */
{
    DWORD              dwErr;
    LINETRANSLATECAPS  caps;
    LINETRANSLATECAPS* pCaps;
    LINELOCATIONENTRY* pEntry;
    LOCATION*          pLocation;
    DWORD              cb;
    DWORD              i;

    TRACE("GetLocationInfo");

    *ppLocations = NULL;
    *pcLocations = 0;
    *pdwCurLocation = 0;

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    /* Get the buffer size needed.
    */
    ZeroMemory( &caps, sizeof(caps) );
    caps.dwTotalSize = sizeof(caps);
    TRACE("lineGetTranslateCapsW");
    dwErr = lineGetTranslateCapsW( *pHlineapp, TAPIVERSION, &caps );
    TRACE1("lineGetTranslateCapsW=$%X",dwErr);
    if (dwErr != 0)
    {
        if (dwErr == (DWORD )LINEERR_INIFILECORRUPT)
        {
            /* Means the TAPI registry is uninitialized.  Return no locations
            ** and "default" current location.
            */
            dwErr = 0;
        }
        return dwErr;
    }

    /* Allocate the buffer.
    */
    pCaps = (LINETRANSLATECAPS* )Malloc( caps.dwNeededSize );
    if (!pCaps)
        return ERROR_NOT_ENOUGH_MEMORY;

    /* Fill buffer with TAPI location data.
    */
    ZeroMemory( pCaps, caps.dwNeededSize );
    pCaps->dwTotalSize = caps.dwNeededSize;
    TRACE("lineGetTranslateCapsW");
    dwErr = lineGetTranslateCapsW( *pHlineapp, TAPIVERSION, pCaps );
    TRACE1("lineGetTranslateCapsW=$%X",dwErr);
    if (dwErr != 0)
    {
        Free( pCaps );
        return dwErr;
    }

    /* Allocate array returned to caller.
    */
    *pcLocations = pCaps->dwNumLocations;
    *pdwCurLocation = pCaps->dwCurrentLocationID;
    TRACE2("locs=%d,cur=%d",*pcLocations,*pdwCurLocation);
    cb = (sizeof(LOCATION) * *pcLocations) + sizeof(LINETRANSLATECAPS*);
    *ppLocations = Malloc( cb );
    if (!*ppLocations)
    {
        *pcLocations = 0;
        Free( pCaps );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    /* Fill buffer returned to caller with information from TAPI location
    ** buffer.  References to the CAPS buffer are included, so the address
    ** of the CAPS buffer is tacked on the end for freeing later.
    */
    pEntry = (LINELOCATIONENTRY* )
        (((BYTE* )pCaps) + pCaps->dwLocationListOffset);
    pLocation = *ppLocations;
    ZeroMemory( pLocation, cb );
    for (i = 0; i < *pcLocations; ++i)
    {
        pLocation->dwId = pEntry->dwPermanentLocationID;
        pLocation->pszName =
            (TCHAR* )(((BYTE* )pCaps) + pEntry->dwLocationNameOffset);

        ++pEntry;
        ++pLocation;
    }

    *((LINETRANSLATECAPS** )pLocation) = pCaps;
    return 0;
}


DWORD
SetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwLocationId )

    /* Sets the current TAPI location to 'dwLocationId'.  '*PHlineapp' is the
    ** TAPI handle returned from a previous TAPI call or NULL if none.
    ** 'HInst' is the module instance handle.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD    dwErr;
    HLINEAPP hlineapp;

    TRACE1("SetCurrentLocation(id=%d)",dwLocationId);

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    TRACE("lineSetCurrentLocation");
    dwErr = lineSetCurrentLocation( *pHlineapp, dwLocationId );
    TRACE1("lineSetCurrentLocation=$%X",dwErr);

    if (dwErr == (DWORD )LINEERR_INIFILECORRUPT && dwLocationId == 0)
    {
        /* Means the TAPI registry is uninitialized.  If caller is setting the
        ** default location, this is OK.
        */
        return 0;
    }

    return dwErr;
}


#if 0
DWORD
TapiConfigureDlg(
    IN     HWND   hwndOwner,
    IN     DWORD  dwDeviceId,
    IN OUT BYTE** ppBlob,
    IN OUT DWORD* pcbBlob )

    /* Popup the TAPI dialog to edit device 'dwDeviceId, with input blob
    ** '*ppBlob' of size '*pcBlob'.  '*ppBlob' can be NULL causing the current
    ** system defaults for the device to be used as input.  'HwndOwner' is the
    ** window owning the modal dialog.
    */
{
    DWORD      dwErr;
    VARSTRING  vs;
    VARSTRING* pVs;
    VARSTRING* pVsDefault;
    BYTE*      pIn;
    BYTE*      pOut;
    DWORD      cbIn;
    DWORD      cbOut;

    TRACE("TapiConfigureDlg");

    pVs = NULL;

    if (*ppBlob)
    {
        /* Caller provided input blob.
        */
        pIn = *ppBlob;
        cbIn = *pcbBlob;
    }
    else
    {
        /* Caller did not provide input blob, so look up the default for this
        ** device.
        */
        dwErr = GetDefaultDeviceBlob( dwDeviceId, &pVsDefault, &pIn, &cbIn );
        if (dwErr != 0)
            return dwErr;
    }

    /* Get the buffer size needed.
    */
    ZeroMemory( &vs, sizeof(vs) );
    vs.dwTotalSize = sizeof(vs);
    TRACE("lineConfigDialogEditW");
    dwErr = lineConfigDialogEditW(
        dwDeviceId, hwndOwner, g_szTapiDevClass, pIn, cbIn, &vs );
    TRACE1("lineConfigDialogEditW=$%X",dwErr);
    if (dwErr != LINEERR_STRUCTURETOOSMALL && dwErr != 0)
        goto TapiConfigureDlg_Error;

    /* Allocate the buffer.
    */
    pVs = (VARSTRING* )Malloc( vs.dwNeededSize );
    if (!pVs)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto TapiConfigureDlg_Error;
    }

    /* Popup the dialog which edits the information in the buffer.
    */
    ZeroMemory( pVs, vs.dwNeededSize );
    pVs->dwTotalSize = vs.dwNeededSize;
    TRACE("lineConfigDialogEditW");
    dwErr = lineConfigDialogEditW(
        dwDeviceId, hwndOwner, g_szTapiDevClass, pIn, cbIn, pVs );
    TRACE1("lineConfigDialogEditW=$%X",dwErr);
    if (dwErr != 0)
        goto TapiConfigureDlg_Error;

    /* Allocate a new "blob" buffer and fill it with the "blob" subset of the
    ** larger VARSTRING buffer.  Can't avoid this copy without introducing
    ** Freeing complexity for caller.
    */
    cbOut = pVs->dwStringSize;
    pOut = Malloc( cbOut );
    if (!pOut)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto TapiConfigureDlg_Error;
    }

    CopyMemory( pOut, ((BYTE* )pVs) + pVs->dwStringOffset, cbOut );
    Free( pVs );

    if (pIn == *ppBlob)
        Free( pIn );
    else
        Free( pVsDefault );

    *ppBlob = pOut;
    *pcbBlob = cbOut;
    TRACE1("TapiConfigureDlg=0,cbBlob=%d",cbOut);
    return 0;

TapiConfigureDlg_Error:

    Free0( pVs );
    if (pIn != *ppBlob)
        Free( pVsDefault );

    TRACE1("TapiConfigureDlg=$%X",dwErr);
    return dwErr;
}
#endif


#if 0
DWORD
TapiInit(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    OUT    DWORD*    pcDevices )

    /* Initialize TAPI and return the app handle and device count.  Does
    ** nothing if '*pHlineapp' is non-NULL.  'PcDevices' may be NULL if caller
    ** is not interested in the device count.  'HInst' is the module instance.
    **
    ** According to BernieM, the hlineapp passed to the TAPI location,
    ** country, and line translation APIs (the ones we use in the UI) is not
    ** currently used.  Therefore, since, lineInitialize can take several
    ** seconds to complete we optimize for speed by stubbing it out in these
    ** wrappers.
    */
{
    DWORD    dwErr;
    HLINEAPP hlineapp;
    DWORD    cDevices;

    ASSERT(pHlineapp);
    TRACE1("TapiInit(h=$%x)",*pHlineapp);

    dwErr = 0;

    if (!*pHlineapp)
    {
        hlineapp = NULL;
        cDevices = 0;

        TRACE("lineInitializeW");
        dwErr = lineInitializeW(
            &hlineapp, hInst, TapiLineCallback, NULL, &cDevices );
        TRACE1("lineInitializeW=$%X",dwErr);

        if (dwErr == 0)
        {
            *pHlineapp = hlineapp;
            if (pcDevices)
                *pcDevices = cDevices;
        }
    }

    return dwErr;
}
#endif


void
TapiLineCallback(
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD dwInstance,
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN DWORD dwParam3 )

    /* Dummy TAPI callback required by lineInitialize.
    */
{
    TRACE3("TapiLineCallback(h=$%x,m=$%x,i=$%x...",hDevice,dwMessage,dwInstance);
    TRACE3(" p1=$%x,p2=$%x,p3=$%x)",dwParam1,dwParam2,dwParam3);
}


DWORD
TapiLocationDlg(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     HWND      hwndOwner,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId )

    /* Displays the TAPI location property sheet owned by 'hwndOwner'.
    ** '*PHlineapp' is the TAPI handle returned from a previous TAPI call or
    ** NULL if none.  'DwCountryCode', 'pszAreaCode', and 'pszPhoneNumber' are
    ** the components of the TAPI canonical phone number.  'DwDeviceId'
    ** specified the device to which the dialog applies, or 0 for a generic
    ** device.  'HInst' is the module instance handle.
    */
{
    DWORD  dwErr;
    DWORD  cDevices;
    TCHAR* pszCanon;

    TRACE("TapiLocationDlg");

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    pszCanon = GetCanonPhoneNumber(
        dwCountryCode, pszAreaCode, pszPhoneNumber );
    TRACEW1("lineTranslateDialogW(\"%s\")",(pszCanon)?pszCanon:TEXT(""));
    dwErr = lineTranslateDialogW(
        *pHlineapp, dwDeviceId, TAPIVERSION, hwndOwner, pszCanon );

    if (dwErr == LINEERR_INUSE)
    {
        // This error means the dialog is already up and hence our request was
        // ignored.  From our point of view, this is success, e.g. we don't
        // need to do an error popup, so map accordingly.  See bug 216683.
        //
        dwErr = 0;
    }

    TRACE1("lineTranslateDialogW=$%X",dwErr);
    Free0( pszCanon );

    return dwErr;
}


DWORD APIENTRY
TapiNewLocation(
    IN TCHAR* pszName )

    /* Clone current location giving name 'pszName'.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    TRACEW1("TapiNewLocation(%s)",pszName);

#ifdef UNICODE

    return internalNewLocationW( pszName );

#else
    {
        DWORD  dwErr;
        WCHAR* pszNameW;

        pszNameW = StrDupWFromA( pszName );
        dwErr = internalNewLocation( pszNameW );
        Free0( pszNameW );
        return dwErr;
    }
#endif
}


DWORD
TapiNoLocationDlg(
    IN HINSTANCE hInst,
    IN HLINEAPP* pHlineapp,
    IN HWND      hwndOwner )

    /* Gives TAPI a chance to initialize the first location, if necessary.
    ** Call this before any other TAPI calls.  'HInst' is the module instance
    ** handle.  '*pHlineapp' is the handle returned from a previous TAPI call
    ** or NULL if none (typical in this case).  'HwndOwner' is the window to
    ** own the TAPI dialog, if it appears.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD             dwErr;
    LINETRANSLATECAPS caps;

    TRACE("TapiNoLocationDlg");

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    /* Make an arbitrary TAPI call to see if the TAPI registry has been
    ** initialized.
    */
    ZeroMemory( &caps, sizeof(caps) );
    caps.dwTotalSize = sizeof(caps);
    TRACE("lineGetTranslateCapsW");
    dwErr = lineGetTranslateCapsW( *pHlineapp, TAPIVERSION, &caps );
    TRACE1("lineGetTranslateCapsW=$%X",dwErr);

    if (dwErr == (DWORD )LINEERR_INIFILECORRUPT)
    {
        /* This semi-private TAPI API allows the "first location" wizard page
        ** to appear without the following "TAPI Dialing Properties" sheet.
        */
        extern LOpenDialAsst(
            IN HWND    hwnd,
            IN LPCTSTR lpszAddressIn,
            IN BOOL    fSimple,
            IN BOOL    fSilentInstall );

        dwErr = LOpenDialAsst( hwndOwner, NULL, TRUE, TRUE );
    }

    return dwErr;
}


DWORD APIENTRY
TapiRemoveLocation(
    IN DWORD dwID )

    /* Remove TAPI location 'dwID'.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    TRACE("TapiRemoveLocation");

    return internalRemoveLocation( dwID );
}


DWORD APIENTRY
TapiRenameLocation(
    IN WCHAR* pszOldName,
    IN WCHAR* pszNewName )

    /* Renames TAPI location 'pszOldName' to 'pszNewName'.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    TRACEW1("TapiRenameLocation(o=%s...",pszOldName);
    TRACEW1("...n=%s)",pszNewName);

#ifdef UNICODE

    return internalRenameLocationW( pszOldName, pszNewName );

#else
    {
        WCHAR* pszOldNameW;
        WCHAR* pszNewNameW;

        pszOldNameW = StrDupWFromA( pszOldName );
        pszNewNameW = StrDupWFromA( pszNewName );
        dwErr = internalNewLocation( pszOldNameW, pszNewNameW );
        Free0( pszOldNameW );
        Free0( pszNewNameW );
        return dwErr;
    }
#endif
}


DWORD
TapiShutdown(
    IN HLINEAPP hlineapp )

    /* Terminate the TAPI session 'hlineapp', or do nothing if 'hlineapp' is
    ** NULL.
    */
{
#if 0
    DWORD dwErr = 0;

    TRACE1("TapiShutdown(h=$%x)",hlineapp);

    if (hlineapp)
    {
        TRACE("lineShutdown");
        dwErr = lineShutdown( hlineapp );
        TRACE1("lineShutdown=$%X",dwErr);
    }

    return dwErr;
#else
    /* See TapiInit.
    */
    ASSERT(!hlineapp);
    return 0;
#endif
}


DWORD
TapiTranslateAddress(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId,
    IN     BOOL      fDialable,
    OUT    TCHAR**   ppszResult )

    /* Returns '*pszResult', a heap string containing the TAPI location
    ** transformed dialable phone number built from the component phone number
    ** parts.  '*PHlineapp' is the TAPI handle returned from a previous TAPI
    ** call or NULL if none.  parts.  'dwDeviceId' is the device to which the
    ** number is to be applied or 0 for generic treatment.  'HInst' is the
    ** module instance handle.  'FDialable' indicates the dialable, as opposed
    ** to the displayable string should be returned.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD                dwErr;
    TCHAR*               pszCanon;
    LINETRANSLATEOUTPUT  output;
    LINETRANSLATEOUTPUT* pOutput;

    TRACE("TapiTranslateAddress");

    pOutput = NULL;
    pszCanon = NULL;
    *ppszResult = NULL;

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    pszCanon = GetCanonPhoneNumber(
        dwCountryCode, pszAreaCode, pszPhoneNumber );

    ZeroMemory( &output, sizeof(output) );
    output.dwTotalSize = sizeof(output);

    TRACE("lineTranslateAddressW");
    dwErr = lineTranslateAddressW(
        *pHlineapp, dwDeviceId, TAPIVERSION, pszCanon, 0,
        LINETRANSLATEOPTION_CANCELCALLWAITING, &output );
    TRACE1("lineTranslateAddressW=$%X",dwErr);
    if (dwErr != 0)
        goto TapiTranslateAddress_Error;

    pOutput = (LINETRANSLATEOUTPUT* )Malloc( output.dwNeededSize );
    if (!pOutput)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto TapiTranslateAddress_Error;
    }

    ZeroMemory( pOutput, output.dwNeededSize );
    pOutput->dwTotalSize = output.dwNeededSize;
    TRACE("lineTranslateAddressW");
    dwErr = lineTranslateAddressW(
        *pHlineapp, dwDeviceId, TAPIVERSION, pszCanon, 0,
        LINETRANSLATEOPTION_CANCELCALLWAITING, pOutput );
    TRACE1("lineTranslateAddressW=$%X",dwErr);
    if (dwErr != 0)
        goto TapiTranslateAddress_Error;

    if (fDialable)
    {
        *ppszResult = StrDup(
            (TCHAR* )(((BYTE* )pOutput) + pOutput->dwDialableStringOffset) );
    }
    else
    {
        *ppszResult = StrDup(
            (TCHAR* )(((BYTE* )pOutput) + pOutput->dwDisplayableStringOffset) );
    }

    if (!*ppszResult)
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

TapiTranslateAddress_Error:

    Free0( pszCanon );
    Free0( pOutput );
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\uiutil\lvx.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** lvx.c
** Listview extension routines
** Listed alphabetically
**
** 11/25/95 Steve Cobb
**     Some adapted from \\ftp\data\softlib\mslfiles\odlistvw.exe sample code.
*/

#include <windows.h>  // Win32 root
#include <windowsx.h> // Win32 macro extensions
#include <commctrl.h> // Win32 common controls
#include <debug.h>    // Trace and assert
#include <uiutil.h>   // Our public header
#include <lvx.rch>    // Our resource constants


/* List view of check boxes state indices.
*/
#define SI_Unchecked 1
#define SI_Checked   2
#define SI_DisabledUnchecked 3
#define SI_DisabledChecked 4

/* Text indents within a column in pixels.  If you mess with the dx, you're
** asking for misalignment problems with the header labels.  BTW, the first
** column doesn't line up with it's header if there are no icons.  Regular
** list view has this problem, too.  If you try to fix this you'll wind up
** duplicating the AUTOSIZE_USEHEADER option of ListView_SetColumnWidth.
** Should be able to change the dy without causing problems.
*/
#define LVX_dxColText 4
#define LVX_dyColText 1

/* Guaranteed vertical space between icons.  Should be able to mess with this
** without causing problems.
*/
#define LVX_dyIconSpacing 1

/* The atom identifying our context property suitable for use by the Windows
** XxxProp APIs.  A Prop is used to associate context information (the address
** of the WNDPROC we subclassed) with a "list view of check boxes" window.
*/
static LPCWSTR g_lvxcbContextId = NULL;


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/
LRESULT APIENTRY
LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
LvxDrawItem(
    IN DRAWITEMSTRUCT* pdis,
    IN PLVXCALLBACK    pLvxCallback );

BOOL
LvxMeasureItem(
    IN     HWND               hwnd,
    IN OUT MEASUREITEMSTRUCT* pmis );


/*----------------------------------------------------------------------------
** ListView of check boxes
**----------------------------------------------------------------------------
*/

BOOL
ListView_GetCheck(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is checked, false otherwise.  This function works on disabled
    ** check boxes as well as enabled ones.
    */
{
    UINT unState;

    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );
    return !!((unState == INDEXTOSTATEIMAGEMASK( SI_Checked )) ||
              (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )));
}

BOOL
ListView_IsCheckDisabled (
        IN HWND hwndLv,
        IN INT  iItem) 

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is disabled, false otherwise.  
    */
{
    UINT unState;
    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );

    if ((unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )) ||
        (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledUnchecked )))
        return TRUE;

    return FALSE;
}       

VOID
ListView_DisableCheck (
        IN HWND hwndLv,
        IN INT  iItem) 

    /* Disables a check box of item 'iItem' of listview of checkboxes.  Once
    ** disabled, ListView_SetCheck will have no effect on the item until
    ** ListView_EnableCheck(...) is called for this item.  Likewise, there is no 
    ** way through the UI to change the check of this item until it is enabled.
    ** Calling this function on a disabled check has no effect.
    */
{
    BOOL fCheck;

    fCheck = ListView_GetCheck(hwndLv, iItem);
    
    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_DisabledChecked : SI_DisabledUnchecked),
        LVIS_STATEIMAGEMASK );
}

VOID
ListView_EnableCheck (
        IN HWND hwndLv,
        IN INT  iItem) 

    /* Reverses the effect of ListView_DisableCheck.
    */
{
    BOOL fCheck;

    fCheck = ListView_GetCheck(hwndLv, iItem);
    
    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_Checked : SI_Unchecked ),
        LVIS_STATEIMAGEMASK );
}


UINT
ListView_GetCheckedCount(
    IN HWND hwndLv )

    /* Returns the number of checked items in 'hwndLv' regardless of whether
    ** they are disabled.
    */
{
    UINT c = 0;
    INT  i = -1;

    while ((i = ListView_GetNextItem( hwndLv, i, LVNI_ALL )) >= 0)
    {
        if (ListView_GetCheck( hwndLv, i ))
            ++c;
    }

    return c;
}


BOOL
ListView_InstallChecks(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Initialize "list of checkbox" handling for listview 'hwndLv'.  'Hinst'
    ** is the module instance containing the two checkbox icons.  See LVX.RC.
    **
    ** Returns true if successful, false otherwise.  Caller must eventually
    ** call 'ListView_UninstallChecks', typically in WM_DESTROY processing.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;
    WNDPROC    pOldProc;
    //Add this for RTL(right to left, mirrored windows version)
    //whistler bug 41349       gangz
    //
    BOOL       fMirrored=FALSE; 
    DWORD      dwLayout;

        
    // pmay: 397395
    //
    // Prevent endless loops resulting from accidentally calling this
    // api twice.
    //
    pOldProc = (WNDPROC)GetWindowLongPtr(hwndLv, GWLP_WNDPROC);
    if (pOldProc == LvxcbProc)
    {
        return TRUE;
    }

    //get current application's layout (RTL or normal)      gangz
    //  for whistler bug 41349
    //There are two ways:
    //(1) use  GetWindowLong() with GWL_EXSTYLE for WS_EX_LAYOUTRTL style if 
    //    you have a window handler available
    //(2) use GetProcessDefaultLayout() to get the layout for the current 
    //    process, and compare that against LAYOUT_RTL  
    //
    dwLayout = GetWindowLong(hwndLv, GWL_EXSTYLE);
    if ( WS_EX_LAYOUTRTL & dwLayout )
    {
        fMirrored = TRUE;
     }

    /* Build checkbox image lists.
    */
    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Unchecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( fMirrored?IID_CheckedRTL : IID_Checked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_DisabledUnchecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( fMirrored?IID_DisabledCheckedRTL : IID_DisabledChecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_STATE );

    /* Register atom for use in the Windows XxxProp calls which are used to
    ** associate the old WNDPROC with the listview window handle.
    */
    if (!g_lvxcbContextId)
        g_lvxcbContextId = (LPCWSTR )GlobalAddAtom( L"RASLVXCB" );
    if (!g_lvxcbContextId)
        return FALSE;

    /* Subclass the current window procedure.
    */
    pOldProc = (WNDPROC)SetWindowLongPtr(
                                hwndLv, GWLP_WNDPROC, (ULONG_PTR)LvxcbProc );

    return SetProp( hwndLv, g_lvxcbContextId, (HANDLE )pOldProc );
}


VOID
ListView_SetCheck(
    IN HWND hwndLv,
    IN INT  iItem,
    IN BOOL fCheck )

    /* Sets the check mark on item 'iItem' of listview of checkboxes 'hwndLv'
    ** to checked if 'fCheck' is true or unchecked if false.
    */
{
    NM_LISTVIEW nmlv;

    if (ListView_IsCheckDisabled(hwndLv, iItem))
        return;

    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_Checked : SI_Unchecked ),
        LVIS_STATEIMAGEMASK );

    nmlv.hdr.code = LVXN_SETCHECK;
    nmlv.hdr.hwndFrom = hwndLv;
    nmlv.iItem = iItem;

    FORWARD_WM_NOTIFY(
        GetParent(hwndLv), GetDlgCtrlID(hwndLv), &nmlv, SendMessage
        );
}


VOID
ListView_UninstallChecks(
    IN HWND hwndLv )

    /* Uninstalls "listview of check boxes" handling from list view 'hwndLv'.
    */
{
    WNDPROC pOldProc;

    pOldProc = (WNDPROC)GetProp( hwndLv, g_lvxcbContextId );
    if (pOldProc)
    {
        /* Un-subclass so it can terminate without access to the context.
        */
        SetWindowLongPtr( hwndLv, GWLP_WNDPROC, (ULONG_PTR)pOldProc );
    }

    RemoveProp( hwndLv, g_lvxcbContextId );
}


LRESULT APIENTRY
LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* List view subclass window procedure to trap toggle-check events.
    */
{
    WNDPROC pOldProc;
    INT     iItem;
    BOOL    fSet;
    BOOL    fClear;
    BOOL    fToggle;

    iItem = -1;
    fSet = fClear = fToggle = FALSE;

    if (unMsg == WM_LBUTTONDOWN)
    {
        LV_HITTESTINFO info;

        /* Left mouse button pressed over checkbox icon toggles state.
        ** Normally, we'd use LVHT_ONITEMSTATEICON and be done with it, but we
        ** want to work with our cool owner-drawn list view extensions in
        ** which case the control doesn't know where the icon is on the item,
        ** so it returns a hit anywhere on the item anyway.
        */
        ZeroMemory( &info, sizeof(info) );
        info.pt.x = LOWORD( lparam );
        info.pt.y = HIWORD( lparam );
        info.flags = LVHT_ONITEM;
        iItem = ListView_HitTest( hwnd, &info );

        if (iItem >= 0)
        {
            /* OK, it's over item 'iItem'.  Now figure out if it's over the
            ** checkbox.  Note this currently doesn't account for use of the
            ** "indent" feature on an owner-drawn item.
            */
            if ((INT )(LOWORD( lparam )) >= GetSystemMetrics( SM_CXSMICON ))
                iItem = -1;
            else
                fToggle = TRUE;
        }
    }
    else if (unMsg == WM_LBUTTONDBLCLK)
    {
        LV_HITTESTINFO info;

        /* Left mouse button double clicked over any area toggles state.
        ** Normally, we'd use LVHT_ONITEMSTATEICON and be done with it, but we
        ** want to work with our cool owner-drawn list view extensions in
        ** which case the control doesn't know where the icon is on the item,
        ** so it returns a hit anywhere on the item anyway.
        */
        ZeroMemory( &info, sizeof(info) );
        info.pt.x = LOWORD( lparam );
        info.pt.y = HIWORD( lparam );
        info.flags = LVHT_ONITEM;
        iItem = ListView_HitTest( hwnd, &info );

        if (iItem >= 0)
        {
            /* OK, it's over item 'iItem'.  If the click does not occur
             * over a checkbox, inform the parent of the double click.
            */
            if ((INT )(LOWORD( lparam )) >= GetSystemMetrics( SM_CXSMICON )) {
                NM_LISTVIEW nmlv;
                nmlv.hdr.code = LVXN_DBLCLK;
                nmlv.hdr.hwndFrom = hwnd;
                nmlv.iItem = iItem;
                
                FORWARD_WM_NOTIFY(
                    GetParent(hwnd), GetDlgCtrlID(hwnd), &nmlv, SendMessage);
                    
                iItem = -1;
            }

            /*
             * Otherwise, toggle the state.
            */
            else
                fToggle = TRUE;
        }
    }
    else if (unMsg == WM_CHAR)
    {
        /* Space bar pressed with item selected toggles check.
        ** Plus or Equals keys set check.
        ** Minus key clears check.
        */
        switch (wparam)
        {
            case TEXT(' '):
                fToggle = TRUE;
                break;

            case TEXT('+'):
            case TEXT('='):
                fSet = TRUE;
                break;

            case TEXT('-'):
                fClear = TRUE;
                break;
        }

        if (fToggle || fSet || fClear)
            iItem = ListView_GetNextItem( hwnd, -1, LVNI_SELECTED );
    }
    else if (unMsg == WM_KEYDOWN)
    {
        /* Left arrow becomes up arrow and right arrow becomes down arrow so
        ** the list of checkboxes behaves just like a static group of
        ** checkboxes.
        */
        if (wparam == VK_LEFT)
            wparam = VK_UP;
        else if (wparam == VK_RIGHT)
            wparam = VK_DOWN;
    }

    if (iItem >= 0)
    {

        /* If we are handling the spacebar, plus, minus, or equals,
        ** the change we make applies to all the selected items;
        ** hence the do {} while(WM_CHAR).
        */
        
        do {

            if (fToggle)
            {
                UINT unOldState;
                BOOL fCheck;
    
                fCheck = ListView_GetCheck( hwnd, iItem );
                ListView_SetCheck( hwnd, iItem, !fCheck );
            }
            else if (fSet)
            {
                if (!ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, TRUE );
            }
            else if (fClear)
            {
                if (ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, FALSE );
            }

            iItem = ListView_GetNextItem(hwnd, iItem, LVNI_SELECTED);

        } while(iItem >= 0 && unMsg == WM_CHAR);

        if (fSet || fClear) {

            /* Don't pass to listview to avoid beep.
            */
            return 0;
        }
    }

    pOldProc = (WNDPROC )GetProp( hwnd, g_lvxcbContextId );
    if (pOldProc)
        return CallWindowProc( pOldProc, hwnd, unMsg, wparam, lparam );

    return 0;
}


/*----------------------------------------------------------------------------
** Enhanced ListView
**----------------------------------------------------------------------------
*/

BOOL
ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback )

    /* Handler that, when installed, turns a regular report-view-only list
    ** view (but with style LVS_OWNERDRAWFIXED) into an enhanced list view
    ** with full width selection bar and other custom column display options.
    ** It should appear in list view owner's dialog proc as follows:
    **
    **     BOOL
    **     MyDlgProc(
    **         IN HWND   hwnd,
    **         IN UINT   unMsg,
    **         IN WPARAM wparam,
    **         IN LPARAM lparam )
    **     {
    **         if (ListView_OwnerHandler(
    **                 hwnd, unMsg, wParam, lParam, MyLvxCallback ))
    **             return TRUE;
    **
    **         <the rest of your stuff here>
    **     }
    **
    ** 'PLvxCallback' is caller's callback routine that provides information
    ** about drawing columns and other options.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    /* This routine executes on EVERY message thru the dialog so keep it
    ** efficient, please.
    */
    switch (unMsg)
    {
        case WM_DRAWITEM:
            return LvxDrawItem( (DRAWITEMSTRUCT* )lparam, pLvxCallback );

        case WM_MEASUREITEM:
            return LvxMeasureItem( hwnd, (MEASUREITEMSTRUCT* )lparam );
    }

    return FALSE;
}


BOOL
LvxDrawItem(
    IN DRAWITEMSTRUCT* pdis,
    IN PLVXCALLBACK    pLvxCallback )

    /* Respond to WM_DRAWITEM by drawing the list view item.  'Pdis' is the
    ** information sent by the system.  'PLvxCallback' is caller's callback to
    ** get information about drawing the control.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    LV_ITEM      item;
    INT          i;
    INT          dxState;
    INT          dyState;
    INT          dxSmall;
    INT          dySmall;
    INT          dxIndent;
    UINT         uiStyleState;
    UINT         uiStyleSmall;
    HIMAGELIST   himlState;
    HIMAGELIST   himlSmall;
    LVXDRAWINFO* pDrawInfo;
    RECT         rc;
    RECT         rcClient;
    BOOL         fEnabled;
    BOOL         fSelected;
    HDC          hdc;
    HFONT        hfont;


    TRACE3("LvxDrawItem,i=%d,a=$%X,s=$%X",
        pdis->itemID,pdis->itemAction,pdis->itemState);

    /* Make sure this is something we want to handle.
    */
    if (pdis->CtlType != ODT_LISTVIEW)
        return FALSE;

    if (pdis->itemAction != ODA_DRAWENTIRE
        && pdis->itemAction != ODA_SELECT
        && pdis->itemAction != ODA_FOCUS)
    {
        return TRUE;
    }

    /* Get item information from the list view.
    */
    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_IMAGE + LVIF_STATE;
    item.iItem = pdis->itemID;
    item.stateMask = LVIS_STATEIMAGEMASK;
    if (!ListView_GetItem( pdis->hwndItem, &item ))
    {
        TRACE("LvxDrawItem GetItem failed");
        return TRUE;
    }

    /* Stash some useful stuff for reference later.
    */
    fEnabled = IsWindowEnabled( pdis->hwndItem )
               && !(pdis->itemState & ODS_DISABLED);
    fSelected = (pdis->itemState & ODS_SELECTED);
    GetClientRect( pdis->hwndItem, &rcClient );

    /* Callback owner to get drawing information.
    */
    ASSERT(pLvxCallback);
    pDrawInfo = pLvxCallback( pdis->hwndItem, pdis->itemID );
    ASSERT(pDrawInfo);

    /* Get image list icon sizes now, though we draw them last because their
    ** background is set up during first column text output.
    */
    dxState = dyState = 0;
    himlState = ListView_GetImageList( pdis->hwndItem, LVSIL_STATE );
    if (himlState)
        ImageList_GetIconSize( himlState, &dxState, &dyState );

    dxSmall = dySmall = 0;
    himlSmall = ListView_GetImageList( pdis->hwndItem, LVSIL_SMALL );
    if (himlSmall)
        ImageList_GetIconSize( himlSmall, &dxSmall, &dySmall );

    uiStyleState = uiStyleSmall = ILD_TRANSPARENT;

    /* Figure out the number of pixels to indent the item, if any.
    */
    if (pDrawInfo->dxIndent >= 0)
        dxIndent = pDrawInfo->dxIndent;
    else
    {
        if (dxSmall > 0)
            dxIndent = dxSmall;
        else
            dxIndent = GetSystemMetrics( SM_CXSMICON );
    }

    /* Get a device context for the window and set it up with the font the
    ** control says it's using.  (Can't use the one that comes in the
    ** DRAWITEMSTRUCT because sometimes it has the wrong rectangle, see bug
    ** 13106)
    */
    hdc = GetDC( pdis->hwndItem );

    if(NULL == hdc)
    {
        return FALSE;
    }
    
    hfont = (HFONT )SendMessage( pdis->hwndItem, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    /* Set things up as if we'd just got done processing a column that ends
    ** after the icons, then loop thru each column from left to right.
    */
    rc.right = pdis->rcItem.left + dxIndent + dxState + dxSmall;
    rc.top = pdis->rcItem.top;
    rc.bottom = pdis->rcItem.bottom;

    for (i = 0; i < pDrawInfo->cCols; ++i)
    {
        TCHAR  szText[ LVX_MaxColTchars + 1 ];
        TCHAR* pszText;
        INT    dxCol;

        /* Get the column width, adding any index and icon width to the first
        ** column.
        */
        dxCol = ListView_GetColumnWidth( pdis->hwndItem, i );
        if (i == 0)
            dxCol -= dxIndent + dxState + dxSmall;

        szText[ 0 ] = TEXT('\0');
        ListView_GetItemText( pdis->hwndItem, pdis->itemID, i, szText,
            LVX_MaxColTchars + 1 );

        /* Update rectangle to enclose just this one item's column 'i'.
        */
        rc.left = rc.right;
        rc.right = rc.left + dxCol;

        if ((pDrawInfo->dwFlags & LVXDI_DxFill)
            && i == pDrawInfo->cCols - 1)
        {
            INT dxWnd = pdis->rcItem.left + rcClient.right;

            if (rc.right < dxWnd)
            {
                /* When the last column does not fill out a full controls
                ** width of space, extend it to the right so it does.  Note
                ** this does not mean the user can't scroll off to the right
                ** if they want.
                ** (Abolade-Gbadegesin 03-27-96)
                ** Don't subtrace rc.left when there is only one column;
                ** this accounts for the space needed for icons.
                */
                rc.right = pdis->rcItem.right = dxWnd;
                if (i == 0) {
                    ListView_SetColumnWidth(pdis->hwndItem, i, rc.right);
                }
                else {
                    ListView_SetColumnWidth(
                        pdis->hwndItem, i, rc.right - rc.left );
                }
            }
        }

        /* Lop the text and append "..." if it won't fit in the column.
        */
        pszText = Ellipsisize( hdc, szText, rc.right - rc.left, LVX_dxColText );
        if (!pszText)
            continue;

        /* Figure out the appropriate text and background colors for the
        ** current item state.
        */
        if (fEnabled)
        {
            if (fSelected)
            {
                SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
                if (pDrawInfo->dwFlags & LVXDI_Blend50Sel)
                    uiStyleSmall |= ILD_BLEND50;
            }
            else
            {
                if (pDrawInfo->adwFlags[ i ] & LVXDIA_3dFace)
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
                }
                else
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_WINDOW ) );
                }
            }
        }
        else
        {
            if (pDrawInfo->adwFlags[ i ] & LVXDIA_Static)
            {
                SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
            }
            else
            {
                SetTextColor( hdc, GetSysColor( COLOR_GRAYTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
            }

            if (pDrawInfo->dwFlags & LVXDI_Blend50Dis)
                uiStyleSmall |= ILD_BLEND50;
        }

        /* Draw the column text.  In the first column the background of any
        ** indent and icons is erased to the text background color.
        */
        {
            RECT rcBg = rc;

            if (i == 0)
                rcBg.left -= dxIndent + dxState + dxSmall;

            ExtTextOut( hdc, rc.left + LVX_dxColText,
                rc.top + LVX_dyColText, ETO_CLIPPED + ETO_OPAQUE,
                &rcBg, pszText, lstrlen( pszText ), NULL );
        }

        Free( pszText );
    }

    /* Finally, draw the icons, if caller specified any.
    */
    if (himlState)
    {
        ImageList_Draw( himlState, (item.state >> 12) - 1, hdc,
            pdis->rcItem.left + dxIndent, pdis->rcItem.top, uiStyleState );
    }

    if (himlSmall)
    {
        ImageList_Draw( himlSmall, item.iImage, hdc,
            pdis->rcItem.left + dxIndent + dxState,
            pdis->rcItem.top, uiStyleSmall );
    }

    /* Draw the dotted focus rectangle around the whole item, if indicated.
    */
//comment for bug 52688 whistler
//   if ((pdis->itemState & ODS_FOCUS) && GetFocus() == pdis->hwndItem)
//        DrawFocusRect( hdc, &pdis->rcItem );
//

    ReleaseDC( pdis->hwndItem, hdc );

    return TRUE;
}



BOOL
LvxMeasureItem(
    IN     HWND               hwnd,
    IN OUT MEASUREITEMSTRUCT* pmis )

    /* Respond to WM_MEASUREITEM message, i.e. fill in the height of an item
    ** in the ListView.  'Hwnd' is the owner window.  'Pmis' is the structure
    ** provided from Windows.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    HDC        hdc;
    HWND       hwndLv;
    HFONT      hfont;
    TEXTMETRIC tm;
    UINT       dySmIcon;
    RECT       rc;

    TRACE("LvxMeasureItem");

    if (pmis->CtlType != ODT_LISTVIEW)
        return FALSE;

    hwndLv = GetDlgItem( hwnd, pmis->CtlID );
    ASSERT(hwndLv);

    /* Get a device context for the list view control and set up the font the
    ** control says it's using.  MSDN claims the final font may not be
    ** available at this point, but it sure seems to be.
    */
    hdc = GetDC( hwndLv );
    hfont = (HFONT )SendMessage( hwndLv, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    if (GetTextMetrics( hdc, &tm ))
        pmis->itemHeight = tm.tmHeight + 1;
    else
        pmis->itemHeight = 0;

    /* Make sure it's tall enough for a standard small icon.
    */
    dySmIcon = (UINT )GetSystemMetrics( SM_CYSMICON );
    if (pmis->itemHeight < dySmIcon + LVX_dyIconSpacing)
        pmis->itemHeight = dySmIcon + LVX_dyIconSpacing;

    /* Set the width since the docs say to, though I don't think it's used by
    ** list view.
    */
    GetClientRect( hwndLv, &rc );
    pmis->itemWidth = rc.right - rc.left - 1;

    ReleaseDC( hwndLv, hdc );
    return TRUE;
}


/*----------------------------------------------------------------------------
** ListView utilities
**----------------------------------------------------------------------------
*/

VOID
ListView_SetDeviceImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Set the "small icon" image list view 'hwndLv' to be a list of DI_*
    ** images.  'Hinst' is the module instance containing the icons IID_Modem
    ** and IID_Adapter.  For example, see RASDLG.DLL.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;

    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Modem ) );
    if ( NULL != hIcon )
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Adapter ) );
    if ( NULL != hIcon )
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Direct_Connect ) );
    if ( NULL != hIcon )
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Connections_Modem ) );
    if ( NULL != hIcon )
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_SMALL );
}

VOID
ListView_SetUserImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Set the "small icon" image list view 'hwndLv' to be a list of DI_*
    ** images.  'Hinst' is the module instance containing the icons IID_Modem
    ** and IID_Adapter.  For example, see RASDLG.DLL.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;

    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Connections_User ) );

    if(NULL != hIcon)
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_SMALL );
}


VOID
ListView_SetNetworkComponentImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Set the "small icon" image list view 'hwndLv' to be a list of DI_*
    ** images.  'Hinst' is the module instance containing the icons IID_Modem
    ** and IID_Adapter.  For example, see RASDLG.DLL.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;

    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Protocol ) );

    if(NULL != hIcon)
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Service ) );

    if(NULL != hIcon)
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Client ) );

    if(NULL != hIcon)
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_SMALL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\uiutil\ipaddr.c ===
/* Copyright (c) 1991, Microsoft Corporation, all rights reserved
**
** ipaddr.c
** IP Address custom edit control
**
** 11/09/92 Greg Strange
**     Original code
**
** 09/07/95 Steve Cobb
**     Lifted TerryK/TRomano-updated version from NCPA, deleting IPDLL
**     stuff, and making minor RAS-related customizations.
*/

#include <windows.h> // Win32 core
#include <uiutil.h>  // Our public header
#include <debug.h>    // Trace and assert

#define IPADDRESS_CLASS TEXT("RasIpAddress")

// Extended style bit causes the ip address control to
// correct the ip address so that it is contiguous (for submasks)
#define IPADDR_EX_STYLE_CONTIGUOUS 0x1

/* Module instance handle set when custom control is initialized.
*/
static HANDLE g_hLibInstance = NULL;

/* String ID of message displayed when user enters a field value that is out
** of range.  Something like "You must choose a value from %1 to %2 for this
** field."  Set when the custom control is initialized.
*/
static DWORD g_dwBadIpAddrRange = 0;

/* String ID of the popup title when the range error above is displayed.  Set
** when the custom control is initialized.
*/
static DWORD g_dwErrorTitle = 0;


// The character that is displayed between address fields.
#define FILLER     TEXT('.')
#define SZFILLER   TEXT(".")
#define SPACE      TEXT(' ')
#define BACK_SPACE 8

/* Min, max values */
#define NUM_FIELDS      4
#define CHARS_PER_FIELD 3
#define HEAD_ROOM       1       // space at top of control
#define LEAD_ROOM       3       // space at front of control
#define MIN_FIELD_VALUE 0       // default minimum allowable field value
#define MAX_FIELD_VALUE 255     // default maximum allowable field value


// All the information unique to one control is stuffed in one of these
// structures in global memory and the handle to the memory is stored in the
// Windows extra space.

typedef struct tagFIELD {
    HANDLE      hWnd;
    FARPROC     lpfnWndProc;
    BYTE        byLow;  // lowest allowed value for this field.
    BYTE        byHigh; // Highest allowed value for this field.
} FIELD;

typedef struct tagCONTROL {
    HWND        hwndParent;
    UINT        uiFieldWidth;
    UINT        uiFillerWidth;
    BOOL        fEnabled;
    BOOL        fPainted;
    BOOL        bControlInFocus;        // TRUE if the control is already in focus, dont't send another focus command
    BOOL        bCancelParentNotify;    // Don't allow the edit controls to notify parent if TRUE
    BOOL        fInMessageBox;  // Set when a message box is displayed so that
                                // we don't send a EN_KILLFOCUS message when
                                // we receive the EN_KILLFOCUS message for the
                                // current field.
    FIELD       Children[NUM_FIELDS];
} CONTROL;


// The following macros extract and store the CONTROL structure for a control.
#define IPADDRESS_EXTRA             (sizeof(DWORD) + sizeof(DWORD))
#define GET_CONTROL_HANDLE(hWnd)    ((HGLOBAL)(GetWindowLongPtr((hWnd), GWLP_USERDATA)))
#define SAVE_CONTROL_HANDLE(hWnd,x) (SetWindowLongPtr((hWnd), GWLP_USERDATA, (ULONG_PTR)x))
#define IPADDR_GET_SUBSTYLE(hwnd) (GetWindowLong((hwnd), 4))
#define IPADDR_SET_SUBSTYLE(hwnd, style) (SetWindowLong((hwnd), 4, (style)))

/* internal IPAddress function prototypes */
LRESULT FAR PASCAL IPAddressWndFn( HWND, UINT, WPARAM, LPARAM );
LRESULT FAR PASCAL IPAddressFieldProc(HWND, UINT, WPARAM, LPARAM);
BOOL SwitchFields(CONTROL FAR *, int, int, WORD, WORD);
void EnterField(FIELD FAR *, WORD, WORD);
BOOL ExitField(CONTROL FAR *, int iField);
int GetFieldValue(FIELD FAR *);


LOGFONT logfont;


void SetDefaultFont( )
{
    LANGID langid = PRIMARYLANGID(GetThreadLocale());
    BOOL fIsDbcs = (langid == LANG_CHINESE ||
                    langid == LANG_JAPANESE ||
                    langid == LANG_KOREAN);
    HDC hdc = GetDC(NULL);

    if(NULL == hdc)
    {
        return;
    }

    logfont.lfWidth            = 0;
    logfont.lfEscapement       = 0;
    logfont.lfOrientation      = 0;
    logfont.lfOutPrecision     = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision    = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality          = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily   = VARIABLE_PITCH | FF_SWISS;
    logfont.lfUnderline        = 0;
    logfont.lfStrikeOut        = 0;
    logfont.lfItalic           = 0;
    logfont.lfWeight           = FW_NORMAL;


    if (fIsDbcs)
    {
        logfont.lfHeight       = -(9*GetDeviceCaps(hdc,LOGPIXELSY)/72);
        logfont.lfCharSet      = DEFAULT_CHARSET;
    }
    else
    {
        logfont.lfHeight       = -(8*GetDeviceCaps(hdc,LOGPIXELSY)/72);
        logfont.lfCharSet      = ANSI_CHARSET;
    }
    lstrcpy( logfont.lfFaceName,TEXT("MS Shell Dlg"));

    ReleaseDC(NULL, hdc);
}



/*
    IpAddrInit() - IPAddress custom control initialization
    call
        hInstance = library or application instance
        dwErrorTitle = String ID of error popup title
        dwBadIpAddrRange = String ID of bad range popup text, e.g.
            "You must choose a value between %1 and %2 for this field."
    return
        TRUE on success, FALSE on failure.

    This function does all the one time initialization of IPAddress custom
    controls.  Specifically it creates the IPAddress window class.
*/
int FAR PASCAL
IpAddrInit(
    IN HANDLE hInstance,
    IN DWORD  dwErrorTitle,
    IN DWORD  dwBadIpAddrRange )
{
    HGLOBAL            hClassStruct;
    LPWNDCLASS        lpClassStruct;

    /* register IPAddress window if necessary */
    if ( g_hLibInstance == NULL ) {

        /* allocate memory for class structure */
        hClassStruct = GlobalAlloc( GHND, (DWORD)sizeof(WNDCLASS) );
        if ( hClassStruct ) {

            /* lock it down */
            lpClassStruct = (LPWNDCLASS)GlobalLock( hClassStruct );
            if ( lpClassStruct ) {

                /* define class attributes */
                lpClassStruct->lpszClassName = IPADDRESS_CLASS;
                lpClassStruct->hCursor =       LoadCursor(NULL,IDC_IBEAM);
                lpClassStruct->lpszMenuName =  (LPCTSTR)NULL;
                lpClassStruct->style =         CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS|CS_GLOBALCLASS;
                lpClassStruct->lpfnWndProc =   IPAddressWndFn;
                lpClassStruct->hInstance =     hInstance;
                lpClassStruct->hIcon =         NULL;
                lpClassStruct->cbWndExtra =    IPADDRESS_EXTRA;
                lpClassStruct->hbrBackground = (HBRUSH)(COLOR_WINDOW + 1 );

                /* register IPAddress window class */
                g_hLibInstance = ( RegisterClass(lpClassStruct) ) ? hInstance : NULL;
                GlobalUnlock( hClassStruct );
            }
            GlobalFree( hClassStruct );
        }
    }
    SetDefaultFont();

    g_dwErrorTitle = dwErrorTitle;
    g_dwBadIpAddrRange = dwBadIpAddrRange;

    return( g_hLibInstance ? 1:0 );
}

// Use this function to force the ip address entered to
// be contiguous (series of 1's followed by a series of 0's).
// This is useful for entering valid submasks
//
// Returns NO_ERROR if successful, error code otherwise
//
DWORD APIENTRY IpAddr_ForceContiguous(HWND hwndIpAddr) {
    DWORD dwOldStyle;

    // Set the last error information so that we can
    // return an error correctly
    SetLastError(NO_ERROR);

    // Set the extended style of the given window so
    // that it descriminates the address entered.
    dwOldStyle = IPADDR_GET_SUBSTYLE(hwndIpAddr);
    IPADDR_SET_SUBSTYLE(hwndIpAddr, dwOldStyle | IPADDR_EX_STYLE_CONTIGUOUS);

    return GetLastError();
}


void FormatIPAddress(LPTSTR pszString, DWORD* dwValue)
{
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    int nField, nPos;
    BOOL fFinish = FALSE;

    dwValue[0] = 0; dwValue[1] = 0; dwValue[2] = 0; dwValue[3] = 0;

    if (pszString[0] == 0)
        return;

    for( nField = 0, nPos = 0; !fFinish; nPos++)
    {
        if (( pszString[nPos]<TEXT('0')) || (pszString[nPos]>TEXT('9')))
        {
            // not a number
            nField++;
            fFinish = (nField == 4);
        }
        else
        {
            dwValue[nField] *= 10;
            dwValue[nField] += (pszString[nPos]-TEXT('0'));
        }
    }
}

// This function causes the ip address entered into hwndIpAddr to be
// corrected so that it is contiguous.
DWORD IpAddrMakeContiguous(HWND hwndIpAddr) {
    DWORD i, dwNewMask, dwMask;

    // Read in the current address
    SendMessage(hwndIpAddr, IP_GETADDRESS, 0, (LPARAM)&dwMask);

    // Find out where the first '1' is in binary going right to left
    dwNewMask = 0;
    for (i = 0; i < sizeof(dwMask)*8; i++) {
        dwNewMask |= 1 << i;
        if (dwNewMask & dwMask) {
            break;
        }
    }

    // At this point, dwNewMask is 000...0111...  If we inverse it,
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwNewMask = dwMask | ~dwNewMask;

    // If the new mask is different, correct it here
    if (dwMask != dwNewMask) {
        WCHAR pszAddr[32];
        wsprintfW(pszAddr, L"%d.%d.%d.%d", FIRST_IPADDRESS (dwNewMask),
                                           SECOND_IPADDRESS(dwNewMask),
                                           THIRD_IPADDRESS (dwNewMask),
                                           FOURTH_IPADDRESS(dwNewMask));
        SendMessage(hwndIpAddr, IP_SETADDRESS, 0, (LPARAM)pszAddr);
    }

    return NO_ERROR;
}


LRESULT FAR PASCAL IPAddressWndFn( hWnd, wMsg, wParam, lParam )
    HWND            hWnd;
    UINT            wMsg;
    WPARAM            wParam;
    LPARAM            lParam;
{
    LONG lResult;
    HGLOBAL hControl;
    CONTROL *pControl;
    int i;

    lResult = TRUE;

    switch( wMsg )
    {

    case WM_HELP:
    {
        HWND hwndParent = GetParent(hWnd);
        HELPINFO* p = (HELPINFO*)lParam;

        p->hItemHandle = hWnd;
        p->iCtrlId = (INT) GetWindowLongPtr(hWnd, GWLP_ID);
        
        TRACE4( "IPAddressWndFn(HLP,t=%d,id=%d,h=$%08x,p=$%08x)",
            p->iContextType,p->iCtrlId,p->hItemHandle,hwndParent);

        SendMessage(hwndParent, WM_HELP, wParam, lParam);
        return 0;
    }        
    break;
        
    case WM_CONTEXTMENU:
    {
        SendMessage(GetParent(hWnd), WM_CONTEXTMENU, (WPARAM)GetParent(hWnd), 0);
        return 0;
    }
    break;
        
// use empty string (not NULL) to set to blank
    case WM_SETTEXT:
        {
            static TCHAR szBuf[CHARS_PER_FIELD+1];
            DWORD dwValue[4];
            LPTSTR pszString = (LPTSTR)lParam;

            if (!pszString)
                pszString = TEXT("0.0.0.0");

            FormatIPAddress(pszString, &dwValue[0]);

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            pControl->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                if (pszString[0] == 0)
                {
                    szBuf[0] = 0;
                }
                else
                {
                    wsprintf(szBuf, TEXT("%d"), dwValue[i]);
                }
                SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
            }

            pControl->bCancelParentNotify = FALSE;

            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            GlobalUnlock(hControl);
        }
        break;

    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
        {
            int iFieldValue;
            int srcPos, desPos;
            DWORD dwValue[4];
            TCHAR pszResult[30];
            TCHAR *pszDest = (TCHAR *)lParam;

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            lResult = 0;
            dwValue[0] = 0;
            dwValue[1] = 0;
            dwValue[2] = 0;
            dwValue[3] = 0;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                iFieldValue = GetFieldValue(&(pControl->Children[i]));
                if (iFieldValue == -1)
                    iFieldValue = 0;
                else
                    ++lResult;
                dwValue[i] = iFieldValue;
            }
            wsprintf( pszResult, TEXT("%d.%d.%d.%d"), dwValue[0], dwValue[1], dwValue[2], dwValue[3] );
            if ( wMsg == WM_GETTEXTLENGTH )
            {
                lResult = lstrlen( pszResult );
            }
            else
            {
                for ( srcPos=0, desPos=0; (srcPos+1<(INT)wParam) && (pszResult[srcPos]!=TEXT('\0')); )
                {
                    pszDest[desPos++] = pszResult[srcPos++];
                }
                pszDest[desPos]=TEXT('\0');
                lResult = desPos;
            }
            GlobalUnlock(hControl);
        }
        break;

    case WM_GETDLGCODE :
        lResult = DLGC_WANTCHARS;
        break;

    case WM_NCCREATE:
        SetWindowLong(hWnd, GWL_EXSTYLE, (GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_CLIENTEDGE));
        lResult = TRUE;
        break;

    case WM_CREATE : /* create pallette window */
        {
            HDC hdc;
            UINT uiFieldStart;
            FARPROC lpfnFieldProc;

            hControl = GlobalAlloc(GMEM_MOVEABLE, sizeof(CONTROL));
            if (hControl)
            {
                HFONT OldFont;
                RECT rect;

                #define LPCS    ((CREATESTRUCT *)lParam)

                pControl = (CONTROL *)GlobalLock(hControl);
                pControl->fEnabled = TRUE;
                pControl->fPainted = FALSE;
                pControl->fInMessageBox = FALSE;
                pControl->hwndParent = LPCS->hwndParent;
                pControl->uiFillerWidth = 1;
                pControl->bControlInFocus = FALSE;
                pControl->bCancelParentNotify = FALSE;

                hdc = GetDC(hWnd);
                GetClientRect(hWnd, &rect);
                OldFont = SelectObject( hdc, CreateFontIndirect(&logfont) );
                if( NULL != OldFont )
                {
                    HFONT NewFont;
                    GetCharWidth(hdc, FILLER, FILLER,
                                            (int *)(&pControl->uiFillerWidth));
                    NewFont = SelectObject(hdc, OldFont );
                    if( NULL != NewFont )
                    {
                        DeleteObject( NewFont );
                    }
                }
                ReleaseDC(hWnd, hdc);

                pControl->uiFieldWidth = (LPCS->cx
                                          - LEAD_ROOM
                                          - pControl->uiFillerWidth
                                              *(NUM_FIELDS-1))
                                                  / NUM_FIELDS;
                uiFieldStart = LEAD_ROOM;

                lpfnFieldProc = MakeProcInstance((FARPROC)IPAddressFieldProc,
                                                 LPCS->hInstance);

                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    pControl->Children[i].byLow = MIN_FIELD_VALUE;
                    pControl->Children[i].byHigh = MAX_FIELD_VALUE;

                    pControl->Children[i].hWnd = CreateWindowEx(0,
                                        TEXT("Edit"),
                                        NULL,
                                        WS_CHILD | WS_VISIBLE |
                                        ES_CENTER,
                                        uiFieldStart,
                                        HEAD_ROOM,
                                        pControl->uiFieldWidth,
                                        (rect.bottom-rect.top),
                                        hWnd,
                                        (HMENU)UlongToPtr(i),
                                        LPCS->hInstance,
                                        (LPVOID)NULL);

                    SendMessage(pControl->Children[i].hWnd, EM_LIMITTEXT,
                                CHARS_PER_FIELD, 0L);

                    SendMessage(pControl->Children[i].hWnd, WM_SETFONT,
                                (WPARAM)CreateFontIndirect(&logfont), TRUE);

                    pControl->Children[i].lpfnWndProc =
                        (FARPROC) GetWindowLongPtr(pControl->Children[i].hWnd,
                                                GWLP_WNDPROC);

                    SetWindowLongPtr(pControl->Children[i].hWnd,
                                  GWLP_WNDPROC, (ULONG_PTR)lpfnFieldProc);

                    uiFieldStart += pControl->uiFieldWidth
                                    + pControl->uiFillerWidth;
                }

                GlobalUnlock(hControl);
                SAVE_CONTROL_HANDLE(hWnd, hControl);

                #undef LPCS
            }
            else
                DestroyWindow(hWnd);
        }
        lResult = 0;
        break;

    case WM_PAINT: /* paint control window */
        {
            PAINTSTRUCT Ps;
            RECT rect;
            UINT uiFieldStart;
            COLORREF TextColor;
            COLORREF cRef;
            HFONT OldFont, NewFont, TmpFont;
            HBRUSH hbr;

            //Add return value check for bug 199026
            if ( BeginPaint(hWnd, (LPPAINTSTRUCT)&Ps) )
            {
                NewFont = CreateFontIndirect(&logfont);
                if (NewFont)
                {
                    OldFont = SelectObject( Ps.hdc, NewFont );
                    if (OldFont)
                    {
                        GetClientRect(hWnd, &rect);
                        hControl = GET_CONTROL_HANDLE(hWnd);
                        if (hControl)
                        {
                            pControl = (CONTROL *)GlobalLock(hControl);
                            if (pControl)
                            {
                                if (pControl->fEnabled)
                                {
                                    TextColor = GetSysColor(COLOR_WINDOWTEXT);
                                    cRef = GetSysColor(COLOR_WINDOW);

                                }
                                else
                                {
                                    TextColor = GetSysColor(COLOR_GRAYTEXT);
                                    cRef = GetSysColor(COLOR_3DFACE);
                                }

                                if (cRef)
                                    SetBkColor(Ps.hdc, cRef);

                                if (TextColor)
                                    SetTextColor(Ps.hdc, TextColor);


                                hbr = CreateSolidBrush(cRef);
                                if ( NULL != hbr )
                                {
                                    FillRect(Ps.hdc, &rect, hbr);
                                    DeleteObject(hbr);
                                }

                                SetRect(&rect, 
                                        0, 
                                        HEAD_ROOM, 
                                        pControl->uiFillerWidth, 
                                        (rect.bottom-rect.top));

                                ExtTextOut(Ps.hdc, 
                                           rect.left, 
                                           HEAD_ROOM, 
                                           ETO_OPAQUE, 
                                           &rect, 
                                           L" ", 
                                           1, 
                                           NULL);

                                for (i = 0; i < NUM_FIELDS-1; ++i)
                                {
                                    rect.left += pControl->uiFieldWidth + 
                                                 pControl->uiFillerWidth;

                                    rect.right += rect.left + 
                                                  pControl->uiFillerWidth;

                                    ExtTextOut(Ps.hdc, 
                                               rect.left, 
                                               HEAD_ROOM, 
                                               ETO_OPAQUE, 
                                               &rect, 
                                               SZFILLER, 
                                               1, 
                                               NULL);
                                }

                                pControl->fPainted = TRUE;

                                GlobalUnlock(hControl);
                            }
                        }
                    
                        TmpFont = SelectObject(Ps.hdc, OldFont);

                        if (TmpFont)
                        {
                            NewFont = TmpFont;
                        }
                        else
                        {
                            NewFont = OldFont;
                        }
                    }

                    DeleteObject(NewFont);
                }
            EndPaint(hWnd, &Ps);
            }
        }
        break;

    case WM_SETFOCUS : /* get focus - display caret */
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);
        EnterField(&(pControl->Children[0]), 0, CHARS_PER_FIELD);
        GlobalUnlock(hControl);
        break;

    case WM_LBUTTONDOWN : /* left button depressed - fall through */
        SetFocus(hWnd);
        break;

    case WM_ENABLE:
        {
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            pControl->fEnabled = (BOOL)wParam;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                EnableWindow(pControl->Children[i].hWnd, (BOOL)wParam);
            }
            if (pControl->fPainted)    InvalidateRect(hWnd, NULL, FALSE);
            GlobalUnlock(hControl);
        }
        break;

    case WM_DESTROY :
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);

// Restore all the child window procedures before we delete our memory block.
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            SetWindowLongPtr(pControl->Children[i].hWnd, GWLP_WNDPROC,
                          (ULONG_PTR)pControl->Children[i].lpfnWndProc);
        }

        GlobalUnlock(hControl);
        GlobalFree(hControl);
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
// One of the fields lost the focus, see if it lost the focus to another field
// of if we've lost the focus altogether.  If its lost altogether, we must send
// an EN_KILLFOCUS notification on up the ladder.
        case EN_KILLFOCUS:
            {
                HWND hFocus;

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                if (!pControl->fInMessageBox)
                {
                    hFocus = GetFocus();
                    for (i = 0; i < NUM_FIELDS; ++i)
                        if (pControl->Children[i].hWnd == hFocus)
                            break;

                    if (i >= NUM_FIELDS)
                    {
                        // Before sending the message up the ladder, make sure that
                        // the ip address is contiguous if needed
                        if (IPADDR_GET_SUBSTYLE(hWnd) & IPADDR_EX_STYLE_CONTIGUOUS)
                            IpAddrMakeContiguous(hWnd);

                        SendMessage(pControl->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID),
                                    EN_KILLFOCUS), (LPARAM)hWnd);
                        pControl->bControlInFocus = FALSE;
                    }
                }
                GlobalUnlock(hControl);
            }
            break;

        case EN_SETFOCUS:
            {
                HWND hFocus;

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                if (!pControl->fInMessageBox)
                {
                    hFocus = (HWND)lParam;

                    for (i = 0; i < NUM_FIELDS; ++i)
                        if (pControl->Children[i].hWnd == hFocus)
                            break;

                    // send a focus message when the
                    if (i < NUM_FIELDS && pControl->bControlInFocus == FALSE)
                    {
                        SendMessage(pControl->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID),
                                    EN_SETFOCUS), (LPARAM)hWnd);

                    pControl->bControlInFocus = TRUE; // only set the focus once
                    }
                }
                GlobalUnlock(hControl);
            }
            break;

        case EN_CHANGE:
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            if (pControl->bCancelParentNotify == FALSE)
            {
                    SendMessage(pControl->hwndParent, WM_COMMAND,
                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            }

            GlobalUnlock(hControl);

            break;
        }
        break;

// Get the value of the IP Address.  The address is placed in the DWORD pointed
// to by lParam and the number of non-blank fields is returned.
    case IP_GETADDRESS:
        {
            int iFieldValue;
            DWORD dwValue;

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            lResult = 0;
            dwValue = 0;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                iFieldValue = GetFieldValue(&(pControl->Children[i]));
                if (iFieldValue == -1)
                    iFieldValue = 0;
                else
                    ++lResult;
                dwValue = (dwValue << 8) + iFieldValue;
            }
            *((DWORD *)lParam) = dwValue;

            GlobalUnlock(hControl);
        }
        break;

// Clear all fields to blanks.
    case IP_CLEARADDRESS:
        {
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            pControl->bCancelParentNotify = TRUE;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) TEXT(""));
            }
            pControl->bCancelParentNotify = FALSE;
            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            GlobalUnlock(hControl);
        }
        break;

// Set the value of the IP Address.  The address is in the lParam with the
// first address byte being the high byte, the second being the second byte,
// and so on.  A lParam value of -1 removes the address.
    case IP_SETADDRESS:
        {
            static TCHAR szBuf[CHARS_PER_FIELD+1];
            DWORD dwValue[4];
            LPTSTR pszString = (LPTSTR)lParam;

            FormatIPAddress(pszString, &dwValue[0]);

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            pControl->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                if (pszString[0] == 0)
                {
                    szBuf[0] =0;
                }
                else
                {
                    wsprintf(szBuf, TEXT("%d"), dwValue[i]);
                }
                SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
            }


            pControl->bCancelParentNotify = FALSE;

            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            GlobalUnlock(hControl);
        }
        break;

    case IP_SETRANGE:
        if (wParam < NUM_FIELDS)
        {
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            pControl->Children[wParam].byLow = LOBYTE(LOWORD(lParam));
            pControl->Children[wParam].byHigh = HIBYTE(LOWORD(lParam));

            GlobalUnlock(hControl);
        }
        break;

// Set the focus to this control.
// wParam = the field number to set focus to, or -1 to set the focus to the
// first non-blank field.
    case IP_SETFOCUS:
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);

        if (wParam >= NUM_FIELDS)
        {
            for (wParam = 0; wParam < NUM_FIELDS; ++wParam)
                if (GetFieldValue(&(pControl->Children[wParam])) == -1)   break;
            if (wParam >= NUM_FIELDS)    wParam = 0;
        }
        EnterField(&(pControl->Children[wParam]), 0, CHARS_PER_FIELD);

        GlobalUnlock(hControl);
        break;

// Determine whether all four subfields are blank
    case IP_ISBLANK:
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);

        lResult = TRUE;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            if (GetFieldValue(&(pControl->Children[i])) != -1)
            {
                lResult = FALSE;
                break;
            }
        }

        GlobalUnlock(hControl);
        break;

    default:
        lResult = (LONG) DefWindowProc( hWnd, wMsg, wParam, lParam );
        break;
    }
    return( lResult );
}




/*
    IPAddressFieldProc() - Edit field window procedure

    This function sub-classes each edit field.
*/
LRESULT FAR PASCAL IPAddressFieldProc(HWND hWnd,
                                       UINT wMsg,
                                       WPARAM wParam,
                                       LPARAM lParam)
{
    HANDLE hControl;
    CONTROL *pControl;
    FIELD *pField;
    HWND hControlWindow;
    WORD wChildID;
    LRESULT lresult;

    if (!(hControlWindow = GetParent(hWnd)))
        return 0;

    hControl = GET_CONTROL_HANDLE(hControlWindow);
    pControl = (CONTROL *)GlobalLock(hControl);
    wChildID = (WORD)GetWindowLong(hWnd, GWL_ID);
    pField = &(pControl->Children[wChildID]);
    if (pField->hWnd != hWnd)    return 0;

    switch (wMsg)
    {
    case WM_CONTEXTMENU:
    {
        SendMessage(GetParent(hWnd), WM_CONTEXTMENU, (WPARAM)GetParent(hWnd), 0);
        return 0;
    }
    break;
    
    case WM_HELP:
    {
        HWND hwndParent = GetParent(hWnd);
        HELPINFO* p = (HELPINFO*)lParam;

        p->hItemHandle = hWnd;
        p->iCtrlId = (INT) GetWindowLongPtr(hWnd, GWLP_ID);
        
        TRACE4( "IPAddressFieldProc(HLP,t=%d,id=%d,h=$%08x,p=$%08x)",
            p->iContextType,p->iCtrlId,p->hItemHandle,hwndParent);

        SendMessage(hwndParent, WM_HELP, wParam, lParam);
        return 0;
    }        
    break;
        
    case WM_DESTROY:
        DeleteObject( (HGDIOBJ)SendMessage( hWnd, WM_GETFONT, 0, 0 ));
        return 0;
    case WM_CHAR:

// Typing in the last digit in a field, skips to the next field.
        if (wParam >= TEXT('0') && wParam <= TEXT('9'))
        {
            DWORD dwResult;

            dwResult = (DWORD)CallWindowProc((WNDPROC)pControl->Children[wChildID].lpfnWndProc,
                                            hWnd, wMsg, wParam, lParam);
            dwResult = (DWORD) SendMessage(hWnd, EM_GETSEL, 0, 0L);

            if (dwResult == MAKELPARAM(CHARS_PER_FIELD, CHARS_PER_FIELD)
                && ExitField(pControl, wChildID)
                && wChildID < NUM_FIELDS-1)
            {
                EnterField(&(pControl->Children[wChildID+1]),
                                0, CHARS_PER_FIELD);
            }
            GlobalUnlock( hControl );
            return dwResult;
        }

// spaces and periods fills out the current field and then if possible,
// goes to the next field.
        else if (wParam == FILLER || wParam == SPACE )
        {
            DWORD dwResult;
            dwResult = (DWORD) SendMessage(hWnd, EM_GETSEL, 0, 0L);
            if (dwResult != 0L && HIWORD(dwResult) == LOWORD(dwResult)
                && ExitField(pControl, wChildID))
            {
                if (wChildID >= NUM_FIELDS-1)
                    MessageBeep((UINT)-1);
                else
                {
                    EnterField(&(pControl->Children[wChildID+1]),
                                    0, CHARS_PER_FIELD);
                }
            }
            GlobalUnlock( hControl );
            return 0;
        }

// Backspaces go to the previous field if at the beginning of the current field.
// Also, if the focus shifts to the previous field, the backspace must be
// processed by that field.
        else if (wParam == BACK_SPACE)
        {
            if (wChildID > 0 && SendMessage(hWnd, EM_GETSEL, 0, 0L) == 0L)
            {
                if (SwitchFields(pControl, wChildID, wChildID-1,
                              CHARS_PER_FIELD, CHARS_PER_FIELD)
                    && SendMessage(pControl->Children[wChildID-1].hWnd,
                        EM_LINELENGTH, 0, 0L) != 0L)
                {
                    SendMessage(pControl->Children[wChildID-1].hWnd,
                                wMsg, wParam, lParam);
                }
                GlobalUnlock( hControl );
                return 0;
            }
        }

// Any other printable characters are not allowed.
        else if (wParam > SPACE)
        {
            MessageBeep((UINT)-1);
            GlobalUnlock( hControl );
            return 0;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {

// Arrow keys move between fields when the end of a field is reached.
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                if ((wParam == VK_LEFT || wParam == VK_UP) && wChildID > 0)
                {
                    SwitchFields(pControl, wChildID, wChildID-1,
                                  0, CHARS_PER_FIELD);
                    GlobalUnlock( hControl );
                    return 0;
                }
                else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                         && wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pControl, wChildID, wChildID+1,
                                      0, CHARS_PER_FIELD);
                    GlobalUnlock( hControl );
                    return 0;
                }
            }
            else
            {
                DWORD dwResult;
                WORD wStart, wEnd;

                dwResult = (DWORD) SendMessage(hWnd, EM_GETSEL, 0, 0L);
                wStart = LOWORD(dwResult);
                wEnd = HIWORD(dwResult);
                if (wStart == wEnd)
                {
                    if ((wParam == VK_LEFT || wParam == VK_UP)
                        && wStart == 0
                        && wChildID > 0)
                    {
                        SwitchFields(pControl, wChildID, wChildID-1,
                                          CHARS_PER_FIELD, CHARS_PER_FIELD);
                        GlobalUnlock( hControl );
                        return 0;
                    }
                    else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                             && wChildID < NUM_FIELDS-1)
                    {
                        dwResult = (DWORD)SendMessage(hWnd, EM_LINELENGTH, 0, 0L);
                        if (wStart >= dwResult)
                        {
                            SwitchFields(pControl, wChildID, wChildID+1, 0, 0);
                            GlobalUnlock( hControl );
                            return 0;
                        }
                    }
                }
            }
            break;

// Home jumps back to the beginning of the first field.
        case VK_HOME:
            if (wChildID > 0)
            {
                SwitchFields(pControl, wChildID, 0, 0, 0);
                GlobalUnlock( hControl );
                return 0;
            }
            break;

// End scoots to the end of the last field.
        case VK_END:
            if (wChildID < NUM_FIELDS-1)
            {
                SwitchFields(pControl, wChildID, NUM_FIELDS-1,
                                CHARS_PER_FIELD, CHARS_PER_FIELD);
                GlobalUnlock( hControl );
                return 0;
            }
            break;


        } // switch (wParam)

        break;

    case WM_KILLFOCUS:
        if ( !ExitField( pControl, wChildID ))
        {
            GlobalUnlock( hControl );
            return 0;
        }

    } // switch (wMsg)

    lresult = CallWindowProc( (WNDPROC)pControl->Children[wChildID].lpfnWndProc,
        hWnd, wMsg, wParam, lParam);
    GlobalUnlock( hControl );
    return lresult;
}




/*
    Switch the focus from one field to another.
    call
        pControl = Pointer to the CONTROL structure.
        iOld = Field we're leaving.
        iNew = Field we're entering.
        hNew = Window of field to goto
        wStart = First character selected
        wEnd = Last character selected + 1
    returns
        TRUE on success, FALSE on failure.

    Only switches fields if the current field can be validated.
*/
BOOL SwitchFields(CONTROL *pControl, int iOld, int iNew, WORD wStart, WORD wEnd)
{
    if (!ExitField(pControl, iOld))    return FALSE;
    EnterField(&(pControl->Children[iNew]), wStart, wEnd);
    return TRUE;
}



/*
    Set the focus to a specific field's window.
    call
        pField = pointer to field structure for the field.
        wStart = First character selected
        wEnd = Last character selected + 1
*/
void EnterField(FIELD *pField, WORD wStart, WORD wEnd)
{
    SetFocus(pField->hWnd);
    SendMessage(pField->hWnd, EM_SETSEL, wStart, wEnd);
}


/*
    Exit a field.
    call
        pControl = pointer to CONTROL structure.
        iField = field number being exited.
    returns
        TRUE if the user may exit the field.
        FALSE if he may not.
*/
BOOL ExitField(CONTROL  *pControl, int iField)
{
    HWND hControlWnd;
    HWND hDialog;
    WORD wLength;
    FIELD *pField;
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    int i,j;

    pField = &(pControl->Children[iField]);
    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        for (j=0,i=0;j<(INT)wLength;j++)
        {
            i=i*10+szBuf[j]-TEXT('0');
        }
        if (i < (int)(UINT)pField->byLow || i > (int)(UINT)pField->byHigh)
        {
            if ( i < (int)(UINT) pField->byLow )
            {
                /* too small */
                wsprintf(szBuf, TEXT("%d"), (int)(UINT)pField->byLow );
            }
            else
            {
                /* must be bigger */
                wsprintf(szBuf, TEXT("%d"), (int)(UINT)pField->byHigh );
            }
            SendMessage(pField->hWnd, WM_SETTEXT, 0, (LPARAM) (LPSTR) szBuf);
            if ((hControlWnd = GetParent(pField->hWnd)) != NULL
                && (hDialog = GetParent(hControlWnd)) != NULL)
            {
                MSGARGS msgargs;
                TCHAR   szLow[ 50 ];
                TCHAR   szHigh[ 50 ];

                pControl->fInMessageBox = TRUE;

                ZeroMemory( &msgargs, sizeof(msgargs) );
                msgargs.dwFlags = MB_ICONEXCLAMATION + MB_OK;
                wsprintf( szLow, TEXT("%d"), (int )pField->byLow );
                msgargs.apszArgs[ 0 ] = szLow;
                wsprintf( szHigh, TEXT("%d"), (int )pField->byHigh );
                msgargs.apszArgs[ 1 ] = szHigh;

                MsgDlgUtil( hDialog, g_dwBadIpAddrRange,
                    &msgargs, g_hLibInstance, g_dwErrorTitle );

                pControl->fInMessageBox = FALSE;
                SendMessage(pField->hWnd, EM_SETSEL, 0, CHARS_PER_FIELD);
                return FALSE;
            }
        }
    }
    return TRUE;
}


/*
    Get the value stored in a field.
    call
        pField = pointer to the FIELD structure for the field.
    returns
        The value (0..255) or -1 if the field has not value.
*/
int GetFieldValue(FIELD *pField)
{
    WORD wLength;
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    INT i,j;

    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        for (j=0,i=0;j<(INT)wLength;j++)
        {
            i=i*10+szBuf[j]-TEXT('0');
        }
        return i;
    }
    else
        return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\uiutil\popupdlg.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** popupdlg.c
** UI helper library
** Popup dialog routines
** Listed alphabetically
**
** 08/25/95 Steve Cobb
*/


#include <nt.h>       // NT declarations
#include <ntrtl.h>    // NT general runtime-library
#include <nturtl.h>   // NT user-mode runtime-library
#include <windows.h>  // Win32 root
#include <lmerr.h>    // LAN Manager errors
#include <lmcons.h>   // LAN Manager constants
#include <stdarg.h>   // To stop va_list argument warning only
#include <ras.h>      // RAS API definitions
#include <raserror.h> // Win32 RAS error codes
#include <debug.h>    // Trace/assert library
#include <nouiutil.h> // No-HWND utilities
#include <uiutil.h>   // Our public header


/*----------------------------------------------------------------------------
** Error popup
**----------------------------------------------------------------------------
*/

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat )

    /* Pops up a modal error dialog centered on 'hwndOwner'.  'DwOperation' is
    ** the string resource ID of the string describing the operation underway
    ** when the error occurred.  'DwError' is the code of the system or RAS
    ** error that occurred.  'Pargs' is a extended formatting arguments or
    ** NULL if none.  'hInstance' is the application/module handle where
    ** string resources are located.  'DwTitle' is the string ID of the dialog
    ** title.  'DwFormat' is the string ID of the error format title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszOp;
    TCHAR  szErrorNum[ 50 ];
    TCHAR* pszError;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("ErrorDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the error number string.
    */
    if (dwError > 0x7FFFFFFF)
        wsprintf( szErrorNum, TEXT("0x%X"), dwError );
    else
        wsprintf( szErrorNum, TEXT("%u"), dwError );

    /* Build the error text string.
    */
    if (!GetErrorText( dwError, &pszError ))
        pszError = pszNotFound;

    /* Build the operation string.
    */
    pszUnformatted = PszFromId( hInstance, dwOperation );
    pszOp = pszNotFound;

    if (pszUnformatted)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pszUnformatted, 0, 0, (LPTSTR )&pszOp, 1,
            (va_list* )((pargs) ? pargs->apszOpArgs : NULL) );

        Free( pszUnformatted );
    }

    /* Call MsgDlgUtil with the standard arguments plus any auxillary format
    ** arguments.
    */
    pszUnformatted = PszFromId( hInstance, dwFormat );
    pszResult = pszNotFound;

    if (pszUnformatted)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.dwFlags = MB_ICONEXCLAMATION + MB_OK + MB_SETFOREGROUND;
        msgargs.pszString = pszUnformatted;
        msgargs.apszArgs[ 0 ] = pszOp;
        msgargs.apszArgs[ 1 ] = szErrorNum;
        msgargs.apszArgs[ 2 ] = pszError;

        if (pargs)
        {
            msgargs.fStringOutput = pargs->fStringOutput;

            CopyMemory( &msgargs.apszArgs[ 3 ], pargs->apszAuxFmtArgs,
                3 * sizeof(TCHAR) );
        }

        nResult =
            MsgDlgUtil(
                hwndOwner, 0, &msgargs, hInstance, dwTitle );

        Free( pszUnformatted );

        if (pargs && pargs->fStringOutput)
            pargs->pszOutput = msgargs.pszOutput;
    }

    if (pszOp != pszNotFound)
        LocalFree( pszOp );
    if (pszError != pszNotFound)
        LocalFree( pszError );

    return nResult;
}


BOOL
GetErrorText(
    DWORD   dwError,
    TCHAR** ppszError )

    /* Fill caller's '*ppszError' with the address of a LocalAlloc'ed heap
    ** block containing the error text associated with error 'dwError'.  It is
    ** caller's responsibility to LocalFree the returned string.
    **
    ** Returns true if successful, false otherwise.
    */
{
#define MAXRASERRORLEN 256

    TCHAR  szBuf[ MAXRASERRORLEN + 1 ];
    DWORD  dwFlags;
    HANDLE hmodule;
    DWORD  cch;

    /* Don't panic if the RAS API address is not loaded.  Caller may be trying
    ** and get an error up during LoadRas.
    */
    if ((Rasapi32DllLoaded() || RasRpcDllLoaded())
        && g_pRasGetErrorString
        && g_pRasGetErrorString(
               (UINT )dwError, (LPTSTR )szBuf, MAXRASERRORLEN ) == 0)
    {
        /* It's a RAS error.
        */
        *ppszError = LocalAlloc( LPTR, (lstrlen( szBuf ) + 1) * sizeof(TCHAR) );
        if (!*ppszError)
            return FALSE;

        lstrcpy( *ppszError, szBuf );
        return TRUE;
    }

    /* The rest adapted from BLT's LoadSystem routine.
    */
    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER + FORMAT_MESSAGE_IGNORE_INSERTS;

    if (dwError >= MIN_LANMAN_MESSAGE_ID && dwError <= MAX_LANMAN_MESSAGE_ID)
    {
        /* It's a net error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_HMODULE;
        hmodule = GetModuleHandle( TEXT("NETMSG.DLL") );
    }
    else
    {
        /* It must be a system error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_SYSTEM;
        hmodule = NULL;
    }

    /* Whistler bug: 389111 VPN connection returns unacceptable error message
    ** when smart card is not available
    */
    dwFlags |= FORMAT_MESSAGE_MAX_WIDTH_MASK;

    /* This is an NTSTATUS error msg.
    */
    if (NT_ERROR(dwError))
    {
        dwError = RtlNtStatusToDosError( dwError );
    }

    cch = FormatMessage(
            dwFlags, hmodule, dwError, 0, (LPTSTR )ppszError, 1, NULL );

    /* FormatMessage failed so we are going to get a generic one from RAS.
    */
    if (!cch || !*ppszError)
    {
        Free0( *ppszError );
        dwError = ERROR_UNKNOWN;

        if ((Rasapi32DllLoaded() || RasRpcDllLoaded())
            && g_pRasGetErrorString
            && g_pRasGetErrorString(
                   (UINT )dwError, (LPTSTR )szBuf, MAXRASERRORLEN ) == 0)
        {
            *ppszError = LocalAlloc( LPTR, (lstrlen( szBuf ) + 1) *
                            sizeof(TCHAR) );
            if (!*ppszError)
                return FALSE;

            lstrcpy( *ppszError, szBuf );
            return TRUE;
        }
    }

    return (cch > 0);
}


/*----------------------------------------------------------------------------
** Message popup
**----------------------------------------------------------------------------
*/

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle )

    /* Pops up a message dialog centered on 'hwndOwner'.  'DwMsg' is the
    ** string resource ID of the message text.  'Pargs' is a extended
    ** formatting arguments or NULL if none.  'hInstance' is the
    ** application/module handle where string resources are located.
    ** 'DwTitle' is the string ID of the dialog title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("MsgDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the message string.
    */
    pszResult = pszNotFound;

    if (pargs && pargs->pszString)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pargs->pszString, 0, 0, (LPTSTR )&pszResult, 1,
            (va_list* )pargs->apszArgs );
    }
    else
    {
        pszUnformatted = PszFromId( hInstance, dwMsg );

        if (pszUnformatted)
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING +
                    FORMAT_MESSAGE_ALLOCATE_BUFFER +
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszUnformatted, 0, 0, (LPTSTR )&pszResult, 1,
                (va_list* )((pargs) ? pargs->apszArgs : NULL) );

            Free( pszUnformatted );
        }
    }

    if (!pargs || !pargs->fStringOutput)
    {
        TCHAR* pszTitle;
        DWORD  dwFlags;
        HHOOK  hhook;

        if (pargs && pargs->dwFlags != 0)
            dwFlags = pargs->dwFlags;
        else
            dwFlags = MB_ICONINFORMATION + MB_OK + MB_SETFOREGROUND;

        pszTitle = PszFromId( hInstance, dwTitle );

        if (hwndOwner)
        {
            /* Install hook that will get the message box centered on the
            ** owner window.
            */
            hhook = SetWindowsHookEx( WH_CALLWNDPROC,
                CenterDlgOnOwnerCallWndProc,
                hInstance, GetCurrentThreadId() );
        }
        else
            hhook = NULL;

        if (pszResult)
        {
            nResult = MessageBox( hwndOwner, pszResult, pszTitle, dwFlags );
        }

        if (hhook)
            UnhookWindowsHookEx( hhook );

        Free0( pszTitle );
        if (pszResult != pszNotFound)
            LocalFree( pszResult );
    }
    else
    {
        /* Caller wants the string without doing the popup.
        */
        pargs->pszOutput = (pszResult != pszNotFound) ? pszResult : NULL;
        nResult = IDOK;
    }

    return nResult;
}


LRESULT CALLBACK
CenterDlgOnOwnerCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam )

    /* Standard Win32 CallWndProc hook callback that looks for the next dialog
    ** started and centers it on it's owner window.
    */
{
    /* Arrive here when any window procedure associated with our thread is
    ** called.
    */
    if (!wparam)
    {
        CWPSTRUCT* p = (CWPSTRUCT* )lparam;

        /* The message is from outside our process.  Look for the MessageBox
        ** dialog initialization message and take that opportunity to center
        ** the dialog on it's owner's window.
        */
        if (p->message == WM_INITDIALOG)
            CenterWindow( p->hwnd, GetParent( p->hwnd ) );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\uiutil\tldef.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    tldef.h
//
// History:
//  Abolade Gbadegesin   Nov-20-1995    Created.
//
// Private implementation declarations for TreeList control.
//============================================================================

#ifndef _TLDEF_H_
#define _TLDEF_H_


typedef struct _TLITEM {

    struct _TLITEM *pParent;
    LIST_ENTRY      leSiblings;
    LIST_ENTRY      lhChildren;
    LIST_ENTRY      lhSubitems;
    INT             iLevel;
    INT             iIndex;
    UINT            nChildren;

    LV_ITEM         lvi;
    PTSTR           pszText;
    LPARAM          lParam;
    INT             iImage;
    UINT            uiFlag;

} TLITEM;


typedef struct _TLSUBITEM {

    LIST_ENTRY      leItems;
    DWORD           dwFlags;
    INT             iSubItem;
    PTSTR           pszText;

} TLSUBITEM;


typedef struct _TL {

    HWND            hwnd;
    UINT            iCtrlId;
    HWND            hwndList;
    HWND            hwndParent;
    TLITEM          root;
    UINT            nColumns;
    UINT            cyItem;
    UINT            cyText;
    UINT            cxIndent;
    HDC             hdcImages;
    HBITMAP         hbmp;
    HBITMAP         hbmpMem;
    UINT            cxBmp;
    UINT            cyBmp;
    HBITMAP         hbmpStart;
    HBRUSH          hbrBk;

} TL;

#define TLI_EXPANDED        0x0001

#define TL_ICONCOUNT            (IID_TL_IconLast - IID_TL_IconBase + 1)
#define TL_ICONID(index)        ((index) + IID_TL_IconBase)
#define TL_ICONINDEX(id)        ((id) - IID_TL_IconBase)

#define TL_GetPtr(hwnd)         (TL *)GetWindowLongPtr((hwnd), 0)
#define TL_SetPtr(hwnd,ptr)     (TL *)SetWindowLongPtr((hwnd), 0, (ULONG_PTR)(ptr))

#define TL_StateImageValue(p)   (((p)->lvi.state >> 12) & 0xf)
#define TL_StateImageIndex(p)   (TL_StateImageValue(p) - 1)
#define TL_IsExpanded(p)        ((p)->uiFlag & TLI_EXPANDED)
#define TL_IsVisible(p)         ((p)->iIndex != -1)

#define TL_VerticalLine         0
#define TL_RootChildless        1
#define TL_RootParentCollapsed  2
#define TL_RootParentExpanded   3
#define TL_MidChildless         4
#define TL_MidParentCollapsed   5
#define TL_MidParentExpanded    6
#define TL_EndChildless         7
#define TL_EndParentCollapsed   8
#define TL_EndParentExpanded    9
#define TL_ImageCount           10


LRESULT
CALLBACK
TL_WndProc(
    HWND hwnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
TL_OnCreate(
    TL *ptl,
    CREATESTRUCT *pcs
    );

VOID
TL_OnDestroy(
    TL *ptl
    );

BOOL
TL_NotifyParent(
    TL *ptl,
    NMHDR *pnmh
    );

LRESULT
TL_OnNotify(
    TL *ptl,
    INT iCtrlId,
    NMHDR *pnmh
    );

HTLITEM
TL_OnInsertItem(
    TL *ptl,
    TL_INSERTSTRUCT *ptlis
    );

BOOL
TL_OnDeleteItem(
    TL *ptl,
    HTLITEM hitem
    );

BOOL
TL_OnDeleteAllItems(
    TL *ptl
    );

VOID
TL_DeleteAndNotify(
    TL *ptl,
    TLITEM *pItem
    );

BOOL
TL_OnGetItem(
    TL *ptl,
    LV_ITEM *plvi
    );

BOOL
TL_OnSetItem(
    TL *ptl,
    LV_ITEM *plvi
    );

UINT
TL_OnGetItemCount(
    TL *ptl
    );

HTLITEM
TL_OnGetNextItem(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    );

#define TL_Enumerate(ptl,pitem) \
        TL_OnGetNextItem((ptl), TLGN_ENUMERATE, (HTLITEM)(pitem))

BOOL
TL_OnExpand(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    );

BOOL
TL_ItemExpand(
    TL *ptl,
    TLITEM *pItem
    );

BOOL
TL_ItemCollapse(
    TL *ptl,
    TLITEM *pItem
    );

INT
TL_OnInsertColumn(
    TL *ptl,
    INT iCol,
    LV_COLUMN *pCol
    );

BOOL
TL_OnDeleteColumn(
    TL *ptl,
    INT iCol
    );

BOOL
TL_OnSetSelection(
    TL *ptl,
    HTLITEM hItem
    );

VOID
TL_OnWindowPosChanged(
    TL *ptl,
    WINDOWPOS *pwp
    );

VOID
TL_OnEraseBackground(
    TL *ptl,
    HDC hdc
    );

BOOL
TL_OnDrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    );

BOOL
TL_DrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    );

VOID
TL_OnMeasureItem(
    TL *ptl,
    MEASUREITEMSTRUCT *pmis
    );

HBITMAP
TL_CreateColorBitmap(
    INT cx,
    INT cy
    );

VOID
TL_CreateTreeImages(
    TL *ptl
    );

VOID
TL_DottedLine(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    BOOL fVertical
    );

VOID
TL_DrawButton(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    HBRUSH hbrSign,
    HBRUSH hbrBox,
    HBRUSH hbrBk,
    BOOL bCollapsed
    );

VOID
TL_UpdateListIndices(
    TL *ptl,
    TLITEM *pStart
    );

VOID
TL_UpdateDescendantIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    );

VOID
TL_UpdateAncestorIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    );

VOID
TL_UpdateImage(
    TL *ptl,
    TLITEM *pItem,
    TLITEM **ppChanged
    );

VOID
TL_CountItems(
    TLITEM *pParent,
    INT *piCount
    );

BOOL
TL_OnRedraw(
    TL *ptl
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\uiutil\wait.c ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** wait.c
** Waiting for services popup
** Listed alphabetically
**
** 02/17/96 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace and assert
#include <nouiutil.h> // No-HWND utilities
#include <uiutil.h>   // Our public header
#include <wait.rch>   // Our resource constants

/* Set when RasLoad has completed successfully in this process context.
*/
BOOL g_fRasLoaded = FALSE;


/* Waiting for services thread argument block.
*/
#define WSARGS struct tagWSARGS
WSARGS
{
    HINSTANCE hInst;
    HWND      hwndOwner;
    HANDLE    hEventUp;
    HANDLE    hEventDie;
};

/* Waiting for services thread context.
*/
#define WSINFO struct tagWSINFO
WSINFO
{
    HANDLE hEventDie;
    DWORD  dwThreadId;
    HICON  hIcon;    
};


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

VOID
StartWaitingForServices(
    HINSTANCE hInst,
    HWND      hwndOwner,
    WSINFO*   pInfo );

VOID
StopWaitingForServices(
    IN WSINFO* pInfo );

DWORD
WsThread(
    LPVOID pArg );

BOOL CALLBACK
WsDlgProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam );


/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/

DWORD
LoadRas(
    IN HINSTANCE hInst,
    IN HWND      hwnd )

    /* Starts the RASMAN service and loads the RASMAN and RASAPI32 entrypoint
    ** addresses.  The "waiting for services" popup is displayed, if
    ** indicated.  'HInst' and 'hwnd' are the owning instance and window.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD  dwErr;
    WSINFO info;

    TRACE("LoadRas");

    ZeroMemory(&info, sizeof(WSINFO)); 
    if (g_fRasLoaded)
        dwErr = 0;
    else
    {
        if (IsRasmanServiceRunning())
            info.hEventDie = NULL;
        else
            StartWaitingForServices( hInst, hwnd, &info );

        dwErr = LoadRasapi32Dll();
        if (dwErr == 0)
        {
            dwErr = LoadRasmanDll();
            if (dwErr == 0)
            {
                ASSERT(g_pRasInitialize);
                TRACE("RasInitialize");
                dwErr = g_pRasInitialize();
                TRACE1("RasInitialize=%d",dwErr);
            }
        }

        StopWaitingForServices( &info );

        if (dwErr == 0)
            g_fRasLoaded = TRUE;
    }

    TRACE1("LoadRas=%d",dwErr);
    return dwErr;
}


VOID
StartWaitingForServices(
    HINSTANCE hInst,
    HWND      hwndOwner,
    WSINFO*   pInfo )

    /* Popup the "waiting for services" dialog in another thread.  'HInst' and
    ** 'hwnd' are the owning instance and window.  Fills caller's 'pInfo' with
    ** context to pass to StopWaitingForServices.
    */
{
#ifndef NT4STUFF

    // Set the hourglass cursor
    pInfo->hIcon = SetCursor (LoadCursor (NULL, IDC_WAIT));
    ShowCursor (TRUE);

#else 

    WSARGS* pArgs;
    HANDLE  hThread;
    HANDLE  hEventUp;

    pInfo->hEventDie = NULL;

    pArgs = (WSARGS* )Malloc( sizeof(*pArgs) );
    if (!pArgs)
        return;

    ZeroMemory( pArgs, sizeof(*pArgs) );
    pArgs->hInst = hInst;
    pArgs->hwndOwner = hwndOwner;

    hEventUp = pArgs->hEventUp =
        CreateEvent( NULL, FALSE, FALSE, NULL );
    if (!hEventUp)
    {
        Free( pArgs );
        return;
    }

    pInfo->hEventDie = pArgs->hEventDie =
        CreateEvent( NULL, FALSE, FALSE, NULL );
    if (!pInfo->hEventDie)
    {
        Free( pArgs );
        CloseHandle( hEventUp );
        return;
    }

    /* Create a thread so paint messages for the popup get processed.  The
    ** current thread is going to be tied up starting RAS Manager.
    */
    hThread = CreateThread( NULL, 0, WsThread, pArgs, 0, &pInfo->dwThreadId );
    if (hThread)
    {
        /* Don't begin churning on RASMAN until the popup has displayed
        ** itself.
        */
        SetThreadPriority( hThread, THREAD_PRIORITY_HIGHEST );
        WaitForSingleObject( hEventUp, INFINITE );
        CloseHandle( hThread );
    }
    else
    {
        /* Thread was DOA.
        */
        CloseHandle( pInfo->hEventDie );
        pInfo->hEventDie = NULL;
        Free( pArgs );
    }

    CloseHandle( hEventUp );
    
#endif    
}


VOID
StopWaitingForServices(
    IN WSINFO* pInfo )

    /* Terminate the "waiting for services" popup.  'PInfo' is the context
    ** from StartWaitingForServices.
    */
{
    TRACE("StopWaitingForServices");


#ifndef NT4STUFF

    if (pInfo->hIcon == NULL)
        pInfo->hIcon = LoadCursor (NULL, IDC_ARROW);

    SetCursor (pInfo->hIcon);
    ShowCursor (TRUE);
    
#else

    if (pInfo->hEventDie)
    {
        /* The post triggers the message loop to action, but you can't rely on
        ** the posted message arriving in the thread message loop.  For
        ** example, if user holds the mouse down on the window caption, the
        ** message never appears, presumably because it's flushed by some
        ** sub-loop during "move window" processing.  Set the event to make
        ** sure the popup knows to quit the next time it processes a message.
        */
        SetEvent( pInfo->hEventDie );
        PostThreadMessage( pInfo->dwThreadId, WM_CLOSE, 0, 0 );
    }
    
#endif    
}


DWORD
WsThread(
    LPVOID pArg )

    /* Waiting for services thread main.
    */
{
    WSARGS* pArgs;
    HWND    hwnd;
    MSG     msg;

    TRACE("WsThread running");

    pArgs = (WSARGS* )pArg;
    hwnd = CreateDialog( pArgs->hInst,
               MAKEINTRESOURCE( DID_WS_WaitingForServices ),
               NULL, (DLGPROC)WsDlgProc );
    if (hwnd)
    {
        LONG lStyle;

        /* Make ourselves topmost if the owner window is, otherwise we may not
        ** be visible under the topmost window, such as the winlogin window.
        ** Note that if you actally create the dialog with an owner you have
        ** all kinds of thread related problems.  In retrospect, should have
        ** written this such that the "waiting" dialog happened in the main
        ** thread and the LoadLibraries and RasInitialize happened in the
        ** created thread which would automatically avoid this kind of
        ** problem, but this works too.
        */
        lStyle = GetWindowLong( pArgs->hwndOwner, GWL_EXSTYLE );
        if (lStyle & WS_EX_TOPMOST)
        {
            TRACE("TOPMOST");
            SetWindowPos( hwnd, HWND_TOPMOST,
                0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );
        }

        CenterWindow( hwnd, pArgs->hwndOwner );
        ShowWindow( hwnd, SW_SHOW );
        UpdateWindow( hwnd );
        SetForegroundWindow( hwnd );
    }

    /* Tell other thread to go on.
    */
    SetEvent( pArgs->hEventUp );

    if (hwnd)
    {
        TRACE("WsThread msg-loop running");

        while (GetMessage( &msg, NULL, 0, 0 ))
        {
            if (WaitForSingleObject( pArgs->hEventDie, 0 ) == WAIT_OBJECT_0)
            {
                /* Normal termination.
                */
                DestroyWindow( hwnd );
                break;
            }

            if (!IsDialogMessage( hwnd, &msg ))
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }

        if (pArgs->hwndOwner)
            SetForegroundWindow( pArgs->hwndOwner );
    }

    CloseHandle( pArgs->hEventDie );
    Free( pArgs );
    TRACE("WsThread terminating");
    return 0;
}


BOOL CALLBACK
WsDlgProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam )

    /* Standard Win32 dialog procedure.
    */
{
    if (unMsg == WM_INITDIALOG)
    {
        HMENU hmenu;

        /* Remove Close from the system menu since some people think it kills
        ** the app and not just the popup.
        */
        hmenu = GetSystemMenu( hwnd, FALSE );
        if (hmenu && DeleteMenu( hmenu, SC_CLOSE, MF_BYCOMMAND ))
            DrawMenuBar( hwnd );
        return TRUE;
    }

    return FALSE;
}


VOID
UnloadRas(
    void )

    /* Unload the DLLs loaded by LoadRas().
    */
{
    if (g_fRasLoaded)
    {
        g_fRasLoaded = FALSE;
        UnloadRasmanDll();
        UnloadRasapi32Dll();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\uiutil\ui.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** ui.c
** UI helper routines
** Listed alphabetically
**
** 08/25/95 Steve Cobb
*/


#include <windows.h>  // Win32 root
#include <windowsx.h> // Win32 macro extensions
#include <commctrl.h> // Win32 common controls
#include <debug.h>    // Trace and assert
#include <uiutil.h>   // Our public header


/*----------------------------------------------------------------------------
** Globals
**----------------------------------------------------------------------------
*/

/* See SetOffDesktop.
*/
static LPCWSTR g_SodContextId = NULL;

/* Set when running in a mode where WinHelp does not work.  This is a
** workaround to the problem where WinHelp does not work correctly before a
** user is logged on.  See AddContextHelpButton.
*/
BOOL g_fNoWinHelp = FALSE;


/*----------------------------------------------------------------------------
** Local datatypes
**----------------------------------------------------------------------------
*/

/* SetOffDesktop context.
*/
#define SODINFO struct tagSODINFO
SODINFO
{
    RECT  rectOrg;
    BOOL  fWeMadeInvisible;
};

/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

BOOL CALLBACK
CancelOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam );

BOOL CALLBACK
CloseOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam );


/*----------------------------------------------------------------------------
** Utility routines
**----------------------------------------------------------------------------
*/

VOID
AddContextHelpButton(
    IN HWND hwnd )

    /* Turns on title bar context help button in 'hwnd'.
    **
    ** Dlgedit.exe doesn't currently support adding this style at dialog
    ** resource edit time.  When that's fixed set DS_CONTEXTHELP in the dialog
    ** definition and remove this routine.
    */
{
    LONG lStyle;

    if (g_fNoWinHelp)
        return;

    lStyle = GetWindowLong( hwnd, GWL_EXSTYLE );

    if (lStyle)
        SetWindowLong( hwnd, GWL_EXSTYLE, lStyle | WS_EX_CONTEXTHELP );
}


VOID
Button_MakeDefault(
    IN HWND hwndDlg,
    IN HWND hwndPb )

    /* Make 'hwndPb' the default button on dialog 'hwndDlg'.
    */
{
    DWORD dwResult;
    HWND  hwndPbOldDefault;

    dwResult = (DWORD) SendMessage( hwndDlg, DM_GETDEFID, 0, 0 );
    if (HIWORD( dwResult ) == DC_HASDEFID)
    {
        /* Un-default the current default button.
        */
        hwndPbOldDefault = GetDlgItem( hwndDlg, LOWORD( dwResult ) );
        Button_SetStyle( hwndPbOldDefault, BS_PUSHBUTTON, TRUE );
    }

    /* Set caller's button to the default.
    */
    SendMessage( hwndDlg, DM_SETDEFID, GetDlgCtrlID( hwndPb ), 0 );
    Button_SetStyle( hwndPb, BS_DEFPUSHBUTTON, TRUE );
}


HBITMAP
Button_CreateBitmap(
    IN HWND        hwndPb,
    IN BITMAPSTYLE bitmapstyle )

    /* Creates a bitmap of 'bitmapstyle' suitable for display on 'hwndPb.  The
    ** 'hwndPb' must have been created with BS_BITMAP style.
    **
    ** 'HwndPb' may be a checkbox with BS_PUSHLIKE style, in which case the
    ** button locks down when pressed like a toolbar button.  This case
    ** requires that a color bitmap be created resulting in two extra
    ** restrictions.  First, caller must handle WM_SYSCOLORCHANGE and rebuild
    ** the bitmaps with the new colors and second, the button cannot be
    ** disabled.
    **
    ** Returns the handle to the bitmap.  Caller can display it on the button
    ** as follows:
    **
    **     SendMessage( hwndPb, BM_SETIMAGE, 0, (LPARAM )hbitmap );
    **
    ** Caller is responsible for calling DeleteObject(hbitmap) when done using
    ** the bitmap, typically when the dialog is destroyed.
    **
    ** (Adapted from a routine by Tony Romano)
    */
{
    RECT    rect;
    HDC     hdc;
    HDC     hdcMem;
    HBITMAP hbitmap;
    HFONT   hfont;
    HPEN    hpen;
    SIZE    sizeText;
    SIZE    sizeBitmap;
    INT     x;
    INT     y;
    TCHAR*  psz;
    TCHAR*  pszText;
    TCHAR*  pszText2;
    DWORD   dxBitmap;
    DWORD   dxBetween;
    BOOL    fOnRight;
    BOOL    fPushLike;

    hdc = NULL;
    hdcMem = NULL;
    hbitmap = NULL;
    hpen = NULL;
    pszText = NULL;
    pszText2 = NULL;

    switch (bitmapstyle)
    {
        case BMS_UpArrowOnLeft:
        case BMS_DownArrowOnLeft:
        case BMS_UpArrowOnRight:
        case BMS_DownArrowOnRight:
            dxBitmap = 5;
            dxBetween = 4;
            break;

        case BMS_UpTriangleOnLeft:
        case BMS_DownTriangleOnLeft:
        case BMS_UpTriangleOnRight:
        case BMS_DownTriangleOnRight:
            dxBitmap = 7;
            dxBetween = 6;
            break;

        default:
            return NULL;
    }

    fOnRight = (bitmapstyle & BMS_OnRight);
    fPushLike = (GetWindowLong( hwndPb, GWL_STYLE ) & BS_PUSHLIKE);

    /* Get a memory DC compatible with the button window.
    */
    hdc = GetDC( hwndPb );
    if (!hdc)
        return NULL;
    hdcMem = CreateCompatibleDC( hdc );
    if (!hdcMem)
        goto BCB_Error;

    /* Create a compatible bitmap covering the entire button in the memory DC.
    **
    ** For a push button, the bitmap is created compatible with the memory DC,
    ** NOT the display DC.  This causes the bitmap to be monochrome, the
    ** default for memory DCs.  When GDI maps monochrome bitmaps into color,
    ** white is replaced with the background color and black is replaced with
    ** the text color, which is exactly what we want.  With this technique, we
    ** are relieved from explicit handling of changes in system colors.
    **
    ** For a push-like checkbox the bitmap is created compatible with the
    ** button itself, so the bitmap is typically color.
    */
    GetClientRect( hwndPb, &rect );
    hbitmap = CreateCompatibleBitmap(
        (fPushLike) ? hdc : hdcMem, rect.right, rect.bottom );
    if (!hbitmap)
        goto BCB_Error;
    ReleaseDC( hwndPb, hdc );
    hdc = NULL;
    SelectObject( hdcMem, hbitmap );

    /* Select the font the button says it's using.
    */
    hfont = (HFONT )SendMessage( hwndPb, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdcMem, hfont );

    /* Set appropriate colors for regular and stuck-down states.  Don't need
    ** to do anything for the monochrome case as the default black pen and
    ** white background are what we want.
    */
    if (fPushLike)
    {
        INT nColor;

        if (bitmapstyle == BMS_UpArrowOnLeft
           || bitmapstyle == BMS_UpArrowOnRight
           || bitmapstyle == BMS_UpTriangleOnLeft
           || bitmapstyle == BMS_UpTriangleOnRight)
        {
            nColor = COLOR_BTNHILIGHT;
        }
        else
        {
            nColor = COLOR_BTNFACE;
        }

        SetBkColor( hdcMem, GetSysColor( nColor ) );
        hpen = CreatePen( PS_SOLID, 0, GetSysColor( COLOR_BTNTEXT ) );
        if (hpen)
            SelectObject( hdcMem, hpen );
    }

    /* The created bitmap is random, so we erase it to the background color.
    ** No text is written here.
    */
    ExtTextOut( hdcMem, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL );

    /* Get the button label and make a copy with the '&' accelerator-escape
    ** removed, which would otherwise mess up our width calculations.
    */
    pszText = GetText( hwndPb );
    pszText2 = StrDup( pszText );
    if (!pszText || !pszText2)
        goto BCB_Error;

    for (psz = pszText2; *psz; psz = CharNext( psz ) )
    {
        if (*psz == TEXT('&'))
        {
            lstrcpy( psz, psz + 1 );
            break;
        }
    }

    /* Calculate the width of the button label text.
    */
    sizeText.cx = 0;
    sizeText.cy = 0;
    GetTextExtentPoint32( hdcMem, pszText2, lstrlen( pszText2 ), &sizeText );

    /* Draw the text off-center horizontally enough so it is centered with the
    ** bitmap symbol added.
    */
    --rect.bottom;
    sizeBitmap.cx = dxBitmap;
    sizeBitmap.cy = 0;

    rect.left +=
        ((rect.right - (sizeText.cx + sizeBitmap.cx) - dxBetween) / 2);

    if (fOnRight)
    {
        DrawText( hdcMem, pszText, -1, &rect,
            DT_VCENTER + DT_SINGLELINE + DT_EXTERNALLEADING );
        rect.left += sizeText.cx + dxBetween;
    }
    else
    {
        rect.left += dxBitmap + dxBetween;
        DrawText( hdcMem, pszText, -1, &rect,
            DT_VCENTER + DT_SINGLELINE + DT_EXTERNALLEADING );
        rect.left -= dxBitmap + dxBetween;
    }

    /* Eliminate the top and bottom 3 pixels of button from consideration for
    ** the bitmap symbol.  This leaves the button control room to do the
    ** border and 3D edges.
    */
    InflateRect( &rect, 0, -3 );

    /* Draw the bitmap symbol.  The rectangle is now 'dxBitmap' wide and
    ** centered vertically with variable height depending on the button size.
    */
    switch (bitmapstyle)
    {
        case BMS_UpArrowOnLeft:
        case BMS_UpArrowOnRight:
        {
            /* v-left
            ** ..... <-top
            ** .....
            ** .....
            ** ..*.. \
            ** .***.  |
            ** *****  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..   > varies depending on font height
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*.. /
            ** .....
            ** .....
            ** .....
            ** ..... <-bottom
            */

            /* Draw the vertical line.
            */
            x = rect.left + 2;
            y = rect.top + 3;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x, rect.bottom - 3 );

            /* Draw the 2 crossbars.
            */
            MoveToEx( hdcMem, x - 1, ++y, NULL );
            LineTo( hdcMem, x + 2, y );
            MoveToEx( hdcMem, x - 2, ++y, NULL );
            LineTo( hdcMem, x + 3, y );
            break;
        }

        case BMS_DownArrowOnLeft:
        case BMS_DownArrowOnRight:
        {
            /* v-left
            ** ..... <-top
            ** .....
            ** .....
            ** ..*.. \
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..   > varies depending on font height
            ** ..*..  |
            ** ..*..  |
            ** *****  |
            ** .***.  |
            ** ..*.. /
            ** .....
            ** .....
            ** .....
            ** ..... <-bottom
            */

            /* Draw the vertical line.
            */
            x = rect.left + 2;
            y = rect.top + 3;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x, rect.bottom - 3 );

            /* Draw the 2 crossbars.
            */
            y = rect.bottom - 6;
            MoveToEx( hdcMem, x - 2, y, NULL );
            LineTo( hdcMem, x + 3, y );
            MoveToEx( hdcMem, x - 1, ++y, NULL );
            LineTo( hdcMem, x + 2, y );
            break;
        }

        case BMS_UpTriangleOnLeft:
        case BMS_UpTriangleOnRight:
        {
            /* v-left
            ** ....... <-top
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ...o... <- o indicates x,y origin
            ** ..***..
            ** .*****.
            ** *******
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ....... <-bottom
            */
            x = rect.left + 3;
            y = ((rect.bottom - rect.top) / 2) + 2;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x + 1, y );
            ++y;
            MoveToEx( hdcMem, x - 1, y, NULL );
            LineTo( hdcMem, x + 2, y );
            ++y;
            MoveToEx( hdcMem, x - 2, y, NULL );
            LineTo( hdcMem, x + 3, y );
            ++y;
            MoveToEx( hdcMem, x - 3, y, NULL );
            LineTo( hdcMem, x + 4, y );
            break;
        }

        case BMS_DownTriangleOnLeft:
        case BMS_DownTriangleOnRight:
        {
            /* v-left
            ** ....... <-top
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ***o*** <- o indicates x,y origin
            ** .*****.
            ** ..***..
            ** ...*...
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ....... <-bottom
            */
            x = rect.left + 3;
            y = ((rect.bottom - rect.top) / 2) + 2;
            MoveToEx( hdcMem, x - 3, y, NULL );
            LineTo( hdcMem, x + 4, y );
            ++y;
            MoveToEx( hdcMem, x - 2, y, NULL );
            LineTo( hdcMem, x + 3, y );
            ++y;
            MoveToEx( hdcMem, x - 1, y, NULL );
            LineTo( hdcMem, x + 2, y );
            ++y;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x + 1, y );
            break;
        }
    }

BCB_Error:

    Free0( pszText );
    Free0( pszText2 );
    if (hdc)
        ReleaseDC( hwndPb, hdc );
    if (hdcMem)
        DeleteDC( hdcMem );
    if (hpen)
        DeleteObject( hpen );
    return hbitmap;
}


VOID
CenterWindow(
    IN HWND hwnd,
    IN HWND hwndRef )

    /* Center window 'hwnd' on window 'hwndRef' or if 'hwndRef' is NULL on
    ** screen.  The window position is adjusted so that no parts are clipped
    ** by the edge of the screen, if necessary.  If 'hwndRef' has been moved
    ** off-screen with SetOffDesktop, the original position is used.
    */
{
    RECT rectCur;
    LONG dxCur;
    LONG dyCur;
    RECT rectRef;
    LONG dxRef;
    LONG dyRef;

    GetWindowRect( hwnd, &rectCur );
    dxCur = rectCur.right - rectCur.left;
    dyCur = rectCur.bottom - rectCur.top;

    if (hwndRef)
    {
        if (!SetOffDesktop( hwndRef, SOD_GetOrgRect, &rectRef ))
            GetWindowRect( hwndRef, &rectRef );
    }
    else
    {
        rectRef.top = rectRef.left = 0;
        rectRef.right = GetSystemMetrics( SM_CXSCREEN );
        rectRef.bottom = GetSystemMetrics( SM_CYSCREEN );
    }

    dxRef = rectRef.right - rectRef.left;
    dyRef = rectRef.bottom - rectRef.top;

    rectCur.left = rectRef.left + ((dxRef - dxCur) / 2);
    rectCur.top = rectRef.top + ((dyRef - dyCur) / 2);

    SetWindowPos(
        hwnd, NULL,
        rectCur.left, rectCur.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );

    UnclipWindow( hwnd );
}


//Add this function for whislter bug  320863    gangz
//
//Center expand the window horizontally in its parent window
// this expansion will remain the left margin between the child window
// and the parent window
// hwnd: Child Window
// hwndRef: Reference window
// bHoriz: TRUE, means expand horizontally, let the right margin equal the left margin
// bVert: TRUE, elongate the height proportial to the width;
// hwndVertBound: the window that our vertical expandasion cannot overlap with
//
VOID
CenterExpandWindowRemainLeftMargin(
    IN HWND hwnd,
    IN HWND hwndRef,
    BOOL bHoriz,
    BOOL bVert,
    IN HWND hwndVertBottomBound)
{
    RECT rectCur, rectRef, rectVbBound;
    LONG dxCur, dyCur, dxRef;
    POINT ptTemp;
    double ratio;
    BOOL bvbBound = FALSE;

    if (hwnd)
    {
        GetWindowRect( hwnd, &rectCur );

        if (hwndRef)
        {
            GetWindowRect( hwndRef, &rectRef );

          if(hwndVertBottomBound)
          {
            GetWindowRect( hwndVertBottomBound, &rectVbBound );

            //We only consider normal cases, if hwnd and hwndVertBound are already
            //overlapped, that is the problem beyond this function.
            //
            if ( rectCur.top < rectVbBound.top )
            {
                bvbBound = TRUE;
             }
    
          }
          
          dxRef = rectRef.right - rectRef.left +1;
          dxCur = rectCur.right - rectCur.left +1;
          dyCur = rectCur.bottom - rectCur.top +1;
          ratio = dyCur*1.0/dxCur;
          
          if(bHoriz)
          {
               rectCur.right = rectRef.right - (rectCur.left - rectRef.left);
          }

          if(bVert)
          {
               rectCur.bottom = rectCur.top + 
                                (LONG)( (rectCur.right - rectCur.left+1) * ratio );
          }

          if(bvbBound)
          {
                //if overlapping occurs w/o expansion, we need to fix it
                //then we do the vertical centering,
                // this bounding is basically for JPN bugs 329700 329715 which
                // wont happen on English build
                //
                
                if(rectCur.bottom > rectVbBound.top )
                {
                   LONG dxResult, dyResult, dyVRef;

                   dyResult = rectVbBound.top - rectCur.top;
                   dxResult = (LONG)(dyResult/ratio);

                   ptTemp.x = rectVbBound.left;
                   ptTemp.y = rectVbBound.top-1;
                   
                   //For whistler bug 371914        gangz
                   //Cannot use ScreenToClient() here
                   //On RTL build, we must use MapWindowPoint() instead
                   //
                   MapWindowPoints(HWND_DESKTOP,
                                  hwndRef,
                                  &ptTemp,
                                  1);

                   dyVRef = ptTemp.y + 1;
                  
                   rectCur.left = rectRef.left + (dxRef - dxResult)/2;
                   rectCur.right = rectRef.right - (dxRef-dxResult)/2;
                   rectCur.bottom = rectVbBound.top - (dyVRef-dyResult)/2;
                   rectCur.top = rectCur.bottom - dyResult;
               }
           }

            ptTemp.x = rectCur.left;
            ptTemp.y = rectCur.top;
            MapWindowPoints(HWND_DESKTOP,
                           hwndRef,
                           &ptTemp,
                           1);
           
            rectCur.left = ptTemp.x;
            rectCur.top  = ptTemp.y;

            ptTemp.x = rectCur.right;
            ptTemp.y = rectCur.bottom;
            MapWindowPoints(HWND_DESKTOP,
                           hwndRef,
                           &ptTemp,
                           1);

            rectCur.right  = ptTemp.x;
            rectCur.bottom = ptTemp.y;

            //For mirrored build
            //
            if ( rectCur.right < rectCur.left )
            {
                int tmp;

                tmp = rectCur.right;
                rectCur.right = rectCur.left;
                rectCur.left = tmp;
            }
            
            SetWindowPos(
                    hwnd, 
                    NULL,
                    rectCur.left,
                    rectCur.top, 
                    rectCur.right - rectCur.left + 1,
                    rectCur.bottom - rectCur.top +1,
                    SWP_NOZORDER);
        }
    }

}


VOID
CancelOwnedWindows(
    IN HWND hwnd )

    /* Sends WM_COMMAND(IDCANCEL) to all windows that are owned by 'hwnd' in
    ** the current thread.
    */
{
    EnumThreadWindows( GetCurrentThreadId(),
        CloseOwnedWindowsEnumProc, (LPARAM )hwnd );
}


BOOL CALLBACK
CancelOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam )

    /* Standard Win32 EnumThreadWindowsWndProc used by CancelOwnedWindows.
    */
{
    HWND hwndThis;

    for (hwndThis = GetParent( hwnd );
         hwndThis;
         hwndThis = GetParent( hwndThis ))
    {
        if (hwndThis == (HWND )lparam)
        {
            FORWARD_WM_COMMAND(
                hwnd, IDCANCEL, NULL, 0, SendMessage );
            break;
        }
    }

    return TRUE;
}


VOID
CloseOwnedWindows(
    IN HWND hwnd )

    /* Sends WM_CLOSE to all windows that are owned by 'hwnd' in the current
    ** thread.
    */
{
    EnumThreadWindows( GetCurrentThreadId(),
        CloseOwnedWindowsEnumProc, (LPARAM )hwnd );
}


BOOL CALLBACK
CloseOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam )

    /* Standard Win32 EnumThreadWindowsWndProc used by CloseOwnedWindows.
    */
{
    HWND hwndThis;

    for (hwndThis = GetParent( hwnd );
         hwndThis;
         hwndThis = GetParent( hwndThis ))
    {
        if (hwndThis == (HWND )lparam)
        {
            SendMessage( hwnd, WM_CLOSE, 0, 0 );
            break;
        }
    }

    return TRUE;
}


INT
ComboBox_AddItem(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem )

    /* Adds data item 'pItem' with displayed text 'pszText' to listbox
    ** 'hwndLb'.  The item is added sorted if the listbox has LBS_SORT style,
    ** or to the end of the list otherwise.  If the listbox has LB_HASSTRINGS
    ** style, 'pItem' is a null terminated string, otherwise it is any user
    ** defined data.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT nIndex;

    nIndex = ComboBox_AddString( hwndLb, pszText );
    if (nIndex >= 0)
        ComboBox_SetItemData( hwndLb, nIndex, pItem );
    return nIndex;
}


INT
ComboBox_AddItemFromId(
    IN HINSTANCE hinstance,
    IN HWND      hwndLb,
    IN DWORD     dwStringId,
    IN VOID*     pItem )

    /* Adds data item 'pItem' to listbox 'hwndLb'.  'dwStringId' is the string
    ** ID of the item's displayed text.  'Hinstance' is the app or module
    ** instance handle.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT     i;
    LPCTSTR psz;

    psz = PszLoadString( hinstance, dwStringId );

    if (psz)
    {
        i = ComboBox_AddItem( hwndLb, psz, pItem );
    }
    else
    {
        i = LB_ERRSPACE;
    }

    return i;
}


INT
ComboBox_AddItemSorted(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem )

    /* Adds data item 'pItem' with displayed text 'pszText' to listbox
    ** 'hwndLb' in order sorted by 'pszText'.  It is assumed all items added
    ** to the list to this point are sorted.  If the listbox has LB_HASSTRINGS
    ** style, 'pItem' is a null terminated string, otherwise it is any user
    ** defined data.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT nIndex;
    INT i;
    INT c;

    c = ComboBox_GetCount( hwndLb );
    for (i = 0; i < c; ++i)
    {
        TCHAR* psz;

        psz = ComboBox_GetPsz( hwndLb, i );
        if (psz)
        {
            if (lstrcmp( pszText, psz ) < 0)
                break;
            Free( psz );
        }
    }

    if (i >= c)
        i = -1;

    nIndex = ComboBox_InsertString( hwndLb, i, pszText );
    if (nIndex >= 0)
        ComboBox_SetItemData( hwndLb, nIndex, pItem );

    return nIndex;
}


VOID
ComboBox_AutoSizeDroppedWidth(
    IN HWND hwndLb )

    /* Set the width of the drop-down list 'hwndLb' to the width of the
    ** longest item (or the width of the list box if that's wider).
    */
{
    HDC    hdc;
    HFONT  hfont;
    TCHAR* psz;
    SIZE   size;
    DWORD  cch;
    DWORD  dxNew;
    DWORD  i;

    hfont = (HFONT )SendMessage( hwndLb, WM_GETFONT, 0, 0 );
    if (!hfont)
        return;

    hdc = GetDC( hwndLb );
    if (!hdc)
        return;

    SelectObject( hdc, hfont );

    dxNew = 0;
    for (i = 0; psz = ComboBox_GetPsz( hwndLb, i ); ++i)
    {
        cch = lstrlen( psz );
        if (GetTextExtentPoint32( hdc, psz, cch, &size ))
        {
            if (dxNew < (DWORD )size.cx)
                dxNew = (DWORD )size.cx;
        }

        Free( psz );
    }

    ReleaseDC( hwndLb, hdc );

    /* Allow for the spacing on left and right added by the control.
    */
    dxNew += 6;

    /* Figure out if the vertical scrollbar will be displayed and, if so,
    ** allow for it's width.
    */
    {
        RECT  rectD;
        RECT  rectU;
        DWORD dyItem;
        DWORD cItemsInDrop;
        DWORD cItemsInList;

        GetWindowRect( hwndLb, &rectU );
        SendMessage( hwndLb, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM )&rectD );
        dyItem = (DWORD)SendMessage( hwndLb, CB_GETITEMHEIGHT, 0, 0 );
        cItemsInDrop = (rectD.bottom - rectU.bottom) / dyItem;
        cItemsInList = ComboBox_GetCount( hwndLb );
        if (cItemsInDrop < cItemsInList)
            dxNew += GetSystemMetrics( SM_CXVSCROLL );
    }

    SendMessage( hwndLb, CB_SETDROPPEDWIDTH, dxNew, 0 );
}


#if 0
VOID
ComboBox_FillFromPszList(
    IN HWND     hwndLb,
    IN DTLLIST* pdtllistPsz )

    /* Loads 'hwndLb' with an item form each node in the list strings,
    ** 'pdtllistPsz'.
    */
{
    DTLNODE* pNode;

    if (!pdtllistPsz)
        return;

    for (pNode = DtlGetFirstNode( pdtllistPsz );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz;

        psz = (TCHAR* )DtlGetData( pNode );
        ASSERT(psz);
        ComboBox_AddString( hwndLb, psz );
    }
}
#endif


VOID*
ComboBox_GetItemDataPtr(
    IN HWND hwndLb,
    IN INT  nIndex )

    /* Returns the address of the 'nIndex'th item context in 'hwndLb' or NULL
    ** if none.
    */
{
    LRESULT lResult;

    if (nIndex < 0)
        return NULL;

    lResult = ComboBox_GetItemData( hwndLb, nIndex );
    if (lResult < 0)
        return NULL;

    return (VOID* )lResult;
}


TCHAR*
ComboBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex )

    /* Returns heap block containing the text contents of the 'nIndex'th item
    ** of combo box 'hwnd' or NULL.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = ComboBox_GetLBTextLen( hwnd, nIndex );
    if (cch < 0)
        return NULL;

    psz = Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        ComboBox_GetLBText( hwnd, nIndex, psz );
    }

    return psz;
}


VOID
ComboBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex )

    /* Set selection in listbox 'hwndLb' to 'nIndex' and notify parent as if
    ** user had clicked the item which Windows doesn't do for some reason.
    */
{
    ComboBox_SetCurSel( hwndLb, nIndex );

    SendMessage(
        GetParent( hwndLb ),
        WM_COMMAND,
        (WPARAM )MAKELONG(
            (WORD )GetDlgCtrlID( hwndLb ), (WORD )CBN_SELCHANGE ),
        (LPARAM )hwndLb );
}


TCHAR*
Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL )

    /* Returns a heap string containing the 'psz' shortened to fit in the
    ** given width, if necessary, by truncating and adding "...". 'Hdc' is the
    ** device context with the appropiate font selected.  'DxColumn' is the
    ** width of the column.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    const TCHAR szDots[] = TEXT("...");

    SIZE   size;
    TCHAR* pszResult;
    TCHAR* pszResultLast;
    TCHAR* pszResult2nd;
    DWORD  cch;

    cch = lstrlen( psz );
    pszResult = Malloc( (cch * sizeof(TCHAR)) + sizeof(szDots) );
    if (!pszResult)
        return NULL;
    lstrcpy( pszResult, psz );

    dxColumn -= dxColText;
    if (dxColumn <= 0)
    {
        /* None of the column text will be visible so bag the calculations and
        ** just return the original string.
        */
        return pszResult;
    }

    if (!GetTextExtentPoint32( hdc, pszResult, cch, &size ))
    {
        Free( pszResult );
        return NULL;
    }

    pszResult2nd = CharNext( pszResult );
    pszResultLast = pszResult + cch;

    while (size.cx > dxColumn && pszResultLast > pszResult2nd)
    {
        /* Doesn't fit.  Lop off a character, add the ellipsis, and try again.
        ** The minimum result is "..." for empty original or "x..." for
        ** non-empty original.
        */
        pszResultLast = CharPrev( pszResult2nd, pszResultLast );
        lstrcpy( pszResultLast, szDots );

        if (!GetTextExtentPoint( hdc, pszResult, lstrlen( pszResult ), &size ))
        {
            Free( pszResult );
            return NULL;
        }
    }

    return pszResult;
}


VOID
ExpandWindow(
    IN HWND hwnd,
    IN LONG dx,
    IN LONG dy )

    /* Expands window 'hwnd' 'dx' pels to the right and 'dy' pels down from
    ** it's current size.
    */
{
    RECT rect;

    GetWindowRect( hwnd, &rect );

    SetWindowPos( hwnd, NULL,
        0, 0, rect.right - rect.left + dx, rect.bottom - rect.top + dy,
        SWP_NOMOVE + SWP_NOZORDER );
}


TCHAR*
GetText(
    IN HWND hwnd )

    /* Returns heap block containing the text contents of the window 'hwnd' or
    ** NULL.  It is caller's responsibility to Free the returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = GetWindowTextLength( hwnd );
    psz = Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        GetWindowText( hwnd, psz, cch + 1 );
    }

    return psz;
}


HWND
HwndFromCursorPos(
    IN  HINSTANCE   hinstance,
    IN  POINT*      ppt OPTIONAL )

    /* Returns a "Static" control window created at the specified position
    ** (or at the cursor position if NULL is passed in).
    ** The window is moved off the desktop using SetOffDesktop()
    ** so that it can be specified as the owner window
    ** for a popup dialog shown using MsgDlgUtil.
    ** The window returned should be destroyed using DestroyWindow().
    */
{

    HWND hwnd;
    POINT pt;

    if (ppt) { pt = *ppt; }
    else { GetCursorPos(&pt); }

    //
    // create the window
    //

    hwnd = CreateWindowEx(
                WS_EX_TOOLWINDOW, TEXT("Static"), NULL, WS_POPUP, pt.x, pt.y,
                1, 1, NULL, NULL, hinstance, NULL
                );
    if (!hwnd) { return NULL; }

    //
    // move it off the desktop
    //

    SetOffDesktop(hwnd, SOD_MoveOff, NULL);

    ShowWindow(hwnd, SW_SHOW);

    return hwnd;
}

LPTSTR
IpGetAddressAsText(
    HWND    hwndIp )
{
    if (SendMessage( hwndIp, IPM_ISBLANK, 0, 0 ))
    {
        return NULL;
    }
    else
    {
        DWORD dwIpAddrHost;
        TCHAR szIpAddr [32];

        SendMessage( hwndIp, IPM_GETADDRESS, 0, (LPARAM)&dwIpAddrHost );
        IpHostAddrToPsz( dwIpAddrHost, szIpAddr );
        return StrDup( szIpAddr );
    }
}


void
IpSetAddressText(
    HWND    hwndIp,
    LPCTSTR pszIpAddress )
{
    if (pszIpAddress)
    {
        DWORD dwIpAddrHost = IpPszToHostAddr( pszIpAddress );
        SendMessage( hwndIp, IPM_SETADDRESS, 0, dwIpAddrHost );
    }
    else
    {
        SendMessage( hwndIp, IPM_CLEARADDRESS, 0, 0 );
    }
}


INT
ListBox_AddItem(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem )

    /* Adds data item 'pItem' with displayed text 'pszText' to listbox
    ** 'hwndLb'.  The item is added sorted if the listbox has LBS_SORT style,
    ** or to the end of the list otherwise.  If the listbox has LB_HASSTRINGS
    ** style, 'pItem' is a null terminated string, otherwise it is any user
    ** defined data.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT nIndex;

    nIndex = ListBox_AddString( hwndLb, pszText );
    if (nIndex >= 0)
        ListBox_SetItemData( hwndLb, nIndex, pItem );
    return nIndex;
}


TCHAR*
ListBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex )

    /* Returns heap block containing the text contents of the 'nIndex'th item
    ** of list box 'hwnd' or NULL.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = ListBox_GetTextLen( hwnd, nIndex );
    psz = Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        ListBox_GetText( hwnd, nIndex, psz );
    }

    return psz;
}


INT
ListBox_IndexFromString(
    IN HWND   hwnd,
    IN TCHAR* psz )

    /* Returns the index of the item in string list 'hwnd' that matches 'psz'
    ** or -1 if not found.  Unlike, ListBox_FindStringExact, this compare in
    ** case sensitive.
    */
{
    INT i;
    INT c;

    c = ListBox_GetCount( hwnd );

    for (i = 0; i < c; ++i)
    {
        TCHAR* pszThis;

        pszThis = ListBox_GetPsz( hwnd, i );
        if (pszThis)
        {
            BOOL f;

            f = (lstrcmp( psz, pszThis ) == 0);
            Free( pszThis );
            if (f)
                return i;
        }
    }

    return -1;
}


VOID
ListBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex )

    /* Set selection in listbox 'hwndLb' to 'nIndex' and notify parent as if
    ** user had clicked the item which Windows doesn't do for some reason.
    */
{
    ListBox_SetCurSel( hwndLb, nIndex );

    SendMessage(
        GetParent( hwndLb ),
        WM_COMMAND,
        (WPARAM )MAKELONG(
            (WORD )GetDlgCtrlID( hwndLb ), (WORD )LBN_SELCHANGE ),
        (LPARAM )hwndLb );
}


VOID*
ListView_GetParamPtr(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns the lParam address of the 'iItem' item in 'hwndLv' or NULL if
    ** none or error.
    */
{
    LV_ITEM item;

    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_PARAM;
    item.iItem = iItem;

    if (!ListView_GetItem( hwndLv, &item ))
        return NULL;

    return (VOID* )item.lParam;
}


VOID*
ListView_GetSelectedParamPtr(
    IN HWND hwndLv )

    /* Returns the lParam address of the first selected item in 'hwndLv' or
    ** NULL if none or error.
    */
{
    INT     iSel;
    LV_ITEM item;

    iSel = ListView_GetNextItem( hwndLv, -1, LVNI_SELECTED );
    if (iSel < 0)
        return NULL;

    return ListView_GetParamPtr( hwndLv, iSel );
}


VOID
ListView_InsertSingleAutoWidthColumn(
    HWND hwndLv )

    // Insert a single auto-sized column into listview 'hwndLv', e.g. for a
    // list of checkboxes with no visible column header.
    //
{
    LV_COLUMN col;

    ZeroMemory( &col, sizeof(col) );
    col.mask = LVCF_FMT;
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndLv, 0, &col );
    ListView_SetColumnWidth( hwndLv, 0, LVSCW_AUTOSIZE );
}


BOOL
ListView_SetParamPtr(
    IN HWND  hwndLv,
    IN INT   iItem,
    IN VOID* pParam )

    /* Set the lParam address of the 'iItem' item in 'hwndLv' to 'pParam'.
    ** Return true if successful, false otherwise.
    */
{
    LV_ITEM item;

    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_PARAM;
    item.iItem = iItem;
    item.lParam = (LPARAM )pParam;

    return ListView_SetItem( hwndLv, &item );
}


VOID
Menu_CreateAccelProxies(
    IN HINSTANCE hinst,
    IN HWND      hwndParent,
    IN DWORD     dwMid )

    /* Causes accelerators on a popup menu to choose menu commands when the
    ** popup menu is not dropped down.  'Hinst' is the app/dll instance.
    ** 'HwndParent' is the window that receives the popup menu command
    ** messages.  'DwMid' is the menu ID of the menu bar containing the popup
    ** menu.
    */
{
    #define MCF_cbBuf 512

    HMENU        hmenuBar;
    HMENU        hmenuPopup;
    TCHAR        szBuf[ MCF_cbBuf ];
    MENUITEMINFO item;
    INT          i;

    hmenuBar = LoadMenu( hinst, MAKEINTRESOURCE( dwMid ) );
    ASSERT(hmenuBar);
    hmenuPopup = GetSubMenu( hmenuBar, 0 );
    ASSERT(hmenuPopup);

    /* Loop thru menu items on the popup menu.
    */
    for (i = 0; TRUE; ++i)
    {
        ZeroMemory( &item, sizeof(item) );
        item.cbSize = sizeof(item);
        item.fMask = MIIM_TYPE + MIIM_ID;
        item.dwTypeData = szBuf;
        item.cch = MCF_cbBuf;

        if (!GetMenuItemInfo( hmenuPopup, i, TRUE, &item ))
            break;

        if (item.fType != MFT_STRING)
            continue;

        /* Create an off-screen button on the parent with the same ID and
        ** text as the menu item.
        */
        CreateWindow( TEXT("button"), szBuf, WS_CHILD,
            30000, 30000, 0, 0, hwndParent, (HMENU )UlongToPtr(item.wID), hinst, NULL );
    }

    DestroyMenu( hmenuBar );
}


VOID
ScreenToClientRect(
    IN     HWND  hwnd,
    IN OUT RECT* pRect )

    /* Converts '*pRect' from screen to client coordinates of 'hwnd'.
    */
{
    POINT xyUL;
    POINT xyBR;

    xyUL.x = pRect->left;
    xyUL.y = pRect->top;
    xyBR.x = pRect->right;
    xyBR.y = pRect->bottom;

    ScreenToClient( hwnd, &xyUL );
    ScreenToClient( hwnd, &xyBR );

    pRect->left = xyUL.x;
    pRect->top = xyUL.y;
    pRect->right = xyBR.x;
    pRect->bottom = xyBR.y;
}


BOOL
SetOffDesktop(
    IN  HWND  hwnd,
    IN  DWORD dwAction,
    OUT RECT* prectOrg )

    /* Move 'hwnd' back and forth from the visible desktop to the area
    ** off-screen.  Use this when you want to "hide" your owner window without
    ** hiding yourself which Windows automatically does.
    **
    ** 'dwAction' describes the action to take:
    **     SOD_Moveoff:        Move 'hwnd' off the desktop.
    **     SOD_MoveBackFree:   Undo SOD_MoveOff.
    **     SOD_GetOrgRect:     Retrieves original 'hwnd' position.
    **     SOD_Free:           Free SOD_MoveOff context without restoring.
    **     SOD_MoveBackHidden: Move window back, but hidden so you can call
    **                             routines that internally query the position
    **                             of the window.  Undo with SOD_Moveoff.
    **
    ** '*prectOrg' is set to the original window position when 'dwAction' is
    ** SOD_GetOrgRect.  Otherwise, it is ignored, and may be NULL.
    **
    ** Returns true if the window has a SODINFO context, false otherwise.
    */
{
    SODINFO* pInfo;

    TRACE2("SetOffDesktop(h=$%08x,a=%d)",hwnd,dwAction);

    if (!g_SodContextId)
    {
        g_SodContextId = (LPCTSTR )GlobalAddAtom( TEXT("RASSETOFFDESKTOP") );
        if (!g_SodContextId)
            return FALSE;
    }

    pInfo = (SODINFO* )GetProp( hwnd, g_SodContextId );

    if (dwAction == SOD_MoveOff)
    {
        if (pInfo)
        {
            /* Caller is undoing a SOD_MoveBackHidden.
            */
            SetWindowPos( hwnd, NULL,
                pInfo->rectOrg.left, GetSystemMetrics( SM_CYSCREEN ),
                0, 0, SWP_NOSIZE + SWP_NOZORDER );

            if (pInfo->fWeMadeInvisible)
            {
                ShowWindow( hwnd, SW_SHOW );
                pInfo->fWeMadeInvisible = FALSE;
            }
        }
        else
        {
            BOOL f;

            pInfo = (SODINFO* )Malloc( sizeof(SODINFO) );
            if (!pInfo)
                return FALSE;

            f = IsWindowVisible( hwnd );
            if (!f)
                ShowWindow( hwnd, SW_HIDE );

            GetWindowRect( hwnd, &pInfo->rectOrg );
            SetWindowPos( hwnd, NULL, pInfo->rectOrg.left,
                GetSystemMetrics( SM_CYSCREEN ),
                0, 0, SWP_NOSIZE + SWP_NOZORDER );

            if (!f)
                ShowWindow( hwnd, SW_SHOW );

            pInfo->fWeMadeInvisible = FALSE;
            SetProp( hwnd, g_SodContextId, pInfo );
        }
    }
    else if (dwAction == SOD_MoveBackFree || dwAction == SOD_Free)
    {
        if (pInfo)
        {
            if (dwAction == SOD_MoveBackFree)
            {
                SetWindowPos( hwnd, NULL,
                    pInfo->rectOrg.left, pInfo->rectOrg.top, 0, 0,
                    SWP_NOSIZE + SWP_NOZORDER );
            }

            Free( pInfo );
            RemoveProp( hwnd, g_SodContextId );
        }

        return FALSE;
    }
    else if (dwAction == SOD_GetOrgRect)
    {
        if (!pInfo)
            return FALSE;

        *prectOrg = pInfo->rectOrg;
    }
    else
    {
        ASSERT(dwAction==SOD_MoveBackHidden);

        if (!pInfo)
            return FALSE;

        if (IsWindowVisible( hwnd ))
        {
            ShowWindow( hwnd, SW_HIDE );
            pInfo->fWeMadeInvisible = TRUE;
        }

        SetWindowPos( hwnd, NULL,
            pInfo->rectOrg.left, pInfo->rectOrg.top, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER );
    }

    return TRUE;
}


BOOL
SetDlgItemNum(
    IN HWND hwndDlg,
    IN INT iDlgItem,
    IN UINT uValue )

    /* Similar to SetDlgItemInt, but this function uses commas (or the
    ** locale-specific separator) to delimit thousands
    */
{

    DWORD dwSize;
    TCHAR szNumber[32];

    dwSize  = 30;
    GetNumberString(uValue, szNumber, &dwSize);

    return SetDlgItemText(hwndDlg, iDlgItem, szNumber);
}


BOOL
SetEvenTabWidths(
    IN HWND  hwndDlg,
    IN DWORD cPages )

    /* Set the tabs on property sheet 'hwndDlg' to have even fixed width.
    ** 'cPages' is the number of pages on the property sheet.
    **
    ** Returns true if successful, false if any of the tabs requires more than
    ** the fixed width in which case the call has no effect.
    */
{
    HWND hwndTab;
    LONG lStyle;
    RECT rect;
    INT  dxFixed;

    /* The tab control uses hard-coded 1-inch tabs when you set FIXEDWIDTH
    ** style while we want the tabs to fill the page, so we figure out the
    ** correct width ourselves.  For some reason, without a fudge-factor (the
    ** -10) the expansion does not fit on a single line.  The factor
    ** absolutely required varies between large and small fonts and the number
    ** of tabs does not seem to be a factor.
    */
    hwndTab = PropSheet_GetTabControl( hwndDlg );
    GetWindowRect( hwndTab, &rect );
    dxFixed = (rect.right - rect.left - 10 ) / cPages;

    while (cPages > 0)
    {
        RECT rectTab;

        --cPages;
        if (!TabCtrl_GetItemRect( hwndTab, cPages, &rectTab )
            || dxFixed < rectTab.right - rectTab.left)
        {
            /* This tab requires more than the fixed width.  Since the fixed
            ** width is unworkable do nothing.
            */
            return FALSE;
        }
    }

    TabCtrl_SetItemSize( hwndTab, dxFixed, 0 );
    lStyle = GetWindowLong( hwndTab, GWL_STYLE );
    SetWindowLong( hwndTab, GWL_STYLE, lStyle | TCS_FIXEDWIDTH );
    return TRUE;
}


HFONT
SetFont(
    HWND   hwndCtrl,
    TCHAR* pszFaceName,
    BYTE   bfPitchAndFamily,
    INT    nPointSize,
    BOOL   fUnderline,
    BOOL   fStrikeout,
    BOOL   fItalic,
    BOOL   fBold )

    /* Sets font of control 'hwndCtrl' to a font matching the specified
    ** attributes.  See LOGFONT documentation.
    **
    ** Returns the HFONT of the created font if successful or NULL.  Caller
    ** should DeleteObject the returned HFONT when the control is destroyed.
    */
{
    LOGFONT logfont;
    INT     nPelsPerInch;
    HFONT   hfont;

    {
        HDC hdc = GetDC( NULL );
        if (hdc == NULL)
        {
            return NULL;
        }
       
        nPelsPerInch = GetDeviceCaps( hdc, LOGPIXELSY );
        ReleaseDC( NULL, hdc );
    }

    ZeroMemory( &logfont, sizeof(logfont) );
    logfont.lfHeight = -MulDiv( nPointSize, nPelsPerInch, 72 );

    {
        DWORD       cp;
        CHARSETINFO csi;

        cp = GetACP();
        if (TranslateCharsetInfo( &cp, &csi, TCI_SRCCODEPAGE ))
            logfont.lfCharSet = (UCHAR)csi.ciCharset;
        else
            logfont.lfCharSet = ANSI_CHARSET;
    }

    logfont.lfOutPrecision = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily = bfPitchAndFamily;
    lstrcpy( logfont.lfFaceName, pszFaceName );
    logfont.lfUnderline = (BYTE)fUnderline;
    logfont.lfStrikeOut = (BYTE)fStrikeout;
    logfont.lfItalic = (BYTE)fItalic;
    logfont.lfWeight = (fBold) ? FW_BOLD : FW_NORMAL;

    hfont = CreateFontIndirect( &logfont );
    if (hfont)
    {
        SendMessage( hwndCtrl,
            WM_SETFONT, (WPARAM )hfont, MAKELPARAM( TRUE, 0 ) );
    }

    return hfont;
}



VOID
SlideWindow(
    IN HWND hwnd,
    IN HWND hwndParent,
    IN LONG dx,
    IN LONG dy )

    /* Moves window 'hwnd' 'dx' pels right and 'dy' pels down from it's
    ** current position.  'HwndParent' is the handle of 'hwnd's parent or NULL
    ** if 'hwnd' is not a child window.
    */
{
    RECT  rect;
    POINT xy;

    GetWindowRect( hwnd, &rect );
    xy.x = rect.left;
    xy.y = rect.top;

    if (GetParent( hwnd ))
    {
        /*
         * For mirrored parents we us the right point not the left.
         */
        if (GetWindowLongPtr(GetParent( hwnd ), GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
            xy.x = rect.right;
        }
        ScreenToClient( hwndParent, &xy );
    }

    SetWindowPos( hwnd, NULL,
        xy.x + dx, xy.y + dy, 0, 0,
        SWP_NOSIZE + SWP_NOZORDER );
}


VOID
UnclipWindow(
    IN HWND hwnd )

    /* Moves window 'hwnd' so any clipped parts are again visible on the
    ** screen.  The window is moved only as far as necessary to achieve this.
    */
{
    RECT rect;
    INT  dxScreen = GetSystemMetrics( SM_CXSCREEN );
    INT  dyScreen = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect( hwnd, &rect );

    if (rect.right > dxScreen)
        rect.left = dxScreen - (rect.right - rect.left);

    if (rect.left < 0)
        rect.left = 0;

    if (rect.bottom > dyScreen)
        rect.top = dyScreen - (rect.bottom - rect.top);

    if (rect.top < 0)
        rect.top = 0;

    SetWindowPos(
        hwnd, NULL,
        rect.left, rect.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\pbk\file.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// file.c
// Remote Access phonebook library
// File access routines
// Listed alphabetically
//
// 09/21/95 Steve Cobb
//
// About .PBK files:
// -----------------
//
// A phonebook file is an MB ANSI file containing 0-n []ed sections, each
// containing information for a single phonebook entry.  The single entry may
// contain multiple link information.  Refer to file 'notes.txt' for a
// description of how this format differs from the NT 3.51 format.
//
//    [ENTRY]
//    Encoding=<encoding>             ; New
//    Type=<RASET-code>               ; New
//    Description=<text>              ; Used for upgrade only
//    AutoLogon=<1/0>
//    DialParamsUID=<unique-ID>
//    Guid=<16-byte-binary>           ; Absence indicates pre-NT5 entry
//    BaseProtocol=<BP-code>
//    VpnStrategy=<VS-code>
//    Authentication=<AS-code>
//    ExcludedProtocols=<NP-bits>
//    LcpExtensions=<1/0>
//    DataEncryption=<DE-code>
//    SkipNwcWarning=<1/0>
//    SkipDownLevelDialog=<1/0>
//    SkipDoubleDialDialog=<1/0>
//    SwCompression=<1/0>
//    UseCountryAndAreaCodes=<1/0>    ; Used for upgrade only
//    AreaCode=<string>               ; Used for upgrade only
//    CountryID=<id>                  ; Used for upgrade only
//    CountryCode=<code>              ; Used for upgrade only
//    ShowMonitorIconInTaskBar
//    CustomAuthKey=<EAP-IANA-code>
//    CustomAuthData=<hexdump>
//    CustomAuthIdentity=<name>
//    AuthRestrictions=<AR-code>
//    TypicalAuth=<TA-code>
//    ShowMonitorIconInTaskBar=<1/0>
//    OverridePref=<RASOR-bits>
//    DialMode=<DM-code>
//    DialPercent=<0-100>
//    DialSeconds=<1-n>
//    HangUpPercent=<0-100>
//    HangUpSeconds=<1-n>
//    RedialAttempts=<n>
//    RedialSeconds=<n>
//    IdleDisconnectSeconds=<-1,0,1-n>
//    RedialOnLinkFailure=<1/0>
//    CallbackMode=<CBM-code>
//    CustomDialDll=<path>
//    CustomDialFunc=<func-name>
//    AuthenticateServer=<1/0>
//    ShareMsFilePrint=<1/0>
//    BindMsNetClient=<1/0>
//    SharedPhoneNumbers=<1/0>
//    PrerequisiteEntry=<entry-name>
//    PrerequisitePbk=<PBK-path>
//    PreferredPort=<port name>
//    PreferredDevice=<device name>
//    PreviewUserPw=<1/0>
//    PreviewDomain=<1/0>
//    PreviewPhoneNumber=<1/0>
//    ShowDialingProgress=<1/0>
//    CustomScript=<1/0>
//
// The following single set of IP parameters appear in place of the equivalent
// separate sets of PppXxx or SlipXxx parameters in the previous phonebook.
//
//    IpPrioritizeRemote=<1/0>
//    IpHeaderCompression=<1/0>
//    IpAddress=<a.b.c.d>
//    IpDnsAddress=<a.b.c.d>
//    IpDns2Address=<a.b.c.d>
//    IpWinsAddress=<a.b.c.d>
//    IpWins2Address=<a.b.c.d>
//    IpAssign=<ASRC-code>
//    IpNameAssign=<ASRC-code>
//    IpFrameSize=<1006/1500>
//    IpDnsFlags=<DNS_ bits>
//    IpDnsSuffix=<dns suffix>
//
// Each entry contains a NETCOMPONENT subsection containing a freeform list of
// keys and values representing installed net component parameters.
//
//    NETCOMPONENTS=
//    <key1>=<value1>
//    <key2>=<value2>
//    <keyn>=<valuen>
//
// In general each section contains subsections delimited by MEDIA=<something>
// and DEVICE=<something> lines.  In NT 3.51 there had to be exactly one MEDIA
// subsection and it had to be the first subsection of the section.  There
// could be any number of DEVICE subsections.  Now, there can be multiple
// MEDIA/DEVICE sets where the position of the set determines it's sub-entry
// index, the first being 1, the second 2, etc.
//
// For serial media, the program currently expects 1 to 4 DEVICE subsections,
// representing a preconnect switch, modem, X.25 PAD, and postconnect switch
// (often a script).  Following is a full serial link:
//
//    MEDIA=serial
//    Port=<port-name>
//    Device=<device-name>            ; Absence indicates a 3.51- phonebook
//    ConnectBps=<bps>
//
//    DEVICE=switch
//    Type=<switchname or Terminal>   ; Used for upgrade only
//    Name=<switchname>
//    Terminal=<1/0>
//
//    DEVICE=modem
//    PhoneNumber=<phonenumber1>
//    AreaCode=<area-code1>
//    CountryID=<id>
//    CountryCode=<country-code>
//    UseDialingRules=<1/0>
//    Comment=<arbitrary-text1>
//    PhoneNumber=<phonenumber2>
//    AreaCode=<area-code1>
//    CountryID=<id>
//    CountryCode=<country-code>
//    UseDialingRules=<1/0>
//    Comment=<arbitrary-text2>
//    PhoneNumber=<phonenumberN>
//    AreaCode=<area-code1>
//    CountryID=<id>
//    CountryCode=<country-code>
//    UseDialingRules=<1/0>
//    Comment=<arbitrary-textn>
//    LastSelectedPhone=<index>
//    PromoteAlternates=<1/0>
//    TryNextAlternateOnFail=<1/0>
//    TapiBlob=<hexdump>
//    HwFlowControl=<1/0>
//    Protocol=<1/0>
//    Compression=<1/0>
//    Speaker=<0/1>
//
//    DEVICE=pad
//    X25Pad=<padtype>
//    X25Address=<X121address>
//    UserData=<userdata>
//    Facilities=<facilities>
//
//    DEVICE=switch
//    Type=<switchname or Terminal>   ; Used for upgrade only
//    Name=<switchname>
//    Terminal=<1/0>
//
// In the above, when a "pad" device appears without a modem (local PAD card),
// the X25Pad field is written but is empty, because this is what the old
// library/UI appears to do (though it does not look to be what was intended).
//
// For ISDN media, the program expects exactly 1 DEVICE subsection.
//
//    MEDIA=isdn
//    Port=<port>
//    Device=<device-name>
//
//    DEVICE=isdn
//    PhoneNumber=<phonenumber1>
//    AreaCode=<area-code1>
//    CountryID=<id>
//    CountryCode=<country-code>
//    UseDialingRules=<1/0>
//    Comment=<arbitrary-text1>
//    PhoneNumber=<phonenumber2>
//    AreaCode=<area-code1>
//    CountryID=<id>
//    CountryCode=<country-code>
//    UseDialingRules=<1/0>
//    Comment=<arbitrary-text2>
//    PhoneNumber=<phonenumberN>
//    AreaCode=<area-code1>
//    CountryID=<id>
//    CountryCode=<country-code>
//    UseDialingRules=<1/0>
//    Comment=<arbitrary-textn>
//    LastSelectedPhone=<index>
//    PromoteAlternates=<1/0>
//    TryNextAlternateOnFail=<1/0>
//    LineType=<0/1/2>
//    Fallback=<1/0>
//    EnableCompression=<1/0>         ; Old proprietary protocol only
//    ChannelAggregation=<channels>   ; Old proprietary protocol only
//    Proprietary=<1/0>               ; Exists only in new, not found is 1.
//
//
// For X.25 media, the program expects exactly 1 DEVICE subsection.
//
//    MEDIA=x25
//    Port=<port-name>
//    Device=<device-name>
//
//    DEVICE=x25
//    X25Address=<X121address>
//    UserData=<userdata>
//    Facilities=<facilities>
//
// For other media, the program expects exactly one DEVICE subsection with
// device name matching the media.  "Other" media and devices are created for
// entries assigned to all non-serial, non-isdn medias.
//
//    MEDIA=<media>
//    Port=<port-name>
//    Device=<device-name>
//
//    DEVICE=<media>
//    PhoneNumber=<phonenumber1>
//    AreaCode=<area-code1>
//    CountryID=<id>
//    CountryCode=<country-code>
//    UseDialingRules=<1/0>
//    Comment=<arbitrary-text1>
//    PhoneNumber=<phonenumber2>
//    AreaCode=<area-code1>
//    CountryID=<id>
//    CountryCode=<country-code>
//    UseDialingRules=<1/0>
//    Comment=<arbitrary-text2>
//    PhoneNumber=<phonenumberN>
//    AreaCode=<area-code1>
//    CountryID=<id>
//    CountryCode=<country-code>
//    UseDialingRules=<1/0>
//    Comment=<arbitrary-textn>
//    LastSelectedPhone=<index>
//    PromoteAlternates=<1/0>
//    TryNextAlternateOnFail=<1/0>
//
// The phonebook also supports the concept of "custom" entries, i.e. entries
// that fit the MEDIA followed by DEVICE subsection rules but which do not
// include certain expected key fields.  A custom entry is not editable with
// the UI, but may be chosen for connection.  This gives us a story for new
// drivers added by 3rd parties or after release and not yet fully supported
// in the UI.  (Note: The RAS API support for most the custom entry discussion
// above may be removed for NT SUR)
//

#include <nt.h>
#include <ntrtl.h>  // for DbgPrint
#include <nturtl.h>
#include <shlobj.h> // for CSIDL_*
#include "pbkp.h"

// This mutex guards against multiple RASFILE access to any phonebook file
// across processes.  Because this is currently a static library there is no
// easy way to protect a single file at a time though this would be adequate.
//
#define PBMUTEXNAME "RasPbFile"
HANDLE g_hmutexPb = NULL;


#define MARK_LastLineToDelete         249
#define MARK_BeginNetComponentsSearch 248

#define IB_BytesPerLine 64

const WCHAR  c_pszRegKeySecureVpn[]              = L"System\\CurrentControlSet\\Services\\Rasman\\PPP";
const WCHAR  c_pszRegValSecureVpn[]              = L"SecureVPN";
const WCHAR* c_pszRegKeyForceStrongEncryption    = c_pszRegKeySecureVpn;
const WCHAR  c_pszRegValForceStrongEncryption[]  = L"ForceStrongEncryption";

//
// Enumerated values define what encoding was used to store information
// in the phonebook.
//
#define EN_Ansi           0x0       // Ansi encoding
#define EN_Standard       0x1       // Utf8 encoding

//
// pmay: 124594
// 
// Defines a function prototype that converts a string from ansi to TCHAR.
//
typedef 
TCHAR* 
(* STRDUP_T_FROM_A_FUNC)(
    IN CHAR* pszAnsi);

//----------------------------------------------------------------------------
// Local prototypes
//----------------------------------------------------------------------------

BOOL
DeleteCurrentSection(
    IN HRASFILE h );

DWORD
GetPersonalPhonebookFile(
    IN TCHAR* pszUser,
    IN LONG lNum,
    OUT TCHAR* pszFile );

BOOL
GetPhonebookPath(
    IN PBUSER* pUser,
    IN DWORD dwFlags,
    OUT TCHAR** ppszPath,
    OUT DWORD* pdwPhonebookMode );

DWORD
InsertBinary(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN BYTE* pData,
    IN DWORD cbData );

DWORD
InsertBinaryChunk(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN BYTE* pData,
    IN DWORD cbData );

DWORD
InsertDeviceList(
    IN PBFILE *pFile,
    IN HRASFILE h,
    IN PBENTRY* ppbentry,
    IN PBLINK* ppblink );

DWORD
InsertFlag(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN BOOL fValue );

DWORD
InsertGroup(
    IN HRASFILE h,
    IN CHAR* pszGroupKey,
    IN TCHAR* pszValue );

DWORD
InsertLong(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN LONG lValue );

DWORD
InsertNetComponents(
    IN HRASFILE h,
    IN DTLLIST* pdtllist );

DWORD
InsertPhoneList(
    IN HRASFILE h,
    IN DTLLIST* pdtllist );

DWORD
InsertSection(
    IN HRASFILE h,
    IN TCHAR* pszSectionName );

DWORD
InsertString(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN TCHAR* pszValue );

DWORD
InsertStringA(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN CHAR* pszValue );

DWORD
InsertStringList(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN DTLLIST* pdtllistValues );

BOOL
IsGroup(
    IN CHAR* pszText );

DWORD
ModifyEntryList(
    IN PBFILE* pFile );

DWORD
ReadBinary(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT BYTE** ppResult,
    OUT DWORD* pcb );

DWORD
ReadDeviceList(
    IN HRASFILE h,
    IN STRDUP_T_FROM_A_FUNC pStrDupTFromA,
    IN OUT PBENTRY* ppbentry,
    IN OUT PBLINK* ppblink,
    IN BOOL fUnconfiguredPort,
    IN BOOL* pfSpeaker );

DWORD
ReadEntryList(
    IN OUT PBFILE* pFile,
    IN DWORD dwFlags,
    IN LPCTSTR pszSection);

DWORD
ReadFlag(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT BOOL* pfResult );

DWORD
ReadLong(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT LONG* plResult );

VOID
ReadNetComponents(
    IN HRASFILE h,
    IN DTLLIST* pdtllist );

DWORD
ReadPhoneList(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    OUT DTLLIST** ppdtllist,
    OUT BOOL* pfDirty );

DWORD
ReadString(
    IN HRASFILE h,
    IN STRDUP_T_FROM_A_FUNC pStrDupTFromA,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT TCHAR** ppszResult );

DWORD
ReadStringList(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT DTLLIST** ppdtllistResult );

BOOL
PbportTypeMatchesEntryType(
    IN PBPORT * ppbport,
    IN PBENTRY* ppbentry);

PBPORT*
PpbportFromNullModem(
    IN DTLLIST* pdtllistPorts,
    IN TCHAR* pszPort,
    IN TCHAR* pszDevice );

DWORD 
UpgradeRegistryOptions(
    IN HANDLE hConnection,
    IN PBENTRY* pEntry );

//----------------------------------------------------------------------------
// Routines
//----------------------------------------------------------------------------

VOID
ClosePhonebookFile(
    IN OUT PBFILE* pFile )

    // Closes the currently open phonebook file for shutdown.
    //
{
    if (pFile->hrasfile != -1)
    {
        RasfileClose( pFile->hrasfile );
        pFile->hrasfile = -1;
    }

    Free0( pFile->pszPath );
    pFile->pszPath = NULL;

    if (pFile->pdtllistEntries)
    {
        if (DtlGetListId( pFile->pdtllistEntries ) == RPBF_HeadersOnly)
        {
            DtlDestroyList( pFile->pdtllistEntries, DestroyPszNode );
        }
        else if (DtlGetListId(pFile->pdtllistEntries) == RPBF_HeaderType)
        {
            DtlDestroyList(pFile->pdtllistEntries, DestroyEntryTypeNode);
        }
        else
        {
            DtlDestroyList( pFile->pdtllistEntries, DestroyEntryNode );
        }
        pFile->pdtllistEntries = NULL;
    }
}


BOOL
DeleteCurrentSection(
    IN HRASFILE h )

    // Delete the section containing the current line from phonebook file 'h'.
    //
    // Returns true if all lines are deleted successfully, false otherwise.
    // False is returned if the current line is not in a section.  If
    // successful, the current line is set to the line following the deleted
    // section.  There are no promises about the current line in case of
    // failure.
    //
{
    BOOL fLastLine;

    // Mark the last line in the section, then reset the current line to the
    // first line of the section.
    //
    if (!RasfileFindLastLine( h, RFL_ANY, RFS_SECTION )
        || !RasfilePutLineMark( h, MARK_LastLineToDelete )
        || !RasfileFindFirstLine( h, RFL_ANY, RFS_SECTION ))
    {
        return FALSE;
    }

    // Delete lines up to and including the last line of the section.
    //
    do
    {
        fLastLine = (RasfileGetLineMark( h ) == MARK_LastLineToDelete);

        if (!RasfileDeleteLine( h ))
        {
            return FALSE;
        }
    }
    while (!fLastLine);

    return TRUE;
}

// (shaunco) DwAllocateSecurityDescriptorAllowAccessToWorld was added when
// it was seen that the old InitSecurityDescriptor code was leaking memory
// like a sieve.
//
#define SIZE_ALIGNED_FOR_TYPE(_size, _type) \
    (((_size) + sizeof(_type)-1) & ~(sizeof(_type)-1))

DWORD
DwAllocateSecurityDescriptorAllowAccessToWorld (
    PSECURITY_DESCRIPTOR*   ppSd
    )
{
    PSECURITY_DESCRIPTOR    pSd;
    PSID                    pSid;
    PACL                    pDacl;
    DWORD                   dwErr = NOERROR;
    DWORD                   dwAlignSdSize;
    DWORD                   dwAlignDaclSize;
    DWORD                   dwSidSize;
    PVOID                   pvBuffer;
    DWORD                   dwAcls = 0;

    // Here is the buffer we are building.
    //
    //   |<- a ->|<- b ->|<- c ->|
    //   +-------+--------+------+
    //   |      p|      p|       |
    //   | SD   a| DACL a| SID   |
    //   |      d|      d|       |
    //   +-------+-------+-------+
    //   ^       ^       ^
    //   |       |       |
    //   |       |       +--pSid
    //   |       |
    //   |       +--pDacl
    //   |
    //   +--pSd (this is returned via *ppSd)
    //
    //   pad is so that pDacl and pSid are aligned properly.
    //
    //   a = dwAlignSdSize
    //   b = dwAlignDaclSize
    //   c = dwSidSize
    //

    // Initialize output parameter.
    //
    *ppSd = NULL;

    // Compute the size of the SID.  The SID is the well-known SID for World
    // (S-1-1-0).
    //
    dwSidSize = GetSidLengthRequired(1);

    // Compute the size of the DACL.  It has an inherent copy of SID within
    // it so add enough room for it.  It also must sized properly so that
    // a pointer to a SID structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignDaclSize = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(ACCESS_ALLOWED_ACE) + sizeof(ACL) + dwSidSize,
                        PSID);

    // Compute the size of the SD.  It must be sized propertly so that a
    // pointer to a DACL structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignSdSize   = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(SECURITY_DESCRIPTOR),
                        PACL);

    // Allocate the buffer big enough for all.
    //
    dwErr = ERROR_OUTOFMEMORY;
    pvBuffer = Malloc(dwSidSize + dwAlignDaclSize + dwAlignSdSize);
    if (pvBuffer)
    {
        SID_IDENTIFIER_AUTHORITY SidIdentifierWorldAuth
                                    = SECURITY_WORLD_SID_AUTHORITY;
        PULONG  pSubAuthority;

        dwErr = NOERROR;

        // Setup the pointers into the buffer.
        //
        pSd   = pvBuffer;
        pDacl = (PACL)((PBYTE)pvBuffer + dwAlignSdSize);
        pSid  = (PSID)((PBYTE)pDacl + dwAlignDaclSize);

        // Initialize pSid as S-1-1-0.
        //
        if (!InitializeSid(
                pSid,
                &SidIdentifierWorldAuth,
                1))  // 1 sub-authority
        {
            dwErr = GetLastError();
            goto finish;
        }

        pSubAuthority = GetSidSubAuthority(pSid, 0);
        *pSubAuthority = SECURITY_WORLD_RID;

        // Initialize pDacl.
        //
        if (!InitializeAcl(
                pDacl,
                dwAlignDaclSize,
                ACL_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        dwAcls = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;

        dwAcls &= ~(WRITE_DAC | WRITE_OWNER);
        
        if(!AddAccessAllowedAce(
                pDacl,
                ACL_REVISION,
                dwAcls,
                pSid))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Initialize pSd.
        //
        if (!InitializeSecurityDescriptor(
                pSd,
                SECURITY_DESCRIPTOR_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set pSd to use pDacl.
        //
        if (!SetSecurityDescriptorDacl(
                pSd,
                TRUE,
                pDacl,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the owner for pSd.
        //
        if (!SetSecurityDescriptorOwner(
                pSd,
                NULL,
                TRUE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the group for pSd.
        //
        if (!SetSecurityDescriptorGroup(
                pSd,
                NULL,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

finish:
        if (!dwErr)
        {
            *ppSd = pSd;
        }
        else
        {
            Free(pvBuffer);
        }
    }

    return dwErr;
}

BOOL
GetDefaultPhonebookPath(
    IN  DWORD dwFlags,
    OUT TCHAR** ppszPath )

    // Loads caller's 'ppszPath' with the path to the default phonebook
    // for the current user, i.e. the phonebook which would be opened
    // if 'NULL' were passed as the 'pszPhonebook' argument to any RAS API.
    //
    // Returns true if successful, or false otherwise.
    // It is the caller's responsibility to Free the returned string.
    //

{
    DWORD dwPhonebookMode;
    BOOL f;
    PBUSER user;

    if (GetUserPreferences( NULL, &user, FALSE ) != 0)
    {
        return FALSE;
    }

    f = GetPhonebookPath( &user, dwFlags, ppszPath, &dwPhonebookMode );

    DestroyUserPreferences( &user );

    return f;
}


#if 0
DWORD
GetPersonalPhonebookFile(
    IN TCHAR* pszUser,
    IN LONG lNum,
    OUT TCHAR* pszFile )

    // Loads caller's 'pszFile' buffer with the NUL-terminated filename
    // corresponding to unique phonebook file name attempt 'lNum' for current
    // user 'pszUser'.  Caller's 'pszFile' must be at least 13 characters
    // long.  Attempts go from -1 to 999.
    //
    // Returns 0 if successful or a non-0 error code.
    //
{
    TCHAR szNum[ 3 + 1 ];

    if (lNum < 0)
    {
        lstrcpyn( pszFile, pszUser, 9 );
    }
    else
    {
        if (lNum > 999)
        {
            return ERROR_PATH_NOT_FOUND;
        }

        lstrcpy( pszFile, TEXT("00000000") );
        LToT( lNum, szNum, 10 );
        lstrcpy( pszFile + 8 - lstrlen( szNum ), szNum );
        CopyMemory( pszFile, pszUser,
            (min( lstrlen( pszUser ), 5 )) * sizeof(TCHAR) );
    }

    lstrcat( pszFile, TEXT(".pbk") );
    return 0;
}
#endif


BOOL
GetPhonebookDirectory(
    IN DWORD dwPhonebookMode,
    OUT TCHAR* pszPathBuf )

    // Loads caller's 'pszPathBuf' (should have length MAX_PATH + 1) with the
    // path to the directory containing phonebook files for the given mode,
    // e.g. c:\nt\system32\ras\" for mode PBM_Router.  Note the
    // trailing backslash.
    //
    // Returns true if successful, false otherwise.  Caller is guaranteed that
    // an 8.3 filename will fit on the end of the directory without exceeding
    // MAX_PATH.
    //
{
    BOOL bSuccess = FALSE;
    UINT cch;

    // 205217: (shaunco) PBM_System also comees from the profile now.
    // We pick it up using the command appdata directory returned from
    // SHGetFolderPath.
    //
    if (dwPhonebookMode == PBM_Personal || dwPhonebookMode == PBM_System)
    {
        HANDLE hToken = NULL;

        if ((OpenThreadToken(
                GetCurrentThread(), 
                TOKEN_QUERY | TOKEN_IMPERSONATE, 
                TRUE, 
                &hToken)
             || OpenProcessToken(
                    GetCurrentProcess(), 
                    TOKEN_QUERY | TOKEN_IMPERSONATE, 
                    &hToken)))
        {
            HRESULT hr;
            INT csidl = CSIDL_APPDATA;

            if (dwPhonebookMode == PBM_System)
            {
                csidl = CSIDL_COMMON_APPDATA;
            }

            hr = SHGetFolderPath(NULL, csidl, hToken, 0, pszPathBuf);

            if (SUCCEEDED(hr))
            {
                if(lstrlen(pszPathBuf) <=
                    (MAX_PATH - 
                        (lstrlen(TEXT("\\Microsoft\\Network\\Connections\\Pbk\\")))))
                {
                    lstrcat(pszPathBuf, TEXT("\\Microsoft\\Network\\Connections\\Pbk\\"));
                    bSuccess = TRUE;
                }
            }
            else
            {
                TRACE1("ShGetFolderPath failed. hr=0x%08x", hr);
            }

            CloseHandle(hToken);
        }
    }
    else
    {
        // Note: RASDLG uses this case to determine the scripts directory.
        //
        cch = GetSystemDirectory(pszPathBuf, MAX_PATH + 1);

        if (cch != 0 && cch <= (MAX_PATH - (5 + 8 + 1 + 3)))
        {
            lstrcat(pszPathBuf, TEXT("\\Ras\\"));
            bSuccess = TRUE;
        }
    }

    return bSuccess;
}


BOOL
GetPhonebookPath(
    IN PBUSER* pUser,
    IN DWORD dwFlags,
    OUT TCHAR** ppszPath,
    OUT DWORD* pdwPhonebookMode )

    // Loads caller's '*ppszPath', with the full path to the user's phonebook
    // file.  Caller's '*pdwPhonebookMode' is set to the mode, system,
    // personal, or alternate.  'PUser' is the current user preferences.
    //
    // Returns true if successful, false otherwise.  It is caller's
    // responsibility to Free the returned string.
    //
{
    TCHAR szPath[ MAX_PATH + 1 ];

    *szPath = TEXT('\0');
    
    if (pUser)
    {
        if (pUser->dwPhonebookMode == PBM_Personal)
        {
            if (!GetPersonalPhonebookPath( pUser->pszPersonalFile, szPath ))
            {
                return FALSE;
            }
            *ppszPath = StrDup( szPath );
            if(NULL == *ppszPath)
            {
                return FALSE;
            }
            
            *pdwPhonebookMode = PBM_Personal;
            return TRUE;
        }
        else if (pUser->dwPhonebookMode == PBM_Alternate)
        {
            *ppszPath = StrDup( pUser->pszAlternatePath );

            if(NULL == *ppszPath)
            {
                return FALSE;
            }
            
            *pdwPhonebookMode = PBM_Alternate;
            return TRUE;
        }
    }

    // 205217: (shaunco) Admins or power users get to use the public
    // phonebook file.  Everyone else must use their own phonebook to
    // prevent them from adding to/deleting from the public phonebook.
    // The exception is the 'no user' case when we are called from winlogon.
    // For this case, all edits happen in the public phonebook.
    //
    if (
        (dwFlags & RPBF_NoUser)     || 
        (dwFlags & RPBF_AllUserPbk) ||  // XP 346918
        (FIsUserAdminOrPowerUser()) 
        )
    {
        TRACE("User is an admin or power user. (or no user context yet)");

        if (!GetPublicPhonebookPath( szPath ))
        {
            return FALSE;
        }
        *ppszPath = StrDup( szPath );

        if(NULL == *ppszPath)
        {
            return FALSE;
        }
        
        *pdwPhonebookMode = PBM_System;
    }
    else
    {
        TRACE("User is NOT an admin or power user.");

        if (!GetPersonalPhonebookPath( NULL, szPath ))
        {
            return FALSE;
        }
        *ppszPath = StrDup( szPath );
        
        if(NULL == *ppszPath)
        {
            return FALSE;
        }
        
        *pdwPhonebookMode = PBM_Personal;
    }
    return TRUE;
}


BOOL
GetPersonalPhonebookPath(
    IN TCHAR* pszFile,
    OUT TCHAR* pszPathBuf )

    // Loads caller's 'pszPathBuf' (should have length MAX_PATH + 1) with the
    // path to the personal phonebook, (in the user's profile.)
    // 'PszFile' is the filename of the personal phonebook.
    //
    // Returns true if successful, false otherwise.
    //
{
    if (!GetPhonebookDirectory( PBM_Personal, pszPathBuf ))
    {
        return FALSE;
    }

    // No file means use the default name for a phonebook.
    //
    if (!pszFile)
    {
        pszFile = TEXT("rasphone.pbk");
    }

    lstrcat( pszPathBuf, pszFile );

    return TRUE;
}


BOOL
GetPublicPhonebookPath(
    OUT TCHAR* pszPathBuf )

    // Loads caller's 'pszPathBuf' (should have length MAX_PATH + 1) with the
    // path to the system phonebook, (in the all-user's profile.)
    //
    // Returns true if successful, false otherwise.
    //
{
    if (!GetPhonebookDirectory( PBM_System, pszPathBuf ))
    {
        return FALSE;
    }

    lstrcat( pszPathBuf, TEXT("rasphone.pbk") );

    return TRUE;
}


DWORD
InitializePbk(
    void )

    // Initialize the PBK library.  This routine must be called before any
    // other PBK library calls.  See also TerminatePbk.
    //
{
    if (!g_hmutexPb)
    {
        DWORD dwErr;
        SECURITY_ATTRIBUTES     sa;
        PSECURITY_DESCRIPTOR    pSd;

        // The mutex must be accessible by everyone, even processes with
        // security privilege lower than the creator.
        //
        dwErr = DwAllocateSecurityDescriptorAllowAccessToWorld(&pSd);
        if (dwErr != 0)
        {
            return dwErr;
        }

        sa.nLength = sizeof(SECURITY_ATTRIBUTES) ;
        sa.lpSecurityDescriptor = pSd;
        sa.bInheritHandle = FALSE ;

        g_hmutexPb = CreateMutexA( &sa, FALSE, PBMUTEXNAME );
        Free(pSd);
        if (!g_hmutexPb)
        {
            DWORD dwErr = 0;
            
            dwErr = GetLastError();

            if(ERROR_ACCESS_DENIED == dwErr)
            {
                dwErr = NO_ERROR;
                //
                // Try to open the mutex for synchronization.
                // the mutex must already have been created.
                //
                g_hmutexPb = OpenMutexA(SYNCHRONIZE, FALSE, PBMUTEXNAME);
                if(NULL == g_hmutexPb)
                {
                    return GetLastError();
                }
            }
        }
    }

    return 0;
}


#if 0
DWORD
InitPersonalPhonebook(
    OUT TCHAR** ppszFile )

    // Creates a new personal phonebook file and initializes it to the current
    // contents of the public phonebook file.  Returns the address of the file
    // name in caller's '*ppszfile' which is caller's responsibility to Free.
    //
    // Returns 0 if succesful, otherwise a non-0 error code.
    //
{
    TCHAR szUser[ UNLEN + 1 ];
    DWORD cbUser = UNLEN + 1;
    TCHAR szPath[ MAX_PATH + 1 ];
    TCHAR* pszDirEnd;
    LONG lTry = -1;

    // Find a name for the personal phonebook that is derived from the
    // username and does not already exist.
    //
    if (!GetUserName( szUser, &cbUser ))
    {
        return ERROR_NO_SUCH_USER;
    }

    if (!GetPhonebookDirectory( PBM_Personal, szPath ))
    {
        return ERROR_PATH_NOT_FOUND;
    }

    pszDirEnd = &szPath[ lstrlen( szPath ) ];

    do
    {
        DWORD dwErr;

        dwErr = GetPersonalPhonebookFile( szUser, lTry++, pszDirEnd );
        if (dwErr != 0)
        {
            return dwErr;
        }
    }
    while (FFileExists( szPath ));

    // Copy the public phonebook to the new personal phonebook.
    //
    {
        TCHAR szPublicPath[ MAX_PATH + 1 ];

        if (!GetPublicPhonebookPath( szPublicPath ))
        {
            return ERROR_PATH_NOT_FOUND;
        }

        if (!CopyFile( szPublicPath, szPath, TRUE ))
        {
            return GetLastError();
        }
    }

    *ppszFile = StrDup( pszDirEnd );
    if (!*ppszFile)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return 0;
}
#endif


DWORD
InsertBinary(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN BYTE* pData,
    IN DWORD cbData )

    // Insert key/value line(s) with key 'pszKey' and value hex dump 'cbData'
    // of 'pData' at the current line in file 'h'.  The data will be split
    // over multiple same-named keys, if necessary.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the one added.
    //
{
    DWORD dwErr;
    BYTE* p;
    DWORD c;

    p = pData;
    c = 0;

    while (cbData)
    {
        if (cbData >= IB_BytesPerLine)
        {
            c = IB_BytesPerLine;
        }
        else
        {
            c = cbData;
        }

        dwErr = InsertBinaryChunk( h, pszKey, p, c );
        if (dwErr != 0)
        {
            return dwErr;
        }

        p += c;
        cbData -= c;
    }

    return 0;
}


DWORD
InsertBinaryChunk(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN BYTE* pData,
    IN DWORD cbData )

    // Insert key/value line(s) with key 'pszKey' and value hex dump 'cbData'
    // of 'pData' at the current line in file 'h'.  The data will be split
    // over multiple same-named keys, if necessary.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the one added.
    //
{
    CHAR szBuf[ (IB_BytesPerLine * 2) + 1 ];
    CHAR* pszBuf;
    BOOL fStatus;

    ASSERT( cbData<=IB_BytesPerLine );

    szBuf[ 0 ] = '\0';
    for (pszBuf = szBuf; cbData; ++pData, --cbData)
    {
        *pszBuf++ = HexChar( (BYTE )(*pData / 16) );
        *pszBuf++ = HexChar( (BYTE )(*pData % 16) );
    }
    *pszBuf = '\0';

    return InsertStringA( h, pszKey, szBuf );
}


DWORD
InsertDeviceList(
    IN PBFILE *pFile,
    IN HRASFILE h,
    IN PBENTRY* ppbentry,
    IN PBLINK* ppblink )

    // Inserts the list of devices associated with link 'ppblink' of phone
    // book entry 'ppbentry' at the current line of file 'h'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.
    //
{
    DWORD dwErr, dwFlags = 0;
    PBDEVICETYPE type;

    type = ppblink->pbport.pbdevicetype;
    dwFlags = ppblink->pbport.dwFlags;

    if (type == PBDT_Isdn)
    {
        // ISDN ports use a single device with the same name as the media.
        //
        if ((dwErr = InsertGroup(
                h, GROUPKEY_Device, TEXT(ISDN_TXT) )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertPhoneList( h, ppblink->pdtllistPhones )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_LastSelectedPhone,
                ppblink->iLastSelectedPhone )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_PromoteAlternates,
                ppblink->fPromoteAlternates )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_TryNextAlternateOnFail,
                ppblink->fTryNextAlternateOnFail )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong( h, KEY_LineType, ppblink->lLineType )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag( h, KEY_Fallback, ppblink->fFallback )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_Compression, ppblink->fCompression )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_Channels, ppblink->lChannels )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_ProprietaryIsdn, ppblink->fProprietaryIsdn )) != 0)
        {
            return dwErr;
        }
    }
    else if (type == PBDT_X25)
    {
        // Native X.25 ports are assumed to use a single device with the same
        // name as the media, i.e. "x25".
        //
        if ((dwErr = InsertGroup( h, GROUPKEY_Device, TEXT(X25_TXT) )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_X25_Address, ppbentry->pszX25Address )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_X25_UserData, ppbentry->pszX25UserData )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_X25_Facilities, ppbentry->pszX25Facilities )) != 0)
        {
            return dwErr;
        }
    }
    else if (   (type == PBDT_Other)
            ||  (type == PBDT_Irda)
            ||  (type == PBDT_Vpn)
            ||  (type == PBDT_Serial)
            ||  (type == PBDT_Atm)
            ||  (type == PBDT_Parallel)
            ||  (type == PBDT_Sonet)
            ||  (type == PBDT_Sw56)
            ||  (type == PBDT_FrameRelay)
            ||  (type == PBDT_PPPoE))
    {

        //
        // If we are looking at a downlevel server (<= win2k) we
        // save the device type as media.
        //
        RAS_RPC *pConnection = (RAS_RPC *) pFile->hConnection;
        TCHAR *pszDevice = NULL;
        BOOL bFreeDev = FALSE;
        
        if(pFile->hConnection < (HANDLE)VERSION_501)
        {
            pszDevice = pszDeviceTypeFromRdt(RdtFromPbdt(type, dwFlags));
        }
        
        if(NULL == pszDevice)
        {
            pszDevice = ppblink->pbport.pszMedia;
        }
        else
        {
            bFreeDev = TRUE;
        }
                            
        // "Other" ports use a single device with the same name as the media.
        //
        if ((dwErr = InsertGroup(
                h, GROUPKEY_Device, pszDevice )) != 0)
        {
            if (bFreeDev) Free0(pszDevice);
            return dwErr;
        }

        if ((dwErr = InsertPhoneList( h, ppblink->pdtllistPhones )) != 0)
        {
            if (bFreeDev) Free0(pszDevice);
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_LastSelectedPhone,
                ppblink->iLastSelectedPhone )) != 0)
        {
            if (bFreeDev) Free0(pszDevice);
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_PromoteAlternates,
                ppblink->fPromoteAlternates )) != 0)
        {
            if (bFreeDev) Free0(pszDevice);
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_TryNextAlternateOnFail,
                ppblink->fTryNextAlternateOnFail )) != 0)
        {
            if (bFreeDev) Free0(pszDevice);
            return dwErr;
        }
    }
    else
    {
        // Serial ports may involve multiple devices, specifically a modem, an
        // X.25 dialup PAD, and a post-connect switch.  Pre-connect script is
        // preserved, though no longer offered by UI.
        //
        if (ppblink->pbport.fScriptBefore
            || ppblink->pbport.fScriptBeforeTerminal)
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_SWITCH_TXT) )) != 0)
            {
                return dwErr;
            }

            if (ppblink->pbport.fScriptBefore)
            {
                if ((dwErr = InsertString(
                        h, KEY_Name,
                        ppblink->pbport.pszScriptBefore )) != 0)
                {
                    return dwErr;
                }
            }

            if (ppblink->pbport.fScriptBeforeTerminal)
            {
                if ((dwErr = InsertFlag(
                        h, KEY_Terminal,
                        ppblink->pbport.fScriptBeforeTerminal )) != 0)
                {
                    return dwErr;
                }
            }

            if (ppblink->pbport.fScriptBefore)
            {
                if ((dwErr = InsertFlag(
                        h, KEY_Script,
                        ppblink->pbport.fScriptBefore )) != 0)
                {
                    return dwErr;
                }
            }
        }

        if (((type == PBDT_Null) && !(dwFlags & PBP_F_NullModem)) ||
            (type == PBDT_ComPort)
            )
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_NULL_TXT) )) != 0)
            {
                return dwErr;
            }
        }

        // pmay: 245860
        //
        // We must save null modems the same way we save modems in
        // order to export properties such as connect bps.
        //
        if ((type == PBDT_Modem) ||
            (dwFlags & PBP_F_NullModem))
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_MODEM_TXT) )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertPhoneList( h, ppblink->pdtllistPhones )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertLong(
                    h, KEY_LastSelectedPhone,
                    ppblink->iLastSelectedPhone )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_PromoteAlternates,
                    ppblink->fPromoteAlternates )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_TryNextAlternateOnFail,
                    ppblink->fTryNextAlternateOnFail )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_HwFlow, ppblink->fHwFlow )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_Ec, ppblink->fEc )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_Ecc, ppblink->fEcc )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_Speaker, ppblink->fSpeaker )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertLong(
                    h, KEY_MdmProtocol, ppblink->dwModemProtocol )) != 0)
            {
                return dwErr;
            }
        }

        if (type == PBDT_Pad
            || (type == PBDT_Modem && ppbentry->pszX25Network))
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_PAD_TXT) )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertString(
                    h, KEY_PAD_Type, ppbentry->pszX25Network )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertString(
                    h, KEY_PAD_Address, ppbentry->pszX25Address )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertString(
                    h, KEY_PAD_UserData, ppbentry->pszX25UserData )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertString(
                    h, KEY_PAD_Facilities, ppbentry->pszX25Facilities )) != 0)
            {
                return dwErr;
            }
        }

        if (ppbentry->fScriptAfter 
            || ppbentry->fScriptAfterTerminal 
            || ppbentry->dwCustomScript)
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_SWITCH_TXT) )) != 0)
            {
                return dwErr;
            }

            if (ppbentry->fScriptAfter)
            {
                if ((dwErr = InsertString(
                        h, KEY_Name,
                        ppbentry->pszScriptAfter )) != 0)
                {
                    return dwErr;
                }
            }

            if (ppbentry->fScriptAfterTerminal)
            {
                if ((dwErr = InsertFlag(
                        h, KEY_Terminal,
                        ppbentry->fScriptAfterTerminal )) != 0)
                {
                    return dwErr;
                }
            }

            if (ppbentry->fScriptAfter)
            {
                if ((dwErr = InsertFlag(
                        h, KEY_Script,
                        ppbentry->fScriptAfter )) != 0)
                {
                    return dwErr;
                }
            }

            if(ppbentry->dwCustomScript)
            {
                if((dwErr = InsertLong(
                        h, KEY_CustomScript,
                        ppbentry->dwCustomScript)) != 0)
                {
                    return dwErr;
                }
            }
        }
    }

    return 0;
}


DWORD
InsertFlag(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN BOOL fValue )

    // Insert a key/value line after the current line in file 'h'.  The
    // inserted line has a key of 'pszKey' and a value of "1" if 'fValue' is
    // true or "0" otherwise.  If 'pszKey' is NULL a blank line is appended.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the one added.
    //
{
    return InsertStringA( h, pszKey, (fValue) ? "1" : "0" );
}


DWORD
InsertGroup(
    IN HRASFILE h,
    IN CHAR* pszGroupKey,
    IN TCHAR* pszValue )

    // Insert a blank line and a group header with group key 'pszGroupKey' and
    // value 'pszValue' after the current line in file 'h'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the added group header.
    //
{
    DWORD dwErr;

    if ((dwErr = InsertString( h, NULL, NULL )) != 0)
    {
        return dwErr;
    }

    if ((dwErr = InsertString( h, pszGroupKey, pszValue )) != 0)
    {
        return dwErr;
    }

    return 0;
}


DWORD
InsertLong(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN LONG lValue )

    // Insert a key/value line after the current line in file 'h'.  The
    // inserted line has a key of 'pszKey' and a value of 'lValue'.  If
    // 'pszKey' is NULL a blank line is appended.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the one added.
    //
{
    CHAR szNum[ 33 + 1 ];

    _ltoa( lValue, szNum, 10 );

    return InsertStringA( h, pszKey, szNum );
}


DWORD
InsertNetComponents(
    IN HRASFILE h,
    IN DTLLIST* pdtllist )

    // Inserts the NETCOMPONENTS group and adds lines for the list of net
    // component key/value pairs in 'pdtllist' at the current line of file
    // 'h'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.
    //
{
    DWORD dwErr;
    DTLNODE* pdtlnode;

    // Insert the NETCOMPONENTS group.
    //
    dwErr = InsertGroup( h, GROUPKEY_NetComponents, TEXT("") );
    if (dwErr != 0)
    {
        return dwErr;
    }

    // Insert a key/value pair for each listed net component.
    //
    for (pdtlnode = DtlGetFirstNode( pdtllist );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        KEYVALUE* pKv;
        CHAR* pszKeyA;

        pKv = (KEYVALUE* )DtlGetData( pdtlnode );
        ASSERT( pKv );

        pszKeyA = StrDupAFromT( pKv->pszKey );
        if (!pszKeyA)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = InsertString( h, pszKeyA, pKv->pszValue );
        Free0( pszKeyA );
        if (dwErr != 0)
        {
            return dwErr;
        }
    }

    return 0;
}


DWORD
InsertPhoneList(
    IN HRASFILE h,
    IN DTLLIST* pdtllist )

    // Insert key/value lines for each PBPHONE node in from 'pdtllist' after
    // the current line in file 'h'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the last one added.
    //
{
    DWORD dwErr;
    DTLNODE* pdtlnode;

    for (pdtlnode = DtlGetFirstNode( pdtllist );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        CHAR* pszValueA;
        PBPHONE* pPhone;

        pPhone = (PBPHONE* )DtlGetData( pdtlnode );

        dwErr = InsertString( h, KEY_PhoneNumber, pPhone->pszPhoneNumber );
        if (dwErr)
        {
            return dwErr;
        }

        dwErr = InsertString( h, KEY_AreaCode, pPhone->pszAreaCode );
        if (dwErr)
        {
            return dwErr;
        }

        dwErr = InsertLong( h, KEY_CountryCode, pPhone->dwCountryCode );
        if (dwErr)
        {
            return dwErr;
        }

        dwErr = InsertLong( h, KEY_CountryID, pPhone->dwCountryID );
        if (dwErr)
        {
            return dwErr;
        }

        dwErr = InsertFlag( h, KEY_UseDialingRules, pPhone->fUseDialingRules );
        if (dwErr)
        {
            return dwErr;
        }

        dwErr = InsertString( h, KEY_Comment, pPhone->pszComment );
        if (dwErr)
        {
            return dwErr;
        }
    }

    return 0;
}


DWORD
InsertSection(
    IN HRASFILE h,
    IN TCHAR* pszSectionName )

    // Insert a section header with name 'pszSectionName' and a trailing blank
    // line in file 'h' after the current line.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the added section header.
    //
{
    DWORD dwErr;
    CHAR* pszSectionNameA;
    BOOL fStatus;

    ASSERT( pszSectionName );

    if ((dwErr = InsertString( h, NULL, NULL )) != 0)
    {
        return dwErr;
    }

    pszSectionNameA = StrDupAFromT( pszSectionName );
    if (!pszSectionNameA)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    fStatus = RasfilePutSectionName( h, pszSectionNameA );

    Free( pszSectionNameA );

    if (!fStatus)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if ((dwErr = InsertString( h, NULL, NULL )) != 0)
    {
        return dwErr;
    }

    RasfileFindFirstLine( h, RFL_SECTION, RFS_SECTION );

    return 0;
}


DWORD
InsertString(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN TCHAR* pszValue )

    // Insert a key/value line with key 'pszKey' and value 'pszValue' after
    // the current line in file 'h'.  If 'pszKey' is NULL a blank line is
    // appended.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the one added.
    //
{
    BOOL fStatus;
    CHAR* pszValueA;

    if (pszValue)
    {
        pszValueA = StrDupAFromT( pszValue );

        if (!pszValueA)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        pszValueA = NULL;
    }

    fStatus = InsertStringA( h, pszKey, pszValueA );

    Free0( pszValueA );
    return fStatus;
}


DWORD
InsertStringA(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN CHAR* pszValue )

    // Insert a key/value line with key 'pszKey' and value 'pszValue' after
    // the current line in file 'h'.  If 'pszKey' is NULL a blank line is
    // appended.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the one added.
    //
{
    if (!RasfileInsertLine( h, "", FALSE ))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!RasfileFindNextLine( h, RFL_ANY, RFS_FILE ))
    {
        RasfileFindFirstLine( h, RFL_ANY, RFS_FILE );
    }

    if (pszKey)
    {
        CHAR* pszValueA;

        if (!pszValue)
        {
            pszValue = "";
        }

        if (!RasfilePutKeyValueFields( h, pszKey, pszValue ))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return 0;
}


DWORD
InsertStringList(
    IN HRASFILE h,
    IN CHAR* pszKey,
    IN DTLLIST* pdtllistValues )

    // Insert key/value lines with key 'pszKey' and values from
    // 'pdtllistValues' after the current line in file 'h'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.  The current
    // line is the last one added.
    //
{
    DTLNODE* pdtlnode;

    for (pdtlnode = DtlGetFirstNode( pdtllistValues );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        CHAR* pszValueA;
        BOOL fStatus;

        if (!RasfileInsertLine( h, "", FALSE ))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (!RasfileFindNextLine( h, RFL_ANY, RFS_FILE ))
        {
            RasfileFindFirstLine( h, RFL_ANY, RFS_FILE );
        }

        pszValueA = StrDupAFromT( (TCHAR* )DtlGetData( pdtlnode ) );
        if (!pszValueA)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        fStatus = RasfilePutKeyValueFields( h, pszKey, pszValueA );

        Free( pszValueA );

        if (!fStatus)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return 0;
}


BOOL
IsDeviceLine(
    IN CHAR* pszText )

    // Returns true if the text of the line, 'pszText', indicates the line is
    // a DEVICE subsection header, false otherwise.
    //
{
    return
        (StrNCmpA( pszText, GROUPID_Device, sizeof(GROUPID_Device) - 1 ) == 0);
}


BOOL
IsGroup(
    IN CHAR* pszText )

    // Returns true if the text of the line, 'pszText', indicates the line is
    // a valid subsection header, false otherwise.  The address of this
    // routine is passed to the RASFILE library on RasFileLoad.
    //
{
    return
        IsMediaLine( pszText )
        || IsDeviceLine( pszText )
        || IsNetComponentsLine( pszText );
}


BOOL
IsMediaLine(
    IN CHAR* pszText )

    // Returns true if the text of the line, 'pszText', indicates the line is
    // a MEDIA subsection header, false otherwise.
    //
{
    return
        (StrNCmpA( pszText, GROUPID_Media, sizeof(GROUPID_Media) - 1 ) == 0);
}


BOOL
IsNetComponentsLine(
    IN CHAR* pszText )

    // Returns true if the text of the line, 'pszText', indicates the line is
    // a NETCOMPONENTS subsection header, false otherwise.
    //
{
    return
        (StrNCmpA(
            pszText,
            GROUPID_NetComponents,
            sizeof(GROUPID_NetComponents) - 1 ) == 0);
}


DWORD
ModifyEntryList(
    IN PBFILE* pFile )

    // Update all dirty entries in phone book file 'pFile'.
    //
    // Returns 0 if successful, otherwise a non-zero error code.
    //
{
    DWORD dwErr = 0;
    DTLNODE* pdtlnodeEntry;
    DTLNODE* pdtlnodeLink;
    HRASFILE h;

    h = pFile->hrasfile;

    for (pdtlnodeEntry = DtlGetFirstNode( pFile->pdtllistEntries );
         pdtlnodeEntry;
         pdtlnodeEntry = DtlGetNextNode( pdtlnodeEntry ))
    {
        PBENTRY* ppbentry = (PBENTRY* )DtlGetData( pdtlnodeEntry );

     // if (!ppbentry->fDirty || ppbentry->fCustom)
     //for bug 174260
        if (!ppbentry->fDirty )
        {
            continue;
        }

        // Delete the current version of the entry, if any.
        //
        {
            CHAR* pszEntryNameA;

            ASSERT( ppbentry->pszEntryName );
            pszEntryNameA = StrDupAFromT( ppbentry->pszEntryName );
            if (!pszEntryNameA)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if (RasfileFindSectionLine( h, pszEntryNameA, TRUE ))
            {
                DeleteCurrentSection( h );
            }

            Free( pszEntryNameA );
        }

        // Append a blank line followed by a section header and the entry
        // description to the end of the file.
        //
        RasfileFindLastLine( h, RFL_ANY, RFS_FILE );

        if ((dwErr = InsertSection( h, ppbentry->pszEntryName )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_Encoding,
               (LONG ) EN_Standard )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_Type,
               (LONG )ppbentry->dwType )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_AutoLogon, ppbentry->fAutoLogon )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_UseRasCredentials, ppbentry->fUseRasCredentials)) != 0)
        {   
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_UID,
                (LONG )ppbentry->dwDialParamsUID )) != 0)
        {
            break;
        }

        if(ppbentry->pGuid)
        {
            if ((dwErr = InsertBinary(
                    h, KEY_Guid,
                    (BYTE* )ppbentry->pGuid, sizeof( GUID ) )) != 0)
            {
                return dwErr;
            }
        }

        if ((dwErr = InsertLong(
                h, KEY_BaseProtocol,
                (LONG )ppbentry->dwBaseProtocol )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_VpnStrategy,
                (LONG )ppbentry->dwVpnStrategy )) != 0)
        {
            break;
        }

#if AMB
        if ((dwErr = InsertLong(
                h, KEY_Authentication,
                (LONG )ppbentry->dwAuthentication )) != 0)
        {
            break;
        }
#endif

        if ((dwErr = InsertLong(
                h, KEY_ExcludedProtocols,
                (LONG )ppbentry->dwfExcludedProtocols )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_LcpExtensions,
                ppbentry->fLcpExtensions )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_DataEncryption,
                ppbentry->dwDataEncryption )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_SwCompression,
                ppbentry->fSwCompression )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_NegotiateMultilinkAlways,
                ppbentry->fNegotiateMultilinkAlways )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_SkipNwcWarning,
                ppbentry->fSkipNwcWarning )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_SkipDownLevelDialog,
                ppbentry->fSkipDownLevelDialog )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_SkipDoubleDialDialog,
                ppbentry->fSkipDoubleDialDialog )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_DialMode,
                (LONG )ppbentry->dwDialMode )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_DialPercent,
                (LONG )ppbentry->dwDialPercent )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_DialSeconds,
                (LONG )ppbentry->dwDialSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_HangUpPercent,
                (LONG )ppbentry->dwHangUpPercent )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_HangUpSeconds,
                (LONG )ppbentry->dwHangUpSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_OverridePref,
                ppbentry->dwfOverridePref )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_RedialAttempts,
                ppbentry->dwRedialAttempts )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_RedialSeconds,
                ppbentry->dwRedialSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_IdleDisconnectSeconds,
                ppbentry->lIdleDisconnectSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_RedialOnLinkFailure,
                ppbentry->fRedialOnLinkFailure )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_CallbackMode,
                ppbentry->dwCallbackMode )) != 0)
        {
            break;
        }

        if ((dwErr = InsertString(
                h, KEY_CustomDialDll,
                ppbentry->pszCustomDialDll )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_CustomDialFunc,
                ppbentry->pszCustomDialFunc )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_CustomDialerName,
                ppbentry->pszCustomDialerName)) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_AuthenticateServer,
                ppbentry->fAuthenticateServer )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_ShareMsFilePrint,
                ppbentry->fShareMsFilePrint )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_BindMsNetClient,
                ppbentry->fBindMsNetClient )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_SharedPhoneNumbers,
                ppbentry->fSharedPhoneNumbers )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_GlobalDeviceSettings,
                ppbentry->fGlobalDeviceSettings)) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_PrerequisiteEntry,
                ppbentry->pszPrerequisiteEntry )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_PrerequisitePbk,
                ppbentry->pszPrerequisitePbk )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_PreferredPort,
                ppbentry->pszPreferredPort )) != 0)
        {
            return dwErr;
        }
        
        if ((dwErr = InsertString(
                h, KEY_PreferredDevice,
                ppbentry->pszPreferredDevice )) != 0)
        {
            return dwErr;
        }

        //For XPSP1 664578, .Net 639551
        if ((dwErr = InsertLong(
                h, KEY_PreferredBps,
                ppbentry->dwPreferredBps)) != 0)
        {
            return dwErr;
        }
        
        if ((dwErr = InsertFlag(
                h, KEY_PreferredHwFlow,
                ppbentry->fPreferredHwFlow)) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_PreferredEc,
                ppbentry->fPreferredEc)) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_PreferredEcc,
                ppbentry->fPreferredEcc)) != 0)
        {
            return dwErr;
        }
        

        if ((dwErr = InsertLong(
                h, KEY_PreferredSpeaker,
                ppbentry->fPreferredSpeaker)) != 0)
        {
            return dwErr;
        }

        //For whistler bug 402522
        //
        if ((dwErr = InsertLong(
                h, KEY_PreferredModemProtocol,
                ppbentry->dwPreferredModemProtocol)) != 0)
        {
            return dwErr;
        }


        if ((dwErr = InsertFlag(
                h, KEY_PreviewUserPw,
                ppbentry->fPreviewUserPw )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_PreviewDomain,
                ppbentry->fPreviewDomain )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_PreviewPhoneNumber,
                ppbentry->fPreviewPhoneNumber )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_ShowDialingProgress,
                ppbentry->fShowDialingProgress )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_ShowMonitorIconInTaskBar,
                ppbentry->fShowMonitorIconInTaskBar )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_CustomAuthKey,
                ppbentry->dwCustomAuthKey )) != 0)
        {
            return dwErr;
        }

        if(ppbentry->pCustomAuthData)
        {
            if ((dwErr = InsertBinary(
                    h, KEY_CustomAuthData,
                    ppbentry->pCustomAuthData,
                    ppbentry->cbCustomAuthData )) != 0)
            {
                return dwErr;
            }
        }

        // Insert the IP addressing parameters for both PPP/SLIP.
        //
        if ((dwErr = InsertLong(
                h, KEY_AuthRestrictions,
                ppbentry->dwAuthRestrictions )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_TypicalAuth,
                ppbentry->dwTypicalAuth )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_IpPrioritizeRemote,
                ppbentry->fIpPrioritizeRemote )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_IpHeaderCompression,
                ppbentry->fIpHeaderCompression )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpAddress,
                (ppbentry->pszIpAddress)
                    ? ppbentry->pszIpAddress : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpDnsAddress,
                (ppbentry->pszIpDnsAddress)
                    ? ppbentry->pszIpDnsAddress : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpDns2Address,
                (ppbentry->pszIpDns2Address)
                    ? ppbentry->pszIpDns2Address : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpWinsAddress,
                (ppbentry->pszIpWinsAddress)
                    ? ppbentry->pszIpWinsAddress : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpWins2Address,
                (ppbentry->pszIpWins2Address)
                    ? ppbentry->pszIpWins2Address : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        // Next two actually used for PPP only.
        //
        if ((dwErr = InsertLong(
                h, KEY_IpAddressSource,
                ppbentry->dwIpAddressSource )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_IpNameSource,
                ppbentry->dwIpNameSource )) != 0)
        {
            return dwErr;
        }

        // Next one actually used for SLIP only.
        //
        if ((dwErr = InsertLong(
                h, KEY_IpFrameSize, ppbentry->dwFrameSize )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_IpDnsFlags, ppbentry->dwIpDnsFlags )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_IpNbtFlags, ppbentry->dwIpNbtFlags )) != 0)
        {
            return dwErr;
        }

        // Whistler bug 300933
        //
        if ((dwErr = InsertLong(
                h, KEY_TcpWindowSize, ppbentry->dwTcpWindowSize )) != 0)
        {
            return dwErr;
        }

        // Add the use flag
        //
        if ((dwErr = InsertLong(
                h, KEY_UseFlags,
                ppbentry->dwUseFlags )) != 0)
        {
            return dwErr;
        }

        // Add IpSec flags for whistler bug 193987 gangz
        //
        if ((dwErr = InsertLong(
                h, KEY_IpSecFlags,
                ppbentry->dwIpSecFlags )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpDnsSuffix,
                ppbentry->pszIpDnsSuffix)) != 0)
        {
            return dwErr;
        }

        // Insert the net components section.
        //
        InsertNetComponents( h, ppbentry->pdtllistNetComponents );

        // Append the MEDIA subsections.
        //
        for (pdtlnodeLink = DtlGetFirstNode( ppbentry->pdtllistLinks );
             pdtlnodeLink;
             pdtlnodeLink = DtlGetNextNode( pdtlnodeLink ))
        {
            PBLINK* ppblink;
            TCHAR* pszMedia;

            ppblink = (PBLINK* )DtlGetData( pdtlnodeLink );
            ASSERT( ppblink );
            pszMedia = ppblink->pbport.pszMedia;

            if ((dwErr = InsertGroup( h, GROUPKEY_Media, pszMedia )) != 0)
            {
                break;
            }

            if ((dwErr = InsertString(
                    h, KEY_Port, ppblink->pbport.pszPort )) != 0)
            {
                break;
            }

            if (ppblink->pbport.pszDevice)
            {
                if ((dwErr = InsertString(
                        h, KEY_Device, ppblink->pbport.pszDevice )) != 0)
                {
                    break;
                }
            }

            if ( (ppblink->pbport.pbdevicetype == PBDT_Modem) ||
                 (ppblink->pbport.dwFlags & PBP_F_NullModem)
               )
            {
                if ((dwErr = InsertLong(
                        h, KEY_InitBps, ppblink->dwBps )) != 0)
                {
                    break;
                }
            }

            // Append the device subsection lines.
            //
            RasfileFindLastLine( h, RFL_ANYACTIVE, RFS_GROUP );

            if ((dwErr = InsertDeviceList( pFile, h, ppbentry, ppblink )) != 0)
            {
                break;
            }

            ppbentry->fDirty = FALSE;
        }
    }

    return dwErr;
}


DWORD
ReadBinary(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT BYTE** ppResult,
    OUT DWORD* pcb )

    // Utility routine to read a string value from the next line in the scope
    // 'rfscope' with key 'pszKey'.  The result is placed in the allocated
    // '*ppszResult' buffer.  The current line is reset to the start of the
    // scope if the call was successful.
    //
    // Returns 0 if successful, or a non-zero error code.  "Not found" is
    // considered successful, in which case '*ppszResult' is not changed.
    // Caller is responsible for freeing the returned '*ppszResult' buffer.
    //
{
    DWORD cb;
    DWORD cbLine;
    CHAR  szValue[ RAS_MAXLINEBUFLEN + 1 ];
    CHAR* pch;
    BYTE* pResult;
    BYTE* pLineResult;

    pResult = pLineResult = NULL;
    cb = cbLine = 0;

    while (RasfileFindNextKeyLine( h, pszKey, rfscope ))
    {
        if (!RasfileGetKeyValueFields( h, NULL, szValue ))
        {
            Free0( pResult );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        cbLine = lstrlenA( szValue );
        if (cbLine & 1)
        {
            Free0( pResult );
            return ERROR_CORRUPT_PHONEBOOK;
        }
        cbLine /= 2;
        cb += cbLine;

        if (pResult)
        {
            pResult = Realloc( pResult, cb );
        }
        else
        {
            pResult = Malloc( cb );
        }

        if (!pResult)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pLineResult = pResult + (cb - cbLine);

        pch = szValue;
        while (*pch != '\0')
        {
            *pLineResult = HexValue( *pch++ ) * 16;
            *pLineResult += HexValue( *pch++ );
            ++pLineResult;
        }
    }

    *ppResult = pResult;
    *pcb = cb;
    return 0;
}


DWORD
ReadDeviceList(
    IN HRASFILE h,
    IN STRDUP_T_FROM_A_FUNC pStrDupTFromA,
    IN OUT PBENTRY* ppbentry,
    IN OUT PBLINK* ppblink,
    IN BOOL fUnconfiguredPort,
    IN BOOL* pfDisableSpeaker )

    // Reads all DEVICE subsections the section from the first subsection
    // following the current position in phonebook file 'h'.  Caller's
    // '*ppbentry' and '*ppblink' buffer is loaded with information extracted
    // from the subsections.  'FUnconfiguredPort' is true if the port for the
    // link was unconfigured.  In this case, data found/not-found by this
    // routine helps determine whether the link was an MXS modem link.
    // 'pfDisableSpeaker' is the address of the old speaker setting or NULL to
    // read it from the file.
    //
    // Returns 0 if successful, ERROR_CORRUPT_PHONEBOOK if any subsection
    // other than a DEVICE subsection is encountered, or another non-0 error
    // code indicating a fatal error.
    //
{
    INT i;
    DWORD dwErr;
    CHAR szValue[ RAS_MAXLINEBUFLEN + 1 ];
    BOOL fPreconnectFound = FALSE;
    BOOL fModemFound = FALSE;
    BOOL fPadFound = FALSE;
    BOOL fPostconnectFound = FALSE;
    BOOL fDirty = FALSE;

    // For each subsection...
    //
    while (RasfileFindNextLine( h, RFL_GROUP, RFS_SECTION ))
    {
        CHAR* pszLine;

        pszLine = (CHAR* )RasfileGetLine( h );
        if (IsMediaLine( pszLine ))
        {
            RasfileFindPrevLine( h, RFL_ANY, RFS_SECTION );
            break;
        }

        if (!IsDeviceLine( pszLine ))
        {
            return ERROR_CORRUPT_PHONEBOOK;
        }

        RasfileGetKeyValueFields( h, NULL, szValue );

        TRACE1( "Reading device group \"%s\"", szValue );

        if (lstrcmpiA( szValue, ISDN_TXT ) == 0)
        {
            // It's an ISDN device.
            //
            ppblink->pbport.pbdevicetype = PBDT_Isdn;

            if ((dwErr = ReadPhoneList( h, RFS_GROUP,
                    &ppblink->pdtllistPhones,
                    &fDirty )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadLong( h, RFS_GROUP,
                    KEY_LastSelectedPhone,
                    &ppblink->iLastSelectedPhone )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_PromoteAlternates,
                    &ppblink->fPromoteAlternates )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_TryNextAlternateOnFail,
                    &ppblink->fTryNextAlternateOnFail )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadLong( h, RFS_GROUP,
                    KEY_LineType, &ppblink->lLineType )) != 0)
            {
                return dwErr;
            }

            if (ppblink->lLineType < 0 || ppblink->lLineType > 2)
                ppblink->lLineType = 0;

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_Fallback, &ppblink->fFallback )) != 0)
            {
                return dwErr;
            }

            // Default is true if not found.  Default for new entry is false,
            // so must set this before reading the entry.
            //
            ppblink->fProprietaryIsdn = TRUE;
            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_ProprietaryIsdn, &ppblink->fProprietaryIsdn )) != 0)
            {
                return dwErr;
            }

            // If "Channels" is not found assume it's not proprietary.  This
            // covers a case that never shipped outside the NT group.
            //
            {
                LONG lChannels = -1;
                if ((dwErr = ReadLong( h, RFS_GROUP,
                        KEY_Channels, &lChannels )) != 0)
                {
                    return dwErr;
                }

                if (lChannels == -1)
                {
                    ppblink->fProprietaryIsdn = FALSE;
                }
                else
                {
                    ppblink->lChannels = lChannels;
                }
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_Compression, &ppblink->fCompression )) != 0)
            {
                return dwErr;
            }
        }
        else if (lstrcmpiA( szValue, X25_TXT ) == 0)
        {
            // It's a native X.25 device.
            //
            ppblink->pbport.pbdevicetype = PBDT_X25;

            if ((dwErr = ReadString( h, pStrDupTFromA, RFS_GROUP,
                    KEY_X25_Address, &ppbentry->pszX25Address )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, pStrDupTFromA, RFS_GROUP,
                    KEY_X25_UserData, &ppbentry->pszX25UserData )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, pStrDupTFromA, RFS_GROUP,
                    KEY_X25_Facilities, &ppbentry->pszX25Facilities )) != 0)
            {
                return dwErr;
            }
        }
        else if (lstrcmpiA( szValue, MXS_MODEM_TXT ) == 0)
        {
            // It's a MODEM device.
            //
            ppblink->pbport.pbdevicetype = PBDT_Modem;

            if ((dwErr = ReadPhoneList( h, RFS_GROUP,
                    &ppblink->pdtllistPhones,
                    &fDirty )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadLong( h, RFS_GROUP,
                    KEY_LastSelectedPhone,
                    &ppblink->iLastSelectedPhone )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_PromoteAlternates,
                    &ppblink->fPromoteAlternates )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_TryNextAlternateOnFail,
                    &ppblink->fTryNextAlternateOnFail )) != 0)
            {
                return dwErr;
            }

            {
                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_HwFlow, &ppblink->fHwFlow )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_Ec, &ppblink->fEc )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_Ecc, &ppblink->fEcc )) != 0)
                {
                    return dwErr;
                }

                if (pfDisableSpeaker)
                {
                    ppblink->fSpeaker = !*pfDisableSpeaker;
                }
                else
                {
                    if ((dwErr = ReadFlag( h, RFS_GROUP,
                            KEY_Speaker, &ppblink->fSpeaker )) != 0)
                    {
                        return dwErr;
                    }
                }
                if ((dwErr = ReadLong( h, RFS_GROUP,
                        KEY_MdmProtocol, &ppblink->dwModemProtocol )) != 0)
                {
                    return dwErr;
                }
            }

            fModemFound = TRUE;
        }
        else if (lstrcmpiA( szValue, MXS_SWITCH_TXT ) == 0)
        {
            // It's a SWITCH device.
            // Read switch type string.
            //
            TCHAR* pszSwitch = NULL;

            if ((dwErr = ReadString( h, pStrDupTFromA, RFS_GROUP,
                    KEY_Type, &pszSwitch )) != 0)
            {
                return dwErr;
            }

            if (pszSwitch)
            {
                // It's a pre-NT5 switch.
                //
                if (!fPreconnectFound && !fModemFound && !fPadFound)
                {
                    // It's the preconnect switch.
                    //
                    if (lstrcmpi( pszSwitch, TEXT(SM_TerminalText) ) == 0)
                    {
                        ppblink->pbport.fScriptBeforeTerminal = TRUE;
                        Free( pszSwitch );
                    }
                    else
                    {
                        ppblink->pbport.fScriptBefore = TRUE;
                        ppblink->pbport.pszScriptBefore = pszSwitch;
                    }

                    fPreconnectFound = TRUE;
                }
                else if (!fPostconnectFound)
                {
                    // It's the postconnect switch, i.e. a login script.
                    //
                    if (lstrcmpi( pszSwitch, TEXT(SM_TerminalText) ) == 0)
                    {
                        ppbentry->fScriptAfterTerminal = TRUE;
                        Free( pszSwitch );
                    }
                    else
                    {
                        ppbentry->fScriptAfter = TRUE;
                        ppbentry->pszScriptAfter = pszSwitch;
                    }

                    fPostconnectFound = TRUE;
                }
                else
                {
                    // It's a switch, but it's not in the normal pre- or post-
                    // connect positions.
                    //
                    ppbentry->fCustom = TRUE;
                    Free( pszSwitch );
                    return 0;
                }
            }
            else
            {
                BOOL fTerminal;
                BOOL fScript;
                TCHAR* pszName;

                // It's an NT5+ switch.
                //
                fTerminal = FALSE;
                fScript = FALSE;
                pszName = NULL;

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_Terminal, &fTerminal )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_Script, &fScript )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadLong(h, RFS_GROUP,
                            KEY_CustomScript, &ppbentry->dwCustomScript)))
                {
                    return dwErr;
                }
                          

                if ((dwErr = ReadString( h, pStrDupTFromA, RFS_GROUP,
                        KEY_Name, &pszName )) != 0)
                {
                    return dwErr;
                }

                if (!fPreconnectFound && !fModemFound && !fPadFound)
                {
                    // It's the preconnect switch.
                    //
                    ppblink->pbport.fScriptBeforeTerminal = fTerminal;
                    ppblink->pbport.fScriptBefore = fScript;
                    ppblink->pbport.pszScriptBefore = pszName;

                    fPreconnectFound = TRUE;
                }
                else if (!fPostconnectFound)
                {
                    // It's the postconnect switch, i.e. a login script.
                    //
                    ppbentry->fScriptAfterTerminal = fTerminal;
                    ppbentry->fScriptAfter = fScript;
                    ppbentry->pszScriptAfter = pszName;

                    fPostconnectFound = TRUE;
                }
                else
                {
                    // It's a switch, but it's not in the normal pre- or post-
                    // connect positions.
                    //
                    ppbentry->fCustom = TRUE;
                    return 0;
                }
            }
        }
        else if (lstrcmpiA( szValue, MXS_PAD_TXT ) == 0)
        {
            // It's an X.25 PAD device.
            //
            if (!fModemFound)
            {
                ppblink->pbport.pbdevicetype = PBDT_Pad;
            }

            if ((dwErr = ReadString( h, pStrDupTFromA, RFS_GROUP,
                    KEY_PAD_Type, &ppbentry->pszX25Network )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, pStrDupTFromA, RFS_GROUP,
                    KEY_PAD_Address, &ppbentry->pszX25Address )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, pStrDupTFromA, RFS_GROUP,
                    KEY_PAD_UserData, &ppbentry->pszX25UserData )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, pStrDupTFromA, RFS_GROUP,
                    KEY_PAD_Facilities, &ppbentry->pszX25Facilities )) != 0)
            {
                return dwErr;
            }

            fPadFound = TRUE;
        }
        else if (lstrcmpiA( szValue, MXS_NULL_TXT ) == 0)
        {
            // It's a null device.  Currently, there is no specific null
            // information stored.
            //
            ppblink->pbport.pbdevicetype = PBDT_Null;
        }
        else if ( (lstrcmpiA( szValue, S_WIN9XATM ) == 0) &&
                  (ppblink->pbport.pszDevice[ 0 ] == TEXT('\0')) )
        {
            // Whistler 326015 PBK: if ATM device name is NULL, we should seek
            // out a device name just like w/serial/ISDN
            //
            // This section was added to cover a Win9x migration problem. The
            // ATM device name is NULL'd during the upgrade because we have no
            // way to predict what the name will end up as. We will now use the
            // first ATM device name we get from RASMAN, if any.
            //
            ppblink->pbport.pbdevicetype = PBDT_Atm;

            // Read only the phone number strings and hunt flag.
            //
            if ((dwErr = ReadPhoneList( h, RFS_GROUP,
                    &ppblink->pdtllistPhones,
                    &fDirty )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadLong( h, RFS_GROUP,
                    KEY_LastSelectedPhone,
                    &ppblink->iLastSelectedPhone )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_PromoteAlternates,
                    &ppblink->fPromoteAlternates )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_TryNextAlternateOnFail,
                    &ppblink->fTryNextAlternateOnFail )) != 0)
            {
                return dwErr;
            }
        }
        else
        {
            BOOL fSame;
            CHAR* pszMedia;
            TCHAR *pszValue;

            pszMedia = StrDupAFromT( ppblink->pbport.pszMedia );
            if (!pszMedia)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            pszValue =  pStrDupTFromA(szValue);

            if(!pszValue)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            fSame = (lstrcmpiA( szValue, pszMedia ) == 0);

            Free( pszMedia );

            if (    (fSame)
                ||  (lstrcmpi(pszValue, TEXT("SERIAL")) == 0)
                ||  (lstrcmpi(pszValue, RASDT_Vpn) == 0)
                ||  (lstrcmpi(pszValue, RASDT_Generic) == 0)
                ||  (lstrcmpi(pszValue, RASDT_FrameRelay) == 0)
                ||  (lstrcmpi(pszValue, RASDT_Atm) == 0)
                ||  (lstrcmpi(pszValue, RASDT_Sonet) == 0)
                ||  (lstrcmpi(pszValue, RASDT_SW56) == 0)
                ||  (lstrcmpi(pszValue, RASDT_Irda) == 0)
                ||  (lstrcmpi(pszValue, RASDT_Parallel) == 0)
                ||  (lstrcmpi(pszValue, RASDT_PPPoE) == 0))
            {
                Free(pszValue);
                
                // It's an "other" device.
                //
                if(PBDT_None == ppblink->pbport.pbdevicetype)
                {
                    ppblink->pbport.pbdevicetype = PBDT_Other;
                }

                // Read only the phone number strings and hunt flag.
                //
                if ((dwErr = ReadPhoneList( h, RFS_GROUP,
                        &ppblink->pdtllistPhones,
                        &fDirty )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadLong( h, RFS_GROUP,
                        KEY_LastSelectedPhone,
                        &ppblink->iLastSelectedPhone )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_PromoteAlternates,
                        &ppblink->fPromoteAlternates )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_TryNextAlternateOnFail,
                        &ppblink->fTryNextAlternateOnFail )) != 0)
                {
                    return dwErr;
                }
            }
            else
            {
                Free(pszValue);
                
                // Device name doesn't match media so it's a custom type, i.e.
                // it wasn't created by us.
                //
                ppbentry->fCustom = TRUE;
            }
        }
    }

    if (ppblink->pbport.pbdevicetype == PBDT_None)
    {
        TRACE( "No device section" );
        return ERROR_CORRUPT_PHONEBOOK;
    }

    if (fDirty)
    {
        ppbentry->fDirty = TRUE;
    }

    return 0;
}

DWORD
ReadEntryList(
    IN OUT PBFILE* pFile,
    IN DWORD dwFlags,
    IN LPCTSTR pszSection)

    // Creates the entry list 'pFile->pdtllistEntries' from previously loaded
    // phonebook file 'pFile.hrasfile'.' 'FRouter' is true if router ports
    // should be used for comparison/conversion of devices, false otherwise.
    //
    // Returns 0 if successful, otherwise a non-0 error code.
    //
{
    DWORD dwErr = 0;
    BOOL fDirty = FALSE;
    DTLNODE* pdtlnodeEntry = NULL;
    DTLNODE* pdtlnodeLink = NULL;
    PBENTRY* ppbentry;
    PBLINK* ppblink;
    CHAR* szValue;
    BOOL fStatus;
    BOOL fFoundMedia;
    BOOL fSectionDeleted;
    BOOL fOldPhonebook;
    BOOL fDisableSwCompression;
    BOOL fDisableModemSpeaker;
    BOOL fRouter;
    HRASFILE h;
    DTLLIST* pdtllistPorts = NULL;
    DWORD dwfInstalledProtocols;
    DWORD dwEncoding;
    DWORD dwEntryType;
    STRDUP_T_FROM_A_FUNC pDupTFromA = StrDupTFromA;
    TCHAR* pszCurEntryName;
    BOOL fOldPhoneNumberParts;
    TCHAR* pszOldAreaCode;
    BOOL  fOldUseDialingRules;
    DWORD dwOldCountryID;
    DWORD dwOldCountryCode;
    DWORD dwDialUIDOffset;

    fOldPhoneNumberParts = FALSE;
    pszOldAreaCode = NULL;
    szValue = NULL;
    dwOldCountryID = 0;
    dwOldCountryCode = 0;
    dwDialUIDOffset = 0;

    // Make sure our assumption that ISDN phone number keys are equivalent to
    // modem phone number keys is correct.
    //
    ASSERT( lstrcmpiA( ISDN_PHONENUMBER_KEY, KEY_PhoneNumber ) == 0 );
    ASSERT( lstrcmpiA( MXS_PHONENUMBER_KEY, KEY_PhoneNumber ) == 0 );

    h = pFile->hrasfile;
    ASSERT( h != -1 );

    fRouter = !!(dwFlags & RPBF_Router);
    if ( fRouter )
    {
        //
        // if router bit is set, check for protocols to which RasRtr
        // or RasSrv is bound
        //
        dwfInstalledProtocols = GetInstalledProtocolsEx( NULL, TRUE, FALSE, TRUE );
    }
    else
    {
        //
        // get protocols to which Dial Up Client is bound
        //
        dwfInstalledProtocols = GetInstalledProtocolsEx( NULL, FALSE, TRUE, FALSE );
    }

    // Look up a couple flags in the old global section and, if found, apply
    // them to the new per-entry equivalents.  This will only find anything on
    // phonebook upgrade, since all ".XXX" sections are deleted later.
    //
    fOldPhonebook = FALSE;
    if (RasfileFindSectionLine( h, GLOBALSECTIONNAME, TRUE ))
    {
        fOldPhonebook = TRUE;

        fDisableModemSpeaker = FALSE;
        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_DisableModemSpeaker, &fDisableModemSpeaker )) != 0)
        {
            return dwErr;
        }

        fDisableSwCompression = FALSE;
        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_DisableSwCompression, &fDisableSwCompression )) != 0)
        {
            return dwErr;
        }

        TRACE2( "Old phonebook: dms=%d,dsc=%d",
            fDisableModemSpeaker, fDisableSwCompression );
    }

    if (!(pFile->pdtllistEntries = DtlCreateList( 0L )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // XP 339346
    //
    if (! (szValue = (CHAR*)Malloc( (RAS_MAXLINEBUFLEN + 1) * sizeof(CHAR))))
    {
        DtlDestroyList(pFile->pdtllistEntries, NULL);
        pFile->pdtllistEntries = NULL;
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // For each connectoid section in the file...
    //
    fSectionDeleted = FALSE;
    for (fStatus = RasfileFindFirstLine( h, RFL_SECTION, RFS_FILE );
         fStatus;
         fSectionDeleted
             || (fStatus = RasfileFindNextLine( h, RFL_SECTION, RFS_FILE )))
    {
        fSectionDeleted = FALSE;

        // Read the entry name (same as section name), skipping over any
        // sections beginning with dot.  These are reserved for special
        // purposes (like the old global section).
        //
        if (!RasfileGetSectionName( h, szValue ))
        {
            // Get here only when the last section in the file is deleted
            // within the loop.
            //
            break;
        }

        TRACE1( "ENTRY: Reading \"%s\"", szValue );

        if (szValue[ 0 ] == '.')
        {
            TRACE1( "Obsolete section %s deleted", szValue );
            DeleteCurrentSection( h );
            fSectionDeleted = TRUE;
            continue;
        }

        // Figure out if this entry was saved with ansi or
        // utf8 encoding
        //
        dwEncoding = EN_Ansi;
        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_Encoding, (LONG* )&dwEncoding )) != 0)
        {
            break;
        }

        // Read in the type
        //
        dwEntryType = RASET_Phone;
        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_Type, (LONG* )&dwEntryType )) != 0)
        {
            break;
        }

        if (dwEncoding == EN_Ansi)
        {
            // We need to write the entry out in UTF8 for localization
            // reasons, so mark it dirty since it has the wrong encoding.
            //
            pDupTFromA = StrDupTFromAUsingAnsiEncoding;
        }
        else
        {
            pDupTFromA = StrDupTFromA;
        }

        // Get the current entry name
        //
        pszCurEntryName = pDupTFromA( szValue );
        if (pszCurEntryName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Make sure this is the entry that the user requested
        //
        if (pszSection && lstrcmpi(pszCurEntryName, pszSection))
        {
            Free(pszCurEntryName);
            continue;
        }

        // Create the type of node requested in the flags
        //
        if (dwFlags & RPBF_HeadersOnly)
        {
            DtlPutListCode( pFile->pdtllistEntries, RPBF_HeadersOnly );
            pdtlnodeEntry = DtlCreateNode( pszCurEntryName, 0L );
            if (!pdtlnodeEntry )
            {
                Free( pszCurEntryName );
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            DtlAddNodeLast( pFile->pdtllistEntries, pdtlnodeEntry );

            continue;
        }
        else if (dwFlags & RPBF_HeaderType)
        {
            RASENTRYHEADER * preh;
        
            DtlPutListCode( pFile->pdtllistEntries, RPBF_HeaderType );
            pdtlnodeEntry = DtlCreateSizedNode(sizeof(RASENTRYHEADER), 0);
            if (!pdtlnodeEntry )
            {
                Free( pszCurEntryName );
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            preh = (RASENTRYHEADER *) DtlGetData(pdtlnodeEntry);
            lstrcpynW(
                preh->szEntryName, 
                pszCurEntryName,
                sizeof(preh->szEntryName) / sizeof(WCHAR));
            preh->dwEntryType = dwEntryType;
            Free( pszCurEntryName );

            DtlAddNodeLast( pFile->pdtllistEntries, pdtlnodeEntry );
            
            continue;
        }

        // If we reach this point, we know that all phonebook
        // info is being requested.
        //
        if (!(pdtlnodeEntry = CreateEntryNode( FALSE )))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        
        // Initialize the entry, name, and type
        //
        DtlAddNodeLast( pFile->pdtllistEntries, pdtlnodeEntry );
        ppbentry = (PBENTRY* )DtlGetData( pdtlnodeEntry );
        ppbentry->pszEntryName = pszCurEntryName;
        ppbentry->dwType = dwEntryType;

        // Change default on "upgrade" to "show domain field".  See bug 281673.
        //
        ppbentry->fPreviewDomain = TRUE;

        if ((fOldPhonebook) || (dwEncoding == EN_Ansi))
        {
            // Mark all entries dirty when upgrading old phonebooks because
            // they all need to have there DialParamUIDs written out.
            //
            fDirty = ppbentry->fDirty = TRUE;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_AutoLogon, &ppbentry->fAutoLogon )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_UseRasCredentials, &ppbentry->fUseRasCredentials )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_UID, (LONG* )&ppbentry->dwDialParamsUID )) != 0)
        {
            break;
        }

        {
            GUID* pGuid;
            DWORD cb;

            pGuid = NULL;
            if ((dwErr = ReadBinary( h, RFS_SECTION, KEY_Guid,
                    (BYTE** )&pGuid, &cb )) != 0)
            {
                break;
            }

            if (cb == sizeof(UUID))
            {
                Free0( ppbentry->pGuid );
                ppbentry->pGuid = pGuid;
            }
            else
            {
             